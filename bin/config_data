#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;
  
  # This module doesn't do much of anything itself, it inherits from the
  # modules that do the real work.  The only real thing it has to do is
  # figure out which OS-specific module to pull in.  Many of the
  # OS-specific modules don't do anything either - most of the work is
  # done in Module::Build::Base.
  
  use 5.006;
  use strict;
  use warnings;
  use File::Spec ();
  use File::Path ();
  use File::Basename ();
  use Perl::OSType ();
  
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  # Inserts the given module into the @ISA hierarchy between
  # Module::Build and its immediate parent
  sub _interpose_module {
    my ($self, $mod) = @_;
    eval "use $mod";
    die $@ if $@;
  
    no strict 'refs';
    my $top_class = $mod;
    while (@{"${top_class}::ISA"}) {
      last if ${"${top_class}::ISA"}[0] eq $ISA[0];
      $top_class = ${"${top_class}::ISA"}[0];
    }
  
    @{"${top_class}::ISA"} = @ISA;
    @ISA = ($mod);
  }
  
  if (grep {-e File::Spec->catfile($_, qw(Module Build Platform), $^O) . '.pm'} @INC) {
    __PACKAGE__->_interpose_module("Module::Build::Platform::$^O");
  
  } elsif ( my $ostype = os_type() ) {
    __PACKAGE__->_interpose_module("Module::Build::Platform::$ostype");
  
  } else {
    warn "Unknown OS type '$^O' - using default settings\n";
  }
  
  sub os_type { return Perl::OSType::os_type() }
  
  sub is_vmsish { return Perl::OSType::is_os_type('VMS') }
  sub is_windowsish { return Perl::OSType::is_os_type('Windows') }
  sub is_unixish { return Perl::OSType::is_os_type('Unix') }
  
  1;
  
  __END__
  
  =for :stopwords
  bindoc binhtml destdir distcheck distclean distdir distmeta distsign disttest
  fakeinstall html installdirs installsitebin installsitescript installvendorbin
  installvendorscript libdoc libhtml pardist ppd ppmdist realclean skipcheck
  testall testcover testdb testpod testpodcoverage versioninstall
  
  =head1 NAME
  
  Module::Build - Build and install Perl modules
  
  =head1 SYNOPSIS
  
  Standard process for building & installing modules:
  
    perl Build.PL
    ./Build
    ./Build test
    ./Build install
  
  Or, if you're on a platform (like DOS or Windows) that doesn't require
  the "./" notation, you can do this:
  
    perl Build.PL
    Build
    Build test
    Build install
  
  
  =head1 DESCRIPTION
  
  C<Module::Build> is a system for building, testing, and installing
  Perl modules.  It is meant to be an alternative to
  C<ExtUtils::MakeMaker>.  Developers may alter the behavior of the
  module through subclassing in a much more straightforward way than
  with C<MakeMaker>.  It also does not require a C<make> on your system
  - most of the C<Module::Build> code is pure-perl and written in a very
  cross-platform way.
  
  See L<"MOTIVATIONS"> for more comparisons between C<ExtUtils::MakeMaker>
  and C<Module::Build>.
  
  To install C<Module::Build>, and any other module that uses
  C<Module::Build> for its installation process, do the following:
  
    perl Build.PL       # 'Build.PL' script creates the 'Build' script
    ./Build             # Need ./ to ensure we're using this "Build" script
    ./Build test        # and not another one that happens to be in the PATH
    ./Build install
  
  This illustrates initial configuration and the running of three
  'actions'.  In this case the actions run are 'build' (the default
  action), 'test', and 'install'.  Other actions defined so far include:
  
    build                          manifest
    clean                          manifest_skip
    code                           manpages
    config_data                    pardist
    diff                           ppd
    dist                           ppmdist
    distcheck                      prereq_data
    distclean                      prereq_report
    distdir                        pure_install
    distinstall                    realclean
    distmeta                       retest
    distsign                       skipcheck
    disttest                       test
    docs                           testall
    fakeinstall                    testcover
    help                           testdb
    html                           testpod
    install                        testpodcoverage
    installdeps                    versioninstall
  
  You can run the 'help' action for a complete list of actions.
  
  
  =head1 GUIDE TO DOCUMENTATION
  
  The documentation for C<Module::Build> is broken up into sections:
  
  =over
  
  =item General Usage (L<Module::Build>)
  
  This is the document you are currently reading. It describes basic
  usage and background information.  Its main purpose is to assist the
  user who wants to learn how to invoke and control C<Module::Build>
  scripts at the command line.
  
  =item Authoring Reference (L<Module::Build::Authoring>)
  
  This document describes the structure and organization of
  C<Module::Build>, and the relevant concepts needed by authors who are
  writing F<Build.PL> scripts for a distribution or controlling
  C<Module::Build> processes programmatically.
  
  =item API Reference (L<Module::Build::API>)
  
  This is a reference to the C<Module::Build> API.
  
  =item Cookbook (L<Module::Build::Cookbook>)
  
  This document demonstrates how to accomplish many common tasks.  It
  covers general command line usage and authoring of F<Build.PL>
  scripts.  Includes working examples.
  
  =back
  
  
  =head1 ACTIONS
  
  There are some general principles at work here.  First, each task when
  building a module is called an "action".  These actions are listed
  above; they correspond to the building, testing, installing,
  packaging, etc., tasks.
  
  Second, arguments are processed in a very systematic way.  Arguments
  are always key=value pairs.  They may be specified at C<perl Build.PL>
  time (i.e. C<perl Build.PL destdir=/my/secret/place>), in which case
  their values last for the lifetime of the C<Build> script.  They may
  also be specified when executing a particular action (i.e.
  C<Build test verbose=1>), in which case their values last only for the
  lifetime of that command.  Per-action command line parameters take
  precedence over parameters specified at C<perl Build.PL> time.
  
  The build process also relies heavily on the C<Config.pm> module.
  If the user wishes to override any of the
  values in C<Config.pm>, she may specify them like so:
  
    perl Build.PL --config cc=gcc --config ld=gcc
  
  The following build actions are provided by default.
  
  =over 4
  
  =item build
  
  [version 0.01]
  
  If you run the C<Build> script without any arguments, it runs the
  C<build> action, which in turn runs the C<code> and C<docs> actions.
  
  This is analogous to the C<MakeMaker> I<make all> target.
  
  =item clean
  
  [version 0.01]
  
  This action will clean up any files that the build process may have
  created, including the C<blib/> directory (but not including the
  C<_build/> directory and the C<Build> script itself).
  
  =item code
  
  [version 0.20]
  
  This action builds your code base.
  
  By default it just creates a C<blib/> directory and copies any C<.pm>
  and C<.pod> files from your C<lib/> directory into the C<blib/>
  directory.  It also compiles any C<.xs> files from C<lib/> and places
  them in C<blib/>.  Of course, you need a working C compiler (probably
  the same one that built perl itself) for the compilation to work
  properly.
  
  The C<code> action also runs any C<.PL> files in your F<lib/>
  directory.  Typically these create other files, named the same but
  without the C<.PL> ending.  For example, a file F<lib/Foo/Bar.pm.PL>
  could create the file F<lib/Foo/Bar.pm>.  The C<.PL> files are
  processed first, so any C<.pm> files (or other kinds that we deal
  with) will get copied correctly.
  
  =item config_data
  
  [version 0.26]
  
  ...
  
  =item diff
  
  [version 0.14]
  
  This action will compare the files about to be installed with their
  installed counterparts.  For .pm and .pod files, a diff will be shown
  (this currently requires a 'diff' program to be in your PATH).  For
  other files like compiled binary files, we simply report whether they
  differ.
  
  A C<flags> parameter may be passed to the action, which will be passed
  to the 'diff' program.  Consult your 'diff' documentation for the
  parameters it will accept - a good one is C<-u>:
  
    ./Build diff flags=-u
  
  =item dist
  
  [version 0.02]
  
  This action is helpful for module authors who want to package up their
  module for source distribution through a medium like CPAN.  It will create a
  tarball of the files listed in F<MANIFEST> and compress the tarball using
  GZIP compression.
  
  By default, this action will use the C<Archive::Tar> module. However, you can
  force it to use binary "tar" and "gzip" executables by supplying an explicit
  C<tar> (and optional C<gzip>) parameter:
  
    ./Build dist --tar C:\path\to\tar.exe --gzip C:\path\to\zip.exe
  
  =item distcheck
  
  [version 0.05]
  
  Reports which files are in the build directory but not in the
  F<MANIFEST> file, and vice versa.  (See L<manifest> for details.)
  
  =item distclean
  
  [version 0.05]
  
  Performs the 'realclean' action and then the 'distcheck' action.
  
  =item distdir
  
  [version 0.05]
  
  Creates a "distribution directory" named C<$dist_name-$dist_version>
  (if that directory already exists, it will be removed first), then
  copies all the files listed in the F<MANIFEST> file to that directory.
  This directory is what the distribution tarball is created from.
  
  =item distinstall
  
  [version 0.37]
  
  Performs the 'distdir' action, then switches into that directory and runs a
  C<perl Build.PL>, followed by the 'build' and 'install' actions in that
  directory.  Use PERL_MB_OPT or F<.modulebuildrc> to set options that should be
  applied during subprocesses
  
  =item distmeta
  
  [version 0.21]
  
  Creates the F<META.yml> file that describes the distribution.
  
  F<META.yml> is a file containing various bits of I<metadata> about the
  distribution.  The metadata includes the distribution name, version,
  abstract, prerequisites, license, and various other data about the
  distribution.  This file is created as F<META.yml> in a simplified YAML format.
  
  F<META.yml> file must also be listed in F<MANIFEST> - if it's not, a
  warning will be issued.
  
  The current version of the F<META.yml> specification can be found
  on CPAN as L<CPAN::Meta::Spec>.
  
  =item distsign
  
  [version 0.16]
  
  Uses C<Module::Signature> to create a SIGNATURE file for your
  distribution, and adds the SIGNATURE file to the distribution's
  MANIFEST.
  
  =item disttest
  
  [version 0.05]
  
  Performs the 'distdir' action, then switches into that directory and runs a
  C<perl Build.PL>, followed by the 'build' and 'test' actions in that directory.
  Use PERL_MB_OPT or F<.modulebuildrc> to set options that should be applied
  during subprocesses
  
  
  =item docs
  
  [version 0.20]
  
  This will generate documentation (e.g. Unix man pages and HTML
  documents) for any installable items under B<blib/> that
  contain POD.  If there are no C<bindoc> or C<libdoc> installation
  targets defined (as will be the case on systems that don't support
  Unix manpages) no action is taken for manpages.  If there are no
  C<binhtml> or C<libhtml> installation targets defined no action is
  taken for HTML documents.
  
  =item fakeinstall
  
  [version 0.02]
  
  This is just like the C<install> action, but it won't actually do
  anything, it will just report what it I<would> have done if you had
  actually run the C<install> action.
  
  =item help
  
  [version 0.03]
  
  This action will simply print out a message that is meant to help you
  use the build process.  It will show you a list of available build
  actions too.
  
  With an optional argument specifying an action name (e.g. C<Build help
  test>), the 'help' action will show you any POD documentation it can
  find for that action.
  
  =item html
  
  [version 0.26]
  
  This will generate HTML documentation for any binary or library files
  under B<blib/> that contain POD.  The HTML documentation will only be
  installed if the install paths can be determined from values in
  C<Config.pm>.  You can also supply or override install paths on the
  command line by specifying C<install_path> values for the C<binhtml>
  and/or C<libhtml> installation targets.
  
  With an optional C<html_links> argument set to a false value, you can
  skip the search for other documentation to link to, because that can
  waste a lot of time if there aren't any links to generate anyway:
  
    ./Build html --html_links 0
  
  =item install
  
  [version 0.01]
  
  This action will use C<ExtUtils::Install> to install the files from
  C<blib/> into the system.  See L<"INSTALL PATHS">
  for details about how Module::Build determines where to install
  things, and how to influence this process.
  
  If you want the installation process to look around in C<@INC> for
  other versions of the stuff you're installing and try to delete it,
  you can use the C<uninst> parameter, which tells C<ExtUtils::Install> to
  do so:
  
    ./Build install uninst=1
  
  This can be a good idea, as it helps prevent multiple versions of a
  module from being present on your system, which can be a confusing
  situation indeed.
  
  =item installdeps
  
  [version 0.36]
  
  This action will use the C<cpan_client> parameter as a command to install
  missing prerequisites.  You will be prompted whether to install
  optional dependencies.
  
  The C<cpan_client> option defaults to 'cpan' but can be set as an option or in
  F<.modulebuildrc>.  It must be a shell command that takes a list of modules to
  install as arguments (e.g. 'cpanp -i' for CPANPLUS).  If the program part is a
  relative path (e.g. 'cpan' or 'cpanp'), it will be located relative to the perl
  program that executed Build.PL.
  
    /opt/perl/5.8.9/bin/perl Build.PL
    ./Build installdeps --cpan_client 'cpanp -i'
    # installs to 5.8.9
  
  =item manifest
  
  [version 0.05]
  
  This is an action intended for use by module authors, not people
  installing modules.  It will bring the F<MANIFEST> up to date with the
  files currently present in the distribution.  You may use a
  F<MANIFEST.SKIP> file to exclude certain files or directories from
  inclusion in the F<MANIFEST>.  F<MANIFEST.SKIP> should contain a bunch
  of regular expressions, one per line.  If a file in the distribution
  directory matches any of the regular expressions, it won't be included
  in the F<MANIFEST>.
  
  The following is a reasonable F<MANIFEST.SKIP> starting point, you can
  add your own stuff to it:
  
    ^_build
    ^Build$
    ^blib
    ~$
    \.bak$
    ^MANIFEST\.SKIP$
    CVS
  
  See the L<distcheck> and L<skipcheck> actions if you want to find out
  what the C<manifest> action would do, without actually doing anything.
  
  =item manifest_skip
  
  [version 0.3608]
  
  This is an action intended for use by module authors, not people
  installing modules.  It will generate a boilerplate MANIFEST.SKIP file
  if one does not already exist.
  
  =item manpages
  
  [version 0.28]
  
  This will generate man pages for any binary or library files under
  B<blib/> that contain POD.  The man pages will only be installed if the
  install paths can be determined from values in C<Config.pm>.  You can
  also supply or override install paths by specifying there values on
  the command line with the C<bindoc> and C<libdoc> installation
  targets.
  
  =item pardist
  
  [version 0.2806]
  
  Generates a PAR binary distribution for use with L<PAR> or L<PAR::Dist>.
  
  It requires that the PAR::Dist module (version 0.17 and up) is
  installed on your system.
  
  =item ppd
  
  [version 0.20]
  
  Build a PPD file for your distribution.
  
  This action takes an optional argument C<codebase> which is used in
  the generated PPD file to specify the (usually relative) URL of the
  distribution.  By default, this value is the distribution name without
  any path information.
  
  Example:
  
    ./Build ppd --codebase "MSWin32-x86-multi-thread/Module-Build-0.21.tar.gz"
  
  =item ppmdist
  
  [version 0.23]
  
  Generates a PPM binary distribution and a PPD description file.  This
  action also invokes the C<ppd> action, so it can accept the same
  C<codebase> argument described under that action.
  
  This uses the same mechanism as the C<dist> action to tar & zip its
  output, so you can supply C<tar> and/or C<gzip> parameters to affect
  the result.
  
  =item prereq_data
  
  [version 0.32]
  
  This action prints out a Perl data structure of all prerequisites and the versions
  required.  The output can be loaded again using C<eval()>.  This can be useful for
  external tools that wish to query a Build script for prerequisites.
  
  =item prereq_report
  
  [version 0.28]
  
  This action prints out a list of all prerequisites, the versions required, and
  the versions actually installed.  This can be useful for reviewing the
  configuration of your system prior to a build, or when compiling data to send
  for a bug report.
  
  =item pure_install
  
  [version 0.28]
  
  This action is identical to the C<install> action.  In the future,
  though, when C<install> starts writing to the file
  F<$(INSTALLARCHLIB)/perllocal.pod>, C<pure_install> won't, and that
  will be the only difference between them.
  
  =item realclean
  
  [version 0.01]
  
  This action is just like the C<clean> action, but also removes the
  C<_build> directory and the C<Build> script.  If you run the
  C<realclean> action, you are essentially starting over, so you will
  have to re-create the C<Build> script again.
  
  =item retest
  
  [version 0.2806]
  
  This is just like the C<test> action, but doesn't actually build the
  distribution first, and doesn't add F<blib/> to the load path, and
  therefore will test against a I<previously> installed version of the
  distribution.  This can be used to verify that a certain installed
  distribution still works, or to see whether newer versions of a
  distribution still pass the old regression tests, and so on.
  
  =item skipcheck
  
  [version 0.05]
  
  Reports which files are skipped due to the entries in the
  F<MANIFEST.SKIP> file (See L<manifest> for details)
  
  =item test
  
  [version 0.01]
  
  This will use C<Test::Harness> or C<TAP::Harness> to run any regression
  tests and report their results. Tests can be defined in the standard
  places: a file called C<test.pl> in the top-level directory, or several
  files ending with C<.t> in a C<t/> directory.
  
  If you want tests to be 'verbose', i.e. show details of test execution
  rather than just summary information, pass the argument C<verbose=1>.
  
  If you want to run tests under the perl debugger, pass the argument
  C<debugger=1>.
  
  If you want to have Module::Build find test files with different file
  name extensions, pass the C<test_file_exts> argument with an array
  of extensions, such as C<[qw( .t .s .z )]>.
  
  If you want test to be run by C<TAP::Harness>, rather than C<Test::Harness>,
  pass the argument C<tap_harness_args> as an array reference of arguments to
  pass to the TAP::Harness constructor.
  
  In addition, if a file called C<visual.pl> exists in the top-level
  directory, this file will be executed as a Perl script and its output
  will be shown to the user.  This is a good place to put speed tests or
  other tests that don't use the C<Test::Harness> format for output.
  
  To override the choice of tests to run, you may pass a C<test_files>
  argument whose value is a whitespace-separated list of test scripts to
  run.  This is especially useful in development, when you only want to
  run a single test to see whether you've squashed a certain bug yet:
  
    ./Build test --test_files t/something_failing.t
  
  You may also pass several C<test_files> arguments separately:
  
    ./Build test --test_files t/one.t --test_files t/two.t
  
  or use a C<glob()>-style pattern:
  
    ./Build test --test_files 't/01-*.t'
  
  =item testall
  
  [version 0.2807]
  
  [Note: the 'testall' action and the code snippets below are currently
  in alpha stage, see
  L<"http://www.nntp.perl.org/group/perl.module.build/2007/03/msg584.html"> ]
  
  Runs the C<test> action plus each of the C<test$type> actions defined by
  the keys of the C<test_types> parameter.
  
  Currently, you need to define the ACTION_test$type method yourself and
  enumerate them in the test_types parameter.
  
    my $mb = Module::Build->subclass(
      code => q(
        sub ACTION_testspecial { shift->generic_test(type => 'special'); }
        sub ACTION_testauthor  { shift->generic_test(type => 'author'); }
      )
    )->new(
      ...
      test_types  => {
        special => '.st',
        author  => ['.at', '.pt' ],
      },
      ...
  
  =item testcover
  
  [version 0.26]
  
  Runs the C<test> action using C<Devel::Cover>, generating a
  code-coverage report showing which parts of the code were actually
  exercised during the tests.
  
  To pass options to C<Devel::Cover>, set the C<$DEVEL_COVER_OPTIONS>
  environment variable:
  
    DEVEL_COVER_OPTIONS=-ignore,Build ./Build testcover
  
  =item testdb
  
  [version 0.05]
  
  This is a synonym for the 'test' action with the C<debugger=1>
  argument.
  
  =item testpod
  
  [version 0.25]
  
  This checks all the files described in the C<docs> action and
  produces C<Test::Harness>-style output.  If you are a module author,
  this is useful to run before creating a new release.
  
  =item testpodcoverage
  
  [version 0.28]
  
  This checks the pod coverage of the distribution and
  produces C<Test::Harness>-style output. If you are a module author,
  this is useful to run before creating a new release.
  
  =item versioninstall
  
  [version 0.16]
  
  ** Note: since C<only.pm> is so new, and since we just recently added
  support for it here too, this feature is to be considered
  experimental. **
  
  If you have the C<only.pm> module installed on your system, you can
  use this action to install a module into the version-specific library
  trees.  This means that you can have several versions of the same
  module installed and C<use> a specific one like this:
  
    use only MyModule => 0.55;
  
  To override the default installation libraries in C<only::config>,
  specify the C<versionlib> parameter when you run the C<Build.PL> script:
  
    perl Build.PL --versionlib /my/version/place/
  
  To override which version the module is installed as, specify the
  C<version> parameter when you run the C<Build.PL> script:
  
    perl Build.PL --version 0.50
  
  See the C<only.pm> documentation for more information on
  version-specific installs.
  
  =back
  
  
  =head1 OPTIONS
  
  =head2 Command Line Options
  
  The following options can be used during any invocation of C<Build.PL>
  or the Build script, during any action.  For information on other
  options specific to an action, see the documentation for the
  respective action.
  
  NOTE: There is some preliminary support for options to use the more
  familiar long option style.  Most options can be preceded with the
  C<--> long option prefix, and the underscores changed to dashes
  (e.g. C<--use-rcfile>).  Additionally, the argument to boolean options is
  optional, and boolean options can be negated by prefixing them with
  C<no> or C<no-> (e.g. C<--noverbose> or C<--no-verbose>).
  
  =over 4
  
  =item quiet
  
  Suppress informative messages on output.
  
  =item verbose
  
  Display extra information about the Build on output.  C<verbose> will
  turn off C<quiet>
  
  =item cpan_client
  
  Sets the C<cpan_client> command for use with the C<installdeps> action.
  See C<installdeps> for more details.
  
  =item use_rcfile
  
  Load the F<~/.modulebuildrc> option file.  This option can be set to
  false to prevent the custom resource file from being loaded.
  
  =item allow_mb_mismatch
  
  Suppresses the check upon startup that the version of Module::Build
  we're now running under is the same version that was initially invoked
  when building the distribution (i.e. when the C<Build.PL> script was
  first run).  As of 0.3601, a mismatch results in a warning instead of
  a fatal error, so this option effectively just suppresses the warning.
  
  =item debug
  
  Prints Module::Build debugging information to STDOUT, such as a trace of
  executed build actions.
  
  =back
  
  =head2 Default Options File (F<.modulebuildrc>)
  
  [version 0.28]
  
  When Module::Build starts up, it will look first for a file,
  F<$ENV{HOME}/.modulebuildrc>.  If it's not found there, it will look
  in the F<.modulebuildrc> file in the directories referred to by
  the environment variables C<HOMEDRIVE> + C<HOMEDIR>, C<USERPROFILE>,
  C<APPDATA>, C<WINDIR>, C<SYS$LOGIN>.  If the file exists, the options
  specified there will be used as defaults, as if they were typed on the
  command line.  The defaults can be overridden by specifying new values
  on the command line.
  
  The action name must come at the beginning of the line, followed by any
  amount of whitespace and then the options.  Options are given the same
  as they would be on the command line.  They can be separated by any
  amount of whitespace, including newlines, as long there is whitespace at
  the beginning of each continued line.  Anything following a hash mark (C<#>)
  is considered a comment, and is stripped before parsing.  If more than
  one line begins with the same action name, those lines are merged into
  one set of options.
  
  Besides the regular actions, there are two special pseudo-actions: the
  key C<*> (asterisk) denotes any global options that should be applied
  to all actions, and the key 'Build_PL' specifies options to be applied
  when you invoke C<perl Build.PL>.
  
    *           verbose=1   # global options
    diff        flags=-u
    install     --install_base /home/ken
                --install_path html=/home/ken/docs/html
    installdeps --cpan_client 'cpanp -i'
  
  If you wish to locate your resource file in a different location, you
  can set the environment variable C<MODULEBUILDRC> to the complete
  absolute path of the file containing your options.
  
  =head2 Environment variables
  
  =over
  
  =item MODULEBUILDRC
  
  [version 0.28]
  
  Specifies an alternate location for a default options file as described above.
  
  =item PERL_MB_OPT
  
  [version 0.36]
  
  Command line options that are applied to Build.PL or any Build action.  The
  string is split as the shell would (e.g. whitespace) and the result is
  prepended to any actual command-line arguments.
  
  =back
  
  =head1 INSTALL PATHS
  
  [version 0.19]
  
  When you invoke Module::Build's C<build> action, it needs to figure
  out where to install things.  The nutshell version of how this works
  is that default installation locations are determined from
  F<Config.pm>, and they may be overridden by using the C<install_path>
  parameter.  An C<install_base> parameter lets you specify an
  alternative installation root like F</home/foo>, and a C<destdir> lets
  you specify a temporary installation directory like F</tmp/install> in
  case you want to create bundled-up installable packages.
  
  Natively, Module::Build provides default installation locations for
  the following types of installable items:
  
  =over 4
  
  =item lib
  
  Usually pure-Perl module files ending in F<.pm>.
  
  =item arch
  
  "Architecture-dependent" module files, usually produced by compiling
  XS, L<Inline>, or similar code.
  
  =item script
  
  Programs written in pure Perl.  In order to improve reuse, try to make
  these as small as possible - put the code into modules whenever
  possible.
  
  =item bin
  
  "Architecture-dependent" executable programs, i.e. compiled C code or
  something.  Pretty rare to see this in a perl distribution, but it
  happens.
  
  =item bindoc
  
  Documentation for the stuff in C<script> and C<bin>.  Usually
  generated from the POD in those files.  Under Unix, these are manual
  pages belonging to the 'man1' category.
  
  =item libdoc
  
  Documentation for the stuff in C<lib> and C<arch>.  This is usually
  generated from the POD in F<.pm> files.  Under Unix, these are manual
  pages belonging to the 'man3' category.
  
  =item binhtml
  
  This is the same as C<bindoc> above, but applies to HTML documents.
  
  =item libhtml
  
  This is the same as C<libdoc> above, but applies to HTML documents.
  
  =back
  
  Four other parameters let you control various aspects of how
  installation paths are determined:
  
  =over 4
  
  =item installdirs
  
  The default destinations for these installable things come from
  entries in your system's C<Config.pm>.  You can select from three
  different sets of default locations by setting the C<installdirs>
  parameter as follows:
  
                            'installdirs' set to:
                     core          site                vendor
  
                uses the following defaults from Config.pm:
  
    lib     => installprivlib  installsitelib      installvendorlib
    arch    => installarchlib  installsitearch     installvendorarch
    script  => installscript   installsitescript   installvendorscript
    bin     => installbin      installsitebin      installvendorbin
    bindoc  => installman1dir  installsiteman1dir  installvendorman1dir
    libdoc  => installman3dir  installsiteman3dir  installvendorman3dir
    binhtml => installhtml1dir installsitehtml1dir installvendorhtml1dir [*]
    libhtml => installhtml3dir installsitehtml3dir installvendorhtml3dir [*]
  
    * Under some OS (eg. MSWin32) the destination for HTML documents is
      determined by the C<Config.pm> entry C<installhtmldir>.
  
  The default value of C<installdirs> is "site".  If you're creating
  vendor distributions of module packages, you may want to do something
  like this:
  
    perl Build.PL --installdirs vendor
  
  or
  
    ./Build install --installdirs vendor
  
  If you're installing an updated version of a module that was included
  with perl itself (i.e. a "core module"), then you may set
  C<installdirs> to "core" to overwrite the module in its present
  location.
  
  (Note that the 'script' line is different from C<MakeMaker> -
  unfortunately there's no such thing as "installsitescript" or
  "installvendorscript" entry in C<Config.pm>, so we use the
  "installsitebin" and "installvendorbin" entries to at least get the
  general location right.  In the future, if C<Config.pm> adds some more
  appropriate entries, we'll start using those.)
  
  =item install_path
  
  Once the defaults have been set, you can override them.
  
  On the command line, that would look like this:
  
    perl Build.PL --install_path lib=/foo/lib --install_path arch=/foo/lib/arch
  
  or this:
  
    ./Build install --install_path lib=/foo/lib --install_path arch=/foo/lib/arch
  
  =item install_base
  
  You can also set the whole bunch of installation paths by supplying the
  C<install_base> parameter to point to a directory on your system.  For
  instance, if you set C<install_base> to "/home/ken" on a Linux
  system, you'll install as follows:
  
    lib     => /home/ken/lib/perl5
    arch    => /home/ken/lib/perl5/i386-linux
    script  => /home/ken/bin
    bin     => /home/ken/bin
    bindoc  => /home/ken/man/man1
    libdoc  => /home/ken/man/man3
    binhtml => /home/ken/html
    libhtml => /home/ken/html
  
  Note that this is I<different> from how C<MakeMaker>'s C<PREFIX>
  parameter works.  C<install_base> just gives you a default layout under the
  directory you specify, which may have little to do with the
  C<installdirs=site> layout.
  
  The exact layout under the directory you specify may vary by system -
  we try to do the "sensible" thing on each platform.
  
  =item destdir
  
  If you want to install everything into a temporary directory first
  (for instance, if you want to create a directory tree that a package
  manager like C<rpm> or C<dpkg> could create a package from), you can
  use the C<destdir> parameter:
  
    perl Build.PL --destdir /tmp/foo
  
  or
  
    ./Build install --destdir /tmp/foo
  
  This will effectively install to "/tmp/foo/$sitelib",
  "/tmp/foo/$sitearch", and the like, except that it will use
  C<File::Spec> to make the pathnames work correctly on whatever
  platform you're installing on.
  
  =item prefix
  
  Provided for compatibility with C<ExtUtils::MakeMaker>'s PREFIX argument.
  C<prefix> should be used when you want Module::Build to install your
  modules, documentation, and scripts in the same place as
  C<ExtUtils::MakeMaker>'s PREFIX mechanism.
  
  The following are equivalent.
  
      perl Build.PL --prefix /tmp/foo
      perl Makefile.PL PREFIX=/tmp/foo
  
  Because of the complex nature of the prefixification logic, the
  behavior of PREFIX in C<MakeMaker> has changed subtly over time.
  Module::Build's --prefix logic is equivalent to the PREFIX logic found
  in C<ExtUtils::MakeMaker> 6.30.
  
  The maintainers of C<MakeMaker> do understand the troubles with the
  PREFIX mechanism, and added INSTALL_BASE support in version 6.31 of
  C<MakeMaker>, which was released in 2006.
  
  If you don't need to retain compatibility with old versions (pre-6.31) of C<ExtUtils::MakeMaker> or
  are starting a fresh Perl installation we recommend you use
  C<install_base> instead (and C<INSTALL_BASE> in C<ExtUtils::MakeMaker>).
  See L<Module::Build::Cookbook/Installing in the same location as
  ExtUtils::MakeMaker> for further information.
  
  
  =back
  
  
  =head1 MOTIVATIONS
  
  There are several reasons I wanted to start over, and not just fix
  what I didn't like about C<MakeMaker>:
  
  =over 4
  
  =item *
  
  I don't like the core idea of C<MakeMaker>, namely that C<make> should be
  involved in the build process.  Here are my reasons:
  
  =over 4
  
  =item +
  
  When a person is installing a Perl module, what can you assume about
  their environment?  Can you assume they have C<make>?  No, but you can
  assume they have some version of Perl.
  
  =item +
  
  When a person is writing a Perl module for intended distribution, can
  you assume that they know how to build a Makefile, so they can
  customize their build process?  No, but you can assume they know Perl,
  and could customize that way.
  
  =back
  
  For years, these things have been a barrier to people getting the
  build/install process to do what they want.
  
  =item *
  
  There are several architectural decisions in C<MakeMaker> that make it
  very difficult to customize its behavior.  For instance, when using
  C<MakeMaker> you do C<use ExtUtils::MakeMaker>, but the object created in
  C<WriteMakefile()> is actually blessed into a package name that's
  created on the fly, so you can't simply subclass
  C<ExtUtils::MakeMaker>.  There is a workaround C<MY> package that lets
  you override certain C<MakeMaker> methods, but only certain explicitly
  preselected (by C<MakeMaker>) methods can be overridden.  Also, the method
  of customization is very crude: you have to modify a string containing
  the Makefile text for the particular target.  Since these strings
  aren't documented, and I<can't> be documented (they take on different
  values depending on the platform, version of perl, version of
  C<MakeMaker>, etc.), you have no guarantee that your modifications will
  work on someone else's machine or after an upgrade of C<MakeMaker> or
  perl.
  
  =item *
  
  It is risky to make major changes to C<MakeMaker>, since it does so many
  things, is so important, and generally works.  C<Module::Build> is an
  entirely separate package so that I can work on it all I want, without
  worrying about backward compatibility with C<MakeMaker>.
  
  =item *
  
  Finally, Perl is said to be a language for system administration.
  Could it really be the case that Perl isn't up to the task of building
  and installing software?  Even if that software is a bunch of
  C<.pm> files that just need to be copied from one place to
  another?  My sense was that we could design a system to accomplish
  this in a flexible, extensible, and friendly manner.  Or die trying.
  
  =back
  
  
  =head1 TO DO
  
  The current method of relying on time stamps to determine whether a
  derived file is out of date isn't likely to scale well, since it
  requires tracing all dependencies backward, it runs into problems on
  NFS, and it's just generally flimsy.  It would be better to use an MD5
  signature or the like, if available.  See C<cons> for an example.
  
   - append to perllocal.pod
   - add a 'plugin' functionality
  
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  Development questions, bug reports, and patches should be sent to the
  Module-Build mailing list at <module-build@perl.org>.
  
  Bug reports are also welcome at
  <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build>.
  
  The latest development version is available from the Git
  repository at <https://github.com/Perl-Toolchain-Gang/Module-Build>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  perl(1), L<Module::Build::Cookbook>, L<Module::Build::Authoring>,
  L<Module::Build::API>, L<ExtUtils::MakeMaker>
  
  F<META.yml> Specification:
  L<CPAN::Meta::Spec>
  
  L<http://www.dsmit.com/cons/>
  
  L<http://search.cpan.org/dist/PerlBuildSystem/>
  
  =cut
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2
  package Module::Build::Base;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  use Carp;
  use Cwd ();
  use File::Copy ();
  use File::Find ();
  use File::Path ();
  use File::Basename ();
  use File::Spec 0.82 ();
  use File::Compare ();
  use Module::Build::Dumper ();
  use Text::ParseWords ();
  
  use Module::Metadata;
  use Module::Build::Notes;
  use Module::Build::Config;
  use version;
  
  
  #################### Constructors ###########################
  sub new {
    my $self = shift()->_construct(@_);
  
    $self->{invoked_action} = $self->{action} ||= 'Build_PL';
    $self->cull_args(@ARGV);
  
    die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n"
      if $self->{action} && $self->{action} ne 'Build_PL';
  
    $self->check_manifest;
    $self->auto_require;
  
    # All checks must run regardless if one fails, so no short circuiting!
    if( grep { !$_ } $self->check_prereq, $self->check_autofeatures ) {
      $self->log_warn(<<EOF);
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
      unless (
        $self->dist_name eq 'Module-Build' ||
        $ENV{PERL5_CPANPLUS_IS_RUNNING} || $ENV{PERL5_CPAN_IS_RUNNING}
      ) {
        $self->log_warn(
          "Run 'Build installdeps' to install missing prerequisites.\n\n"
        );
      }
    }
  
    # record for later use in resume;
    $self->{properties}{_added_to_INC} = [ $self->_added_to_INC ];
  
    $self->set_bundle_inc;
  
    $self->dist_name;
    $self->dist_version;
    $self->release_status;
    $self->_guess_module_name unless $self->module_name;
  
    $self->_find_nested_builds;
  
    return $self;
  }
  
  sub resume {
    my $package = shift;
    my $self = $package->_construct(@_);
    $self->read_config;
  
    my @added_earlier = @{ $self->{properties}{_added_to_INC} || [] };
  
    @INC = ($self->_added_to_INC, @added_earlier, $self->_default_INC);
  
    # If someone called Module::Build->current() or
    # Module::Build->new_from_context() and the correct class to use is
    # actually a *subclass* of Module::Build, we may need to load that
    # subclass here and re-delegate the resume() method to it.
    unless ( $package->isa($self->build_class) ) {
      my $build_class = $self->build_class;
      my $config_dir = $self->config_dir || '_build';
      my $build_lib = File::Spec->catdir( $config_dir, 'lib' );
      unshift( @INC, $build_lib );
      unless ( $build_class->can('new') ) {
        eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@";
      }
      return $build_class->resume(@_);
    }
  
    unless ($self->_perl_is_same($self->{properties}{perl})) {
      my $perl = $self->find_perl_interpreter;
      die(<<"DIEFATAL");
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
    }
  
    $self->cull_args(@ARGV);
  
    unless ($self->allow_mb_mismatch) {
      my $mb_version = $Module::Build::VERSION;
      if ( $mb_version ne $self->{properties}{mb_version} ) {
        $self->log_warn(<<"MISMATCH");
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
      }
    }
  
    $self->{invoked_action} = $self->{action} ||= 'build';
  
    return $self;
  }
  
  sub new_from_context {
    my ($package, %args) = @_;
  
    $package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);
    return $package->resume;
  }
  
  sub current {
    # hmm, wonder what the right thing to do here is
    local @ARGV;
    return shift()->resume;
  }
  
  sub _construct {
    my ($package, %input) = @_;
  
    my $args   = delete $input{args}   || {};
    my $config = delete $input{config} || {};
  
    my $self = bless {
        args => {%$args},
        config => Module::Build::Config->new(values => $config),
        properties => {
            base_dir        => $package->cwd,
            mb_version      => $Module::Build::VERSION,
            %input,
        },
        phash => {},
        stash => {}, # temporary caching, not stored in _build
    }, $package;
  
    $self->_set_defaults;
    my ($p, $ph) = ($self->{properties}, $self->{phash});
  
    foreach (qw(notes config_data features runtime_params cleanup auto_features)) {
      my $file = File::Spec->catfile($self->config_dir, $_);
      $ph->{$_} = Module::Build::Notes->new(file => $file);
      $ph->{$_}->restore if -e $file;
      if (exists $p->{$_}) {
        my $vals = delete $p->{$_};
        foreach my $k (sort keys %$vals) {
          $self->$_($k, $vals->{$k});
        }
      }
    }
  
    # The following warning could be unnecessary if the user is running
    # an embedded perl, but there aren't too many of those around, and
    # embedded perls aren't usually used to install modules, and the
    # installation process sometimes needs to run external scripts
    # (e.g. to run tests).
    $p->{perl} = $self->find_perl_interpreter
      or $self->log_warn("Warning: Can't locate your perl binary");
  
    my $blibdir = sub { File::Spec->catdir($p->{blib}, @_) };
    $p->{bindoc_dirs} ||= [ $blibdir->("script") ];
    $p->{libdoc_dirs} ||= [ $blibdir->("lib"), $blibdir->("arch") ];
  
    $p->{dist_author} = [ $p->{dist_author} ] if defined $p->{dist_author} and not ref $p->{dist_author};
  
    # Synonyms
    $p->{requires} = delete $p->{prereq} if defined $p->{prereq};
    $p->{script_files} = delete $p->{scripts} if defined $p->{scripts};
  
    # Convert to from shell strings to arrays
    for ('extra_compiler_flags', 'extra_linker_flags') {
      $p->{$_} = [ $self->split_like_shell($p->{$_}) ] if exists $p->{$_};
    }
  
    # Convert to arrays
    for ('include_dirs') {
      $p->{$_} = [ $p->{$_} ] if exists $p->{$_} && !ref $p->{$_}
    }
  
    $self->add_to_cleanup( @{delete $p->{add_to_cleanup}} )
      if $p->{add_to_cleanup};
  
    return $self;
  }
  
  ################## End constructors #########################
  
  sub log_info {
    my $self = shift;
    print @_ if ref($self) && ( $self->verbose || ! $self->quiet );
  }
  sub log_verbose {
    my $self = shift;
    print @_ if ref($self) && $self->verbose;
  }
  sub log_debug {
    my $self = shift;
    print @_ if ref($self) && $self->debug;
  }
  
  sub log_warn {
    # Try to make our call stack invisible
    shift;
    if (@_ and $_[-1] !~ /\n$/) {
      my (undef, $file, $line) = caller();
      warn @_, " at $file line $line.\n";
    } else {
      warn @_;
    }
  }
  
  
  # install paths must be generated when requested to be sure all changes
  # to config (from various sources) are included
  sub _default_install_paths {
    my $self = shift;
    my $c = $self->{config};
    my $p = {};
  
    my @libstyle = $c->get('installstyle') ?
        File::Spec->splitdir($c->get('installstyle')) : qw(lib perl5);
    my $arch     = $c->get('archname');
    my $version  = $c->get('version');
  
    my $bindoc  = $c->get('installman1dir') || undef;
    my $libdoc  = $c->get('installman3dir') || undef;
  
    my $binhtml = $c->get('installhtml1dir') || $c->get('installhtmldir') || undef;
    my $libhtml = $c->get('installhtml3dir') || $c->get('installhtmldir') || undef;
  
    $p->{install_sets} =
      {
       core   => {
         lib     => $c->get('installprivlib'),
         arch    => $c->get('installarchlib'),
         bin     => $c->get('installbin'),
         script  => $c->get('installscript'),
         bindoc  => $bindoc,
         libdoc  => $libdoc,
         binhtml => $binhtml,
         libhtml => $libhtml,
       },
       site   => {
         lib     => $c->get('installsitelib'),
         arch    => $c->get('installsitearch'),
         bin     => $c->get('installsitebin')      || $c->get('installbin'),
         script  => $c->get('installsitescript')   ||
           $c->get('installsitebin') || $c->get('installscript'),
         bindoc  => $c->get('installsiteman1dir')  || $bindoc,
         libdoc  => $c->get('installsiteman3dir')  || $libdoc,
         binhtml => $c->get('installsitehtml1dir') || $binhtml,
         libhtml => $c->get('installsitehtml3dir') || $libhtml,
       },
       vendor => {
         lib     => $c->get('installvendorlib'),
         arch    => $c->get('installvendorarch'),
         bin     => $c->get('installvendorbin')      || $c->get('installbin'),
         script  => $c->get('installvendorscript')   ||
           $c->get('installvendorbin') || $c->get('installscript'),
         bindoc  => $c->get('installvendorman1dir')  || $bindoc,
         libdoc  => $c->get('installvendorman3dir')  || $libdoc,
         binhtml => $c->get('installvendorhtml1dir') || $binhtml,
         libhtml => $c->get('installvendorhtml3dir') || $libhtml,
       },
      };
  
    $p->{original_prefix} =
      {
       core   => $c->get('installprefixexp') || $c->get('installprefix') ||
                 $c->get('prefixexp')        || $c->get('prefix') || '',
       site   => $c->get('siteprefixexp'),
       vendor => $c->get('usevendorprefix') ? $c->get('vendorprefixexp') : '',
      };
    $p->{original_prefix}{site} ||= $p->{original_prefix}{core};
  
    # Note: you might be tempted to use $Config{installstyle} here
    # instead of hard-coding lib/perl5, but that's been considered and
    # (at least for now) rejected.  `perldoc Config` has some wisdom
    # about it.
    $p->{install_base_relpaths} =
      {
       lib     => ['lib', 'perl5'],
       arch    => ['lib', 'perl5', $arch],
       bin     => ['bin'],
       script  => ['bin'],
       bindoc  => ['man', 'man1'],
       libdoc  => ['man', 'man3'],
       binhtml => ['html'],
       libhtml => ['html'],
      };
  
    $p->{prefix_relpaths} =
      {
       core => {
         lib        => [@libstyle],
         arch       => [@libstyle, $version, $arch],
         bin        => ['bin'],
         script     => ['bin'],
         bindoc     => ['man', 'man1'],
         libdoc     => ['man', 'man3'],
         binhtml    => ['html'],
         libhtml    => ['html'],
       },
       vendor => {
         lib        => [@libstyle],
         arch       => [@libstyle, $version, $arch],
         bin        => ['bin'],
         script     => ['bin'],
         bindoc     => ['man', 'man1'],
         libdoc     => ['man', 'man3'],
         binhtml    => ['html'],
         libhtml    => ['html'],
       },
       site => {
         lib        => [@libstyle, 'site_perl'],
         arch       => [@libstyle, 'site_perl', $version, $arch],
         bin        => ['bin'],
         script     => ['bin'],
         bindoc     => ['man', 'man1'],
         libdoc     => ['man', 'man3'],
         binhtml    => ['html'],
         libhtml    => ['html'],
       },
      };
      return $p
  }
  
  sub _find_nested_builds {
    my $self = shift;
    my $r = $self->recurse_into or return;
  
    my ($file, @r);
    if (!ref($r) && $r eq 'auto') {
      local *DH;
      opendir DH, $self->base_dir
        or die "Can't scan directory " . $self->base_dir . " for nested builds: $!";
      while (defined($file = readdir DH)) {
        my $subdir = File::Spec->catdir( $self->base_dir, $file );
        next unless -d $subdir;
        push @r, $subdir if -e File::Spec->catfile( $subdir, 'Build.PL' );
      }
    }
  
    $self->recurse_into(\@r);
  }
  
  sub cwd {
    return Cwd::cwd();
  }
  
  sub _quote_args {
    # Returns a string that can become [part of] a command line with
    # proper quoting so that the subprocess sees this same list of args.
    my ($self, @args) = @_;
  
    my @quoted;
  
    for (@args) {
      if ( /^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/ ) {
        # Looks pretty safe
        push @quoted, $_;
      } else {
        # XXX this will obviously have to improve - is there already a
        # core module lying around that does proper quoting?
        s/('+)/'"$1"'/g;
        push @quoted, qq('$_');
      }
    }
  
    return join " ", @quoted;
  }
  
  sub _backticks {
    my ($self, @cmd) = @_;
    if ($self->have_forkpipe) {
      local *FH;
      my $pid = open *FH, "-|";
      if ($pid) {
        return wantarray ? <FH> : join '', <FH>;
      } else {
        die "Can't execute @cmd: $!\n" unless defined $pid;
        exec { $cmd[0] } @cmd;
      }
    } else {
      my $cmd = $self->_quote_args(@cmd);
      return `$cmd`;
    }
  }
  
  # Tells us whether the construct open($fh, '-|', @command) is
  # supported.  It would probably be better to dynamically sense this.
  sub have_forkpipe { 1 }
  
  # Determine whether a given binary is the same as the perl
  # (configuration) that started this process.
  sub _perl_is_same {
    my ($self, $perl) = @_;
  
    my @cmd = ($perl);
  
    # When run from the perl core, @INC will include the directories
    # where perl is yet to be installed. We need to reference the
    # absolute path within the source distribution where it can find
    # it's Config.pm This also prevents us from picking up a Config.pm
    # from a different configuration that happens to be already
    # installed in @INC.
    if ($ENV{PERL_CORE}) {
      push @cmd, '-I' . File::Spec->catdir(File::Basename::dirname($perl), 'lib');
    }
  
    push @cmd, qw(-MConfig=myconfig -e print -e myconfig);
    return $self->_backticks(@cmd) eq Config->myconfig;
  }
  
  # cache _discover_perl_interpreter() results
  {
    my $known_perl;
    sub find_perl_interpreter {
      my $self = shift;
  
      return $known_perl if defined($known_perl);
      return $known_perl = $self->_discover_perl_interpreter;
    }
  }
  
  # Returns the absolute path of the perl interpreter used to invoke
  # this process. The path is derived from $^X or $Config{perlpath}. On
  # some platforms $^X contains the complete absolute path of the
  # interpreter, on other it may contain a relative path, or simply
  # 'perl'. This can also vary depending on whether a path was supplied
  # when perl was invoked. Additionally, the value in $^X may omit the
  # executable extension on platforms that use one. It's a fatal error
  # if the interpreter can't be found because it can result in undefined
  # behavior by routines that depend on it (generating errors or
  # invoking the wrong perl.)
  sub _discover_perl_interpreter {
    my $proto = shift;
    my $c     = ref($proto) ? $proto->{config} : 'Module::Build::Config';
  
    my $perl  = $^X;
    my $perl_basename = File::Basename::basename($perl);
  
    my @potential_perls;
  
    # Try 1, Check $^X for absolute path
    push( @potential_perls, $perl )
        if File::Spec->file_name_is_absolute($perl);
  
    # Try 2, Check $^X for a valid relative path
    my $abs_perl = File::Spec->rel2abs($perl);
    push( @potential_perls, $abs_perl );
  
    # Try 3, Last ditch effort: These two option use hackery to try to locate
    # a suitable perl. The hack varies depending on whether we are running
    # from an installed perl or an uninstalled perl in the perl source dist.
    if ($ENV{PERL_CORE}) {
  
      # Try 3.A, If we are in a perl source tree, running an uninstalled
      # perl, we can keep moving up the directory tree until we find our
      # binary. We wouldn't do this under any other circumstances.
  
      # CBuilder is also in the core, so it should be available here
      require ExtUtils::CBuilder;
      my $perl_src = Cwd::realpath( ExtUtils::CBuilder->perl_src );
      if ( defined($perl_src) && length($perl_src) ) {
        my $uninstperl =
          File::Spec->rel2abs(File::Spec->catfile( $perl_src, $perl_basename ));
        push( @potential_perls, $uninstperl );
      }
  
    } else {
  
      # Try 3.B, First look in $Config{perlpath}, then search the user's
      # PATH. We do not want to do either if we are running from an
      # uninstalled perl in a perl source tree.
  
      push( @potential_perls, $c->get('perlpath') );
  
      push( @potential_perls,
            map File::Spec->catfile($_, $perl_basename), File::Spec->path() );
    }
  
    # Now that we've enumerated the potential perls, it's time to test
    # them to see if any of them match our configuration, returning the
    # absolute path of the first successful match.
    my $exe = $c->get('exe_ext');
    foreach my $thisperl ( @potential_perls ) {
  
      if (defined $exe) {
        $thisperl .= $exe unless $thisperl =~ m/$exe$/i;
      }
  
      if ( -f $thisperl && $proto->_perl_is_same($thisperl) ) {
        return $thisperl;
      }
    }
  
    # We've tried all alternatives, and didn't find a perl that matches
    # our configuration. Throw an exception, and list alternatives we tried.
    my @paths = map File::Basename::dirname($_), @potential_perls;
    die "Can't locate the perl binary used to run this script " .
        "in (@paths)\n";
  }
  
  # Adapted from IPC::Cmd::can_run()
  sub find_command {
    my ($self, $command) = @_;
  
    if( File::Spec->file_name_is_absolute($command) ) {
      return $self->_maybe_command($command);
  
    } else {
      for my $dir ( File::Spec->path ) {
        my $abs = File::Spec->catfile($dir, $command);
        return $abs if $abs = $self->_maybe_command($abs);
      }
    }
  }
  
  # Copied from ExtUtils::MM_Unix::maybe_command
  sub _maybe_command {
    my($self,$file) = @_;
    return $file if -x $file && ! -d $file;
    return;
  }
  
  sub _is_interactive {
    return -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;   # Pipe?
  }
  
  # NOTE this is a blocking operation if(-t STDIN)
  sub _is_unattended {
    my $self = shift;
    return $ENV{PERL_MM_USE_DEFAULT} ||
      ( !$self->_is_interactive && eof STDIN );
  }
  
  sub _readline {
    my $self = shift;
    return undef if $self->_is_unattended;
  
    my $answer = <STDIN>;
    chomp $answer if defined $answer;
    return $answer;
  }
  
  sub prompt {
    my $self = shift;
    my $mess = shift
      or die "prompt() called without a prompt message";
  
    # use a list to distinguish a default of undef() from no default
    my @def;
    @def = (shift) if @_;
    # use dispdef for output
    my @dispdef = scalar(@def) ?
      ('[', (defined($def[0]) ? $def[0] . ' ' : ''), ']') :
      (' ', '');
  
    local $|=1;
    print "$mess ", @dispdef;
  
    if ( $self->_is_unattended && !@def ) {
      die <<EOF;
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
    }
  
    my $ans = $self->_readline();
  
    if ( !defined($ans)        # Ctrl-D or unattended
         or !length($ans) ) {  # User hit return
      print "$dispdef[1]\n";
      $ans = scalar(@def) ? $def[0] : '';
    }
  
    return $ans;
  }
  
  sub y_n {
    my $self = shift;
    my ($mess, $def)  = @_;
  
    die "y_n() called without a prompt message" unless $mess;
    die "Invalid default value: y_n() default must be 'y' or 'n'"
      if $def && $def !~ /^[yn]/i;
  
    my $answer;
    while (1) { # XXX Infinite or a large number followed by an exception ?
      $answer = $self->prompt(@_);
      return 1 if $answer =~ /^y/i;
      return 0 if $answer =~ /^n/i;
      local $|=1;
      print "Please answer 'y' or 'n'.\n";
    }
  }
  
  sub current_action { shift->{action} }
  sub invoked_action { shift->{invoked_action} }
  
  sub notes        { shift()->{phash}{notes}->access(@_) }
  sub config_data  { shift()->{phash}{config_data}->access(@_) }
  sub runtime_params { shift->{phash}{runtime_params}->read( @_ ? shift : () ) }  # Read-only
  sub auto_features  { shift()->{phash}{auto_features}->access(@_) }
  
  sub features     {
    my $self = shift;
    my $ph = $self->{phash};
  
    if (@_) {
      my $key = shift;
      if ($ph->{features}->exists($key)) {
        return $ph->{features}->access($key, @_);
      }
  
      if (my $info = $ph->{auto_features}->access($key)) {
        my $disabled;
        for my $type ( @{$self->prereq_action_types} ) {
          next if $type eq 'description' || $type eq 'recommends' || ! exists $info->{$type};
          my $prereqs = $info->{$type};
          for my $modname ( sort keys %$prereqs ) {
            my $spec = $prereqs->{$modname};
            my $status = $self->check_installed_status($modname, $spec);
            if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
            if ( ! eval "require $modname; 1" ) { return 0; }
          }
        }
        return 1;
      }
  
      return $ph->{features}->access($key, @_);
    }
  
    # No args - get the auto_features & overlay the regular features
    my %features;
    my %auto_features = $ph->{auto_features}->access();
    while (my ($name, $info) = each %auto_features) {
      my $failures = $self->prereq_failures($info);
      my $disabled = grep( /^(?:\w+_)?(?:requires|conflicts)$/,
                          keys %$failures ) ? 1 : 0;
      $features{$name} = $disabled ? 0 : 1;
    }
    %features = (%features, $ph->{features}->access());
  
    return wantarray ? %features : \%features;
  }
  BEGIN { *feature = \&features } # Alias
  
  sub _mb_feature {
    my $self = shift;
  
    if (($self->module_name || '') eq 'Module::Build') {
      # We're building Module::Build itself, so ...::ConfigData isn't
      # valid, but $self->features() should be.
      return $self->feature(@_);
    } else {
      require Module::Build::ConfigData;
      return Module::Build::ConfigData->feature(@_);
    }
  }
  
  sub _warn_mb_feature_deps {
    my $self = shift;
    my $name = shift;
    $self->log_warn(
      "The '$name' feature is not available.  Please install missing\n" .
      "feature dependencies and try again.\n".
      $self->_feature_deps_msg($name) . "\n"
    );
  }
  
  sub add_build_element {
      my ($self, $elem) = @_;
      my $elems = $self->build_elements;
      push @$elems, $elem unless grep { $_ eq $elem } @$elems;
  }
  
  sub ACTION_config_data {
    my $self = shift;
    return unless $self->has_config_data;
  
    my $module_name = $self->module_name
      or die "The config_data feature requires that 'module_name' be set";
    my $notes_name = $module_name . '::ConfigData'; # TODO: Customize name ???
    my $notes_pm = File::Spec->catfile($self->blib, 'lib', split /::/, "$notes_name.pm");
  
    return if $self->up_to_date(['Build.PL',
                                 $self->config_file('config_data'),
                                 $self->config_file('features')
                                ], $notes_pm);
  
    $self->log_verbose("Writing config notes to $notes_pm\n");
    File::Path::mkpath(File::Basename::dirname($notes_pm));
  
    Module::Build::Notes->write_config_data
      (
       file => $notes_pm,
       module => $module_name,
       config_module => $notes_name,
       config_data => scalar $self->config_data,
       feature => scalar $self->{phash}{features}->access(),
       auto_features => scalar $self->auto_features,
      );
  }
  
  ########################################################################
  { # enclosing these lexicals -- TODO
    my %valid_properties = ( __PACKAGE__,  {} );
    my %additive_properties;
  
    sub _mb_classes {
      my $class = ref($_[0]) || $_[0];
      return ($class, $class->mb_parents);
    }
  
    sub valid_property {
      my ($class, $prop) = @_;
      return grep exists( $valid_properties{$_}{$prop} ), $class->_mb_classes;
    }
  
    sub valid_properties {
      return keys %{ shift->valid_properties_defaults() };
    }
  
    sub valid_properties_defaults {
      my %out;
      for my $class (reverse shift->_mb_classes) {
        @out{ keys %{ $valid_properties{$class} } } = map {
          $_->()
        } values %{ $valid_properties{$class} };
      }
      return \%out;
    }
  
    sub array_properties {
      map { exists $additive_properties{$_}->{ARRAY} ? @{$additive_properties{$_}->{ARRAY}} : () } shift->_mb_classes;
    }
  
    sub hash_properties {
      map { exists $additive_properties{$_}->{HASH} ? @{$additive_properties{$_}->{HASH}} : () } shift->_mb_classes;
    }
  
    sub add_property {
      my ($class, $property) = (shift, shift);
      die "Property '$property' already exists"
        if $class->valid_property($property);
      my %p = @_ == 1 ? ( default => shift ) : @_;
  
      my $type = ref $p{default};
      $valid_properties{$class}{$property} =
        $type eq 'CODE' ? $p{default}                           :
        $type eq 'HASH' ? sub { return { %{ $p{default} } }   } :
        $type eq 'ARRAY'? sub { return [ @{ $p{default} } ]   } :
                          sub { return $p{default}            } ;
  
      push @{$additive_properties{$class}->{$type}}, $property
        if $type;
  
      unless ($class->can($property)) {
        # TODO probably should put these in a util package
        my $sub = $type eq 'HASH'
          ? _make_hash_accessor($property, \%p)
          : _make_accessor($property, \%p);
        no strict 'refs';
        *{"$class\::$property"} = $sub;
      }
  
      return $class;
    }
  
    sub property_error {
      my $self = shift;
      die 'ERROR: ', @_;
    }
  
    sub _set_defaults {
      my $self = shift;
  
      # Set the build class.
      $self->{properties}{build_class} ||= ref $self;
  
      # If there was no orig_dir, set to the same as base_dir
      $self->{properties}{orig_dir} ||= $self->{properties}{base_dir};
  
      my $defaults = $self->valid_properties_defaults;
  
      foreach my $prop (keys %$defaults) {
        $self->{properties}{$prop} = $defaults->{$prop}
          unless exists $self->{properties}{$prop};
      }
  
      # Copy defaults for arrays any arrays.
      for my $prop ($self->array_properties) {
        $self->{properties}{$prop} = [@{$defaults->{$prop}}]
          unless exists $self->{properties}{$prop};
      }
      # Copy defaults for arrays any hashes.
      for my $prop ($self->hash_properties) {
        $self->{properties}{$prop} = {%{$defaults->{$prop}}}
          unless exists $self->{properties}{$prop};
      }
    }
  
  } # end enclosure
  ########################################################################
  sub _make_hash_accessor {
    my ($property, $p) = @_;
    my $check = $p->{check} || sub { 1 };
  
    return sub {
      my $self = shift;
  
      # This is only here to deprecate the historic accident of calling
      # properties as class methods - I suspect it only happens in our
      # test suite.
      unless(ref($self)) {
        carp("\n$property not a class method (@_)");
        return;
      }
  
      my $x = $self->{properties};
      return $x->{$property} unless @_;
  
      my $prop = $x->{$property};
      if ( defined $_[0] && !ref $_[0] ) {
        if ( @_ == 1 ) {
          return exists $prop->{$_[0]} ? $prop->{$_[0]} : undef;
        } elsif ( @_ % 2 == 0 ) {
          my %new = (%{ $prop }, @_);
          local $_ = \%new;
          $x->{$property} = \%new if $check->($self);
          return $x->{$property};
        } else {
          die "Unexpected arguments for property '$property'\n";
        }
      } else {
        die "Unexpected arguments for property '$property'\n"
            if defined $_[0] && ref $_[0] ne 'HASH';
        local $_ = $_[0];
        $x->{$property} = shift if $check->($self);
      }
    };
  }
  ########################################################################
  sub _make_accessor {
    my ($property, $p) = @_;
    my $check = $p->{check} || sub { 1 };
  
    return sub {
      my $self = shift;
  
      # This is only here to deprecate the historic accident of calling
      # properties as class methods - I suspect it only happens in our
      # test suite.
      unless(ref($self)) {
        carp("\n$property not a class method (@_)");
        return;
      }
  
      my $x = $self->{properties};
      return $x->{$property} unless @_;
      local $_ = $_[0];
      $x->{$property} = shift if $check->($self);
      return $x->{$property};
    };
  }
  ########################################################################
  
  # Add the default properties.
  __PACKAGE__->add_property(auto_configure_requires => 1);
  __PACKAGE__->add_property(blib => 'blib');
  __PACKAGE__->add_property(build_class => 'Module::Build');
  __PACKAGE__->add_property(build_elements => [qw(PL support pm xs share_dir pod script)]);
  __PACKAGE__->add_property(build_script => 'Build');
  __PACKAGE__->add_property(build_bat => 0);
  __PACKAGE__->add_property(bundle_inc => []);
  __PACKAGE__->add_property(bundle_inc_preload => []);
  __PACKAGE__->add_property(config_dir => '_build');
  __PACKAGE__->add_property(dynamic_config => 1);
  __PACKAGE__->add_property(include_dirs => []);
  __PACKAGE__->add_property(license => 'unknown');
  __PACKAGE__->add_property(metafile => 'META.yml');
  __PACKAGE__->add_property(mymetafile => 'MYMETA.yml');
  __PACKAGE__->add_property(metafile2 => 'META.json');
  __PACKAGE__->add_property(mymetafile2 => 'MYMETA.json');
  __PACKAGE__->add_property(recurse_into => []);
  __PACKAGE__->add_property(use_rcfile => 1);
  __PACKAGE__->add_property(create_packlist => 1);
  __PACKAGE__->add_property(allow_mb_mismatch => 0);
  __PACKAGE__->add_property(config => undef);
  __PACKAGE__->add_property(test_file_exts => ['.t']);
  __PACKAGE__->add_property(use_tap_harness => 0);
  __PACKAGE__->add_property(cpan_client => 'cpan');
  __PACKAGE__->add_property(tap_harness_args => {});
  __PACKAGE__->add_property(pureperl_only => 0);
  __PACKAGE__->add_property(allow_pureperl => 0);
  __PACKAGE__->add_property(
    'installdirs',
    default => 'site',
    check   => sub {
      return 1 if /^(core|site|vendor)$/;
      return shift->property_error(
        $_ eq 'perl'
        ? 'Perhaps you meant installdirs to be "core" rather than "perl"?'
        : 'installdirs must be one of "core", "site", or "vendor"'
      );
      return shift->property_error("Perhaps you meant 'core'?") if $_ eq 'perl';
      return 0;
    },
  );
  
  {
    __PACKAGE__->add_property(html_css => '');
  }
  
  {
    my @prereq_action_types = qw(requires build_requires test_requires conflicts recommends);
    foreach my $type (@prereq_action_types) {
      __PACKAGE__->add_property($type => {});
    }
    __PACKAGE__->add_property(prereq_action_types => \@prereq_action_types);
  }
  
  __PACKAGE__->add_property($_ => {}) for qw(
    get_options
    install_base_relpaths
    install_path
    install_sets
    meta_add
    meta_merge
    original_prefix
    prefix_relpaths
    configure_requires
  );
  
  __PACKAGE__->add_property($_) for qw(
    PL_files
    autosplit
    base_dir
    bindoc_dirs
    c_source
    cover
    create_license
    create_makefile_pl
    create_readme
    debugger
    destdir
    dist_abstract
    dist_author
    dist_name
    dist_suffix
    dist_version
    dist_version_from
    extra_compiler_flags
    extra_linker_flags
    has_config_data
    install_base
    libdoc_dirs
    magic_number
    mb_version
    module_name
    needs_compiler
    orig_dir
    perl
    pm_files
    pod_files
    pollute
    prefix
    program_name
    quiet
    recursive_test_files
    release_status
    script_files
    scripts
    share_dir
    sign
    test_files
    verbose
    debug
    xs_files
    extra_manify_args
  );
  
  sub config {
    my $self = shift;
    my $c = ref($self) ? $self->{config} : 'Module::Build::Config';
    return $c->all_config unless @_;
  
    my $key = shift;
    return $c->get($key) unless @_;
  
    my $val = shift;
    return $c->set($key => $val);
  }
  
  sub mb_parents {
      # Code borrowed from Class::ISA.
      my @in_stack = (shift);
      my %seen = ($in_stack[0] => 1);
  
      my ($current, @out);
      while (@in_stack) {
          next unless defined($current = shift @in_stack)
            && $current->isa('Module::Build::Base');
          push @out, $current;
          next if $current eq 'Module::Build::Base';
          no strict 'refs';
          unshift @in_stack,
            map {
                my $c = $_; # copy, to avoid being destructive
                substr($c,0,2) = "main::" if substr($c,0,2) eq '::';
                # Canonize the :: -> main::, ::foo -> main::foo thing.
                # Should I ever canonize the Foo'Bar = Foo::Bar thing?
                $seen{$c}++ ? () : $c;
            } @{"$current\::ISA"};
  
          # I.e., if this class has any parents (at least, ones I've never seen
          # before), push them, in order, onto the stack of classes I need to
          # explore.
      }
      shift @out;
      return @out;
  }
  
  sub extra_linker_flags   { shift->_list_accessor('extra_linker_flags',   @_) }
  sub extra_compiler_flags { shift->_list_accessor('extra_compiler_flags', @_) }
  
  sub _list_accessor {
    (my $self, local $_) = (shift, shift);
    my $p = $self->{properties};
    $p->{$_} = [@_] if @_;
    $p->{$_} = [] unless exists $p->{$_};
    return ref($p->{$_}) ? $p->{$_} : [$p->{$_}];
  }
  
  # XXX Problem - if Module::Build is loaded from a different directory,
  # it'll look for (and perhaps destroy/create) a _build directory.
  sub subclass {
    my ($pack, %opts) = @_;
  
    my $build_dir = '_build'; # XXX The _build directory is ostensibly settable by the user.  Shouldn't hard-code here.
    $pack->delete_filetree($build_dir) if -e $build_dir;
  
    die "Must provide 'code' or 'class' option to subclass()\n"
      unless $opts{code} or $opts{class};
  
    $opts{code}  ||= '';
    $opts{class} ||= 'MyModuleBuilder';
  
    my $filename = File::Spec->catfile($build_dir, 'lib', split '::', $opts{class}) . '.pm';
    my $filedir  = File::Basename::dirname($filename);
    $pack->log_verbose("Creating custom builder $filename in $filedir\n");
  
    File::Path::mkpath($filedir);
    die "Can't create directory $filedir: $!" unless -d $filedir;
  
    open(my $fh, '>', $filename) or die "Can't create $filename: $!";
    print $fh <<EOF;
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
    close $fh;
  
    unshift @INC, File::Spec->catdir(File::Spec->rel2abs($build_dir), 'lib');
    eval "use $opts{class}";
    die $@ if $@;
  
    return $opts{class};
  }
  
  sub _guess_module_name {
    my $self = shift;
    my $p = $self->{properties};
    return if $p->{module_name};
    if ( $p->{dist_version_from} && -e $p->{dist_version_from} ) {
      my $mi = Module::Metadata->new_from_file($self->dist_version_from);
      $p->{module_name} = $mi->name;
    }
    else {
      my $mod_path = my $mod_name = $p->{dist_name};
      $mod_name =~ s{-}{::}g;
      $mod_path =~ s{-}{/}g;
      $mod_path .= ".pm";
      if ( -e $mod_path || -e "lib/$mod_path" ) {
        $p->{module_name} = $mod_name;
      }
      else {
        $self->log_warn( << 'END_WARN' );
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
      }
    }
  }
  
  sub dist_name {
    my $self = shift;
    my $p = $self->{properties};
    my $me = 'dist_name';
    return $p->{$me} if defined $p->{$me};
  
    die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter"
      unless $self->module_name;
  
    ($p->{$me} = $self->module_name) =~ s/::/-/g;
  
    return $p->{$me};
  }
  
  sub release_status {
    my ($self) = @_;
    my $me = 'release_status';
    my $p = $self->{properties};
  
    if ( ! defined $p->{$me} ) {
      $p->{$me} = $self->_is_dev_version ? 'testing' : 'stable';
    }
  
    unless ( $p->{$me} =~ qr/\A(?:stable|testing|unstable)\z/ ) {
      die "Illegal value '$p->{$me}' for $me\n";
    }
  
    if ( $p->{$me} eq 'stable' && $self->_is_dev_version ) {
      my $version = $self->dist_version;
      die "Illegal value '$p->{$me}' with version '$version'\n";
    }
    return $p->{$me};
  }
  
  sub dist_suffix {
    my ($self) = @_;
    my $p = $self->{properties};
    my $me = 'dist_suffix';
  
    return $p->{$me} if defined $p->{$me};
  
    if ( $self->release_status eq 'stable' ) {
      $p->{$me} = "";
    }
    else {
      # non-stable release but non-dev version number needs '-TRIAL' appended
      $p->{$me} = $self->_is_dev_version ? "" : "TRIAL" ;
    }
  
    return $p->{$me};
  }
  
  sub dist_version_from {
    my ($self) = @_;
    my $p = $self->{properties};
    my $me = 'dist_version_from';
  
    if ($self->module_name) {
      $p->{$me} ||=
        join( '/', 'lib', split(/::/, $self->module_name) ) . '.pm';
    }
    return $p->{$me} || undef;
  }
  
  sub dist_version {
    my ($self) = @_;
    my $p = $self->{properties};
    my $me = 'dist_version';
  
    return $p->{$me} if defined $p->{$me};
  
    if ( my $dist_version_from = $self->dist_version_from ) {
      my $version_from = File::Spec->catfile( split( qr{/}, $dist_version_from ) );
      my $pm_info = Module::Metadata->new_from_file( $version_from )
        or die "Can't find file $version_from to determine version";
      #$p->{$me} is undef here
      $p->{$me} = $self->normalize_version( $pm_info->version() );
      unless (defined $p->{$me}) {
        die "Can't determine distribution version from $version_from";
      }
    }
  
    die ("Can't determine distribution version, must supply either 'dist_version',\n".
         "'dist_version_from', or 'module_name' parameter")
      unless defined $p->{$me};
  
    return $p->{$me};
  }
  
  sub _is_dev_version {
    my ($self) = @_;
    my $dist_version = $self->dist_version;
    my $version_obj = eval { version->new( $dist_version ) };
    # assume it's normal if the version string is fatal -- in this case
    # the author might be doing something weird so should play along and
    # assume they'll specify all necessary behavior
    return $@ ? 0 : $version_obj->is_alpha;
  }
  
  sub dist_author   { shift->_pod_parse('author')   }
  sub dist_abstract { shift->_pod_parse('abstract') }
  
  sub _pod_parse {
    my ($self, $part) = @_;
    my $p = $self->{properties};
    my $member = "dist_$part";
    return $p->{$member} if defined $p->{$member};
  
    my $docfile = $self->_main_docfile
      or return;
    open(my $fh, '<', $docfile)
      or return;
  
    require Module::Build::PodParser;
    my $parser = Module::Build::PodParser->new(fh => $fh);
    my $method = "get_$part";
    return $p->{$member} = $parser->$method();
  }
  
  sub version_from_file { # Method provided for backwards compatibility
    return Module::Metadata->new_from_file($_[1])->version();
  }
  
  sub find_module_by_name { # Method provided for backwards compatibility
    return Module::Metadata->find_module_by_name(@_[1,2]);
  }
  
  {
    # $unlink_list_for_pid{$$} = [ ... ]
    my %unlink_list_for_pid;
  
    sub _unlink_on_exit {
      my $self = shift;
      for my $f ( @_ ) {
        push @{$unlink_list_for_pid{$$}}, $f if -f $f;
      }
      return 1;
    }
  
    END {
      for my $f ( map glob($_), @{ $unlink_list_for_pid{$$} || [] } ) {
        next unless -e $f;
        File::Path::rmtree($f, 0, 0);
      }
    }
  }
  
  sub add_to_cleanup {
    my $self = shift;
    my %files = map {$self->localize_file_path($_), 1} @_;
    $self->{phash}{cleanup}->write(\%files);
  }
  
  sub cleanup {
    my $self = shift;
    my $all = $self->{phash}{cleanup}->read;
    return wantarray ? sort keys %$all : keys %$all;
  }
  
  sub config_file {
    my $self = shift;
    return unless -d $self->config_dir;
    return File::Spec->catfile($self->config_dir, @_);
  }
  
  sub read_config {
    my ($self) = @_;
  
    my $file = $self->config_file('build_params')
      or die "Can't find 'build_params' in " . $self->config_dir;
    open(my $fh, '<', $file) or die "Can't read '$file': $!";
    my $ref = eval do {local $/; <$fh>};
    die if $@;
    close $fh;
    my $c;
    ($self->{args}, $c, $self->{properties}) = @$ref;
    $self->{config} = Module::Build::Config->new(values => $c);
  }
  
  sub has_config_data {
    my $self = shift;
    return scalar grep $self->{phash}{$_}->has_data(), qw(config_data features auto_features);
  }
  
  sub _write_data {
    my ($self, $filename, $data) = @_;
  
    my $file = $self->config_file($filename);
    open(my $fh, '>', $file) or die "Can't create '$file': $!";
    unless (ref($data)) {  # e.g. magicnum
      print $fh $data;
      return;
    }
  
    print {$fh} Module::Build::Dumper->_data_dump($data);
    close $fh;
  }
  
  sub write_config {
    my ($self) = @_;
  
    File::Path::mkpath($self->{properties}{config_dir});
    -d $self->{properties}{config_dir} or die "Can't mkdir $self->{properties}{config_dir}: $!";
  
    my @items = @{ $self->prereq_action_types };
    $self->_write_data('prereqs', { map { $_, $self->$_() } @items });
    $self->_write_data('build_params', [$self->{args}, $self->{config}->values_set, $self->{properties}]);
  
    # Set a new magic number and write it to a file
    $self->_write_data('magicnum', $self->magic_number(int rand 1_000_000));
  
    $self->{phash}{$_}->write() foreach qw(notes cleanup features auto_features config_data runtime_params);
  }
  
  {
    # packfile map -- keys are guts of regular expressions;  If they match,
    # values are module names corresponding to the packlist
    my %packlist_map = (
      '^File::Spec'         => 'Cwd',
      '^Devel::AssertOS'    => 'Devel::CheckOS',
    );
  
    sub _find_packlist {
      my ($self, $inst, $mod) = @_;
      my $lookup = $mod;
      my $packlist = eval { $inst->packlist($lookup) };
      if ( ! $packlist ) {
        # try from packlist_map
        while ( my ($re, $new_mod) = each %packlist_map ) {
          if ( $mod =~ qr/$re/ ) {
            $lookup = $new_mod;
            $packlist = eval { $inst->packlist($lookup) };
            last;
          }
        }
      }
      return $packlist ? $lookup : undef;
    }
  
    sub set_bundle_inc {
      my $self = shift;
  
      my $bundle_inc = $self->{properties}{bundle_inc};
      my $bundle_inc_preload = $self->{properties}{bundle_inc_preload};
      # We're in author mode if inc::latest is loaded, but not from cwd
      return unless inc::latest->can('loaded_modules');
      require ExtUtils::Installed;
      # ExtUtils::Installed is buggy about finding additions to default @INC
      my $inst = eval { ExtUtils::Installed->new(extra_libs => [@INC]) };
      if ($@) {
        $self->log_warn( << "EUI_ERROR" );
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
        return;
      }
      my @bundle_list = map { [ $_, 0 ] } inc::latest->loaded_modules;
  
      # XXX TODO: Need to get ordering of prerequisites correct so they are
      # are loaded in the right order. Use an actual tree?!
  
      while( @bundle_list ) {
        my ($mod, $prereq) = @{ shift @bundle_list };
  
        # XXX TODO: Append prereqs to list
        # skip if core or already in bundle or preload lists
        # push @bundle_list, [$_, 1] for prereqs()
  
        # Locate packlist for bundling
        my $lookup = $self->_find_packlist($inst,$mod);
        if ( ! $lookup ) {
          # XXX Really needs a more helpful error message here
          die << "NO_PACKLIST";
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
        }
        else {
          push @{ $prereq ? $bundle_inc_preload : $bundle_inc }, $lookup;
        }
      }
    } # sub check_bundling
  }
  
  sub check_autofeatures {
    my ($self) = @_;
    my $features = $self->auto_features;
  
    return 1 unless %$features;
  
    # TODO refactor into ::Util
    my $longest = sub {
      my @str = @_ or croak("no strings given");
  
      my @len = map({length($_)} @str);
      my $max = 0;
      my $longest;
      for my $i (0..$#len) {
        ($max, $longest) = ($len[$i], $str[$i]) if($len[$i] > $max);
      }
      return($longest);
    };
    my $max_name_len = length($longest->(keys %$features));
  
    my ($num_disabled, $log_text) = (0, "\nChecking optional features...\n");
    for my $name ( sort keys %$features ) {
      $log_text .= $self->_feature_deps_msg($name, $max_name_len);
    }
  
    $num_disabled = () = $log_text =~ /disabled/g;
  
    # warn user if features disabled
    if ( $num_disabled ) {
      $self->log_warn( $log_text );
      return 0;
    }
    else {
      $self->log_verbose( $log_text );
      return 1;
    }
  }
  
  sub _feature_deps_msg {
    my ($self, $name, $max_name_len) = @_;
      $max_name_len ||= length $name;
      my $features = $self->auto_features;
      my $info = $features->{$name};
      my $feature_text = "$name" . '.' x ($max_name_len - length($name) + 4);
  
      my ($log_text, $disabled) = ('','');
      if ( my $failures = $self->prereq_failures($info) ) {
        $disabled = grep( /^(?:\w+_)?(?:requires|conflicts)$/,
                    keys %$failures ) ? 1 : 0;
        $feature_text .= $disabled ? "disabled\n" : "enabled\n";
  
        for my $type ( @{ $self->prereq_action_types } ) {
          next unless exists $failures->{$type};
          $feature_text .= "  $type:\n";
          my $prereqs = $failures->{$type};
          for my $module ( sort keys %$prereqs ) {
            my $status = $prereqs->{$module};
            my $required =
              ($type =~ /^(?:\w+_)?(?:requires|conflicts)$/) ? 1 : 0;
            my $prefix = ($required) ? '!' : '*';
            $feature_text .= "    $prefix $status->{message}\n";
          }
        }
      } else {
        $feature_text .= "enabled\n";
      }
      $log_text .= $feature_text if $disabled || $self->verbose;
      return $log_text;
  }
  
  # Automatically detect configure_requires prereqs
  sub auto_config_requires {
    my ($self) = @_;
    my $p = $self->{properties};
  
    # add current Module::Build to configure_requires if there
    # isn't one already specified (but not ourself, so we're not circular)
    if ( $self->dist_name ne 'Module-Build'
      && $self->auto_configure_requires
      && ! exists $p->{configure_requires}{'Module::Build'}
    ) {
      (my $ver = $VERSION) =~ s/^(\d+\.\d\d).*$/$1/; # last major release only
      $self->log_warn(<<EOM);
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
      $self->_add_prereq('configure_requires', 'Module::Build', $ver);
    }
  
    # if we're in author mode, add inc::latest modules to
    # configure_requires if not already set.  If we're not in author mode
    # then configure_requires will have been satisfied, or we'll just
    # live with what we've bundled
    if ( inc::latest->can('loaded_module') ) {
      for my $mod ( inc::latest->loaded_modules ) {
        next if exists $p->{configure_requires}{$mod};
        $self->_add_prereq('configure_requires', $mod, $mod->VERSION);
      }
    }
  
    return;
  }
  
  # Automatically detect and add prerequisites based on configuration
  sub auto_require {
    my ($self) = @_;
    my $p = $self->{properties};
  
    # If needs_compiler is not explicitly set, automatically set it
    # If set, we need ExtUtils::CBuilder (and a compiler)
    my $xs_files = $self->find_xs_files;
    if ( ! defined $p->{needs_compiler} ) {
      $self->needs_compiler( keys %$xs_files || defined $self->c_source );
    }
    if ($self->needs_compiler) {
      $self->_add_prereq('build_requires', 'ExtUtils::CBuilder', 0);
      if ( ! $self->have_c_compiler ) {
        $self->log_warn(<<'EOM');
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      }
    }
  
    # If using share_dir, require File::ShareDir
    if ( $self->share_dir ) {
      $self->_add_prereq( 'requires', 'File::ShareDir', '1.00' );
    }
  
    return;
  }
  
  sub _add_prereq {
    my ($self, $type, $module, $version) = @_;
    my $p = $self->{properties};
    $version = 0 unless defined $version;
    if ( exists $p->{$type}{$module} ) {
      return if $self->compare_versions( $version, '<=', $p->{$type}{$module} );
    }
    $self->log_verbose("Adding to $type\: $module => $version\n");
    $p->{$type}{$module} = $version;
    return 1;
  }
  
  sub prereq_failures {
    my ($self, $info) = @_;
  
    my @types = @{ $self->prereq_action_types };
    $info ||= {map {$_, $self->$_()} @types};
  
    my $out;
  
    foreach my $type (@types) {
      my $prereqs = $info->{$type};
      for my $modname ( keys %$prereqs ) {
        my $spec = $prereqs->{$modname};
        my $status = $self->check_installed_status($modname, $spec);
  
        if ($type =~ /^(?:\w+_)?conflicts$/) {
          next if !$status->{ok};
          $status->{conflicts} = delete $status->{need};
          $status->{message} = "$modname ($status->{have}) conflicts with this distribution";
  
        } elsif ($type =~ /^(?:\w+_)?recommends$/) {
          next if $status->{ok};
          $status->{message} = (!ref($status->{have}) && $status->{have} eq '<none>'
                                ? "$modname is not installed"
                                : "$modname ($status->{have}) is installed, but we prefer to have $spec");
        } else {
          next if $status->{ok};
        }
  
        $out->{$type}{$modname} = $status;
      }
    }
  
    return $out;
  }
  
  # returns a hash of defined prerequisites; i.e. only prereq types with values
  sub _enum_prereqs {
    my $self = shift;
    my %prereqs;
    foreach my $type ( @{ $self->prereq_action_types } ) {
      if ( $self->can( $type ) ) {
        my $prereq = $self->$type() || {};
        $prereqs{$type} = $prereq if %$prereq;
      }
    }
    return \%prereqs;
  }
  
  sub check_prereq {
    my $self = shift;
  
    # Check to see if there are any prereqs to check
    my $info = $self->_enum_prereqs;
    return 1 unless $info;
  
    my $log_text = "Checking prerequisites...\n";
  
    my $failures = $self->prereq_failures($info);
  
    if ( $failures ) {
      $self->log_warn($log_text);
      for my $type ( @{ $self->prereq_action_types } ) {
        my $prereqs = $failures->{$type};
        $self->log_warn("  ${type}:\n") if keys %$prereqs;
        for my $module ( sort keys %$prereqs ) {
          my $status = $prereqs->{$module};
          my $prefix = ($type =~ /^(?:\w+_)?recommends$/) ? "* " : "! ";
          $self->log_warn("    $prefix $status->{message}\n");
        }
      }
      return 0;
    } else {
      $self->log_verbose($log_text . "Looks good\n\n");
      return 1;
    }
  }
  
  sub perl_version {
    my ($self) = @_;
    # Check the current perl interpreter
    # It's much more convenient to use $] here than $^V, but 'man
    # perlvar' says I'm not supposed to.  Bloody tyrant.
    return $^V ? $self->perl_version_to_float(sprintf "%vd", $^V) : $];
  }
  
  sub perl_version_to_float {
    my ($self, $version) = @_;
    return $version if grep( /\./, $version ) < 2;
    $version =~ s/\./../;
    $version =~ s/\.(\d+)/sprintf '%03d', $1/eg;
    return $version;
  }
  
  sub _parse_conditions {
    my ($self, $spec) = @_;
  
    return ">= 0" if not defined $spec;
    if ($spec =~ /^\s*([\w.]+)\s*$/) { # A plain number, maybe with dots, letters, and underscores
      return (">= $spec");
    } else {
      return split /\s*,\s*/, $spec;
    }
  }
  
  sub try_require {
    my ($self, $modname, $spec) = @_;
    my $status = $self->check_installed_status($modname, defined($spec) ? $spec : 0);
    return unless $status->{ok};
    my $path = $modname;
    $path =~ s{::}{/}g;
    $path .= ".pm";
    if ( defined $INC{$path} ) {
      return 1;
    }
    elsif ( exists $INC{$path} ) { # failed before, don't try again
      return;
    }
    else {
      return eval "require $modname";
    }
  }
  
  sub check_installed_status {
    my ($self, $modname, $spec) = @_;
    my %status = (need => $spec);
  
    if ($modname eq 'perl') {
      $status{have} = $self->perl_version;
  
    } elsif (eval { no strict; $status{have} = ${"${modname}::VERSION"} }) {
      # Don't try to load if it's already loaded
  
    } else {
      my $pm_info = Module::Metadata->new_from_module( $modname );
      unless (defined( $pm_info )) {
        @status{ qw(have message) } = ('<none>', "$modname is not installed");
        return \%status;
      }
  
      $status{have} = eval { $pm_info->version() };
      if ($spec and !defined($status{have})) {
        @status{ qw(have message) } = (undef, "Couldn't find a \$VERSION in prerequisite $modname");
        return \%status;
      }
    }
  
    my @conditions = $self->_parse_conditions($spec);
  
    foreach (@conditions) {
      my ($op, $version) = /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x
        or die "Invalid prerequisite condition '$_' for $modname";
  
      $version = $self->perl_version_to_float($version)
        if $modname eq 'perl';
  
      next if $op eq '>=' and !$version;  # Module doesn't have to actually define a $VERSION
  
      unless ($self->compare_versions( $status{have}, $op, $version )) {
        $status{message} = "$modname ($status{have}) is installed, but we need version $op $version";
        return \%status;
      }
    }
  
    $status{ok} = 1;
    return \%status;
  }
  
  sub compare_versions {
    my $self = shift;
    my ($v1, $op, $v2) = @_;
    $v1 = version->new($v1)
      unless eval { $v1->isa('version') };
  
    my $eval_str = "\$v1 $op \$v2";
    my $result   = eval $eval_str;
    $self->log_warn("error comparing versions: '$eval_str' $@") if $@;
  
    return $result;
  }
  
  # I wish I could set $! to a string, but I can't, so I use $@
  sub check_installed_version {
    my ($self, $modname, $spec) = @_;
  
    my $status = $self->check_installed_status($modname, $spec);
  
    if ($status->{ok}) {
      return $status->{have} if $status->{have} and "$status->{have}" ne '<none>';
      return '0 but true';
    }
  
    $@ = $status->{message};
    return 0;
  }
  
  sub make_executable {
    # Perl's chmod() is mapped to useful things on various non-Unix
    # platforms, so we use it in the base class even though it looks
    # Unixish.
  
    my $self = shift;
    foreach (@_) {
      my $current_mode = (stat $_)[2];
      chmod $current_mode | oct(111), $_;
    }
  }
  
  sub is_executable {
    # We assume this does the right thing on generic platforms, though
    # we do some other more specific stuff on Unixish platforms.
    my ($self, $file) = @_;
    return -x $file;
  }
  
  sub _startperl { shift()->config('startperl') }
  
  # Return any directories in @INC which are not in the default @INC for
  # this perl.  For example, stuff passed in with -I or loaded with "use lib".
  sub _added_to_INC {
    my $self = shift;
  
    my %seen;
    $seen{$_}++ foreach $self->_default_INC;
    return grep !$seen{$_}++, @INC;
  }
  
  # Determine the default @INC for this Perl
  {
    my @default_inc; # Memoize
    sub _default_INC {
      my $self = shift;
      return @default_inc if @default_inc;
  
      local $ENV{PERL5LIB};  # this is not considered part of the default.
  
      my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
  
      my @inc = $self->_backticks($perl, '-le', 'print for @INC');
      chomp @inc;
  
      return @default_inc = @inc;
    }
  }
  
  sub print_build_script {
    my ($self, $fh) = @_;
  
    my $build_package = $self->build_class;
  
    my $closedata="";
  
    my $config_requires;
    if ( -f $self->metafile ) {
      my $meta = eval { $self->read_metafile( $self->metafile ) };
      $config_requires = $meta && $meta->{prereqs}{configure}{requires}{'Module::Build'};
    }
    $config_requires ||= 0;
  
    my %q = map {$_, $self->$_()} qw(config_dir base_dir);
  
    $q{base_dir} = Win32::GetShortPathName($q{base_dir}) if $self->is_windowsish;
  
    $q{magic_numfile} = $self->config_file('magicnum');
  
    my @myINC = $self->_added_to_INC;
    for (@myINC, values %q) {
      $_ = File::Spec->canonpath( $_ ) unless $self->is_vmsish;
      s/([\\\'])/\\$1/g;
    }
  
    my $quoted_INC = join ",\n", map "     '$_'", @myINC;
    my $shebang = $self->_startperl;
    my $magic_number = $self->magic_number;
  
  my $dot_in_inc_code = $INC[-1] eq '.' ? <<'END' : '';
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
    print $fh <<EOF;
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  }
  
  sub create_mymeta {
    my ($self) = @_;
  
    my ($meta_obj, $mymeta);
    my @metafiles = ( $self->metafile2, $self->metafile,  );
    my @mymetafiles = ( $self->mymetafile2, $self->mymetafile, );
  
    # cleanup old MYMETA
    for my $f ( @mymetafiles ) {
      if ( $self->delete_filetree($f) ) {
        $self->log_verbose("Removed previous '$f'\n");
      }
    }
  
    # Try loading META.json or META.yml
    if ( $self->try_require("CPAN::Meta", "2.142060") ) {
      for my $file ( @metafiles ) {
        next unless -f $file;
        $meta_obj = eval { CPAN::Meta->load_file($file, { lazy_validation => 0 }) };
        last if $meta_obj;
      }
    }
  
    # maybe get a copy in spec v2 format (regardless of original source)
  
    my $mymeta_obj;
    if ($meta_obj) {
      # if we have metadata, just update it
      my %updated = (
        %{ $meta_obj->as_struct({ version => 2.0 }) },
        prereqs => $self->_normalize_prereqs,
        dynamic_config => 0,
        generated_by => "Module::Build version $Module::Build::VERSION",
      );
      $mymeta_obj = CPAN::Meta->new( \%updated, { lazy_validation => 0 } );
    }
    else {
      $mymeta_obj = $self->_get_meta_object(quiet => 0, dynamic => 0, fatal => 1, auto => 0);
    }
  
    my @created = $self->_write_meta_files( $mymeta_obj, 'MYMETA' );
  
    $self->log_warn("Could not create MYMETA files\n")
      unless @created;
  
    return 1;
  }
  
  sub create_build_script {
    my ($self) = @_;
  
    $self->write_config;
    $self->create_mymeta;
  
    # Create Build
    my ($build_script, $dist_name, $dist_version)
      = map $self->$_(), qw(build_script dist_name dist_version);
  
    if ( $self->delete_filetree($build_script) ) {
      $self->log_verbose("Removed previous script '$build_script'\n");
    }
  
    $self->log_info("Creating new '$build_script' script for ",
                    "'$dist_name' version '$dist_version'\n");
    open(my $fh, '>', $build_script) or die "Can't create '$build_script': $!";
    $self->print_build_script($fh);
    close $fh;
  
    $self->make_executable($build_script);
  
    return 1;
  }
  
  sub check_manifest {
    my $self = shift;
    return unless -e 'MANIFEST';
  
    # Stolen nearly verbatim from MakeMaker.  But ExtUtils::Manifest
    # could easily be re-written into a modern Perl dialect.
  
    require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
    local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
  
    $self->log_verbose("Checking whether your kit is complete...\n");
    if (my @missed = ExtUtils::Manifest::manicheck()) {
      $self->log_warn("WARNING: the following files are missing in your kit:\n",
                      "\t", join("\n\t", @missed), "\n",
                      "Please inform the author.\n\n");
    } else {
      $self->log_verbose("Looks good\n\n");
    }
  }
  
  sub dispatch {
    my $self = shift;
    local $self->{_completed_actions} = {};
  
    if (@_) {
      my ($action, %p) = @_;
      my $args = $p{args} ? delete($p{args}) : {};
  
      local $self->{invoked_action} = $action;
      local $self->{args} = {%{$self->{args}}, %$args};
      local $self->{properties} = {%{$self->{properties}}, %p};
      return $self->_call_action($action);
    }
  
    die "No build action specified" unless $self->{action};
    local $self->{invoked_action} = $self->{action};
    $self->_call_action($self->{action});
  }
  
  sub _call_action {
    my ($self, $action) = @_;
  
    return if $self->{_completed_actions}{$action}++;
  
    local $self->{action} = $action;
    my $method = $self->can_action( $action );
    die "No action '$action' defined, try running the 'help' action.\n" unless $method;
    $self->log_debug("Starting ACTION_$action\n");
    my $rc = $self->$method();
    $self->log_debug("Finished ACTION_$action\n");
    return $rc;
  }
  
  sub can_action {
    my ($self, $action) = @_;
    return $self->can( "ACTION_$action" );
  }
  
  # cuts the user-specified options out of the command-line args
  sub cull_options {
      my $self = shift;
      my (@argv) = @_;
  
      # XXX is it even valid to call this as a class method?
      return({}, @argv) unless(ref($self)); # no object
  
      my $specs = $self->get_options;
      return({}, @argv) unless($specs and %$specs); # no user options
  
      require Getopt::Long;
      # XXX Should we let Getopt::Long handle M::B's options? That would
      # be easy-ish to add to @specs right here, but wouldn't handle options
      # passed without "--" as M::B currently allows. We might be able to
      # get around this by setting the "prefix_pattern" Configure option.
      my @specs;
      my $args = {};
      # Construct the specifications for GetOptions.
      foreach my $k (sort keys %$specs) {
          my $v = $specs->{$k};
          # Throw an error if specs conflict with our own.
          die "Option specification '$k' conflicts with a " . ref $self
            . " option of the same name"
            if $self->valid_property($k);
          push @specs, $k . (defined $v->{type} ? $v->{type} : '');
          push @specs, $v->{store} if exists $v->{store};
          $args->{$k} = $v->{default} if exists $v->{default};
      }
  
      local @ARGV = @argv; # No other way to dupe Getopt::Long
  
      # Get the options values and return them.
      # XXX Add option to allow users to set options?
      if ( @specs ) {
        Getopt::Long::Configure('pass_through');
        Getopt::Long::GetOptions($args, @specs);
      }
  
      return $args, @ARGV;
  }
  
  sub unparse_args {
    my ($self, $args) = @_;
    my @out;
    foreach my $k (sort keys %$args) {
      my $v = $args->{$k};
      push @out, (ref $v eq 'HASH'  ? map {+"--$k", "$_=$v->{$_}"} sort keys %$v :
                  ref $v eq 'ARRAY' ? map {+"--$k", $_} @$v :
                  ("--$k", $v));
    }
    return @out;
  }
  
  sub args {
      my $self = shift;
      return wantarray ? %{ $self->{args} } : $self->{args} unless @_;
      my $key = shift;
      $self->{args}{$key} = shift if @_;
      return $self->{args}{$key};
  }
  
  # allows select parameters (with underscores) to be spoken with dashes
  # when used as command-line options
  sub _translate_option {
    my $self = shift;
    my $opt  = shift;
  
    (my $tr_opt = $opt) =~ tr/-/_/;
  
    return $tr_opt if grep $tr_opt =~ /^(?:no_?)?$_$/, qw(
      create_license
      create_makefile_pl
      create_readme
      extra_compiler_flags
      extra_linker_flags
      install_base
      install_path
      meta_add
      meta_merge
      test_files
      use_rcfile
      use_tap_harness
      tap_harness_args
      cpan_client
      pureperl_only
      allow_pureperl
    ); # normalize only selected option names
  
    return $opt;
  }
  
  my %singular_argument = map { ($_ => 1) } qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;
  
  sub _read_arg {
    my ($self, $args, $key, $val) = @_;
  
    $key = $self->_translate_option($key);
  
    if ( exists $args->{$key} and not $singular_argument{$key} ) {
      $args->{$key} = [ $args->{$key} ] unless ref $args->{$key};
      push @{$args->{$key}}, $val;
    } else {
      $args->{$key} = $val;
    }
  }
  
  # decide whether or not an option requires/has an operand
  sub _optional_arg {
    my $self = shift;
    my $opt  = shift;
    my $argv = shift;
  
    $opt = $self->_translate_option($opt);
  
    my @bool_opts = qw(
      build_bat
      create_license
      create_readme
      pollute
      quiet
      uninst
      use_rcfile
      verbose
      debug
      sign
      use_tap_harness
      pureperl_only
      allow_pureperl
    );
  
    # inverted boolean options; eg --noverbose or --no-verbose
    # converted to proper name & returned with false value (verbose, 0)
    if ( grep $opt =~ /^no[-_]?$_$/, @bool_opts ) {
      $opt =~ s/^no-?//;
      return ($opt, 0);
    }
  
    # non-boolean option; return option unchanged along with its argument
    return ($opt, shift(@$argv)) unless grep $_ eq $opt, @bool_opts;
  
    # we're punting a bit here, if an option appears followed by a digit
    # we take the digit as the argument for the option. If there is
    # nothing that looks like a digit, we pretend the option is a flag
    # that is being set and has no argument.
    my $arg = 1;
    $arg = shift(@$argv) if @$argv && $argv->[0] =~ /^\d+$/;
  
    return ($opt, $arg);
  }
  
  sub read_args {
    my $self = shift;
  
    (my $args, @_) = $self->cull_options(@_);
    my %args = %$args;
  
    my $opt_re = qr/[\w\-]+/;
  
    my ($action, @argv);
    while (@_) {
      local $_ = shift;
      if ( /^(?:--)?($opt_re)=(.*)$/ ) {
        $self->_read_arg(\%args, $1, $2);
      } elsif ( /^--($opt_re)$/ ) {
        my($opt, $arg) = $self->_optional_arg($1, \@_);
        $self->_read_arg(\%args, $opt, $arg);
      } elsif ( /^($opt_re)$/ and !defined($action)) {
        $action = $1;
      } else {
        push @argv, $_;
      }
    }
    $args{ARGV} = \@argv;
  
    for ('extra_compiler_flags', 'extra_linker_flags') {
      $args{$_} = [ $self->split_like_shell($args{$_}) ] if exists $args{$_};
    }
  
    # Convert to arrays
    for ('include_dirs') {
      $args{$_} = [ $args{$_} ] if exists $args{$_} && !ref $args{$_}
    }
  
    # Hashify these parameters
    for ($self->hash_properties, 'config') {
      next unless exists $args{$_};
      my %hash;
      $args{$_} ||= [];
      $args{$_} = [ $args{$_} ] unless ref $args{$_};
      foreach my $arg ( @{$args{$_}} ) {
        $arg =~ /($opt_re)=(.*)/
          or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";
        $hash{$1} = $2;
      }
      $args{$_} = \%hash;
    }
  
    # De-tilde-ify any path parameters
    for my $key (qw(prefix install_base destdir)) {
      next if !defined $args{$key};
      $args{$key} = $self->_detildefy($args{$key});
    }
  
    for my $key (qw(install_path)) {
      next if !defined $args{$key};
  
      for my $subkey (keys %{$args{$key}}) {
        next if !defined $args{$key}{$subkey};
        my $subkey_ext = $self->_detildefy($args{$key}{$subkey});
        if ( $subkey eq 'html' ) { # translate for compatibility
          $args{$key}{binhtml} = $subkey_ext;
          $args{$key}{libhtml} = $subkey_ext;
        } else {
          $args{$key}{$subkey} = $subkey_ext;
        }
      }
    }
  
    if ($args{makefile_env_macros}) {
      require Module::Build::Compat;
      %args = (%args, Module::Build::Compat->makefile_to_build_macros);
    }
  
    return \%args, $action;
  }
  
  # Default: do nothing.  Overridden for Unix & Windows.
  sub _detildefy {}
  
  
  # merge Module::Build argument lists that have already been parsed
  # by read_args(). Takes two references to option hashes and merges
  # the contents, giving priority to the first.
  sub _merge_arglist {
    my( $self, $opts1, $opts2 ) = @_;
  
    $opts1 ||= {};
    $opts2 ||= {};
    my %new_opts = %$opts1;
    while (my ($key, $val) = each %$opts2) {
      if ( exists( $opts1->{$key} ) ) {
        if ( ref( $val ) eq 'HASH' ) {
          while (my ($k, $v) = each %$val) {
            $new_opts{$key}{$k} = $v unless exists( $opts1->{$key}{$k} );
          }
        }
      } else {
        $new_opts{$key} = $val
      }
    }
  
    return %new_opts;
  }
  
  # Look for a home directory on various systems.
  sub _home_dir {
    my @home_dirs;
    push( @home_dirs, $ENV{HOME} ) if $ENV{HOME};
  
    push( @home_dirs, File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '') )
        if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
  
    my @other_home_envs = qw( USERPROFILE APPDATA WINDIR SYS$LOGIN );
    push( @home_dirs, map $ENV{$_}, grep $ENV{$_}, @other_home_envs );
  
    my @real_home_dirs = grep -d, @home_dirs;
  
    return wantarray ? @real_home_dirs : shift( @real_home_dirs );
  }
  
  sub _find_user_config {
    my $self = shift;
    my $file = shift;
    foreach my $dir ( $self->_home_dir ) {
      my $path = File::Spec->catfile( $dir, $file );
      return $path if -e $path;
    }
    return undef;
  }
  
  # read ~/.modulebuildrc returning global options '*' and
  # options specific to the currently executing $action.
  sub read_modulebuildrc {
    my( $self, $action ) = @_;
  
    return () unless $self->use_rcfile;
  
    my $modulebuildrc;
    if ( exists($ENV{MODULEBUILDRC}) && $ENV{MODULEBUILDRC} eq 'NONE' ) {
      return ();
    } elsif ( exists($ENV{MODULEBUILDRC}) && -e $ENV{MODULEBUILDRC} ) {
      $modulebuildrc = $ENV{MODULEBUILDRC};
    } elsif ( exists($ENV{MODULEBUILDRC}) ) {
      $self->log_warn("WARNING: Can't find resource file " .
                      "'$ENV{MODULEBUILDRC}' defined in environment.\n" .
                      "No options loaded\n");
      return ();
    } else {
      $modulebuildrc = $self->_find_user_config( '.modulebuildrc' );
      return () unless $modulebuildrc;
    }
  
    open(my $fh, '<', $modulebuildrc )
        or die "Can't open $modulebuildrc: $!";
  
    my %options; my $buffer = '';
    while (defined( my $line = <$fh> )) {
      chomp( $line );
      $line =~ s/#.*$//;
      next unless length( $line );
  
      if ( $line =~ /^\S/ ) {
        if ( $buffer ) {
          my( $action, $options ) = split( /\s+/, $buffer, 2 );
          $options{$action} .= $options . ' ';
          $buffer = '';
        }
        $buffer = $line;
      } else {
        $buffer .= $line;
      }
    }
  
    if ( $buffer ) { # anything left in $buffer ?
      my( $action, $options ) = split( /\s+/, $buffer, 2 );
      $options{$action} .= $options . ' '; # merge if more than one line
    }
  
    my ($global_opts) =
      $self->read_args( $self->split_like_shell( $options{'*'} || '' ) );
  
    # let fakeinstall act like install if not provided
    if ( $action eq 'fakeinstall' && ! exists $options{fakeinstall} ) {
      $action = 'install';
    }
    my ($action_opts) =
      $self->read_args( $self->split_like_shell( $options{$action} || '' ) );
  
    # specific $action options take priority over global options '*'
    return $self->_merge_arglist( $action_opts, $global_opts );
  }
  
  # merge the relevant options in ~/.modulebuildrc into Module::Build's
  # option list where they do not conflict with commandline options.
  sub merge_modulebuildrc {
    my( $self, $action, %cmdline_opts ) = @_;
    my %rc_opts = $self->read_modulebuildrc( $action || $self->{action} || 'build' );
    my %new_opts = $self->_merge_arglist( \%cmdline_opts, \%rc_opts );
    $self->merge_args( $action, %new_opts );
  }
  
  sub merge_args {
    my ($self, $action, %args) = @_;
    $self->{action} = $action if defined $action;
  
    my %additive = map { $_ => 1 } $self->hash_properties;
  
    # Extract our 'properties' from $cmd_args, the rest are put in 'args'.
    while (my ($key, $val) = each %args) {
      $self->{phash}{runtime_params}->access( $key => $val )
        if $self->valid_property($key);
  
      if ($key eq 'config') {
        $self->config($_ => $val->{$_}) foreach keys %$val;
      } else {
        my $add_to = $additive{$key}             ? $self->{properties}{$key} :
                     $self->valid_property($key) ? $self->{properties}       :
                     $self->{args}               ;
  
        if ($additive{$key}) {
          $add_to->{$_} = $val->{$_} foreach keys %$val;
        } else {
          $add_to->{$key} = $val;
        }
      }
    }
  }
  
  sub cull_args {
    my $self = shift;
    my @arg_list = @_;
    unshift @arg_list, $self->split_like_shell($ENV{PERL_MB_OPT})
      if $ENV{PERL_MB_OPT};
    my ($args, $action) = $self->read_args(@arg_list);
    $self->merge_args($action, %$args);
    $self->merge_modulebuildrc( $action, %$args );
  }
  
  sub super_classes {
    my ($self, $class, $seen) = @_;
    $class ||= ref($self) || $self;
    $seen  ||= {};
  
    no strict 'refs';
    my @super = grep {not $seen->{$_}++} $class, @{ $class . '::ISA' };
    return @super, map {$self->super_classes($_,$seen)} @super;
  }
  
  sub known_actions {
    my ($self) = @_;
  
    my %actions;
    no strict 'refs';
  
    foreach my $class ($self->super_classes) {
      foreach ( keys %{ $class . '::' } ) {
        $actions{$1}++ if /^ACTION_(\w+)/;
      }
    }
  
    return wantarray ? sort keys %actions : \%actions;
  }
  
  sub get_action_docs {
    my ($self, $action) = @_;
    my $actions = $self->known_actions;
    die "No known action '$action'" unless $actions->{$action};
  
    my ($files_found, @docs) = (0);
    foreach my $class ($self->super_classes) {
      (my $file = $class) =~ s{::}{/}g;
      # NOTE: silently skipping relative paths if any chdir() happened
      $file = $INC{$file . '.pm'} or next;
      open(my $fh, '<', $file) or next;
      $files_found++;
  
      # Code below modified from /usr/bin/perldoc
  
      # Skip to ACTIONS section
      local $_;
      while (<$fh>) {
        last if /^=head1 ACTIONS\s/;
      }
  
      # Look for our action and determine the style
      my $style;
      while (<$fh>) {
        last if /^=head1 /;
  
        # only item and head2 are allowed (3&4 are not in 5.005)
        if(/^=(item|head2)\s+\Q$action\E\b/) {
          $style = $1;
          push @docs, $_;
          last;
        }
      }
      $style or next; # not here
  
      # and the content
      if($style eq 'item') {
        my ($found, $inlist) = (0, 0);
        while (<$fh>) {
          if (/^=(item|back)/) {
            last unless $inlist;
          }
          push @docs, $_;
          ++$inlist if /^=over/;
          --$inlist if /^=back/;
        }
      }
      else { # head2 style
        # stop at anything equal or greater than the found level
        while (<$fh>) {
          last if(/^=(?:head[12]|cut)/);
          push @docs, $_;
        }
      }
      # TODO maybe disallow overriding just pod for an action
      # TODO and possibly: @docs and last;
    }
  
    unless ($files_found) {
      $@ = "Couldn't find any documentation to search";
      return;
    }
    unless (@docs) {
      $@ = "Couldn't find any docs for action '$action'";
      return;
    }
  
    return join '', @docs;
  }
  
  sub ACTION_prereq_report {
    my $self = shift;
    $self->log_info( $self->prereq_report );
  }
  
  sub ACTION_prereq_data {
    my $self = shift;
    $self->log_info( Module::Build::Dumper->_data_dump( $self->prereq_data ) );
  }
  
  sub prereq_data {
    my $self = shift;
    my @types = ('configure_requires', @{ $self->prereq_action_types } );
    my $info = { map { $_ => $self->$_() } grep { %{$self->$_()} } @types };
    return $info;
  }
  
  sub prereq_report {
    my $self = shift;
    my $info = $self->prereq_data;
  
    my $output = '';
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      $output .= "\n$type:\n";
      my $mod_len = 2;
      my $ver_len = 4;
      my %mods;
      foreach my $modname (sort keys %$prereqs) {
        my $spec = $prereqs->{$modname};
        my $len  = length $modname;
        $mod_len = $len if $len > $mod_len;
        $spec    ||= '0';
        $len     = length $spec;
        $ver_len = $len if $len > $ver_len;
  
        my $mod = $self->check_installed_status($modname, $spec);
        $mod->{name} = $modname;
        $mod->{ok} ||= 0;
        $mod->{ok} = ! $mod->{ok} if $type =~ /^(\w+_)?conflicts$/;
  
        $mods{lc $modname} = $mod;
      }
  
      my $space  = q{ } x ($mod_len - 3);
      my $vspace = q{ } x ($ver_len - 3);
      my $sline  = q{-} x ($mod_len - 3);
      my $vline  = q{-} x ($ver_len - 3);
      my $disposition = ($type =~ /^(\w+_)?conflicts$/) ?
                          'Clash' : 'Need';
      $output .=
        "    Module $space  $disposition $vspace  Have\n".
        "    ------$sline+------$vline-+----------\n";
  
  
      for my $k (sort keys %mods) {
        my $mod = $mods{$k};
        my $space  = q{ } x ($mod_len - length $k);
        my $vspace = q{ } x ($ver_len - length $mod->{need});
        my $f = $mod->{ok} ? ' ' : '!';
        $output .=
          "  $f $mod->{name} $space     $mod->{need}  $vspace   ".
          (defined($mod->{have}) ? $mod->{have} : "")."\n";
      }
    }
    return $output;
  }
  
  sub ACTION_help {
    my ($self) = @_;
    my $actions = $self->known_actions;
  
    if (@{$self->{args}{ARGV}}) {
      my $msg = eval {$self->get_action_docs($self->{args}{ARGV}[0], $actions)};
      print $@ ? "$@\n" : $msg;
      return;
    }
  
    print <<EOF;
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  
    print $self->_action_listing($actions);
  
    print "\nRun `Build help <action>` for details on an individual action.\n";
    print "See `perldoc Module::Build` for complete documentation.\n";
  }
  
  sub _action_listing {
    my ($self, $actions) = @_;
  
    # Flow down columns, not across rows
    my @actions = sort keys %$actions;
    @actions = map $actions[($_ + ($_ % 2) * @actions) / 2],  0..$#actions;
  
    my $out = '';
    while (my ($one, $two) = splice @actions, 0, 2) {
      $out .= sprintf("  %-12s                   %-12s\n", $one, $two||'');
    }
    $out =~ s{\s*$}{}mg; # remove trailing spaces
    return $out;
  }
  
  sub ACTION_retest {
    my ($self) = @_;
  
    # Protect others against our @INC changes
    local @INC = @INC;
  
    # Filter out nonsensical @INC entries - some versions of
    # Test::Harness will really explode the number of entries here
    @INC = grep {ref() || -d} @INC if @INC > 100;
  
    $self->do_tests;
  }
  
  sub ACTION_testall {
    my ($self) = @_;
  
    my @types;
    for my $action (grep { $_ ne 'all' } $self->get_test_types) {
      # XXX We can't just dispatch because we get multiple summaries but
      # we'll need to dispatch to support custom setup/teardown in the
      # action.  To support that, we'll need to call something besides
      # Harness::runtests() because we'll need to collect the results in
      # parts, then run the summary.
      push(@types, $action);
      #$self->_call_action( "test$action" );
    }
    $self->generic_test(types => ['default', @types]);
  }
  
  sub get_test_types {
    my ($self) = @_;
  
    my $t = $self->{properties}->{test_types};
    return ( defined $t ? ( wantarray ? sort keys %$t : keys %$t ) : () );
  }
  
  
  sub ACTION_test {
    my ($self) = @_;
    $self->generic_test(type => 'default');
  }
  
  sub generic_test {
    my $self = shift;
    (@_ % 2) and croak('Odd number of elements in argument hash');
    my %args = @_;
  
    my $p = $self->{properties};
  
    my @types = (
      (exists($args{type})  ? $args{type} : ()),
      (exists($args{types}) ? @{$args{types}} : ()),
    );
    @types or croak "need some types of tests to check";
  
    my %test_types = (
      default => $p->{test_file_exts},
      (defined($p->{test_types}) ? %{$p->{test_types}} : ()),
    );
  
    for my $type (@types) {
      croak "$type not defined in test_types!"
        unless defined $test_types{ $type };
    }
  
    # we use local here because it ends up two method calls deep
    local $p->{test_file_exts} = [ map { ref $_ ? @$_ : $_ } @test_types{@types} ];
    $self->depends_on('code');
  
    # Protect others against our @INC changes
    local @INC = @INC;
  
    # Make sure we test the module in blib/
    unshift @INC, (File::Spec->catdir($p->{base_dir}, $self->blib, 'lib'),
                   File::Spec->catdir($p->{base_dir}, $self->blib, 'arch'));
  
    # Filter out nonsensical @INC entries - some versions of
    # Test::Harness will really explode the number of entries here
    @INC = grep {ref() || -d} @INC if @INC > 100;
  
    $self->do_tests;
  }
  
  # Test::Harness dies on failure but TAP::Harness does not, so we must
  # die if running under TAP::Harness
  sub do_tests {
    my $self = shift;
  
    my $tests = $self->find_test_files;
  
    local $ENV{PERL_DL_NONLAZY} = 1;
  
    if(@$tests) {
      my $args = $self->tap_harness_args;
      if($self->use_tap_harness or ($args and %$args)) {
        my $aggregate = $self->run_tap_harness($tests);
        if ( $aggregate->has_errors ) {
          die "Errors in testing.  Cannot continue.\n";
        }
      }
      else {
        $self->run_test_harness($tests);
      }
    }
    else {
      $self->log_info("No tests defined.\n");
    }
  
    $self->run_visual_script;
  }
  
  sub run_tap_harness {
    my ($self, $tests) = @_;
  
    require TAP::Harness::Env;
  
    # TODO allow the test @INC to be set via our API?
  
    my $aggregate = TAP::Harness::Env->create({
      lib => [@INC],
      verbosity => $self->{properties}{verbose},
      switches  => [ $self->harness_switches ],
      %{ $self->tap_harness_args },
    })->runtests(@$tests);
  
    return $aggregate;
  }
  
  sub run_test_harness {
      my ($self, $tests) = @_;
      require Test::Harness;
  
      local $Test::Harness::verbose = $self->verbose || 0;
      local $Test::Harness::switches = join ' ', $self->harness_switches;
  
      Test::Harness::runtests(@$tests);
  }
  
  sub run_visual_script {
      my $self = shift;
      # This will get run and the user will see the output.  It doesn't
      # emit Test::Harness-style output.
      $self->run_perl_script('visual.pl', '-Mblib='.$self->blib)
          if -e 'visual.pl';
  }
  
  sub harness_switches {
      my $self = shift;
      my @res;
      push @res, qw(-w -d) if $self->{properties}{debugger};
      push @res, '-MDevel::Cover' if $self->{properties}{cover};
      return @res;
  }
  
  sub test_files {
    my $self = shift;
    my $p = $self->{properties};
    if (@_) {
      return $p->{test_files} = (@_ == 1 ? shift : [@_]);
    }
    return $self->find_test_files;
  }
  
  sub expand_test_dir {
    my ($self, $dir) = @_;
    my $exts = $self->{properties}{test_file_exts};
  
    return sort map { @{$self->rscan_dir($dir, qr{^[^.].*\Q$_\E$})} } @$exts
      if $self->recursive_test_files;
  
    return sort map { glob File::Spec->catfile($dir, "*$_") } @$exts;
  }
  
  sub ACTION_testdb {
    my ($self) = @_;
    local $self->{properties}{debugger} = 1;
    $self->depends_on('test');
  }
  
  sub ACTION_testcover {
    my ($self) = @_;
  
    unless (Module::Metadata->find_module_by_name('Devel::Cover')) {
      warn("Cannot run testcover action unless Devel::Cover is installed.\n");
      return;
    }
  
    $self->add_to_cleanup('coverage', 'cover_db');
    $self->depends_on('code');
  
    # See whether any of the *.pm files have changed since last time
    # testcover was run.  If so, start over.
    if (-e 'cover_db') {
      my $pm_files = $self->rscan_dir
          (File::Spec->catdir($self->blib, 'lib'), $self->file_qr('\.pm$') );
      my $cover_files = $self->rscan_dir('cover_db', sub {-f $_ and not /\.html$/});
  
      $self->do_system(qw(cover -delete))
        unless $self->up_to_date($pm_files,         $cover_files)
            && $self->up_to_date($self->test_files, $cover_files);
    }
  
    local $self->{properties}{cover} = 1;
    $self->depends_on('test');
    $self->do_system('cover');
  }
  
  sub ACTION_code {
    my ($self) = @_;
  
    # All installable stuff gets created in blib/ .
    # Create blib/arch to keep blib.pm happy
    my $blib = $self->blib;
    $self->add_to_cleanup($blib);
    File::Path::mkpath( File::Spec->catdir($blib, 'arch') );
  
    if (my $split = $self->autosplit) {
      $self->autosplit_file($_, $blib) for ref($split) ? @$split : ($split);
    }
  
    foreach my $element (@{$self->build_elements}) {
      my $method = "process_${element}_files";
      $method = "process_files_by_extension" unless $self->can($method);
      $self->$method($element);
    }
  
    $self->depends_on('config_data');
  }
  
  sub ACTION_build {
    my $self = shift;
    $self->log_info("Building " . $self->dist_name . "\n");
    $self->depends_on('code');
    $self->depends_on('docs');
  }
  
  sub process_files_by_extension {
    my ($self, $ext) = @_;
  
    my $method = "find_${ext}_files";
    my $files = $self->can($method) ? $self->$method() : $self->_find_file_by_type($ext,  'lib');
  
    foreach my $file (sort keys %$files) {
      $self->copy_if_modified(from => $file, to => File::Spec->catfile($self->blib, $files->{$file}) );
    }
  }
  
  sub process_support_files {
    my $self = shift;
    my $p = $self->{properties};
    return unless $p->{c_source};
  
    my $files;
    if (ref($p->{c_source}) eq "ARRAY") {
        push @{$p->{include_dirs}}, @{$p->{c_source}};
        for my $path (@{$p->{c_source}}) {
            push @$files, @{ $self->rscan_dir($path, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$')) };
        }
    } else {
        push @{$p->{include_dirs}}, $p->{c_source};
        $files = $self->rscan_dir($p->{c_source}, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$'));
    }
  
    foreach my $file (@$files) {
        push @{$p->{objects}}, $self->compile_c($file);
    }
  }
  
  sub process_share_dir_files {
    my $self = shift;
    my $files = $self->_find_share_dir_files;
    return unless $files;
  
    # root for all File::ShareDir paths
    my $share_prefix = File::Spec->catdir($self->blib, qw/lib auto share/);
  
    # copy all share files to blib
    foreach my $file (sort keys %$files) {
      $self->copy_if_modified(
        from => $file, to => File::Spec->catfile( $share_prefix, $files->{$file} )
      );
    }
  }
  
  sub _find_share_dir_files {
    my $self = shift;
    my $share_dir = $self->share_dir;
    return unless $share_dir;
  
    my @file_map;
    if ( $share_dir->{dist} ) {
      my $prefix = "dist/".$self->dist_name;
      push @file_map, $self->_share_dir_map( $prefix, $share_dir->{dist} );
    }
  
    if ( $share_dir->{module} ) {
      for my $mod ( sort keys %{ $share_dir->{module} } ) {
        (my $altmod = $mod) =~ s{::}{-}g;
        my $prefix = "module/$altmod";
        push @file_map, $self->_share_dir_map($prefix, $share_dir->{module}{$mod});
      }
    }
  
    return { @file_map };
  }
  
  sub _share_dir_map {
    my ($self, $prefix, $list) = @_;
    my %files;
    for my $dir ( @$list ) {
      for my $f ( @{ $self->rscan_dir( $dir, sub {-f} )} ) {
        $f =~ s{\A.*?\Q$dir\E/}{};
        $files{"$dir/$f"} = "$prefix/$f";
      }
    }
    return %files;
  }
  
  sub process_PL_files {
    my ($self) = @_;
    my $files = $self->find_PL_files;
  
    foreach my $file (sort keys %$files) {
      my $to = $files->{$file};
      unless ($self->up_to_date( $file, $to )) {
        $self->run_perl_script($file, [], [@$to]) or die "$file failed";
        $self->add_to_cleanup(@$to);
      }
    }
  }
  
  sub process_xs_files {
    my $self = shift;
    return if $self->pureperl_only && $self->allow_pureperl;
    my $files = $self->find_xs_files;
    croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;
    foreach my $from (sort keys %$files) {
      my $to = $files->{$from};
      unless ($from eq $to) {
        $self->add_to_cleanup($to);
        $self->copy_if_modified( from => $from, to => $to );
      }
      $self->process_xs($to);
    }
  }
  
  sub process_pod_files { shift()->process_files_by_extension(shift()) }
  sub process_pm_files  { shift()->process_files_by_extension(shift()) }
  
  sub process_script_files {
    my $self = shift;
    my $files = $self->find_script_files;
    return unless keys %$files;
  
    my $script_dir = File::Spec->catdir($self->blib, 'script');
    File::Path::mkpath( $script_dir );
  
    foreach my $file (sort keys %$files) {
      my $result = $self->copy_if_modified($file, $script_dir, 'flatten') or next;
      $self->fix_shebang_line($result) unless $self->is_vmsish;
      $self->make_executable($result);
    }
  }
  
  sub find_PL_files {
    my $self = shift;
    if (my $files = $self->{properties}{PL_files}) {
      # 'PL_files' is given as a Unix file spec, so we localize_file_path().
  
      if (ref $files eq 'ARRAY') {
        return { map {$_, [/^(.*)\.PL$/]}
                 map $self->localize_file_path($_),
                 @$files };
  
      } elsif (ref $files eq 'HASH') {
        my %out;
        while (my ($file, $to) = each %$files) {
          $out{ $self->localize_file_path($file) } = [ map $self->localize_file_path($_),
                                                       ref $to ? @$to : ($to) ];
        }
        return \%out;
  
      } else {
        die "'PL_files' must be a hash reference or array reference";
      }
    }
  
    return unless -d 'lib';
    return {
      map {$_, [/^(.*)\.PL$/i ]}
      @{ $self->rscan_dir('lib', $self->file_qr('\.PL$')) }
    };
  }
  
  sub find_pm_files  { shift->_find_file_by_type('pm',  'lib') }
  sub find_pod_files { shift->_find_file_by_type('pod', 'lib') }
  sub find_xs_files  { shift->_find_file_by_type('xs',  'lib') }
  
  sub find_script_files {
    my $self = shift;
    if (my $files = $self->script_files) {
      # Always given as a Unix file spec.  Values in the hash are
      # meaningless, but we preserve if present.
      return { map {$self->localize_file_path($_), $files->{$_}} keys %$files };
    }
  
    # No default location for script files
    return {};
  }
  
  sub find_test_files {
    my $self = shift;
    my $p = $self->{properties};
  
    if (my $files = $p->{test_files}) {
      $files = [sort keys %$files] if ref $files eq 'HASH';
      $files = [map { -d $_ ? $self->expand_test_dir($_) : $_ }
                map glob,
                $self->split_like_shell($files)];
  
      # Always given as a Unix file spec.
      return [ map $self->localize_file_path($_), @$files ];
  
    } else {
      # Find all possible tests in t/ or test.pl
      my @tests;
      push @tests, 'test.pl'                          if -e 'test.pl';
      push @tests, $self->expand_test_dir('t')        if -e 't' and -d _;
      return \@tests;
    }
  }
  
  sub _find_file_by_type {
    my ($self, $type, $dir) = @_;
  
    if (my $files = $self->{properties}{"${type}_files"}) {
      # Always given as a Unix file spec
      return { map $self->localize_file_path($_), %$files };
    }
  
    return {} unless -d $dir;
    return { map {$_, $_}
             map $self->localize_file_path($_),
             grep !/\.\#/,
             @{ $self->rscan_dir($dir, $self->file_qr("\\.$type\$")) } };
  }
  
  sub localize_file_path {
    my ($self, $path) = @_;
    return File::Spec->catfile( split m{/}, $path );
  }
  
  sub localize_dir_path {
    my ($self, $path) = @_;
    return File::Spec->catdir( split m{/}, $path );
  }
  
  sub fix_shebang_line { # Adapted from fixin() in ExtUtils::MM_Unix 1.35
    my ($self, @files) = @_;
    my $c = ref($self) ? $self->{config} : 'Module::Build::Config';
  
    my ($does_shbang) = $c->get('sharpbang') =~ /^\s*\#\!/;
    for my $file (@files) {
      open(my $FIXIN, '<', $file) or die "Can't process '$file': $!";
      local $/ = "\n";
      chomp(my $line = <$FIXIN>);
      next unless $line =~ s/^\s*\#!\s*//;     # Not a shebang file.
  
      my ($cmd, $arg) = (split(' ', $line, 2), '');
      next unless $cmd =~ /perl/i;
      my $interpreter = $self->{properties}{perl};
  
      $self->log_verbose("Changing sharpbang in $file to $interpreter\n");
      my $shb = '';
      $shb .= $c->get('sharpbang')."$interpreter $arg\n" if $does_shbang;
  
      open(my $FIXOUT, '>', "$file.new")
        or die "Can't create new $file: $!\n";
  
      # Print out the new #! line (or equivalent).
      local $\;
      undef $/; # Was localized above
      print $FIXOUT $shb, <$FIXIN>;
      close $FIXIN;
      close $FIXOUT;
  
      rename($file, "$file.bak")
        or die "Can't rename $file to $file.bak: $!";
  
      rename("$file.new", $file)
        or die "Can't rename $file.new to $file: $!";
  
      $self->delete_filetree("$file.bak")
        or $self->log_warn("Couldn't clean up $file.bak, leaving it there");
  
      $self->do_system($c->get('eunicefix'), $file) if $c->get('eunicefix') ne ':';
    }
  }
  
  
  sub ACTION_testpod {
    my $self = shift;
    $self->depends_on('docs');
  
    eval q{use Test::Pod 0.95; 1}
      or die "The 'testpod' action requires Test::Pod version 0.95";
  
    my @files = sort keys %{$self->_find_pods($self->libdoc_dirs)},
                     keys %{$self->_find_pods
                               ($self->bindoc_dirs,
                                exclude => [ $self->file_qr('\.bat$') ])}
      or die "Couldn't find any POD files to test\n";
  
    { package # hide from PAUSE
        Module::Build::PodTester;  # Don't want to pollute the main namespace
      Test::Pod->import( tests => scalar @files );
      pod_file_ok($_) foreach @files;
    }
  }
  
  sub ACTION_testpodcoverage {
    my $self = shift;
  
    $self->depends_on('docs');
  
    eval q{use Test::Pod::Coverage 1.00; 1}
      or die "The 'testpodcoverage' action requires ",
             "Test::Pod::Coverage version 1.00";
  
    # TODO this needs test coverage!
  
    # XXX work-around a bug in Test::Pod::Coverage previous to v1.09
    # Make sure we test the module in blib/
    local @INC = @INC;
    my $p = $self->{properties};
    unshift(@INC,
      # XXX any reason to include arch?
      File::Spec->catdir($p->{base_dir}, $self->blib, 'lib'),
      #File::Spec->catdir($p->{base_dir}, $self->blib, 'arch')
    );
  
    all_pod_coverage_ok();
  }
  
  sub ACTION_docs {
    my $self = shift;
  
    $self->depends_on('code');
    $self->depends_on('manpages', 'html');
  }
  
  # Given a file type, will return true if the file type would normally
  # be installed when neither install-base nor prefix has been set.
  # I.e. it will be true only if the path is set from Config.pm or
  # set explicitly by the user via install-path.
  sub _is_default_installable {
    my $self = shift;
    my $type = shift;
    return ( $self->install_destination($type) &&
             ( $self->install_path($type) ||
               $self->install_sets($self->installdirs)->{$type} )
           ) ? 1 : 0;
  }
  
  sub _is_ActivePerl {
  #  return 0;
    my $self = shift;
    unless (exists($self->{_is_ActivePerl})) {
      $self->{_is_ActivePerl} = (eval { require ActivePerl::DocTools; } || 0);
    }
    return $self->{_is_ActivePerl};
  }
  
  sub _is_ActivePPM {
  #  return 0;
    my $self = shift;
    unless (exists($self->{_is_ActivePPM})) {
      $self->{_is_ActivePPM} = (eval { require ActivePerl::PPM; } || 0);
    }
    return $self->{_is_ActivePPM};
  }
  
  sub ACTION_manpages {
    my $self = shift;
  
    return unless $self->_mb_feature('manpage_support');
  
    $self->depends_on('code');
  
    my %extra_manify_args = $self->{properties}{'extra_manify_args'} ? %{ $self->{properties}{'extra_manify_args'} } : ();
  
    foreach my $type ( qw(bin lib) ) {
      next unless ( $self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));
      my $files = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
                                     exclude => [ $self->file_qr('\.bat$') ] );
      next unless %$files;
  
      my $sub = $self->can("manify_${type}_pods");
      $self->$sub( %extra_manify_args ) if defined( $sub );
    }
  }
  
  sub manify_bin_pods {
    my $self    = shift;
    my %podman_args = (section =>  1, @_); # binaries go in section 1
  
    my $files   = $self->_find_pods( $self->{properties}{bindoc_dirs},
                                     exclude => [ $self->file_qr('\.bat$') ] );
    return unless keys %$files;
  
    my $mandir = File::Spec->catdir( $self->blib, 'bindoc' );
    File::Path::mkpath( $mandir, 0, oct(777) );
  
    require Pod::Man;
    foreach my $file (sort keys %$files) {
      # Pod::Simple based parsers only support one document per instance.
      # This is expected to change in a future version (Pod::Simple > 3.03).
      my $parser  = Pod::Man->new( %podman_args );
      my $manpage = $self->man1page_name( $file ) . '.' .
                    $self->config( 'man1ext' );
      my $outfile = File::Spec->catfile($mandir, $manpage);
      next if $self->up_to_date( $file, $outfile );
      $self->log_verbose("Manifying $file -> $outfile\n");
      eval { $parser->parse_from_file( $file, $outfile ); 1 }
        or $self->log_warn("Error creating '$outfile': $@\n");
      $files->{$file} = $outfile;
    }
  }
  
  sub manify_lib_pods {
    my $self    = shift;
    my %podman_args = (section => 3, @_); # libraries go in section 3
  
    my $files   = $self->_find_pods($self->{properties}{libdoc_dirs});
    return unless keys %$files;
  
    my $mandir = File::Spec->catdir( $self->blib, 'libdoc' );
    File::Path::mkpath( $mandir, 0, oct(777) );
  
    require Pod::Man;
    foreach my $file (sort keys %$files) {
      # Pod::Simple based parsers only support one document per instance.
      # This is expected to change in a future version (Pod::Simple > 3.03).
      my $parser  = Pod::Man->new( %podman_args );
      my $manpage = $self->man3page_name( $files->{$file} ) . '.' .
                    $self->config( 'man3ext' );
      my $outfile = File::Spec->catfile( $mandir, $manpage);
      next if $self->up_to_date( $file, $outfile );
      $self->log_verbose("Manifying $file -> $outfile\n");
      eval { $parser->parse_from_file( $file, $outfile ); 1 }
        or $self->log_warn("Error creating '$outfile': $@\n");
      $files->{$file} = $outfile;
    }
  }
  
  sub _find_pods {
    my ($self, $dirs, %args) = @_;
    my %files;
    foreach my $spec (@$dirs) {
      my $dir = $self->localize_dir_path($spec);
      next unless -e $dir;
  
      FILE: foreach my $file ( @{ $self->rscan_dir( $dir ) } ) {
        foreach my $regexp ( @{ $args{exclude} } ) {
          next FILE if $file =~ $regexp;
        }
        $file = $self->localize_file_path($file);
        $files{$file} = File::Spec->abs2rel($file, $dir) if $self->contains_pod( $file )
      }
    }
    return \%files;
  }
  
  sub contains_pod {
    my ($self, $file) = @_;
    return '' unless -T $file;  # Only look at text files
  
    open(my $fh, '<', $file ) or die "Can't open $file: $!";
    while (my $line = <$fh>) {
      return 1 if $line =~ /^\=(?:head|pod|item)/;
    }
  
    return '';
  }
  
  sub ACTION_html {
    my $self = shift;
  
    return unless $self->_mb_feature('HTML_support');
  
    $self->depends_on('code');
  
    foreach my $type ( qw(bin lib) ) {
      next unless ( $self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));
      $self->htmlify_pods( $type );
    }
  }
  
  # 1) If it's an ActiveState perl install, we need to run
  #    ActivePerl::DocTools->UpdateTOC;
  # 2) Links to other modules are not being generated
  sub htmlify_pods {
    my $self = shift;
    my $type = shift;
    my $htmldir = shift || File::Spec->catdir($self->blib, "${type}html");
  
    $self->add_to_cleanup('pod2htm*');
  
    my $pods = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
                                  exclude => [ $self->file_qr('\.(?:bat|com|html)$') ] );
    return unless %$pods;  # nothing to do
  
    unless ( -d $htmldir ) {
      File::Path::mkpath($htmldir, 0, oct(755))
        or die "Couldn't mkdir $htmldir: $!";
    }
  
    my @rootdirs = ($type eq 'bin') ? qw(bin) :
        $self->installdirs eq 'core' ? qw(lib) : qw(site lib);
    my $podroot = $ENV{PERL_CORE}
                ? File::Basename::dirname($ENV{PERL_CORE})
                : $self->original_prefix('core');
  
    my $htmlroot = $self->install_sets('core')->{libhtml};
    my $podpath;
    unless (defined $self->args('html_links') and !$self->args('html_links')) {
      my @podpath = ( (map { File::Spec->abs2rel($_ ,$podroot) } grep { -d  }
                       ( $self->install_sets('core', 'lib'), # lib
                         $self->install_sets('core', 'bin'), # bin
                         $self->install_sets('site', 'lib'), # site/lib
                       ) ), File::Spec->rel2abs($self->blib) );
  
      $podpath = $ENV{PERL_CORE}
        ? File::Spec->catdir($podroot, 'lib')
          : join(":", map { tr,:\\,|/,; $_ } @podpath);
    }
  
    my $blibdir = join('/', File::Spec->splitdir(
      (File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),''
    );
  
    my ($with_ActiveState, $htmltool);
  
    if ( $with_ActiveState = $self->_is_ActivePerl
      && eval { require ActivePerl::DocTools::Pod; 1 }
    ) {
      my $tool_v = ActiveState::DocTools::Pod->VERSION;
      $htmltool = "ActiveState::DocTools::Pod";
      $htmltool .= " $tool_v" if $tool_v && length $tool_v;
    }
    else {
        require Module::Build::PodParser;
        require Pod::Html;
      $htmltool = "Pod::Html " .  Pod::Html->VERSION;
    }
    $self->log_verbose("Converting Pod to HTML with $htmltool\n");
  
    my $errors = 0;
  
    POD:
    foreach my $pod ( sort keys %$pods ) {
  
      my ($name, $path) = File::Basename::fileparse($pods->{$pod},
        $self->file_qr('\.(?:pm|plx?|pod)$')
      );
      my @dirs = File::Spec->splitdir( File::Spec->canonpath( $path ) );
      pop( @dirs ) if scalar(@dirs) && $dirs[-1] eq File::Spec->curdir;
  
      my $fulldir = File::Spec->catdir($htmldir, @rootdirs, @dirs);
      my $tmpfile = File::Spec->catfile($fulldir, "${name}.tmp");
      my $outfile = File::Spec->catfile($fulldir, "${name}.html");
      my $infile  = File::Spec->abs2rel($pod);
  
      next if $self->up_to_date($infile, $outfile);
  
      unless ( -d $fulldir ){
        File::Path::mkpath($fulldir, 0, oct(755))
          or die "Couldn't mkdir $fulldir: $!";
      }
  
      $self->log_verbose("HTMLifying $infile -> $outfile\n");
      if ( $with_ActiveState ) {
        my $depth = @rootdirs + @dirs;
        my %opts = ( infile => $infile,
          outfile => $tmpfile,
          ( defined($podpath) ? (podpath => $podpath) : ()),
          podroot => $podroot,
          index => 1,
          depth => $depth,
        );
        eval {
          ActivePerl::DocTools::Pod::pod2html(map { ($_, $opts{$_}) } sort keys %opts);
          1;
        } or $self->log_warn("[$htmltool] pod2html (" .
          join(", ", map { "q{$_} => q{$opts{$_}}" } (sort keys %opts)) . ") failed: $@");
      } else {
        my $path2root = File::Spec->catdir((File::Spec->updir) x @dirs);
        open(my $fh, '<', $infile) or die "Can't read $infile: $!";
        my $abstract = Module::Build::PodParser->new(fh => $fh)->get_abstract();
  
        my $title = join( '::', (@dirs, $name) );
        $title .= " - $abstract" if $abstract;
  
        my @opts = (
          "--title=$title",
          ( defined($podpath) ? "--podpath=$podpath" : ()),
          "--infile=$infile",
          "--outfile=$tmpfile",
          "--podroot=$podroot",
          ($path2root ? "--htmlroot=$path2root" : ()),
        );
  
        unless ( eval{Pod::Html->VERSION(1.12)} ) {
          push( @opts, ('--flush') ); # caching removed in 1.12
        }
  
        if ( eval{Pod::Html->VERSION(1.12)} ) {
          push( @opts, ('--header', '--backlink') );
        } elsif ( eval{Pod::Html->VERSION(1.03)} ) {
          push( @opts, ('--header', '--backlink=Back to Top') );
        }
  
        $self->log_verbose("P::H::pod2html @opts\n");
        {
          my $orig = Cwd::getcwd();
          eval { Pod::Html::pod2html(@opts); 1 }
            or $self->log_warn("[$htmltool] pod2html( " .
            join(", ", map { "q{$_}" } @opts) . ") failed: $@");
          chdir($orig);
        }
      }
      # We now have to cleanup the resulting html file
      if ( ! -r $tmpfile ) {
        $errors++;
        next POD;
      }
      open(my $fh, '<', $tmpfile) or die "Can't read $tmpfile: $!";
      my $html = join('',<$fh>);
      close $fh;
      if (!$self->_is_ActivePerl) {
        # These fixups are already done by AP::DT:P:pod2html
        # The output from pod2html is NOT XHTML!
        # IE6+ will display content that is not valid for DOCTYPE
        $html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;
        $html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;
  
        # IE6+ will not display local HTML files with strict
        # security without this comment
        $html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i;
      }
      # Fixup links that point to our temp blib
      $html =~ s/\Q$blibdir\E//g;
  
      open($fh, '>', $outfile) or die "Can't write $outfile: $!";
      print $fh $html;
      close $fh;
      unlink($tmpfile);
    }
  
    return ! $errors;
  
  }
  
  # Adapted from ExtUtils::MM_Unix
  sub man1page_name {
    my $self = shift;
    return File::Basename::basename( shift );
  }
  
  # Adapted from ExtUtils::MM_Unix and Pod::Man
  # Depending on M::B's dependency policy, it might make more sense to refactor
  # Pod::Man::begin_pod() to extract a name() methods, and use them...
  #    -spurkis
  sub man3page_name {
    my $self = shift;
    my ($vol, $dirs, $file) = File::Spec->splitpath( shift );
    my @dirs = File::Spec->splitdir( File::Spec->canonpath($dirs) );
  
    # Remove known exts from the base name
    $file =~ s/\.p(?:od|m|l)\z//i;
  
    return join( $self->manpage_separator, @dirs, $file );
  }
  
  sub manpage_separator {
    return '::';
  }
  
  # For systems that don't have 'diff' executable, should use Algorithm::Diff
  sub ACTION_diff {
    my $self = shift;
    $self->depends_on('build');
    my $local_lib = File::Spec->rel2abs('lib');
    my @myINC = grep {$_ ne $local_lib} @INC;
  
    # The actual install destination might not be in @INC, so check there too.
    push @myINC, map $self->install_destination($_), qw(lib arch);
  
    my @flags = @{$self->{args}{ARGV}};
    @flags = $self->split_like_shell($self->{args}{flags} || '') unless @flags;
  
    my $installmap = $self->install_map;
    delete $installmap->{read};
    delete $installmap->{write};
  
    my $text_suffix = $self->file_qr('\.(pm|pod)$');
  
    foreach my $localdir (sort keys %$installmap) {
      my @localparts = File::Spec->splitdir($localdir);
      my $files = $self->rscan_dir($localdir, sub {-f});
  
      foreach my $file (@$files) {
        my @parts = File::Spec->splitdir($file);
        @parts = @parts[@localparts .. $#parts]; # Get rid of blib/lib or similar
  
        my $installed = Module::Metadata->find_module_by_name(
                          join('::', @parts), \@myINC );
        if (not $installed) {
          print "Only in lib: $file\n";
          next;
        }
  
        my $status = File::Compare::compare($installed, $file);
        next if $status == 0;  # Files are the same
        die "Can't compare $installed and $file: $!" if $status == -1;
  
        if ($file =~ $text_suffix) {
          $self->do_system('diff', @flags, $installed, $file);
        } else {
          print "Binary files $file and $installed differ\n";
        }
      }
    }
  }
  
  sub ACTION_pure_install {
    shift()->depends_on('install');
  }
  
  sub ACTION_install {
    my ($self) = @_;
    require ExtUtils::Install;
    $self->depends_on('build');
    # RT#63003 suggest that odd circumstances that we might wind up
    # in a different directory than we started, so wrap with _do_in_dir to
    # ensure we get back to where we started; hope this fixes it!
    $self->_do_in_dir( ".", sub {
      ExtUtils::Install::install(
        $self->install_map, $self->verbose, 0, $self->{args}{uninst}||0
      );
    });
    if ($self->_is_ActivePerl && $self->{_completed_actions}{html}) {
      $self->log_info("Building ActivePerl Table of Contents\n");
      eval { ActivePerl::DocTools::WriteTOC(verbose => $self->verbose ? 1 : 0); 1; }
        or $self->log_warn("AP::DT:: WriteTOC() failed: $@");
    }
    if ($self->_is_ActivePPM) {
      # We touch 'lib/perllocal.pod'. There is an existing logic in subroutine _init_db()
      # of 'ActivePerl/PPM/InstallArea.pm' that says that if 'lib/perllocal.pod' has a 'date-last-touched'
      # greater than that of the PPM SQLite databases ('etc/ppm-perl-area.db' and/or
      # 'site/etc/ppm-site-area.db') then the PPM SQLite databases are rebuilt from scratch.
  
      # in the following line, 'perllocal.pod' this is *always* 'lib/perllocal.pod', never 'site/lib/perllocal.pod'
      my $F_perllocal = File::Spec->catfile($self->install_sets('core', 'lib'), 'perllocal.pod');
      my $dt_stamp = time;
  
      $self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");
  
      open my $perllocal, ">>", $F_perllocal;
      close $perllocal;
      utime($dt_stamp, $dt_stamp, $F_perllocal);
    }
  }
  
  sub ACTION_fakeinstall {
    my ($self) = @_;
    require ExtUtils::Install;
    my $eui_version = ExtUtils::Install->VERSION;
    if ( $eui_version < 1.32 ) {
      $self->log_warn(
        "The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n"
        . "(You only have version $eui_version)."
      );
      return;
    }
    $self->depends_on('build');
    ExtUtils::Install::install($self->install_map, !$self->quiet, 1, $self->{args}{uninst}||0);
  }
  
  sub ACTION_versioninstall {
    my ($self) = @_;
  
    die "You must have only.pm 0.25 or greater installed for this operation: $@\n"
      unless eval { require only; 'only'->VERSION(0.25); 1 };
  
    $self->depends_on('build');
  
    my %onlyargs = map {exists($self->{args}{$_}) ? ($_ => $self->{args}{$_}) : ()}
      qw(version versionlib);
    only::install::install(%onlyargs);
  }
  
  sub ACTION_installdeps {
    my ($self) = @_;
  
    # XXX include feature prerequisites as optional prereqs?
  
    my $info = $self->_enum_prereqs;
    if (! $info ) {
      $self->log_info( "No prerequisites detected\n" );
      return;
    }
  
    my $failures = $self->prereq_failures($info);
    if ( ! $failures ) {
      $self->log_info( "All prerequisites satisfied\n" );
      return;
    }
  
    my @install;
    foreach my $type (sort keys %$failures) {
      my $prereqs = $failures->{$type};
      if($type =~ m/^(?:\w+_)?requires$/) {
        push(@install, sort keys %$prereqs);
        next;
      }
      $self->log_info("Checking optional dependencies:\n");
      foreach my $module (sort keys %$prereqs) {
        push(@install, $module) if($self->y_n("Install $module?", 'y'));
      }
    }
  
    return unless @install;
  
    my ($command, @opts) = $self->split_like_shell($self->cpan_client);
  
    # relative command should be relative to our active Perl
    # so we need to locate that command
    if ( ! File::Spec->file_name_is_absolute( $command ) ) {
      # prefer site to vendor to core
      my @loc = ( 'site', 'vendor', '' );
      my @bindirs = File::Basename::dirname($self->perl);
      push @bindirs,
        map {
          ($self->config->{"install${_}bin"}, $self->config->{"install${_}script"})
        } @loc;
      for my $d ( @bindirs ) {
        my $abs_cmd = $self->find_command(File::Spec->catfile( $d, $command ));
        if ( defined $abs_cmd ) {
          $command = $abs_cmd;
          last;
        }
      }
    }
  
    $self->do_system($command, @opts, @install);
  }
  
  sub ACTION_clean {
    my ($self) = @_;
    $self->log_info("Cleaning up build files\n");
    foreach my $item (map glob($_), $self->cleanup) {
      $self->delete_filetree($item);
    }
  }
  
  sub ACTION_realclean {
    my ($self) = @_;
    $self->depends_on('clean');
    $self->log_info("Cleaning up configuration files\n");
    $self->delete_filetree(
      $self->config_dir, $self->mymetafile, $self->mymetafile2, $self->build_script
    );
  }
  
  sub ACTION_ppd {
    my ($self) = @_;
  
    require Module::Build::PPMMaker;
    my $ppd = Module::Build::PPMMaker->new();
    my $file = $ppd->make_ppd(%{$self->{args}}, build => $self);
    $self->add_to_cleanup($file);
  }
  
  sub ACTION_ppmdist {
    my ($self) = @_;
  
    $self->depends_on( 'build' );
  
    my $ppm = $self->ppm_name;
    $self->delete_filetree( $ppm );
    $self->log_info( "Creating $ppm\n" );
    $self->add_to_cleanup( $ppm, "$ppm.tar.gz" );
  
    my %types = ( # translate types/dirs to those expected by ppm
      lib     => 'lib',
      arch    => 'arch',
      bin     => 'bin',
      script  => 'script',
      bindoc  => 'man1',
      libdoc  => 'man3',
      binhtml => undef,
      libhtml => undef,
    );
  
    foreach my $type ($self->install_types) {
      next if exists( $types{$type} ) && !defined( $types{$type} );
  
      my $dir = File::Spec->catdir( $self->blib, $type );
      next unless -e $dir;
  
      my $files = $self->rscan_dir( $dir );
      foreach my $file ( @$files ) {
        next unless -f $file;
        my $rel_file =
          File::Spec->abs2rel( File::Spec->rel2abs( $file ),
                               File::Spec->rel2abs( $dir  ) );
        my $to_file  =
          File::Spec->catfile( $ppm, 'blib',
                              exists( $types{$type} ) ? $types{$type} : $type,
                              $rel_file );
        $self->copy_if_modified( from => $file, to => $to_file );
      }
    }
  
    foreach my $type ( qw(bin lib) ) {
      $self->htmlify_pods( $type, File::Spec->catdir($ppm, 'blib', 'html') );
    }
  
    # create a tarball;
    # the directory tar'ed must be blib so we need to do a chdir first
    my $target = File::Spec->catfile( File::Spec->updir, $ppm );
    $self->_do_in_dir( $ppm, sub { $self->make_tarball( 'blib', $target ) } );
  
    $self->depends_on( 'ppd' );
  
    $self->delete_filetree( $ppm );
  }
  
  sub ACTION_pardist {
    my ($self) = @_;
  
    # Need PAR::Dist
    if ( not eval { require PAR::Dist; PAR::Dist->VERSION(0.17) } ) {
      $self->log_warn(
        "In order to create .par distributions, you need to\n"
        . "install PAR::Dist first."
      );
      return();
    }
  
    $self->depends_on( 'build' );
  
    return PAR::Dist::blib_to_par(
      name => $self->dist_name,
      version => $self->dist_version,
    );
  }
  
  sub ACTION_dist {
    my ($self) = @_;
  
    # MUST dispatch() and not depends_ok() so we generate a clean distdir
    $self->dispatch('distdir');
  
    my $dist_dir = $self->dist_dir;
  
    $self->make_tarball($dist_dir);
    $self->delete_filetree($dist_dir);
  }
  
  sub ACTION_distcheck {
    my ($self) = @_;
  
    $self->_check_manifest_skip unless $self->invoked_action eq 'distclean';
  
    require ExtUtils::Manifest;
    local $^W; # ExtUtils::Manifest is not warnings clean.
    my ($missing, $extra) = ExtUtils::Manifest::fullcheck();
  
    return unless @$missing || @$extra;
  
    my $msg = "MANIFEST appears to be out of sync with the distribution\n";
    if ( $self->invoked_action eq 'distcheck' ) {
      die $msg;
    } else {
      warn $msg;
    }
  }
  
  sub _check_mymeta_skip {
    my $self = shift;
    my $maniskip = shift || 'MANIFEST.SKIP';
  
    require ExtUtils::Manifest;
    local $^W; # ExtUtils::Manifest is not warnings clean.
  
    # older ExtUtils::Manifest had a private _maniskip
    my $skip_factory = ExtUtils::Manifest->can('maniskip')
                    || ExtUtils::Manifest->can('_maniskip');
  
    my $mymetafile = $self->mymetafile;
    # we can't check it, just add it anyway to be safe
    for my $file ( $self->mymetafile, $self->mymetafile2 ) {
      unless ( $skip_factory && $skip_factory->($maniskip)->($file) ) {
        $self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");
        my $safe = quotemeta($file);
        $self->_append_maniskip("^$safe\$", $maniskip);
      }
    }
  }
  
  sub _add_to_manifest {
    my ($self, $manifest, $lines) = @_;
    $lines = [$lines] unless ref $lines;
  
    my $existing_files = $self->_read_manifest($manifest);
    return unless defined( $existing_files );
  
    @$lines = grep {!exists $existing_files->{$_}} @$lines
      or return;
  
    my $mode = (stat $manifest)[2];
    chmod($mode | oct(222), $manifest) or die "Can't make $manifest writable: $!";
  
    open(my $fh, '<', $manifest) or die "Can't read $manifest: $!";
    my $last_line = (<$fh>)[-1] || "\n";
    my $has_newline = $last_line =~ /\n$/;
    close $fh;
  
    open($fh, '>>', $manifest) or die "Can't write to $manifest: $!";
    print $fh "\n" unless $has_newline;
    print $fh map "$_\n", @$lines;
    close $fh;
    chmod($mode, $manifest);
  
    $self->log_verbose(map "Added to $manifest: $_\n", @$lines);
  }
  
  sub _sign_dir {
    my ($self, $dir) = @_;
  
    unless (eval { require Module::Signature; 1 }) {
      $self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");
      return;
    }
  
    # Add SIGNATURE to the MANIFEST
    {
      my $manifest = File::Spec->catfile($dir, 'MANIFEST');
      die "Signing a distribution requires a MANIFEST file" unless -e $manifest;
      $self->_add_to_manifest($manifest, "SIGNATURE    Added here by Module::Build");
    }
  
    # Would be nice if Module::Signature took a directory argument.
  
    $self->_do_in_dir($dir, sub {local $Module::Signature::Quiet = 1; Module::Signature::sign()});
  }
  
  sub _do_in_dir {
    my ($self, $dir, $do) = @_;
  
    my $start_dir = File::Spec->rel2abs($self->cwd);
    chdir $dir or die "Can't chdir() to $dir: $!";
    eval {$do->()};
    my @err = $@ ? ($@) : ();
    chdir $start_dir or push @err, "Can't chdir() back to $start_dir: $!";
    die join "\n", @err if @err;
  }
  
  sub ACTION_distsign {
    my ($self) = @_;
    {
      local $self->{properties}{sign} = 0;  # We'll sign it ourselves
      $self->depends_on('distdir') unless -d $self->dist_dir;
    }
    $self->_sign_dir($self->dist_dir);
  }
  
  sub ACTION_skipcheck {
    my ($self) = @_;
  
    require ExtUtils::Manifest;
    local $^W; # ExtUtils::Manifest is not warnings clean.
    ExtUtils::Manifest::skipcheck();
  }
  
  sub ACTION_distclean {
    my ($self) = @_;
  
    $self->depends_on('realclean');
    $self->depends_on('distcheck');
  }
  
  sub do_create_makefile_pl {
    my $self = shift;
    require Module::Build::Compat;
    $self->log_info("Creating Makefile.PL\n");
    eval { Module::Build::Compat->create_makefile_pl($self->create_makefile_pl, $self, @_) };
    if ( $@ ) {
      1 while unlink 'Makefile.PL';
      die "$@\n";
    }
    $self->_add_to_manifest('MANIFEST', 'Makefile.PL');
  }
  
  sub do_create_license {
    my $self = shift;
    $self->log_info("Creating LICENSE file\n");
  
    if (  ! $self->_mb_feature('license_creation') ) {
      $self->_warn_mb_feature_deps('license_creation');
      die "Aborting.\n";
    }
  
    my $l = $self->license
      or die "Can't create LICENSE file: No license specified\n";
  
    my $license = $self->_software_license_object
      or die << "HERE";
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  
    $self->delete_filetree('LICENSE');
  
    open(my $fh, '>', 'LICENSE')
      or die "Can't write LICENSE file: $!";
    print $fh $license->fulltext;
    close $fh;
  
    $self->_add_to_manifest('MANIFEST', 'LICENSE');
  }
  
  sub do_create_readme {
    my $self = shift;
    $self->delete_filetree('README');
  
    my $docfile = $self->_main_docfile;
    unless ( $docfile ) {
      $self->log_warn(<<EOF);
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
      return;
    }
  
    # work around some odd Pod::Readme->new() failures in test reports by
    # confirming that new() is available
    if ( eval {require Pod::Readme; Pod::Readme->can('new') } ) {
      $self->log_info("Creating README using Pod::Readme\n");
  
      my $parser = Pod::Readme->new;
      $parser->parse_from_file($docfile, 'README', @_);
  
    } elsif ( eval {require Pod::Text; 1} ) {
      $self->log_info("Creating README using Pod::Text\n");
  
      if ( open(my $fh, '>', 'README') ) {
        local $^W = 0;
        no strict "refs";
  
        # work around bug in Pod::Text 3.01, which expects
        # Pod::Simple::parse_file to take input and output filehandles
        # when it actually only takes an input filehandle
  
        my $old_parse_file;
        $old_parse_file = \&{"Pod::Simple::parse_file"}
          and
        local *{"Pod::Simple::parse_file"} = sub {
          my $self = shift;
          $self->output_fh($_[1]) if $_[1];
          $self->$old_parse_file($_[0]);
        }
          if $Pod::Text::VERSION
            == 3.01; # Split line to avoid evil version-finder
  
        Pod::Text::pod2text( $docfile, $fh );
  
        close $fh;
      } else {
        $self->log_warn(
          "Cannot create 'README' file: Can't open file for writing\n" );
        return;
      }
  
    } else {
      $self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");
      return;
    }
  
    $self->_add_to_manifest('MANIFEST', 'README');
  }
  
  sub _main_docfile {
    my $self = shift;
    if ( my $pm_file = $self->dist_version_from ) {
      (my $pod_file = $pm_file) =~ s/.pm$/.pod/;
      return (-e $pod_file ? $pod_file : $pm_file);
    } else {
      return undef;
    }
  }
  
  sub do_create_bundle_inc {
    my $self = shift;
    my $dist_inc = File::Spec->catdir( $self->dist_dir, 'inc' );
    require inc::latest;
    inc::latest->write($dist_inc, @{$self->bundle_inc_preload});
    inc::latest->bundle_module($_, $dist_inc) for @{$self->bundle_inc};
    return 1;
  }
  
  sub ACTION_distdir {
    my ($self) = @_;
  
    if ( @{$self->bundle_inc} && ! $self->_mb_feature('inc_bundling_support') ) {
      $self->_warn_mb_feature_deps('inc_bundling_support');
      die "Aborting.\n";
    }
  
    $self->depends_on('distmeta');
  
    my $dist_files = $self->_read_manifest('MANIFEST')
      or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";
    delete $dist_files->{SIGNATURE};  # Don't copy, create a fresh one
    die "No files found in MANIFEST - try running 'manifest' action?\n"
      unless ($dist_files and keys %$dist_files);
    my $metafile = $self->metafile;
    $self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")
      unless exists $dist_files->{$metafile};
  
    my $dist_dir = $self->dist_dir;
    $self->delete_filetree($dist_dir);
    $self->log_info("Creating $dist_dir\n");
    $self->add_to_cleanup($dist_dir);
  
    foreach my $file (sort keys %$dist_files) {
      next if $file =~ m{^MYMETA\.}; # Double check that we skip MYMETA.*
      my $new = $self->copy_if_modified(from => $file, to_dir => $dist_dir, verbose => 0);
    }
  
    $self->do_create_bundle_inc if @{$self->bundle_inc};
  
    $self->_sign_dir($dist_dir) if $self->{properties}{sign};
  }
  
  sub ACTION_disttest {
    my ($self) = @_;
  
    $self->depends_on('distdir');
  
    $self->_do_in_dir
      ( $self->dist_dir,
        sub {
          local $ENV{AUTHOR_TESTING}  = 1;
          local $ENV{RELEASE_TESTING} = 1;
  
          # XXX could be different names for scripts
  
          $self->run_perl_script('Build.PL') # XXX Should this be run w/ --nouse-rcfile
            or die "Error executing 'Build.PL' in dist directory: $!";
          $self->run_perl_script($self->build_script)
            or die "Error executing $self->build_script in dist directory: $!";
          $self->run_perl_script($self->build_script, [], ['test'])
            or die "Error executing 'Build test' in dist directory";
        });
  }
  
  sub ACTION_distinstall {
    my ($self, @args) = @_;
  
    $self->depends_on('distdir');
  
    $self->_do_in_dir ( $self->dist_dir,
      sub {
        $self->run_perl_script('Build.PL')
          or die "Error executing 'Build.PL' in dist directory: $!";
        $self->run_perl_script($self->build_script)
          or die "Error executing $self->build_script in dist directory: $!";
        $self->run_perl_script($self->build_script, [], ['install'])
          or die "Error executing 'Build install' in dist directory";
      }
    );
  }
  
  =begin private
  
    my $has_include = $build->_eumanifest_has_include;
  
  Returns true if the installed version of ExtUtils::Manifest supports
  #include and #include_default directives.  False otherwise.
  
  =end private
  
  =cut
  
  # #!include and #!include_default were added in 1.50
  sub _eumanifest_has_include {
      my $self = shift;
  
      require ExtUtils::Manifest;
      return eval { ExtUtils::Manifest->VERSION(1.50); 1 };
  }
  
  
  =begin private
  
    my $maniskip_file = $build->_default_maniskip;
  
  Returns the location of the installed MANIFEST.SKIP file used by
  default.
  
  =end private
  
  =cut
  
  sub _default_maniskip {
      my $self = shift;
  
      my $default_maniskip;
      for my $dir (@INC) {
          $default_maniskip = File::Spec->catfile($dir, "ExtUtils", "MANIFEST.SKIP");
          last if -r $default_maniskip;
      }
  
      return $default_maniskip;
  }
  
  
  =begin private
  
    my $content = $build->_slurp($file);
  
  Reads $file and returns the $content.
  
  =end private
  
  =cut
  
  sub _slurp {
      my $self = shift;
      my $file = shift;
      my $mode = shift || "";
      open my $fh, "<$mode", $file or croak "Can't open $file for reading: $!";
      local $/;
      return <$fh>;
  }
  
  sub _spew {
      my $self = shift;
      my $file = shift;
      my $content = shift || "";
      my $mode = shift || "";
      open my $fh, ">$mode", $file or croak "Can't open $file for writing: $!";
      print {$fh} $content;
      close $fh;
  }
  
  sub _case_tolerant {
    my $self = shift;
    if ( ref $self ) {
      $self->{_case_tolerant} = File::Spec->case_tolerant
        unless defined($self->{_case_tolerant});
      return $self->{_case_tolerant};
    }
    else {
      return File::Spec->case_tolerant;
    }
  }
  
  sub _append_maniskip {
    my $self = shift;
    my $skip = shift;
    my $file = shift || 'MANIFEST.SKIP';
    return unless defined $skip && length $skip;
    open(my $fh, '>>', $file)
      or die "Can't open $file: $!";
  
    print $fh "$skip\n";
    close $fh;
  }
  
  sub _write_default_maniskip {
    my $self = shift;
    my $file = shift || 'MANIFEST.SKIP';
    open(my $fh, '>', $file)
      or die "Can't open $file: $!";
  
    my $content = $self->_eumanifest_has_include ? "#!include_default\n"
                                                 : $self->_slurp( $self->_default_maniskip );
  
    $content .= <<'EOF';
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
  
    # Skip, for example, 'Module-Build-0.27.tar.gz'
    $content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";
  
    print $fh $content;
    
    close $fh;
  
    return;
  }
  
  sub _check_manifest_skip {
    my ($self) = @_;
  
    my $maniskip = 'MANIFEST.SKIP';
  
    if ( ! -e $maniskip ) {
      $self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");
      $self->_write_default_maniskip($maniskip);
      $self->_unlink_on_exit($maniskip);
    }
    else {
      # MYMETA must not be added to MANIFEST, so always confirm the skip
      $self->_check_mymeta_skip( $maniskip );
    }
  
    return;
  }
  
  sub ACTION_manifest {
    my ($self) = @_;
  
    $self->_check_manifest_skip;
  
    require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
    local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
    ExtUtils::Manifest::mkmanifest();
  }
  
  sub ACTION_manifest_skip {
    my ($self) = @_;
  
    if ( -e 'MANIFEST.SKIP' ) {
      $self->log_warn("MANIFEST.SKIP already exists.\n");
      return 0;
    }
    $self->log_info("Creating a new MANIFEST.SKIP file\n");
    return $self->_write_default_maniskip;
    return -e 'MANIFEST.SKIP'
  }
  
  # Case insensitive regex for files
  sub file_qr {
      return shift->{_case_tolerant} ? qr($_[0])i : qr($_[0]);
  }
  
  sub dist_dir {
    my ($self) = @_;
    my $dir = join "-", $self->dist_name, $self->dist_version;
    $dir .= "-" . $self->dist_suffix if $self->dist_suffix;
    return $dir;
  }
  
  sub ppm_name {
    my $self = shift;
    return 'PPM-' . $self->dist_dir;
  }
  
  sub _files_in {
    my ($self, $dir) = @_;
    return unless -d $dir;
  
    local *DH;
    opendir DH, $dir or die "Can't read directory $dir: $!";
  
    my @files;
    while (defined (my $file = readdir DH)) {
      my $full_path = File::Spec->catfile($dir, $file);
      next if -d $full_path;
      push @files, $full_path;
    }
    return @files;
  }
  
  sub share_dir {
    my $self = shift;
    my $p = $self->{properties};
  
    $p->{share_dir} = shift if @_;
  
    # Always coerce to proper hash form
    if    ( ! defined $p->{share_dir} ) {
      return;
    }
    elsif ( ! ref $p->{share_dir}  ) {
      # scalar -- treat as a single 'dist' directory
      $p->{share_dir} = { dist => [ $p->{share_dir} ] };
    }
    elsif ( ref $p->{share_dir} eq 'ARRAY' ) {
      # array -- treat as a list of 'dist' directories
      $p->{share_dir} = { dist => $p->{share_dir} };
    }
    elsif ( ref $p->{share_dir} eq 'HASH' ) {
      # hash -- check structure
      my $share_dir = $p->{share_dir};
      # check dist key
      if ( defined $share_dir->{dist} ) {
        if ( ! ref $share_dir->{dist} ) {
          # scalar, so upgrade to arrayref
          $share_dir->{dist} = [ $share_dir->{dist} ];
        }
        elsif ( ref $share_dir->{dist} ne 'ARRAY' ) {
          die "'dist' key in 'share_dir' must be scalar or arrayref";
        }
      }
      # check module key
      if ( defined $share_dir->{module} ) {
        my $mod_hash = $share_dir->{module};
        if ( ref $mod_hash eq 'HASH' ) {
          for my $k ( sort keys %$mod_hash ) {
            if ( ! ref $mod_hash->{$k} ) {
              $mod_hash->{$k} = [ $mod_hash->{$k} ];
            }
            elsif( ref $mod_hash->{$k} ne 'ARRAY' ) {
              die "modules in 'module' key of 'share_dir' must be scalar or arrayref";
            }
          }
        }
        else {
            die "'module' key in 'share_dir' must be hashref";
        }
      }
    }
    else {
      die "'share_dir' must be hashref, arrayref or string";
    }
  
    return $p->{share_dir};
  }
  
  sub script_files {
    my $self = shift;
  
    for ($self->{properties}{script_files}) {
      $_ = shift if @_;
      next unless $_;
  
      # Always coerce into a hash
      return $_ if ref $_ eq 'HASH';
      return $_ = { map {$_,1} @$_ } if ref $_ eq 'ARRAY';
  
      die "'script_files' must be a hashref, arrayref, or string" if ref();
  
      return $_ = { map {$_,1} $self->_files_in( $_ ) } if -d $_;
      return $_ = {$_ => 1};
    }
  
    my %pl_files = map {
      File::Spec->canonpath( $_ ) => 1
    } keys %{ $self->PL_files || {} };
  
    my @bin_files = $self->_files_in('bin');
  
    my %bin_map = map {
      $_ => File::Spec->canonpath( $_ )
    } @bin_files;
  
    return $_ = { map {$_ => 1} grep !$pl_files{$bin_map{$_}}, @bin_files };
  }
  BEGIN { *scripts = \&script_files; }
  
  {
    my %licenses = (
      perl         => 'Perl_5',
      apache       => 'Apache_2_0',
      apache_1_1   => 'Apache_1_1',
      artistic     => 'Artistic_1',
      artistic_2   => 'Artistic_2',
      lgpl         => 'LGPL_2_1',
      lgpl2        => 'LGPL_2_1',
      lgpl3        => 'LGPL_3_0',
      bsd          => 'BSD',
      gpl          => 'GPL_1',
      gpl2         => 'GPL_2',
      gpl3         => 'GPL_3',
      mit          => 'MIT',
      mozilla      => 'Mozilla_1_1',
      restrictive  => 'Restricted',
      open_source  => undef,
      unrestricted => undef,
      unknown      => undef,
    );
  
    # TODO - would be nice to not have these here, since they're more
    # properly stored only in Software::License
    my %license_urls = (
      perl         => 'http://dev.perl.org/licenses/',
      apache       => 'http://apache.org/licenses/LICENSE-2.0',
      apache_1_1   => 'http://apache.org/licenses/LICENSE-1.1',
      artistic     => 'http://opensource.org/licenses/artistic-license.php',
      artistic_2   => 'http://opensource.org/licenses/artistic-license-2.0.php',
      lgpl         => 'http://opensource.org/licenses/lgpl-license.php',
      lgpl2        => 'http://opensource.org/licenses/lgpl-2.1.php',
      lgpl3        => 'http://opensource.org/licenses/lgpl-3.0.html',
      bsd          => 'http://opensource.org/licenses/bsd-license.php',
      gpl          => 'http://opensource.org/licenses/gpl-license.php',
      gpl2         => 'http://opensource.org/licenses/gpl-2.0.php',
      gpl3         => 'http://opensource.org/licenses/gpl-3.0.html',
      mit          => 'http://opensource.org/licenses/mit-license.php',
      mozilla      => 'http://opensource.org/licenses/mozilla1.1.php',
      restrictive  => undef,
      open_source  => undef,
      unrestricted => undef,
      unknown      => undef,
    );
    sub valid_licenses {
      return \%licenses;
    }
    sub _license_url {
      return $license_urls{$_[1]};
    }
  }
  
  sub _software_license_class {
    my ($self, $license) = @_;
    if ($self->valid_licenses->{$license} && eval { require Software::LicenseUtils; Software::LicenseUtils->VERSION(0.103009) }) {
      my @classes = Software::LicenseUtils->guess_license_from_meta_key($license, 1);
      if (@classes == 1) {
        eval "require $classes[0]";
        return $classes[0];
      }
    }
    LICENSE: for my $l ( $self->valid_licenses->{ $license }, $license ) {
      next unless defined $l;
      my $trial = "Software::License::" . $l;
      if ( eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1" ) {
        return $trial;
      }
    }
    return;
  }
  
  # use mapping or license name directly
  sub _software_license_object {
    my ($self) = @_;
    return unless defined( my $license = $self->license );
  
    my $class = $self->_software_license_class($license) or return;
  
    # Software::License requires a 'holder' argument
    my $author = join( " & ", @{ $self->dist_author }) || 'unknown';
    my $sl = eval { $class->new({holder=>$author}) };
    if ( $@ ) {
      $self->log_warn( "Error getting '$class' object: $@" );
    }
  
    return $sl;
  }
  
  sub _hash_merge {
    my ($self, $h, $k, $v) = @_;
    if (ref $h->{$k} eq 'ARRAY') {
      push @{$h->{$k}}, ref $v ? @$v : $v;
    } elsif (ref $h->{$k} eq 'HASH') {
      $h->{$k}{$_} = $v->{$_} foreach keys %$v;
    } else {
      $h->{$k} = $v;
    }
  }
  
  sub ACTION_distmeta {
    my ($self) = @_;
    $self->do_create_makefile_pl if $self->create_makefile_pl;
    $self->do_create_readme if $self->create_readme;
    $self->do_create_license if $self->create_license;
    $self->do_create_metafile;
  }
  
  sub do_create_metafile {
    my $self = shift;
    return if $self->{wrote_metadata};
  
    my $p = $self->{properties};
  
    unless ($p->{license}) {
      $self->log_warn("No license specified, setting license = 'unknown'\n");
      $p->{license} = 'unknown';
    }
  
    my @metafiles = ( $self->metafile, $self->metafile2 );
    # If we're in the distdir, the metafile may exist and be non-writable.
    $self->delete_filetree($_) for @metafiles;
  
    # Since we're building ourself, we have to do some special stuff
    # here: the ConfigData module is found in blib/lib.
    local @INC = @INC;
    if (($self->module_name || '') eq 'Module::Build') {
      $self->depends_on('config_data');
      push @INC, File::Spec->catdir($self->blib, 'lib');
    }
  
    my $meta_obj = $self->_get_meta_object(
      quiet => 1, fatal => 1, auto => 1
    );
    my @created = $self->_write_meta_files( $meta_obj, 'META' );
    if ( @created ) {
      $self->{wrote_metadata} = 1;
      $self->_add_to_manifest('MANIFEST', $_) for @created;
    }
    return 1;
  }
  
  sub _write_meta_files {
    my $self = shift;
    my ($meta, $file) = @_;
    $file =~ s{\.(?:yml|json)$}{};
  
    my @created;
    push @created, "$file\.yml"
      if $meta && $meta->save( "$file\.yml", {version => "1.4"} );
    push @created, "$file\.json"
      if $meta && $meta->save( "$file\.json" );
  
    if ( @created ) {
      $self->log_info("Created " . join(" and ", @created) . "\n");
    }
    return @created;
  }
  
  sub _get_meta_object {
    my $self = shift;
    my %args = @_;
    return unless $self->try_require("CPAN::Meta", "2.142060");
  
    my $meta;
    eval {
      my $data = $self->get_metadata(
        fatal => $args{fatal},
        auto => $args{auto},
      );
      $data->{dynamic_config} = $args{dynamic} if defined $args{dynamic};
      $meta = CPAN::Meta->create($data);
    };
    if ($@ && ! $args{quiet}) {
      $self->log_warn(
        "Could not get valid metadata. Error is: $@\n"
      );
    }
  
    return $meta;
  }
  
  sub read_metafile {
    my $self = shift;
    my ($metafile) = @_;
  
    return unless $self->try_require("CPAN::Meta", "2.110420");
    my $meta = CPAN::Meta->load_file($metafile);
    return $meta->as_struct( {version => "2.0"} );
  }
  
  sub normalize_version {
    my ($self, $version) = @_;
    $version = 0 unless defined $version and length $version;
  
    if ( $version =~ /[=<>!,]/ ) { # logic, not just version
      # take as is without modification
    }
    elsif ( ref $version eq 'version') { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  }
  
  my %prereq_map = (
    requires => [ qw/runtime requires/],
    configure_requires => [qw/configure requires/],
    build_requires => [ qw/build requires/ ],
    test_requires => [ qw/test requires/ ],
    test_recommends => [ qw/test recommends/ ],
    recommends => [ qw/runtime recommends/ ],
    conflicts => [ qw/runtime conflicts/ ],
  );
  
  sub _normalize_prereqs {
    my ($self) = @_;
    my $p = $self->{properties};
  
    # copy prereq data structures so we can modify them before writing to META
    my %prereq_types;
    for my $type ( 'configure_requires', @{$self->prereq_action_types} ) {
      if (exists $p->{$type} and keys %{ $p->{$type} }) {
        my ($phase, $relation) = @{ $prereq_map{$type} };
        for my $mod ( keys %{ $p->{$type} } ) {
          $prereq_types{$phase}{$relation}{$mod} = $self->normalize_version($p->{$type}{$mod});
        }
      }
    }
    return \%prereq_types;
  }
  
  sub _get_license {
    my $self = shift;
  
    my $license = $self->license;
    my ($meta_license, $meta_license_url);
  
    my $valid_licenses = $self->valid_licenses();
    if ( my $sl = $self->_software_license_object ) {
      $meta_license = $sl->meta2_name;
      $meta_license_url = $sl->url;
    }
    elsif ( exists $valid_licenses->{$license} ) {
      $meta_license = $valid_licenses->{$license} ? lc $valid_licenses->{$license} : $license;
      $meta_license_url = $self->_license_url( $license );
    }
    else {
      $self->log_warn( "Can not determine license type for '" . $self->license
        . "'\nSetting META license field to 'unknown'.\n");
      $meta_license = 'unknown';
    }
    return ($meta_license, $meta_license_url);
  }
  
  sub get_metadata {
    my ($self, %args) = @_;
  
    my $fatal = $args{fatal} || 0;
    my $p = $self->{properties};
  
    $self->auto_config_requires if $args{auto};
  
    # validate required fields
    foreach my $f (qw(dist_name dist_version dist_author dist_abstract license)) {
      my $field = $self->$f();
      unless ( defined $field and length $field ) {
        my $err = "ERROR: Missing required field '$f' for metafile\n";
        if ( $fatal ) {
          die $err;
        }
        else {
          $self->log_warn($err);
        }
      }
    }
  
    my %metadata = (
      name => $self->dist_name,
      version => $self->normalize_version($self->dist_version),
      author => $self->dist_author,
      abstract => $self->dist_abstract,
      generated_by => "Module::Build version $Module::Build::VERSION",
      'meta-spec' => {
        version => '2',
        url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
      },
      dynamic_config => exists $p->{dynamic_config} ? $p->{dynamic_config} : 1,
      release_status => $self->release_status,
    );
  
    my ($meta_license, $meta_license_url) = $self->_get_license;
    $metadata{license} = [ $meta_license ];
    $metadata{resources}{license} = [ $meta_license_url ] if defined $meta_license_url;
  
    $metadata{prereqs} = $self->_normalize_prereqs;
  
    if (exists $p->{no_index}) {
      $metadata{no_index} = $p->{no_index};
    } elsif (my $pkgs = eval { $self->find_dist_packages }) {
      $metadata{provides} = $pkgs if %$pkgs;
    } else {
      $self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" .
                      "Nothing to enter for 'provides' field in metafile.\n");
    }
  
    if (my $add = $self->meta_add) {
      if (not exists $add->{'meta-spec'} or $add->{'meta-spec'}{version} != 2) {
        require CPAN::Meta::Converter;
        if (CPAN::Meta::Converter->VERSION('2.141170')) {
          $add = CPAN::Meta::Converter->new($add)->upgrade_fragment;
          delete $add->{prereqs}; # XXX this would now overwrite all prereqs
        }
        else {
          $self->log_warn("Can't meta_add without CPAN::Meta 2.141170");
        }
      }
  
      while (my($k, $v) = each %{$add}) {
        $metadata{$k} = $v;
      }
    }
  
    if (my $merge = $self->meta_merge) {
      if (eval { require CPAN::Meta::Merge }) {
        %metadata = %{ CPAN::Meta::Merge->new(default_version => '1.4')->merge(\%metadata, $merge) };
      }
      else {
        $self->log_warn("Can't merge without CPAN::Meta::Merge");
      }
    }
  
    return \%metadata;
  }
  
  # To preserve compatibility with old API, $node *must* be a hashref
  # passed in to prepare_metadata.  $keys is an arrayref holding a
  # list of keys -- it's use is optional and generally no longer needed
  # but kept for back compatibility.  $args is an optional parameter to
  # support the new 'fatal' toggle
  
  sub prepare_metadata {
    my ($self, $node, $keys, $args) = @_;
    unless ( ref $node eq 'HASH' ) {
      croak "prepare_metadata() requires a hashref argument to hold output\n";
    }
    croak 'Keys argument to prepare_metadata is no longer supported' if $keys;
    %{$node} = %{ $self->get_meta(%{$args}) };
    return $node;
  }
  
  sub _read_manifest {
    my ($self, $file) = @_;
    return undef unless -e $file;
  
    require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
    local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
    return scalar ExtUtils::Manifest::maniread($file);
  }
  
  sub find_dist_packages {
    my $self = shift;
  
    # Only packages in .pm files are candidates for inclusion here.
    # Only include things in the MANIFEST, not things in developer's
    # private stock.
  
    my $manifest = $self->_read_manifest('MANIFEST')
      or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";
  
    # Localize
    my %dist_files = map { $self->localize_file_path($_) => $_ }
                         keys %$manifest;
  
    my @pm_files = sort grep { $_ !~ m{^t} } # skip things in t/
                     grep {exists $dist_files{$_}}
                       keys %{ $self->find_pm_files };
  
    return $self->find_packages_in_files(\@pm_files, \%dist_files);
  }
  
  # XXX Do not document this function; mst wrote it and now says the API is
  # stupid and needs to be fixed and it shouldn't become a public API until then
  sub find_packages_in_files {
    my ($self, $file_list, $filename_map) = @_;
  
    # First, we enumerate all packages & versions,
    # separating into primary & alternative candidates
    my( %prime, %alt );
    foreach my $file (@{$file_list}) {
      my $mapped_filename = $filename_map->{$file};
      my @path = split( /\//, $mapped_filename );
      (my $prime_package = join( '::', @path[1..$#path] )) =~ s/\.pm$//;
  
      my $pm_info = Module::Metadata->new_from_file( $file );
  
      foreach my $package ( $pm_info->packages_inside ) {
        next if $package eq 'main';  # main can appear numerous times, ignore
        next if $package eq 'DB';    # special debugging package, ignore
        next if grep /^_/, split( /::/, $package ); # private package, ignore
  
        my $version = $pm_info->version( $package );
  
        if ( $package eq $prime_package ) {
          if ( exists( $prime{$package} ) ) {
            # Module::Metadata will handle this conflict
            die "Unexpected conflict in '$package'; multiple versions found.\n";
          } else {
            $prime{$package}{file} = $mapped_filename;
            $prime{$package}{version} = $version if defined( $version );
          }
        } else {
          push( @{$alt{$package}}, {
                                    file    => $mapped_filename,
                                    version => $version,
                                   } );
        }
      }
    }
  
    # Then we iterate over all the packages found above, identifying conflicts
    # and selecting the "best" candidate for recording the file & version
    # for each package.
    foreach my $package ( sort keys( %alt ) ) {
      my $result = $self->_resolve_module_versions( $alt{$package} );
  
      if ( exists( $prime{$package} ) ) { # primary package selected
  
        if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
          $self->log_warn(
            "Found conflicting versions for package '$package'\n" .
            "  $prime{$package}{file} ($prime{$package}{version})\n" .
            $result->{err}
          );
  
        } elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
            if ( $self->compare_versions( $prime{$package}{version}, '!=',
                                          $result->{version} ) ) {
              $self->log_warn(
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              );
            }
  
          } else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
        } else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
        }
  
      } else { # No primary package was selected, use the best alternative
  
        if ( $result->{err} ) {
          $self->log_warn(
            "Found conflicting versions for package '$package'\n" .
            $result->{err}
          );
        }
  
        # Despite possible conflicting versions, we choose to record
        # something rather than nothing
        $prime{$package}{file}    = $result->{file};
        $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
      }
    }
  
    # Normalize versions or delete them if undef/0
    for my $provides ( values %prime ) {
      if ( $provides->{version} ) {
        $provides->{version} = $self->normalize_version( $provides->{version} )
      }
      else {
        delete $provides->{version};
      }
    }
  
    return \%prime;
  }
  
  # separate out some of the conflict resolution logic from
  # $self->find_dist_packages(), above, into a helper function.
  #
  sub _resolve_module_versions {
    my $self = shift;
  
    my $packages = shift;
  
    my( $file, $version );
    my $err = '';
      foreach my $p ( @$packages ) {
        if ( defined( $p->{version} ) ) {
          if ( defined( $version ) ) {
            if ( $self->compare_versions( $version, '!=', $p->{version} ) ) {
              $err .= "  $p->{file} ($p->{version})\n";
            } else {
              # same version declared multiple times, ignore
            }
          } else {
            $file    = $p->{file};
            $version = $p->{version};
          }
        }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
    if ( $err ) {
      $err = "  $file ($version)\n" . $err;
    }
  
    my %result = (
      file    => $file,
      version => $version,
      err     => $err
    );
  
    return \%result;
  }
  
  sub make_tarball {
    my ($self, $dir, $file) = @_;
    $file ||= $dir;
  
    $self->log_info("Creating $file.tar.gz\n");
  
    if ($self->{args}{tar}) {
      my $tar_flags = $self->verbose ? 'cvf' : 'cf';
      $self->do_system($self->split_like_shell($self->{args}{tar}), $tar_flags, "$file.tar", $dir);
      $self->do_system($self->split_like_shell($self->{args}{gzip}), "$file.tar") if $self->{args}{gzip};
    } else {
      eval { require Archive::Tar && Archive::Tar->VERSION(1.09); 1 }
        or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n".
               "or specify a binary tar program with the '--tar' option.\n".
               "See the documentation for the 'dist' action.\n";
  
      my $files = $self->rscan_dir($dir);
  
      # Archive::Tar versions >= 1.09 use the following to enable a compatibility
      # hack so that the resulting archive is compatible with older clients.
      # If no file path is 100 chars or longer, we disable the prefix field
      # for maximum compatibility.  If there are any long file paths then we
      # need the prefix field after all.
      $Archive::Tar::DO_NOT_USE_PREFIX =
        (grep { length($_) >= 100 } @$files) ? 0 : 1;
  
      my $tar   = Archive::Tar->new;
      $tar->add_files(@$files);
      for my $f ($tar->get_files) {
        $f->mode($f->mode & ~022); # chmod go-w
      }
      $tar->write("$file.tar.gz", 1);
    }
  }
  
  sub install_path {
    my $self = shift;
    my( $type, $value ) = ( @_, '<empty>' );
  
    Carp::croak( 'Type argument missing' )
      unless defined( $type );
  
    my $map = $self->{properties}{install_path};
    return $map unless @_;
  
    # delete existing value if $value is literal undef()
    unless ( defined( $value ) ) {
      delete( $map->{$type} );
      return undef;
    }
  
    # return existing value if no new $value is given
    if ( $value eq '<empty>' ) {
      return undef unless exists $map->{$type};
      return $map->{$type};
    }
  
    # set value if $value is a valid relative path
    return $map->{$type} = $value;
  }
  
  sub install_sets {
    # Usage: install_sets('site'), install_sets('site', 'lib'),
    #   or install_sets('site', 'lib' => $value);
    my ($self, $dirs, $key, $value) = @_;
    $dirs = $self->installdirs unless defined $dirs;
    # update property before merging with defaults
    if ( @_ == 4 && defined $dirs && defined $key) {
      # $value can be undef; will mask default
      $self->{properties}{install_sets}{$dirs}{$key} = $value;
    }
    my $map = { $self->_merge_arglist(
      $self->{properties}{install_sets},
      $self->_default_install_paths->{install_sets}
    )};
    if ( defined $dirs && defined $key ) {
      return $map->{$dirs}{$key};
    }
    elsif ( defined $dirs ) {
      return $map->{$dirs};
    }
    else {
      croak "Can't determine installdirs for install_sets()";
    }
  }
  
  sub original_prefix {
    # Usage: original_prefix(), original_prefix('lib'),
    #   or original_prefix('lib' => $value);
    my ($self, $key, $value) = @_;
    # update property before merging with defaults
    if ( @_ == 3 && defined $key) {
      # $value can be undef; will mask default
      $self->{properties}{original_prefix}{$key} = $value;
    }
    my $map = { $self->_merge_arglist(
      $self->{properties}{original_prefix},
      $self->_default_install_paths->{original_prefix}
    )};
    return $map unless defined $key;
    return $map->{$key}
  }
  
  sub install_base_relpaths {
    # Usage: install_base_relpaths(), install_base_relpaths('lib'),
    #   or install_base_relpaths('lib' => $value);
    my $self = shift;
    if ( @_ > 1 ) { # change values before merge
      $self->_set_relpaths($self->{properties}{install_base_relpaths}, @_);
    }
    my $map = { $self->_merge_arglist(
      $self->{properties}{install_base_relpaths},
      $self->_default_install_paths->{install_base_relpaths}
    )};
    return $map unless @_;
    my $relpath = $map->{$_[0]};
    return defined $relpath ? File::Spec->catdir( @$relpath ) : undef;
  }
  
  # Defaults to use in case the config install paths cannot be prefixified.
  sub prefix_relpaths {
    # Usage: prefix_relpaths('site'), prefix_relpaths('site', 'lib'),
    #   or prefix_relpaths('site', 'lib' => $value);
    my $self = shift;
    my $installdirs = shift || $self->installdirs
      or croak "Can't determine installdirs for prefix_relpaths()";
    if ( @_ > 1 ) { # change values before merge
      $self->{properties}{prefix_relpaths}{$installdirs} ||= {};
      $self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs}, @_);
    }
    my $map = {$self->_merge_arglist(
      $self->{properties}{prefix_relpaths}{$installdirs},
      $self->_default_install_paths->{prefix_relpaths}{$installdirs}
    )};
    return $map unless @_;
    my $relpath = $map->{$_[0]};
    return defined $relpath ? File::Spec->catdir( @$relpath ) : undef;
  }
  
  sub _set_relpaths {
    my $self = shift;
    my( $map, $type, $value ) = @_;
  
    Carp::croak( 'Type argument missing' )
      unless defined( $type );
  
    # set undef if $value is literal undef()
    if ( ! defined( $value ) ) {
      $map->{$type} = undef;
      return;
    }
    # set value if $value is a valid relative path
    else {
      Carp::croak( "Value must be a relative path" )
        if File::Spec::Unix->file_name_is_absolute($value);
  
      my @value = split( /\//, $value );
      $map->{$type} = \@value;
    }
  }
  
  # Translated from ExtUtils::MM_Any::init_INSTALL_from_PREFIX
  sub prefix_relative {
    my ($self, $type) = @_;
    my $installdirs = $self->installdirs;
  
    my $relpath = $self->install_sets($installdirs)->{$type};
  
    return $self->_prefixify($relpath,
                             $self->original_prefix($installdirs),
                             $type,
                            );
  }
  
  # Translated from ExtUtils::MM_Unix::prefixify()
  sub _prefixify {
    my($self, $path, $sprefix, $type) = @_;
  
    my $rprefix = $self->prefix;
    $rprefix .= '/' if $sprefix =~ m|/$|;
  
    $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")
      if defined( $path ) && length( $path );
  
    if( !defined( $path ) || ( length( $path ) == 0 ) ) {
      $self->log_verbose("  no path to prefixify, falling back to default.\n");
      return $self->_prefixify_default( $type, $rprefix );
    } elsif( !File::Spec->file_name_is_absolute($path) ) {
      $self->log_verbose("    path is relative, not prefixifying.\n");
    } elsif( $path !~ s{^\Q$sprefix\E\b}{}s ) {
      $self->log_verbose("    cannot prefixify, falling back to default.\n");
      return $self->_prefixify_default( $type, $rprefix );
    }
  
    $self->log_verbose("    now $path in $rprefix\n");
  
    return $path;
  }
  
  sub _prefixify_default {
    my $self = shift;
    my $type = shift;
    my $rprefix = shift;
  
    my $default = $self->prefix_relpaths($self->installdirs, $type);
    if( !$default ) {
      $self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");
      return $rprefix;
    } else {
      return $default;
    }
  }
  
  sub install_destination {
    my ($self, $type) = @_;
  
    return $self->install_path($type) if $self->install_path($type);
  
    if ( $self->install_base ) {
      my $relpath = $self->install_base_relpaths($type);
      return $relpath ? File::Spec->catdir($self->install_base, $relpath) : undef;
    }
  
    if ( $self->prefix ) {
      my $relpath = $self->prefix_relative($type);
      return $relpath ? File::Spec->catdir($self->prefix, $relpath) : undef;
    }
  
    return $self->install_sets($self->installdirs)->{$type};
  }
  
  sub install_types {
    my $self = shift;
  
    my %types;
    if ( $self->install_base ) {
      %types = %{$self->install_base_relpaths};
    } elsif ( $self->prefix ) {
      %types = %{$self->prefix_relpaths};
    } else {
      %types = %{$self->install_sets($self->installdirs)};
    }
  
    %types = (%types, %{$self->install_path});
  
    return sort keys %types;
  }
  
  sub install_map {
    my ($self, $blib) = @_;
    $blib ||= $self->blib;
  
    my( %map, @skipping );
    foreach my $type ($self->install_types) {
      my $localdir = File::Spec->catdir( $blib, $type );
      next unless -e $localdir;
  
      # the line "...next if (($type eq 'bindoc'..." was one of many changes introduced for
      # improving HTML generation on ActivePerl, see https://rt.cpan.org/Public/Bug/Display.html?id=53478
      # Most changes were ok, but this particular line caused test failures in t/manifypods.t on windows,
      # therefore it is commented out.
  
      # ********* next if (($type eq 'bindoc' || $type eq 'libdoc') && not $self->is_unixish);
  
      if (my $dest = $self->install_destination($type)) {
        $map{$localdir} = $dest;
      } else {
        push( @skipping, $type );
      }
    }
  
    $self->log_warn(
      "WARNING: Can't figure out install path for types: @skipping\n" .
      "Files will not be installed.\n"
    ) if @skipping;
  
    # Write the packlist into the same place as ExtUtils::MakeMaker.
    if ($self->create_packlist and my $module_name = $self->module_name) {
      my $archdir = $self->install_destination('arch');
      my @ext = split /::/, $module_name;
      $map{write} = File::Spec->catfile($archdir, 'auto', @ext, '.packlist');
    }
  
    # Handle destdir
    if (length(my $destdir = $self->destdir || '')) {
      foreach (keys %map) {
        # Need to remove volume from $map{$_} using splitpath, or else
        # we'll create something crazy like C:\Foo\Bar\E:\Baz\Quux
        # VMS will always have the file separate than the path.
        my ($volume, $path, $file) = File::Spec->splitpath( $map{$_}, 0 );
  
        # catdir needs a list of directories, or it will create something
        # crazy like volume:[Foo.Bar.volume.Baz.Quux]
        my @dirs = File::Spec->splitdir($path);
  
        # First merge the directories
        $path = File::Spec->catdir($destdir, @dirs);
  
        # Then put the file back on if there is one.
        if ($file ne '') {
            $map{$_} = File::Spec->catfile($path, $file)
        } else {
            $map{$_} = $path;
        }
      }
    }
  
    $map{read} = '';  # To keep ExtUtils::Install quiet
  
    return \%map;
  }
  
  sub depends_on {
    my $self = shift;
    foreach my $action (@_) {
      $self->_call_action($action);
    }
  }
  
  sub rscan_dir {
    my ($self, $dir, $pattern) = @_;
    my @result;
    local $_; # find() can overwrite $_, so protect ourselves
    my $subr = !$pattern ? sub {push @result, $File::Find::name} :
               !ref($pattern) || (ref $pattern eq 'Regexp') ? sub {push @result, $File::Find::name if /$pattern/} :
               ref($pattern) eq 'CODE' ? sub {push @result, $File::Find::name if $pattern->()} :
               die "Unknown pattern type";
  
    File::Find::find({wanted => $subr, no_chdir => 1, preprocess => sub { sort @_ } }, $dir);
    return \@result;
  }
  
  sub delete_filetree {
    my $self = shift;
    my $deleted = 0;
    foreach (@_) {
      next unless -e $_;
      $self->log_verbose("Deleting $_\n");
      File::Path::rmtree($_, 0, 0);
      die "Couldn't remove '$_': $!\n" if -e $_;
      $deleted++;
    }
    return $deleted;
  }
  
  sub autosplit_file {
    my ($self, $file, $to) = @_;
    require AutoSplit;
    my $dir = File::Spec->catdir($to, 'lib', 'auto');
    AutoSplit::autosplit($file, $dir);
  }
  
  sub cbuilder {
    # Returns a CBuilder object
  
    my $self = shift;
    my $s = $self->{stash};
    return $s->{_cbuilder} if $s->{_cbuilder};
  
    require ExtUtils::CBuilder;
    return $s->{_cbuilder} = ExtUtils::CBuilder->new(
      config => $self->config,
      ($self->quiet ? (quiet => 1 ) : ()),
    );
  }
  
  sub have_c_compiler {
    my ($self) = @_;
  
    my $p = $self->{properties};
    return $p->{_have_c_compiler} if defined $p->{_have_c_compiler};
  
    $self->log_verbose("Checking if compiler tools configured... ");
    my $b = $self->cbuilder;
    my $have = $b && eval { $b->have_compiler };
    $self->log_verbose($have ? "ok.\n" : "failed.\n");
    return $p->{_have_c_compiler} = $have;
  }
  
  sub compile_c {
    my ($self, $file, %args) = @_;
  
    if ( ! $self->have_c_compiler ) {
      die "Error: no compiler detected to compile '$file'.  Aborting\n";
    }
  
    my $b = $self->cbuilder;
    my $obj_file = $b->object_file($file);
    $self->add_to_cleanup($obj_file);
    return $obj_file if $self->up_to_date($file, $obj_file);
  
    $b->compile(source => $file,
                defines => $args{defines},
                object_file => $obj_file,
                include_dirs => $self->include_dirs,
                extra_compiler_flags => $self->extra_compiler_flags,
               );
  
    return $obj_file;
  }
  
  sub link_c {
    my ($self, $spec) = @_;
    my $p = $self->{properties}; # For convenience
  
    $self->add_to_cleanup($spec->{lib_file});
  
    my $objects = $p->{objects} || [];
  
    return $spec->{lib_file}
      if $self->up_to_date([$spec->{obj_file}, @$objects],
                           $spec->{lib_file});
  
    my $module_name = $spec->{module_name} || $self->module_name;
  
    $self->cbuilder->link(
      module_name => $module_name,
      objects     => [$spec->{obj_file}, @$objects],
      lib_file    => $spec->{lib_file},
      extra_linker_flags => $self->extra_linker_flags );
  
    return $spec->{lib_file};
  }
  
  sub compile_xs {
    my ($self, $file, %args) = @_;
  
    $self->log_verbose("$file -> $args{outfile}\n");
  
    if (eval {require ExtUtils::ParseXS; 1}) {
  
      ExtUtils::ParseXS::process_file(
                                      filename => $file,
                                      prototypes => 0,
                                      output => $args{outfile},
                                     );
    } else {
      # Ok, I give up.  Just use backticks.
  
      my $xsubpp = Module::Metadata->find_module_by_name('ExtUtils::xsubpp')
        or die "Can't find ExtUtils::xsubpp in INC (@INC)";
  
      my @typemaps;
      push @typemaps, Module::Metadata->find_module_by_name(
          'ExtUtils::typemap', \@INC
      );
      my $lib_typemap = Module::Metadata->find_module_by_name(
          'typemap', [File::Basename::dirname($file), File::Spec->rel2abs('.')]
      );
      push @typemaps, $lib_typemap if $lib_typemap;
      @typemaps = map {+'-typemap', $_} @typemaps;
  
      my $cf = $self->{config};
      my $perl = $self->{properties}{perl};
  
      my @command = ($perl, "-I".$cf->get('installarchlib'), "-I".$cf->get('installprivlib'), $xsubpp, '-noprototypes',
                     @typemaps, $file);
  
      $self->log_info("@command\n");
      open(my $fh, '>', $args{outfile}) or die "Couldn't write $args{outfile}: $!";
      print {$fh} $self->_backticks(@command);
      close $fh;
    }
  }
  
  sub split_like_shell {
    my ($self, $string) = @_;
  
    return () unless defined($string);
    return @$string if ref $string eq 'ARRAY';
    $string =~ s/^\s+|\s+$//g;
    return () unless length($string);
  
    return Text::ParseWords::shellwords($string);
  }
  
  sub oneliner {
    # Returns a string that the shell can evaluate as a perl command.
    # This should be avoided whenever possible, since "the shell" really
    # means zillions of shells on zillions of platforms and it's really
    # hard to get it right all the time.
  
    # Some of this code is stolen with permission from ExtUtils::MakeMaker.
  
    my($self, $cmd, $switches, $args) = @_;
    $switches = [] unless defined $switches;
    $args = [] unless defined $args;
  
    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};
  
    my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
    return $self->_quote_args($perl, @$switches, '-e', $cmd, @$args);
  }
  
  sub run_perl_script {
    my ($self, $script, $preargs, $postargs) = @_;
    foreach ($preargs, $postargs) {
      $_ = [ $self->split_like_shell($_) ] unless ref();
    }
    return $self->run_perl_command([@$preargs, $script, @$postargs]);
  }
  
  sub run_perl_command {
    # XXX Maybe we should accept @args instead of $args?  Must resolve
    # this before documenting.
    my ($self, $args) = @_;
    $args = [ $self->split_like_shell($args) ] unless ref($args);
    my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
  
    # Make sure our local additions to @INC are propagated to the subprocess
    local $ENV{PERL5LIB} = join $self->config('path_sep'), $self->_added_to_INC;
  
    return $self->do_system($perl, @$args);
  }
  
  # Infer various data from the path of the input filename
  # that is needed to create output files.
  # The input filename is expected to be of the form:
  #   lib/Module/Name.ext or Module/Name.ext
  sub _infer_xs_spec {
    my $self = shift;
    my $file = shift;
  
    my $cf = $self->{config};
  
    my %spec;
  
    my( $v, $d, $f ) = File::Spec->splitpath( $file );
    my @d = File::Spec->splitdir( $d );
    (my $file_base = $f) =~ s/\.[^.]+$//i;
  
    $spec{base_name} = $file_base;
  
    $spec{src_dir} = File::Spec->catpath( $v, $d, '' );
  
    # the module name
    shift( @d ) while @d && ($d[0] eq 'lib' || $d[0] eq '');
    pop( @d ) while @d && $d[-1] eq '';
    $spec{module_name} = join( '::', (@d, $file_base) );
  
    $spec{archdir} = File::Spec->catdir($self->blib, 'arch', 'auto',
                                        @d, $file_base);
  
    $spec{c_file} = File::Spec->catfile( $spec{src_dir},
                                         "${file_base}.c" );
  
    $spec{obj_file} = File::Spec->catfile( $spec{src_dir},
                                           "${file_base}".$cf->get('obj_ext') );
  
    require DynaLoader;
    my $modfname = defined &DynaLoader::mod2fname ? DynaLoader::mod2fname([@d, $file_base]) : $file_base;
  
    $spec{bs_file} = File::Spec->catfile($spec{archdir}, "$modfname.bs");
  
    $spec{lib_file} = File::Spec->catfile($spec{archdir}, "$modfname.".$cf->get('dlext'));
  
    return \%spec;
  }
  
  sub process_xs {
    my ($self, $file) = @_;
  
    my $spec = $self->_infer_xs_spec($file);
  
    # File name, minus the suffix
    (my $file_base = $file) =~ s/\.[^.]+$//;
  
    # .xs -> .c
    $self->add_to_cleanup($spec->{c_file});
  
    unless ($self->up_to_date($file, $spec->{c_file})) {
      $self->compile_xs($file, outfile => $spec->{c_file});
    }
  
    # .c -> .o
    my $v = $self->dist_version;
    $self->compile_c($spec->{c_file},
                     defines => {VERSION => qq{"$v"}, XS_VERSION => qq{"$v"}});
  
    # archdir
    File::Path::mkpath($spec->{archdir}, 0, oct(777)) unless -d $spec->{archdir};
  
    # .xs -> .bs
    $self->add_to_cleanup($spec->{bs_file});
    unless ($self->up_to_date($file, $spec->{bs_file})) {
      require ExtUtils::Mkbootstrap;
      $self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");
      ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});  # Original had $BSLOADLIBS - what's that?
      open(my $fh, '>>', $spec->{bs_file});  # create
      utime((time)x2, $spec->{bs_file});  # touch
    }
  
    # .o -> .(a|bundle)
    $self->link_c($spec);
  }
  
  sub do_system {
    my ($self, @cmd) = @_;
    $self->log_verbose("@cmd\n");
  
    # Some systems proliferate huge PERL5LIBs, try to ameliorate:
    my %seen;
    my $sep = $self->config('path_sep');
    local $ENV{PERL5LIB} =
      ( !exists($ENV{PERL5LIB}) ? '' :
        length($ENV{PERL5LIB}) < 500
        ? $ENV{PERL5LIB}
        : join $sep, grep { ! $seen{$_}++ and -d $_ } split($sep, $ENV{PERL5LIB})
      );
  
    my $status = system(@cmd);
    if ($status and $! =~ /Argument list too long/i) {
      my $env_entries = '';
      foreach (sort keys %ENV) { $env_entries .= "$_=>".length($ENV{$_})."; " }
      warn "'Argument list' was 'too long', env lengths are $env_entries";
    }
    return !$status;
  }
  
  sub copy_if_modified {
    my $self = shift;
    my %args = (@_ > 3
                ? ( @_ )
                : ( from => shift, to_dir => shift, flatten => shift )
               );
    $args{verbose} = !$self->quiet
      unless exists $args{verbose};
  
    my $file = $args{from};
    unless (defined $file and length $file) {
      die "No 'from' parameter given to copy_if_modified";
    }
  
    # makes no sense to replicate an absolute path, so assume flatten
    $args{flatten} = 1 if File::Spec->file_name_is_absolute( $file );
  
    my $to_path;
    if (defined $args{to} and length $args{to}) {
      $to_path = $args{to};
    } elsif (defined $args{to_dir} and length $args{to_dir}) {
      $to_path = File::Spec->catfile( $args{to_dir}, $args{flatten}
                                      ? File::Basename::basename($file)
                                      : $file );
    } else {
      die "No 'to' or 'to_dir' parameter given to copy_if_modified";
    }
  
    return if $self->up_to_date($file, $to_path); # Already fresh
  
    {
      local $self->{properties}{quiet} = 1;
      $self->delete_filetree($to_path); # delete destination if exists
    }
  
    # Create parent directories
    File::Path::mkpath(File::Basename::dirname($to_path), 0, oct(777));
  
    $self->log_verbose("Copying $file -> $to_path\n");
  
    if ($^O eq 'os2') {# copy will not overwrite; 0x1 = overwrite
      chmod 0666, $to_path;
      File::Copy::syscopy($file, $to_path, 0x1) or die "Can't copy('$file', '$to_path'): $!";
    } else {
      File::Copy::copy($file, $to_path) or die "Can't copy('$file', '$to_path'): $!";
    }
  
    # mode is read-only + (executable if source is executable)
    my $mode = oct(444) | ( $self->is_executable($file) ? oct(111) : 0 );
    chmod( $mode, $to_path );
  
    return $to_path;
  }
  
  sub up_to_date {
    my ($self, $source, $derived) = @_;
    $source  = [$source]  unless ref $source;
    $derived = [$derived] unless ref $derived;
  
    # empty $derived means $source should always run
    return 0 if @$source && !@$derived || grep {not -e} @$derived;
  
    my $most_recent_source = time / (24*60*60);
    foreach my $file (@$source) {
      unless (-e $file) {
        $self->log_warn("Can't find source file $file for up-to-date check");
        next;
      }
      $most_recent_source = -M _ if -M _ < $most_recent_source;
    }
  
    foreach my $derived (@$derived) {
      return 0 if -M $derived > $most_recent_source;
    }
    return 1;
  }
  
  sub dir_contains {
    my ($self, $first, $second) = @_;
    # File::Spec doesn't have an easy way to check whether one directory
    # is inside another, unfortunately.
  
    ($first, $second) = map File::Spec->canonpath($_), ($first, $second);
    my @first_dirs = File::Spec->splitdir($first);
    my @second_dirs = File::Spec->splitdir($second);
  
    return 0 if @second_dirs < @first_dirs;
  
    my $is_same = ( $self->_case_tolerant
                    ? sub {lc(shift()) eq lc(shift())}
                    : sub {shift() eq shift()} );
  
    while (@first_dirs) {
      return 0 unless $is_same->(shift @first_dirs, shift @second_dirs);
    }
  
    return 1;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Base - Default methods for Module::Build
  
  =head1 SYNOPSIS
  
    Please see the Module::Build documentation.
  
  =head1 DESCRIPTION
  
  The C<Module::Build::Base> module defines the core functionality of
  C<Module::Build>.  Its methods may be overridden by any of the
  platform-dependent modules in the C<Module::Build::Platform::>
  namespace, but the intention here is to make this base module as
  platform-neutral as possible.  Nicely enough, Perl has several core
  tools available in the C<File::> namespace for doing this, so the task
  isn't very difficult.
  
  Please see the C<Module::Build> documentation for more details.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3)
  
  =cut
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  
  use File::Basename ();
  use File::Spec;
  use Config;
  use Module::Build;
  use Module::Metadata;
  use version;
  use Data::Dumper;
  
  my %convert_installdirs = (
      PERL        => 'core',
      SITE        => 'site',
      VENDOR      => 'vendor',
  );
  
  my %makefile_to_build =
    (
     TEST_VERBOSE => 'verbose',
     VERBINST     => 'verbose',
     INC          => sub { map {(extra_compiler_flags => $_)} Module::Build->split_like_shell(shift) },
     POLLUTE      => sub { (extra_compiler_flags => '-DPERL_POLLUTE') },
     INSTALLDIRS  => sub { (installdirs => $convert_installdirs{uc shift()}) },
     LIB          => sub {
         my $lib = shift;
         my %config = (
             installprivlib  => $lib,
             installsitelib  => $lib,
             installarchlib  => "$lib/$Config{archname}",
             installsitearch => "$lib/$Config{archname}"
         );
         return map { (config => "$_=$config{$_}") } sort keys %config;
     },
  
     # Convert INSTALLVENDORLIB and friends.
     (
         map {
             my $name = $_;
             $name => sub {
                   my @ret = (config => lc($name) . "=" . shift );
                   print STDERR "# Converted to @ret\n";
  
                   return @ret;
             }
         } qw(
           INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
           INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
           INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
           INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
           INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
           INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR
         )
     ),
  
     # Some names they have in common
     map {$_, lc($_)} qw(DESTDIR PREFIX INSTALL_BASE UNINST),
    );
  
  my %macro_to_build = %makefile_to_build;
  # "LIB=foo make" is not the same as "perl Makefile.PL LIB=foo"
  delete $macro_to_build{LIB};
  
  sub _merge_prereq {
    my ($req, $breq) = @_;
    $req ||= {};
    $breq ||= {};
  
    # validate formats
    for my $p ( $req, $breq ) {
      for my $k (sort keys %$p) {
        next if $k eq 'perl';
  
        my $v_obj = eval { version->new($p->{$k}) };
        if ( ! defined $v_obj ) {
            die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n";
        }
  
        # It seems like a lot of people trip over "0.1.2" stuff, so we help them here...
        if ( $v_obj->is_qv ) {
          my $proper_ver = $v_obj->numify;
          warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";
          $p->{$k} = $proper_ver;
        }
      }
    }
    # merge
    my $merge = { %$req };
    for my $k ( keys %$breq ) {
      my $v1 = $merge->{$k} || 0;
      my $v2 = $breq->{$k};
      $merge->{$k} = $v1 > $v2 ? $v1 : $v2;
    }
    return %$merge;
  }
  
  
  sub create_makefile_pl {
    my ($package, $type, $build, %args) = @_;
  
    die "Don't know how to build Makefile.PL of type '$type'"
      unless $type =~ /^(small|passthrough|traditional)$/;
  
    if ($type eq 'passthrough') {
      $build->log_warn(<<"HERE");
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
    }
  
    my $fh;
    if ($args{fh}) {
      $fh = $args{fh};
    } else {
      $args{file} ||= 'Makefile.PL';
      local $build->{properties}{quiet} = 1;
      $build->delete_filetree($args{file});
      open($fh, '>', "$args{file}") or die "Can't write $args{file}: $!";
    }
  
    print {$fh} "# Note: this file was auto-generated by ", __PACKAGE__, " version $VERSION\n";
  
    # Minimum perl version should be specified as "require 5.XXXXXX" in
    # Makefile.PL
    my $requires = $build->requires;
    if ( my $minimum_perl = $requires->{perl} ) {
      my $min_ver = version->new($minimum_perl)->numify;
      print {$fh} "require $min_ver;\n";
    }
  
    # If a *bundled* custom subclass is being used, make sure we add its
    # directory to @INC.  Also, lib.pm always needs paths in Unix format.
    my $subclass_load = '';
    if (ref($build) ne "Module::Build") {
      my $subclass_dir = $package->subclass_dir($build);
  
      if (File::Spec->file_name_is_absolute($subclass_dir)) {
        my $base_dir = $build->base_dir;
  
        if ($build->dir_contains($base_dir, $subclass_dir)) {
  	$subclass_dir = File::Spec->abs2rel($subclass_dir, $base_dir);
  	$subclass_dir = $package->unixify_dir($subclass_dir);
          $subclass_load = "use lib '$subclass_dir';";
        }
        # Otherwise, leave it the empty string
  
      } else {
        $subclass_dir = $package->unixify_dir($subclass_dir);
        $subclass_load = "use lib '$subclass_dir';";
      }
    }
  
    if ($type eq 'small') {
      printf {$fh} <<'EOF', $subclass_load, ref($build), ref($build);
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
    } elsif ($type eq 'passthrough') {
      printf {$fh} <<'EOF', $subclass_load, ref($build), ref($build);
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
    } elsif ($type eq 'traditional') {
  
      my (%MM_Args, %prereq);
      if (eval "use Tie::IxHash 1.2; 1") {
        tie %MM_Args, 'Tie::IxHash'; # Don't care if it fails here
        tie %prereq,  'Tie::IxHash'; # Don't care if it fails here
      }
  
      my %name = ($build->module_name
  		? (NAME => $build->module_name)
  		: (DISTNAME => $build->dist_name));
  
      my %version = ($build->dist_version_from
  		   ? (VERSION_FROM => $build->dist_version_from)
  		   : (VERSION      => $build->dist_version)
  		  );
      %MM_Args = (%name, %version);
  
      %prereq = _merge_prereq( $build->requires, $build->build_requires );
      %prereq = map {$_, $prereq{$_}} sort keys %prereq;
  
       delete $prereq{perl};
      $MM_Args{PREREQ_PM} = \%prereq;
  
      $MM_Args{INSTALLDIRS} = $build->installdirs eq 'core' ? 'perl' : $build->installdirs;
  
      $MM_Args{EXE_FILES} = [ sort keys %{$build->script_files} ] if $build->script_files;
  
      $MM_Args{PL_FILES} = $build->PL_files || {};
  
      if ($build->recursive_test_files) {
          $MM_Args{test} = { TESTS => join q{ }, $package->_test_globs($build) };
      }
  
      local $Data::Dumper::Terse = 1;
      my $args = Data::Dumper::Dumper(\%MM_Args);
      $args =~ s/\{(.*)\}/($1)/s;
  
      print $fh <<"EOF";
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
    }
  }
  
  sub _test_globs {
    my ($self, $build) = @_;
  
    return map { File::Spec->catfile($_, '*.t') }
           @{$build->rscan_dir('t', sub { -d $File::Find::name })};
  }
  
  sub subclass_dir {
    my ($self, $build) = @_;
  
    return (Module::Metadata->find_module_dir_by_name(ref $build)
  	  || File::Spec->catdir($build->config_dir, 'lib'));
  }
  
  sub unixify_dir {
    my ($self, $path) = @_;
    return join '/', File::Spec->splitdir($path);
  }
  
  sub makefile_to_build_args {
    my $class = shift;
    my @out;
    foreach my $arg (@_) {
      next if $arg eq '';
  
      my ($key, $val) = ($arg =~ /^(\w+)=(.+)/ ? ($1, $2) :
  		       die "Malformed argument '$arg'");
  
      # Do tilde-expansion if it looks like a tilde prefixed path
      ( $val ) = Module::Build->_detildefy( $val ) if $val =~ /^~/;
  
      if (exists $makefile_to_build{$key}) {
        my $trans = $makefile_to_build{$key};
        push @out, $class->_argvify( ref($trans) ? $trans->($val) : ($trans => $val) );
      } elsif (exists $Config{lc($key)}) {
        push @out, $class->_argvify( config => lc($key) . "=$val" );
      } else {
        # Assume M::B can handle it in lowercase form
        push @out, $class->_argvify("\L$key" => $val);
      }
    }
    return @out;
  }
  
  sub _argvify {
    my ($self, @pairs) = @_;
    my @out;
    while (@pairs) {
      my ($k, $v) = splice @pairs, 0, 2;
      push @out, ("--$k", $v);
    }
    return @out;
  }
  
  sub makefile_to_build_macros {
    my @out;
    my %config; # must accumulate and return as a hashref
    foreach my $macro (sort keys %macro_to_build) {
      my $trans = $macro_to_build{$macro};
      # On some platforms (e.g. Cygwin with 'make'), the mere presence
      # of "EXPORT: FOO" in the Makefile will make $ENV{FOO} defined.
      # Therefore we check length() too.
      next unless exists $ENV{$macro} && length $ENV{$macro};
      my $val = $ENV{$macro};
      my @args = ref($trans) ? $trans->($val) : ($trans => $val);
      while (@args) {
        my ($k, $v) = splice(@args, 0, 2);
        if ( $k eq 'config' ) {
          if ( $v =~ /^([^=]+)=(.*)$/ ) {
            $config{$1} = $2;
          }
          else {
            warn "Couldn't parse config '$v'\n";
          }
        }
        else {
          push @out, ($k => $v);
        }
      }
    }
    push @out, (config => \%config) if %config;
    return @out;
  }
  
  sub run_build_pl {
    my ($pack, %in) = @_;
    $in{script} ||= 'Build.PL';
    my @args = $in{args} ? $pack->makefile_to_build_args(@{$in{args}}) : ();
    print "# running $in{script} @args\n";
    Module::Build->run_perl_script($in{script}, [], \@args) or die "Couldn't run $in{script}: $!";
  }
  
  sub fake_makefile {
    my ($self, %args) = @_;
    unless (exists $args{build_class}) {
      warn "Unknown 'build_class', defaulting to 'Module::Build'\n";
      $args{build_class} = 'Module::Build';
    }
    my $class = $args{build_class};
  
    my $perl = $class->find_perl_interpreter;
  
    # VMS MMS/MMK need to use MCR to run the Perl image.
    $perl = 'MCR ' . $perl if $self->_is_vms_mms;
  
    my $noop = ($class->is_windowsish ? 'rem>nul'  :
  	      $self->_is_vms_mms    ? 'Continue' :
  	      'true');
  
    my $filetype = $class->is_vmsish ? '.COM' : '';
  
    my $Build = 'Build' . $filetype . ' --makefile_env_macros 1';
    my $unlink = $class->oneliner('1 while unlink $ARGV[0]', [], [$args{makefile}]);
    $unlink =~ s/\$/\$\$/g unless $class->is_vmsish;
  
    my $maketext = join '', map { "$_=\n" } sort keys %macro_to_build;
  
    $maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n"
                      : $^O eq 'MSWin32' && $Config{make} =~ /gmake/
                      ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");
  
    $maketext .= <<"EOF";
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  
    foreach my $action ($class->known_actions) {
      next if $action =~ /^(all|distclean|realclean|force_do_it)$/;  # Don't double-define
      $maketext .= <<"EOF";
  $action : force_do_it
  	$perl $Build $action
  EOF
    }
  
    if ($self->_is_vms_mms) {
      # Roll our own .EXPORT as MMS/MMK don't honor that directive.
      $maketext .= "\n.FIRST\n\t\@ $noop\n";
      for my $macro (sort keys %macro_to_build) {
        $maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n";
      }
      $maketext .= "\n";
    }
    else {
      $maketext .= "\n.EXPORT : " . join(' ', sort keys %macro_to_build) . "\n\n";
    }
  
    return $maketext;
  }
  
  sub fake_prereqs {
    my $file = File::Spec->catfile('_build', 'prereqs');
    open(my $fh, '<', "$file") or die "Can't read $file: $!";
    my $prereqs = eval do {local $/; <$fh>};
    close $fh;
  
    my %merged = _merge_prereq( $prereqs->{requires}, $prereqs->{build_requires} );
    my @prereq;
    foreach (sort keys %merged) {
      next if $_ eq 'perl';
      push @prereq, "$_=>q[$merged{$_}]";
    }
    return unless @prereq;
    return "#     PREREQ_PM => { " . join(", ", @prereq) . " }\n\n";
  }
  
  
  sub write_makefile {
    my ($pack, %in) = @_;
  
    unless (exists $in{build_class}) {
      warn "Unknown 'build_class', defaulting to 'Module::Build'\n";
      $in{build_class} = 'Module::Build';
    }
    my $class = $in{build_class};
    $in{makefile} ||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';
  
    open  MAKE, "> $in{makefile}" or die "Cannot write $in{makefile}: $!";
    print MAKE $pack->fake_prereqs;
    print MAKE $pack->fake_makefile(%in);
    close MAKE;
  }
  
  sub _is_vms_mms {
    return Module::Build->is_vmsish && ($Config{make} =~ m/MM[SK]/i);
  }
  
  1;
  __END__
  
  =for :stopwords passthrough
  
  =head1 NAME
  
  Module::Build::Compat - Compatibility with ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
    # In a Build.PL :
    use Module::Build;
    my $build = Module::Build->new
      ( module_name => 'Foo::Bar',
        license     => 'perl',
        create_makefile_pl => 'traditional' );
    ...
  
  
  =head1 DESCRIPTION
  
  Because C<ExtUtils::MakeMaker> has been the standard way to distribute
  modules for a long time, many tools (CPAN.pm, or your system
  administrator) may expect to find a working F<Makefile.PL> in every
  distribution they download from CPAN.  If you want to throw them a
  bone, you can use C<Module::Build::Compat> to automatically generate a
  F<Makefile.PL> for you, in one of several different styles.
  
  C<Module::Build::Compat> also provides some code that helps out the
  F<Makefile.PL> at runtime.
  
  
  =head1 METHODS
  
  =over 4
  
  =item create_makefile_pl($style, $build)
  
  Creates a F<Makefile.PL> in the current directory in one of several
  styles, based on the supplied C<Module::Build> object C<$build>.  This is
  typically controlled by passing the desired style as the
  C<create_makefile_pl> parameter to C<Module::Build>'s C<new()> method;
  the F<Makefile.PL> will then be automatically created during the
  C<distdir> action.
  
  The currently supported styles are:
  
  =over 4
  
  =item traditional
  
  A F<Makefile.PL> will be created in the "traditional" style, i.e. it will
  use C<ExtUtils::MakeMaker> and won't rely on C<Module::Build> at all.
  In order to create the F<Makefile.PL>, we'll include the C<requires> and
  C<build_requires> dependencies as the C<PREREQ_PM> parameter.
  
  You don't want to use this style if during the C<perl Build.PL> stage
  you ask the user questions, or do some auto-sensing about the user's
  environment, or if you subclass C<Module::Build> to do some
  customization, because the vanilla F<Makefile.PL> won't do any of that.
  
  =item small
  
  A small F<Makefile.PL> will be created that passes all functionality
  through to the F<Build.PL> script in the same directory.  The user must
  already have C<Module::Build> installed in order to use this, or else
  they'll get a module-not-found error.
  
  =item passthrough (DEPRECATED)
  
  This is just like the C<small> option above, but if C<Module::Build> is
  not already installed on the user's system, the script will offer to
  use C<CPAN.pm> to download it and install it before continuing with
  the build.
  
  This option has been deprecated and may be removed in a future version
  of Module::Build.  Modern CPAN.pm and CPANPLUS will recognize the
  C<configure_requires> metadata property and install Module::Build before
  running Build.PL if Module::Build is listed and Module::Build now
  adds itself to configure_requires by default.
  
  Perl 5.10.1 includes C<configure_requires> support.  In the future, when
  C<configure_requires> support is deemed sufficiently widespread, the
  C<passthrough> style will be removed.
  
  =back
  
  =item run_build_pl(args => \@ARGV)
  
  This method runs the F<Build.PL> script, passing it any arguments the
  user may have supplied to the C<perl Makefile.PL> command.  Because
  C<ExtUtils::MakeMaker> and C<Module::Build> accept different arguments, this
  method also performs some translation between the two.
  
  C<run_build_pl()> accepts the following named parameters:
  
  =over 4
  
  =item args
  
  The C<args> parameter specifies the parameters that would usually
  appear on the command line of the C<perl Makefile.PL> command -
  typically you'll just pass a reference to C<@ARGV>.
  
  =item script
  
  This is the filename of the script to run - it defaults to C<Build.PL>.
  
  =back
  
  =item write_makefile()
  
  This method writes a 'dummy' F<Makefile> that will pass all commands
  through to the corresponding C<Module::Build> actions.
  
  C<write_makefile()> accepts the following named parameters:
  
  =over 4
  
  =item makefile
  
  The name of the file to write - defaults to the string C<Makefile>.
  
  =back
  
  =back
  
  
  =head1 SCENARIOS
  
  So, some common scenarios are:
  
  =over 4
  
  =item 1.
  
  Just include a F<Build.PL> script (without a F<Makefile.PL>
  script), and give installation directions in a F<README> or F<INSTALL>
  document explaining how to install the module.  In particular, explain
  that the user must install C<Module::Build> before installing your
  module.
  
  Note that if you do this, you may make things easier for yourself, but
  harder for people with older versions of CPAN or CPANPLUS on their
  system, because those tools generally only understand the
  F<Makefile.PL>/C<ExtUtils::MakeMaker> way of doing things.
  
  =item 2.
  
  Include a F<Build.PL> script and a "traditional" F<Makefile.PL>,
  created either manually or with C<create_makefile_pl()>.  Users won't
  ever have to install C<Module::Build> if they use the F<Makefile.PL>, but
  they won't get to take advantage of C<Module::Build>'s extra features
  either.
  
  For good measure, of course, test both the F<Makefile.PL> and the
  F<Build.PL> before shipping.
  
  =item 3.
  
  Include a F<Build.PL> script and a "pass-through" F<Makefile.PL>
  built using C<Module::Build::Compat>.  This will mean that people can
  continue to use the "old" installation commands, and they may never
  notice that it's actually doing something else behind the scenes.  It
  will also mean that your installation process is compatible with older
  versions of tools like CPAN and CPANPLUS.
  
  =back
  
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  L<Module::Build>(3), L<ExtUtils::MakeMaker>(3)
  
  
  =cut
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Config;
  
  sub new {
    my ($pack, %args) = @_;
    return bless {
  		stack => {},
  		values => $args{values} || {},
  	       }, $pack;
  }
  
  sub get {
    my ($self, $key) = @_;
    return $self->{values}{$key} if ref($self) && exists $self->{values}{$key};
    return $Config{$key};
  }
  
  sub set {
    my ($self, $key, $val) = @_;
    $self->{values}{$key} = $val;
  }
  
  sub push {
    my ($self, $key, $val) = @_;
    push @{$self->{stack}{$key}}, $self->{values}{$key}
      if exists $self->{values}{$key};
    $self->{values}{$key} = $val;
  }
  
  sub pop {
    my ($self, $key) = @_;
  
    my $val = delete $self->{values}{$key};
    if ( exists $self->{stack}{$key} ) {
      $self->{values}{$key} = pop @{$self->{stack}{$key}};
      delete $self->{stack}{$key} unless @{$self->{stack}{$key}};
    }
  
    return $val;
  }
  
  sub values_set {
    my $self = shift;
    return undef unless ref($self);
    return $self->{values};
  }
  
  sub all_config {
    my $self = shift;
    my $v = ref($self) ? $self->{values} : {};
    return {%Config, %$v};
  }
  
  1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  
  =head1 NAME
  
  Module::Build::ConfigData - Configuration for Module::Build
  
  =head1 SYNOPSIS
  
    use Module::Build::ConfigData;
    $value = Module::Build::ConfigData->config('foo');
    $value = Module::Build::ConfigData->feature('bar');
  
    @names = Module::Build::ConfigData->config_names;
    @names = Module::Build::ConfigData->feature_names;
  
    Module::Build::ConfigData->set_config(foo => $new_value);
    Module::Build::ConfigData->set_feature(bar => $new_value);
    Module::Build::ConfigData->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<Module::Build>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<Module::Build::ConfigData>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<Module::Build::ConfigData>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<Module::Build::ConfigData>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<Module::Build::ConfigData> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<Module::Build::ConfigData> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<Module::Build::ConfigData>.
  
  =cut
  
  
  __DATA__
  do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  
  
  =head1 NAME
  
  Module::Build::Cookbook - Examples of Module::Build Usage
  
  =head1 DESCRIPTION
  
  C<Module::Build> isn't conceptually very complicated, but examples are
  always helpful.  The following recipes should help developers and/or
  installers put together the pieces from the other parts of the
  documentation.
  
  
  =head1 BASIC RECIPES
  
  
  =head2 Installing modules that use Module::Build
  
  In most cases, you can just issue the following commands:
  
    perl Build.PL
    ./Build
    ./Build test
    ./Build install
  
  There's nothing complicated here - first you're running a script
  called F<Build.PL>, then you're running a (newly-generated) script
  called F<Build> and passing it various arguments.
  
  The exact commands may vary a bit depending on how you invoke perl
  scripts on your system.  For instance, if you have multiple versions
  of perl installed, you can install to one particular perl's library
  directories like so:
  
    /usr/bin/perl5.8.1 Build.PL
    ./Build
    ./Build test
    ./Build install
  
  If you're on Windows where the current directory is always searched
  first for scripts, you'll probably do something like this:
  
    perl Build.PL
    Build
    Build test
    Build install
  
  On the old Mac OS (version 9 or lower) using MacPerl, you can
  double-click on the F<Build.PL> script to create the F<Build> script,
  then double-click on the F<Build> script to run its C<build>, C<test>,
  and C<install> actions.
  
  The F<Build> script knows what perl was used to run F<Build.PL>, so
  you don't need to re-invoke the F<Build> script with the complete perl
  path each time.  If you invoke it with the I<wrong> perl path, you'll
  get a warning or a fatal error.
  
  =head2 Modifying Config.pm values
  
  C<Module::Build> relies heavily on various values from perl's
  C<Config.pm> to do its work.  For example, default installation paths
  are given by C<installsitelib> and C<installvendorman3dir> and
  friends, C linker & compiler settings are given by C<ld>,
  C<lddlflags>, C<cc>, C<ccflags>, and so on.  I<If you're pretty sure
  you know what you're doing>, you can tell C<Module::Build> to pretend
  there are different values in F<Config.pm> than what's really there,
  by passing arguments for the C<--config> parameter on the command
  line:
  
    perl Build.PL --config cc=gcc --config ld=gcc
  
  Inside the C<Build.PL> script the same thing can be accomplished by
  passing values for the C<config> parameter to C<new()>:
  
   my $build = Module::Build->new
     (
      ...
      config => { cc => 'gcc', ld => 'gcc' },
      ...
     );
  
  In custom build code, the same thing can be accomplished by calling
  the L<Module::Build/config> method:
  
   $build->config( cc => 'gcc' );     # Set
   $build->config( ld => 'gcc' );     # Set
   ...
   my $linker = $build->config('ld'); # Get
  
  
  =head2 Installing modules using the programmatic interface
  
  If you need to build, test, and/or install modules from within some
  other perl code (as opposed to having the user type installation
  commands at the shell), you can use the programmatic interface.
  Create a Module::Build object (or an object of a custom Module::Build
  subclass) and then invoke its C<dispatch()> method to run various
  actions.
  
    my $build = Module::Build->new
      (
       module_name => 'Foo::Bar',
       license     => 'perl',
       requires    => { 'Some::Module'   => '1.23' },
      );
    $build->dispatch('build');
    $build->dispatch('test', verbose => 1);
    $build->dispatch('install');
  
  The first argument to C<dispatch()> is the name of the action, and any
  following arguments are named parameters.
  
  This is the interface we use to test Module::Build itself in the
  regression tests.
  
  
  =head2 Installing to a temporary directory
  
  To create packages for package managers like RedHat's C<rpm> or
  Debian's C<deb>, you may need to install to a temporary directory
  first and then create the package from that temporary installation.
  To do this, specify the C<destdir> parameter to the C<install> action:
  
    ./Build install --destdir /tmp/my-package-1.003
  
  This essentially just prepends all the installation paths with the
  F</tmp/my-package-1.003> directory.
  
  
  =head2 Installing to a non-standard directory
  
  To install to a non-standard directory (for example, if you don't have
  permission to install in the system-wide directories), you can use the
  C<install_base> or C<prefix> parameters:
  
    ./Build install --install_base /foo/bar
  
  See L<Module::Build/"INSTALL PATHS"> for a much more complete
  discussion of how installation paths are determined.
  
  
  =head2 Installing in the same location as ExtUtils::MakeMaker
  
  With the introduction of C<--prefix> in Module::Build 0.28 and
  C<INSTALL_BASE> in C<ExtUtils::MakeMaker> 6.31 its easy to get them both
  to install to the same locations.
  
  First, ensure you have at least version 0.28 of Module::Build
  installed and 6.31 of C<ExtUtils::MakeMaker>.  Prior versions have
  differing (and in some cases quite strange) installation behaviors.
  
  The following installation flags are equivalent between
  C<ExtUtils::MakeMaker> and C<Module::Build>.
  
      MakeMaker             Module::Build
      PREFIX=...            --prefix ...
      INSTALL_BASE=...      --install_base ...
      DESTDIR=...           --destdir ...
      LIB=...               --install_path lib=...
      INSTALLDIRS=...       --installdirs ...
      INSTALLDIRS=perl      --installdirs core
      UNINST=...            --uninst ...
      INC=...               --extra_compiler_flags ...
      POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE
  
  For example, if you are currently installing C<MakeMaker> modules with
  this command:
  
      perl Makefile.PL PREFIX=~
      make test
      make install UNINST=1
  
  You can install into the same location with Module::Build using this:
  
      perl Build.PL --prefix ~
      ./Build test
      ./Build install --uninst 1
  
  =head3 C<prefix> vs C<install_base>
  
  The behavior of C<prefix> is complicated and depends on
  how your Perl is configured.  The resulting installation locations
  will vary from machine to machine and even different installations of
  Perl on the same machine.  Because of this, it's difficult to document
  where C<prefix> will place your modules.
  
  In contrast, C<install_base> has predictable, easy to explain
  installation locations.  Now that C<Module::Build> and C<MakeMaker> both
  have C<install_base> there is little reason to use C<prefix> other
  than to preserve your existing installation locations.  If you are
  starting a fresh Perl installation we encourage you to use
  C<install_base>.  If you have an existing installation installed via
  C<prefix>, consider moving it to an installation structure matching
  C<install_base> and using that instead.
  
  
  =head2 Running a single test file
  
  C<Module::Build> supports running a single test, which enables you to
  track down errors more quickly.  Use the following format:
  
    ./Build test --test_files t/mytest.t
  
  In addition, you may want to run the test in verbose mode to get more
  informative output:
  
    ./Build test --test_files t/mytest.t --verbose 1
  
  I run this so frequently that I define the following shell alias:
  
    alias t './Build test --verbose 1 --test_files'
  
  So then I can just execute C<t t/mytest.t> to run a single test.
  
  
  =head1 ADVANCED RECIPES
  
  
  =head2 Making a CPAN.pm-compatible distribution
  
  New versions of CPAN.pm understand how to use a F<Build.PL> script,
  but old versions don't.  If authors want to help users who have old
  versions, some form of F<Makefile.PL> should be supplied.  The easiest
  way to accomplish this is to use the C<create_makefile_pl> parameter to
  C<< Module::Build->new() >> in the C<Build.PL> script, which can
  create various flavors of F<Makefile.PL> during the C<dist> action.
  
  As a best practice, we recommend using the "traditional" style of
  F<Makefile.PL> unless your distribution has needs that can't be
  accomplished that way.
  
  The C<Module::Build::Compat> module, which is part of
  C<Module::Build>'s distribution, is responsible for creating these
  F<Makefile.PL>s.  Please see L<Module::Build::Compat> for the details.
  
  
  =head2 Changing the order of the build process
  
  The C<build_elements> property specifies the steps C<Module::Build>
  will take when building a distribution.  To change the build order,
  change the order of the entries in that property:
  
    # Process pod files first
    my @e = @{$build->build_elements};
    my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;
    unshift @e, splice @e, $i, 1;
  
  Currently, C<build_elements> has the following default value:
  
    [qw( PL support pm xs pod script )]
  
  Do take care when altering this property, since there may be
  non-obvious (and non-documented!) ordering dependencies in the
  C<Module::Build> code.
  
  
  =head2 Adding new file types to the build process
  
  Sometimes you might have extra types of files that you want to install
  alongside the standard types like F<.pm> and F<.pod> files.  For
  instance, you might have a F<Bar.dat> file containing some data
  related to the C<Foo::Bar> module and you'd like for it to end up as
  F<Foo/Bar.dat> somewhere in perl's C<@INC> path so C<Foo::Bar> can
  access it easily at runtime.  The following code from a sample
  C<Build.PL> file demonstrates how to accomplish this:
  
    use Module::Build;
    my $build = Module::Build->new
      (
       module_name => 'Foo::Bar',
       ...other stuff here...
      );
    $build->add_build_element('dat');
    $build->create_build_script;
  
  This will find all F<.dat> files in the F<lib/> directory, copy them
  to the F<blib/lib/> directory during the C<build> action, and install
  them during the C<install> action.
  
  If your extra files aren't located in the C<lib/> directory in your
  distribution, you can explicitly say where they are, just as you'd do
  with F<.pm> or F<.pod> files:
  
    use Module::Build;
    my $build = new Module::Build
      (
       module_name => 'Foo::Bar',
       dat_files => {'some/dir/Bar.dat' => 'lib/Foo/Bar.dat'},
       ...other stuff here...
      );
    $build->add_build_element('dat');
    $build->create_build_script;
  
  If your extra files actually need to be created on the user's machine,
  or if they need some other kind of special processing, you'll probably
  want to subclass C<Module::Build> and create a special method to
  process them, named C<process_${kind}_files()>:
  
    use Module::Build;
    my $class = Module::Build->subclass(code => <<'EOF');
      sub process_dat_files {
        my $self = shift;
        ... locate and process *.dat files,
        ... and create something in blib/lib/
      }
    EOF
    my $build = $class->new
      (
       module_name => 'Foo::Bar',
       ...other stuff here...
      );
    $build->add_build_element('dat');
    $build->create_build_script;
  
  If your extra files don't go in F<lib/> but in some other place, see
  L<"Adding new elements to the install process"> for how to actually
  get them installed.
  
  Please note that these examples use some capabilities of Module::Build
  that first appeared in version 0.26.  Before that it could
  still be done, but the simple cases took a bit more work.
  
  
  =head2 Adding new elements to the install process
  
  By default, Module::Build creates seven subdirectories of the F<blib>
  directory during the build process: F<lib>, F<arch>, F<bin>,
  F<script>, F<bindoc>, F<libdoc>, and F<html> (some of these may be
  missing or empty if there's nothing to go in them).  Anything copied
  to these directories during the build will eventually be installed
  during the C<install> action (see L<Module::Build/"INSTALL PATHS">.
  
  If you need to create a new custom type of installable element, e.g. C<conf>,
  then you need to tell Module::Build where things in F<blib/conf/>
  should be installed.  To do this, use the C<install_path> parameter to
  the C<new()> method:
  
    my $build = Module::Build->new
      (
       ...other stuff here...
       install_path => { conf => $installation_path }
      );
  
  Or you can call the C<install_path()> method later:
  
    $build->install_path(conf => $installation_path);
  
  The user may also specify the path on the command line:
  
    perl Build.PL --install_path conf=/foo/path/etc
  
  The important part, though, is that I<somehow> the install path needs
  to be set, or else nothing in the F<blib/conf/> directory will get
  installed, and a runtime error during the C<install> action will
  result.
  
  See also L<"Adding new file types to the build process"> for how to
  create the stuff in F<blib/conf/> in the first place.
  
  
  =head1 EXAMPLES ON CPAN
  
  Several distributions on CPAN are making good use of various features
  of Module::Build.  They can serve as real-world examples for others.
  
  
  =head2 SVN-Notify-Mirror
  
  L<http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/>
  
  John Peacock, author of the C<SVN-Notify-Mirror> distribution, says:
  
  =over 4
  
  =item 1. Using C<auto_features>, I check to see whether two optional
  modules are available - SVN::Notify::Config and Net::SSH;
  
  =item 2. If the S::N::Config module is loaded, I automatically
  generate test files for it during Build (using the C<PL_files>
  property).
  
  =item 3. If the C<ssh_feature> is available, I ask if the user wishes
  to perform the ssh tests (since it requires a little preliminary
  setup);
  
  =item 4. Only if the user has C<ssh_feature> and answers yes to the
  testing, do I generate a test file.
  
  I'm sure I could not have handled this complexity with EU::MM, but it
  was very easy to do with M::B.
  
  =back
  
  
  =head2 Modifying an action
  
  Sometimes you might need an to have an action, say C<./Build install>,
  do something unusual.  For instance, you might need to change the
  ownership of a file or do something else peculiar to your application.
  
  You can subclass C<Module::Build> on the fly using the C<subclass()>
  method and override the methods that perform the actions.  You may
  need to read through C<Module::Build::Authoring> and
  C<Module::Build::API> to find the methods you want to override.  All
  "action" methods are implemented by a method called "ACTION_" followed
  by the action's name, so here's an example of how it would work for
  the C<install> action:
  
    # Build.PL
    use Module::Build;
    my $class = Module::Build->subclass(
        class => "Module::Build::Custom",
        code => <<'SUBCLASS' );
  
    sub ACTION_install {
        my $self = shift;
        # YOUR CODE HERE
        $self->SUPER::ACTION_install;
    }
    SUBCLASS
  
    $class->new(
        module_name => 'Your::Module',
        # rest of the usual Module::Build parameters
    )->create_build_script;
  
  
  =head2 Adding an action
  
  You can add a new C<./Build> action simply by writing the method for
  it in your subclass.  Use C<depends_on> to declare that another action
  must have been run before your action.
  
  For example, let's say you wanted to be able to write C<./Build
  commit> to test your code and commit it to Subversion.
  
    # Build.PL
    use Module::Build;
    my $class = Module::Build->subclass(
        class => "Module::Build::Custom",
        code => <<'SUBCLASS' );
  
    sub ACTION_commit {
        my $self = shift;
  
        $self->depends_on("test");
        $self->do_system(qw(svn commit));
    }
    SUBCLASS
  
  
  =head2 Bundling Module::Build
  
  Note: This section probably needs an update as the technology improves
  (see contrib/bundle.pl in the distribution).
  
  Suppose you want to use some new-ish features of Module::Build,
  e.g. newer than the version of Module::Build your users are likely to
  already have installed on their systems.  The first thing you should
  do is set C<configure_requires> to your minimum version of
  Module::Build.  See L<Module::Build::Authoring>.
  
  But not every build system honors C<configure_requires> yet.  Here's
  how you can ship a copy of Module::Build, but still use a newer
  installed version to take advantage of any bug fixes and upgrades.
  
  First, install Module::Build into F<Your-Project/inc/Module-Build>.
  CPAN will not index anything in the F<inc> directory so this copy will
  not show up in CPAN searches.
  
      cd Module-Build
      perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build
      ./Build test
      ./Build install
  
  You should now have all the Module::Build .pm files in
  F<Your-Project/inc/Module-Build/lib/perl5>.
  
  Next, add this to the top of your F<Build.PL>.
  
      my $Bundled_MB = 0.30;  # or whatever version it was.
  
      # Find out what version of Module::Build is installed or fail quietly.
      # This should be cross-platform.
      my $Installed_MB =
          `$^X -e "eval q{require Module::Build; print Module::Build->VERSION} or exit 1"`;
  
      # some operating systems put a newline at the end of every print.
      chomp $Installed_MB;
  
      $Installed_MB = 0 if $?;
  
      # Use our bundled copy of Module::Build if it's newer than the installed.
      unshift @INC, "inc/Module-Build/lib/perl5" if $Bundled_MB > $Installed_MB;
  
      require Module::Build;
  
  And write the rest of your F<Build.PL> normally.  Module::Build will
  remember your change to C<@INC> and use it when you run F<./Build>.
  
  In the future, we hope to provide a more automated solution for this
  scenario; see C<inc/latest.pm> in the Module::Build distribution for
  one indication of the direction we're moving.
  
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2008 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  perl(1), L<Module::Build>(3), L<Module::Build::Authoring>(3),
  L<Module::Build::API>(3)
  
  =cut
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  
  # This is just a split-out of a wrapper function to do Data::Dumper
  # stuff "the right way".  See:
  # http://groups.google.com/group/perl.module.build/browse_thread/thread/c8065052b2e0d741
  
  use Data::Dumper;
  
  sub _data_dump {
    my ($self, $data) = @_;
    return ("do{ my "
  	  . Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump()
  	  . '$x; }')
  }
  
  1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;
  
  # A class for persistent hashes
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Data::Dumper;
  use Module::Build::Dumper;
  
  sub new {
    my ($class, %args) = @_;
    my $file = delete $args{file} or die "Missing required parameter 'file' to new()";
    my $self = bless {
  		    disk => {},
  		    new  => {},
  		    file => $file,
  		    %args,
  		   }, $class;
  }
  
  sub restore {
    my $self = shift;
  
    open(my $fh, '<', $self->{file}) or die "Can't read $self->{file}: $!";
    $self->{disk} = eval do {local $/; <$fh>};
    die $@ if $@;
    close $fh;
    $self->{new} = {};
  }
  
  sub access {
    my $self = shift;
    return $self->read() unless @_;
  
    my $key = shift;
    return $self->read($key) unless @_;
  
    my $value = shift;
    $self->write({ $key => $value });
    return $self->read($key);
  }
  
  sub has_data {
    my $self = shift;
    return keys %{$self->read()} > 0;
  }
  
  sub exists {
    my ($self, $key) = @_;
    return exists($self->{new}{$key}) || exists($self->{disk}{$key});
  }
  
  sub read {
    my $self = shift;
  
    if (@_) {
      # Return 1 key as a scalar
      my $key = shift;
      return $self->{new}{$key} if exists $self->{new}{$key};
      return $self->{disk}{$key};
    }
  
    # Return all data
    my $out = (keys %{$self->{new}}
  	     ? {%{$self->{disk}}, %{$self->{new}}}
  	     : $self->{disk});
    return wantarray ? %$out : $out;
  }
  
  sub _same {
    my ($self, $x, $y) = @_;
    return 1 if !defined($x) and !defined($y);
    return 0 if !defined($x) or  !defined($y);
    return $x eq $y;
  }
  
  sub write {
    my ($self, $href) = @_;
    $href ||= {};
  
    @{$self->{new}}{ keys %$href } = values %$href;  # Merge
  
    # Do some optimization to avoid unnecessary writes
    foreach my $key (keys %{ $self->{new} }) {
      next if ref $self->{new}{$key};
      next if ref $self->{disk}{$key} or !exists $self->{disk}{$key};
      delete $self->{new}{$key} if $self->_same($self->{new}{$key}, $self->{disk}{$key});
    }
  
    if (my $file = $self->{file}) {
      my ($vol, $dir, $base) = File::Spec->splitpath($file);
      $dir = File::Spec->catpath($vol, $dir, '');
      return unless -e $dir && -d $dir;  # The user needs to arrange for this
  
      return if -e $file and !keys %{ $self->{new} };  # Nothing to do
  
      @{$self->{disk}}{ keys %{$self->{new}} } = values %{$self->{new}};  # Merge
      $self->_dump($file, $self->{disk});
  
      $self->{new} = {};
    }
    return $self->read;
  }
  
  sub _dump {
    my ($self, $file, $data) = @_;
  
    open(my $fh, '>', $file) or die "Can't create '$file': $!";
    print {$fh} Module::Build::Dumper->_data_dump($data);
    close $fh;
  }
  
  my $orig_template = do { local $/; <DATA> };
  close DATA;
  
  sub write_config_data {
    my ($self, %args) = @_;
  
    my $template = $orig_template;
    $template =~ s/NOTES_NAME/$args{config_module}/g;
    $template =~ s/MODULE_NAME/$args{module}/g;
    $template =~ s/=begin private\n//;
    $template =~ s/=end private/=cut/;
  
    # strip out private POD markers we use to keep pod from being
    # recognized for *this* source file
    $template =~ s{$_\n}{} for '=begin private', '=end private';
  
    open(my $fh, '>', $args{file}) or die "Can't create '$args{file}': $!";
    print {$fh} $template;
    print {$fh} "\n__DATA__\n";
    print {$fh} Module::Build::Dumper->_data_dump([$args{config_data}, $args{feature}, $args{auto_features}]);
    close $fh;
  }
  
  1;
  
  
  =head1 NAME
  
  Module::Build::Notes - Create persistent distribution configuration modules
  
  =head1 DESCRIPTION
  
  This module is used internally by Module::Build to create persistent
  configuration files that can be installed with a distribution.  See
  L<Module::Build::ConfigData> for an example.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Module::Build>(3)
  
  =cut
  
  __DATA__
  package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;
  
  use strict;
  use warnings;
  use Config;
  
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  # This code is mostly borrowed from ExtUtils::MM_Unix 6.10_03, with a
  # few tweaks based on the PPD spec at
  # http://www.xav.com/perl/site/lib/XML/PPD.html
  
  # The PPD spec is based on <http://www.w3.org/TR/NOTE-OSD>
  
  sub new {
    my $package = shift;
    return bless {@_}, $package;
  }
  
  sub make_ppd {
    my ($self, %args) = @_;
    my $build = delete $args{build};
  
    my @codebase;
    if (exists $args{codebase}) {
      @codebase = ref $args{codebase} ? @{$args{codebase}} : ($args{codebase});
    } else {
      my $distfile = $build->ppm_name . '.tar.gz';
      print "Using default codebase '$distfile'\n";
      @codebase = ($distfile);
    }
  
    my %dist;
    foreach my $info (qw(name author abstract version)) {
      my $method = "dist_$info";
      $dist{$info} = $build->$method() or die "Can't determine distribution's $info\n";
    }
  
    $self->_simple_xml_escape($_) foreach $dist{abstract}, @{$dist{author}};
  
    # TODO: could add <LICENSE HREF=...> tag if we knew what the URLs were for
    # various licenses
    my $ppd = <<"PPD";
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
  
    # We don't include recommended dependencies because PPD has no way
    # to distinguish them from normal dependencies.  We don't include
    # build_requires dependencies because the PPM installer doesn't
    # build or test before installing.  And obviously we don't include
    # conflicts either.
  
    foreach my $type (qw(requires)) {
      my $prereq = $build->$type();
      foreach my $modname (sort keys %$prereq) {
        next if $modname eq 'perl';
  
        my $min_version = '0.0';
        foreach my $c ($build->_parse_conditions($prereq->{$modname})) {
          my ($op, $version) = $c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;
  
          # This is a nasty hack because it fails if there is no >= op
          if ($op eq '>=') {
            $min_version = $version;
            last;
          }
        }
  
        # PPM4 spec requires a '::' for top level modules
        $modname .= '::' unless $modname =~ /::/;
  
        $ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!;
      }
    }
  
    # We only include these tags if this module involves XS, on the
    # assumption that pure Perl modules will work on any OS.
    if (keys %{$build->find_xs_files}) {
      my $perl_version = $self->_ppd_version($build->perl_version);
      $ppd .= sprintf(<<'EOF', $self->_varchname($build->config) );
          <ARCHITECTURE NAME="%s" />
  EOF
    }
  
    foreach my $codebase (@codebase) {
      $self->_simple_xml_escape($codebase);
      $ppd .= sprintf(<<'EOF', $codebase);
          <CODEBASE HREF="%s" />
  EOF
    }
  
    $ppd .= <<'EOF';
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
  
    my $ppd_file = "$dist{name}.ppd";
    open(my $fh, '>', $ppd_file)
      or die "Cannot write to $ppd_file: $!";
  
    binmode($fh, ":utf8")
      if $] >= 5.008 && $Config{useperlio};
    print $fh $ppd;
    close $fh;
  
    return $ppd_file;
  }
  
  sub _ppd_version {
    my ($self, $version) = @_;
  
    # generates something like "0,18,0,0"
    return join ',', (split(/\./, $version), (0)x4)[0..3];
  }
  
  sub _varchname {  # Copied from PPM.pm
    my ($self, $config) = @_;
    my $varchname = $config->{archname};
    # Append "-5.8" to architecture name for Perl 5.8 and later
    if ($] >= 5.008) {
        my $vstring = sprintf "%vd", $^V;
        $vstring =~ s/\.\d+$//;
        $varchname .= "-$vstring";
    }
    return $varchname;
  }
  
  {
    my %escapes = (
  		 "\n" => "\\n",
  		 '"' => '&quot;',
  		 '&' => '&amp;',
  		 '>' => '&gt;',
  		 '<' => '&lt;',
  		);
    my $rx = join '|', keys %escapes;
  
    sub _simple_xml_escape {
      $_[1] =~ s/($rx)/$escapes{$1}/go;
    }
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::PPMMaker - Perl Package Manager file creation
  
  =head1 SYNOPSIS
  
    On the command line, builds a .ppd file:
    ./Build ppd
  
  
  =head1 DESCRIPTION
  
  This package contains the code that builds F<.ppd> "Perl Package
  Description" files, in support of ActiveState's "Perl Package
  Manager".  Details are here:
  L<http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/>
  
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>, Ken Williams <kwilliams@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3)
  
  =cut
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::Default - Stub class for unknown platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  our @ISA = qw(Module::Build::Base);
  
  use ExtUtils::Install;
  
  sub have_forkpipe { 0 }
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(@_);
  
    # $Config{sitelib} and $Config{sitearch} are, unfortunately, missing.
    foreach ('sitelib', 'sitearch') {
      $self->config($_ => $self->config("install$_"))
        unless $self->config($_);
    }
  
    # For some reason $Config{startperl} is filled with a bunch of crap.
    (my $sp = $self->config('startperl')) =~ s/.*Exit \{Status\}\s//;
    $self->config(startperl => $sp);
  
    return $self;
  }
  
  sub make_executable {
    my $self = shift;
    require MacPerl;
    foreach (@_) {
      MacPerl::SetFileInfo('McPL', 'TEXT', $_);
    }
  }
  
  sub dispatch {
    my $self = shift;
  
    if( !@_ and !@ARGV ) {
      require MacPerl;
  
      # What comes first in the action list.
      my @action_list = qw(build test install);
      my %actions = map {+($_, 1)} $self->known_actions;
      delete @actions{@action_list};
      push @action_list, sort { $a cmp $b } keys %actions;
  
      my %toolserver = map {+$_ => 1} qw(test disttest diff testdb);
      foreach (@action_list) {
        $_ .= ' *' if $toolserver{$_};
      }
  
      my $cmd = MacPerl::Pick("What build command? ('*' requires ToolServer)", @action_list);
      return unless defined $cmd;
      $cmd =~ s/ \*$//;
      $ARGV[0] = ($cmd);
  
      my $args = MacPerl::Ask('Any extra arguments?  (ie. verbose=1)', '');
      return unless defined $args;
      push @ARGV, $self->split_like_shell($args);
    }
  
    $self->SUPER::dispatch(@_);
  }
  
  sub ACTION_realclean {
    my $self = shift;
    chmod 0666, $self->{properties}{build_script};
    $self->SUPER::ACTION_realclean;
  }
  
  # ExtUtils::Install has a hard-coded '.' directory in versions less
  # than 1.30.  We use a sneaky trick to turn that into ':'.
  #
  # Note that we do it here in a cross-platform way, so this code could
  # actually go in Module::Build::Base.  But we put it here to be less
  # intrusive for other platforms.
  
  sub ACTION_install {
    my $self = shift;
  
    return $self->SUPER::ACTION_install(@_)
      if eval {ExtUtils::Install->VERSION('1.30'); 1};
  
    local $^W = 0; # Avoid a 'redefine' warning
    local *ExtUtils::Install::find = sub {
      my ($code, @dirs) = @_;
  
      @dirs = map { $_ eq '.' ? File::Spec->curdir : $_ } @dirs;
  
      return File::Find::find($code, @dirs);
    };
  
    return $self->SUPER::ACTION_install(@_);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Module::Build::Platform::MacOS - Builder class for MacOS platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base> and override a few methods.  Please see
  L<Module::Build> for the docs.
  
  =head2 Overridden Methods
  
  =over 4
  
  =item new()
  
  MacPerl doesn't define $Config{sitelib} or $Config{sitearch} for some
  reason, but $Config{installsitelib} and $Config{installsitearch} are
  there.  So we copy the install variables to the other location
  
  =item make_executable()
  
  On MacOS we set the file type and creator to MacPerl so it will run
  with a double-click.
  
  =item dispatch()
  
  Because there's no easy way to say "./Build test" on MacOS, if
  dispatch is called with no arguments and no @ARGV a dialog box will
  pop up asking what action to take and any extra arguments.
  
  Default action is "test".
  
  =item ACTION_realclean()
  
  Need to unlock the Build program before deleting.
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  sub is_executable {
    # We consider the owner bit to be authoritative on a file, because
    # -x will always return true if the user is root and *any*
    # executable bit is set.  The -x test seems to try to answer the
    # question "can I execute this file", but I think we want "is this
    # file executable".
  
    my ($self, $file) = @_;
    return +(stat $file)[2] & 0100;
  }
  
  sub _startperl { "#! " . shift()->perl }
  
  sub _construct {
    my $self = shift()->SUPER::_construct(@_);
  
    # perl 5.8.1-RC[1-3] had some broken %Config entries, and
    # unfortunately Red Hat 9 shipped it like that.  Fix 'em up here.
    my $c = $self->{config};
    for (qw(siteman1 siteman3 vendorman1 vendorman3)) {
      $c->{"install${_}dir"} ||= $c->{"install${_}"};
    }
  
    return $self;
  }
  
  # Open group says username should be portable filename characters,
  # but some Unix OS working with ActiveDirectory wind up with user-names
  # with back-slashes in the name.  The new code below is very liberal
  # in what it accepts.
  sub _detildefy {
    my ($self, $value) = @_;
    $value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username
      [$1 ?
       (eval{(getpwnam $1)[7]} || "~$1") :
       ($ENV{HOME} || eval{(getpwuid $>)[7]} || glob("~"))
      ]ex;
    return $value;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::Unix - Builder class for Unix platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  use Config;
  
  our @ISA = qw(Module::Build::Base);
  
  
  
  =head1 NAME
  
  Module::Build::Platform::VMS - Builder class for VMS platforms
  
  =head1 DESCRIPTION
  
  This module inherits from C<Module::Build::Base> and alters a few
  minor details of its functionality.  Please see L<Module::Build> for
  the general docs.
  
  =head2 Overridden Methods
  
  =over 4
  
  =item _set_defaults
  
  Change $self->{build_script} to 'Build.com' so @Build works.
  
  =cut
  
  sub _set_defaults {
      my $self = shift;
      $self->SUPER::_set_defaults(@_);
  
      $self->{properties}{build_script} = 'Build.com';
  }
  
  
  =item cull_args
  
  '@Build foo' on VMS will not preserve the case of 'foo'.  Rather than forcing
  people to write '@Build "foo"' we'll dispatch case-insensitively.
  
  =cut
  
  sub cull_args {
      my $self = shift;
      my($action, $args) = $self->SUPER::cull_args(@_);
      my @possible_actions = grep { lc $_ eq lc $action } $self->known_actions;
  
      die "Ambiguous action '$action'.  Could be one of @possible_actions"
          if @possible_actions > 1;
  
      return ($possible_actions[0], $args);
  }
  
  
  =item manpage_separator
  
  Use '__' instead of '::'.
  
  =cut
  
  sub manpage_separator {
      return '__';
  }
  
  
  =item prefixify
  
  Prefixify taking into account VMS' filepath syntax.
  
  =cut
  
  # Translated from ExtUtils::MM_VMS::prefixify()
  
  sub _catprefix {
      my($self, $rprefix, $default) = @_;
  
      my($rvol, $rdirs) = File::Spec->splitpath($rprefix);
      if( $rvol ) {
          return File::Spec->catpath($rvol,
                                     File::Spec->catdir($rdirs, $default),
                                     ''
                                    )
      }
      else {
          return File::Spec->catdir($rdirs, $default);
      }
  }
  
  
  sub _prefixify {
      my($self, $path, $sprefix, $type) = @_;
      my $rprefix = $self->prefix;
  
      return '' unless defined $path;
  
      $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");
  
      # Translate $(PERLPREFIX) to a real path.
      $rprefix = VMS::Filespec::vmspath($rprefix) if $rprefix;
      $sprefix = VMS::Filespec::vmspath($sprefix) if $sprefix;
  
      $self->log_verbose("  rprefix translated to $rprefix\n".
                         "  sprefix translated to $sprefix\n");
  
      if( length($path) == 0 ) {
          $self->log_verbose("  no path to prefixify.\n")
      }
      elsif( !File::Spec->file_name_is_absolute($path) ) {
          $self->log_verbose("    path is relative, not prefixifying.\n");
      }
      elsif( $sprefix eq $rprefix ) {
          $self->log_verbose("  no new prefix.\n");
      }
      else {
          my($path_vol, $path_dirs) = File::Spec->splitpath( $path );
  	my $vms_prefix = $self->config('vms_prefix');
          if( $path_vol eq $vms_prefix.':' ) {
              $self->log_verbose("  $vms_prefix: seen\n");
  
              $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
              $path = $self->_catprefix($rprefix, $path_dirs);
          }
          else {
              $self->log_verbose("    cannot prefixify.\n");
  	    return $self->prefix_relpaths($self->installdirs, $type);
          }
      }
  
      $self->log_verbose("    now $path\n");
  
      return $path;
  }
  
  =item _quote_args
  
  Command-line arguments (but not the command itself) must be quoted
  to ensure case preservation.
  
  =cut
  
  sub _quote_args {
    # Returns a string that can become [part of] a command line with
    # proper quoting so that the subprocess sees this same list of args,
    # or if we get a single arg that is an array reference, quote the
    # elements of it and return the reference.
    my ($self, @args) = @_;
    my $got_arrayref = (scalar(@args) == 1
                        && ref $args[0] eq 'ARRAY')
                     ? 1
                     : 0;
  
    # Do not quote qualifiers that begin with '/'.
    map { if (!/^\//) {
            $_ =~ s/\"/""/g;     # escape C<"> by doubling
            $_ = q(").$_.q(");
          }
    }
      ($got_arrayref ? @{$args[0]}
                     : @args
      );
  
    return $got_arrayref ? $args[0]
                         : join(' ', @args);
  }
  
  =item have_forkpipe
  
  There is no native fork(), so some constructs depending on it are not
  available.
  
  =cut
  
  sub have_forkpipe { 0 }
  
  =item _backticks
  
  Override to ensure that we quote the arguments but not the command.
  
  =cut
  
  sub _backticks {
    # The command must not be quoted but the arguments to it must be.
    my ($self, @cmd) = @_;
    my $cmd = shift @cmd;
    my $args = $self->_quote_args(@cmd);
    return `$cmd $args`;
  }
  
  =item find_command
  
  Local an executable program
  
  =cut
  
  sub find_command {
      my ($self, $command) = @_;
  
      # a lot of VMS executables have a symbol defined
      # check those first
      if ( $^O eq 'VMS' ) {
          require VMS::DCLsym;
          my $syms = VMS::DCLsym->new;
          return $command if scalar $syms->getsym( uc $command );
      }
  
      $self->SUPER::find_command($command);
  }
  
  # _maybe_command copied from ExtUtils::MM_VMS::maybe_command
  
  =item _maybe_command (override)
  
  Follows VMS naming conventions for executable files.
  If the name passed in doesn't exactly match an executable file,
  appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
  to check for DCL procedure.  If this fails, checks directories in DCL$PATH
  and finally F<Sys$System:> for an executable file having the name specified,
  with or without the F<.Exe>-equivalent suffix.
  
  =cut
  
  sub _maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d _;
      my(@dirs) = ('');
      my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');
  
      if ($file !~ m![/:>\]]!) {
          for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
              my $dir = $ENV{"DCL\$PATH;$i"};
              $dir .= ':' unless $dir =~ m%[\]:]$%;
              push(@dirs,$dir);
          }
          push(@dirs,'Sys$System:');
          foreach my $dir (@dirs) {
              my $sysfile = "$dir$file";
              foreach my $ext (@exts) {
                  return $file if -x "$sysfile$ext" && ! -d _;
              }
          }
      }
      return;
  }
  
  =item do_system
  
  Override to ensure that we quote the arguments but not the command.
  
  =cut
  
  sub do_system {
    # The command must not be quoted but the arguments to it must be.
    my ($self, @cmd) = @_;
    $self->log_verbose("@cmd\n");
    my $cmd = shift @cmd;
    my $args = $self->_quote_args(@cmd);
    return !system("$cmd $args");
  }
  
  =item oneliner
  
  Override to ensure that we do not quote the command.
  
  =cut
  
  sub oneliner {
      my $self = shift;
      my $oneliner = $self->SUPER::oneliner(@_);
  
      $oneliner =~ s/^\"\S+\"//;
  
      return "MCR $^X $oneliner";
  }
  
  =item rscan_dir
  
  Inherit the standard version but remove dots at end of name.
  If the extended character set is in effect, do not remove dots from filenames
  with Unix path delimiters.
  
  =cut
  
  sub rscan_dir {
    my ($self, $dir, $pattern) = @_;
  
    my $result = $self->SUPER::rscan_dir( $dir, $pattern );
  
    for my $file (@$result) {
        if (!_efs() && ($file =~ m#/#)) {
            $file =~ s/\.$//;
        }
    }
    return $result;
  }
  
  =item dist_dir
  
  Inherit the standard version but replace embedded dots with underscores because
  a dot is the directory delimiter on VMS.
  
  =cut
  
  sub dist_dir {
    my $self = shift;
  
    my $dist_dir = $self->SUPER::dist_dir;
    $dist_dir =~ s/\./_/g unless _efs();
    return $dist_dir;
  }
  
  =item man3page_name
  
  Inherit the standard version but chop the extra manpage delimiter off the front if
  there is one.  The VMS version of splitdir('[.foo]') returns '', 'foo'.
  
  =cut
  
  sub man3page_name {
    my $self = shift;
  
    my $mpname = $self->SUPER::man3page_name( shift );
    my $sep = $self->manpage_separator;
    $mpname =~ s/^$sep//;
    return $mpname;
  }
  
  =item expand_test_dir
  
  Inherit the standard version but relativize the paths as the native glob() doesn't
  do that for us.
  
  =cut
  
  sub expand_test_dir {
    my ($self, $dir) = @_;
  
    my @reldirs = $self->SUPER::expand_test_dir( $dir );
  
    for my $eachdir (@reldirs) {
      my ($v,$d,$f) = File::Spec->splitpath( $eachdir );
      my $reldir = File::Spec->abs2rel( File::Spec->catpath( $v, $d, '' ) );
      $eachdir = File::Spec->catfile( $reldir, $f );
    }
    return @reldirs;
  }
  
  =item _detildefy
  
  The home-grown glob() does not currently handle tildes, so provide limited support
  here.  Expect only UNIX format file specifications for now.
  
  =cut
  
  sub _detildefy {
      my ($self, $arg) = @_;
  
      # Apparently double ~ are not translated.
      return $arg if ($arg =~ /^~~/);
  
      # Apparently ~ followed by whitespace are not translated.
      return $arg if ($arg =~ /^~ /);
  
      if ($arg =~ /^~/) {
          my $spec = $arg;
  
          # Remove the tilde
          $spec =~ s/^~//;
  
          # Remove any slash following the tilde if present.
          $spec =~ s#^/##;
  
          # break up the paths for the merge
          my $home = VMS::Filespec::unixify($ENV{HOME});
  
          # In the default VMS mode, the trailing slash is present.
          # In Unix report mode it is not.  The parsing logic assumes that
          # it is present.
          $home .= '/' unless $home =~ m#/$#;
  
          # Trivial case of just ~ by it self
          if ($spec eq '') {
              $home =~ s#/$##;
              return $home;
          }
  
          my ($hvol, $hdir, $hfile) = File::Spec::Unix->splitpath($home);
          if ($hdir eq '') {
               # Someone has tampered with $ENV{HOME}
               # So hfile is probably the directory since this should be
               # a path.
               $hdir = $hfile;
          }
  
          my ($vol, $dir, $file) = File::Spec::Unix->splitpath($spec);
  
          my @hdirs = File::Spec::Unix->splitdir($hdir);
          my @dirs = File::Spec::Unix->splitdir($dir);
  
          unless ($arg =~ m#^~/#) {
              # There is a home directory after the tilde, but it will already
              # be present in in @hdirs so we need to remove it by from @dirs.
  
              shift @dirs;
          }
          my $newdirs = File::Spec::Unix->catdir(@hdirs, @dirs);
  
          $arg = File::Spec::Unix->catpath($hvol, $newdirs, $file);
      }
      return $arg;
  
  }
  
  =item find_perl_interpreter
  
  On VMS, $^X returns the fully qualified absolute path including version
  number.  It's logically impossible to improve on it for getting the perl
  we're currently running, and attempting to manipulate it is usually
  lossy.
  
  =cut
  
  sub find_perl_interpreter {
      return VMS::Filespec::vmsify($^X);
  }
  
  =item localize_file_path
  
  Convert the file path to the local syntax
  
  =cut
  
  sub localize_file_path {
    my ($self, $path) = @_;
    $path = VMS::Filespec::vmsify($path);
    $path =~ s/\.\z//;
    return $path;
  }
  
  =item localize_dir_path
  
  Convert the directory path to the local syntax
  
  =cut
  
  sub localize_dir_path {
    my ($self, $path) = @_;
    return VMS::Filespec::vmspath($path);
  }
  
  =item ACTION_clean
  
  The home-grown glob() expands a bit too aggressively when given a bare name,
  so default in a zero-length extension.
  
  =cut
  
  sub ACTION_clean {
    my ($self) = @_;
    foreach my $item (map glob(VMS::Filespec::rmsexpand($_, '.;0')), $self->cleanup) {
      $self->delete_filetree($item);
    }
  }
  
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i;
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _efs {
      my $efs;
      if ($use_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i;
      }
      return $efs;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  Ken Williams <kwilliams@cpan.org>
  Craig A. Berry <craigberry@mac.com>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
  
  1;
  __END__
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::VOS - Builder class for VOS platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  use Config;
  use File::Basename;
  use File::Spec;
  
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  
  sub manpage_separator {
      return '.';
  }
  
  sub have_forkpipe { 0 }
  
  sub _detildefy {
    my ($self, $value) = @_;
    $value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x
      if $ENV{HOME};
    return $value;
  }
  
  sub ACTION_realclean {
    my ($self) = @_;
  
    $self->SUPER::ACTION_realclean();
  
    my $basename = basename($0);
    $basename =~ s/(?:\.bat)?$//i;
  
    if ( lc $basename eq lc $self->build_script ) {
      if ( $self->build_bat ) {
        $self->log_verbose("Deleting $basename.bat\n");
        my $full_progname = $0;
        $full_progname =~ s/(?:\.bat)?$/.bat/i;
  
        # Voodoo required to have a batch file delete itself without error;
        # Syntax differs between 9x & NT: the later requires a null arg (???)
        require Win32;
        my $null_arg = (Win32::IsWinNT()) ? '""' : '';
        my $cmd = qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");
  
        open(my $fh, '>>', "$basename.bat")
          or die "Can't create $basename.bat: $!";
        print $fh $cmd;
        close $fh ;
      } else {
        $self->delete_filetree($self->build_script . '.bat');
      }
    }
  }
  
  sub make_executable {
    my $self = shift;
  
    $self->SUPER::make_executable(@_);
  
    foreach my $script (@_) {
  
      # Native batch script
      if ( $script =~ /\.(bat|cmd)$/ ) {
        $self->SUPER::make_executable($script);
        next;
  
      # Perl script that needs to be wrapped in a batch script
      } else {
        my %opts = ();
        if ( $script eq $self->build_script ) {
          $opts{ntargs}    = q(-x -S %0 --build_bat %*);
          $opts{otherargs} = q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9);
        }
  
        my $out = eval {$self->pl2bat(in => $script, update => 1, %opts)};
        if ( $@ ) {
          $self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@");
        } else {
          $self->SUPER::make_executable($out);
        }
      }
    }
  }
  
  # This routine was copied almost verbatim from the 'pl2bat' utility
  # distributed with perl. It requires too much voodoo with shell quoting
  # differences and shortcomings between the various flavors of Windows
  # to reliably shell out
  sub pl2bat {
    my $self = shift;
    my %opts = @_;
  
    # NOTE: %0 is already enclosed in doublequotes by cmd.exe, as appropriate
    $opts{ntargs}    = '-x -S %0 %*' unless exists $opts{ntargs};
    $opts{otherargs} = '-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists $opts{otherargs};
  
    $opts{stripsuffix} = '/\\.plx?/' unless exists $opts{stripsuffix};
    $opts{stripsuffix} = ($opts{stripsuffix} =~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");
  
    unless (exists $opts{out}) {
      $opts{out} = $opts{in};
      $opts{out} =~ s/$opts{stripsuffix}$//oi;
      $opts{out} .= '.bat' unless $opts{in} =~ /\.bat$/i or $opts{in} =~ /^-$/;
    }
  
    my $head = <<EOT;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
  
    $head =~ s/^\s+//gm;
    my $headlines = 2 + ($head =~ tr/\n/\n/);
    my $tail = "\n__END__\n:endofperl\n";
  
    my $linedone  = 0;
    my $taildone  = 0;
    my $linenum   = 0;
    my $skiplines = 0;
  
    my $start = $Config{startperl};
    $start = "#!perl" unless $start =~ /^#!.*perl/;
  
    open(my $in, '<', "$opts{in}") or die "Can't open $opts{in}: $!";
    my @file = <$in>;
    close($in);
  
    foreach my $line ( @file ) {
      $linenum++;
      if ( $line =~ /^:endofperl\b/ ) {
        if (!exists $opts{update}) {
          warn "$opts{in} has already been converted to a batch file!\n";
          return;
        }
        $taildone++;
      }
      if ( not $linedone and $line =~ /^#!.*perl/ ) {
        if (exists $opts{update}) {
          $skiplines = $linenum - 1;
          $line .= "#line ".(1+$headlines)."\n";
        } else {
  	$line .= "#line ".($linenum+$headlines)."\n";
        }
  	$linedone++;
      }
      if ( $line =~ /^#\s*line\b/ and $linenum == 2 + $skiplines ) {
        $line = "";
      }
    }
  
    open(my $out, '>', "$opts{out}") or die "Can't open $opts{out}: $!";
    print $out $head;
    print $out $start, ( $opts{usewarnings} ? " -w" : "" ),
               "\n#line ", ($headlines+1), "\n" unless $linedone;
    print $out @file[$skiplines..$#file];
    print $out $tail unless $taildone;
    close($out);
  
    return $opts{out};
  }
  
  
  sub _quote_args {
    # Returns a string that can become [part of] a command line with
    # proper quoting so that the subprocess sees this same list of args.
    my ($self, @args) = @_;
  
    my @quoted;
  
    for (@args) {
      if ( /^[^\s*?!\$<>;|'"\[\]\{\}]+$/ ) {
        # Looks pretty safe
        push @quoted, $_;
      } else {
        # XXX this will obviously have to improve - is there already a
        # core module lying around that does proper quoting?
        s/"/\\"/g;
        push @quoted, qq("$_");
      }
    }
  
    return join " ", @quoted;
  }
  
  
  sub split_like_shell {
    # As it turns out, Windows command-parsing is very different from
    # Unix command-parsing.  Double-quotes mean different things,
    # backslashes don't necessarily mean escapes, and so on.  So we
    # can't use Text::ParseWords::shellwords() to break a command string
    # into words.  The algorithm below was bashed out by Randy and Ken
    # (mostly Randy), and there are a lot of regression tests, so we
    # should feel free to adjust if desired.
  
    (my $self, local $_) = @_;
  
    return @$_ if defined() && ref() eq 'ARRAY';
  
    my @argv;
    return @argv unless defined() && length();
  
    my $length = length;
    m/\G\s*/gc;
  
    ARGS: until ( pos == $length ) {
      my $quote_mode;
      my $arg = '';
      CHARS: until ( pos == $length ) {
        if ( m/\G((?:\\\\)+)(?=\\?(")?)/gc ) {
            if (defined $2) {
                $arg .= '\\' x (length($1) / 2);
            }
            else {
                $arg .= $1;
            }
        }
        elsif ( m/\G\\"/gc ) {
          $arg .= '"';
        }
        elsif ( m/\G"/gc ) {
          if ( $quote_mode && m/\G"/gc ) {
              $arg .= '"';
          }
          $quote_mode = !$quote_mode;
        }
        elsif ( !$quote_mode && m/\G\s+/gc ) {
          last;
        }
        elsif ( m/\G(.)/sgc ) {
          $arg .= $1;
        }
      }
      push @argv, $arg;
    }
  
    return @argv;
  }
  
  
  # system(@cmd) does not like having double-quotes in it on Windows.
  # So we quote them and run it as a single command.
  sub do_system {
    my ($self, @cmd) = @_;
  
    my $cmd = $self->_quote_args(@cmd);
    my $status = system($cmd);
    if ($status and $! =~ /Argument list too long/i) {
      my $env_entries = '';
      foreach (sort keys %ENV) { $env_entries .= "$_=>".length($ENV{$_})."; " }
      warn "'Argument list' was 'too long', env lengths are $env_entries";
    }
    return !$status;
  }
  
  # Copied from ExtUtils::MM_Win32
  sub _maybe_command {
      my($self,$file) = @_;
      my @e = exists($ENV{'PATHEXT'})
            ? split(/;/, $ENV{PATHEXT})
  	  : qw(.com .exe .bat .cmd);
      my $e = '';
      for (@e) { $e .= "\Q$_\E|" }
      chop $e;
      # see if file ends in one of the known extensions
      if ($file =~ /($e)$/i) {
  	return $file if -e $file;
      }
      else {
  	for (@e) {
  	    return "$file$_" if -e "$file$_";
  	}
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::Build::Platform::Windows - Builder class for Windows platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base> and override a few methods.  Please see
  L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3)
  
  =cut
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  # This class isn't necessary anymore, but we can't delete it, because
  # some people might still have the old copy in their @INC, containing
  # code we don't want to execute, so we have to make sure an upgrade
  # will replace it with this empty subclass.
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::aix - Builder class for AIX platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the AIX
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  sub manpage_separator {
     '.'
  }
  
  # Copied from ExtUtils::MM_Cygwin::maybe_command()
  # If our path begins with F</cygdrive/> then we use the Windows version
  # to determine if it may be a command.  Otherwise we use the tests
  # from C<ExtUtils::MM_Unix>.
  
  sub _maybe_command {
      my ($self, $file) = @_;
  
      if ($file =~ m{^/cygdrive/}i) {
          require Module::Build::Platform::Windows;
          return Module::Build::Platform::Windows->_maybe_command($file);
      }
  
      return $self->SUPER::_maybe_command($file);
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::cygwin - Builder class for Cygwin platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the cygwin
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Initial stub by Yitzchak Scott-Thoennes <sthoenna@efn.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  # This class isn't necessary anymore, but we can't delete it, because
  # some people might still have the old copy in their @INC, containing
  # code we don't want to execute, so we have to make sure an upgrade
  # will replace it with this empty subclass.
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::darwin - Builder class for Mac OS X platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the Mac OS X
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  sub manpage_separator { '.' }
  
  sub have_forkpipe { 0 }
  
  # Copied from ExtUtils::MM_OS2::maybe_command
  sub _maybe_command {
      my($self,$file) = @_;
      $file =~ s,[/\\]+,/,g;
      return $file if -x $file && ! -d _;
      return "$file.exe" if -x "$file.exe" && ! -d _;
      return "$file.cmd" if -x "$file.cmd" && ! -d _;
      return;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::os2 - Builder class for OS/2 platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the OS/2
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  sub new {
    # Perl is so fun.
    my $package = shift;
  
    my $self;
    $self = bless {have_pod_parser => 0, @_}, $package;
  
    unless ($self->{fh}) {
      die "No 'file' or 'fh' parameter given" unless $self->{file};
      open($self->{fh}, '<', $self->{file}) or die "Couldn't open $self->{file}: $!";
    }
  
    return $self;
  }
  
  sub parse_from_filehandle {
    my ($self, $fh) = @_;
  
    local $_;
    while (<$fh>) {
      next unless /^=(?!cut)/ .. /^=cut/;  # in POD
      # Accept Name - abstract or C<Name> - abstract
      last if ($self->{abstract}) = /^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix;
    }
  
    my @author;
    while (<$fh>) {
      next unless /^=head1\s+AUTHORS?/i ... /^=/;
      next if /^=/;
      push @author, $_ if /\@/;
    }
    return unless @author;
    s/^\s+|\s+$//g foreach @author;
  
    $self->{author} = \@author;
  
    return;
  }
  
  sub get_abstract {
    my $self = shift;
    return $self->{abstract} if defined $self->{abstract};
  
    $self->parse_from_filehandle($self->{fh});
  
    return $self->{abstract};
  }
  
  sub get_author {
    my $self = shift;
    return $self->{author} if defined $self->{author};
  
    $self->parse_from_filehandle($self->{fh});
  
    return $self->{author} || [];
  }
MODULE_BUILD_PODPARSER

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2:tw=78
  package Module::Metadata; # git description: v1.000032-7-gb4e8a3f
  # ABSTRACT: Gather package and POD information from perl module files
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  sub __clean_eval { eval $_[0] }
  use strict;
  use warnings;
  
  our $VERSION = '1.000033';
  
  use Carp qw/croak/;
  use File::Spec;
  BEGIN {
         # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
         eval {
                 require Fcntl; Fcntl->import('SEEK_SET'); 1;
         } or *SEEK_SET = sub { 0 }
  }
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
      Log::Contextual->import('log_info',
        '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
      );
    }
    else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
            if ( defined( $version ) ) {
              if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                $err .= "  $p->{file} ($p->{version})\n";
              }
              else {
                # same version declared multiple times, ignore
              }
            }
            else {
              $file    = $p->{file};
              $version = $p->{version};
            }
          }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep { $args{version} eq $_ } qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      }
      else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
        my @path = split( /\//, $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            }
            else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          }
          else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              $result->{err}
            };
  
          }
          elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
          if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              };
            }
  
          }
          else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
          }
          else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
          }
  
        }
        else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
              $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( not $handle ) {
      my $filename = $self->{filename};
      open $handle, '<', $filename
        or croak( "Can't open '$filename': $!" );
  
      $self->_handle_bom($handle, $filename);
    }
    $self->_parse_fh($handle);
  
    @{$self->{packages}} = __uniq(@{$self->{packages}});
  
    unless($self->{module} and length($self->{module})) {
      # CAVEAT (possible TODO): .pmc files not treated the same as .pm
      if ($self->{filename} =~ /\.pm$/) {
        my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
        $f =~ s/\..+$//;
        my @candidates = grep /(^|::)$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # this may be undef
      }
      else {
        # this seems like an atrocious heuristic, albeit marginally better than
        # what was here before. It should be rewritten entirely to be more like
        # "if it's not a .pm file, it's not require()able as a name, therefore
        # name() should be undef."
        if ((grep /main/, @{$self->{packages}})
            or (grep /main/, keys %{$self->{versions}})) {
          $self->{module} = 'main';
        }
        else {
          # TODO: this should maybe default to undef instead
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
      if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      # CAVEAT (possible TODO): .pmc files are not discoverable here
      $testfile .= '.pm';
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile;
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sigil, $variable_name, $package);
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $package ) {
        $package = ($package eq '::') ? 'main' : $package;
        $package =~ s/::$//;
      }
    }
  
    return ( $sigil, $variable_name, $package );
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = tell $fh;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = read $fh, $buf, length $buf;
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    }
    elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    }
    elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = read $fh, $buf, length $buf;
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        binmode( $fh, ":encoding($encoding)" );
      }
    }
    else {
      seek $fh, $pos, SEEK_SET
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @packages, %vers, %pod, @pod );
    my $package = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
          push( @pod, $1 );
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = $1;
        }
        elsif ( $self->{collect_pod} ) {
          $pod_data .= "$line\n";
        }
        next;
      }
      elsif ( $is_cut ) {
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
        next;
      }
  
      # Skip after __END__
      next if $in_end;
  
      # Skip comments in code
      next if $line =~ /^\s*#/;
  
      # Would be nice if we could also check $in_string or something too
      if ($line eq '__END__') {
        $in_end++;
        next;
      }
  
      last if $line eq '__DATA__';
  
      # parse $line to see if it's a $VERSION declaration
      my( $version_sigil, $version_fullname, $version_package ) =
        index($line, 'VERSION') >= 1
          ? $self->_parse_version_expression( $line )
          : ();
  
      if ( $line =~ /$PKG_REGEXP/o ) {
        $package = $1;
        my $version = $2;
        push( @packages, $package ) unless grep( $package eq $_, @packages );
        $need_vers = defined $version ? 0 : 1;
  
        if ( not exists $vers{$package} and defined $version ){
          # Upgrade to a version object.
          my $dwim_version = eval { _dwim_version($version) };
          croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
            unless defined $dwim_version;  # "0" is OK!
          $vers{$package} = $dwim_version;
        }
      }
  
      # VERSION defined with full package spec, i.e. $Module::VERSION
      elsif ( $version_fullname && $version_package ) {
        # we do NOT save this package in found @packages
        $need_vers = 0 if $version_package eq $package;
  
        unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
          $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        }
      }
  
      # first non-comment line in undeclared package main is VERSION
      elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
        $need_vers = 0;
        my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        $vers{$package} = $v;
        push( @packages, 'main' );
      }
  
      # first non-comment line in undeclared package defines package main
      elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
        $need_vers = 1;
        $vers{main} = '';
        push( @packages, 'main' );
      }
  
      # only keep if this is the first $VERSION seen
      elsif ( $version_fullname && $need_vers ) {
        $need_vers = 0;
        my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
  
        unless ( defined $vers{$package} && length $vers{$package} ) {
          $vers{$package} = $v;
        }
      }
    } # end loop over each line
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@packages;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  sub __uniq (@)
  {
      my (%seen, $key);
      grep { not $seen{ $key = $_ }++ } @_;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $variable_name, $line ) = @_;
  
    # We compile into a local sub because 'use version' would cause
    # compiletime/runtime issues with local()
    $pn++; # everybody gets their own package
    my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        return \$$variable_name if defined \$$variable_name;
        return \$Module::Metadata::_version::p${pn}::$variable_name;
      };
    };
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    my $vsub = __clean_eval($eval);
    # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      $vsub = __clean_eval($eval);
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
  
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
  
    my $result = eval { $vsub->() };
    # FIXME: $eval is not the right thing to print here
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    # FIXME: $eval is not the right thing to print here
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
           exists( $self->{versions}{$mod} ) ) {
          return $self->{versions}{$mod};
      }
      else {
          return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
           exists( $self->{pod}{$sect} ) ) {
          return $self->{pod}{$sect};
      }
      else {
          return undef;
      }
  }
  
  sub is_indexable {
    my ($self, $package) = @_;
  
    my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;
  
    # check for specific package, if provided
    return !! grep { $_ eq $package } @indexable_packages if $package;
  
    # otherwise, check for any indexable packages at all
    return !! @indexable_packages;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 VERSION
  
  version 1.000033
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 CLASS METHODS
  
  =head2 C<< new_from_file($filename, collect_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  =head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> argument as described above,
  this method accepts a C<inc> argument which is a reference to an array of
  directories to search for the module.  If none are given, the default is
  @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =head2 C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =head2 C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =head2 C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =head1 OBJECT METHODS
  
  =head2 C<< name() >>
  
  Returns the name of the package represented by this module. If there
  is more than one package, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =head2 C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =head2 C<< filename() >>
  
  Returns the absolute path to the file.
  Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
  
  =head2 C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =head2 C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =head2 C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =head2 C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
  
  Available since version 1.000020.
  
  Returns a boolean indicating whether the package (if provided) or any package
  (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
  Note This only checks for valid C<package> declarations, and does not take any
  ownership information into account.
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata>
  (or L<bug-Module-Metadata@rt.cpan.org|mailto:bug-Module-Metadata@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/cpan-workers.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge David Golden Vincent Pit Matt S Trout Chris Nehren Graham Knop Olivier Mengu Tomas Doran Tatsuhiko Miyagawa tokuhirom Kent Fredric Peter Rabbitson Steve Hay Jerry D. Hedden Craig A. Berry Mitchell Steinbrunner Edward Zborowski Gareth Harper James Raspass 'BinGOs' Williams Josh Jore
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Vincent Pit <perl@profvince.com>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Olivier Mengu <dolmen@cpan.org>
  
  =item *
  
  Tomas Doran <bobtfish@bobtfish.net>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  tokuhirom <tokuhirom@gmail.com>
  
  =item *
  
  Kent Fredric <kentnl@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Steve Hay <steve.m.hay@googlemail.com>
  
  =item *
  
  Jerry D. Hedden <jdhedden@cpan.org>
  
  =item *
  
  Craig A. Berry <cberry@cpan.org>
  
  =item *
  
  Craig A. Berry <craigberry@mac.com>
  
  =item *
  
  David Mitchell <davem@iabyn.com>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  Gareth Harper <gareth@broadbean.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =item *
  
  Josh Jore <jjore@cpan.org>
  
  =back
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
MODULE_METADATA

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
X86_64-LINUX_VERSION

$fatpacked{"x86_64-linux/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
X86_64-LINUX_VERSION_REGEX

$fatpacked{"x86_64-linux/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
X86_64-LINUX_VERSION_VPP

$fatpacked{"x86_64-linux/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
X86_64-LINUX_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl 

use strict;
use Module::Build 0.25;
use Getopt::Long;

my %opt_defs = (
		module      => {type => '=s',
				desc => 'The name of the module to configure (required)'},
		feature     => {type => ':s',
				desc => 'Print the value of a feature or all features'},
		config      => {type => ':s',
				desc => 'Print the value of a config option'},
		set_feature => {type => '=s%',
				desc => "Set a feature to 'true' or 'false'"},
		set_config  => {type => '=s%',
				desc => 'Set a config option to the given value'},
		eval        => {type => '',
				desc => 'eval() config values before setting'},
		help        => {type => '',
				desc => 'Print a help message and exit'},
	       );

my %opts;
GetOptions( \%opts, map "$_$opt_defs{$_}{type}", keys %opt_defs ) or die usage(%opt_defs);
print usage(%opt_defs) and exit(0)
  if $opts{help};

my @exclusive = qw(feature config set_feature set_config);
die "Exactly one of the options '" . join("', '", @exclusive) . "' must be specified\n" . usage(%opt_defs)
  unless grep(exists $opts{$_}, @exclusive) == 1;

die "Option --module is required\n" . usage(%opt_defs)
  unless $opts{module};

my $cf = load_config($opts{module});

if (exists $opts{feature}) {

  if (length $opts{feature}) {
    print $cf->feature($opts{feature});
  } else {
    my %auto;
    # note: need to support older ConfigData.pm's
    @auto{$cf->auto_feature_names} = () if $cf->can("auto_feature_names");

    print " Features defined in $cf:\n";
    foreach my $name (sort $cf->feature_names) {
      print "  $name => ", $cf->feature($name), (exists $auto{$name} ? " (dynamic)" : ""), "\n";
    }
  }

} elsif (exists $opts{config}) {

  require Data::Dumper;
  local $Data::Dumper::Terse = 1;

  if (length $opts{config}) {
    print Data::Dumper::Dumper($cf->config($opts{config})), "\n";
  } else {
    print " Configuration defined in $cf:\n";
    foreach my $name (sort $cf->config_names) {
      print "  $name => ", Data::Dumper::Dumper($cf->config($name)), "\n";
    }
  }

} elsif (exists $opts{set_feature}) {
  my %to_set = %{$opts{set_feature}};
  while (my ($k, $v) = each %to_set) {
    die "Feature value must be 0 or 1\n" unless $v =~ /^[01]$/;
    $cf->set_feature($k, 0+$v); # Cast to a number, not a string
  }
  $cf->write;
  print "Feature" . 's'x(keys(%to_set)>1) . " saved\n";

} elsif (exists $opts{set_config}) {

  my %to_set = %{$opts{set_config}};
  while (my ($k, $v) = each %to_set) {
    if ($opts{eval}) {
      $v = eval($v);
      die $@ if $@;
    }
    $cf->set_config($k, $v);
  }
  $cf->write;
  print "Config value" . 's'x(keys(%to_set)>1) . " saved\n";
}

sub load_config {
  my $mod = shift;

  $mod =~ /^([\w:]+)$/
    or die "Invalid module name '$mod'";

  my $cf = $mod . "::ConfigData";
  eval "require $cf";
  die $@ if $@;

  return $cf;
}

sub usage {
  my %defs = @_;

  my $out = "\nUsage: $0 [options]\n\n  Options include:\n";

  foreach my $name (sort keys %defs) {
    $out .= "  --$name";

    for ($defs{$name}{type}) {
      /^=s$/  and      $out .= " <string>";
      /^=s%$/ and      $out .= " <string>=<value>";
    }

    pad_line($out, 35);
    $out .= "$defs{$name}{desc}\n";
  }

  $out .= <<EOF;

  Examples:
   $0 --module Foo::Bar --feature bazzable
   $0 --module Foo::Bar --config magic_number
   $0 --module Foo::Bar --set_feature bazzable=1
   $0 --module Foo::Bar --set_config magic_number=42

EOF

  return $out;
}

sub pad_line {  $_[0] .= ' ' x ($_[1] - length($_[0]) + rindex($_[0], "\n")) }


__END__

=head1 NAME

config_data - Query or change configuration of Perl modules

=head1 SYNOPSIS

  # Get config/feature values
  config_data --module Foo::Bar --feature bazzable
  config_data --module Foo::Bar --config magic_number

  # Set config/feature values
  config_data --module Foo::Bar --set_feature bazzable=1
  config_data --module Foo::Bar --set_config magic_number=42

  # Print a usage message
  config_data --help

=head1 DESCRIPTION

The C<config_data> tool provides a command-line interface to the
configuration of Perl modules.  By "configuration", we mean something
akin to "user preferences" or "local settings".  This is a
formalization and abstraction of the systems that people like Andreas
Koenig (C<CPAN::Config>), Jon Swartz (C<HTML::Mason::Config>), Andy
Wardley (C<Template::Config>), and Larry Wall (perl's own Config.pm)
have developed independently.

The configuration system employed here was developed in the context of
C<Module::Build>.  Under this system, configuration information for a
module C<Foo>, for example, is stored in a module called
C<Foo::ConfigData>) (I would have called it C<Foo::Config>, but that
was taken by all those other systems mentioned in the previous
paragraph...).  These C<...::ConfigData> modules contain the
configuration data, as well as publicly accessible methods for
querying and setting (yes, actually re-writing) the configuration
data.  The C<config_data> script (whose docs you are currently
reading) is merely a front-end for those methods.  If you wish, you
may create alternate front-ends.

The two types of data that may be stored are called C<config> values
and C<feature> values.  A C<config> value may be any perl scalar,
including references to complex data structures.  It must, however, be
serializable using C<Data::Dumper>.  A C<feature> is a boolean (1 or
0) value.

=head1 USAGE

This script functions as a basic getter/setter wrapper around the
configuration of a single module.  On the command line, specify which
module's configuration you're interested in, and pass options to get
or set C<config> or C<feature> values.  The following options are
supported:

=over 4

=item module

Specifies the name of the module to configure (required).

=item feature

When passed the name of a C<feature>, shows its value.  The value will
be 1 if the feature is enabled, 0 if the feature is not enabled, or
empty if the feature is unknown.  When no feature name is supplied,
the names and values of all known features will be shown.

=item config

When passed the name of a C<config> entry, shows its value.  The value
will be displayed using C<Data::Dumper> (or similar) as perl code.
When no config name is supplied, the names and values of all known
config entries will be shown.

=item set_feature

Sets the given C<feature> to the given boolean value.  Specify the value
as either 1 or 0.

=item set_config

Sets the given C<config> entry to the given value.

=item eval

If the C<--eval> option is used, the values in C<set_config> will be
evaluated as perl code before being stored.  This allows moderately
complicated data structures to be stored.  For really complicated
structures, you probably shouldn't use this command-line interface,
just use the Perl API instead.

=item help

Prints a help message, including a few examples, and exits.

=back

=head1 AUTHOR

Ken Williams, kwilliams@cpan.org

=head1 COPYRIGHT

Copyright (c) 1999, Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

Module::Build(3), perl(1).

=cut
