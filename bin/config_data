#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;
  
  # This module doesn't do much of anything itself, it inherits from the
  # modules that do the real work.  The only real thing it has to do is
  # figure out which OS-specific module to pull in.  Many of the
  # OS-specific modules don't do anything either - most of the work is
  # done in Module::Build::Base.
  
  use 5.006;
  use strict;
  use warnings;
  use File::Spec ();
  use File::Path ();
  use File::Basename ();
  use Perl::OSType ();
  
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  # Inserts the given module into the @ISA hierarchy between
  # Module::Build and its immediate parent
  sub _interpose_module {
    my ($self, $mod) = @_;
    eval "use $mod";
    die $@ if $@;
  
    no strict 'refs';
    my $top_class = $mod;
    while (@{"${top_class}::ISA"}) {
      last if ${"${top_class}::ISA"}[0] eq $ISA[0];
      $top_class = ${"${top_class}::ISA"}[0];
    }
  
    @{"${top_class}::ISA"} = @ISA;
    @ISA = ($mod);
  }
  
  if (grep {-e File::Spec->catfile($_, qw(Module Build Platform), $^O) . '.pm'} @INC) {
    __PACKAGE__->_interpose_module("Module::Build::Platform::$^O");
  
  } elsif ( my $ostype = os_type() ) {
    __PACKAGE__->_interpose_module("Module::Build::Platform::$ostype");
  
  } else {
    warn "Unknown OS type '$^O' - using default settings\n";
  }
  
  sub os_type { return Perl::OSType::os_type() }
  
  sub is_vmsish { return Perl::OSType::is_os_type('VMS') }
  sub is_windowsish { return Perl::OSType::is_os_type('Windows') }
  sub is_unixish { return Perl::OSType::is_os_type('Unix') }
  
  1;
  
  __END__
  
  =for :stopwords
  bindoc binhtml destdir distcheck distclean distdir distmeta distsign disttest
  fakeinstall html installdirs installsitebin installsitescript installvendorbin
  installvendorscript libdoc libhtml pardist ppd ppmdist realclean skipcheck
  testall testcover testdb testpod testpodcoverage versioninstall
  
  =head1 NAME
  
  Module::Build - Build and install Perl modules
  
  =head1 SYNOPSIS
  
  Standard process for building & installing modules:
  
    perl Build.PL
    ./Build
    ./Build test
    ./Build install
  
  Or, if you're on a platform (like DOS or Windows) that doesn't require
  the "./" notation, you can do this:
  
    perl Build.PL
    Build
    Build test
    Build install
  
  
  =head1 DESCRIPTION
  
  C<Module::Build> is a system for building, testing, and installing
  Perl modules.  It is meant to be an alternative to
  C<ExtUtils::MakeMaker>.  Developers may alter the behavior of the
  module through subclassing in a much more straightforward way than
  with C<MakeMaker>.  It also does not require a C<make> on your system
  - most of the C<Module::Build> code is pure-perl and written in a very
  cross-platform way.
  
  See L<"MOTIVATIONS"> for more comparisons between C<ExtUtils::MakeMaker>
  and C<Module::Build>.
  
  To install C<Module::Build>, and any other module that uses
  C<Module::Build> for its installation process, do the following:
  
    perl Build.PL       # 'Build.PL' script creates the 'Build' script
    ./Build             # Need ./ to ensure we're using this "Build" script
    ./Build test        # and not another one that happens to be in the PATH
    ./Build install
  
  This illustrates initial configuration and the running of three
  'actions'.  In this case the actions run are 'build' (the default
  action), 'test', and 'install'.  Other actions defined so far include:
  
    build                          manifest
    clean                          manifest_skip
    code                           manpages
    config_data                    pardist
    diff                           ppd
    dist                           ppmdist
    distcheck                      prereq_data
    distclean                      prereq_report
    distdir                        pure_install
    distinstall                    realclean
    distmeta                       retest
    distsign                       skipcheck
    disttest                       test
    docs                           testall
    fakeinstall                    testcover
    help                           testdb
    html                           testpod
    install                        testpodcoverage
    installdeps                    versioninstall
  
  You can run the 'help' action for a complete list of actions.
  
  
  =head1 GUIDE TO DOCUMENTATION
  
  The documentation for C<Module::Build> is broken up into sections:
  
  =over
  
  =item General Usage (L<Module::Build>)
  
  This is the document you are currently reading. It describes basic
  usage and background information.  Its main purpose is to assist the
  user who wants to learn how to invoke and control C<Module::Build>
  scripts at the command line.
  
  =item Authoring Reference (L<Module::Build::Authoring>)
  
  This document describes the structure and organization of
  C<Module::Build>, and the relevant concepts needed by authors who are
  writing F<Build.PL> scripts for a distribution or controlling
  C<Module::Build> processes programmatically.
  
  =item API Reference (L<Module::Build::API>)
  
  This is a reference to the C<Module::Build> API.
  
  =item Cookbook (L<Module::Build::Cookbook>)
  
  This document demonstrates how to accomplish many common tasks.  It
  covers general command line usage and authoring of F<Build.PL>
  scripts.  Includes working examples.
  
  =back
  
  
  =head1 ACTIONS
  
  There are some general principles at work here.  First, each task when
  building a module is called an "action".  These actions are listed
  above; they correspond to the building, testing, installing,
  packaging, etc., tasks.
  
  Second, arguments are processed in a very systematic way.  Arguments
  are always key=value pairs.  They may be specified at C<perl Build.PL>
  time (i.e. C<perl Build.PL destdir=/my/secret/place>), in which case
  their values last for the lifetime of the C<Build> script.  They may
  also be specified when executing a particular action (i.e.
  C<Build test verbose=1>), in which case their values last only for the
  lifetime of that command.  Per-action command line parameters take
  precedence over parameters specified at C<perl Build.PL> time.
  
  The build process also relies heavily on the C<Config.pm> module.
  If the user wishes to override any of the
  values in C<Config.pm>, she may specify them like so:
  
    perl Build.PL --config cc=gcc --config ld=gcc
  
  The following build actions are provided by default.
  
  =over 4
  
  =item build
  
  [version 0.01]
  
  If you run the C<Build> script without any arguments, it runs the
  C<build> action, which in turn runs the C<code> and C<docs> actions.
  
  This is analogous to the C<MakeMaker> I<make all> target.
  
  =item clean
  
  [version 0.01]
  
  This action will clean up any files that the build process may have
  created, including the C<blib/> directory (but not including the
  C<_build/> directory and the C<Build> script itself).
  
  =item code
  
  [version 0.20]
  
  This action builds your code base.
  
  By default it just creates a C<blib/> directory and copies any C<.pm>
  and C<.pod> files from your C<lib/> directory into the C<blib/>
  directory.  It also compiles any C<.xs> files from C<lib/> and places
  them in C<blib/>.  Of course, you need a working C compiler (probably
  the same one that built perl itself) for the compilation to work
  properly.
  
  The C<code> action also runs any C<.PL> files in your F<lib/>
  directory.  Typically these create other files, named the same but
  without the C<.PL> ending.  For example, a file F<lib/Foo/Bar.pm.PL>
  could create the file F<lib/Foo/Bar.pm>.  The C<.PL> files are
  processed first, so any C<.pm> files (or other kinds that we deal
  with) will get copied correctly.
  
  =item config_data
  
  [version 0.26]
  
  ...
  
  =item diff
  
  [version 0.14]
  
  This action will compare the files about to be installed with their
  installed counterparts.  For .pm and .pod files, a diff will be shown
  (this currently requires a 'diff' program to be in your PATH).  For
  other files like compiled binary files, we simply report whether they
  differ.
  
  A C<flags> parameter may be passed to the action, which will be passed
  to the 'diff' program.  Consult your 'diff' documentation for the
  parameters it will accept - a good one is C<-u>:
  
    ./Build diff flags=-u
  
  =item dist
  
  [version 0.02]
  
  This action is helpful for module authors who want to package up their
  module for source distribution through a medium like CPAN.  It will create a
  tarball of the files listed in F<MANIFEST> and compress the tarball using
  GZIP compression.
  
  By default, this action will use the C<Archive::Tar> module. However, you can
  force it to use binary "tar" and "gzip" executables by supplying an explicit
  C<tar> (and optional C<gzip>) parameter:
  
    ./Build dist --tar C:\path\to\tar.exe --gzip C:\path\to\zip.exe
  
  =item distcheck
  
  [version 0.05]
  
  Reports which files are in the build directory but not in the
  F<MANIFEST> file, and vice versa.  (See L<manifest> for details.)
  
  =item distclean
  
  [version 0.05]
  
  Performs the 'realclean' action and then the 'distcheck' action.
  
  =item distdir
  
  [version 0.05]
  
  Creates a "distribution directory" named C<$dist_name-$dist_version>
  (if that directory already exists, it will be removed first), then
  copies all the files listed in the F<MANIFEST> file to that directory.
  This directory is what the distribution tarball is created from.
  
  =item distinstall
  
  [version 0.37]
  
  Performs the 'distdir' action, then switches into that directory and runs a
  C<perl Build.PL>, followed by the 'build' and 'install' actions in that
  directory.  Use PERL_MB_OPT or F<.modulebuildrc> to set options that should be
  applied during subprocesses
  
  =item distmeta
  
  [version 0.21]
  
  Creates the F<META.yml> file that describes the distribution.
  
  F<META.yml> is a file containing various bits of I<metadata> about the
  distribution.  The metadata includes the distribution name, version,
  abstract, prerequisites, license, and various other data about the
  distribution.  This file is created as F<META.yml> in a simplified YAML format.
  
  F<META.yml> file must also be listed in F<MANIFEST> - if it's not, a
  warning will be issued.
  
  The current version of the F<META.yml> specification can be found
  on CPAN as L<CPAN::Meta::Spec>.
  
  =item distsign
  
  [version 0.16]
  
  Uses C<Module::Signature> to create a SIGNATURE file for your
  distribution, and adds the SIGNATURE file to the distribution's
  MANIFEST.
  
  =item disttest
  
  [version 0.05]
  
  Performs the 'distdir' action, then switches into that directory and runs a
  C<perl Build.PL>, followed by the 'build' and 'test' actions in that directory.
  Use PERL_MB_OPT or F<.modulebuildrc> to set options that should be applied
  during subprocesses
  
  
  =item docs
  
  [version 0.20]
  
  This will generate documentation (e.g. Unix man pages and HTML
  documents) for any installable items under B<blib/> that
  contain POD.  If there are no C<bindoc> or C<libdoc> installation
  targets defined (as will be the case on systems that don't support
  Unix manpages) no action is taken for manpages.  If there are no
  C<binhtml> or C<libhtml> installation targets defined no action is
  taken for HTML documents.
  
  =item fakeinstall
  
  [version 0.02]
  
  This is just like the C<install> action, but it won't actually do
  anything, it will just report what it I<would> have done if you had
  actually run the C<install> action.
  
  =item help
  
  [version 0.03]
  
  This action will simply print out a message that is meant to help you
  use the build process.  It will show you a list of available build
  actions too.
  
  With an optional argument specifying an action name (e.g. C<Build help
  test>), the 'help' action will show you any POD documentation it can
  find for that action.
  
  =item html
  
  [version 0.26]
  
  This will generate HTML documentation for any binary or library files
  under B<blib/> that contain POD.  The HTML documentation will only be
  installed if the install paths can be determined from values in
  C<Config.pm>.  You can also supply or override install paths on the
  command line by specifying C<install_path> values for the C<binhtml>
  and/or C<libhtml> installation targets.
  
  With an optional C<html_links> argument set to a false value, you can
  skip the search for other documentation to link to, because that can
  waste a lot of time if there aren't any links to generate anyway:
  
    ./Build html --html_links 0
  
  =item install
  
  [version 0.01]
  
  This action will use C<ExtUtils::Install> to install the files from
  C<blib/> into the system.  See L<"INSTALL PATHS">
  for details about how Module::Build determines where to install
  things, and how to influence this process.
  
  If you want the installation process to look around in C<@INC> for
  other versions of the stuff you're installing and try to delete it,
  you can use the C<uninst> parameter, which tells C<ExtUtils::Install> to
  do so:
  
    ./Build install uninst=1
  
  This can be a good idea, as it helps prevent multiple versions of a
  module from being present on your system, which can be a confusing
  situation indeed.
  
  =item installdeps
  
  [version 0.36]
  
  This action will use the C<cpan_client> parameter as a command to install
  missing prerequisites.  You will be prompted whether to install
  optional dependencies.
  
  The C<cpan_client> option defaults to 'cpan' but can be set as an option or in
  F<.modulebuildrc>.  It must be a shell command that takes a list of modules to
  install as arguments (e.g. 'cpanp -i' for CPANPLUS).  If the program part is a
  relative path (e.g. 'cpan' or 'cpanp'), it will be located relative to the perl
  program that executed Build.PL.
  
    /opt/perl/5.8.9/bin/perl Build.PL
    ./Build installdeps --cpan_client 'cpanp -i'
    # installs to 5.8.9
  
  =item manifest
  
  [version 0.05]
  
  This is an action intended for use by module authors, not people
  installing modules.  It will bring the F<MANIFEST> up to date with the
  files currently present in the distribution.  You may use a
  F<MANIFEST.SKIP> file to exclude certain files or directories from
  inclusion in the F<MANIFEST>.  F<MANIFEST.SKIP> should contain a bunch
  of regular expressions, one per line.  If a file in the distribution
  directory matches any of the regular expressions, it won't be included
  in the F<MANIFEST>.
  
  The following is a reasonable F<MANIFEST.SKIP> starting point, you can
  add your own stuff to it:
  
    ^_build
    ^Build$
    ^blib
    ~$
    \.bak$
    ^MANIFEST\.SKIP$
    CVS
  
  See the L<distcheck> and L<skipcheck> actions if you want to find out
  what the C<manifest> action would do, without actually doing anything.
  
  =item manifest_skip
  
  [version 0.3608]
  
  This is an action intended for use by module authors, not people
  installing modules.  It will generate a boilerplate MANIFEST.SKIP file
  if one does not already exist.
  
  =item manpages
  
  [version 0.28]
  
  This will generate man pages for any binary or library files under
  B<blib/> that contain POD.  The man pages will only be installed if the
  install paths can be determined from values in C<Config.pm>.  You can
  also supply or override install paths by specifying there values on
  the command line with the C<bindoc> and C<libdoc> installation
  targets.
  
  =item pardist
  
  [version 0.2806]
  
  Generates a PAR binary distribution for use with L<PAR> or L<PAR::Dist>.
  
  It requires that the PAR::Dist module (version 0.17 and up) is
  installed on your system.
  
  =item ppd
  
  [version 0.20]
  
  Build a PPD file for your distribution.
  
  This action takes an optional argument C<codebase> which is used in
  the generated PPD file to specify the (usually relative) URL of the
  distribution.  By default, this value is the distribution name without
  any path information.
  
  Example:
  
    ./Build ppd --codebase "MSWin32-x86-multi-thread/Module-Build-0.21.tar.gz"
  
  =item ppmdist
  
  [version 0.23]
  
  Generates a PPM binary distribution and a PPD description file.  This
  action also invokes the C<ppd> action, so it can accept the same
  C<codebase> argument described under that action.
  
  This uses the same mechanism as the C<dist> action to tar & zip its
  output, so you can supply C<tar> and/or C<gzip> parameters to affect
  the result.
  
  =item prereq_data
  
  [version 0.32]
  
  This action prints out a Perl data structure of all prerequisites and the versions
  required.  The output can be loaded again using C<eval()>.  This can be useful for
  external tools that wish to query a Build script for prerequisites.
  
  =item prereq_report
  
  [version 0.28]
  
  This action prints out a list of all prerequisites, the versions required, and
  the versions actually installed.  This can be useful for reviewing the
  configuration of your system prior to a build, or when compiling data to send
  for a bug report.
  
  =item pure_install
  
  [version 0.28]
  
  This action is identical to the C<install> action.  In the future,
  though, when C<install> starts writing to the file
  F<$(INSTALLARCHLIB)/perllocal.pod>, C<pure_install> won't, and that
  will be the only difference between them.
  
  =item realclean
  
  [version 0.01]
  
  This action is just like the C<clean> action, but also removes the
  C<_build> directory and the C<Build> script.  If you run the
  C<realclean> action, you are essentially starting over, so you will
  have to re-create the C<Build> script again.
  
  =item retest
  
  [version 0.2806]
  
  This is just like the C<test> action, but doesn't actually build the
  distribution first, and doesn't add F<blib/> to the load path, and
  therefore will test against a I<previously> installed version of the
  distribution.  This can be used to verify that a certain installed
  distribution still works, or to see whether newer versions of a
  distribution still pass the old regression tests, and so on.
  
  =item skipcheck
  
  [version 0.05]
  
  Reports which files are skipped due to the entries in the
  F<MANIFEST.SKIP> file (See L<manifest> for details)
  
  =item test
  
  [version 0.01]
  
  This will use C<Test::Harness> or C<TAP::Harness> to run any regression
  tests and report their results. Tests can be defined in the standard
  places: a file called C<test.pl> in the top-level directory, or several
  files ending with C<.t> in a C<t/> directory.
  
  If you want tests to be 'verbose', i.e. show details of test execution
  rather than just summary information, pass the argument C<verbose=1>.
  
  If you want to run tests under the perl debugger, pass the argument
  C<debugger=1>.
  
  If you want to have Module::Build find test files with different file
  name extensions, pass the C<test_file_exts> argument with an array
  of extensions, such as C<[qw( .t .s .z )]>.
  
  If you want test to be run by C<TAP::Harness>, rather than C<Test::Harness>,
  pass the argument C<tap_harness_args> as an array reference of arguments to
  pass to the TAP::Harness constructor.
  
  In addition, if a file called C<visual.pl> exists in the top-level
  directory, this file will be executed as a Perl script and its output
  will be shown to the user.  This is a good place to put speed tests or
  other tests that don't use the C<Test::Harness> format for output.
  
  To override the choice of tests to run, you may pass a C<test_files>
  argument whose value is a whitespace-separated list of test scripts to
  run.  This is especially useful in development, when you only want to
  run a single test to see whether you've squashed a certain bug yet:
  
    ./Build test --test_files t/something_failing.t
  
  You may also pass several C<test_files> arguments separately:
  
    ./Build test --test_files t/one.t --test_files t/two.t
  
  or use a C<glob()>-style pattern:
  
    ./Build test --test_files 't/01-*.t'
  
  =item testall
  
  [version 0.2807]
  
  [Note: the 'testall' action and the code snippets below are currently
  in alpha stage, see
  L<"http://www.nntp.perl.org/group/perl.module.build/2007/03/msg584.html"> ]
  
  Runs the C<test> action plus each of the C<test$type> actions defined by
  the keys of the C<test_types> parameter.
  
  Currently, you need to define the ACTION_test$type method yourself and
  enumerate them in the test_types parameter.
  
    my $mb = Module::Build->subclass(
      code => q(
        sub ACTION_testspecial { shift->generic_test(type => 'special'); }
        sub ACTION_testauthor  { shift->generic_test(type => 'author'); }
      )
    )->new(
      ...
      test_types  => {
        special => '.st',
        author  => ['.at', '.pt' ],
      },
      ...
  
  =item testcover
  
  [version 0.26]
  
  Runs the C<test> action using C<Devel::Cover>, generating a
  code-coverage report showing which parts of the code were actually
  exercised during the tests.
  
  To pass options to C<Devel::Cover>, set the C<$DEVEL_COVER_OPTIONS>
  environment variable:
  
    DEVEL_COVER_OPTIONS=-ignore,Build ./Build testcover
  
  =item testdb
  
  [version 0.05]
  
  This is a synonym for the 'test' action with the C<debugger=1>
  argument.
  
  =item testpod
  
  [version 0.25]
  
  This checks all the files described in the C<docs> action and
  produces C<Test::Harness>-style output.  If you are a module author,
  this is useful to run before creating a new release.
  
  =item testpodcoverage
  
  [version 0.28]
  
  This checks the pod coverage of the distribution and
  produces C<Test::Harness>-style output. If you are a module author,
  this is useful to run before creating a new release.
  
  =item versioninstall
  
  [version 0.16]
  
  ** Note: since C<only.pm> is so new, and since we just recently added
  support for it here too, this feature is to be considered
  experimental. **
  
  If you have the C<only.pm> module installed on your system, you can
  use this action to install a module into the version-specific library
  trees.  This means that you can have several versions of the same
  module installed and C<use> a specific one like this:
  
    use only MyModule => 0.55;
  
  To override the default installation libraries in C<only::config>,
  specify the C<versionlib> parameter when you run the C<Build.PL> script:
  
    perl Build.PL --versionlib /my/version/place/
  
  To override which version the module is installed as, specify the
  C<version> parameter when you run the C<Build.PL> script:
  
    perl Build.PL --version 0.50
  
  See the C<only.pm> documentation for more information on
  version-specific installs.
  
  =back
  
  
  =head1 OPTIONS
  
  =head2 Command Line Options
  
  The following options can be used during any invocation of C<Build.PL>
  or the Build script, during any action.  For information on other
  options specific to an action, see the documentation for the
  respective action.
  
  NOTE: There is some preliminary support for options to use the more
  familiar long option style.  Most options can be preceded with the
  C<--> long option prefix, and the underscores changed to dashes
  (e.g. C<--use-rcfile>).  Additionally, the argument to boolean options is
  optional, and boolean options can be negated by prefixing them with
  C<no> or C<no-> (e.g. C<--noverbose> or C<--no-verbose>).
  
  =over 4
  
  =item quiet
  
  Suppress informative messages on output.
  
  =item verbose
  
  Display extra information about the Build on output.  C<verbose> will
  turn off C<quiet>
  
  =item cpan_client
  
  Sets the C<cpan_client> command for use with the C<installdeps> action.
  See C<installdeps> for more details.
  
  =item use_rcfile
  
  Load the F<~/.modulebuildrc> option file.  This option can be set to
  false to prevent the custom resource file from being loaded.
  
  =item allow_mb_mismatch
  
  Suppresses the check upon startup that the version of Module::Build
  we're now running under is the same version that was initially invoked
  when building the distribution (i.e. when the C<Build.PL> script was
  first run).  As of 0.3601, a mismatch results in a warning instead of
  a fatal error, so this option effectively just suppresses the warning.
  
  =item debug
  
  Prints Module::Build debugging information to STDOUT, such as a trace of
  executed build actions.
  
  =back
  
  =head2 Default Options File (F<.modulebuildrc>)
  
  [version 0.28]
  
  When Module::Build starts up, it will look first for a file,
  F<$ENV{HOME}/.modulebuildrc>.  If it's not found there, it will look
  in the F<.modulebuildrc> file in the directories referred to by
  the environment variables C<HOMEDRIVE> + C<HOMEDIR>, C<USERPROFILE>,
  C<APPDATA>, C<WINDIR>, C<SYS$LOGIN>.  If the file exists, the options
  specified there will be used as defaults, as if they were typed on the
  command line.  The defaults can be overridden by specifying new values
  on the command line.
  
  The action name must come at the beginning of the line, followed by any
  amount of whitespace and then the options.  Options are given the same
  as they would be on the command line.  They can be separated by any
  amount of whitespace, including newlines, as long there is whitespace at
  the beginning of each continued line.  Anything following a hash mark (C<#>)
  is considered a comment, and is stripped before parsing.  If more than
  one line begins with the same action name, those lines are merged into
  one set of options.
  
  Besides the regular actions, there are two special pseudo-actions: the
  key C<*> (asterisk) denotes any global options that should be applied
  to all actions, and the key 'Build_PL' specifies options to be applied
  when you invoke C<perl Build.PL>.
  
    *           verbose=1   # global options
    diff        flags=-u
    install     --install_base /home/ken
                --install_path html=/home/ken/docs/html
    installdeps --cpan_client 'cpanp -i'
  
  If you wish to locate your resource file in a different location, you
  can set the environment variable C<MODULEBUILDRC> to the complete
  absolute path of the file containing your options.
  
  =head2 Environment variables
  
  =over
  
  =item MODULEBUILDRC
  
  [version 0.28]
  
  Specifies an alternate location for a default options file as described above.
  
  =item PERL_MB_OPT
  
  [version 0.36]
  
  Command line options that are applied to Build.PL or any Build action.  The
  string is split as the shell would (e.g. whitespace) and the result is
  prepended to any actual command-line arguments.
  
  =back
  
  =head1 INSTALL PATHS
  
  [version 0.19]
  
  When you invoke Module::Build's C<build> action, it needs to figure
  out where to install things.  The nutshell version of how this works
  is that default installation locations are determined from
  F<Config.pm>, and they may be overridden by using the C<install_path>
  parameter.  An C<install_base> parameter lets you specify an
  alternative installation root like F</home/foo>, and a C<destdir> lets
  you specify a temporary installation directory like F</tmp/install> in
  case you want to create bundled-up installable packages.
  
  Natively, Module::Build provides default installation locations for
  the following types of installable items:
  
  =over 4
  
  =item lib
  
  Usually pure-Perl module files ending in F<.pm>.
  
  =item arch
  
  "Architecture-dependent" module files, usually produced by compiling
  XS, L<Inline>, or similar code.
  
  =item script
  
  Programs written in pure Perl.  In order to improve reuse, try to make
  these as small as possible - put the code into modules whenever
  possible.
  
  =item bin
  
  "Architecture-dependent" executable programs, i.e. compiled C code or
  something.  Pretty rare to see this in a perl distribution, but it
  happens.
  
  =item bindoc
  
  Documentation for the stuff in C<script> and C<bin>.  Usually
  generated from the POD in those files.  Under Unix, these are manual
  pages belonging to the 'man1' category.
  
  =item libdoc
  
  Documentation for the stuff in C<lib> and C<arch>.  This is usually
  generated from the POD in F<.pm> files.  Under Unix, these are manual
  pages belonging to the 'man3' category.
  
  =item binhtml
  
  This is the same as C<bindoc> above, but applies to HTML documents.
  
  =item libhtml
  
  This is the same as C<libdoc> above, but applies to HTML documents.
  
  =back
  
  Four other parameters let you control various aspects of how
  installation paths are determined:
  
  =over 4
  
  =item installdirs
  
  The default destinations for these installable things come from
  entries in your system's C<Config.pm>.  You can select from three
  different sets of default locations by setting the C<installdirs>
  parameter as follows:
  
                            'installdirs' set to:
                     core          site                vendor
  
                uses the following defaults from Config.pm:
  
    lib     => installprivlib  installsitelib      installvendorlib
    arch    => installarchlib  installsitearch     installvendorarch
    script  => installscript   installsitescript   installvendorscript
    bin     => installbin      installsitebin      installvendorbin
    bindoc  => installman1dir  installsiteman1dir  installvendorman1dir
    libdoc  => installman3dir  installsiteman3dir  installvendorman3dir
    binhtml => installhtml1dir installsitehtml1dir installvendorhtml1dir [*]
    libhtml => installhtml3dir installsitehtml3dir installvendorhtml3dir [*]
  
    * Under some OS (eg. MSWin32) the destination for HTML documents is
      determined by the C<Config.pm> entry C<installhtmldir>.
  
  The default value of C<installdirs> is "site".  If you're creating
  vendor distributions of module packages, you may want to do something
  like this:
  
    perl Build.PL --installdirs vendor
  
  or
  
    ./Build install --installdirs vendor
  
  If you're installing an updated version of a module that was included
  with perl itself (i.e. a "core module"), then you may set
  C<installdirs> to "core" to overwrite the module in its present
  location.
  
  (Note that the 'script' line is different from C<MakeMaker> -
  unfortunately there's no such thing as "installsitescript" or
  "installvendorscript" entry in C<Config.pm>, so we use the
  "installsitebin" and "installvendorbin" entries to at least get the
  general location right.  In the future, if C<Config.pm> adds some more
  appropriate entries, we'll start using those.)
  
  =item install_path
  
  Once the defaults have been set, you can override them.
  
  On the command line, that would look like this:
  
    perl Build.PL --install_path lib=/foo/lib --install_path arch=/foo/lib/arch
  
  or this:
  
    ./Build install --install_path lib=/foo/lib --install_path arch=/foo/lib/arch
  
  =item install_base
  
  You can also set the whole bunch of installation paths by supplying the
  C<install_base> parameter to point to a directory on your system.  For
  instance, if you set C<install_base> to "/home/ken" on a Linux
  system, you'll install as follows:
  
    lib     => /home/ken/lib/perl5
    arch    => /home/ken/lib/perl5/i386-linux
    script  => /home/ken/bin
    bin     => /home/ken/bin
    bindoc  => /home/ken/man/man1
    libdoc  => /home/ken/man/man3
    binhtml => /home/ken/html
    libhtml => /home/ken/html
  
  Note that this is I<different> from how C<MakeMaker>'s C<PREFIX>
  parameter works.  C<install_base> just gives you a default layout under the
  directory you specify, which may have little to do with the
  C<installdirs=site> layout.
  
  The exact layout under the directory you specify may vary by system -
  we try to do the "sensible" thing on each platform.
  
  =item destdir
  
  If you want to install everything into a temporary directory first
  (for instance, if you want to create a directory tree that a package
  manager like C<rpm> or C<dpkg> could create a package from), you can
  use the C<destdir> parameter:
  
    perl Build.PL --destdir /tmp/foo
  
  or
  
    ./Build install --destdir /tmp/foo
  
  This will effectively install to "/tmp/foo/$sitelib",
  "/tmp/foo/$sitearch", and the like, except that it will use
  C<File::Spec> to make the pathnames work correctly on whatever
  platform you're installing on.
  
  =item prefix
  
  Provided for compatibility with C<ExtUtils::MakeMaker>'s PREFIX argument.
  C<prefix> should be used when you want Module::Build to install your
  modules, documentation, and scripts in the same place as
  C<ExtUtils::MakeMaker>'s PREFIX mechanism.
  
  The following are equivalent.
  
      perl Build.PL --prefix /tmp/foo
      perl Makefile.PL PREFIX=/tmp/foo
  
  Because of the complex nature of the prefixification logic, the
  behavior of PREFIX in C<MakeMaker> has changed subtly over time.
  Module::Build's --prefix logic is equivalent to the PREFIX logic found
  in C<ExtUtils::MakeMaker> 6.30.
  
  The maintainers of C<MakeMaker> do understand the troubles with the
  PREFIX mechanism, and added INSTALL_BASE support in version 6.31 of
  C<MakeMaker>, which was released in 2006.
  
  If you don't need to retain compatibility with old versions (pre-6.31) of C<ExtUtils::MakeMaker> or
  are starting a fresh Perl installation we recommend you use
  C<install_base> instead (and C<INSTALL_BASE> in C<ExtUtils::MakeMaker>).
  See L<Module::Build::Cookbook/Installing in the same location as
  ExtUtils::MakeMaker> for further information.
  
  
  =back
  
  
  =head1 MOTIVATIONS
  
  There are several reasons I wanted to start over, and not just fix
  what I didn't like about C<MakeMaker>:
  
  =over 4
  
  =item *
  
  I don't like the core idea of C<MakeMaker>, namely that C<make> should be
  involved in the build process.  Here are my reasons:
  
  =over 4
  
  =item +
  
  When a person is installing a Perl module, what can you assume about
  their environment?  Can you assume they have C<make>?  No, but you can
  assume they have some version of Perl.
  
  =item +
  
  When a person is writing a Perl module for intended distribution, can
  you assume that they know how to build a Makefile, so they can
  customize their build process?  No, but you can assume they know Perl,
  and could customize that way.
  
  =back
  
  For years, these things have been a barrier to people getting the
  build/install process to do what they want.
  
  =item *
  
  There are several architectural decisions in C<MakeMaker> that make it
  very difficult to customize its behavior.  For instance, when using
  C<MakeMaker> you do C<use ExtUtils::MakeMaker>, but the object created in
  C<WriteMakefile()> is actually blessed into a package name that's
  created on the fly, so you can't simply subclass
  C<ExtUtils::MakeMaker>.  There is a workaround C<MY> package that lets
  you override certain C<MakeMaker> methods, but only certain explicitly
  preselected (by C<MakeMaker>) methods can be overridden.  Also, the method
  of customization is very crude: you have to modify a string containing
  the Makefile text for the particular target.  Since these strings
  aren't documented, and I<can't> be documented (they take on different
  values depending on the platform, version of perl, version of
  C<MakeMaker>, etc.), you have no guarantee that your modifications will
  work on someone else's machine or after an upgrade of C<MakeMaker> or
  perl.
  
  =item *
  
  It is risky to make major changes to C<MakeMaker>, since it does so many
  things, is so important, and generally works.  C<Module::Build> is an
  entirely separate package so that I can work on it all I want, without
  worrying about backward compatibility with C<MakeMaker>.
  
  =item *
  
  Finally, Perl is said to be a language for system administration.
  Could it really be the case that Perl isn't up to the task of building
  and installing software?  Even if that software is a bunch of
  C<.pm> files that just need to be copied from one place to
  another?  My sense was that we could design a system to accomplish
  this in a flexible, extensible, and friendly manner.  Or die trying.
  
  =back
  
  
  =head1 TO DO
  
  The current method of relying on time stamps to determine whether a
  derived file is out of date isn't likely to scale well, since it
  requires tracing all dependencies backward, it runs into problems on
  NFS, and it's just generally flimsy.  It would be better to use an MD5
  signature or the like, if available.  See C<cons> for an example.
  
   - append to perllocal.pod
   - add a 'plugin' functionality
  
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  Development questions, bug reports, and patches should be sent to the
  Module-Build mailing list at <module-build@perl.org>.
  
  Bug reports are also welcome at
  <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Module-Build>.
  
  The latest development version is available from the Git
  repository at <https://github.com/Perl-Toolchain-Gang/Module-Build>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  perl(1), L<Module::Build::Cookbook>, L<Module::Build::Authoring>,
  L<Module::Build::API>, L<ExtUtils::MakeMaker>
  
  F<META.yml> Specification:
  L<CPAN::Meta::Spec>
  
  L<http://www.dsmit.com/cons/>
  
  L<http://search.cpan.org/dist/PerlBuildSystem/>
  
  =cut
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2
  package Module::Build::Base;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  use Carp;
  use Cwd ();
  use File::Copy ();
  use File::Find ();
  use File::Path ();
  use File::Basename ();
  use File::Spec 0.82 ();
  use File::Compare ();
  use Module::Build::Dumper ();
  use Text::ParseWords ();
  
  use Module::Metadata;
  use Module::Build::Notes;
  use Module::Build::Config;
  use version;
  
  
  #################### Constructors ###########################
  sub new {
    my $self = shift()->_construct(@_);
  
    $self->{invoked_action} = $self->{action} ||= 'Build_PL';
    $self->cull_args(@ARGV);
  
    die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n"
      if $self->{action} && $self->{action} ne 'Build_PL';
  
    $self->check_manifest;
    $self->auto_require;
  
    # All checks must run regardless if one fails, so no short circuiting!
    if( grep { !$_ } $self->check_prereq, $self->check_autofeatures ) {
      $self->log_warn(<<EOF);
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
      unless (
        $self->dist_name eq 'Module-Build' ||
        $ENV{PERL5_CPANPLUS_IS_RUNNING} || $ENV{PERL5_CPAN_IS_RUNNING}
      ) {
        $self->log_warn(
          "Run 'Build installdeps' to install missing prerequisites.\n\n"
        );
      }
    }
  
    # record for later use in resume;
    $self->{properties}{_added_to_INC} = [ $self->_added_to_INC ];
  
    $self->set_bundle_inc;
  
    $self->dist_name;
    $self->dist_version;
    $self->release_status;
    $self->_guess_module_name unless $self->module_name;
  
    $self->_find_nested_builds;
  
    return $self;
  }
  
  sub resume {
    my $package = shift;
    my $self = $package->_construct(@_);
    $self->read_config;
  
    my @added_earlier = @{ $self->{properties}{_added_to_INC} || [] };
  
    @INC = ($self->_added_to_INC, @added_earlier, $self->_default_INC);
  
    # If someone called Module::Build->current() or
    # Module::Build->new_from_context() and the correct class to use is
    # actually a *subclass* of Module::Build, we may need to load that
    # subclass here and re-delegate the resume() method to it.
    unless ( $package->isa($self->build_class) ) {
      my $build_class = $self->build_class;
      my $config_dir = $self->config_dir || '_build';
      my $build_lib = File::Spec->catdir( $config_dir, 'lib' );
      unshift( @INC, $build_lib );
      unless ( $build_class->can('new') ) {
        eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@";
      }
      return $build_class->resume(@_);
    }
  
    unless ($self->_perl_is_same($self->{properties}{perl})) {
      my $perl = $self->find_perl_interpreter;
      die(<<"DIEFATAL");
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
    }
  
    $self->cull_args(@ARGV);
  
    unless ($self->allow_mb_mismatch) {
      my $mb_version = $Module::Build::VERSION;
      if ( $mb_version ne $self->{properties}{mb_version} ) {
        $self->log_warn(<<"MISMATCH");
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
      }
    }
  
    $self->{invoked_action} = $self->{action} ||= 'build';
  
    return $self;
  }
  
  sub new_from_context {
    my ($package, %args) = @_;
  
    $package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);
    return $package->resume;
  }
  
  sub current {
    # hmm, wonder what the right thing to do here is
    local @ARGV;
    return shift()->resume;
  }
  
  sub _construct {
    my ($package, %input) = @_;
  
    my $args   = delete $input{args}   || {};
    my $config = delete $input{config} || {};
  
    my $self = bless {
        args => {%$args},
        config => Module::Build::Config->new(values => $config),
        properties => {
            base_dir        => $package->cwd,
            mb_version      => $Module::Build::VERSION,
            %input,
        },
        phash => {},
        stash => {}, # temporary caching, not stored in _build
    }, $package;
  
    $self->_set_defaults;
    my ($p, $ph) = ($self->{properties}, $self->{phash});
  
    foreach (qw(notes config_data features runtime_params cleanup auto_features)) {
      my $file = File::Spec->catfile($self->config_dir, $_);
      $ph->{$_} = Module::Build::Notes->new(file => $file);
      $ph->{$_}->restore if -e $file;
      if (exists $p->{$_}) {
        my $vals = delete $p->{$_};
        foreach my $k (sort keys %$vals) {
          $self->$_($k, $vals->{$k});
        }
      }
    }
  
    # The following warning could be unnecessary if the user is running
    # an embedded perl, but there aren't too many of those around, and
    # embedded perls aren't usually used to install modules, and the
    # installation process sometimes needs to run external scripts
    # (e.g. to run tests).
    $p->{perl} = $self->find_perl_interpreter
      or $self->log_warn("Warning: Can't locate your perl binary");
  
    my $blibdir = sub { File::Spec->catdir($p->{blib}, @_) };
    $p->{bindoc_dirs} ||= [ $blibdir->("script") ];
    $p->{libdoc_dirs} ||= [ $blibdir->("lib"), $blibdir->("arch") ];
  
    $p->{dist_author} = [ $p->{dist_author} ] if defined $p->{dist_author} and not ref $p->{dist_author};
  
    # Synonyms
    $p->{requires} = delete $p->{prereq} if defined $p->{prereq};
    $p->{script_files} = delete $p->{scripts} if defined $p->{scripts};
  
    # Convert to from shell strings to arrays
    for ('extra_compiler_flags', 'extra_linker_flags') {
      $p->{$_} = [ $self->split_like_shell($p->{$_}) ] if exists $p->{$_};
    }
  
    # Convert to arrays
    for ('include_dirs') {
      $p->{$_} = [ $p->{$_} ] if exists $p->{$_} && !ref $p->{$_}
    }
  
    $self->add_to_cleanup( @{delete $p->{add_to_cleanup}} )
      if $p->{add_to_cleanup};
  
    return $self;
  }
  
  ################## End constructors #########################
  
  sub log_info {
    my $self = shift;
    print @_ if ref($self) && ( $self->verbose || ! $self->quiet );
  }
  sub log_verbose {
    my $self = shift;
    print @_ if ref($self) && $self->verbose;
  }
  sub log_debug {
    my $self = shift;
    print @_ if ref($self) && $self->debug;
  }
  
  sub log_warn {
    # Try to make our call stack invisible
    shift;
    if (@_ and $_[-1] !~ /\n$/) {
      my (undef, $file, $line) = caller();
      warn @_, " at $file line $line.\n";
    } else {
      warn @_;
    }
  }
  
  
  # install paths must be generated when requested to be sure all changes
  # to config (from various sources) are included
  sub _default_install_paths {
    my $self = shift;
    my $c = $self->{config};
    my $p = {};
  
    my @libstyle = $c->get('installstyle') ?
        File::Spec->splitdir($c->get('installstyle')) : qw(lib perl5);
    my $arch     = $c->get('archname');
    my $version  = $c->get('version');
  
    my $bindoc  = $c->get('installman1dir') || undef;
    my $libdoc  = $c->get('installman3dir') || undef;
  
    my $binhtml = $c->get('installhtml1dir') || $c->get('installhtmldir') || undef;
    my $libhtml = $c->get('installhtml3dir') || $c->get('installhtmldir') || undef;
  
    $p->{install_sets} =
      {
       core   => {
         lib     => $c->get('installprivlib'),
         arch    => $c->get('installarchlib'),
         bin     => $c->get('installbin'),
         script  => $c->get('installscript'),
         bindoc  => $bindoc,
         libdoc  => $libdoc,
         binhtml => $binhtml,
         libhtml => $libhtml,
       },
       site   => {
         lib     => $c->get('installsitelib'),
         arch    => $c->get('installsitearch'),
         bin     => $c->get('installsitebin')      || $c->get('installbin'),
         script  => $c->get('installsitescript')   ||
           $c->get('installsitebin') || $c->get('installscript'),
         bindoc  => $c->get('installsiteman1dir')  || $bindoc,
         libdoc  => $c->get('installsiteman3dir')  || $libdoc,
         binhtml => $c->get('installsitehtml1dir') || $binhtml,
         libhtml => $c->get('installsitehtml3dir') || $libhtml,
       },
       vendor => {
         lib     => $c->get('installvendorlib'),
         arch    => $c->get('installvendorarch'),
         bin     => $c->get('installvendorbin')      || $c->get('installbin'),
         script  => $c->get('installvendorscript')   ||
           $c->get('installvendorbin') || $c->get('installscript'),
         bindoc  => $c->get('installvendorman1dir')  || $bindoc,
         libdoc  => $c->get('installvendorman3dir')  || $libdoc,
         binhtml => $c->get('installvendorhtml1dir') || $binhtml,
         libhtml => $c->get('installvendorhtml3dir') || $libhtml,
       },
      };
  
    $p->{original_prefix} =
      {
       core   => $c->get('installprefixexp') || $c->get('installprefix') ||
                 $c->get('prefixexp')        || $c->get('prefix') || '',
       site   => $c->get('siteprefixexp'),
       vendor => $c->get('usevendorprefix') ? $c->get('vendorprefixexp') : '',
      };
    $p->{original_prefix}{site} ||= $p->{original_prefix}{core};
  
    # Note: you might be tempted to use $Config{installstyle} here
    # instead of hard-coding lib/perl5, but that's been considered and
    # (at least for now) rejected.  `perldoc Config` has some wisdom
    # about it.
    $p->{install_base_relpaths} =
      {
       lib     => ['lib', 'perl5'],
       arch    => ['lib', 'perl5', $arch],
       bin     => ['bin'],
       script  => ['bin'],
       bindoc  => ['man', 'man1'],
       libdoc  => ['man', 'man3'],
       binhtml => ['html'],
       libhtml => ['html'],
      };
  
    $p->{prefix_relpaths} =
      {
       core => {
         lib        => [@libstyle],
         arch       => [@libstyle, $version, $arch],
         bin        => ['bin'],
         script     => ['bin'],
         bindoc     => ['man', 'man1'],
         libdoc     => ['man', 'man3'],
         binhtml    => ['html'],
         libhtml    => ['html'],
       },
       vendor => {
         lib        => [@libstyle],
         arch       => [@libstyle, $version, $arch],
         bin        => ['bin'],
         script     => ['bin'],
         bindoc     => ['man', 'man1'],
         libdoc     => ['man', 'man3'],
         binhtml    => ['html'],
         libhtml    => ['html'],
       },
       site => {
         lib        => [@libstyle, 'site_perl'],
         arch       => [@libstyle, 'site_perl', $version, $arch],
         bin        => ['bin'],
         script     => ['bin'],
         bindoc     => ['man', 'man1'],
         libdoc     => ['man', 'man3'],
         binhtml    => ['html'],
         libhtml    => ['html'],
       },
      };
      return $p
  }
  
  sub _find_nested_builds {
    my $self = shift;
    my $r = $self->recurse_into or return;
  
    my ($file, @r);
    if (!ref($r) && $r eq 'auto') {
      local *DH;
      opendir DH, $self->base_dir
        or die "Can't scan directory " . $self->base_dir . " for nested builds: $!";
      while (defined($file = readdir DH)) {
        my $subdir = File::Spec->catdir( $self->base_dir, $file );
        next unless -d $subdir;
        push @r, $subdir if -e File::Spec->catfile( $subdir, 'Build.PL' );
      }
    }
  
    $self->recurse_into(\@r);
  }
  
  sub cwd {
    return Cwd::cwd();
  }
  
  sub _quote_args {
    # Returns a string that can become [part of] a command line with
    # proper quoting so that the subprocess sees this same list of args.
    my ($self, @args) = @_;
  
    my @quoted;
  
    for (@args) {
      if ( /^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/ ) {
        # Looks pretty safe
        push @quoted, $_;
      } else {
        # XXX this will obviously have to improve - is there already a
        # core module lying around that does proper quoting?
        s/('+)/'"$1"'/g;
        push @quoted, qq('$_');
      }
    }
  
    return join " ", @quoted;
  }
  
  sub _backticks {
    my ($self, @cmd) = @_;
    if ($self->have_forkpipe) {
      local *FH;
      my $pid = open *FH, "-|";
      if ($pid) {
        return wantarray ? <FH> : join '', <FH>;
      } else {
        die "Can't execute @cmd: $!\n" unless defined $pid;
        exec { $cmd[0] } @cmd;
      }
    } else {
      my $cmd = $self->_quote_args(@cmd);
      return `$cmd`;
    }
  }
  
  # Tells us whether the construct open($fh, '-|', @command) is
  # supported.  It would probably be better to dynamically sense this.
  sub have_forkpipe { 1 }
  
  # Determine whether a given binary is the same as the perl
  # (configuration) that started this process.
  sub _perl_is_same {
    my ($self, $perl) = @_;
  
    my @cmd = ($perl);
  
    # When run from the perl core, @INC will include the directories
    # where perl is yet to be installed. We need to reference the
    # absolute path within the source distribution where it can find
    # it's Config.pm This also prevents us from picking up a Config.pm
    # from a different configuration that happens to be already
    # installed in @INC.
    if ($ENV{PERL_CORE}) {
      push @cmd, '-I' . File::Spec->catdir(File::Basename::dirname($perl), 'lib');
    }
  
    push @cmd, qw(-MConfig=myconfig -e print -e myconfig);
    return $self->_backticks(@cmd) eq Config->myconfig;
  }
  
  # cache _discover_perl_interpreter() results
  {
    my $known_perl;
    sub find_perl_interpreter {
      my $self = shift;
  
      return $known_perl if defined($known_perl);
      return $known_perl = $self->_discover_perl_interpreter;
    }
  }
  
  # Returns the absolute path of the perl interpreter used to invoke
  # this process. The path is derived from $^X or $Config{perlpath}. On
  # some platforms $^X contains the complete absolute path of the
  # interpreter, on other it may contain a relative path, or simply
  # 'perl'. This can also vary depending on whether a path was supplied
  # when perl was invoked. Additionally, the value in $^X may omit the
  # executable extension on platforms that use one. It's a fatal error
  # if the interpreter can't be found because it can result in undefined
  # behavior by routines that depend on it (generating errors or
  # invoking the wrong perl.)
  sub _discover_perl_interpreter {
    my $proto = shift;
    my $c     = ref($proto) ? $proto->{config} : 'Module::Build::Config';
  
    my $perl  = $^X;
    my $perl_basename = File::Basename::basename($perl);
  
    my @potential_perls;
  
    # Try 1, Check $^X for absolute path
    push( @potential_perls, $perl )
        if File::Spec->file_name_is_absolute($perl);
  
    # Try 2, Check $^X for a valid relative path
    my $abs_perl = File::Spec->rel2abs($perl);
    push( @potential_perls, $abs_perl );
  
    # Try 3, Last ditch effort: These two option use hackery to try to locate
    # a suitable perl. The hack varies depending on whether we are running
    # from an installed perl or an uninstalled perl in the perl source dist.
    if ($ENV{PERL_CORE}) {
  
      # Try 3.A, If we are in a perl source tree, running an uninstalled
      # perl, we can keep moving up the directory tree until we find our
      # binary. We wouldn't do this under any other circumstances.
  
      # CBuilder is also in the core, so it should be available here
      require ExtUtils::CBuilder;
      my $perl_src = Cwd::realpath( ExtUtils::CBuilder->perl_src );
      if ( defined($perl_src) && length($perl_src) ) {
        my $uninstperl =
          File::Spec->rel2abs(File::Spec->catfile( $perl_src, $perl_basename ));
        push( @potential_perls, $uninstperl );
      }
  
    } else {
  
      # Try 3.B, First look in $Config{perlpath}, then search the user's
      # PATH. We do not want to do either if we are running from an
      # uninstalled perl in a perl source tree.
  
      push( @potential_perls, $c->get('perlpath') );
  
      push( @potential_perls,
            map File::Spec->catfile($_, $perl_basename), File::Spec->path() );
    }
  
    # Now that we've enumerated the potential perls, it's time to test
    # them to see if any of them match our configuration, returning the
    # absolute path of the first successful match.
    my $exe = $c->get('exe_ext');
    foreach my $thisperl ( @potential_perls ) {
  
      if (defined $exe) {
        $thisperl .= $exe unless $thisperl =~ m/$exe$/i;
      }
  
      if ( -f $thisperl && $proto->_perl_is_same($thisperl) ) {
        return $thisperl;
      }
    }
  
    # We've tried all alternatives, and didn't find a perl that matches
    # our configuration. Throw an exception, and list alternatives we tried.
    my @paths = map File::Basename::dirname($_), @potential_perls;
    die "Can't locate the perl binary used to run this script " .
        "in (@paths)\n";
  }
  
  # Adapted from IPC::Cmd::can_run()
  sub find_command {
    my ($self, $command) = @_;
  
    if( File::Spec->file_name_is_absolute($command) ) {
      return $self->_maybe_command($command);
  
    } else {
      for my $dir ( File::Spec->path ) {
        my $abs = File::Spec->catfile($dir, $command);
        return $abs if $abs = $self->_maybe_command($abs);
      }
    }
  }
  
  # Copied from ExtUtils::MM_Unix::maybe_command
  sub _maybe_command {
    my($self,$file) = @_;
    return $file if -x $file && ! -d $file;
    return;
  }
  
  sub _is_interactive {
    return -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;   # Pipe?
  }
  
  # NOTE this is a blocking operation if(-t STDIN)
  sub _is_unattended {
    my $self = shift;
    return $ENV{PERL_MM_USE_DEFAULT} ||
      ( !$self->_is_interactive && eof STDIN );
  }
  
  sub _readline {
    my $self = shift;
    return undef if $self->_is_unattended;
  
    my $answer = <STDIN>;
    chomp $answer if defined $answer;
    return $answer;
  }
  
  sub prompt {
    my $self = shift;
    my $mess = shift
      or die "prompt() called without a prompt message";
  
    # use a list to distinguish a default of undef() from no default
    my @def;
    @def = (shift) if @_;
    # use dispdef for output
    my @dispdef = scalar(@def) ?
      ('[', (defined($def[0]) ? $def[0] . ' ' : ''), ']') :
      (' ', '');
  
    local $|=1;
    print "$mess ", @dispdef;
  
    if ( $self->_is_unattended && !@def ) {
      die <<EOF;
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
    }
  
    my $ans = $self->_readline();
  
    if ( !defined($ans)        # Ctrl-D or unattended
         or !length($ans) ) {  # User hit return
      print "$dispdef[1]\n";
      $ans = scalar(@def) ? $def[0] : '';
    }
  
    return $ans;
  }
  
  sub y_n {
    my $self = shift;
    my ($mess, $def)  = @_;
  
    die "y_n() called without a prompt message" unless $mess;
    die "Invalid default value: y_n() default must be 'y' or 'n'"
      if $def && $def !~ /^[yn]/i;
  
    my $answer;
    while (1) { # XXX Infinite or a large number followed by an exception ?
      $answer = $self->prompt(@_);
      return 1 if $answer =~ /^y/i;
      return 0 if $answer =~ /^n/i;
      local $|=1;
      print "Please answer 'y' or 'n'.\n";
    }
  }
  
  sub current_action { shift->{action} }
  sub invoked_action { shift->{invoked_action} }
  
  sub notes        { shift()->{phash}{notes}->access(@_) }
  sub config_data  { shift()->{phash}{config_data}->access(@_) }
  sub runtime_params { shift->{phash}{runtime_params}->read( @_ ? shift : () ) }  # Read-only
  sub auto_features  { shift()->{phash}{auto_features}->access(@_) }
  
  sub features     {
    my $self = shift;
    my $ph = $self->{phash};
  
    if (@_) {
      my $key = shift;
      if ($ph->{features}->exists($key)) {
        return $ph->{features}->access($key, @_);
      }
  
      if (my $info = $ph->{auto_features}->access($key)) {
        my $disabled;
        for my $type ( @{$self->prereq_action_types} ) {
          next if $type eq 'description' || $type eq 'recommends' || ! exists $info->{$type};
          my $prereqs = $info->{$type};
          for my $modname ( sort keys %$prereqs ) {
            my $spec = $prereqs->{$modname};
            my $status = $self->check_installed_status($modname, $spec);
            if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
            if ( ! eval "require $modname; 1" ) { return 0; }
          }
        }
        return 1;
      }
  
      return $ph->{features}->access($key, @_);
    }
  
    # No args - get the auto_features & overlay the regular features
    my %features;
    my %auto_features = $ph->{auto_features}->access();
    while (my ($name, $info) = each %auto_features) {
      my $failures = $self->prereq_failures($info);
      my $disabled = grep( /^(?:\w+_)?(?:requires|conflicts)$/,
                          keys %$failures ) ? 1 : 0;
      $features{$name} = $disabled ? 0 : 1;
    }
    %features = (%features, $ph->{features}->access());
  
    return wantarray ? %features : \%features;
  }
  BEGIN { *feature = \&features } # Alias
  
  sub _mb_feature {
    my $self = shift;
  
    if (($self->module_name || '') eq 'Module::Build') {
      # We're building Module::Build itself, so ...::ConfigData isn't
      # valid, but $self->features() should be.
      return $self->feature(@_);
    } else {
      require Module::Build::ConfigData;
      return Module::Build::ConfigData->feature(@_);
    }
  }
  
  sub _warn_mb_feature_deps {
    my $self = shift;
    my $name = shift;
    $self->log_warn(
      "The '$name' feature is not available.  Please install missing\n" .
      "feature dependencies and try again.\n".
      $self->_feature_deps_msg($name) . "\n"
    );
  }
  
  sub add_build_element {
      my ($self, $elem) = @_;
      my $elems = $self->build_elements;
      push @$elems, $elem unless grep { $_ eq $elem } @$elems;
  }
  
  sub ACTION_config_data {
    my $self = shift;
    return unless $self->has_config_data;
  
    my $module_name = $self->module_name
      or die "The config_data feature requires that 'module_name' be set";
    my $notes_name = $module_name . '::ConfigData'; # TODO: Customize name ???
    my $notes_pm = File::Spec->catfile($self->blib, 'lib', split /::/, "$notes_name.pm");
  
    return if $self->up_to_date(['Build.PL',
                                 $self->config_file('config_data'),
                                 $self->config_file('features')
                                ], $notes_pm);
  
    $self->log_verbose("Writing config notes to $notes_pm\n");
    File::Path::mkpath(File::Basename::dirname($notes_pm));
  
    Module::Build::Notes->write_config_data
      (
       file => $notes_pm,
       module => $module_name,
       config_module => $notes_name,
       config_data => scalar $self->config_data,
       feature => scalar $self->{phash}{features}->access(),
       auto_features => scalar $self->auto_features,
      );
  }
  
  ########################################################################
  { # enclosing these lexicals -- TODO
    my %valid_properties = ( __PACKAGE__,  {} );
    my %additive_properties;
  
    sub _mb_classes {
      my $class = ref($_[0]) || $_[0];
      return ($class, $class->mb_parents);
    }
  
    sub valid_property {
      my ($class, $prop) = @_;
      return grep exists( $valid_properties{$_}{$prop} ), $class->_mb_classes;
    }
  
    sub valid_properties {
      return keys %{ shift->valid_properties_defaults() };
    }
  
    sub valid_properties_defaults {
      my %out;
      for my $class (reverse shift->_mb_classes) {
        @out{ keys %{ $valid_properties{$class} } } = map {
          $_->()
        } values %{ $valid_properties{$class} };
      }
      return \%out;
    }
  
    sub array_properties {
      map { exists $additive_properties{$_}->{ARRAY} ? @{$additive_properties{$_}->{ARRAY}} : () } shift->_mb_classes;
    }
  
    sub hash_properties {
      map { exists $additive_properties{$_}->{HASH} ? @{$additive_properties{$_}->{HASH}} : () } shift->_mb_classes;
    }
  
    sub add_property {
      my ($class, $property) = (shift, shift);
      die "Property '$property' already exists"
        if $class->valid_property($property);
      my %p = @_ == 1 ? ( default => shift ) : @_;
  
      my $type = ref $p{default};
      $valid_properties{$class}{$property} =
        $type eq 'CODE' ? $p{default}                           :
        $type eq 'HASH' ? sub { return { %{ $p{default} } }   } :
        $type eq 'ARRAY'? sub { return [ @{ $p{default} } ]   } :
                          sub { return $p{default}            } ;
  
      push @{$additive_properties{$class}->{$type}}, $property
        if $type;
  
      unless ($class->can($property)) {
        # TODO probably should put these in a util package
        my $sub = $type eq 'HASH'
          ? _make_hash_accessor($property, \%p)
          : _make_accessor($property, \%p);
        no strict 'refs';
        *{"$class\::$property"} = $sub;
      }
  
      return $class;
    }
  
    sub property_error {
      my $self = shift;
      die 'ERROR: ', @_;
    }
  
    sub _set_defaults {
      my $self = shift;
  
      # Set the build class.
      $self->{properties}{build_class} ||= ref $self;
  
      # If there was no orig_dir, set to the same as base_dir
      $self->{properties}{orig_dir} ||= $self->{properties}{base_dir};
  
      my $defaults = $self->valid_properties_defaults;
  
      foreach my $prop (keys %$defaults) {
        $self->{properties}{$prop} = $defaults->{$prop}
          unless exists $self->{properties}{$prop};
      }
  
      # Copy defaults for arrays any arrays.
      for my $prop ($self->array_properties) {
        $self->{properties}{$prop} = [@{$defaults->{$prop}}]
          unless exists $self->{properties}{$prop};
      }
      # Copy defaults for arrays any hashes.
      for my $prop ($self->hash_properties) {
        $self->{properties}{$prop} = {%{$defaults->{$prop}}}
          unless exists $self->{properties}{$prop};
      }
    }
  
  } # end enclosure
  ########################################################################
  sub _make_hash_accessor {
    my ($property, $p) = @_;
    my $check = $p->{check} || sub { 1 };
  
    return sub {
      my $self = shift;
  
      # This is only here to deprecate the historic accident of calling
      # properties as class methods - I suspect it only happens in our
      # test suite.
      unless(ref($self)) {
        carp("\n$property not a class method (@_)");
        return;
      }
  
      my $x = $self->{properties};
      return $x->{$property} unless @_;
  
      my $prop = $x->{$property};
      if ( defined $_[0] && !ref $_[0] ) {
        if ( @_ == 1 ) {
          return exists $prop->{$_[0]} ? $prop->{$_[0]} : undef;
        } elsif ( @_ % 2 == 0 ) {
          my %new = (%{ $prop }, @_);
          local $_ = \%new;
          $x->{$property} = \%new if $check->($self);
          return $x->{$property};
        } else {
          die "Unexpected arguments for property '$property'\n";
        }
      } else {
        die "Unexpected arguments for property '$property'\n"
            if defined $_[0] && ref $_[0] ne 'HASH';
        local $_ = $_[0];
        $x->{$property} = shift if $check->($self);
      }
    };
  }
  ########################################################################
  sub _make_accessor {
    my ($property, $p) = @_;
    my $check = $p->{check} || sub { 1 };
  
    return sub {
      my $self = shift;
  
      # This is only here to deprecate the historic accident of calling
      # properties as class methods - I suspect it only happens in our
      # test suite.
      unless(ref($self)) {
        carp("\n$property not a class method (@_)");
        return;
      }
  
      my $x = $self->{properties};
      return $x->{$property} unless @_;
      local $_ = $_[0];
      $x->{$property} = shift if $check->($self);
      return $x->{$property};
    };
  }
  ########################################################################
  
  # Add the default properties.
  __PACKAGE__->add_property(auto_configure_requires => 1);
  __PACKAGE__->add_property(blib => 'blib');
  __PACKAGE__->add_property(build_class => 'Module::Build');
  __PACKAGE__->add_property(build_elements => [qw(PL support pm xs share_dir pod script)]);
  __PACKAGE__->add_property(build_script => 'Build');
  __PACKAGE__->add_property(build_bat => 0);
  __PACKAGE__->add_property(bundle_inc => []);
  __PACKAGE__->add_property(bundle_inc_preload => []);
  __PACKAGE__->add_property(config_dir => '_build');
  __PACKAGE__->add_property(dynamic_config => 1);
  __PACKAGE__->add_property(include_dirs => []);
  __PACKAGE__->add_property(license => 'unknown');
  __PACKAGE__->add_property(metafile => 'META.yml');
  __PACKAGE__->add_property(mymetafile => 'MYMETA.yml');
  __PACKAGE__->add_property(metafile2 => 'META.json');
  __PACKAGE__->add_property(mymetafile2 => 'MYMETA.json');
  __PACKAGE__->add_property(recurse_into => []);
  __PACKAGE__->add_property(use_rcfile => 1);
  __PACKAGE__->add_property(create_packlist => 1);
  __PACKAGE__->add_property(allow_mb_mismatch => 0);
  __PACKAGE__->add_property(config => undef);
  __PACKAGE__->add_property(test_file_exts => ['.t']);
  __PACKAGE__->add_property(use_tap_harness => 0);
  __PACKAGE__->add_property(cpan_client => 'cpan');
  __PACKAGE__->add_property(tap_harness_args => {});
  __PACKAGE__->add_property(pureperl_only => 0);
  __PACKAGE__->add_property(allow_pureperl => 0);
  __PACKAGE__->add_property(
    'installdirs',
    default => 'site',
    check   => sub {
      return 1 if /^(core|site|vendor)$/;
      return shift->property_error(
        $_ eq 'perl'
        ? 'Perhaps you meant installdirs to be "core" rather than "perl"?'
        : 'installdirs must be one of "core", "site", or "vendor"'
      );
      return shift->property_error("Perhaps you meant 'core'?") if $_ eq 'perl';
      return 0;
    },
  );
  
  {
    __PACKAGE__->add_property(html_css => '');
  }
  
  {
    my @prereq_action_types = qw(requires build_requires test_requires conflicts recommends);
    foreach my $type (@prereq_action_types) {
      __PACKAGE__->add_property($type => {});
    }
    __PACKAGE__->add_property(prereq_action_types => \@prereq_action_types);
  }
  
  __PACKAGE__->add_property($_ => {}) for qw(
    get_options
    install_base_relpaths
    install_path
    install_sets
    meta_add
    meta_merge
    original_prefix
    prefix_relpaths
    configure_requires
  );
  
  __PACKAGE__->add_property($_) for qw(
    PL_files
    autosplit
    base_dir
    bindoc_dirs
    c_source
    cover
    create_license
    create_makefile_pl
    create_readme
    debugger
    destdir
    dist_abstract
    dist_author
    dist_name
    dist_suffix
    dist_version
    dist_version_from
    extra_compiler_flags
    extra_linker_flags
    has_config_data
    install_base
    libdoc_dirs
    magic_number
    mb_version
    module_name
    needs_compiler
    orig_dir
    perl
    pm_files
    pod_files
    pollute
    prefix
    program_name
    quiet
    recursive_test_files
    release_status
    script_files
    scripts
    share_dir
    sign
    test_files
    verbose
    debug
    xs_files
    extra_manify_args
  );
  
  sub config {
    my $self = shift;
    my $c = ref($self) ? $self->{config} : 'Module::Build::Config';
    return $c->all_config unless @_;
  
    my $key = shift;
    return $c->get($key) unless @_;
  
    my $val = shift;
    return $c->set($key => $val);
  }
  
  sub mb_parents {
      # Code borrowed from Class::ISA.
      my @in_stack = (shift);
      my %seen = ($in_stack[0] => 1);
  
      my ($current, @out);
      while (@in_stack) {
          next unless defined($current = shift @in_stack)
            && $current->isa('Module::Build::Base');
          push @out, $current;
          next if $current eq 'Module::Build::Base';
          no strict 'refs';
          unshift @in_stack,
            map {
                my $c = $_; # copy, to avoid being destructive
                substr($c,0,2) = "main::" if substr($c,0,2) eq '::';
                # Canonize the :: -> main::, ::foo -> main::foo thing.
                # Should I ever canonize the Foo'Bar = Foo::Bar thing?
                $seen{$c}++ ? () : $c;
            } @{"$current\::ISA"};
  
          # I.e., if this class has any parents (at least, ones I've never seen
          # before), push them, in order, onto the stack of classes I need to
          # explore.
      }
      shift @out;
      return @out;
  }
  
  sub extra_linker_flags   { shift->_list_accessor('extra_linker_flags',   @_) }
  sub extra_compiler_flags { shift->_list_accessor('extra_compiler_flags', @_) }
  
  sub _list_accessor {
    (my $self, local $_) = (shift, shift);
    my $p = $self->{properties};
    $p->{$_} = [@_] if @_;
    $p->{$_} = [] unless exists $p->{$_};
    return ref($p->{$_}) ? $p->{$_} : [$p->{$_}];
  }
  
  # XXX Problem - if Module::Build is loaded from a different directory,
  # it'll look for (and perhaps destroy/create) a _build directory.
  sub subclass {
    my ($pack, %opts) = @_;
  
    my $build_dir = '_build'; # XXX The _build directory is ostensibly settable by the user.  Shouldn't hard-code here.
    $pack->delete_filetree($build_dir) if -e $build_dir;
  
    die "Must provide 'code' or 'class' option to subclass()\n"
      unless $opts{code} or $opts{class};
  
    $opts{code}  ||= '';
    $opts{class} ||= 'MyModuleBuilder';
  
    my $filename = File::Spec->catfile($build_dir, 'lib', split '::', $opts{class}) . '.pm';
    my $filedir  = File::Basename::dirname($filename);
    $pack->log_verbose("Creating custom builder $filename in $filedir\n");
  
    File::Path::mkpath($filedir);
    die "Can't create directory $filedir: $!" unless -d $filedir;
  
    open(my $fh, '>', $filename) or die "Can't create $filename: $!";
    print $fh <<EOF;
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
    close $fh;
  
    unshift @INC, File::Spec->catdir(File::Spec->rel2abs($build_dir), 'lib');
    eval "use $opts{class}";
    die $@ if $@;
  
    return $opts{class};
  }
  
  sub _guess_module_name {
    my $self = shift;
    my $p = $self->{properties};
    return if $p->{module_name};
    if ( $p->{dist_version_from} && -e $p->{dist_version_from} ) {
      my $mi = Module::Metadata->new_from_file($self->dist_version_from);
      $p->{module_name} = $mi->name;
    }
    else {
      my $mod_path = my $mod_name = $p->{dist_name};
      $mod_name =~ s{-}{::}g;
      $mod_path =~ s{-}{/}g;
      $mod_path .= ".pm";
      if ( -e $mod_path || -e "lib/$mod_path" ) {
        $p->{module_name} = $mod_name;
      }
      else {
        $self->log_warn( << 'END_WARN' );
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
      }
    }
  }
  
  sub dist_name {
    my $self = shift;
    my $p = $self->{properties};
    my $me = 'dist_name';
    return $p->{$me} if defined $p->{$me};
  
    die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter"
      unless $self->module_name;
  
    ($p->{$me} = $self->module_name) =~ s/::/-/g;
  
    return $p->{$me};
  }
  
  sub release_status {
    my ($self) = @_;
    my $me = 'release_status';
    my $p = $self->{properties};
  
    if ( ! defined $p->{$me} ) {
      $p->{$me} = $self->_is_dev_version ? 'testing' : 'stable';
    }
  
    unless ( $p->{$me} =~ qr/\A(?:stable|testing|unstable)\z/ ) {
      die "Illegal value '$p->{$me}' for $me\n";
    }
  
    if ( $p->{$me} eq 'stable' && $self->_is_dev_version ) {
      my $version = $self->dist_version;
      die "Illegal value '$p->{$me}' with version '$version'\n";
    }
    return $p->{$me};
  }
  
  sub dist_suffix {
    my ($self) = @_;
    my $p = $self->{properties};
    my $me = 'dist_suffix';
  
    return $p->{$me} if defined $p->{$me};
  
    if ( $self->release_status eq 'stable' ) {
      $p->{$me} = "";
    }
    else {
      # non-stable release but non-dev version number needs '-TRIAL' appended
      $p->{$me} = $self->_is_dev_version ? "" : "TRIAL" ;
    }
  
    return $p->{$me};
  }
  
  sub dist_version_from {
    my ($self) = @_;
    my $p = $self->{properties};
    my $me = 'dist_version_from';
  
    if ($self->module_name) {
      $p->{$me} ||=
        join( '/', 'lib', split(/::/, $self->module_name) ) . '.pm';
    }
    return $p->{$me} || undef;
  }
  
  sub dist_version {
    my ($self) = @_;
    my $p = $self->{properties};
    my $me = 'dist_version';
  
    return $p->{$me} if defined $p->{$me};
  
    if ( my $dist_version_from = $self->dist_version_from ) {
      my $version_from = File::Spec->catfile( split( qr{/}, $dist_version_from ) );
      my $pm_info = Module::Metadata->new_from_file( $version_from )
        or die "Can't find file $version_from to determine version";
      #$p->{$me} is undef here
      $p->{$me} = $self->normalize_version( $pm_info->version() );
      unless (defined $p->{$me}) {
        die "Can't determine distribution version from $version_from";
      }
    }
  
    die ("Can't determine distribution version, must supply either 'dist_version',\n".
         "'dist_version_from', or 'module_name' parameter")
      unless defined $p->{$me};
  
    return $p->{$me};
  }
  
  sub _is_dev_version {
    my ($self) = @_;
    my $dist_version = $self->dist_version;
    my $version_obj = eval { version->new( $dist_version ) };
    # assume it's normal if the version string is fatal -- in this case
    # the author might be doing something weird so should play along and
    # assume they'll specify all necessary behavior
    return $@ ? 0 : $version_obj->is_alpha;
  }
  
  sub dist_author   { shift->_pod_parse('author')   }
  sub dist_abstract { shift->_pod_parse('abstract') }
  
  sub _pod_parse {
    my ($self, $part) = @_;
    my $p = $self->{properties};
    my $member = "dist_$part";
    return $p->{$member} if defined $p->{$member};
  
    my $docfile = $self->_main_docfile
      or return;
    open(my $fh, '<', $docfile)
      or return;
  
    require Module::Build::PodParser;
    my $parser = Module::Build::PodParser->new(fh => $fh);
    my $method = "get_$part";
    return $p->{$member} = $parser->$method();
  }
  
  sub version_from_file { # Method provided for backwards compatibility
    return Module::Metadata->new_from_file($_[1])->version();
  }
  
  sub find_module_by_name { # Method provided for backwards compatibility
    return Module::Metadata->find_module_by_name(@_[1,2]);
  }
  
  {
    # $unlink_list_for_pid{$$} = [ ... ]
    my %unlink_list_for_pid;
  
    sub _unlink_on_exit {
      my $self = shift;
      for my $f ( @_ ) {
        push @{$unlink_list_for_pid{$$}}, $f if -f $f;
      }
      return 1;
    }
  
    END {
      for my $f ( map glob($_), @{ $unlink_list_for_pid{$$} || [] } ) {
        next unless -e $f;
        File::Path::rmtree($f, 0, 0);
      }
    }
  }
  
  sub add_to_cleanup {
    my $self = shift;
    my %files = map {$self->localize_file_path($_), 1} @_;
    $self->{phash}{cleanup}->write(\%files);
  }
  
  sub cleanup {
    my $self = shift;
    my $all = $self->{phash}{cleanup}->read;
    return wantarray ? sort keys %$all : keys %$all;
  }
  
  sub config_file {
    my $self = shift;
    return unless -d $self->config_dir;
    return File::Spec->catfile($self->config_dir, @_);
  }
  
  sub read_config {
    my ($self) = @_;
  
    my $file = $self->config_file('build_params')
      or die "Can't find 'build_params' in " . $self->config_dir;
    open(my $fh, '<', $file) or die "Can't read '$file': $!";
    my $ref = eval do {local $/; <$fh>};
    die if $@;
    close $fh;
    my $c;
    ($self->{args}, $c, $self->{properties}) = @$ref;
    $self->{config} = Module::Build::Config->new(values => $c);
  }
  
  sub has_config_data {
    my $self = shift;
    return scalar grep $self->{phash}{$_}->has_data(), qw(config_data features auto_features);
  }
  
  sub _write_data {
    my ($self, $filename, $data) = @_;
  
    my $file = $self->config_file($filename);
    open(my $fh, '>', $file) or die "Can't create '$file': $!";
    unless (ref($data)) {  # e.g. magicnum
      print $fh $data;
      return;
    }
  
    print {$fh} Module::Build::Dumper->_data_dump($data);
    close $fh;
  }
  
  sub write_config {
    my ($self) = @_;
  
    File::Path::mkpath($self->{properties}{config_dir});
    -d $self->{properties}{config_dir} or die "Can't mkdir $self->{properties}{config_dir}: $!";
  
    my @items = @{ $self->prereq_action_types };
    $self->_write_data('prereqs', { map { $_, $self->$_() } @items });
    $self->_write_data('build_params', [$self->{args}, $self->{config}->values_set, $self->{properties}]);
  
    # Set a new magic number and write it to a file
    $self->_write_data('magicnum', $self->magic_number(int rand 1_000_000));
  
    $self->{phash}{$_}->write() foreach qw(notes cleanup features auto_features config_data runtime_params);
  }
  
  {
    # packfile map -- keys are guts of regular expressions;  If they match,
    # values are module names corresponding to the packlist
    my %packlist_map = (
      '^File::Spec'         => 'Cwd',
      '^Devel::AssertOS'    => 'Devel::CheckOS',
    );
  
    sub _find_packlist {
      my ($self, $inst, $mod) = @_;
      my $lookup = $mod;
      my $packlist = eval { $inst->packlist($lookup) };
      if ( ! $packlist ) {
        # try from packlist_map
        while ( my ($re, $new_mod) = each %packlist_map ) {
          if ( $mod =~ qr/$re/ ) {
            $lookup = $new_mod;
            $packlist = eval { $inst->packlist($lookup) };
            last;
          }
        }
      }
      return $packlist ? $lookup : undef;
    }
  
    sub set_bundle_inc {
      my $self = shift;
  
      my $bundle_inc = $self->{properties}{bundle_inc};
      my $bundle_inc_preload = $self->{properties}{bundle_inc_preload};
      # We're in author mode if inc::latest is loaded, but not from cwd
      return unless inc::latest->can('loaded_modules');
      require ExtUtils::Installed;
      # ExtUtils::Installed is buggy about finding additions to default @INC
      my $inst = eval { ExtUtils::Installed->new(extra_libs => [@INC]) };
      if ($@) {
        $self->log_warn( << "EUI_ERROR" );
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
        return;
      }
      my @bundle_list = map { [ $_, 0 ] } inc::latest->loaded_modules;
  
      # XXX TODO: Need to get ordering of prerequisites correct so they are
      # are loaded in the right order. Use an actual tree?!
  
      while( @bundle_list ) {
        my ($mod, $prereq) = @{ shift @bundle_list };
  
        # XXX TODO: Append prereqs to list
        # skip if core or already in bundle or preload lists
        # push @bundle_list, [$_, 1] for prereqs()
  
        # Locate packlist for bundling
        my $lookup = $self->_find_packlist($inst,$mod);
        if ( ! $lookup ) {
          # XXX Really needs a more helpful error message here
          die << "NO_PACKLIST";
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
        }
        else {
          push @{ $prereq ? $bundle_inc_preload : $bundle_inc }, $lookup;
        }
      }
    } # sub check_bundling
  }
  
  sub check_autofeatures {
    my ($self) = @_;
    my $features = $self->auto_features;
  
    return 1 unless %$features;
  
    # TODO refactor into ::Util
    my $longest = sub {
      my @str = @_ or croak("no strings given");
  
      my @len = map({length($_)} @str);
      my $max = 0;
      my $longest;
      for my $i (0..$#len) {
        ($max, $longest) = ($len[$i], $str[$i]) if($len[$i] > $max);
      }
      return($longest);
    };
    my $max_name_len = length($longest->(keys %$features));
  
    my ($num_disabled, $log_text) = (0, "\nChecking optional features...\n");
    for my $name ( sort keys %$features ) {
      $log_text .= $self->_feature_deps_msg($name, $max_name_len);
    }
  
    $num_disabled = () = $log_text =~ /disabled/g;
  
    # warn user if features disabled
    if ( $num_disabled ) {
      $self->log_warn( $log_text );
      return 0;
    }
    else {
      $self->log_verbose( $log_text );
      return 1;
    }
  }
  
  sub _feature_deps_msg {
    my ($self, $name, $max_name_len) = @_;
      $max_name_len ||= length $name;
      my $features = $self->auto_features;
      my $info = $features->{$name};
      my $feature_text = "$name" . '.' x ($max_name_len - length($name) + 4);
  
      my ($log_text, $disabled) = ('','');
      if ( my $failures = $self->prereq_failures($info) ) {
        $disabled = grep( /^(?:\w+_)?(?:requires|conflicts)$/,
                    keys %$failures ) ? 1 : 0;
        $feature_text .= $disabled ? "disabled\n" : "enabled\n";
  
        for my $type ( @{ $self->prereq_action_types } ) {
          next unless exists $failures->{$type};
          $feature_text .= "  $type:\n";
          my $prereqs = $failures->{$type};
          for my $module ( sort keys %$prereqs ) {
            my $status = $prereqs->{$module};
            my $required =
              ($type =~ /^(?:\w+_)?(?:requires|conflicts)$/) ? 1 : 0;
            my $prefix = ($required) ? '!' : '*';
            $feature_text .= "    $prefix $status->{message}\n";
          }
        }
      } else {
        $feature_text .= "enabled\n";
      }
      $log_text .= $feature_text if $disabled || $self->verbose;
      return $log_text;
  }
  
  # Automatically detect configure_requires prereqs
  sub auto_config_requires {
    my ($self) = @_;
    my $p = $self->{properties};
  
    # add current Module::Build to configure_requires if there
    # isn't one already specified (but not ourself, so we're not circular)
    if ( $self->dist_name ne 'Module-Build'
      && $self->auto_configure_requires
      && ! exists $p->{configure_requires}{'Module::Build'}
    ) {
      (my $ver = $VERSION) =~ s/^(\d+\.\d\d).*$/$1/; # last major release only
      $self->log_warn(<<EOM);
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
      $self->_add_prereq('configure_requires', 'Module::Build', $ver);
    }
  
    # if we're in author mode, add inc::latest modules to
    # configure_requires if not already set.  If we're not in author mode
    # then configure_requires will have been satisfied, or we'll just
    # live with what we've bundled
    if ( inc::latest->can('loaded_module') ) {
      for my $mod ( inc::latest->loaded_modules ) {
        next if exists $p->{configure_requires}{$mod};
        $self->_add_prereq('configure_requires', $mod, $mod->VERSION);
      }
    }
  
    return;
  }
  
  # Automatically detect and add prerequisites based on configuration
  sub auto_require {
    my ($self) = @_;
    my $p = $self->{properties};
  
    # If needs_compiler is not explicitly set, automatically set it
    # If set, we need ExtUtils::CBuilder (and a compiler)
    my $xs_files = $self->find_xs_files;
    if ( ! defined $p->{needs_compiler} ) {
      $self->needs_compiler( keys %$xs_files || defined $self->c_source );
    }
    if ($self->needs_compiler) {
      $self->_add_prereq('build_requires', 'ExtUtils::CBuilder', 0);
      if ( ! $self->have_c_compiler ) {
        $self->log_warn(<<'EOM');
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      }
    }
  
    # If using share_dir, require File::ShareDir
    if ( $self->share_dir ) {
      $self->_add_prereq( 'requires', 'File::ShareDir', '1.00' );
    }
  
    return;
  }
  
  sub _add_prereq {
    my ($self, $type, $module, $version) = @_;
    my $p = $self->{properties};
    $version = 0 unless defined $version;
    if ( exists $p->{$type}{$module} ) {
      return if $self->compare_versions( $version, '<=', $p->{$type}{$module} );
    }
    $self->log_verbose("Adding to $type\: $module => $version\n");
    $p->{$type}{$module} = $version;
    return 1;
  }
  
  sub prereq_failures {
    my ($self, $info) = @_;
  
    my @types = @{ $self->prereq_action_types };
    $info ||= {map {$_, $self->$_()} @types};
  
    my $out;
  
    foreach my $type (@types) {
      my $prereqs = $info->{$type};
      for my $modname ( keys %$prereqs ) {
        my $spec = $prereqs->{$modname};
        my $status = $self->check_installed_status($modname, $spec);
  
        if ($type =~ /^(?:\w+_)?conflicts$/) {
          next if !$status->{ok};
          $status->{conflicts} = delete $status->{need};
          $status->{message} = "$modname ($status->{have}) conflicts with this distribution";
  
        } elsif ($type =~ /^(?:\w+_)?recommends$/) {
          next if $status->{ok};
          $status->{message} = (!ref($status->{have}) && $status->{have} eq '<none>'
                                ? "$modname is not installed"
                                : "$modname ($status->{have}) is installed, but we prefer to have $spec");
        } else {
          next if $status->{ok};
        }
  
        $out->{$type}{$modname} = $status;
      }
    }
  
    return $out;
  }
  
  # returns a hash of defined prerequisites; i.e. only prereq types with values
  sub _enum_prereqs {
    my $self = shift;
    my %prereqs;
    foreach my $type ( @{ $self->prereq_action_types } ) {
      if ( $self->can( $type ) ) {
        my $prereq = $self->$type() || {};
        $prereqs{$type} = $prereq if %$prereq;
      }
    }
    return \%prereqs;
  }
  
  sub check_prereq {
    my $self = shift;
  
    # Check to see if there are any prereqs to check
    my $info = $self->_enum_prereqs;
    return 1 unless $info;
  
    my $log_text = "Checking prerequisites...\n";
  
    my $failures = $self->prereq_failures($info);
  
    if ( $failures ) {
      $self->log_warn($log_text);
      for my $type ( @{ $self->prereq_action_types } ) {
        my $prereqs = $failures->{$type};
        $self->log_warn("  ${type}:\n") if keys %$prereqs;
        for my $module ( sort keys %$prereqs ) {
          my $status = $prereqs->{$module};
          my $prefix = ($type =~ /^(?:\w+_)?recommends$/) ? "* " : "! ";
          $self->log_warn("    $prefix $status->{message}\n");
        }
      }
      return 0;
    } else {
      $self->log_verbose($log_text . "Looks good\n\n");
      return 1;
    }
  }
  
  sub perl_version {
    my ($self) = @_;
    # Check the current perl interpreter
    # It's much more convenient to use $] here than $^V, but 'man
    # perlvar' says I'm not supposed to.  Bloody tyrant.
    return $^V ? $self->perl_version_to_float(sprintf "%vd", $^V) : $];
  }
  
  sub perl_version_to_float {
    my ($self, $version) = @_;
    return $version if grep( /\./, $version ) < 2;
    $version =~ s/\./../;
    $version =~ s/\.(\d+)/sprintf '%03d', $1/eg;
    return $version;
  }
  
  sub _parse_conditions {
    my ($self, $spec) = @_;
  
    return ">= 0" if not defined $spec;
    if ($spec =~ /^\s*([\w.]+)\s*$/) { # A plain number, maybe with dots, letters, and underscores
      return (">= $spec");
    } else {
      return split /\s*,\s*/, $spec;
    }
  }
  
  sub try_require {
    my ($self, $modname, $spec) = @_;
    my $status = $self->check_installed_status($modname, defined($spec) ? $spec : 0);
    return unless $status->{ok};
    my $path = $modname;
    $path =~ s{::}{/}g;
    $path .= ".pm";
    if ( defined $INC{$path} ) {
      return 1;
    }
    elsif ( exists $INC{$path} ) { # failed before, don't try again
      return;
    }
    else {
      return eval "require $modname";
    }
  }
  
  sub check_installed_status {
    my ($self, $modname, $spec) = @_;
    my %status = (need => $spec);
  
    if ($modname eq 'perl') {
      $status{have} = $self->perl_version;
  
    } elsif (eval { no strict; $status{have} = ${"${modname}::VERSION"} }) {
      # Don't try to load if it's already loaded
  
    } else {
      my $pm_info = Module::Metadata->new_from_module( $modname );
      unless (defined( $pm_info )) {
        @status{ qw(have message) } = ('<none>', "$modname is not installed");
        return \%status;
      }
  
      $status{have} = eval { $pm_info->version() };
      if ($spec and !defined($status{have})) {
        @status{ qw(have message) } = (undef, "Couldn't find a \$VERSION in prerequisite $modname");
        return \%status;
      }
    }
  
    my @conditions = $self->_parse_conditions($spec);
  
    foreach (@conditions) {
      my ($op, $version) = /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x
        or die "Invalid prerequisite condition '$_' for $modname";
  
      $version = $self->perl_version_to_float($version)
        if $modname eq 'perl';
  
      next if $op eq '>=' and !$version;  # Module doesn't have to actually define a $VERSION
  
      unless ($self->compare_versions( $status{have}, $op, $version )) {
        $status{message} = "$modname ($status{have}) is installed, but we need version $op $version";
        return \%status;
      }
    }
  
    $status{ok} = 1;
    return \%status;
  }
  
  sub compare_versions {
    my $self = shift;
    my ($v1, $op, $v2) = @_;
    $v1 = version->new($v1)
      unless eval { $v1->isa('version') };
  
    my $eval_str = "\$v1 $op \$v2";
    my $result   = eval $eval_str;
    $self->log_warn("error comparing versions: '$eval_str' $@") if $@;
  
    return $result;
  }
  
  # I wish I could set $! to a string, but I can't, so I use $@
  sub check_installed_version {
    my ($self, $modname, $spec) = @_;
  
    my $status = $self->check_installed_status($modname, $spec);
  
    if ($status->{ok}) {
      return $status->{have} if $status->{have} and "$status->{have}" ne '<none>';
      return '0 but true';
    }
  
    $@ = $status->{message};
    return 0;
  }
  
  sub make_executable {
    # Perl's chmod() is mapped to useful things on various non-Unix
    # platforms, so we use it in the base class even though it looks
    # Unixish.
  
    my $self = shift;
    foreach (@_) {
      my $current_mode = (stat $_)[2];
      chmod $current_mode | oct(111), $_;
    }
  }
  
  sub is_executable {
    # We assume this does the right thing on generic platforms, though
    # we do some other more specific stuff on Unixish platforms.
    my ($self, $file) = @_;
    return -x $file;
  }
  
  sub _startperl { shift()->config('startperl') }
  
  # Return any directories in @INC which are not in the default @INC for
  # this perl.  For example, stuff passed in with -I or loaded with "use lib".
  sub _added_to_INC {
    my $self = shift;
  
    my %seen;
    $seen{$_}++ foreach $self->_default_INC;
    return grep !$seen{$_}++, @INC;
  }
  
  # Determine the default @INC for this Perl
  {
    my @default_inc; # Memoize
    sub _default_INC {
      my $self = shift;
      return @default_inc if @default_inc;
  
      local $ENV{PERL5LIB};  # this is not considered part of the default.
  
      my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
  
      my @inc = $self->_backticks($perl, '-le', 'print for @INC');
      chomp @inc;
  
      return @default_inc = @inc;
    }
  }
  
  sub print_build_script {
    my ($self, $fh) = @_;
  
    my $build_package = $self->build_class;
  
    my $closedata="";
  
    my $config_requires;
    if ( -f $self->metafile ) {
      my $meta = eval { $self->read_metafile( $self->metafile ) };
      $config_requires = $meta && $meta->{prereqs}{configure}{requires}{'Module::Build'};
    }
    $config_requires ||= 0;
  
    my %q = map {$_, $self->$_()} qw(config_dir base_dir);
  
    $q{base_dir} = Win32::GetShortPathName($q{base_dir}) if $self->is_windowsish;
  
    $q{magic_numfile} = $self->config_file('magicnum');
  
    my @myINC = $self->_added_to_INC;
    for (@myINC, values %q) {
      $_ = File::Spec->canonpath( $_ ) unless $self->is_vmsish;
      s/([\\\'])/\\$1/g;
    }
  
    my $quoted_INC = join ",\n", map "     '$_'", @myINC;
    my $shebang = $self->_startperl;
    my $magic_number = $self->magic_number;
  
  my $dot_in_inc_code = $INC[-1] eq '.' ? <<'END' : '';
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
    print $fh <<EOF;
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  }
  
  sub create_mymeta {
    my ($self) = @_;
  
    my ($meta_obj, $mymeta);
    my @metafiles = ( $self->metafile2, $self->metafile,  );
    my @mymetafiles = ( $self->mymetafile2, $self->mymetafile, );
  
    # cleanup old MYMETA
    for my $f ( @mymetafiles ) {
      if ( $self->delete_filetree($f) ) {
        $self->log_verbose("Removed previous '$f'\n");
      }
    }
  
    # Try loading META.json or META.yml
    if ( $self->try_require("CPAN::Meta", "2.142060") ) {
      for my $file ( @metafiles ) {
        next unless -f $file;
        $meta_obj = eval { CPAN::Meta->load_file($file, { lazy_validation => 0 }) };
        last if $meta_obj;
      }
    }
  
    # maybe get a copy in spec v2 format (regardless of original source)
  
    my $mymeta_obj;
    if ($meta_obj) {
      # if we have metadata, just update it
      my %updated = (
        %{ $meta_obj->as_struct({ version => 2.0 }) },
        prereqs => $self->_normalize_prereqs,
        dynamic_config => 0,
        generated_by => "Module::Build version $Module::Build::VERSION",
      );
      $mymeta_obj = CPAN::Meta->new( \%updated, { lazy_validation => 0 } );
    }
    else {
      $mymeta_obj = $self->_get_meta_object(quiet => 0, dynamic => 0, fatal => 1, auto => 0);
    }
  
    my @created = $self->_write_meta_files( $mymeta_obj, 'MYMETA' );
  
    $self->log_warn("Could not create MYMETA files\n")
      unless @created;
  
    return 1;
  }
  
  sub create_build_script {
    my ($self) = @_;
  
    $self->write_config;
    $self->create_mymeta;
  
    # Create Build
    my ($build_script, $dist_name, $dist_version)
      = map $self->$_(), qw(build_script dist_name dist_version);
  
    if ( $self->delete_filetree($build_script) ) {
      $self->log_verbose("Removed previous script '$build_script'\n");
    }
  
    $self->log_info("Creating new '$build_script' script for ",
                    "'$dist_name' version '$dist_version'\n");
    open(my $fh, '>', $build_script) or die "Can't create '$build_script': $!";
    $self->print_build_script($fh);
    close $fh;
  
    $self->make_executable($build_script);
  
    return 1;
  }
  
  sub check_manifest {
    my $self = shift;
    return unless -e 'MANIFEST';
  
    # Stolen nearly verbatim from MakeMaker.  But ExtUtils::Manifest
    # could easily be re-written into a modern Perl dialect.
  
    require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
    local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
  
    $self->log_verbose("Checking whether your kit is complete...\n");
    if (my @missed = ExtUtils::Manifest::manicheck()) {
      $self->log_warn("WARNING: the following files are missing in your kit:\n",
                      "\t", join("\n\t", @missed), "\n",
                      "Please inform the author.\n\n");
    } else {
      $self->log_verbose("Looks good\n\n");
    }
  }
  
  sub dispatch {
    my $self = shift;
    local $self->{_completed_actions} = {};
  
    if (@_) {
      my ($action, %p) = @_;
      my $args = $p{args} ? delete($p{args}) : {};
  
      local $self->{invoked_action} = $action;
      local $self->{args} = {%{$self->{args}}, %$args};
      local $self->{properties} = {%{$self->{properties}}, %p};
      return $self->_call_action($action);
    }
  
    die "No build action specified" unless $self->{action};
    local $self->{invoked_action} = $self->{action};
    $self->_call_action($self->{action});
  }
  
  sub _call_action {
    my ($self, $action) = @_;
  
    return if $self->{_completed_actions}{$action}++;
  
    local $self->{action} = $action;
    my $method = $self->can_action( $action );
    die "No action '$action' defined, try running the 'help' action.\n" unless $method;
    $self->log_debug("Starting ACTION_$action\n");
    my $rc = $self->$method();
    $self->log_debug("Finished ACTION_$action\n");
    return $rc;
  }
  
  sub can_action {
    my ($self, $action) = @_;
    return $self->can( "ACTION_$action" );
  }
  
  # cuts the user-specified options out of the command-line args
  sub cull_options {
      my $self = shift;
      my (@argv) = @_;
  
      # XXX is it even valid to call this as a class method?
      return({}, @argv) unless(ref($self)); # no object
  
      my $specs = $self->get_options;
      return({}, @argv) unless($specs and %$specs); # no user options
  
      require Getopt::Long;
      # XXX Should we let Getopt::Long handle M::B's options? That would
      # be easy-ish to add to @specs right here, but wouldn't handle options
      # passed without "--" as M::B currently allows. We might be able to
      # get around this by setting the "prefix_pattern" Configure option.
      my @specs;
      my $args = {};
      # Construct the specifications for GetOptions.
      foreach my $k (sort keys %$specs) {
          my $v = $specs->{$k};
          # Throw an error if specs conflict with our own.
          die "Option specification '$k' conflicts with a " . ref $self
            . " option of the same name"
            if $self->valid_property($k);
          push @specs, $k . (defined $v->{type} ? $v->{type} : '');
          push @specs, $v->{store} if exists $v->{store};
          $args->{$k} = $v->{default} if exists $v->{default};
      }
  
      local @ARGV = @argv; # No other way to dupe Getopt::Long
  
      # Get the options values and return them.
      # XXX Add option to allow users to set options?
      if ( @specs ) {
        Getopt::Long::Configure('pass_through');
        Getopt::Long::GetOptions($args, @specs);
      }
  
      return $args, @ARGV;
  }
  
  sub unparse_args {
    my ($self, $args) = @_;
    my @out;
    foreach my $k (sort keys %$args) {
      my $v = $args->{$k};
      push @out, (ref $v eq 'HASH'  ? map {+"--$k", "$_=$v->{$_}"} sort keys %$v :
                  ref $v eq 'ARRAY' ? map {+"--$k", $_} @$v :
                  ("--$k", $v));
    }
    return @out;
  }
  
  sub args {
      my $self = shift;
      return wantarray ? %{ $self->{args} } : $self->{args} unless @_;
      my $key = shift;
      $self->{args}{$key} = shift if @_;
      return $self->{args}{$key};
  }
  
  # allows select parameters (with underscores) to be spoken with dashes
  # when used as command-line options
  sub _translate_option {
    my $self = shift;
    my $opt  = shift;
  
    (my $tr_opt = $opt) =~ tr/-/_/;
  
    return $tr_opt if grep $tr_opt =~ /^(?:no_?)?$_$/, qw(
      create_license
      create_makefile_pl
      create_readme
      extra_compiler_flags
      extra_linker_flags
      install_base
      install_path
      meta_add
      meta_merge
      test_files
      use_rcfile
      use_tap_harness
      tap_harness_args
      cpan_client
      pureperl_only
      allow_pureperl
    ); # normalize only selected option names
  
    return $opt;
  }
  
  my %singular_argument = map { ($_ => 1) } qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;
  
  sub _read_arg {
    my ($self, $args, $key, $val) = @_;
  
    $key = $self->_translate_option($key);
  
    if ( exists $args->{$key} and not $singular_argument{$key} ) {
      $args->{$key} = [ $args->{$key} ] unless ref $args->{$key};
      push @{$args->{$key}}, $val;
    } else {
      $args->{$key} = $val;
    }
  }
  
  # decide whether or not an option requires/has an operand
  sub _optional_arg {
    my $self = shift;
    my $opt  = shift;
    my $argv = shift;
  
    $opt = $self->_translate_option($opt);
  
    my @bool_opts = qw(
      build_bat
      create_license
      create_readme
      pollute
      quiet
      uninst
      use_rcfile
      verbose
      debug
      sign
      use_tap_harness
      pureperl_only
      allow_pureperl
    );
  
    # inverted boolean options; eg --noverbose or --no-verbose
    # converted to proper name & returned with false value (verbose, 0)
    if ( grep $opt =~ /^no[-_]?$_$/, @bool_opts ) {
      $opt =~ s/^no-?//;
      return ($opt, 0);
    }
  
    # non-boolean option; return option unchanged along with its argument
    return ($opt, shift(@$argv)) unless grep $_ eq $opt, @bool_opts;
  
    # we're punting a bit here, if an option appears followed by a digit
    # we take the digit as the argument for the option. If there is
    # nothing that looks like a digit, we pretend the option is a flag
    # that is being set and has no argument.
    my $arg = 1;
    $arg = shift(@$argv) if @$argv && $argv->[0] =~ /^\d+$/;
  
    return ($opt, $arg);
  }
  
  sub read_args {
    my $self = shift;
  
    (my $args, @_) = $self->cull_options(@_);
    my %args = %$args;
  
    my $opt_re = qr/[\w\-]+/;
  
    my ($action, @argv);
    while (@_) {
      local $_ = shift;
      if ( /^(?:--)?($opt_re)=(.*)$/ ) {
        $self->_read_arg(\%args, $1, $2);
      } elsif ( /^--($opt_re)$/ ) {
        my($opt, $arg) = $self->_optional_arg($1, \@_);
        $self->_read_arg(\%args, $opt, $arg);
      } elsif ( /^($opt_re)$/ and !defined($action)) {
        $action = $1;
      } else {
        push @argv, $_;
      }
    }
    $args{ARGV} = \@argv;
  
    for ('extra_compiler_flags', 'extra_linker_flags') {
      $args{$_} = [ $self->split_like_shell($args{$_}) ] if exists $args{$_};
    }
  
    # Convert to arrays
    for ('include_dirs') {
      $args{$_} = [ $args{$_} ] if exists $args{$_} && !ref $args{$_}
    }
  
    # Hashify these parameters
    for ($self->hash_properties, 'config') {
      next unless exists $args{$_};
      my %hash;
      $args{$_} ||= [];
      $args{$_} = [ $args{$_} ] unless ref $args{$_};
      foreach my $arg ( @{$args{$_}} ) {
        $arg =~ /($opt_re)=(.*)/
          or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";
        $hash{$1} = $2;
      }
      $args{$_} = \%hash;
    }
  
    # De-tilde-ify any path parameters
    for my $key (qw(prefix install_base destdir)) {
      next if !defined $args{$key};
      $args{$key} = $self->_detildefy($args{$key});
    }
  
    for my $key (qw(install_path)) {
      next if !defined $args{$key};
  
      for my $subkey (keys %{$args{$key}}) {
        next if !defined $args{$key}{$subkey};
        my $subkey_ext = $self->_detildefy($args{$key}{$subkey});
        if ( $subkey eq 'html' ) { # translate for compatibility
          $args{$key}{binhtml} = $subkey_ext;
          $args{$key}{libhtml} = $subkey_ext;
        } else {
          $args{$key}{$subkey} = $subkey_ext;
        }
      }
    }
  
    if ($args{makefile_env_macros}) {
      require Module::Build::Compat;
      %args = (%args, Module::Build::Compat->makefile_to_build_macros);
    }
  
    return \%args, $action;
  }
  
  # Default: do nothing.  Overridden for Unix & Windows.
  sub _detildefy {}
  
  
  # merge Module::Build argument lists that have already been parsed
  # by read_args(). Takes two references to option hashes and merges
  # the contents, giving priority to the first.
  sub _merge_arglist {
    my( $self, $opts1, $opts2 ) = @_;
  
    $opts1 ||= {};
    $opts2 ||= {};
    my %new_opts = %$opts1;
    while (my ($key, $val) = each %$opts2) {
      if ( exists( $opts1->{$key} ) ) {
        if ( ref( $val ) eq 'HASH' ) {
          while (my ($k, $v) = each %$val) {
            $new_opts{$key}{$k} = $v unless exists( $opts1->{$key}{$k} );
          }
        }
      } else {
        $new_opts{$key} = $val
      }
    }
  
    return %new_opts;
  }
  
  # Look for a home directory on various systems.
  sub _home_dir {
    my @home_dirs;
    push( @home_dirs, $ENV{HOME} ) if $ENV{HOME};
  
    push( @home_dirs, File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '') )
        if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
  
    my @other_home_envs = qw( USERPROFILE APPDATA WINDIR SYS$LOGIN );
    push( @home_dirs, map $ENV{$_}, grep $ENV{$_}, @other_home_envs );
  
    my @real_home_dirs = grep -d, @home_dirs;
  
    return wantarray ? @real_home_dirs : shift( @real_home_dirs );
  }
  
  sub _find_user_config {
    my $self = shift;
    my $file = shift;
    foreach my $dir ( $self->_home_dir ) {
      my $path = File::Spec->catfile( $dir, $file );
      return $path if -e $path;
    }
    return undef;
  }
  
  # read ~/.modulebuildrc returning global options '*' and
  # options specific to the currently executing $action.
  sub read_modulebuildrc {
    my( $self, $action ) = @_;
  
    return () unless $self->use_rcfile;
  
    my $modulebuildrc;
    if ( exists($ENV{MODULEBUILDRC}) && $ENV{MODULEBUILDRC} eq 'NONE' ) {
      return ();
    } elsif ( exists($ENV{MODULEBUILDRC}) && -e $ENV{MODULEBUILDRC} ) {
      $modulebuildrc = $ENV{MODULEBUILDRC};
    } elsif ( exists($ENV{MODULEBUILDRC}) ) {
      $self->log_warn("WARNING: Can't find resource file " .
                      "'$ENV{MODULEBUILDRC}' defined in environment.\n" .
                      "No options loaded\n");
      return ();
    } else {
      $modulebuildrc = $self->_find_user_config( '.modulebuildrc' );
      return () unless $modulebuildrc;
    }
  
    open(my $fh, '<', $modulebuildrc )
        or die "Can't open $modulebuildrc: $!";
  
    my %options; my $buffer = '';
    while (defined( my $line = <$fh> )) {
      chomp( $line );
      $line =~ s/#.*$//;
      next unless length( $line );
  
      if ( $line =~ /^\S/ ) {
        if ( $buffer ) {
          my( $action, $options ) = split( /\s+/, $buffer, 2 );
          $options{$action} .= $options . ' ';
          $buffer = '';
        }
        $buffer = $line;
      } else {
        $buffer .= $line;
      }
    }
  
    if ( $buffer ) { # anything left in $buffer ?
      my( $action, $options ) = split( /\s+/, $buffer, 2 );
      $options{$action} .= $options . ' '; # merge if more than one line
    }
  
    my ($global_opts) =
      $self->read_args( $self->split_like_shell( $options{'*'} || '' ) );
  
    # let fakeinstall act like install if not provided
    if ( $action eq 'fakeinstall' && ! exists $options{fakeinstall} ) {
      $action = 'install';
    }
    my ($action_opts) =
      $self->read_args( $self->split_like_shell( $options{$action} || '' ) );
  
    # specific $action options take priority over global options '*'
    return $self->_merge_arglist( $action_opts, $global_opts );
  }
  
  # merge the relevant options in ~/.modulebuildrc into Module::Build's
  # option list where they do not conflict with commandline options.
  sub merge_modulebuildrc {
    my( $self, $action, %cmdline_opts ) = @_;
    my %rc_opts = $self->read_modulebuildrc( $action || $self->{action} || 'build' );
    my %new_opts = $self->_merge_arglist( \%cmdline_opts, \%rc_opts );
    $self->merge_args( $action, %new_opts );
  }
  
  sub merge_args {
    my ($self, $action, %args) = @_;
    $self->{action} = $action if defined $action;
  
    my %additive = map { $_ => 1 } $self->hash_properties;
  
    # Extract our 'properties' from $cmd_args, the rest are put in 'args'.
    while (my ($key, $val) = each %args) {
      $self->{phash}{runtime_params}->access( $key => $val )
        if $self->valid_property($key);
  
      if ($key eq 'config') {
        $self->config($_ => $val->{$_}) foreach keys %$val;
      } else {
        my $add_to = $additive{$key}             ? $self->{properties}{$key} :
                     $self->valid_property($key) ? $self->{properties}       :
                     $self->{args}               ;
  
        if ($additive{$key}) {
          $add_to->{$_} = $val->{$_} foreach keys %$val;
        } else {
          $add_to->{$key} = $val;
        }
      }
    }
  }
  
  sub cull_args {
    my $self = shift;
    my @arg_list = @_;
    unshift @arg_list, $self->split_like_shell($ENV{PERL_MB_OPT})
      if $ENV{PERL_MB_OPT};
    my ($args, $action) = $self->read_args(@arg_list);
    $self->merge_args($action, %$args);
    $self->merge_modulebuildrc( $action, %$args );
  }
  
  sub super_classes {
    my ($self, $class, $seen) = @_;
    $class ||= ref($self) || $self;
    $seen  ||= {};
  
    no strict 'refs';
    my @super = grep {not $seen->{$_}++} $class, @{ $class . '::ISA' };
    return @super, map {$self->super_classes($_,$seen)} @super;
  }
  
  sub known_actions {
    my ($self) = @_;
  
    my %actions;
    no strict 'refs';
  
    foreach my $class ($self->super_classes) {
      foreach ( keys %{ $class . '::' } ) {
        $actions{$1}++ if /^ACTION_(\w+)/;
      }
    }
  
    return wantarray ? sort keys %actions : \%actions;
  }
  
  sub get_action_docs {
    my ($self, $action) = @_;
    my $actions = $self->known_actions;
    die "No known action '$action'" unless $actions->{$action};
  
    my ($files_found, @docs) = (0);
    foreach my $class ($self->super_classes) {
      (my $file = $class) =~ s{::}{/}g;
      # NOTE: silently skipping relative paths if any chdir() happened
      $file = $INC{$file . '.pm'} or next;
      open(my $fh, '<', $file) or next;
      $files_found++;
  
      # Code below modified from /usr/bin/perldoc
  
      # Skip to ACTIONS section
      local $_;
      while (<$fh>) {
        last if /^=head1 ACTIONS\s/;
      }
  
      # Look for our action and determine the style
      my $style;
      while (<$fh>) {
        last if /^=head1 /;
  
        # only item and head2 are allowed (3&4 are not in 5.005)
        if(/^=(item|head2)\s+\Q$action\E\b/) {
          $style = $1;
          push @docs, $_;
          last;
        }
      }
      $style or next; # not here
  
      # and the content
      if($style eq 'item') {
        my ($found, $inlist) = (0, 0);
        while (<$fh>) {
          if (/^=(item|back)/) {
            last unless $inlist;
          }
          push @docs, $_;
          ++$inlist if /^=over/;
          --$inlist if /^=back/;
        }
      }
      else { # head2 style
        # stop at anything equal or greater than the found level
        while (<$fh>) {
          last if(/^=(?:head[12]|cut)/);
          push @docs, $_;
        }
      }
      # TODO maybe disallow overriding just pod for an action
      # TODO and possibly: @docs and last;
    }
  
    unless ($files_found) {
      $@ = "Couldn't find any documentation to search";
      return;
    }
    unless (@docs) {
      $@ = "Couldn't find any docs for action '$action'";
      return;
    }
  
    return join '', @docs;
  }
  
  sub ACTION_prereq_report {
    my $self = shift;
    $self->log_info( $self->prereq_report );
  }
  
  sub ACTION_prereq_data {
    my $self = shift;
    $self->log_info( Module::Build::Dumper->_data_dump( $self->prereq_data ) );
  }
  
  sub prereq_data {
    my $self = shift;
    my @types = ('configure_requires', @{ $self->prereq_action_types } );
    my $info = { map { $_ => $self->$_() } grep { %{$self->$_()} } @types };
    return $info;
  }
  
  sub prereq_report {
    my $self = shift;
    my $info = $self->prereq_data;
  
    my $output = '';
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      $output .= "\n$type:\n";
      my $mod_len = 2;
      my $ver_len = 4;
      my %mods;
      foreach my $modname (sort keys %$prereqs) {
        my $spec = $prereqs->{$modname};
        my $len  = length $modname;
        $mod_len = $len if $len > $mod_len;
        $spec    ||= '0';
        $len     = length $spec;
        $ver_len = $len if $len > $ver_len;
  
        my $mod = $self->check_installed_status($modname, $spec);
        $mod->{name} = $modname;
        $mod->{ok} ||= 0;
        $mod->{ok} = ! $mod->{ok} if $type =~ /^(\w+_)?conflicts$/;
  
        $mods{lc $modname} = $mod;
      }
  
      my $space  = q{ } x ($mod_len - 3);
      my $vspace = q{ } x ($ver_len - 3);
      my $sline  = q{-} x ($mod_len - 3);
      my $vline  = q{-} x ($ver_len - 3);
      my $disposition = ($type =~ /^(\w+_)?conflicts$/) ?
                          'Clash' : 'Need';
      $output .=
        "    Module $space  $disposition $vspace  Have\n".
        "    ------$sline+------$vline-+----------\n";
  
  
      for my $k (sort keys %mods) {
        my $mod = $mods{$k};
        my $space  = q{ } x ($mod_len - length $k);
        my $vspace = q{ } x ($ver_len - length $mod->{need});
        my $f = $mod->{ok} ? ' ' : '!';
        $output .=
          "  $f $mod->{name} $space     $mod->{need}  $vspace   ".
          (defined($mod->{have}) ? $mod->{have} : "")."\n";
      }
    }
    return $output;
  }
  
  sub ACTION_help {
    my ($self) = @_;
    my $actions = $self->known_actions;
  
    if (@{$self->{args}{ARGV}}) {
      my $msg = eval {$self->get_action_docs($self->{args}{ARGV}[0], $actions)};
      print $@ ? "$@\n" : $msg;
      return;
    }
  
    print <<EOF;
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  
    print $self->_action_listing($actions);
  
    print "\nRun `Build help <action>` for details on an individual action.\n";
    print "See `perldoc Module::Build` for complete documentation.\n";
  }
  
  sub _action_listing {
    my ($self, $actions) = @_;
  
    # Flow down columns, not across rows
    my @actions = sort keys %$actions;
    @actions = map $actions[($_ + ($_ % 2) * @actions) / 2],  0..$#actions;
  
    my $out = '';
    while (my ($one, $two) = splice @actions, 0, 2) {
      $out .= sprintf("  %-12s                   %-12s\n", $one, $two||'');
    }
    $out =~ s{\s*$}{}mg; # remove trailing spaces
    return $out;
  }
  
  sub ACTION_retest {
    my ($self) = @_;
  
    # Protect others against our @INC changes
    local @INC = @INC;
  
    # Filter out nonsensical @INC entries - some versions of
    # Test::Harness will really explode the number of entries here
    @INC = grep {ref() || -d} @INC if @INC > 100;
  
    $self->do_tests;
  }
  
  sub ACTION_testall {
    my ($self) = @_;
  
    my @types;
    for my $action (grep { $_ ne 'all' } $self->get_test_types) {
      # XXX We can't just dispatch because we get multiple summaries but
      # we'll need to dispatch to support custom setup/teardown in the
      # action.  To support that, we'll need to call something besides
      # Harness::runtests() because we'll need to collect the results in
      # parts, then run the summary.
      push(@types, $action);
      #$self->_call_action( "test$action" );
    }
    $self->generic_test(types => ['default', @types]);
  }
  
  sub get_test_types {
    my ($self) = @_;
  
    my $t = $self->{properties}->{test_types};
    return ( defined $t ? ( wantarray ? sort keys %$t : keys %$t ) : () );
  }
  
  
  sub ACTION_test {
    my ($self) = @_;
    $self->generic_test(type => 'default');
  }
  
  sub generic_test {
    my $self = shift;
    (@_ % 2) and croak('Odd number of elements in argument hash');
    my %args = @_;
  
    my $p = $self->{properties};
  
    my @types = (
      (exists($args{type})  ? $args{type} : ()),
      (exists($args{types}) ? @{$args{types}} : ()),
    );
    @types or croak "need some types of tests to check";
  
    my %test_types = (
      default => $p->{test_file_exts},
      (defined($p->{test_types}) ? %{$p->{test_types}} : ()),
    );
  
    for my $type (@types) {
      croak "$type not defined in test_types!"
        unless defined $test_types{ $type };
    }
  
    # we use local here because it ends up two method calls deep
    local $p->{test_file_exts} = [ map { ref $_ ? @$_ : $_ } @test_types{@types} ];
    $self->depends_on('code');
  
    # Protect others against our @INC changes
    local @INC = @INC;
  
    # Make sure we test the module in blib/
    unshift @INC, (File::Spec->catdir($p->{base_dir}, $self->blib, 'lib'),
                   File::Spec->catdir($p->{base_dir}, $self->blib, 'arch'));
  
    # Filter out nonsensical @INC entries - some versions of
    # Test::Harness will really explode the number of entries here
    @INC = grep {ref() || -d} @INC if @INC > 100;
  
    $self->do_tests;
  }
  
  # Test::Harness dies on failure but TAP::Harness does not, so we must
  # die if running under TAP::Harness
  sub do_tests {
    my $self = shift;
  
    my $tests = $self->find_test_files;
  
    local $ENV{PERL_DL_NONLAZY} = 1;
  
    if(@$tests) {
      my $args = $self->tap_harness_args;
      if($self->use_tap_harness or ($args and %$args)) {
        my $aggregate = $self->run_tap_harness($tests);
        if ( $aggregate->has_errors ) {
          die "Errors in testing.  Cannot continue.\n";
        }
      }
      else {
        $self->run_test_harness($tests);
      }
    }
    else {
      $self->log_info("No tests defined.\n");
    }
  
    $self->run_visual_script;
  }
  
  sub run_tap_harness {
    my ($self, $tests) = @_;
  
    require TAP::Harness::Env;
  
    # TODO allow the test @INC to be set via our API?
  
    my $aggregate = TAP::Harness::Env->create({
      lib => [@INC],
      verbosity => $self->{properties}{verbose},
      switches  => [ $self->harness_switches ],
      %{ $self->tap_harness_args },
    })->runtests(@$tests);
  
    return $aggregate;
  }
  
  sub run_test_harness {
      my ($self, $tests) = @_;
      require Test::Harness;
  
      local $Test::Harness::verbose = $self->verbose || 0;
      local $Test::Harness::switches = join ' ', $self->harness_switches;
  
      Test::Harness::runtests(@$tests);
  }
  
  sub run_visual_script {
      my $self = shift;
      # This will get run and the user will see the output.  It doesn't
      # emit Test::Harness-style output.
      $self->run_perl_script('visual.pl', '-Mblib='.$self->blib)
          if -e 'visual.pl';
  }
  
  sub harness_switches {
      my $self = shift;
      my @res;
      push @res, qw(-w -d) if $self->{properties}{debugger};
      push @res, '-MDevel::Cover' if $self->{properties}{cover};
      return @res;
  }
  
  sub test_files {
    my $self = shift;
    my $p = $self->{properties};
    if (@_) {
      return $p->{test_files} = (@_ == 1 ? shift : [@_]);
    }
    return $self->find_test_files;
  }
  
  sub expand_test_dir {
    my ($self, $dir) = @_;
    my $exts = $self->{properties}{test_file_exts};
  
    return sort map { @{$self->rscan_dir($dir, qr{^[^.].*\Q$_\E$})} } @$exts
      if $self->recursive_test_files;
  
    return sort map { glob File::Spec->catfile($dir, "*$_") } @$exts;
  }
  
  sub ACTION_testdb {
    my ($self) = @_;
    local $self->{properties}{debugger} = 1;
    $self->depends_on('test');
  }
  
  sub ACTION_testcover {
    my ($self) = @_;
  
    unless (Module::Metadata->find_module_by_name('Devel::Cover')) {
      warn("Cannot run testcover action unless Devel::Cover is installed.\n");
      return;
    }
  
    $self->add_to_cleanup('coverage', 'cover_db');
    $self->depends_on('code');
  
    # See whether any of the *.pm files have changed since last time
    # testcover was run.  If so, start over.
    if (-e 'cover_db') {
      my $pm_files = $self->rscan_dir
          (File::Spec->catdir($self->blib, 'lib'), $self->file_qr('\.pm$') );
      my $cover_files = $self->rscan_dir('cover_db', sub {-f $_ and not /\.html$/});
  
      $self->do_system(qw(cover -delete))
        unless $self->up_to_date($pm_files,         $cover_files)
            && $self->up_to_date($self->test_files, $cover_files);
    }
  
    local $self->{properties}{cover} = 1;
    $self->depends_on('test');
    $self->do_system('cover');
  }
  
  sub ACTION_code {
    my ($self) = @_;
  
    # All installable stuff gets created in blib/ .
    # Create blib/arch to keep blib.pm happy
    my $blib = $self->blib;
    $self->add_to_cleanup($blib);
    File::Path::mkpath( File::Spec->catdir($blib, 'arch') );
  
    if (my $split = $self->autosplit) {
      $self->autosplit_file($_, $blib) for ref($split) ? @$split : ($split);
    }
  
    foreach my $element (@{$self->build_elements}) {
      my $method = "process_${element}_files";
      $method = "process_files_by_extension" unless $self->can($method);
      $self->$method($element);
    }
  
    $self->depends_on('config_data');
  }
  
  sub ACTION_build {
    my $self = shift;
    $self->log_info("Building " . $self->dist_name . "\n");
    $self->depends_on('code');
    $self->depends_on('docs');
  }
  
  sub process_files_by_extension {
    my ($self, $ext) = @_;
  
    my $method = "find_${ext}_files";
    my $files = $self->can($method) ? $self->$method() : $self->_find_file_by_type($ext,  'lib');
  
    foreach my $file (sort keys %$files) {
      $self->copy_if_modified(from => $file, to => File::Spec->catfile($self->blib, $files->{$file}) );
    }
  }
  
  sub process_support_files {
    my $self = shift;
    my $p = $self->{properties};
    return unless $p->{c_source};
  
    my $files;
    if (ref($p->{c_source}) eq "ARRAY") {
        push @{$p->{include_dirs}}, @{$p->{c_source}};
        for my $path (@{$p->{c_source}}) {
            push @$files, @{ $self->rscan_dir($path, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$')) };
        }
    } else {
        push @{$p->{include_dirs}}, $p->{c_source};
        $files = $self->rscan_dir($p->{c_source}, $self->file_qr('\.c(c|p|pp|xx|\+\+)?$'));
    }
  
    foreach my $file (@$files) {
        push @{$p->{objects}}, $self->compile_c($file);
    }
  }
  
  sub process_share_dir_files {
    my $self = shift;
    my $files = $self->_find_share_dir_files;
    return unless $files;
  
    # root for all File::ShareDir paths
    my $share_prefix = File::Spec->catdir($self->blib, qw/lib auto share/);
  
    # copy all share files to blib
    foreach my $file (sort keys %$files) {
      $self->copy_if_modified(
        from => $file, to => File::Spec->catfile( $share_prefix, $files->{$file} )
      );
    }
  }
  
  sub _find_share_dir_files {
    my $self = shift;
    my $share_dir = $self->share_dir;
    return unless $share_dir;
  
    my @file_map;
    if ( $share_dir->{dist} ) {
      my $prefix = "dist/".$self->dist_name;
      push @file_map, $self->_share_dir_map( $prefix, $share_dir->{dist} );
    }
  
    if ( $share_dir->{module} ) {
      for my $mod ( sort keys %{ $share_dir->{module} } ) {
        (my $altmod = $mod) =~ s{::}{-}g;
        my $prefix = "module/$altmod";
        push @file_map, $self->_share_dir_map($prefix, $share_dir->{module}{$mod});
      }
    }
  
    return { @file_map };
  }
  
  sub _share_dir_map {
    my ($self, $prefix, $list) = @_;
    my %files;
    for my $dir ( @$list ) {
      for my $f ( @{ $self->rscan_dir( $dir, sub {-f} )} ) {
        $f =~ s{\A.*?\Q$dir\E/}{};
        $files{"$dir/$f"} = "$prefix/$f";
      }
    }
    return %files;
  }
  
  sub process_PL_files {
    my ($self) = @_;
    my $files = $self->find_PL_files;
  
    foreach my $file (sort keys %$files) {
      my $to = $files->{$file};
      unless ($self->up_to_date( $file, $to )) {
        $self->run_perl_script($file, [], [@$to]) or die "$file failed";
        $self->add_to_cleanup(@$to);
      }
    }
  }
  
  sub process_xs_files {
    my $self = shift;
    return if $self->pureperl_only && $self->allow_pureperl;
    my $files = $self->find_xs_files;
    croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;
    foreach my $from (sort keys %$files) {
      my $to = $files->{$from};
      unless ($from eq $to) {
        $self->add_to_cleanup($to);
        $self->copy_if_modified( from => $from, to => $to );
      }
      $self->process_xs($to);
    }
  }
  
  sub process_pod_files { shift()->process_files_by_extension(shift()) }
  sub process_pm_files  { shift()->process_files_by_extension(shift()) }
  
  sub process_script_files {
    my $self = shift;
    my $files = $self->find_script_files;
    return unless keys %$files;
  
    my $script_dir = File::Spec->catdir($self->blib, 'script');
    File::Path::mkpath( $script_dir );
  
    foreach my $file (sort keys %$files) {
      my $result = $self->copy_if_modified($file, $script_dir, 'flatten') or next;
      $self->fix_shebang_line($result) unless $self->is_vmsish;
      $self->make_executable($result);
    }
  }
  
  sub find_PL_files {
    my $self = shift;
    if (my $files = $self->{properties}{PL_files}) {
      # 'PL_files' is given as a Unix file spec, so we localize_file_path().
  
      if (ref $files eq 'ARRAY') {
        return { map {$_, [/^(.*)\.PL$/]}
                 map $self->localize_file_path($_),
                 @$files };
  
      } elsif (ref $files eq 'HASH') {
        my %out;
        while (my ($file, $to) = each %$files) {
          $out{ $self->localize_file_path($file) } = [ map $self->localize_file_path($_),
                                                       ref $to ? @$to : ($to) ];
        }
        return \%out;
  
      } else {
        die "'PL_files' must be a hash reference or array reference";
      }
    }
  
    return unless -d 'lib';
    return {
      map {$_, [/^(.*)\.PL$/i ]}
      @{ $self->rscan_dir('lib', $self->file_qr('\.PL$')) }
    };
  }
  
  sub find_pm_files  { shift->_find_file_by_type('pm',  'lib') }
  sub find_pod_files { shift->_find_file_by_type('pod', 'lib') }
  sub find_xs_files  { shift->_find_file_by_type('xs',  'lib') }
  
  sub find_script_files {
    my $self = shift;
    if (my $files = $self->script_files) {
      # Always given as a Unix file spec.  Values in the hash are
      # meaningless, but we preserve if present.
      return { map {$self->localize_file_path($_), $files->{$_}} keys %$files };
    }
  
    # No default location for script files
    return {};
  }
  
  sub find_test_files {
    my $self = shift;
    my $p = $self->{properties};
  
    if (my $files = $p->{test_files}) {
      $files = [sort keys %$files] if ref $files eq 'HASH';
      $files = [map { -d $_ ? $self->expand_test_dir($_) : $_ }
                map glob,
                $self->split_like_shell($files)];
  
      # Always given as a Unix file spec.
      return [ map $self->localize_file_path($_), @$files ];
  
    } else {
      # Find all possible tests in t/ or test.pl
      my @tests;
      push @tests, 'test.pl'                          if -e 'test.pl';
      push @tests, $self->expand_test_dir('t')        if -e 't' and -d _;
      return \@tests;
    }
  }
  
  sub _find_file_by_type {
    my ($self, $type, $dir) = @_;
  
    if (my $files = $self->{properties}{"${type}_files"}) {
      # Always given as a Unix file spec
      return { map $self->localize_file_path($_), %$files };
    }
  
    return {} unless -d $dir;
    return { map {$_, $_}
             map $self->localize_file_path($_),
             grep !/\.\#/,
             @{ $self->rscan_dir($dir, $self->file_qr("\\.$type\$")) } };
  }
  
  sub localize_file_path {
    my ($self, $path) = @_;
    return File::Spec->catfile( split m{/}, $path );
  }
  
  sub localize_dir_path {
    my ($self, $path) = @_;
    return File::Spec->catdir( split m{/}, $path );
  }
  
  sub fix_shebang_line { # Adapted from fixin() in ExtUtils::MM_Unix 1.35
    my ($self, @files) = @_;
    my $c = ref($self) ? $self->{config} : 'Module::Build::Config';
  
    my ($does_shbang) = $c->get('sharpbang') =~ /^\s*\#\!/;
    for my $file (@files) {
      open(my $FIXIN, '<', $file) or die "Can't process '$file': $!";
      local $/ = "\n";
      chomp(my $line = <$FIXIN>);
      next unless $line =~ s/^\s*\#!\s*//;     # Not a shebang file.
  
      my ($cmd, $arg) = (split(' ', $line, 2), '');
      next unless $cmd =~ /perl/i;
      my $interpreter = $self->{properties}{perl};
  
      $self->log_verbose("Changing sharpbang in $file to $interpreter\n");
      my $shb = '';
      $shb .= $c->get('sharpbang')."$interpreter $arg\n" if $does_shbang;
  
      open(my $FIXOUT, '>', "$file.new")
        or die "Can't create new $file: $!\n";
  
      # Print out the new #! line (or equivalent).
      local $\;
      undef $/; # Was localized above
      print $FIXOUT $shb, <$FIXIN>;
      close $FIXIN;
      close $FIXOUT;
  
      rename($file, "$file.bak")
        or die "Can't rename $file to $file.bak: $!";
  
      rename("$file.new", $file)
        or die "Can't rename $file.new to $file: $!";
  
      $self->delete_filetree("$file.bak")
        or $self->log_warn("Couldn't clean up $file.bak, leaving it there");
  
      $self->do_system($c->get('eunicefix'), $file) if $c->get('eunicefix') ne ':';
    }
  }
  
  
  sub ACTION_testpod {
    my $self = shift;
    $self->depends_on('docs');
  
    eval q{use Test::Pod 0.95; 1}
      or die "The 'testpod' action requires Test::Pod version 0.95";
  
    my @files = sort keys %{$self->_find_pods($self->libdoc_dirs)},
                     keys %{$self->_find_pods
                               ($self->bindoc_dirs,
                                exclude => [ $self->file_qr('\.bat$') ])}
      or die "Couldn't find any POD files to test\n";
  
    { package # hide from PAUSE
        Module::Build::PodTester;  # Don't want to pollute the main namespace
      Test::Pod->import( tests => scalar @files );
      pod_file_ok($_) foreach @files;
    }
  }
  
  sub ACTION_testpodcoverage {
    my $self = shift;
  
    $self->depends_on('docs');
  
    eval q{use Test::Pod::Coverage 1.00; 1}
      or die "The 'testpodcoverage' action requires ",
             "Test::Pod::Coverage version 1.00";
  
    # TODO this needs test coverage!
  
    # XXX work-around a bug in Test::Pod::Coverage previous to v1.09
    # Make sure we test the module in blib/
    local @INC = @INC;
    my $p = $self->{properties};
    unshift(@INC,
      # XXX any reason to include arch?
      File::Spec->catdir($p->{base_dir}, $self->blib, 'lib'),
      #File::Spec->catdir($p->{base_dir}, $self->blib, 'arch')
    );
  
    all_pod_coverage_ok();
  }
  
  sub ACTION_docs {
    my $self = shift;
  
    $self->depends_on('code');
    $self->depends_on('manpages', 'html');
  }
  
  # Given a file type, will return true if the file type would normally
  # be installed when neither install-base nor prefix has been set.
  # I.e. it will be true only if the path is set from Config.pm or
  # set explicitly by the user via install-path.
  sub _is_default_installable {
    my $self = shift;
    my $type = shift;
    return ( $self->install_destination($type) &&
             ( $self->install_path($type) ||
               $self->install_sets($self->installdirs)->{$type} )
           ) ? 1 : 0;
  }
  
  sub _is_ActivePerl {
  #  return 0;
    my $self = shift;
    unless (exists($self->{_is_ActivePerl})) {
      $self->{_is_ActivePerl} = (eval { require ActivePerl::DocTools; } || 0);
    }
    return $self->{_is_ActivePerl};
  }
  
  sub _is_ActivePPM {
  #  return 0;
    my $self = shift;
    unless (exists($self->{_is_ActivePPM})) {
      $self->{_is_ActivePPM} = (eval { require ActivePerl::PPM; } || 0);
    }
    return $self->{_is_ActivePPM};
  }
  
  sub ACTION_manpages {
    my $self = shift;
  
    return unless $self->_mb_feature('manpage_support');
  
    $self->depends_on('code');
  
    my %extra_manify_args = $self->{properties}{'extra_manify_args'} ? %{ $self->{properties}{'extra_manify_args'} } : ();
  
    foreach my $type ( qw(bin lib) ) {
      next unless ( $self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));
      my $files = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
                                     exclude => [ $self->file_qr('\.bat$') ] );
      next unless %$files;
  
      my $sub = $self->can("manify_${type}_pods");
      $self->$sub( %extra_manify_args ) if defined( $sub );
    }
  }
  
  sub manify_bin_pods {
    my $self    = shift;
    my %podman_args = (section =>  1, @_); # binaries go in section 1
  
    my $files   = $self->_find_pods( $self->{properties}{bindoc_dirs},
                                     exclude => [ $self->file_qr('\.bat$') ] );
    return unless keys %$files;
  
    my $mandir = File::Spec->catdir( $self->blib, 'bindoc' );
    File::Path::mkpath( $mandir, 0, oct(777) );
  
    require Pod::Man;
    foreach my $file (sort keys %$files) {
      # Pod::Simple based parsers only support one document per instance.
      # This is expected to change in a future version (Pod::Simple > 3.03).
      my $parser  = Pod::Man->new( %podman_args );
      my $manpage = $self->man1page_name( $file ) . '.' .
                    $self->config( 'man1ext' );
      my $outfile = File::Spec->catfile($mandir, $manpage);
      next if $self->up_to_date( $file, $outfile );
      $self->log_verbose("Manifying $file -> $outfile\n");
      eval { $parser->parse_from_file( $file, $outfile ); 1 }
        or $self->log_warn("Error creating '$outfile': $@\n");
      $files->{$file} = $outfile;
    }
  }
  
  sub manify_lib_pods {
    my $self    = shift;
    my %podman_args = (section => 3, @_); # libraries go in section 3
  
    my $files   = $self->_find_pods($self->{properties}{libdoc_dirs});
    return unless keys %$files;
  
    my $mandir = File::Spec->catdir( $self->blib, 'libdoc' );
    File::Path::mkpath( $mandir, 0, oct(777) );
  
    require Pod::Man;
    foreach my $file (sort keys %$files) {
      # Pod::Simple based parsers only support one document per instance.
      # This is expected to change in a future version (Pod::Simple > 3.03).
      my $parser  = Pod::Man->new( %podman_args );
      my $manpage = $self->man3page_name( $files->{$file} ) . '.' .
                    $self->config( 'man3ext' );
      my $outfile = File::Spec->catfile( $mandir, $manpage);
      next if $self->up_to_date( $file, $outfile );
      $self->log_verbose("Manifying $file -> $outfile\n");
      eval { $parser->parse_from_file( $file, $outfile ); 1 }
        or $self->log_warn("Error creating '$outfile': $@\n");
      $files->{$file} = $outfile;
    }
  }
  
  sub _find_pods {
    my ($self, $dirs, %args) = @_;
    my %files;
    foreach my $spec (@$dirs) {
      my $dir = $self->localize_dir_path($spec);
      next unless -e $dir;
  
      FILE: foreach my $file ( @{ $self->rscan_dir( $dir ) } ) {
        foreach my $regexp ( @{ $args{exclude} } ) {
          next FILE if $file =~ $regexp;
        }
        $file = $self->localize_file_path($file);
        $files{$file} = File::Spec->abs2rel($file, $dir) if $self->contains_pod( $file )
      }
    }
    return \%files;
  }
  
  sub contains_pod {
    my ($self, $file) = @_;
    return '' unless -T $file;  # Only look at text files
  
    open(my $fh, '<', $file ) or die "Can't open $file: $!";
    while (my $line = <$fh>) {
      return 1 if $line =~ /^\=(?:head|pod|item)/;
    }
  
    return '';
  }
  
  sub ACTION_html {
    my $self = shift;
  
    return unless $self->_mb_feature('HTML_support');
  
    $self->depends_on('code');
  
    foreach my $type ( qw(bin lib) ) {
      next unless ( $self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));
      $self->htmlify_pods( $type );
    }
  }
  
  # 1) If it's an ActiveState perl install, we need to run
  #    ActivePerl::DocTools->UpdateTOC;
  # 2) Links to other modules are not being generated
  sub htmlify_pods {
    my $self = shift;
    my $type = shift;
    my $htmldir = shift || File::Spec->catdir($self->blib, "${type}html");
  
    $self->add_to_cleanup('pod2htm*');
  
    my $pods = $self->_find_pods( $self->{properties}{"${type}doc_dirs"},
                                  exclude => [ $self->file_qr('\.(?:bat|com|html)$') ] );
    return unless %$pods;  # nothing to do
  
    unless ( -d $htmldir ) {
      File::Path::mkpath($htmldir, 0, oct(755))
        or die "Couldn't mkdir $htmldir: $!";
    }
  
    my @rootdirs = ($type eq 'bin') ? qw(bin) :
        $self->installdirs eq 'core' ? qw(lib) : qw(site lib);
    my $podroot = $ENV{PERL_CORE}
                ? File::Basename::dirname($ENV{PERL_CORE})
                : $self->original_prefix('core');
  
    my $htmlroot = $self->install_sets('core')->{libhtml};
    my $podpath;
    unless (defined $self->args('html_links') and !$self->args('html_links')) {
      my @podpath = ( (map { File::Spec->abs2rel($_ ,$podroot) } grep { -d  }
                       ( $self->install_sets('core', 'lib'), # lib
                         $self->install_sets('core', 'bin'), # bin
                         $self->install_sets('site', 'lib'), # site/lib
                       ) ), File::Spec->rel2abs($self->blib) );
  
      $podpath = $ENV{PERL_CORE}
        ? File::Spec->catdir($podroot, 'lib')
          : join(":", map { tr,:\\,|/,; $_ } @podpath);
    }
  
    my $blibdir = join('/', File::Spec->splitdir(
      (File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),''
    );
  
    my ($with_ActiveState, $htmltool);
  
    if ( $with_ActiveState = $self->_is_ActivePerl
      && eval { require ActivePerl::DocTools::Pod; 1 }
    ) {
      my $tool_v = ActiveState::DocTools::Pod->VERSION;
      $htmltool = "ActiveState::DocTools::Pod";
      $htmltool .= " $tool_v" if $tool_v && length $tool_v;
    }
    else {
        require Module::Build::PodParser;
        require Pod::Html;
      $htmltool = "Pod::Html " .  Pod::Html->VERSION;
    }
    $self->log_verbose("Converting Pod to HTML with $htmltool\n");
  
    my $errors = 0;
  
    POD:
    foreach my $pod ( sort keys %$pods ) {
  
      my ($name, $path) = File::Basename::fileparse($pods->{$pod},
        $self->file_qr('\.(?:pm|plx?|pod)$')
      );
      my @dirs = File::Spec->splitdir( File::Spec->canonpath( $path ) );
      pop( @dirs ) if scalar(@dirs) && $dirs[-1] eq File::Spec->curdir;
  
      my $fulldir = File::Spec->catdir($htmldir, @rootdirs, @dirs);
      my $tmpfile = File::Spec->catfile($fulldir, "${name}.tmp");
      my $outfile = File::Spec->catfile($fulldir, "${name}.html");
      my $infile  = File::Spec->abs2rel($pod);
  
      next if $self->up_to_date($infile, $outfile);
  
      unless ( -d $fulldir ){
        File::Path::mkpath($fulldir, 0, oct(755))
          or die "Couldn't mkdir $fulldir: $!";
      }
  
      $self->log_verbose("HTMLifying $infile -> $outfile\n");
      if ( $with_ActiveState ) {
        my $depth = @rootdirs + @dirs;
        my %opts = ( infile => $infile,
          outfile => $tmpfile,
          ( defined($podpath) ? (podpath => $podpath) : ()),
          podroot => $podroot,
          index => 1,
          depth => $depth,
        );
        eval {
          ActivePerl::DocTools::Pod::pod2html(map { ($_, $opts{$_}) } sort keys %opts);
          1;
        } or $self->log_warn("[$htmltool] pod2html (" .
          join(", ", map { "q{$_} => q{$opts{$_}}" } (sort keys %opts)) . ") failed: $@");
      } else {
        my $path2root = File::Spec->catdir((File::Spec->updir) x @dirs);
        open(my $fh, '<', $infile) or die "Can't read $infile: $!";
        my $abstract = Module::Build::PodParser->new(fh => $fh)->get_abstract();
  
        my $title = join( '::', (@dirs, $name) );
        $title .= " - $abstract" if $abstract;
  
        my @opts = (
          "--title=$title",
          ( defined($podpath) ? "--podpath=$podpath" : ()),
          "--infile=$infile",
          "--outfile=$tmpfile",
          "--podroot=$podroot",
          ($path2root ? "--htmlroot=$path2root" : ()),
        );
  
        unless ( eval{Pod::Html->VERSION(1.12)} ) {
          push( @opts, ('--flush') ); # caching removed in 1.12
        }
  
        if ( eval{Pod::Html->VERSION(1.12)} ) {
          push( @opts, ('--header', '--backlink') );
        } elsif ( eval{Pod::Html->VERSION(1.03)} ) {
          push( @opts, ('--header', '--backlink=Back to Top') );
        }
  
        $self->log_verbose("P::H::pod2html @opts\n");
        {
          my $orig = Cwd::getcwd();
          eval { Pod::Html::pod2html(@opts); 1 }
            or $self->log_warn("[$htmltool] pod2html( " .
            join(", ", map { "q{$_}" } @opts) . ") failed: $@");
          chdir($orig);
        }
      }
      # We now have to cleanup the resulting html file
      if ( ! -r $tmpfile ) {
        $errors++;
        next POD;
      }
      open(my $fh, '<', $tmpfile) or die "Can't read $tmpfile: $!";
      my $html = join('',<$fh>);
      close $fh;
      if (!$self->_is_ActivePerl) {
        # These fixups are already done by AP::DT:P:pod2html
        # The output from pod2html is NOT XHTML!
        # IE6+ will display content that is not valid for DOCTYPE
        $html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;
        $html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;
  
        # IE6+ will not display local HTML files with strict
        # security without this comment
        $html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i;
      }
      # Fixup links that point to our temp blib
      $html =~ s/\Q$blibdir\E//g;
  
      open($fh, '>', $outfile) or die "Can't write $outfile: $!";
      print $fh $html;
      close $fh;
      unlink($tmpfile);
    }
  
    return ! $errors;
  
  }
  
  # Adapted from ExtUtils::MM_Unix
  sub man1page_name {
    my $self = shift;
    return File::Basename::basename( shift );
  }
  
  # Adapted from ExtUtils::MM_Unix and Pod::Man
  # Depending on M::B's dependency policy, it might make more sense to refactor
  # Pod::Man::begin_pod() to extract a name() methods, and use them...
  #    -spurkis
  sub man3page_name {
    my $self = shift;
    my ($vol, $dirs, $file) = File::Spec->splitpath( shift );
    my @dirs = File::Spec->splitdir( File::Spec->canonpath($dirs) );
  
    # Remove known exts from the base name
    $file =~ s/\.p(?:od|m|l)\z//i;
  
    return join( $self->manpage_separator, @dirs, $file );
  }
  
  sub manpage_separator {
    return '::';
  }
  
  # For systems that don't have 'diff' executable, should use Algorithm::Diff
  sub ACTION_diff {
    my $self = shift;
    $self->depends_on('build');
    my $local_lib = File::Spec->rel2abs('lib');
    my @myINC = grep {$_ ne $local_lib} @INC;
  
    # The actual install destination might not be in @INC, so check there too.
    push @myINC, map $self->install_destination($_), qw(lib arch);
  
    my @flags = @{$self->{args}{ARGV}};
    @flags = $self->split_like_shell($self->{args}{flags} || '') unless @flags;
  
    my $installmap = $self->install_map;
    delete $installmap->{read};
    delete $installmap->{write};
  
    my $text_suffix = $self->file_qr('\.(pm|pod)$');
  
    foreach my $localdir (sort keys %$installmap) {
      my @localparts = File::Spec->splitdir($localdir);
      my $files = $self->rscan_dir($localdir, sub {-f});
  
      foreach my $file (@$files) {
        my @parts = File::Spec->splitdir($file);
        @parts = @parts[@localparts .. $#parts]; # Get rid of blib/lib or similar
  
        my $installed = Module::Metadata->find_module_by_name(
                          join('::', @parts), \@myINC );
        if (not $installed) {
          print "Only in lib: $file\n";
          next;
        }
  
        my $status = File::Compare::compare($installed, $file);
        next if $status == 0;  # Files are the same
        die "Can't compare $installed and $file: $!" if $status == -1;
  
        if ($file =~ $text_suffix) {
          $self->do_system('diff', @flags, $installed, $file);
        } else {
          print "Binary files $file and $installed differ\n";
        }
      }
    }
  }
  
  sub ACTION_pure_install {
    shift()->depends_on('install');
  }
  
  sub ACTION_install {
    my ($self) = @_;
    require ExtUtils::Install;
    $self->depends_on('build');
    # RT#63003 suggest that odd circumstances that we might wind up
    # in a different directory than we started, so wrap with _do_in_dir to
    # ensure we get back to where we started; hope this fixes it!
    $self->_do_in_dir( ".", sub {
      ExtUtils::Install::install(
        $self->install_map, $self->verbose, 0, $self->{args}{uninst}||0
      );
    });
    if ($self->_is_ActivePerl && $self->{_completed_actions}{html}) {
      $self->log_info("Building ActivePerl Table of Contents\n");
      eval { ActivePerl::DocTools::WriteTOC(verbose => $self->verbose ? 1 : 0); 1; }
        or $self->log_warn("AP::DT:: WriteTOC() failed: $@");
    }
    if ($self->_is_ActivePPM) {
      # We touch 'lib/perllocal.pod'. There is an existing logic in subroutine _init_db()
      # of 'ActivePerl/PPM/InstallArea.pm' that says that if 'lib/perllocal.pod' has a 'date-last-touched'
      # greater than that of the PPM SQLite databases ('etc/ppm-perl-area.db' and/or
      # 'site/etc/ppm-site-area.db') then the PPM SQLite databases are rebuilt from scratch.
  
      # in the following line, 'perllocal.pod' this is *always* 'lib/perllocal.pod', never 'site/lib/perllocal.pod'
      my $F_perllocal = File::Spec->catfile($self->install_sets('core', 'lib'), 'perllocal.pod');
      my $dt_stamp = time;
  
      $self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");
  
      open my $perllocal, ">>", $F_perllocal;
      close $perllocal;
      utime($dt_stamp, $dt_stamp, $F_perllocal);
    }
  }
  
  sub ACTION_fakeinstall {
    my ($self) = @_;
    require ExtUtils::Install;
    my $eui_version = ExtUtils::Install->VERSION;
    if ( $eui_version < 1.32 ) {
      $self->log_warn(
        "The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n"
        . "(You only have version $eui_version)."
      );
      return;
    }
    $self->depends_on('build');
    ExtUtils::Install::install($self->install_map, !$self->quiet, 1, $self->{args}{uninst}||0);
  }
  
  sub ACTION_versioninstall {
    my ($self) = @_;
  
    die "You must have only.pm 0.25 or greater installed for this operation: $@\n"
      unless eval { require only; 'only'->VERSION(0.25); 1 };
  
    $self->depends_on('build');
  
    my %onlyargs = map {exists($self->{args}{$_}) ? ($_ => $self->{args}{$_}) : ()}
      qw(version versionlib);
    only::install::install(%onlyargs);
  }
  
  sub ACTION_installdeps {
    my ($self) = @_;
  
    # XXX include feature prerequisites as optional prereqs?
  
    my $info = $self->_enum_prereqs;
    if (! $info ) {
      $self->log_info( "No prerequisites detected\n" );
      return;
    }
  
    my $failures = $self->prereq_failures($info);
    if ( ! $failures ) {
      $self->log_info( "All prerequisites satisfied\n" );
      return;
    }
  
    my @install;
    foreach my $type (sort keys %$failures) {
      my $prereqs = $failures->{$type};
      if($type =~ m/^(?:\w+_)?requires$/) {
        push(@install, sort keys %$prereqs);
        next;
      }
      $self->log_info("Checking optional dependencies:\n");
      foreach my $module (sort keys %$prereqs) {
        push(@install, $module) if($self->y_n("Install $module?", 'y'));
      }
    }
  
    return unless @install;
  
    my ($command, @opts) = $self->split_like_shell($self->cpan_client);
  
    # relative command should be relative to our active Perl
    # so we need to locate that command
    if ( ! File::Spec->file_name_is_absolute( $command ) ) {
      # prefer site to vendor to core
      my @loc = ( 'site', 'vendor', '' );
      my @bindirs = File::Basename::dirname($self->perl);
      push @bindirs,
        map {
          ($self->config->{"install${_}bin"}, $self->config->{"install${_}script"})
        } @loc;
      for my $d ( @bindirs ) {
        my $abs_cmd = $self->find_command(File::Spec->catfile( $d, $command ));
        if ( defined $abs_cmd ) {
          $command = $abs_cmd;
          last;
        }
      }
    }
  
    $self->do_system($command, @opts, @install);
  }
  
  sub ACTION_clean {
    my ($self) = @_;
    $self->log_info("Cleaning up build files\n");
    foreach my $item (map glob($_), $self->cleanup) {
      $self->delete_filetree($item);
    }
  }
  
  sub ACTION_realclean {
    my ($self) = @_;
    $self->depends_on('clean');
    $self->log_info("Cleaning up configuration files\n");
    $self->delete_filetree(
      $self->config_dir, $self->mymetafile, $self->mymetafile2, $self->build_script
    );
  }
  
  sub ACTION_ppd {
    my ($self) = @_;
  
    require Module::Build::PPMMaker;
    my $ppd = Module::Build::PPMMaker->new();
    my $file = $ppd->make_ppd(%{$self->{args}}, build => $self);
    $self->add_to_cleanup($file);
  }
  
  sub ACTION_ppmdist {
    my ($self) = @_;
  
    $self->depends_on( 'build' );
  
    my $ppm = $self->ppm_name;
    $self->delete_filetree( $ppm );
    $self->log_info( "Creating $ppm\n" );
    $self->add_to_cleanup( $ppm, "$ppm.tar.gz" );
  
    my %types = ( # translate types/dirs to those expected by ppm
      lib     => 'lib',
      arch    => 'arch',
      bin     => 'bin',
      script  => 'script',
      bindoc  => 'man1',
      libdoc  => 'man3',
      binhtml => undef,
      libhtml => undef,
    );
  
    foreach my $type ($self->install_types) {
      next if exists( $types{$type} ) && !defined( $types{$type} );
  
      my $dir = File::Spec->catdir( $self->blib, $type );
      next unless -e $dir;
  
      my $files = $self->rscan_dir( $dir );
      foreach my $file ( @$files ) {
        next unless -f $file;
        my $rel_file =
          File::Spec->abs2rel( File::Spec->rel2abs( $file ),
                               File::Spec->rel2abs( $dir  ) );
        my $to_file  =
          File::Spec->catfile( $ppm, 'blib',
                              exists( $types{$type} ) ? $types{$type} : $type,
                              $rel_file );
        $self->copy_if_modified( from => $file, to => $to_file );
      }
    }
  
    foreach my $type ( qw(bin lib) ) {
      $self->htmlify_pods( $type, File::Spec->catdir($ppm, 'blib', 'html') );
    }
  
    # create a tarball;
    # the directory tar'ed must be blib so we need to do a chdir first
    my $target = File::Spec->catfile( File::Spec->updir, $ppm );
    $self->_do_in_dir( $ppm, sub { $self->make_tarball( 'blib', $target ) } );
  
    $self->depends_on( 'ppd' );
  
    $self->delete_filetree( $ppm );
  }
  
  sub ACTION_pardist {
    my ($self) = @_;
  
    # Need PAR::Dist
    if ( not eval { require PAR::Dist; PAR::Dist->VERSION(0.17) } ) {
      $self->log_warn(
        "In order to create .par distributions, you need to\n"
        . "install PAR::Dist first."
      );
      return();
    }
  
    $self->depends_on( 'build' );
  
    return PAR::Dist::blib_to_par(
      name => $self->dist_name,
      version => $self->dist_version,
    );
  }
  
  sub ACTION_dist {
    my ($self) = @_;
  
    # MUST dispatch() and not depends_ok() so we generate a clean distdir
    $self->dispatch('distdir');
  
    my $dist_dir = $self->dist_dir;
  
    $self->make_tarball($dist_dir);
    $self->delete_filetree($dist_dir);
  }
  
  sub ACTION_distcheck {
    my ($self) = @_;
  
    $self->_check_manifest_skip unless $self->invoked_action eq 'distclean';
  
    require ExtUtils::Manifest;
    local $^W; # ExtUtils::Manifest is not warnings clean.
    my ($missing, $extra) = ExtUtils::Manifest::fullcheck();
  
    return unless @$missing || @$extra;
  
    my $msg = "MANIFEST appears to be out of sync with the distribution\n";
    if ( $self->invoked_action eq 'distcheck' ) {
      die $msg;
    } else {
      warn $msg;
    }
  }
  
  sub _check_mymeta_skip {
    my $self = shift;
    my $maniskip = shift || 'MANIFEST.SKIP';
  
    require ExtUtils::Manifest;
    local $^W; # ExtUtils::Manifest is not warnings clean.
  
    # older ExtUtils::Manifest had a private _maniskip
    my $skip_factory = ExtUtils::Manifest->can('maniskip')
                    || ExtUtils::Manifest->can('_maniskip');
  
    my $mymetafile = $self->mymetafile;
    # we can't check it, just add it anyway to be safe
    for my $file ( $self->mymetafile, $self->mymetafile2 ) {
      unless ( $skip_factory && $skip_factory->($maniskip)->($file) ) {
        $self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");
        my $safe = quotemeta($file);
        $self->_append_maniskip("^$safe\$", $maniskip);
      }
    }
  }
  
  sub _add_to_manifest {
    my ($self, $manifest, $lines) = @_;
    $lines = [$lines] unless ref $lines;
  
    my $existing_files = $self->_read_manifest($manifest);
    return unless defined( $existing_files );
  
    @$lines = grep {!exists $existing_files->{$_}} @$lines
      or return;
  
    my $mode = (stat $manifest)[2];
    chmod($mode | oct(222), $manifest) or die "Can't make $manifest writable: $!";
  
    open(my $fh, '<', $manifest) or die "Can't read $manifest: $!";
    my $last_line = (<$fh>)[-1] || "\n";
    my $has_newline = $last_line =~ /\n$/;
    close $fh;
  
    open($fh, '>>', $manifest) or die "Can't write to $manifest: $!";
    print $fh "\n" unless $has_newline;
    print $fh map "$_\n", @$lines;
    close $fh;
    chmod($mode, $manifest);
  
    $self->log_verbose(map "Added to $manifest: $_\n", @$lines);
  }
  
  sub _sign_dir {
    my ($self, $dir) = @_;
  
    unless (eval { require Module::Signature; 1 }) {
      $self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");
      return;
    }
  
    # Add SIGNATURE to the MANIFEST
    {
      my $manifest = File::Spec->catfile($dir, 'MANIFEST');
      die "Signing a distribution requires a MANIFEST file" unless -e $manifest;
      $self->_add_to_manifest($manifest, "SIGNATURE    Added here by Module::Build");
    }
  
    # Would be nice if Module::Signature took a directory argument.
  
    $self->_do_in_dir($dir, sub {local $Module::Signature::Quiet = 1; Module::Signature::sign()});
  }
  
  sub _do_in_dir {
    my ($self, $dir, $do) = @_;
  
    my $start_dir = File::Spec->rel2abs($self->cwd);
    chdir $dir or die "Can't chdir() to $dir: $!";
    eval {$do->()};
    my @err = $@ ? ($@) : ();
    chdir $start_dir or push @err, "Can't chdir() back to $start_dir: $!";
    die join "\n", @err if @err;
  }
  
  sub ACTION_distsign {
    my ($self) = @_;
    {
      local $self->{properties}{sign} = 0;  # We'll sign it ourselves
      $self->depends_on('distdir') unless -d $self->dist_dir;
    }
    $self->_sign_dir($self->dist_dir);
  }
  
  sub ACTION_skipcheck {
    my ($self) = @_;
  
    require ExtUtils::Manifest;
    local $^W; # ExtUtils::Manifest is not warnings clean.
    ExtUtils::Manifest::skipcheck();
  }
  
  sub ACTION_distclean {
    my ($self) = @_;
  
    $self->depends_on('realclean');
    $self->depends_on('distcheck');
  }
  
  sub do_create_makefile_pl {
    my $self = shift;
    require Module::Build::Compat;
    $self->log_info("Creating Makefile.PL\n");
    eval { Module::Build::Compat->create_makefile_pl($self->create_makefile_pl, $self, @_) };
    if ( $@ ) {
      1 while unlink 'Makefile.PL';
      die "$@\n";
    }
    $self->_add_to_manifest('MANIFEST', 'Makefile.PL');
  }
  
  sub do_create_license {
    my $self = shift;
    $self->log_info("Creating LICENSE file\n");
  
    if (  ! $self->_mb_feature('license_creation') ) {
      $self->_warn_mb_feature_deps('license_creation');
      die "Aborting.\n";
    }
  
    my $l = $self->license
      or die "Can't create LICENSE file: No license specified\n";
  
    my $license = $self->_software_license_object
      or die << "HERE";
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  
    $self->delete_filetree('LICENSE');
  
    open(my $fh, '>', 'LICENSE')
      or die "Can't write LICENSE file: $!";
    print $fh $license->fulltext;
    close $fh;
  
    $self->_add_to_manifest('MANIFEST', 'LICENSE');
  }
  
  sub do_create_readme {
    my $self = shift;
    $self->delete_filetree('README');
  
    my $docfile = $self->_main_docfile;
    unless ( $docfile ) {
      $self->log_warn(<<EOF);
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
      return;
    }
  
    # work around some odd Pod::Readme->new() failures in test reports by
    # confirming that new() is available
    if ( eval {require Pod::Readme; Pod::Readme->can('new') } ) {
      $self->log_info("Creating README using Pod::Readme\n");
  
      my $parser = Pod::Readme->new;
      $parser->parse_from_file($docfile, 'README', @_);
  
    } elsif ( eval {require Pod::Text; 1} ) {
      $self->log_info("Creating README using Pod::Text\n");
  
      if ( open(my $fh, '>', 'README') ) {
        local $^W = 0;
        no strict "refs";
  
        # work around bug in Pod::Text 3.01, which expects
        # Pod::Simple::parse_file to take input and output filehandles
        # when it actually only takes an input filehandle
  
        my $old_parse_file;
        $old_parse_file = \&{"Pod::Simple::parse_file"}
          and
        local *{"Pod::Simple::parse_file"} = sub {
          my $self = shift;
          $self->output_fh($_[1]) if $_[1];
          $self->$old_parse_file($_[0]);
        }
          if $Pod::Text::VERSION
            == 3.01; # Split line to avoid evil version-finder
  
        Pod::Text::pod2text( $docfile, $fh );
  
        close $fh;
      } else {
        $self->log_warn(
          "Cannot create 'README' file: Can't open file for writing\n" );
        return;
      }
  
    } else {
      $self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");
      return;
    }
  
    $self->_add_to_manifest('MANIFEST', 'README');
  }
  
  sub _main_docfile {
    my $self = shift;
    if ( my $pm_file = $self->dist_version_from ) {
      (my $pod_file = $pm_file) =~ s/.pm$/.pod/;
      return (-e $pod_file ? $pod_file : $pm_file);
    } else {
      return undef;
    }
  }
  
  sub do_create_bundle_inc {
    my $self = shift;
    my $dist_inc = File::Spec->catdir( $self->dist_dir, 'inc' );
    require inc::latest;
    inc::latest->write($dist_inc, @{$self->bundle_inc_preload});
    inc::latest->bundle_module($_, $dist_inc) for @{$self->bundle_inc};
    return 1;
  }
  
  sub ACTION_distdir {
    my ($self) = @_;
  
    if ( @{$self->bundle_inc} && ! $self->_mb_feature('inc_bundling_support') ) {
      $self->_warn_mb_feature_deps('inc_bundling_support');
      die "Aborting.\n";
    }
  
    $self->depends_on('distmeta');
  
    my $dist_files = $self->_read_manifest('MANIFEST')
      or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";
    delete $dist_files->{SIGNATURE};  # Don't copy, create a fresh one
    die "No files found in MANIFEST - try running 'manifest' action?\n"
      unless ($dist_files and keys %$dist_files);
    my $metafile = $self->metafile;
    $self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")
      unless exists $dist_files->{$metafile};
  
    my $dist_dir = $self->dist_dir;
    $self->delete_filetree($dist_dir);
    $self->log_info("Creating $dist_dir\n");
    $self->add_to_cleanup($dist_dir);
  
    foreach my $file (sort keys %$dist_files) {
      next if $file =~ m{^MYMETA\.}; # Double check that we skip MYMETA.*
      my $new = $self->copy_if_modified(from => $file, to_dir => $dist_dir, verbose => 0);
    }
  
    $self->do_create_bundle_inc if @{$self->bundle_inc};
  
    $self->_sign_dir($dist_dir) if $self->{properties}{sign};
  }
  
  sub ACTION_disttest {
    my ($self) = @_;
  
    $self->depends_on('distdir');
  
    $self->_do_in_dir
      ( $self->dist_dir,
        sub {
          local $ENV{AUTHOR_TESTING}  = 1;
          local $ENV{RELEASE_TESTING} = 1;
  
          # XXX could be different names for scripts
  
          $self->run_perl_script('Build.PL') # XXX Should this be run w/ --nouse-rcfile
            or die "Error executing 'Build.PL' in dist directory: $!";
          $self->run_perl_script($self->build_script)
            or die "Error executing $self->build_script in dist directory: $!";
          $self->run_perl_script($self->build_script, [], ['test'])
            or die "Error executing 'Build test' in dist directory";
        });
  }
  
  sub ACTION_distinstall {
    my ($self, @args) = @_;
  
    $self->depends_on('distdir');
  
    $self->_do_in_dir ( $self->dist_dir,
      sub {
        $self->run_perl_script('Build.PL')
          or die "Error executing 'Build.PL' in dist directory: $!";
        $self->run_perl_script($self->build_script)
          or die "Error executing $self->build_script in dist directory: $!";
        $self->run_perl_script($self->build_script, [], ['install'])
          or die "Error executing 'Build install' in dist directory";
      }
    );
  }
  
  =begin private
  
    my $has_include = $build->_eumanifest_has_include;
  
  Returns true if the installed version of ExtUtils::Manifest supports
  #include and #include_default directives.  False otherwise.
  
  =end private
  
  =cut
  
  # #!include and #!include_default were added in 1.50
  sub _eumanifest_has_include {
      my $self = shift;
  
      require ExtUtils::Manifest;
      return eval { ExtUtils::Manifest->VERSION(1.50); 1 };
  }
  
  
  =begin private
  
    my $maniskip_file = $build->_default_maniskip;
  
  Returns the location of the installed MANIFEST.SKIP file used by
  default.
  
  =end private
  
  =cut
  
  sub _default_maniskip {
      my $self = shift;
  
      my $default_maniskip;
      for my $dir (@INC) {
          $default_maniskip = File::Spec->catfile($dir, "ExtUtils", "MANIFEST.SKIP");
          last if -r $default_maniskip;
      }
  
      return $default_maniskip;
  }
  
  
  =begin private
  
    my $content = $build->_slurp($file);
  
  Reads $file and returns the $content.
  
  =end private
  
  =cut
  
  sub _slurp {
      my $self = shift;
      my $file = shift;
      my $mode = shift || "";
      open my $fh, "<$mode", $file or croak "Can't open $file for reading: $!";
      local $/;
      return <$fh>;
  }
  
  sub _spew {
      my $self = shift;
      my $file = shift;
      my $content = shift || "";
      my $mode = shift || "";
      open my $fh, ">$mode", $file or croak "Can't open $file for writing: $!";
      print {$fh} $content;
      close $fh;
  }
  
  sub _case_tolerant {
    my $self = shift;
    if ( ref $self ) {
      $self->{_case_tolerant} = File::Spec->case_tolerant
        unless defined($self->{_case_tolerant});
      return $self->{_case_tolerant};
    }
    else {
      return File::Spec->case_tolerant;
    }
  }
  
  sub _append_maniskip {
    my $self = shift;
    my $skip = shift;
    my $file = shift || 'MANIFEST.SKIP';
    return unless defined $skip && length $skip;
    open(my $fh, '>>', $file)
      or die "Can't open $file: $!";
  
    print $fh "$skip\n";
    close $fh;
  }
  
  sub _write_default_maniskip {
    my $self = shift;
    my $file = shift || 'MANIFEST.SKIP';
    open(my $fh, '>', $file)
      or die "Can't open $file: $!";
  
    my $content = $self->_eumanifest_has_include ? "#!include_default\n"
                                                 : $self->_slurp( $self->_default_maniskip );
  
    $content .= <<'EOF';
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
  
    # Skip, for example, 'Module-Build-0.27.tar.gz'
    $content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";
  
    print $fh $content;
    
    close $fh;
  
    return;
  }
  
  sub _check_manifest_skip {
    my ($self) = @_;
  
    my $maniskip = 'MANIFEST.SKIP';
  
    if ( ! -e $maniskip ) {
      $self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");
      $self->_write_default_maniskip($maniskip);
      $self->_unlink_on_exit($maniskip);
    }
    else {
      # MYMETA must not be added to MANIFEST, so always confirm the skip
      $self->_check_mymeta_skip( $maniskip );
    }
  
    return;
  }
  
  sub ACTION_manifest {
    my ($self) = @_;
  
    $self->_check_manifest_skip;
  
    require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
    local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
    ExtUtils::Manifest::mkmanifest();
  }
  
  sub ACTION_manifest_skip {
    my ($self) = @_;
  
    if ( -e 'MANIFEST.SKIP' ) {
      $self->log_warn("MANIFEST.SKIP already exists.\n");
      return 0;
    }
    $self->log_info("Creating a new MANIFEST.SKIP file\n");
    return $self->_write_default_maniskip;
    return -e 'MANIFEST.SKIP'
  }
  
  # Case insensitive regex for files
  sub file_qr {
      return shift->{_case_tolerant} ? qr($_[0])i : qr($_[0]);
  }
  
  sub dist_dir {
    my ($self) = @_;
    my $dir = join "-", $self->dist_name, $self->dist_version;
    $dir .= "-" . $self->dist_suffix if $self->dist_suffix;
    return $dir;
  }
  
  sub ppm_name {
    my $self = shift;
    return 'PPM-' . $self->dist_dir;
  }
  
  sub _files_in {
    my ($self, $dir) = @_;
    return unless -d $dir;
  
    local *DH;
    opendir DH, $dir or die "Can't read directory $dir: $!";
  
    my @files;
    while (defined (my $file = readdir DH)) {
      my $full_path = File::Spec->catfile($dir, $file);
      next if -d $full_path;
      push @files, $full_path;
    }
    return @files;
  }
  
  sub share_dir {
    my $self = shift;
    my $p = $self->{properties};
  
    $p->{share_dir} = shift if @_;
  
    # Always coerce to proper hash form
    if    ( ! defined $p->{share_dir} ) {
      return;
    }
    elsif ( ! ref $p->{share_dir}  ) {
      # scalar -- treat as a single 'dist' directory
      $p->{share_dir} = { dist => [ $p->{share_dir} ] };
    }
    elsif ( ref $p->{share_dir} eq 'ARRAY' ) {
      # array -- treat as a list of 'dist' directories
      $p->{share_dir} = { dist => $p->{share_dir} };
    }
    elsif ( ref $p->{share_dir} eq 'HASH' ) {
      # hash -- check structure
      my $share_dir = $p->{share_dir};
      # check dist key
      if ( defined $share_dir->{dist} ) {
        if ( ! ref $share_dir->{dist} ) {
          # scalar, so upgrade to arrayref
          $share_dir->{dist} = [ $share_dir->{dist} ];
        }
        elsif ( ref $share_dir->{dist} ne 'ARRAY' ) {
          die "'dist' key in 'share_dir' must be scalar or arrayref";
        }
      }
      # check module key
      if ( defined $share_dir->{module} ) {
        my $mod_hash = $share_dir->{module};
        if ( ref $mod_hash eq 'HASH' ) {
          for my $k ( sort keys %$mod_hash ) {
            if ( ! ref $mod_hash->{$k} ) {
              $mod_hash->{$k} = [ $mod_hash->{$k} ];
            }
            elsif( ref $mod_hash->{$k} ne 'ARRAY' ) {
              die "modules in 'module' key of 'share_dir' must be scalar or arrayref";
            }
          }
        }
        else {
            die "'module' key in 'share_dir' must be hashref";
        }
      }
    }
    else {
      die "'share_dir' must be hashref, arrayref or string";
    }
  
    return $p->{share_dir};
  }
  
  sub script_files {
    my $self = shift;
  
    for ($self->{properties}{script_files}) {
      $_ = shift if @_;
      next unless $_;
  
      # Always coerce into a hash
      return $_ if ref $_ eq 'HASH';
      return $_ = { map {$_,1} @$_ } if ref $_ eq 'ARRAY';
  
      die "'script_files' must be a hashref, arrayref, or string" if ref();
  
      return $_ = { map {$_,1} $self->_files_in( $_ ) } if -d $_;
      return $_ = {$_ => 1};
    }
  
    my %pl_files = map {
      File::Spec->canonpath( $_ ) => 1
    } keys %{ $self->PL_files || {} };
  
    my @bin_files = $self->_files_in('bin');
  
    my %bin_map = map {
      $_ => File::Spec->canonpath( $_ )
    } @bin_files;
  
    return $_ = { map {$_ => 1} grep !$pl_files{$bin_map{$_}}, @bin_files };
  }
  BEGIN { *scripts = \&script_files; }
  
  {
    my %licenses = (
      perl         => 'Perl_5',
      apache       => 'Apache_2_0',
      apache_1_1   => 'Apache_1_1',
      artistic     => 'Artistic_1',
      artistic_2   => 'Artistic_2',
      lgpl         => 'LGPL_2_1',
      lgpl2        => 'LGPL_2_1',
      lgpl3        => 'LGPL_3_0',
      bsd          => 'BSD',
      gpl          => 'GPL_1',
      gpl2         => 'GPL_2',
      gpl3         => 'GPL_3',
      mit          => 'MIT',
      mozilla      => 'Mozilla_1_1',
      restrictive  => 'Restricted',
      open_source  => undef,
      unrestricted => undef,
      unknown      => undef,
    );
  
    # TODO - would be nice to not have these here, since they're more
    # properly stored only in Software::License
    my %license_urls = (
      perl         => 'http://dev.perl.org/licenses/',
      apache       => 'http://apache.org/licenses/LICENSE-2.0',
      apache_1_1   => 'http://apache.org/licenses/LICENSE-1.1',
      artistic     => 'http://opensource.org/licenses/artistic-license.php',
      artistic_2   => 'http://opensource.org/licenses/artistic-license-2.0.php',
      lgpl         => 'http://opensource.org/licenses/lgpl-license.php',
      lgpl2        => 'http://opensource.org/licenses/lgpl-2.1.php',
      lgpl3        => 'http://opensource.org/licenses/lgpl-3.0.html',
      bsd          => 'http://opensource.org/licenses/bsd-license.php',
      gpl          => 'http://opensource.org/licenses/gpl-license.php',
      gpl2         => 'http://opensource.org/licenses/gpl-2.0.php',
      gpl3         => 'http://opensource.org/licenses/gpl-3.0.html',
      mit          => 'http://opensource.org/licenses/mit-license.php',
      mozilla      => 'http://opensource.org/licenses/mozilla1.1.php',
      restrictive  => undef,
      open_source  => undef,
      unrestricted => undef,
      unknown      => undef,
    );
    sub valid_licenses {
      return \%licenses;
    }
    sub _license_url {
      return $license_urls{$_[1]};
    }
  }
  
  sub _software_license_class {
    my ($self, $license) = @_;
    if ($self->valid_licenses->{$license} && eval { require Software::LicenseUtils; Software::LicenseUtils->VERSION(0.103009) }) {
      my @classes = Software::LicenseUtils->guess_license_from_meta_key($license, 1);
      if (@classes == 1) {
        eval "require $classes[0]";
        return $classes[0];
      }
    }
    LICENSE: for my $l ( $self->valid_licenses->{ $license }, $license ) {
      next unless defined $l;
      my $trial = "Software::License::" . $l;
      if ( eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1" ) {
        return $trial;
      }
    }
    return;
  }
  
  # use mapping or license name directly
  sub _software_license_object {
    my ($self) = @_;
    return unless defined( my $license = $self->license );
  
    my $class = $self->_software_license_class($license) or return;
  
    # Software::License requires a 'holder' argument
    my $author = join( " & ", @{ $self->dist_author }) || 'unknown';
    my $sl = eval { $class->new({holder=>$author}) };
    if ( $@ ) {
      $self->log_warn( "Error getting '$class' object: $@" );
    }
  
    return $sl;
  }
  
  sub _hash_merge {
    my ($self, $h, $k, $v) = @_;
    if (ref $h->{$k} eq 'ARRAY') {
      push @{$h->{$k}}, ref $v ? @$v : $v;
    } elsif (ref $h->{$k} eq 'HASH') {
      $h->{$k}{$_} = $v->{$_} foreach keys %$v;
    } else {
      $h->{$k} = $v;
    }
  }
  
  sub ACTION_distmeta {
    my ($self) = @_;
    $self->do_create_makefile_pl if $self->create_makefile_pl;
    $self->do_create_readme if $self->create_readme;
    $self->do_create_license if $self->create_license;
    $self->do_create_metafile;
  }
  
  sub do_create_metafile {
    my $self = shift;
    return if $self->{wrote_metadata};
  
    my $p = $self->{properties};
  
    unless ($p->{license}) {
      $self->log_warn("No license specified, setting license = 'unknown'\n");
      $p->{license} = 'unknown';
    }
  
    my @metafiles = ( $self->metafile, $self->metafile2 );
    # If we're in the distdir, the metafile may exist and be non-writable.
    $self->delete_filetree($_) for @metafiles;
  
    # Since we're building ourself, we have to do some special stuff
    # here: the ConfigData module is found in blib/lib.
    local @INC = @INC;
    if (($self->module_name || '') eq 'Module::Build') {
      $self->depends_on('config_data');
      push @INC, File::Spec->catdir($self->blib, 'lib');
    }
  
    my $meta_obj = $self->_get_meta_object(
      quiet => 1, fatal => 1, auto => 1
    );
    my @created = $self->_write_meta_files( $meta_obj, 'META' );
    if ( @created ) {
      $self->{wrote_metadata} = 1;
      $self->_add_to_manifest('MANIFEST', $_) for @created;
    }
    return 1;
  }
  
  sub _write_meta_files {
    my $self = shift;
    my ($meta, $file) = @_;
    $file =~ s{\.(?:yml|json)$}{};
  
    my @created;
    push @created, "$file\.yml"
      if $meta && $meta->save( "$file\.yml", {version => "1.4"} );
    push @created, "$file\.json"
      if $meta && $meta->save( "$file\.json" );
  
    if ( @created ) {
      $self->log_info("Created " . join(" and ", @created) . "\n");
    }
    return @created;
  }
  
  sub _get_meta_object {
    my $self = shift;
    my %args = @_;
    return unless $self->try_require("CPAN::Meta", "2.142060");
  
    my $meta;
    eval {
      my $data = $self->get_metadata(
        fatal => $args{fatal},
        auto => $args{auto},
      );
      $data->{dynamic_config} = $args{dynamic} if defined $args{dynamic};
      $meta = CPAN::Meta->create($data);
    };
    if ($@ && ! $args{quiet}) {
      $self->log_warn(
        "Could not get valid metadata. Error is: $@\n"
      );
    }
  
    return $meta;
  }
  
  sub read_metafile {
    my $self = shift;
    my ($metafile) = @_;
  
    return unless $self->try_require("CPAN::Meta", "2.110420");
    my $meta = CPAN::Meta->load_file($metafile);
    return $meta->as_struct( {version => "2.0"} );
  }
  
  sub normalize_version {
    my ($self, $version) = @_;
    $version = 0 unless defined $version and length $version;
  
    if ( $version =~ /[=<>!,]/ ) { # logic, not just version
      # take as is without modification
    }
    elsif ( ref $version eq 'version') { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  }
  
  my %prereq_map = (
    requires => [ qw/runtime requires/],
    configure_requires => [qw/configure requires/],
    build_requires => [ qw/build requires/ ],
    test_requires => [ qw/test requires/ ],
    test_recommends => [ qw/test recommends/ ],
    recommends => [ qw/runtime recommends/ ],
    conflicts => [ qw/runtime conflicts/ ],
  );
  
  sub _normalize_prereqs {
    my ($self) = @_;
    my $p = $self->{properties};
  
    # copy prereq data structures so we can modify them before writing to META
    my %prereq_types;
    for my $type ( 'configure_requires', @{$self->prereq_action_types} ) {
      if (exists $p->{$type} and keys %{ $p->{$type} }) {
        my ($phase, $relation) = @{ $prereq_map{$type} };
        for my $mod ( keys %{ $p->{$type} } ) {
          $prereq_types{$phase}{$relation}{$mod} = $self->normalize_version($p->{$type}{$mod});
        }
      }
    }
    return \%prereq_types;
  }
  
  sub _get_license {
    my $self = shift;
  
    my $license = $self->license;
    my ($meta_license, $meta_license_url);
  
    my $valid_licenses = $self->valid_licenses();
    if ( my $sl = $self->_software_license_object ) {
      $meta_license = $sl->meta2_name;
      $meta_license_url = $sl->url;
    }
    elsif ( exists $valid_licenses->{$license} ) {
      $meta_license = $valid_licenses->{$license} ? lc $valid_licenses->{$license} : $license;
      $meta_license_url = $self->_license_url( $license );
    }
    else {
      $self->log_warn( "Can not determine license type for '" . $self->license
        . "'\nSetting META license field to 'unknown'.\n");
      $meta_license = 'unknown';
    }
    return ($meta_license, $meta_license_url);
  }
  
  sub get_metadata {
    my ($self, %args) = @_;
  
    my $fatal = $args{fatal} || 0;
    my $p = $self->{properties};
  
    $self->auto_config_requires if $args{auto};
  
    # validate required fields
    foreach my $f (qw(dist_name dist_version dist_author dist_abstract license)) {
      my $field = $self->$f();
      unless ( defined $field and length $field ) {
        my $err = "ERROR: Missing required field '$f' for metafile\n";
        if ( $fatal ) {
          die $err;
        }
        else {
          $self->log_warn($err);
        }
      }
    }
  
    my %metadata = (
      name => $self->dist_name,
      version => $self->normalize_version($self->dist_version),
      author => $self->dist_author,
      abstract => $self->dist_abstract,
      generated_by => "Module::Build version $Module::Build::VERSION",
      'meta-spec' => {
        version => '2',
        url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
      },
      dynamic_config => exists $p->{dynamic_config} ? $p->{dynamic_config} : 1,
      release_status => $self->release_status,
    );
  
    my ($meta_license, $meta_license_url) = $self->_get_license;
    $metadata{license} = [ $meta_license ];
    $metadata{resources}{license} = [ $meta_license_url ] if defined $meta_license_url;
  
    $metadata{prereqs} = $self->_normalize_prereqs;
  
    if (exists $p->{no_index}) {
      $metadata{no_index} = $p->{no_index};
    } elsif (my $pkgs = eval { $self->find_dist_packages }) {
      $metadata{provides} = $pkgs if %$pkgs;
    } else {
      $self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" .
                      "Nothing to enter for 'provides' field in metafile.\n");
    }
  
    if (my $add = $self->meta_add) {
      if (not exists $add->{'meta-spec'} or $add->{'meta-spec'}{version} != 2) {
        require CPAN::Meta::Converter;
        if (CPAN::Meta::Converter->VERSION('2.141170')) {
          $add = CPAN::Meta::Converter->new($add)->upgrade_fragment;
          delete $add->{prereqs}; # XXX this would now overwrite all prereqs
        }
        else {
          $self->log_warn("Can't meta_add without CPAN::Meta 2.141170");
        }
      }
  
      while (my($k, $v) = each %{$add}) {
        $metadata{$k} = $v;
      }
    }
  
    if (my $merge = $self->meta_merge) {
      if (eval { require CPAN::Meta::Merge }) {
        %metadata = %{ CPAN::Meta::Merge->new(default_version => '1.4')->merge(\%metadata, $merge) };
      }
      else {
        $self->log_warn("Can't merge without CPAN::Meta::Merge");
      }
    }
  
    return \%metadata;
  }
  
  # To preserve compatibility with old API, $node *must* be a hashref
  # passed in to prepare_metadata.  $keys is an arrayref holding a
  # list of keys -- it's use is optional and generally no longer needed
  # but kept for back compatibility.  $args is an optional parameter to
  # support the new 'fatal' toggle
  
  sub prepare_metadata {
    my ($self, $node, $keys, $args) = @_;
    unless ( ref $node eq 'HASH' ) {
      croak "prepare_metadata() requires a hashref argument to hold output\n";
    }
    croak 'Keys argument to prepare_metadata is no longer supported' if $keys;
    %{$node} = %{ $self->get_meta(%{$args}) };
    return $node;
  }
  
  sub _read_manifest {
    my ($self, $file) = @_;
    return undef unless -e $file;
  
    require ExtUtils::Manifest;  # ExtUtils::Manifest is not warnings clean.
    local ($^W, $ExtUtils::Manifest::Quiet) = (0,1);
    return scalar ExtUtils::Manifest::maniread($file);
  }
  
  sub find_dist_packages {
    my $self = shift;
  
    # Only packages in .pm files are candidates for inclusion here.
    # Only include things in the MANIFEST, not things in developer's
    # private stock.
  
    my $manifest = $self->_read_manifest('MANIFEST')
      or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";
  
    # Localize
    my %dist_files = map { $self->localize_file_path($_) => $_ }
                         keys %$manifest;
  
    my @pm_files = sort grep { $_ !~ m{^t} } # skip things in t/
                     grep {exists $dist_files{$_}}
                       keys %{ $self->find_pm_files };
  
    return $self->find_packages_in_files(\@pm_files, \%dist_files);
  }
  
  # XXX Do not document this function; mst wrote it and now says the API is
  # stupid and needs to be fixed and it shouldn't become a public API until then
  sub find_packages_in_files {
    my ($self, $file_list, $filename_map) = @_;
  
    # First, we enumerate all packages & versions,
    # separating into primary & alternative candidates
    my( %prime, %alt );
    foreach my $file (@{$file_list}) {
      my $mapped_filename = $filename_map->{$file};
      my @path = split( /\//, $mapped_filename );
      (my $prime_package = join( '::', @path[1..$#path] )) =~ s/\.pm$//;
  
      my $pm_info = Module::Metadata->new_from_file( $file );
  
      foreach my $package ( $pm_info->packages_inside ) {
        next if $package eq 'main';  # main can appear numerous times, ignore
        next if $package eq 'DB';    # special debugging package, ignore
        next if grep /^_/, split( /::/, $package ); # private package, ignore
  
        my $version = $pm_info->version( $package );
  
        if ( $package eq $prime_package ) {
          if ( exists( $prime{$package} ) ) {
            # Module::Metadata will handle this conflict
            die "Unexpected conflict in '$package'; multiple versions found.\n";
          } else {
            $prime{$package}{file} = $mapped_filename;
            $prime{$package}{version} = $version if defined( $version );
          }
        } else {
          push( @{$alt{$package}}, {
                                    file    => $mapped_filename,
                                    version => $version,
                                   } );
        }
      }
    }
  
    # Then we iterate over all the packages found above, identifying conflicts
    # and selecting the "best" candidate for recording the file & version
    # for each package.
    foreach my $package ( sort keys( %alt ) ) {
      my $result = $self->_resolve_module_versions( $alt{$package} );
  
      if ( exists( $prime{$package} ) ) { # primary package selected
  
        if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
          $self->log_warn(
            "Found conflicting versions for package '$package'\n" .
            "  $prime{$package}{file} ($prime{$package}{version})\n" .
            $result->{err}
          );
  
        } elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
            if ( $self->compare_versions( $prime{$package}{version}, '!=',
                                          $result->{version} ) ) {
              $self->log_warn(
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              );
            }
  
          } else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
        } else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
        }
  
      } else { # No primary package was selected, use the best alternative
  
        if ( $result->{err} ) {
          $self->log_warn(
            "Found conflicting versions for package '$package'\n" .
            $result->{err}
          );
        }
  
        # Despite possible conflicting versions, we choose to record
        # something rather than nothing
        $prime{$package}{file}    = $result->{file};
        $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
      }
    }
  
    # Normalize versions or delete them if undef/0
    for my $provides ( values %prime ) {
      if ( $provides->{version} ) {
        $provides->{version} = $self->normalize_version( $provides->{version} )
      }
      else {
        delete $provides->{version};
      }
    }
  
    return \%prime;
  }
  
  # separate out some of the conflict resolution logic from
  # $self->find_dist_packages(), above, into a helper function.
  #
  sub _resolve_module_versions {
    my $self = shift;
  
    my $packages = shift;
  
    my( $file, $version );
    my $err = '';
      foreach my $p ( @$packages ) {
        if ( defined( $p->{version} ) ) {
          if ( defined( $version ) ) {
            if ( $self->compare_versions( $version, '!=', $p->{version} ) ) {
              $err .= "  $p->{file} ($p->{version})\n";
            } else {
              # same version declared multiple times, ignore
            }
          } else {
            $file    = $p->{file};
            $version = $p->{version};
          }
        }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
    if ( $err ) {
      $err = "  $file ($version)\n" . $err;
    }
  
    my %result = (
      file    => $file,
      version => $version,
      err     => $err
    );
  
    return \%result;
  }
  
  sub make_tarball {
    my ($self, $dir, $file) = @_;
    $file ||= $dir;
  
    $self->log_info("Creating $file.tar.gz\n");
  
    if ($self->{args}{tar}) {
      my $tar_flags = $self->verbose ? 'cvf' : 'cf';
      $self->do_system($self->split_like_shell($self->{args}{tar}), $tar_flags, "$file.tar", $dir);
      $self->do_system($self->split_like_shell($self->{args}{gzip}), "$file.tar") if $self->{args}{gzip};
    } else {
      eval { require Archive::Tar && Archive::Tar->VERSION(1.09); 1 }
        or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n".
               "or specify a binary tar program with the '--tar' option.\n".
               "See the documentation for the 'dist' action.\n";
  
      my $files = $self->rscan_dir($dir);
  
      # Archive::Tar versions >= 1.09 use the following to enable a compatibility
      # hack so that the resulting archive is compatible with older clients.
      # If no file path is 100 chars or longer, we disable the prefix field
      # for maximum compatibility.  If there are any long file paths then we
      # need the prefix field after all.
      $Archive::Tar::DO_NOT_USE_PREFIX =
        (grep { length($_) >= 100 } @$files) ? 0 : 1;
  
      my $tar   = Archive::Tar->new;
      $tar->add_files(@$files);
      for my $f ($tar->get_files) {
        $f->mode($f->mode & ~022); # chmod go-w
      }
      $tar->write("$file.tar.gz", 1);
    }
  }
  
  sub install_path {
    my $self = shift;
    my( $type, $value ) = ( @_, '<empty>' );
  
    Carp::croak( 'Type argument missing' )
      unless defined( $type );
  
    my $map = $self->{properties}{install_path};
    return $map unless @_;
  
    # delete existing value if $value is literal undef()
    unless ( defined( $value ) ) {
      delete( $map->{$type} );
      return undef;
    }
  
    # return existing value if no new $value is given
    if ( $value eq '<empty>' ) {
      return undef unless exists $map->{$type};
      return $map->{$type};
    }
  
    # set value if $value is a valid relative path
    return $map->{$type} = $value;
  }
  
  sub install_sets {
    # Usage: install_sets('site'), install_sets('site', 'lib'),
    #   or install_sets('site', 'lib' => $value);
    my ($self, $dirs, $key, $value) = @_;
    $dirs = $self->installdirs unless defined $dirs;
    # update property before merging with defaults
    if ( @_ == 4 && defined $dirs && defined $key) {
      # $value can be undef; will mask default
      $self->{properties}{install_sets}{$dirs}{$key} = $value;
    }
    my $map = { $self->_merge_arglist(
      $self->{properties}{install_sets},
      $self->_default_install_paths->{install_sets}
    )};
    if ( defined $dirs && defined $key ) {
      return $map->{$dirs}{$key};
    }
    elsif ( defined $dirs ) {
      return $map->{$dirs};
    }
    else {
      croak "Can't determine installdirs for install_sets()";
    }
  }
  
  sub original_prefix {
    # Usage: original_prefix(), original_prefix('lib'),
    #   or original_prefix('lib' => $value);
    my ($self, $key, $value) = @_;
    # update property before merging with defaults
    if ( @_ == 3 && defined $key) {
      # $value can be undef; will mask default
      $self->{properties}{original_prefix}{$key} = $value;
    }
    my $map = { $self->_merge_arglist(
      $self->{properties}{original_prefix},
      $self->_default_install_paths->{original_prefix}
    )};
    return $map unless defined $key;
    return $map->{$key}
  }
  
  sub install_base_relpaths {
    # Usage: install_base_relpaths(), install_base_relpaths('lib'),
    #   or install_base_relpaths('lib' => $value);
    my $self = shift;
    if ( @_ > 1 ) { # change values before merge
      $self->_set_relpaths($self->{properties}{install_base_relpaths}, @_);
    }
    my $map = { $self->_merge_arglist(
      $self->{properties}{install_base_relpaths},
      $self->_default_install_paths->{install_base_relpaths}
    )};
    return $map unless @_;
    my $relpath = $map->{$_[0]};
    return defined $relpath ? File::Spec->catdir( @$relpath ) : undef;
  }
  
  # Defaults to use in case the config install paths cannot be prefixified.
  sub prefix_relpaths {
    # Usage: prefix_relpaths('site'), prefix_relpaths('site', 'lib'),
    #   or prefix_relpaths('site', 'lib' => $value);
    my $self = shift;
    my $installdirs = shift || $self->installdirs
      or croak "Can't determine installdirs for prefix_relpaths()";
    if ( @_ > 1 ) { # change values before merge
      $self->{properties}{prefix_relpaths}{$installdirs} ||= {};
      $self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs}, @_);
    }
    my $map = {$self->_merge_arglist(
      $self->{properties}{prefix_relpaths}{$installdirs},
      $self->_default_install_paths->{prefix_relpaths}{$installdirs}
    )};
    return $map unless @_;
    my $relpath = $map->{$_[0]};
    return defined $relpath ? File::Spec->catdir( @$relpath ) : undef;
  }
  
  sub _set_relpaths {
    my $self = shift;
    my( $map, $type, $value ) = @_;
  
    Carp::croak( 'Type argument missing' )
      unless defined( $type );
  
    # set undef if $value is literal undef()
    if ( ! defined( $value ) ) {
      $map->{$type} = undef;
      return;
    }
    # set value if $value is a valid relative path
    else {
      Carp::croak( "Value must be a relative path" )
        if File::Spec::Unix->file_name_is_absolute($value);
  
      my @value = split( /\//, $value );
      $map->{$type} = \@value;
    }
  }
  
  # Translated from ExtUtils::MM_Any::init_INSTALL_from_PREFIX
  sub prefix_relative {
    my ($self, $type) = @_;
    my $installdirs = $self->installdirs;
  
    my $relpath = $self->install_sets($installdirs)->{$type};
  
    return $self->_prefixify($relpath,
                             $self->original_prefix($installdirs),
                             $type,
                            );
  }
  
  # Translated from ExtUtils::MM_Unix::prefixify()
  sub _prefixify {
    my($self, $path, $sprefix, $type) = @_;
  
    my $rprefix = $self->prefix;
    $rprefix .= '/' if $sprefix =~ m|/$|;
  
    $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")
      if defined( $path ) && length( $path );
  
    if( !defined( $path ) || ( length( $path ) == 0 ) ) {
      $self->log_verbose("  no path to prefixify, falling back to default.\n");
      return $self->_prefixify_default( $type, $rprefix );
    } elsif( !File::Spec->file_name_is_absolute($path) ) {
      $self->log_verbose("    path is relative, not prefixifying.\n");
    } elsif( $path !~ s{^\Q$sprefix\E\b}{}s ) {
      $self->log_verbose("    cannot prefixify, falling back to default.\n");
      return $self->_prefixify_default( $type, $rprefix );
    }
  
    $self->log_verbose("    now $path in $rprefix\n");
  
    return $path;
  }
  
  sub _prefixify_default {
    my $self = shift;
    my $type = shift;
    my $rprefix = shift;
  
    my $default = $self->prefix_relpaths($self->installdirs, $type);
    if( !$default ) {
      $self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");
      return $rprefix;
    } else {
      return $default;
    }
  }
  
  sub install_destination {
    my ($self, $type) = @_;
  
    return $self->install_path($type) if $self->install_path($type);
  
    if ( $self->install_base ) {
      my $relpath = $self->install_base_relpaths($type);
      return $relpath ? File::Spec->catdir($self->install_base, $relpath) : undef;
    }
  
    if ( $self->prefix ) {
      my $relpath = $self->prefix_relative($type);
      return $relpath ? File::Spec->catdir($self->prefix, $relpath) : undef;
    }
  
    return $self->install_sets($self->installdirs)->{$type};
  }
  
  sub install_types {
    my $self = shift;
  
    my %types;
    if ( $self->install_base ) {
      %types = %{$self->install_base_relpaths};
    } elsif ( $self->prefix ) {
      %types = %{$self->prefix_relpaths};
    } else {
      %types = %{$self->install_sets($self->installdirs)};
    }
  
    %types = (%types, %{$self->install_path});
  
    return sort keys %types;
  }
  
  sub install_map {
    my ($self, $blib) = @_;
    $blib ||= $self->blib;
  
    my( %map, @skipping );
    foreach my $type ($self->install_types) {
      my $localdir = File::Spec->catdir( $blib, $type );
      next unless -e $localdir;
  
      # the line "...next if (($type eq 'bindoc'..." was one of many changes introduced for
      # improving HTML generation on ActivePerl, see https://rt.cpan.org/Public/Bug/Display.html?id=53478
      # Most changes were ok, but this particular line caused test failures in t/manifypods.t on windows,
      # therefore it is commented out.
  
      # ********* next if (($type eq 'bindoc' || $type eq 'libdoc') && not $self->is_unixish);
  
      if (my $dest = $self->install_destination($type)) {
        $map{$localdir} = $dest;
      } else {
        push( @skipping, $type );
      }
    }
  
    $self->log_warn(
      "WARNING: Can't figure out install path for types: @skipping\n" .
      "Files will not be installed.\n"
    ) if @skipping;
  
    # Write the packlist into the same place as ExtUtils::MakeMaker.
    if ($self->create_packlist and my $module_name = $self->module_name) {
      my $archdir = $self->install_destination('arch');
      my @ext = split /::/, $module_name;
      $map{write} = File::Spec->catfile($archdir, 'auto', @ext, '.packlist');
    }
  
    # Handle destdir
    if (length(my $destdir = $self->destdir || '')) {
      foreach (keys %map) {
        # Need to remove volume from $map{$_} using splitpath, or else
        # we'll create something crazy like C:\Foo\Bar\E:\Baz\Quux
        # VMS will always have the file separate than the path.
        my ($volume, $path, $file) = File::Spec->splitpath( $map{$_}, 0 );
  
        # catdir needs a list of directories, or it will create something
        # crazy like volume:[Foo.Bar.volume.Baz.Quux]
        my @dirs = File::Spec->splitdir($path);
  
        # First merge the directories
        $path = File::Spec->catdir($destdir, @dirs);
  
        # Then put the file back on if there is one.
        if ($file ne '') {
            $map{$_} = File::Spec->catfile($path, $file)
        } else {
            $map{$_} = $path;
        }
      }
    }
  
    $map{read} = '';  # To keep ExtUtils::Install quiet
  
    return \%map;
  }
  
  sub depends_on {
    my $self = shift;
    foreach my $action (@_) {
      $self->_call_action($action);
    }
  }
  
  sub rscan_dir {
    my ($self, $dir, $pattern) = @_;
    my @result;
    local $_; # find() can overwrite $_, so protect ourselves
    my $subr = !$pattern ? sub {push @result, $File::Find::name} :
               !ref($pattern) || (ref $pattern eq 'Regexp') ? sub {push @result, $File::Find::name if /$pattern/} :
               ref($pattern) eq 'CODE' ? sub {push @result, $File::Find::name if $pattern->()} :
               die "Unknown pattern type";
  
    File::Find::find({wanted => $subr, no_chdir => 1, preprocess => sub { sort @_ } }, $dir);
    return \@result;
  }
  
  sub delete_filetree {
    my $self = shift;
    my $deleted = 0;
    foreach (@_) {
      next unless -e $_;
      $self->log_verbose("Deleting $_\n");
      File::Path::rmtree($_, 0, 0);
      die "Couldn't remove '$_': $!\n" if -e $_;
      $deleted++;
    }
    return $deleted;
  }
  
  sub autosplit_file {
    my ($self, $file, $to) = @_;
    require AutoSplit;
    my $dir = File::Spec->catdir($to, 'lib', 'auto');
    AutoSplit::autosplit($file, $dir);
  }
  
  sub cbuilder {
    # Returns a CBuilder object
  
    my $self = shift;
    my $s = $self->{stash};
    return $s->{_cbuilder} if $s->{_cbuilder};
  
    require ExtUtils::CBuilder;
    return $s->{_cbuilder} = ExtUtils::CBuilder->new(
      config => $self->config,
      ($self->quiet ? (quiet => 1 ) : ()),
    );
  }
  
  sub have_c_compiler {
    my ($self) = @_;
  
    my $p = $self->{properties};
    return $p->{_have_c_compiler} if defined $p->{_have_c_compiler};
  
    $self->log_verbose("Checking if compiler tools configured... ");
    my $b = $self->cbuilder;
    my $have = $b && eval { $b->have_compiler };
    $self->log_verbose($have ? "ok.\n" : "failed.\n");
    return $p->{_have_c_compiler} = $have;
  }
  
  sub compile_c {
    my ($self, $file, %args) = @_;
  
    if ( ! $self->have_c_compiler ) {
      die "Error: no compiler detected to compile '$file'.  Aborting\n";
    }
  
    my $b = $self->cbuilder;
    my $obj_file = $b->object_file($file);
    $self->add_to_cleanup($obj_file);
    return $obj_file if $self->up_to_date($file, $obj_file);
  
    $b->compile(source => $file,
                defines => $args{defines},
                object_file => $obj_file,
                include_dirs => $self->include_dirs,
                extra_compiler_flags => $self->extra_compiler_flags,
               );
  
    return $obj_file;
  }
  
  sub link_c {
    my ($self, $spec) = @_;
    my $p = $self->{properties}; # For convenience
  
    $self->add_to_cleanup($spec->{lib_file});
  
    my $objects = $p->{objects} || [];
  
    return $spec->{lib_file}
      if $self->up_to_date([$spec->{obj_file}, @$objects],
                           $spec->{lib_file});
  
    my $module_name = $spec->{module_name} || $self->module_name;
  
    $self->cbuilder->link(
      module_name => $module_name,
      objects     => [$spec->{obj_file}, @$objects],
      lib_file    => $spec->{lib_file},
      extra_linker_flags => $self->extra_linker_flags );
  
    return $spec->{lib_file};
  }
  
  sub compile_xs {
    my ($self, $file, %args) = @_;
  
    $self->log_verbose("$file -> $args{outfile}\n");
  
    if (eval {require ExtUtils::ParseXS; 1}) {
  
      ExtUtils::ParseXS::process_file(
                                      filename => $file,
                                      prototypes => 0,
                                      output => $args{outfile},
                                     );
    } else {
      # Ok, I give up.  Just use backticks.
  
      my $xsubpp = Module::Metadata->find_module_by_name('ExtUtils::xsubpp')
        or die "Can't find ExtUtils::xsubpp in INC (@INC)";
  
      my @typemaps;
      push @typemaps, Module::Metadata->find_module_by_name(
          'ExtUtils::typemap', \@INC
      );
      my $lib_typemap = Module::Metadata->find_module_by_name(
          'typemap', [File::Basename::dirname($file), File::Spec->rel2abs('.')]
      );
      push @typemaps, $lib_typemap if $lib_typemap;
      @typemaps = map {+'-typemap', $_} @typemaps;
  
      my $cf = $self->{config};
      my $perl = $self->{properties}{perl};
  
      my @command = ($perl, "-I".$cf->get('installarchlib'), "-I".$cf->get('installprivlib'), $xsubpp, '-noprototypes',
                     @typemaps, $file);
  
      $self->log_info("@command\n");
      open(my $fh, '>', $args{outfile}) or die "Couldn't write $args{outfile}: $!";
      print {$fh} $self->_backticks(@command);
      close $fh;
    }
  }
  
  sub split_like_shell {
    my ($self, $string) = @_;
  
    return () unless defined($string);
    return @$string if ref $string eq 'ARRAY';
    $string =~ s/^\s+|\s+$//g;
    return () unless length($string);
  
    return Text::ParseWords::shellwords($string);
  }
  
  sub oneliner {
    # Returns a string that the shell can evaluate as a perl command.
    # This should be avoided whenever possible, since "the shell" really
    # means zillions of shells on zillions of platforms and it's really
    # hard to get it right all the time.
  
    # Some of this code is stolen with permission from ExtUtils::MakeMaker.
  
    my($self, $cmd, $switches, $args) = @_;
    $switches = [] unless defined $switches;
    $args = [] unless defined $args;
  
    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};
  
    my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
    return $self->_quote_args($perl, @$switches, '-e', $cmd, @$args);
  }
  
  sub run_perl_script {
    my ($self, $script, $preargs, $postargs) = @_;
    foreach ($preargs, $postargs) {
      $_ = [ $self->split_like_shell($_) ] unless ref();
    }
    return $self->run_perl_command([@$preargs, $script, @$postargs]);
  }
  
  sub run_perl_command {
    # XXX Maybe we should accept @args instead of $args?  Must resolve
    # this before documenting.
    my ($self, $args) = @_;
    $args = [ $self->split_like_shell($args) ] unless ref($args);
    my $perl = ref($self) ? $self->perl : $self->find_perl_interpreter;
  
    # Make sure our local additions to @INC are propagated to the subprocess
    local $ENV{PERL5LIB} = join $self->config('path_sep'), $self->_added_to_INC;
  
    return $self->do_system($perl, @$args);
  }
  
  # Infer various data from the path of the input filename
  # that is needed to create output files.
  # The input filename is expected to be of the form:
  #   lib/Module/Name.ext or Module/Name.ext
  sub _infer_xs_spec {
    my $self = shift;
    my $file = shift;
  
    my $cf = $self->{config};
  
    my %spec;
  
    my( $v, $d, $f ) = File::Spec->splitpath( $file );
    my @d = File::Spec->splitdir( $d );
    (my $file_base = $f) =~ s/\.[^.]+$//i;
  
    $spec{base_name} = $file_base;
  
    $spec{src_dir} = File::Spec->catpath( $v, $d, '' );
  
    # the module name
    shift( @d ) while @d && ($d[0] eq 'lib' || $d[0] eq '');
    pop( @d ) while @d && $d[-1] eq '';
    $spec{module_name} = join( '::', (@d, $file_base) );
  
    $spec{archdir} = File::Spec->catdir($self->blib, 'arch', 'auto',
                                        @d, $file_base);
  
    $spec{c_file} = File::Spec->catfile( $spec{src_dir},
                                         "${file_base}.c" );
  
    $spec{obj_file} = File::Spec->catfile( $spec{src_dir},
                                           "${file_base}".$cf->get('obj_ext') );
  
    require DynaLoader;
    my $modfname = defined &DynaLoader::mod2fname ? DynaLoader::mod2fname([@d, $file_base]) : $file_base;
  
    $spec{bs_file} = File::Spec->catfile($spec{archdir}, "$modfname.bs");
  
    $spec{lib_file} = File::Spec->catfile($spec{archdir}, "$modfname.".$cf->get('dlext'));
  
    return \%spec;
  }
  
  sub process_xs {
    my ($self, $file) = @_;
  
    my $spec = $self->_infer_xs_spec($file);
  
    # File name, minus the suffix
    (my $file_base = $file) =~ s/\.[^.]+$//;
  
    # .xs -> .c
    $self->add_to_cleanup($spec->{c_file});
  
    unless ($self->up_to_date($file, $spec->{c_file})) {
      $self->compile_xs($file, outfile => $spec->{c_file});
    }
  
    # .c -> .o
    my $v = $self->dist_version;
    $self->compile_c($spec->{c_file},
                     defines => {VERSION => qq{"$v"}, XS_VERSION => qq{"$v"}});
  
    # archdir
    File::Path::mkpath($spec->{archdir}, 0, oct(777)) unless -d $spec->{archdir};
  
    # .xs -> .bs
    $self->add_to_cleanup($spec->{bs_file});
    unless ($self->up_to_date($file, $spec->{bs_file})) {
      require ExtUtils::Mkbootstrap;
      $self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");
      ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});  # Original had $BSLOADLIBS - what's that?
      open(my $fh, '>>', $spec->{bs_file});  # create
      utime((time)x2, $spec->{bs_file});  # touch
    }
  
    # .o -> .(a|bundle)
    $self->link_c($spec);
  }
  
  sub do_system {
    my ($self, @cmd) = @_;
    $self->log_verbose("@cmd\n");
  
    # Some systems proliferate huge PERL5LIBs, try to ameliorate:
    my %seen;
    my $sep = $self->config('path_sep');
    local $ENV{PERL5LIB} =
      ( !exists($ENV{PERL5LIB}) ? '' :
        length($ENV{PERL5LIB}) < 500
        ? $ENV{PERL5LIB}
        : join $sep, grep { ! $seen{$_}++ and -d $_ } split($sep, $ENV{PERL5LIB})
      );
  
    my $status = system(@cmd);
    if ($status and $! =~ /Argument list too long/i) {
      my $env_entries = '';
      foreach (sort keys %ENV) { $env_entries .= "$_=>".length($ENV{$_})."; " }
      warn "'Argument list' was 'too long', env lengths are $env_entries";
    }
    return !$status;
  }
  
  sub copy_if_modified {
    my $self = shift;
    my %args = (@_ > 3
                ? ( @_ )
                : ( from => shift, to_dir => shift, flatten => shift )
               );
    $args{verbose} = !$self->quiet
      unless exists $args{verbose};
  
    my $file = $args{from};
    unless (defined $file and length $file) {
      die "No 'from' parameter given to copy_if_modified";
    }
  
    # makes no sense to replicate an absolute path, so assume flatten
    $args{flatten} = 1 if File::Spec->file_name_is_absolute( $file );
  
    my $to_path;
    if (defined $args{to} and length $args{to}) {
      $to_path = $args{to};
    } elsif (defined $args{to_dir} and length $args{to_dir}) {
      $to_path = File::Spec->catfile( $args{to_dir}, $args{flatten}
                                      ? File::Basename::basename($file)
                                      : $file );
    } else {
      die "No 'to' or 'to_dir' parameter given to copy_if_modified";
    }
  
    return if $self->up_to_date($file, $to_path); # Already fresh
  
    {
      local $self->{properties}{quiet} = 1;
      $self->delete_filetree($to_path); # delete destination if exists
    }
  
    # Create parent directories
    File::Path::mkpath(File::Basename::dirname($to_path), 0, oct(777));
  
    $self->log_verbose("Copying $file -> $to_path\n");
  
    if ($^O eq 'os2') {# copy will not overwrite; 0x1 = overwrite
      chmod 0666, $to_path;
      File::Copy::syscopy($file, $to_path, 0x1) or die "Can't copy('$file', '$to_path'): $!";
    } else {
      File::Copy::copy($file, $to_path) or die "Can't copy('$file', '$to_path'): $!";
    }
  
    # mode is read-only + (executable if source is executable)
    my $mode = oct(444) | ( $self->is_executable($file) ? oct(111) : 0 );
    chmod( $mode, $to_path );
  
    return $to_path;
  }
  
  sub up_to_date {
    my ($self, $source, $derived) = @_;
    $source  = [$source]  unless ref $source;
    $derived = [$derived] unless ref $derived;
  
    # empty $derived means $source should always run
    return 0 if @$source && !@$derived || grep {not -e} @$derived;
  
    my $most_recent_source = time / (24*60*60);
    foreach my $file (@$source) {
      unless (-e $file) {
        $self->log_warn("Can't find source file $file for up-to-date check");
        next;
      }
      $most_recent_source = -M _ if -M _ < $most_recent_source;
    }
  
    foreach my $derived (@$derived) {
      return 0 if -M $derived > $most_recent_source;
    }
    return 1;
  }
  
  sub dir_contains {
    my ($self, $first, $second) = @_;
    # File::Spec doesn't have an easy way to check whether one directory
    # is inside another, unfortunately.
  
    ($first, $second) = map File::Spec->canonpath($_), ($first, $second);
    my @first_dirs = File::Spec->splitdir($first);
    my @second_dirs = File::Spec->splitdir($second);
  
    return 0 if @second_dirs < @first_dirs;
  
    my $is_same = ( $self->_case_tolerant
                    ? sub {lc(shift()) eq lc(shift())}
                    : sub {shift() eq shift()} );
  
    while (@first_dirs) {
      return 0 unless $is_same->(shift @first_dirs, shift @second_dirs);
    }
  
    return 1;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Base - Default methods for Module::Build
  
  =head1 SYNOPSIS
  
    Please see the Module::Build documentation.
  
  =head1 DESCRIPTION
  
  The C<Module::Build::Base> module defines the core functionality of
  C<Module::Build>.  Its methods may be overridden by any of the
  platform-dependent modules in the C<Module::Build::Platform::>
  namespace, but the intention here is to make this base module as
  platform-neutral as possible.  Nicely enough, Perl has several core
  tools available in the C<File::> namespace for doing this, so the task
  isn't very difficult.
  
  Please see the C<Module::Build> documentation for more details.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3)
  
  =cut
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  
  use File::Basename ();
  use File::Spec;
  use Config;
  use Module::Build;
  use Module::Metadata;
  use version;
  use Data::Dumper;
  
  my %convert_installdirs = (
      PERL        => 'core',
      SITE        => 'site',
      VENDOR      => 'vendor',
  );
  
  my %makefile_to_build =
    (
     TEST_VERBOSE => 'verbose',
     VERBINST     => 'verbose',
     INC          => sub { map {(extra_compiler_flags => $_)} Module::Build->split_like_shell(shift) },
     POLLUTE      => sub { (extra_compiler_flags => '-DPERL_POLLUTE') },
     INSTALLDIRS  => sub { (installdirs => $convert_installdirs{uc shift()}) },
     LIB          => sub {
         my $lib = shift;
         my %config = (
             installprivlib  => $lib,
             installsitelib  => $lib,
             installarchlib  => "$lib/$Config{archname}",
             installsitearch => "$lib/$Config{archname}"
         );
         return map { (config => "$_=$config{$_}") } sort keys %config;
     },
  
     # Convert INSTALLVENDORLIB and friends.
     (
         map {
             my $name = $_;
             $name => sub {
                   my @ret = (config => lc($name) . "=" . shift );
                   print STDERR "# Converted to @ret\n";
  
                   return @ret;
             }
         } qw(
           INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
           INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
           INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
           INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
           INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
           INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR
         )
     ),
  
     # Some names they have in common
     map {$_, lc($_)} qw(DESTDIR PREFIX INSTALL_BASE UNINST),
    );
  
  my %macro_to_build = %makefile_to_build;
  # "LIB=foo make" is not the same as "perl Makefile.PL LIB=foo"
  delete $macro_to_build{LIB};
  
  sub _merge_prereq {
    my ($req, $breq) = @_;
    $req ||= {};
    $breq ||= {};
  
    # validate formats
    for my $p ( $req, $breq ) {
      for my $k (sort keys %$p) {
        next if $k eq 'perl';
  
        my $v_obj = eval { version->new($p->{$k}) };
        if ( ! defined $v_obj ) {
            die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n";
        }
  
        # It seems like a lot of people trip over "0.1.2" stuff, so we help them here...
        if ( $v_obj->is_qv ) {
          my $proper_ver = $v_obj->numify;
          warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";
          $p->{$k} = $proper_ver;
        }
      }
    }
    # merge
    my $merge = { %$req };
    for my $k ( keys %$breq ) {
      my $v1 = $merge->{$k} || 0;
      my $v2 = $breq->{$k};
      $merge->{$k} = $v1 > $v2 ? $v1 : $v2;
    }
    return %$merge;
  }
  
  
  sub create_makefile_pl {
    my ($package, $type, $build, %args) = @_;
  
    die "Don't know how to build Makefile.PL of type '$type'"
      unless $type =~ /^(small|passthrough|traditional)$/;
  
    if ($type eq 'passthrough') {
      $build->log_warn(<<"HERE");
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
    }
  
    my $fh;
    if ($args{fh}) {
      $fh = $args{fh};
    } else {
      $args{file} ||= 'Makefile.PL';
      local $build->{properties}{quiet} = 1;
      $build->delete_filetree($args{file});
      open($fh, '>', "$args{file}") or die "Can't write $args{file}: $!";
    }
  
    print {$fh} "# Note: this file was auto-generated by ", __PACKAGE__, " version $VERSION\n";
  
    # Minimum perl version should be specified as "require 5.XXXXXX" in
    # Makefile.PL
    my $requires = $build->requires;
    if ( my $minimum_perl = $requires->{perl} ) {
      my $min_ver = version->new($minimum_perl)->numify;
      print {$fh} "require $min_ver;\n";
    }
  
    # If a *bundled* custom subclass is being used, make sure we add its
    # directory to @INC.  Also, lib.pm always needs paths in Unix format.
    my $subclass_load = '';
    if (ref($build) ne "Module::Build") {
      my $subclass_dir = $package->subclass_dir($build);
  
      if (File::Spec->file_name_is_absolute($subclass_dir)) {
        my $base_dir = $build->base_dir;
  
        if ($build->dir_contains($base_dir, $subclass_dir)) {
  	$subclass_dir = File::Spec->abs2rel($subclass_dir, $base_dir);
  	$subclass_dir = $package->unixify_dir($subclass_dir);
          $subclass_load = "use lib '$subclass_dir';";
        }
        # Otherwise, leave it the empty string
  
      } else {
        $subclass_dir = $package->unixify_dir($subclass_dir);
        $subclass_load = "use lib '$subclass_dir';";
      }
    }
  
    if ($type eq 'small') {
      printf {$fh} <<'EOF', $subclass_load, ref($build), ref($build);
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
    } elsif ($type eq 'passthrough') {
      printf {$fh} <<'EOF', $subclass_load, ref($build), ref($build);
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
    } elsif ($type eq 'traditional') {
  
      my (%MM_Args, %prereq);
      if (eval "use Tie::IxHash 1.2; 1") {
        tie %MM_Args, 'Tie::IxHash'; # Don't care if it fails here
        tie %prereq,  'Tie::IxHash'; # Don't care if it fails here
      }
  
      my %name = ($build->module_name
  		? (NAME => $build->module_name)
  		: (DISTNAME => $build->dist_name));
  
      my %version = ($build->dist_version_from
  		   ? (VERSION_FROM => $build->dist_version_from)
  		   : (VERSION      => $build->dist_version)
  		  );
      %MM_Args = (%name, %version);
  
      %prereq = _merge_prereq( $build->requires, $build->build_requires );
      %prereq = map {$_, $prereq{$_}} sort keys %prereq;
  
       delete $prereq{perl};
      $MM_Args{PREREQ_PM} = \%prereq;
  
      $MM_Args{INSTALLDIRS} = $build->installdirs eq 'core' ? 'perl' : $build->installdirs;
  
      $MM_Args{EXE_FILES} = [ sort keys %{$build->script_files} ] if $build->script_files;
  
      $MM_Args{PL_FILES} = $build->PL_files || {};
  
      if ($build->recursive_test_files) {
          $MM_Args{test} = { TESTS => join q{ }, $package->_test_globs($build) };
      }
  
      local $Data::Dumper::Terse = 1;
      my $args = Data::Dumper::Dumper(\%MM_Args);
      $args =~ s/\{(.*)\}/($1)/s;
  
      print $fh <<"EOF";
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
    }
  }
  
  sub _test_globs {
    my ($self, $build) = @_;
  
    return map { File::Spec->catfile($_, '*.t') }
           @{$build->rscan_dir('t', sub { -d $File::Find::name })};
  }
  
  sub subclass_dir {
    my ($self, $build) = @_;
  
    return (Module::Metadata->find_module_dir_by_name(ref $build)
  	  || File::Spec->catdir($build->config_dir, 'lib'));
  }
  
  sub unixify_dir {
    my ($self, $path) = @_;
    return join '/', File::Spec->splitdir($path);
  }
  
  sub makefile_to_build_args {
    my $class = shift;
    my @out;
    foreach my $arg (@_) {
      next if $arg eq '';
  
      my ($key, $val) = ($arg =~ /^(\w+)=(.+)/ ? ($1, $2) :
  		       die "Malformed argument '$arg'");
  
      # Do tilde-expansion if it looks like a tilde prefixed path
      ( $val ) = Module::Build->_detildefy( $val ) if $val =~ /^~/;
  
      if (exists $makefile_to_build{$key}) {
        my $trans = $makefile_to_build{$key};
        push @out, $class->_argvify( ref($trans) ? $trans->($val) : ($trans => $val) );
      } elsif (exists $Config{lc($key)}) {
        push @out, $class->_argvify( config => lc($key) . "=$val" );
      } else {
        # Assume M::B can handle it in lowercase form
        push @out, $class->_argvify("\L$key" => $val);
      }
    }
    return @out;
  }
  
  sub _argvify {
    my ($self, @pairs) = @_;
    my @out;
    while (@pairs) {
      my ($k, $v) = splice @pairs, 0, 2;
      push @out, ("--$k", $v);
    }
    return @out;
  }
  
  sub makefile_to_build_macros {
    my @out;
    my %config; # must accumulate and return as a hashref
    foreach my $macro (sort keys %macro_to_build) {
      my $trans = $macro_to_build{$macro};
      # On some platforms (e.g. Cygwin with 'make'), the mere presence
      # of "EXPORT: FOO" in the Makefile will make $ENV{FOO} defined.
      # Therefore we check length() too.
      next unless exists $ENV{$macro} && length $ENV{$macro};
      my $val = $ENV{$macro};
      my @args = ref($trans) ? $trans->($val) : ($trans => $val);
      while (@args) {
        my ($k, $v) = splice(@args, 0, 2);
        if ( $k eq 'config' ) {
          if ( $v =~ /^([^=]+)=(.*)$/ ) {
            $config{$1} = $2;
          }
          else {
            warn "Couldn't parse config '$v'\n";
          }
        }
        else {
          push @out, ($k => $v);
        }
      }
    }
    push @out, (config => \%config) if %config;
    return @out;
  }
  
  sub run_build_pl {
    my ($pack, %in) = @_;
    $in{script} ||= 'Build.PL';
    my @args = $in{args} ? $pack->makefile_to_build_args(@{$in{args}}) : ();
    print "# running $in{script} @args\n";
    Module::Build->run_perl_script($in{script}, [], \@args) or die "Couldn't run $in{script}: $!";
  }
  
  sub fake_makefile {
    my ($self, %args) = @_;
    unless (exists $args{build_class}) {
      warn "Unknown 'build_class', defaulting to 'Module::Build'\n";
      $args{build_class} = 'Module::Build';
    }
    my $class = $args{build_class};
  
    my $perl = $class->find_perl_interpreter;
  
    # VMS MMS/MMK need to use MCR to run the Perl image.
    $perl = 'MCR ' . $perl if $self->_is_vms_mms;
  
    my $noop = ($class->is_windowsish ? 'rem>nul'  :
  	      $self->_is_vms_mms    ? 'Continue' :
  	      'true');
  
    my $filetype = $class->is_vmsish ? '.COM' : '';
  
    my $Build = 'Build' . $filetype . ' --makefile_env_macros 1';
    my $unlink = $class->oneliner('1 while unlink $ARGV[0]', [], [$args{makefile}]);
    $unlink =~ s/\$/\$\$/g unless $class->is_vmsish;
  
    my $maketext = join '', map { "$_=\n" } sort keys %macro_to_build;
  
    $maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n"
                      : $^O eq 'MSWin32' && $Config{make} =~ /gmake/
                      ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");
  
    $maketext .= <<"EOF";
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  
    foreach my $action ($class->known_actions) {
      next if $action =~ /^(all|distclean|realclean|force_do_it)$/;  # Don't double-define
      $maketext .= <<"EOF";
  $action : force_do_it
  	$perl $Build $action
  EOF
    }
  
    if ($self->_is_vms_mms) {
      # Roll our own .EXPORT as MMS/MMK don't honor that directive.
      $maketext .= "\n.FIRST\n\t\@ $noop\n";
      for my $macro (sort keys %macro_to_build) {
        $maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n";
      }
      $maketext .= "\n";
    }
    else {
      $maketext .= "\n.EXPORT : " . join(' ', sort keys %macro_to_build) . "\n\n";
    }
  
    return $maketext;
  }
  
  sub fake_prereqs {
    my $file = File::Spec->catfile('_build', 'prereqs');
    open(my $fh, '<', "$file") or die "Can't read $file: $!";
    my $prereqs = eval do {local $/; <$fh>};
    close $fh;
  
    my %merged = _merge_prereq( $prereqs->{requires}, $prereqs->{build_requires} );
    my @prereq;
    foreach (sort keys %merged) {
      next if $_ eq 'perl';
      push @prereq, "$_=>q[$merged{$_}]";
    }
    return unless @prereq;
    return "#     PREREQ_PM => { " . join(", ", @prereq) . " }\n\n";
  }
  
  
  sub write_makefile {
    my ($pack, %in) = @_;
  
    unless (exists $in{build_class}) {
      warn "Unknown 'build_class', defaulting to 'Module::Build'\n";
      $in{build_class} = 'Module::Build';
    }
    my $class = $in{build_class};
    $in{makefile} ||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';
  
    open  MAKE, "> $in{makefile}" or die "Cannot write $in{makefile}: $!";
    print MAKE $pack->fake_prereqs;
    print MAKE $pack->fake_makefile(%in);
    close MAKE;
  }
  
  sub _is_vms_mms {
    return Module::Build->is_vmsish && ($Config{make} =~ m/MM[SK]/i);
  }
  
  1;
  __END__
  
  =for :stopwords passthrough
  
  =head1 NAME
  
  Module::Build::Compat - Compatibility with ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
    # In a Build.PL :
    use Module::Build;
    my $build = Module::Build->new
      ( module_name => 'Foo::Bar',
        license     => 'perl',
        create_makefile_pl => 'traditional' );
    ...
  
  
  =head1 DESCRIPTION
  
  Because C<ExtUtils::MakeMaker> has been the standard way to distribute
  modules for a long time, many tools (CPAN.pm, or your system
  administrator) may expect to find a working F<Makefile.PL> in every
  distribution they download from CPAN.  If you want to throw them a
  bone, you can use C<Module::Build::Compat> to automatically generate a
  F<Makefile.PL> for you, in one of several different styles.
  
  C<Module::Build::Compat> also provides some code that helps out the
  F<Makefile.PL> at runtime.
  
  
  =head1 METHODS
  
  =over 4
  
  =item create_makefile_pl($style, $build)
  
  Creates a F<Makefile.PL> in the current directory in one of several
  styles, based on the supplied C<Module::Build> object C<$build>.  This is
  typically controlled by passing the desired style as the
  C<create_makefile_pl> parameter to C<Module::Build>'s C<new()> method;
  the F<Makefile.PL> will then be automatically created during the
  C<distdir> action.
  
  The currently supported styles are:
  
  =over 4
  
  =item traditional
  
  A F<Makefile.PL> will be created in the "traditional" style, i.e. it will
  use C<ExtUtils::MakeMaker> and won't rely on C<Module::Build> at all.
  In order to create the F<Makefile.PL>, we'll include the C<requires> and
  C<build_requires> dependencies as the C<PREREQ_PM> parameter.
  
  You don't want to use this style if during the C<perl Build.PL> stage
  you ask the user questions, or do some auto-sensing about the user's
  environment, or if you subclass C<Module::Build> to do some
  customization, because the vanilla F<Makefile.PL> won't do any of that.
  
  =item small
  
  A small F<Makefile.PL> will be created that passes all functionality
  through to the F<Build.PL> script in the same directory.  The user must
  already have C<Module::Build> installed in order to use this, or else
  they'll get a module-not-found error.
  
  =item passthrough (DEPRECATED)
  
  This is just like the C<small> option above, but if C<Module::Build> is
  not already installed on the user's system, the script will offer to
  use C<CPAN.pm> to download it and install it before continuing with
  the build.
  
  This option has been deprecated and may be removed in a future version
  of Module::Build.  Modern CPAN.pm and CPANPLUS will recognize the
  C<configure_requires> metadata property and install Module::Build before
  running Build.PL if Module::Build is listed and Module::Build now
  adds itself to configure_requires by default.
  
  Perl 5.10.1 includes C<configure_requires> support.  In the future, when
  C<configure_requires> support is deemed sufficiently widespread, the
  C<passthrough> style will be removed.
  
  =back
  
  =item run_build_pl(args => \@ARGV)
  
  This method runs the F<Build.PL> script, passing it any arguments the
  user may have supplied to the C<perl Makefile.PL> command.  Because
  C<ExtUtils::MakeMaker> and C<Module::Build> accept different arguments, this
  method also performs some translation between the two.
  
  C<run_build_pl()> accepts the following named parameters:
  
  =over 4
  
  =item args
  
  The C<args> parameter specifies the parameters that would usually
  appear on the command line of the C<perl Makefile.PL> command -
  typically you'll just pass a reference to C<@ARGV>.
  
  =item script
  
  This is the filename of the script to run - it defaults to C<Build.PL>.
  
  =back
  
  =item write_makefile()
  
  This method writes a 'dummy' F<Makefile> that will pass all commands
  through to the corresponding C<Module::Build> actions.
  
  C<write_makefile()> accepts the following named parameters:
  
  =over 4
  
  =item makefile
  
  The name of the file to write - defaults to the string C<Makefile>.
  
  =back
  
  =back
  
  
  =head1 SCENARIOS
  
  So, some common scenarios are:
  
  =over 4
  
  =item 1.
  
  Just include a F<Build.PL> script (without a F<Makefile.PL>
  script), and give installation directions in a F<README> or F<INSTALL>
  document explaining how to install the module.  In particular, explain
  that the user must install C<Module::Build> before installing your
  module.
  
  Note that if you do this, you may make things easier for yourself, but
  harder for people with older versions of CPAN or CPANPLUS on their
  system, because those tools generally only understand the
  F<Makefile.PL>/C<ExtUtils::MakeMaker> way of doing things.
  
  =item 2.
  
  Include a F<Build.PL> script and a "traditional" F<Makefile.PL>,
  created either manually or with C<create_makefile_pl()>.  Users won't
  ever have to install C<Module::Build> if they use the F<Makefile.PL>, but
  they won't get to take advantage of C<Module::Build>'s extra features
  either.
  
  For good measure, of course, test both the F<Makefile.PL> and the
  F<Build.PL> before shipping.
  
  =item 3.
  
  Include a F<Build.PL> script and a "pass-through" F<Makefile.PL>
  built using C<Module::Build::Compat>.  This will mean that people can
  continue to use the "old" installation commands, and they may never
  notice that it's actually doing something else behind the scenes.  It
  will also mean that your installation process is compatible with older
  versions of tools like CPAN and CPANPLUS.
  
  =back
  
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  L<Module::Build>(3), L<ExtUtils::MakeMaker>(3)
  
  
  =cut
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Config;
  
  sub new {
    my ($pack, %args) = @_;
    return bless {
  		stack => {},
  		values => $args{values} || {},
  	       }, $pack;
  }
  
  sub get {
    my ($self, $key) = @_;
    return $self->{values}{$key} if ref($self) && exists $self->{values}{$key};
    return $Config{$key};
  }
  
  sub set {
    my ($self, $key, $val) = @_;
    $self->{values}{$key} = $val;
  }
  
  sub push {
    my ($self, $key, $val) = @_;
    push @{$self->{stack}{$key}}, $self->{values}{$key}
      if exists $self->{values}{$key};
    $self->{values}{$key} = $val;
  }
  
  sub pop {
    my ($self, $key) = @_;
  
    my $val = delete $self->{values}{$key};
    if ( exists $self->{stack}{$key} ) {
      $self->{values}{$key} = pop @{$self->{stack}{$key}};
      delete $self->{stack}{$key} unless @{$self->{stack}{$key}};
    }
  
    return $val;
  }
  
  sub values_set {
    my $self = shift;
    return undef unless ref($self);
    return $self->{values};
  }
  
  sub all_config {
    my $self = shift;
    my $v = ref($self) ? $self->{values} : {};
    return {%Config, %$v};
  }
  
  1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  
  =head1 NAME
  
  Module::Build::ConfigData - Configuration for Module::Build
  
  =head1 SYNOPSIS
  
    use Module::Build::ConfigData;
    $value = Module::Build::ConfigData->config('foo');
    $value = Module::Build::ConfigData->feature('bar');
  
    @names = Module::Build::ConfigData->config_names;
    @names = Module::Build::ConfigData->feature_names;
  
    Module::Build::ConfigData->set_config(foo => $new_value);
    Module::Build::ConfigData->set_feature(bar => $new_value);
    Module::Build::ConfigData->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<Module::Build>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<Module::Build::ConfigData>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<Module::Build::ConfigData>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<Module::Build::ConfigData>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<Module::Build::ConfigData> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<Module::Build::ConfigData> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<Module::Build::ConfigData>.
  
  =cut
  
  
  __DATA__
  do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  
  
  =head1 NAME
  
  Module::Build::Cookbook - Examples of Module::Build Usage
  
  =head1 DESCRIPTION
  
  C<Module::Build> isn't conceptually very complicated, but examples are
  always helpful.  The following recipes should help developers and/or
  installers put together the pieces from the other parts of the
  documentation.
  
  
  =head1 BASIC RECIPES
  
  
  =head2 Installing modules that use Module::Build
  
  In most cases, you can just issue the following commands:
  
    perl Build.PL
    ./Build
    ./Build test
    ./Build install
  
  There's nothing complicated here - first you're running a script
  called F<Build.PL>, then you're running a (newly-generated) script
  called F<Build> and passing it various arguments.
  
  The exact commands may vary a bit depending on how you invoke perl
  scripts on your system.  For instance, if you have multiple versions
  of perl installed, you can install to one particular perl's library
  directories like so:
  
    /usr/bin/perl5.8.1 Build.PL
    ./Build
    ./Build test
    ./Build install
  
  If you're on Windows where the current directory is always searched
  first for scripts, you'll probably do something like this:
  
    perl Build.PL
    Build
    Build test
    Build install
  
  On the old Mac OS (version 9 or lower) using MacPerl, you can
  double-click on the F<Build.PL> script to create the F<Build> script,
  then double-click on the F<Build> script to run its C<build>, C<test>,
  and C<install> actions.
  
  The F<Build> script knows what perl was used to run F<Build.PL>, so
  you don't need to re-invoke the F<Build> script with the complete perl
  path each time.  If you invoke it with the I<wrong> perl path, you'll
  get a warning or a fatal error.
  
  =head2 Modifying Config.pm values
  
  C<Module::Build> relies heavily on various values from perl's
  C<Config.pm> to do its work.  For example, default installation paths
  are given by C<installsitelib> and C<installvendorman3dir> and
  friends, C linker & compiler settings are given by C<ld>,
  C<lddlflags>, C<cc>, C<ccflags>, and so on.  I<If you're pretty sure
  you know what you're doing>, you can tell C<Module::Build> to pretend
  there are different values in F<Config.pm> than what's really there,
  by passing arguments for the C<--config> parameter on the command
  line:
  
    perl Build.PL --config cc=gcc --config ld=gcc
  
  Inside the C<Build.PL> script the same thing can be accomplished by
  passing values for the C<config> parameter to C<new()>:
  
   my $build = Module::Build->new
     (
      ...
      config => { cc => 'gcc', ld => 'gcc' },
      ...
     );
  
  In custom build code, the same thing can be accomplished by calling
  the L<Module::Build/config> method:
  
   $build->config( cc => 'gcc' );     # Set
   $build->config( ld => 'gcc' );     # Set
   ...
   my $linker = $build->config('ld'); # Get
  
  
  =head2 Installing modules using the programmatic interface
  
  If you need to build, test, and/or install modules from within some
  other perl code (as opposed to having the user type installation
  commands at the shell), you can use the programmatic interface.
  Create a Module::Build object (or an object of a custom Module::Build
  subclass) and then invoke its C<dispatch()> method to run various
  actions.
  
    my $build = Module::Build->new
      (
       module_name => 'Foo::Bar',
       license     => 'perl',
       requires    => { 'Some::Module'   => '1.23' },
      );
    $build->dispatch('build');
    $build->dispatch('test', verbose => 1);
    $build->dispatch('install');
  
  The first argument to C<dispatch()> is the name of the action, and any
  following arguments are named parameters.
  
  This is the interface we use to test Module::Build itself in the
  regression tests.
  
  
  =head2 Installing to a temporary directory
  
  To create packages for package managers like RedHat's C<rpm> or
  Debian's C<deb>, you may need to install to a temporary directory
  first and then create the package from that temporary installation.
  To do this, specify the C<destdir> parameter to the C<install> action:
  
    ./Build install --destdir /tmp/my-package-1.003
  
  This essentially just prepends all the installation paths with the
  F</tmp/my-package-1.003> directory.
  
  
  =head2 Installing to a non-standard directory
  
  To install to a non-standard directory (for example, if you don't have
  permission to install in the system-wide directories), you can use the
  C<install_base> or C<prefix> parameters:
  
    ./Build install --install_base /foo/bar
  
  See L<Module::Build/"INSTALL PATHS"> for a much more complete
  discussion of how installation paths are determined.
  
  
  =head2 Installing in the same location as ExtUtils::MakeMaker
  
  With the introduction of C<--prefix> in Module::Build 0.28 and
  C<INSTALL_BASE> in C<ExtUtils::MakeMaker> 6.31 its easy to get them both
  to install to the same locations.
  
  First, ensure you have at least version 0.28 of Module::Build
  installed and 6.31 of C<ExtUtils::MakeMaker>.  Prior versions have
  differing (and in some cases quite strange) installation behaviors.
  
  The following installation flags are equivalent between
  C<ExtUtils::MakeMaker> and C<Module::Build>.
  
      MakeMaker             Module::Build
      PREFIX=...            --prefix ...
      INSTALL_BASE=...      --install_base ...
      DESTDIR=...           --destdir ...
      LIB=...               --install_path lib=...
      INSTALLDIRS=...       --installdirs ...
      INSTALLDIRS=perl      --installdirs core
      UNINST=...            --uninst ...
      INC=...               --extra_compiler_flags ...
      POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE
  
  For example, if you are currently installing C<MakeMaker> modules with
  this command:
  
      perl Makefile.PL PREFIX=~
      make test
      make install UNINST=1
  
  You can install into the same location with Module::Build using this:
  
      perl Build.PL --prefix ~
      ./Build test
      ./Build install --uninst 1
  
  =head3 C<prefix> vs C<install_base>
  
  The behavior of C<prefix> is complicated and depends on
  how your Perl is configured.  The resulting installation locations
  will vary from machine to machine and even different installations of
  Perl on the same machine.  Because of this, it's difficult to document
  where C<prefix> will place your modules.
  
  In contrast, C<install_base> has predictable, easy to explain
  installation locations.  Now that C<Module::Build> and C<MakeMaker> both
  have C<install_base> there is little reason to use C<prefix> other
  than to preserve your existing installation locations.  If you are
  starting a fresh Perl installation we encourage you to use
  C<install_base>.  If you have an existing installation installed via
  C<prefix>, consider moving it to an installation structure matching
  C<install_base> and using that instead.
  
  
  =head2 Running a single test file
  
  C<Module::Build> supports running a single test, which enables you to
  track down errors more quickly.  Use the following format:
  
    ./Build test --test_files t/mytest.t
  
  In addition, you may want to run the test in verbose mode to get more
  informative output:
  
    ./Build test --test_files t/mytest.t --verbose 1
  
  I run this so frequently that I define the following shell alias:
  
    alias t './Build test --verbose 1 --test_files'
  
  So then I can just execute C<t t/mytest.t> to run a single test.
  
  
  =head1 ADVANCED RECIPES
  
  
  =head2 Making a CPAN.pm-compatible distribution
  
  New versions of CPAN.pm understand how to use a F<Build.PL> script,
  but old versions don't.  If authors want to help users who have old
  versions, some form of F<Makefile.PL> should be supplied.  The easiest
  way to accomplish this is to use the C<create_makefile_pl> parameter to
  C<< Module::Build->new() >> in the C<Build.PL> script, which can
  create various flavors of F<Makefile.PL> during the C<dist> action.
  
  As a best practice, we recommend using the "traditional" style of
  F<Makefile.PL> unless your distribution has needs that can't be
  accomplished that way.
  
  The C<Module::Build::Compat> module, which is part of
  C<Module::Build>'s distribution, is responsible for creating these
  F<Makefile.PL>s.  Please see L<Module::Build::Compat> for the details.
  
  
  =head2 Changing the order of the build process
  
  The C<build_elements> property specifies the steps C<Module::Build>
  will take when building a distribution.  To change the build order,
  change the order of the entries in that property:
  
    # Process pod files first
    my @e = @{$build->build_elements};
    my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;
    unshift @e, splice @e, $i, 1;
  
  Currently, C<build_elements> has the following default value:
  
    [qw( PL support pm xs pod script )]
  
  Do take care when altering this property, since there may be
  non-obvious (and non-documented!) ordering dependencies in the
  C<Module::Build> code.
  
  
  =head2 Adding new file types to the build process
  
  Sometimes you might have extra types of files that you want to install
  alongside the standard types like F<.pm> and F<.pod> files.  For
  instance, you might have a F<Bar.dat> file containing some data
  related to the C<Foo::Bar> module and you'd like for it to end up as
  F<Foo/Bar.dat> somewhere in perl's C<@INC> path so C<Foo::Bar> can
  access it easily at runtime.  The following code from a sample
  C<Build.PL> file demonstrates how to accomplish this:
  
    use Module::Build;
    my $build = Module::Build->new
      (
       module_name => 'Foo::Bar',
       ...other stuff here...
      );
    $build->add_build_element('dat');
    $build->create_build_script;
  
  This will find all F<.dat> files in the F<lib/> directory, copy them
  to the F<blib/lib/> directory during the C<build> action, and install
  them during the C<install> action.
  
  If your extra files aren't located in the C<lib/> directory in your
  distribution, you can explicitly say where they are, just as you'd do
  with F<.pm> or F<.pod> files:
  
    use Module::Build;
    my $build = new Module::Build
      (
       module_name => 'Foo::Bar',
       dat_files => {'some/dir/Bar.dat' => 'lib/Foo/Bar.dat'},
       ...other stuff here...
      );
    $build->add_build_element('dat');
    $build->create_build_script;
  
  If your extra files actually need to be created on the user's machine,
  or if they need some other kind of special processing, you'll probably
  want to subclass C<Module::Build> and create a special method to
  process them, named C<process_${kind}_files()>:
  
    use Module::Build;
    my $class = Module::Build->subclass(code => <<'EOF');
      sub process_dat_files {
        my $self = shift;
        ... locate and process *.dat files,
        ... and create something in blib/lib/
      }
    EOF
    my $build = $class->new
      (
       module_name => 'Foo::Bar',
       ...other stuff here...
      );
    $build->add_build_element('dat');
    $build->create_build_script;
  
  If your extra files don't go in F<lib/> but in some other place, see
  L<"Adding new elements to the install process"> for how to actually
  get them installed.
  
  Please note that these examples use some capabilities of Module::Build
  that first appeared in version 0.26.  Before that it could
  still be done, but the simple cases took a bit more work.
  
  
  =head2 Adding new elements to the install process
  
  By default, Module::Build creates seven subdirectories of the F<blib>
  directory during the build process: F<lib>, F<arch>, F<bin>,
  F<script>, F<bindoc>, F<libdoc>, and F<html> (some of these may be
  missing or empty if there's nothing to go in them).  Anything copied
  to these directories during the build will eventually be installed
  during the C<install> action (see L<Module::Build/"INSTALL PATHS">.
  
  If you need to create a new custom type of installable element, e.g. C<conf>,
  then you need to tell Module::Build where things in F<blib/conf/>
  should be installed.  To do this, use the C<install_path> parameter to
  the C<new()> method:
  
    my $build = Module::Build->new
      (
       ...other stuff here...
       install_path => { conf => $installation_path }
      );
  
  Or you can call the C<install_path()> method later:
  
    $build->install_path(conf => $installation_path);
  
  The user may also specify the path on the command line:
  
    perl Build.PL --install_path conf=/foo/path/etc
  
  The important part, though, is that I<somehow> the install path needs
  to be set, or else nothing in the F<blib/conf/> directory will get
  installed, and a runtime error during the C<install> action will
  result.
  
  See also L<"Adding new file types to the build process"> for how to
  create the stuff in F<blib/conf/> in the first place.
  
  
  =head1 EXAMPLES ON CPAN
  
  Several distributions on CPAN are making good use of various features
  of Module::Build.  They can serve as real-world examples for others.
  
  
  =head2 SVN-Notify-Mirror
  
  L<http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/>
  
  John Peacock, author of the C<SVN-Notify-Mirror> distribution, says:
  
  =over 4
  
  =item 1. Using C<auto_features>, I check to see whether two optional
  modules are available - SVN::Notify::Config and Net::SSH;
  
  =item 2. If the S::N::Config module is loaded, I automatically
  generate test files for it during Build (using the C<PL_files>
  property).
  
  =item 3. If the C<ssh_feature> is available, I ask if the user wishes
  to perform the ssh tests (since it requires a little preliminary
  setup);
  
  =item 4. Only if the user has C<ssh_feature> and answers yes to the
  testing, do I generate a test file.
  
  I'm sure I could not have handled this complexity with EU::MM, but it
  was very easy to do with M::B.
  
  =back
  
  
  =head2 Modifying an action
  
  Sometimes you might need an to have an action, say C<./Build install>,
  do something unusual.  For instance, you might need to change the
  ownership of a file or do something else peculiar to your application.
  
  You can subclass C<Module::Build> on the fly using the C<subclass()>
  method and override the methods that perform the actions.  You may
  need to read through C<Module::Build::Authoring> and
  C<Module::Build::API> to find the methods you want to override.  All
  "action" methods are implemented by a method called "ACTION_" followed
  by the action's name, so here's an example of how it would work for
  the C<install> action:
  
    # Build.PL
    use Module::Build;
    my $class = Module::Build->subclass(
        class => "Module::Build::Custom",
        code => <<'SUBCLASS' );
  
    sub ACTION_install {
        my $self = shift;
        # YOUR CODE HERE
        $self->SUPER::ACTION_install;
    }
    SUBCLASS
  
    $class->new(
        module_name => 'Your::Module',
        # rest of the usual Module::Build parameters
    )->create_build_script;
  
  
  =head2 Adding an action
  
  You can add a new C<./Build> action simply by writing the method for
  it in your subclass.  Use C<depends_on> to declare that another action
  must have been run before your action.
  
  For example, let's say you wanted to be able to write C<./Build
  commit> to test your code and commit it to Subversion.
  
    # Build.PL
    use Module::Build;
    my $class = Module::Build->subclass(
        class => "Module::Build::Custom",
        code => <<'SUBCLASS' );
  
    sub ACTION_commit {
        my $self = shift;
  
        $self->depends_on("test");
        $self->do_system(qw(svn commit));
    }
    SUBCLASS
  
  
  =head2 Bundling Module::Build
  
  Note: This section probably needs an update as the technology improves
  (see contrib/bundle.pl in the distribution).
  
  Suppose you want to use some new-ish features of Module::Build,
  e.g. newer than the version of Module::Build your users are likely to
  already have installed on their systems.  The first thing you should
  do is set C<configure_requires> to your minimum version of
  Module::Build.  See L<Module::Build::Authoring>.
  
  But not every build system honors C<configure_requires> yet.  Here's
  how you can ship a copy of Module::Build, but still use a newer
  installed version to take advantage of any bug fixes and upgrades.
  
  First, install Module::Build into F<Your-Project/inc/Module-Build>.
  CPAN will not index anything in the F<inc> directory so this copy will
  not show up in CPAN searches.
  
      cd Module-Build
      perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build
      ./Build test
      ./Build install
  
  You should now have all the Module::Build .pm files in
  F<Your-Project/inc/Module-Build/lib/perl5>.
  
  Next, add this to the top of your F<Build.PL>.
  
      my $Bundled_MB = 0.30;  # or whatever version it was.
  
      # Find out what version of Module::Build is installed or fail quietly.
      # This should be cross-platform.
      my $Installed_MB =
          `$^X -e "eval q{require Module::Build; print Module::Build->VERSION} or exit 1"`;
  
      # some operating systems put a newline at the end of every print.
      chomp $Installed_MB;
  
      $Installed_MB = 0 if $?;
  
      # Use our bundled copy of Module::Build if it's newer than the installed.
      unshift @INC, "inc/Module-Build/lib/perl5" if $Bundled_MB > $Installed_MB;
  
      require Module::Build;
  
  And write the rest of your F<Build.PL> normally.  Module::Build will
  remember your change to C<@INC> and use it when you run F<./Build>.
  
  In the future, we hope to provide a more automated solution for this
  scenario; see C<inc/latest.pm> in the Module::Build distribution for
  one indication of the direction we're moving.
  
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2008 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  perl(1), L<Module::Build>(3), L<Module::Build::Authoring>(3),
  L<Module::Build::API>(3)
  
  =cut
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  
  # This is just a split-out of a wrapper function to do Data::Dumper
  # stuff "the right way".  See:
  # http://groups.google.com/group/perl.module.build/browse_thread/thread/c8065052b2e0d741
  
  use Data::Dumper;
  
  sub _data_dump {
    my ($self, $data) = @_;
    return ("do{ my "
  	  . Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump()
  	  . '$x; }')
  }
  
  1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;
  
  # A class for persistent hashes
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Data::Dumper;
  use Module::Build::Dumper;
  
  sub new {
    my ($class, %args) = @_;
    my $file = delete $args{file} or die "Missing required parameter 'file' to new()";
    my $self = bless {
  		    disk => {},
  		    new  => {},
  		    file => $file,
  		    %args,
  		   }, $class;
  }
  
  sub restore {
    my $self = shift;
  
    open(my $fh, '<', $self->{file}) or die "Can't read $self->{file}: $!";
    $self->{disk} = eval do {local $/; <$fh>};
    die $@ if $@;
    close $fh;
    $self->{new} = {};
  }
  
  sub access {
    my $self = shift;
    return $self->read() unless @_;
  
    my $key = shift;
    return $self->read($key) unless @_;
  
    my $value = shift;
    $self->write({ $key => $value });
    return $self->read($key);
  }
  
  sub has_data {
    my $self = shift;
    return keys %{$self->read()} > 0;
  }
  
  sub exists {
    my ($self, $key) = @_;
    return exists($self->{new}{$key}) || exists($self->{disk}{$key});
  }
  
  sub read {
    my $self = shift;
  
    if (@_) {
      # Return 1 key as a scalar
      my $key = shift;
      return $self->{new}{$key} if exists $self->{new}{$key};
      return $self->{disk}{$key};
    }
  
    # Return all data
    my $out = (keys %{$self->{new}}
  	     ? {%{$self->{disk}}, %{$self->{new}}}
  	     : $self->{disk});
    return wantarray ? %$out : $out;
  }
  
  sub _same {
    my ($self, $x, $y) = @_;
    return 1 if !defined($x) and !defined($y);
    return 0 if !defined($x) or  !defined($y);
    return $x eq $y;
  }
  
  sub write {
    my ($self, $href) = @_;
    $href ||= {};
  
    @{$self->{new}}{ keys %$href } = values %$href;  # Merge
  
    # Do some optimization to avoid unnecessary writes
    foreach my $key (keys %{ $self->{new} }) {
      next if ref $self->{new}{$key};
      next if ref $self->{disk}{$key} or !exists $self->{disk}{$key};
      delete $self->{new}{$key} if $self->_same($self->{new}{$key}, $self->{disk}{$key});
    }
  
    if (my $file = $self->{file}) {
      my ($vol, $dir, $base) = File::Spec->splitpath($file);
      $dir = File::Spec->catpath($vol, $dir, '');
      return unless -e $dir && -d $dir;  # The user needs to arrange for this
  
      return if -e $file and !keys %{ $self->{new} };  # Nothing to do
  
      @{$self->{disk}}{ keys %{$self->{new}} } = values %{$self->{new}};  # Merge
      $self->_dump($file, $self->{disk});
  
      $self->{new} = {};
    }
    return $self->read;
  }
  
  sub _dump {
    my ($self, $file, $data) = @_;
  
    open(my $fh, '>', $file) or die "Can't create '$file': $!";
    print {$fh} Module::Build::Dumper->_data_dump($data);
    close $fh;
  }
  
  my $orig_template = do { local $/; <DATA> };
  close DATA;
  
  sub write_config_data {
    my ($self, %args) = @_;
  
    my $template = $orig_template;
    $template =~ s/NOTES_NAME/$args{config_module}/g;
    $template =~ s/MODULE_NAME/$args{module}/g;
    $template =~ s/=begin private\n//;
    $template =~ s/=end private/=cut/;
  
    # strip out private POD markers we use to keep pod from being
    # recognized for *this* source file
    $template =~ s{$_\n}{} for '=begin private', '=end private';
  
    open(my $fh, '>', $args{file}) or die "Can't create '$args{file}': $!";
    print {$fh} $template;
    print {$fh} "\n__DATA__\n";
    print {$fh} Module::Build::Dumper->_data_dump([$args{config_data}, $args{feature}, $args{auto_features}]);
    close $fh;
  }
  
  1;
  
  
  =head1 NAME
  
  Module::Build::Notes - Create persistent distribution configuration modules
  
  =head1 DESCRIPTION
  
  This module is used internally by Module::Build to create persistent
  configuration files that can be installed with a distribution.  See
  L<Module::Build::ConfigData> for an example.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Module::Build>(3)
  
  =cut
  
  __DATA__
  package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;
  
  use strict;
  use warnings;
  use Config;
  
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  # This code is mostly borrowed from ExtUtils::MM_Unix 6.10_03, with a
  # few tweaks based on the PPD spec at
  # http://www.xav.com/perl/site/lib/XML/PPD.html
  
  # The PPD spec is based on <http://www.w3.org/TR/NOTE-OSD>
  
  sub new {
    my $package = shift;
    return bless {@_}, $package;
  }
  
  sub make_ppd {
    my ($self, %args) = @_;
    my $build = delete $args{build};
  
    my @codebase;
    if (exists $args{codebase}) {
      @codebase = ref $args{codebase} ? @{$args{codebase}} : ($args{codebase});
    } else {
      my $distfile = $build->ppm_name . '.tar.gz';
      print "Using default codebase '$distfile'\n";
      @codebase = ($distfile);
    }
  
    my %dist;
    foreach my $info (qw(name author abstract version)) {
      my $method = "dist_$info";
      $dist{$info} = $build->$method() or die "Can't determine distribution's $info\n";
    }
  
    $self->_simple_xml_escape($_) foreach $dist{abstract}, @{$dist{author}};
  
    # TODO: could add <LICENSE HREF=...> tag if we knew what the URLs were for
    # various licenses
    my $ppd = <<"PPD";
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
  
    # We don't include recommended dependencies because PPD has no way
    # to distinguish them from normal dependencies.  We don't include
    # build_requires dependencies because the PPM installer doesn't
    # build or test before installing.  And obviously we don't include
    # conflicts either.
  
    foreach my $type (qw(requires)) {
      my $prereq = $build->$type();
      foreach my $modname (sort keys %$prereq) {
        next if $modname eq 'perl';
  
        my $min_version = '0.0';
        foreach my $c ($build->_parse_conditions($prereq->{$modname})) {
          my ($op, $version) = $c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;
  
          # This is a nasty hack because it fails if there is no >= op
          if ($op eq '>=') {
            $min_version = $version;
            last;
          }
        }
  
        # PPM4 spec requires a '::' for top level modules
        $modname .= '::' unless $modname =~ /::/;
  
        $ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!;
      }
    }
  
    # We only include these tags if this module involves XS, on the
    # assumption that pure Perl modules will work on any OS.
    if (keys %{$build->find_xs_files}) {
      my $perl_version = $self->_ppd_version($build->perl_version);
      $ppd .= sprintf(<<'EOF', $self->_varchname($build->config) );
          <ARCHITECTURE NAME="%s" />
  EOF
    }
  
    foreach my $codebase (@codebase) {
      $self->_simple_xml_escape($codebase);
      $ppd .= sprintf(<<'EOF', $codebase);
          <CODEBASE HREF="%s" />
  EOF
    }
  
    $ppd .= <<'EOF';
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
  
    my $ppd_file = "$dist{name}.ppd";
    open(my $fh, '>', $ppd_file)
      or die "Cannot write to $ppd_file: $!";
  
    binmode($fh, ":utf8")
      if $] >= 5.008 && $Config{useperlio};
    print $fh $ppd;
    close $fh;
  
    return $ppd_file;
  }
  
  sub _ppd_version {
    my ($self, $version) = @_;
  
    # generates something like "0,18,0,0"
    return join ',', (split(/\./, $version), (0)x4)[0..3];
  }
  
  sub _varchname {  # Copied from PPM.pm
    my ($self, $config) = @_;
    my $varchname = $config->{archname};
    # Append "-5.8" to architecture name for Perl 5.8 and later
    if ($] >= 5.008) {
        my $vstring = sprintf "%vd", $^V;
        $vstring =~ s/\.\d+$//;
        $varchname .= "-$vstring";
    }
    return $varchname;
  }
  
  {
    my %escapes = (
  		 "\n" => "\\n",
  		 '"' => '&quot;',
  		 '&' => '&amp;',
  		 '>' => '&gt;',
  		 '<' => '&lt;',
  		);
    my $rx = join '|', keys %escapes;
  
    sub _simple_xml_escape {
      $_[1] =~ s/($rx)/$escapes{$1}/go;
    }
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::PPMMaker - Perl Package Manager file creation
  
  =head1 SYNOPSIS
  
    On the command line, builds a .ppd file:
    ./Build ppd
  
  
  =head1 DESCRIPTION
  
  This package contains the code that builds F<.ppd> "Perl Package
  Description" files, in support of ActiveState's "Perl Package
  Manager".  Details are here:
  L<http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/>
  
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>, Ken Williams <kwilliams@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2006 Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3)
  
  =cut
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::Default - Stub class for unknown platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  our @ISA = qw(Module::Build::Base);
  
  use ExtUtils::Install;
  
  sub have_forkpipe { 0 }
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(@_);
  
    # $Config{sitelib} and $Config{sitearch} are, unfortunately, missing.
    foreach ('sitelib', 'sitearch') {
      $self->config($_ => $self->config("install$_"))
        unless $self->config($_);
    }
  
    # For some reason $Config{startperl} is filled with a bunch of crap.
    (my $sp = $self->config('startperl')) =~ s/.*Exit \{Status\}\s//;
    $self->config(startperl => $sp);
  
    return $self;
  }
  
  sub make_executable {
    my $self = shift;
    require MacPerl;
    foreach (@_) {
      MacPerl::SetFileInfo('McPL', 'TEXT', $_);
    }
  }
  
  sub dispatch {
    my $self = shift;
  
    if( !@_ and !@ARGV ) {
      require MacPerl;
  
      # What comes first in the action list.
      my @action_list = qw(build test install);
      my %actions = map {+($_, 1)} $self->known_actions;
      delete @actions{@action_list};
      push @action_list, sort { $a cmp $b } keys %actions;
  
      my %toolserver = map {+$_ => 1} qw(test disttest diff testdb);
      foreach (@action_list) {
        $_ .= ' *' if $toolserver{$_};
      }
  
      my $cmd = MacPerl::Pick("What build command? ('*' requires ToolServer)", @action_list);
      return unless defined $cmd;
      $cmd =~ s/ \*$//;
      $ARGV[0] = ($cmd);
  
      my $args = MacPerl::Ask('Any extra arguments?  (ie. verbose=1)', '');
      return unless defined $args;
      push @ARGV, $self->split_like_shell($args);
    }
  
    $self->SUPER::dispatch(@_);
  }
  
  sub ACTION_realclean {
    my $self = shift;
    chmod 0666, $self->{properties}{build_script};
    $self->SUPER::ACTION_realclean;
  }
  
  # ExtUtils::Install has a hard-coded '.' directory in versions less
  # than 1.30.  We use a sneaky trick to turn that into ':'.
  #
  # Note that we do it here in a cross-platform way, so this code could
  # actually go in Module::Build::Base.  But we put it here to be less
  # intrusive for other platforms.
  
  sub ACTION_install {
    my $self = shift;
  
    return $self->SUPER::ACTION_install(@_)
      if eval {ExtUtils::Install->VERSION('1.30'); 1};
  
    local $^W = 0; # Avoid a 'redefine' warning
    local *ExtUtils::Install::find = sub {
      my ($code, @dirs) = @_;
  
      @dirs = map { $_ eq '.' ? File::Spec->curdir : $_ } @dirs;
  
      return File::Find::find($code, @dirs);
    };
  
    return $self->SUPER::ACTION_install(@_);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Module::Build::Platform::MacOS - Builder class for MacOS platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base> and override a few methods.  Please see
  L<Module::Build> for the docs.
  
  =head2 Overridden Methods
  
  =over 4
  
  =item new()
  
  MacPerl doesn't define $Config{sitelib} or $Config{sitearch} for some
  reason, but $Config{installsitelib} and $Config{installsitearch} are
  there.  So we copy the install variables to the other location
  
  =item make_executable()
  
  On MacOS we set the file type and creator to MacPerl so it will run
  with a double-click.
  
  =item dispatch()
  
  Because there's no easy way to say "./Build test" on MacOS, if
  dispatch is called with no arguments and no @ARGV a dialog box will
  pop up asking what action to take and any extra arguments.
  
  Default action is "test".
  
  =item ACTION_realclean()
  
  Need to unlock the Build program before deleting.
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  sub is_executable {
    # We consider the owner bit to be authoritative on a file, because
    # -x will always return true if the user is root and *any*
    # executable bit is set.  The -x test seems to try to answer the
    # question "can I execute this file", but I think we want "is this
    # file executable".
  
    my ($self, $file) = @_;
    return +(stat $file)[2] & 0100;
  }
  
  sub _startperl { "#! " . shift()->perl }
  
  sub _construct {
    my $self = shift()->SUPER::_construct(@_);
  
    # perl 5.8.1-RC[1-3] had some broken %Config entries, and
    # unfortunately Red Hat 9 shipped it like that.  Fix 'em up here.
    my $c = $self->{config};
    for (qw(siteman1 siteman3 vendorman1 vendorman3)) {
      $c->{"install${_}dir"} ||= $c->{"install${_}"};
    }
  
    return $self;
  }
  
  # Open group says username should be portable filename characters,
  # but some Unix OS working with ActiveDirectory wind up with user-names
  # with back-slashes in the name.  The new code below is very liberal
  # in what it accepts.
  sub _detildefy {
    my ($self, $value) = @_;
    $value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username
      [$1 ?
       (eval{(getpwnam $1)[7]} || "~$1") :
       ($ENV{HOME} || eval{(getpwuid $>)[7]} || glob("~"))
      ]ex;
    return $value;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::Unix - Builder class for Unix platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  use Config;
  
  our @ISA = qw(Module::Build::Base);
  
  
  
  =head1 NAME
  
  Module::Build::Platform::VMS - Builder class for VMS platforms
  
  =head1 DESCRIPTION
  
  This module inherits from C<Module::Build::Base> and alters a few
  minor details of its functionality.  Please see L<Module::Build> for
  the general docs.
  
  =head2 Overridden Methods
  
  =over 4
  
  =item _set_defaults
  
  Change $self->{build_script} to 'Build.com' so @Build works.
  
  =cut
  
  sub _set_defaults {
      my $self = shift;
      $self->SUPER::_set_defaults(@_);
  
      $self->{properties}{build_script} = 'Build.com';
  }
  
  
  =item cull_args
  
  '@Build foo' on VMS will not preserve the case of 'foo'.  Rather than forcing
  people to write '@Build "foo"' we'll dispatch case-insensitively.
  
  =cut
  
  sub cull_args {
      my $self = shift;
      my($action, $args) = $self->SUPER::cull_args(@_);
      my @possible_actions = grep { lc $_ eq lc $action } $self->known_actions;
  
      die "Ambiguous action '$action'.  Could be one of @possible_actions"
          if @possible_actions > 1;
  
      return ($possible_actions[0], $args);
  }
  
  
  =item manpage_separator
  
  Use '__' instead of '::'.
  
  =cut
  
  sub manpage_separator {
      return '__';
  }
  
  
  =item prefixify
  
  Prefixify taking into account VMS' filepath syntax.
  
  =cut
  
  # Translated from ExtUtils::MM_VMS::prefixify()
  
  sub _catprefix {
      my($self, $rprefix, $default) = @_;
  
      my($rvol, $rdirs) = File::Spec->splitpath($rprefix);
      if( $rvol ) {
          return File::Spec->catpath($rvol,
                                     File::Spec->catdir($rdirs, $default),
                                     ''
                                    )
      }
      else {
          return File::Spec->catdir($rdirs, $default);
      }
  }
  
  
  sub _prefixify {
      my($self, $path, $sprefix, $type) = @_;
      my $rprefix = $self->prefix;
  
      return '' unless defined $path;
  
      $self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");
  
      # Translate $(PERLPREFIX) to a real path.
      $rprefix = VMS::Filespec::vmspath($rprefix) if $rprefix;
      $sprefix = VMS::Filespec::vmspath($sprefix) if $sprefix;
  
      $self->log_verbose("  rprefix translated to $rprefix\n".
                         "  sprefix translated to $sprefix\n");
  
      if( length($path) == 0 ) {
          $self->log_verbose("  no path to prefixify.\n")
      }
      elsif( !File::Spec->file_name_is_absolute($path) ) {
          $self->log_verbose("    path is relative, not prefixifying.\n");
      }
      elsif( $sprefix eq $rprefix ) {
          $self->log_verbose("  no new prefix.\n");
      }
      else {
          my($path_vol, $path_dirs) = File::Spec->splitpath( $path );
  	my $vms_prefix = $self->config('vms_prefix');
          if( $path_vol eq $vms_prefix.':' ) {
              $self->log_verbose("  $vms_prefix: seen\n");
  
              $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
              $path = $self->_catprefix($rprefix, $path_dirs);
          }
          else {
              $self->log_verbose("    cannot prefixify.\n");
  	    return $self->prefix_relpaths($self->installdirs, $type);
          }
      }
  
      $self->log_verbose("    now $path\n");
  
      return $path;
  }
  
  =item _quote_args
  
  Command-line arguments (but not the command itself) must be quoted
  to ensure case preservation.
  
  =cut
  
  sub _quote_args {
    # Returns a string that can become [part of] a command line with
    # proper quoting so that the subprocess sees this same list of args,
    # or if we get a single arg that is an array reference, quote the
    # elements of it and return the reference.
    my ($self, @args) = @_;
    my $got_arrayref = (scalar(@args) == 1
                        && ref $args[0] eq 'ARRAY')
                     ? 1
                     : 0;
  
    # Do not quote qualifiers that begin with '/'.
    map { if (!/^\//) {
            $_ =~ s/\"/""/g;     # escape C<"> by doubling
            $_ = q(").$_.q(");
          }
    }
      ($got_arrayref ? @{$args[0]}
                     : @args
      );
  
    return $got_arrayref ? $args[0]
                         : join(' ', @args);
  }
  
  =item have_forkpipe
  
  There is no native fork(), so some constructs depending on it are not
  available.
  
  =cut
  
  sub have_forkpipe { 0 }
  
  =item _backticks
  
  Override to ensure that we quote the arguments but not the command.
  
  =cut
  
  sub _backticks {
    # The command must not be quoted but the arguments to it must be.
    my ($self, @cmd) = @_;
    my $cmd = shift @cmd;
    my $args = $self->_quote_args(@cmd);
    return `$cmd $args`;
  }
  
  =item find_command
  
  Local an executable program
  
  =cut
  
  sub find_command {
      my ($self, $command) = @_;
  
      # a lot of VMS executables have a symbol defined
      # check those first
      if ( $^O eq 'VMS' ) {
          require VMS::DCLsym;
          my $syms = VMS::DCLsym->new;
          return $command if scalar $syms->getsym( uc $command );
      }
  
      $self->SUPER::find_command($command);
  }
  
  # _maybe_command copied from ExtUtils::MM_VMS::maybe_command
  
  =item _maybe_command (override)
  
  Follows VMS naming conventions for executable files.
  If the name passed in doesn't exactly match an executable file,
  appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
  to check for DCL procedure.  If this fails, checks directories in DCL$PATH
  and finally F<Sys$System:> for an executable file having the name specified,
  with or without the F<.Exe>-equivalent suffix.
  
  =cut
  
  sub _maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d _;
      my(@dirs) = ('');
      my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');
  
      if ($file !~ m![/:>\]]!) {
          for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
              my $dir = $ENV{"DCL\$PATH;$i"};
              $dir .= ':' unless $dir =~ m%[\]:]$%;
              push(@dirs,$dir);
          }
          push(@dirs,'Sys$System:');
          foreach my $dir (@dirs) {
              my $sysfile = "$dir$file";
              foreach my $ext (@exts) {
                  return $file if -x "$sysfile$ext" && ! -d _;
              }
          }
      }
      return;
  }
  
  =item do_system
  
  Override to ensure that we quote the arguments but not the command.
  
  =cut
  
  sub do_system {
    # The command must not be quoted but the arguments to it must be.
    my ($self, @cmd) = @_;
    $self->log_verbose("@cmd\n");
    my $cmd = shift @cmd;
    my $args = $self->_quote_args(@cmd);
    return !system("$cmd $args");
  }
  
  =item oneliner
  
  Override to ensure that we do not quote the command.
  
  =cut
  
  sub oneliner {
      my $self = shift;
      my $oneliner = $self->SUPER::oneliner(@_);
  
      $oneliner =~ s/^\"\S+\"//;
  
      return "MCR $^X $oneliner";
  }
  
  =item rscan_dir
  
  Inherit the standard version but remove dots at end of name.
  If the extended character set is in effect, do not remove dots from filenames
  with Unix path delimiters.
  
  =cut
  
  sub rscan_dir {
    my ($self, $dir, $pattern) = @_;
  
    my $result = $self->SUPER::rscan_dir( $dir, $pattern );
  
    for my $file (@$result) {
        if (!_efs() && ($file =~ m#/#)) {
            $file =~ s/\.$//;
        }
    }
    return $result;
  }
  
  =item dist_dir
  
  Inherit the standard version but replace embedded dots with underscores because
  a dot is the directory delimiter on VMS.
  
  =cut
  
  sub dist_dir {
    my $self = shift;
  
    my $dist_dir = $self->SUPER::dist_dir;
    $dist_dir =~ s/\./_/g unless _efs();
    return $dist_dir;
  }
  
  =item man3page_name
  
  Inherit the standard version but chop the extra manpage delimiter off the front if
  there is one.  The VMS version of splitdir('[.foo]') returns '', 'foo'.
  
  =cut
  
  sub man3page_name {
    my $self = shift;
  
    my $mpname = $self->SUPER::man3page_name( shift );
    my $sep = $self->manpage_separator;
    $mpname =~ s/^$sep//;
    return $mpname;
  }
  
  =item expand_test_dir
  
  Inherit the standard version but relativize the paths as the native glob() doesn't
  do that for us.
  
  =cut
  
  sub expand_test_dir {
    my ($self, $dir) = @_;
  
    my @reldirs = $self->SUPER::expand_test_dir( $dir );
  
    for my $eachdir (@reldirs) {
      my ($v,$d,$f) = File::Spec->splitpath( $eachdir );
      my $reldir = File::Spec->abs2rel( File::Spec->catpath( $v, $d, '' ) );
      $eachdir = File::Spec->catfile( $reldir, $f );
    }
    return @reldirs;
  }
  
  =item _detildefy
  
  The home-grown glob() does not currently handle tildes, so provide limited support
  here.  Expect only UNIX format file specifications for now.
  
  =cut
  
  sub _detildefy {
      my ($self, $arg) = @_;
  
      # Apparently double ~ are not translated.
      return $arg if ($arg =~ /^~~/);
  
      # Apparently ~ followed by whitespace are not translated.
      return $arg if ($arg =~ /^~ /);
  
      if ($arg =~ /^~/) {
          my $spec = $arg;
  
          # Remove the tilde
          $spec =~ s/^~//;
  
          # Remove any slash following the tilde if present.
          $spec =~ s#^/##;
  
          # break up the paths for the merge
          my $home = VMS::Filespec::unixify($ENV{HOME});
  
          # In the default VMS mode, the trailing slash is present.
          # In Unix report mode it is not.  The parsing logic assumes that
          # it is present.
          $home .= '/' unless $home =~ m#/$#;
  
          # Trivial case of just ~ by it self
          if ($spec eq '') {
              $home =~ s#/$##;
              return $home;
          }
  
          my ($hvol, $hdir, $hfile) = File::Spec::Unix->splitpath($home);
          if ($hdir eq '') {
               # Someone has tampered with $ENV{HOME}
               # So hfile is probably the directory since this should be
               # a path.
               $hdir = $hfile;
          }
  
          my ($vol, $dir, $file) = File::Spec::Unix->splitpath($spec);
  
          my @hdirs = File::Spec::Unix->splitdir($hdir);
          my @dirs = File::Spec::Unix->splitdir($dir);
  
          unless ($arg =~ m#^~/#) {
              # There is a home directory after the tilde, but it will already
              # be present in in @hdirs so we need to remove it by from @dirs.
  
              shift @dirs;
          }
          my $newdirs = File::Spec::Unix->catdir(@hdirs, @dirs);
  
          $arg = File::Spec::Unix->catpath($hvol, $newdirs, $file);
      }
      return $arg;
  
  }
  
  =item find_perl_interpreter
  
  On VMS, $^X returns the fully qualified absolute path including version
  number.  It's logically impossible to improve on it for getting the perl
  we're currently running, and attempting to manipulate it is usually
  lossy.
  
  =cut
  
  sub find_perl_interpreter {
      return VMS::Filespec::vmsify($^X);
  }
  
  =item localize_file_path
  
  Convert the file path to the local syntax
  
  =cut
  
  sub localize_file_path {
    my ($self, $path) = @_;
    $path = VMS::Filespec::vmsify($path);
    $path =~ s/\.\z//;
    return $path;
  }
  
  =item localize_dir_path
  
  Convert the directory path to the local syntax
  
  =cut
  
  sub localize_dir_path {
    my ($self, $path) = @_;
    return VMS::Filespec::vmspath($path);
  }
  
  =item ACTION_clean
  
  The home-grown glob() expands a bit too aggressively when given a bare name,
  so default in a zero-length extension.
  
  =cut
  
  sub ACTION_clean {
    my ($self) = @_;
    foreach my $item (map glob(VMS::Filespec::rmsexpand($_, '.;0')), $self->cleanup) {
      $self->delete_filetree($item);
    }
  }
  
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i;
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _efs {
      my $efs;
      if ($use_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i;
      }
      return $efs;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  Ken Williams <kwilliams@cpan.org>
  Craig A. Berry <craigberry@mac.com>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
  
  1;
  __END__
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::VOS - Builder class for VOS platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base>.  Please see the L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  use Config;
  use File::Basename;
  use File::Spec;
  
  use Module::Build::Base;
  
  our @ISA = qw(Module::Build::Base);
  
  
  sub manpage_separator {
      return '.';
  }
  
  sub have_forkpipe { 0 }
  
  sub _detildefy {
    my ($self, $value) = @_;
    $value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x
      if $ENV{HOME};
    return $value;
  }
  
  sub ACTION_realclean {
    my ($self) = @_;
  
    $self->SUPER::ACTION_realclean();
  
    my $basename = basename($0);
    $basename =~ s/(?:\.bat)?$//i;
  
    if ( lc $basename eq lc $self->build_script ) {
      if ( $self->build_bat ) {
        $self->log_verbose("Deleting $basename.bat\n");
        my $full_progname = $0;
        $full_progname =~ s/(?:\.bat)?$/.bat/i;
  
        # Voodoo required to have a batch file delete itself without error;
        # Syntax differs between 9x & NT: the later requires a null arg (???)
        require Win32;
        my $null_arg = (Win32::IsWinNT()) ? '""' : '';
        my $cmd = qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");
  
        open(my $fh, '>>', "$basename.bat")
          or die "Can't create $basename.bat: $!";
        print $fh $cmd;
        close $fh ;
      } else {
        $self->delete_filetree($self->build_script . '.bat');
      }
    }
  }
  
  sub make_executable {
    my $self = shift;
  
    $self->SUPER::make_executable(@_);
  
    foreach my $script (@_) {
  
      # Native batch script
      if ( $script =~ /\.(bat|cmd)$/ ) {
        $self->SUPER::make_executable($script);
        next;
  
      # Perl script that needs to be wrapped in a batch script
      } else {
        my %opts = ();
        if ( $script eq $self->build_script ) {
          $opts{ntargs}    = q(-x -S %0 --build_bat %*);
          $opts{otherargs} = q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9);
        }
  
        my $out = eval {$self->pl2bat(in => $script, update => 1, %opts)};
        if ( $@ ) {
          $self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@");
        } else {
          $self->SUPER::make_executable($out);
        }
      }
    }
  }
  
  # This routine was copied almost verbatim from the 'pl2bat' utility
  # distributed with perl. It requires too much voodoo with shell quoting
  # differences and shortcomings between the various flavors of Windows
  # to reliably shell out
  sub pl2bat {
    my $self = shift;
    my %opts = @_;
  
    # NOTE: %0 is already enclosed in doublequotes by cmd.exe, as appropriate
    $opts{ntargs}    = '-x -S %0 %*' unless exists $opts{ntargs};
    $opts{otherargs} = '-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists $opts{otherargs};
  
    $opts{stripsuffix} = '/\\.plx?/' unless exists $opts{stripsuffix};
    $opts{stripsuffix} = ($opts{stripsuffix} =~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");
  
    unless (exists $opts{out}) {
      $opts{out} = $opts{in};
      $opts{out} =~ s/$opts{stripsuffix}$//oi;
      $opts{out} .= '.bat' unless $opts{in} =~ /\.bat$/i or $opts{in} =~ /^-$/;
    }
  
    my $head = <<EOT;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
  
    $head =~ s/^\s+//gm;
    my $headlines = 2 + ($head =~ tr/\n/\n/);
    my $tail = "\n__END__\n:endofperl\n";
  
    my $linedone  = 0;
    my $taildone  = 0;
    my $linenum   = 0;
    my $skiplines = 0;
  
    my $start = $Config{startperl};
    $start = "#!perl" unless $start =~ /^#!.*perl/;
  
    open(my $in, '<', "$opts{in}") or die "Can't open $opts{in}: $!";
    my @file = <$in>;
    close($in);
  
    foreach my $line ( @file ) {
      $linenum++;
      if ( $line =~ /^:endofperl\b/ ) {
        if (!exists $opts{update}) {
          warn "$opts{in} has already been converted to a batch file!\n";
          return;
        }
        $taildone++;
      }
      if ( not $linedone and $line =~ /^#!.*perl/ ) {
        if (exists $opts{update}) {
          $skiplines = $linenum - 1;
          $line .= "#line ".(1+$headlines)."\n";
        } else {
  	$line .= "#line ".($linenum+$headlines)."\n";
        }
  	$linedone++;
      }
      if ( $line =~ /^#\s*line\b/ and $linenum == 2 + $skiplines ) {
        $line = "";
      }
    }
  
    open(my $out, '>', "$opts{out}") or die "Can't open $opts{out}: $!";
    print $out $head;
    print $out $start, ( $opts{usewarnings} ? " -w" : "" ),
               "\n#line ", ($headlines+1), "\n" unless $linedone;
    print $out @file[$skiplines..$#file];
    print $out $tail unless $taildone;
    close($out);
  
    return $opts{out};
  }
  
  
  sub _quote_args {
    # Returns a string that can become [part of] a command line with
    # proper quoting so that the subprocess sees this same list of args.
    my ($self, @args) = @_;
  
    my @quoted;
  
    for (@args) {
      if ( /^[^\s*?!\$<>;|'"\[\]\{\}]+$/ ) {
        # Looks pretty safe
        push @quoted, $_;
      } else {
        # XXX this will obviously have to improve - is there already a
        # core module lying around that does proper quoting?
        s/"/\\"/g;
        push @quoted, qq("$_");
      }
    }
  
    return join " ", @quoted;
  }
  
  
  sub split_like_shell {
    # As it turns out, Windows command-parsing is very different from
    # Unix command-parsing.  Double-quotes mean different things,
    # backslashes don't necessarily mean escapes, and so on.  So we
    # can't use Text::ParseWords::shellwords() to break a command string
    # into words.  The algorithm below was bashed out by Randy and Ken
    # (mostly Randy), and there are a lot of regression tests, so we
    # should feel free to adjust if desired.
  
    (my $self, local $_) = @_;
  
    return @$_ if defined() && ref() eq 'ARRAY';
  
    my @argv;
    return @argv unless defined() && length();
  
    my $length = length;
    m/\G\s*/gc;
  
    ARGS: until ( pos == $length ) {
      my $quote_mode;
      my $arg = '';
      CHARS: until ( pos == $length ) {
        if ( m/\G((?:\\\\)+)(?=\\?(")?)/gc ) {
            if (defined $2) {
                $arg .= '\\' x (length($1) / 2);
            }
            else {
                $arg .= $1;
            }
        }
        elsif ( m/\G\\"/gc ) {
          $arg .= '"';
        }
        elsif ( m/\G"/gc ) {
          if ( $quote_mode && m/\G"/gc ) {
              $arg .= '"';
          }
          $quote_mode = !$quote_mode;
        }
        elsif ( !$quote_mode && m/\G\s+/gc ) {
          last;
        }
        elsif ( m/\G(.)/sgc ) {
          $arg .= $1;
        }
      }
      push @argv, $arg;
    }
  
    return @argv;
  }
  
  
  # system(@cmd) does not like having double-quotes in it on Windows.
  # So we quote them and run it as a single command.
  sub do_system {
    my ($self, @cmd) = @_;
  
    my $cmd = $self->_quote_args(@cmd);
    my $status = system($cmd);
    if ($status and $! =~ /Argument list too long/i) {
      my $env_entries = '';
      foreach (sort keys %ENV) { $env_entries .= "$_=>".length($ENV{$_})."; " }
      warn "'Argument list' was 'too long', env lengths are $env_entries";
    }
    return !$status;
  }
  
  # Copied from ExtUtils::MM_Win32
  sub _maybe_command {
      my($self,$file) = @_;
      my @e = exists($ENV{'PATHEXT'})
            ? split(/;/, $ENV{PATHEXT})
  	  : qw(.com .exe .bat .cmd);
      my $e = '';
      for (@e) { $e .= "\Q$_\E|" }
      chop $e;
      # see if file ends in one of the known extensions
      if ($file =~ /($e)$/i) {
  	return $file if -e $file;
      }
      else {
  	for (@e) {
  	    return "$file$_" if -e "$file$_";
  	}
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::Build::Platform::Windows - Builder class for Windows platforms
  
  =head1 DESCRIPTION
  
  The sole purpose of this module is to inherit from
  C<Module::Build::Base> and override a few methods.  Please see
  L<Module::Build> for the docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3)
  
  =cut
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  # This class isn't necessary anymore, but we can't delete it, because
  # some people might still have the old copy in their @INC, containing
  # code we don't want to execute, so we have to make sure an upgrade
  # will replace it with this empty subclass.
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::aix - Builder class for AIX platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the AIX
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  sub manpage_separator {
     '.'
  }
  
  # Copied from ExtUtils::MM_Cygwin::maybe_command()
  # If our path begins with F</cygdrive/> then we use the Windows version
  # to determine if it may be a command.  Otherwise we use the tests
  # from C<ExtUtils::MM_Unix>.
  
  sub _maybe_command {
      my ($self, $file) = @_;
  
      if ($file =~ m{^/cygdrive/}i) {
          require Module::Build::Platform::Windows;
          return Module::Build::Platform::Windows->_maybe_command($file);
      }
  
      return $self->SUPER::_maybe_command($file);
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::cygwin - Builder class for Cygwin platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the cygwin
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Initial stub by Yitzchak Scott-Thoennes <sthoenna@efn.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  # This class isn't necessary anymore, but we can't delete it, because
  # some people might still have the old copy in their @INC, containing
  # code we don't want to execute, so we have to make sure an upgrade
  # will replace it with this empty subclass.
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::darwin - Builder class for Mac OS X platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the Mac OS X
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  use Module::Build::Platform::Unix;
  
  our @ISA = qw(Module::Build::Platform::Unix);
  
  sub manpage_separator { '.' }
  
  sub have_forkpipe { 0 }
  
  # Copied from ExtUtils::MM_OS2::maybe_command
  sub _maybe_command {
      my($self,$file) = @_;
      $file =~ s,[/\\]+,/,g;
      return $file if -x $file && ! -d _;
      return "$file.exe" if -x "$file.exe" && ! -d _;
      return "$file.cmd" if -x "$file.cmd" && ! -d _;
      return;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Module::Build::Platform::os2 - Builder class for OS/2 platform
  
  =head1 DESCRIPTION
  
  This module provides some routines very specific to the OS/2
  platform.
  
  Please see the L<Module::Build> for the general docs.
  
  =head1 AUTHOR
  
  Ken Williams <kwilliams@cpan.org>
  
  =head1 SEE ALSO
  
  perl(1), Module::Build(3), ExtUtils::MakeMaker(3)
  
  =cut
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;
  
  use strict;
  use warnings;
  our $VERSION = '0.4224';
  $VERSION = eval $VERSION;
  
  sub new {
    # Perl is so fun.
    my $package = shift;
  
    my $self;
    $self = bless {have_pod_parser => 0, @_}, $package;
  
    unless ($self->{fh}) {
      die "No 'file' or 'fh' parameter given" unless $self->{file};
      open($self->{fh}, '<', $self->{file}) or die "Couldn't open $self->{file}: $!";
    }
  
    return $self;
  }
  
  sub parse_from_filehandle {
    my ($self, $fh) = @_;
  
    local $_;
    while (<$fh>) {
      next unless /^=(?!cut)/ .. /^=cut/;  # in POD
      # Accept Name - abstract or C<Name> - abstract
      last if ($self->{abstract}) = /^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix;
    }
  
    my @author;
    while (<$fh>) {
      next unless /^=head1\s+AUTHORS?/i ... /^=/;
      next if /^=/;
      push @author, $_ if /\@/;
    }
    return unless @author;
    s/^\s+|\s+$//g foreach @author;
  
    $self->{author} = \@author;
  
    return;
  }
  
  sub get_abstract {
    my $self = shift;
    return $self->{abstract} if defined $self->{abstract};
  
    $self->parse_from_filehandle($self->{fh});
  
    return $self->{abstract};
  }
  
  sub get_author {
    my $self = shift;
    return $self->{author} if defined $self->{author};
  
    $self->parse_from_filehandle($self->{fh});
  
    return $self->{author} || [];
  }
MODULE_BUILD_PODPARSER

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2:tw=78
  package Module::Metadata; # git description: v1.000032-7-gb4e8a3f
  # ABSTRACT: Gather package and POD information from perl module files
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  sub __clean_eval { eval $_[0] }
  use strict;
  use warnings;
  
  our $VERSION = '1.000033';
  
  use Carp qw/croak/;
  use File::Spec;
  BEGIN {
         # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
         eval {
                 require Fcntl; Fcntl->import('SEEK_SET'); 1;
         } or *SEEK_SET = sub { 0 }
  }
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
      Log::Contextual->import('log_info',
        '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
      );
    }
    else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
            if ( defined( $version ) ) {
              if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                $err .= "  $p->{file} ($p->{version})\n";
              }
              else {
                # same version declared multiple times, ignore
              }
            }
            else {
              $file    = $p->{file};
              $version = $p->{version};
            }
          }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep { $args{version} eq $_ } qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      }
      else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
        my @path = split( /\//, $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            }
            else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          }
          else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              $result->{err}
            };
  
          }
          elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
          if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              };
            }
  
          }
          else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
          }
          else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
          }
  
        }
        else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
              $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( not $handle ) {
      my $filename = $self->{filename};
      open $handle, '<', $filename
        or croak( "Can't open '$filename': $!" );
  
      $self->_handle_bom($handle, $filename);
    }
    $self->_parse_fh($handle);
  
    @{$self->{packages}} = __uniq(@{$self->{packages}});
  
    unless($self->{module} and length($self->{module})) {
      # CAVEAT (possible TODO): .pmc files not treated the same as .pm
      if ($self->{filename} =~ /\.pm$/) {
        my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
        $f =~ s/\..+$//;
        my @candidates = grep /(^|::)$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # this may be undef
      }
      else {
        # this seems like an atrocious heuristic, albeit marginally better than
        # what was here before. It should be rewritten entirely to be more like
        # "if it's not a .pm file, it's not require()able as a name, therefore
        # name() should be undef."
        if ((grep /main/, @{$self->{packages}})
            or (grep /main/, keys %{$self->{versions}})) {
          $self->{module} = 'main';
        }
        else {
          # TODO: this should maybe default to undef instead
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
      if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      # CAVEAT (possible TODO): .pmc files are not discoverable here
      $testfile .= '.pm';
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile;
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sigil, $variable_name, $package);
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $package ) {
        $package = ($package eq '::') ? 'main' : $package;
        $package =~ s/::$//;
      }
    }
  
    return ( $sigil, $variable_name, $package );
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = tell $fh;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = read $fh, $buf, length $buf;
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    }
    elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    }
    elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = read $fh, $buf, length $buf;
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        binmode( $fh, ":encoding($encoding)" );
      }
    }
    else {
      seek $fh, $pos, SEEK_SET
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @packages, %vers, %pod, @pod );
    my $package = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
          push( @pod, $1 );
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = $1;
        }
        elsif ( $self->{collect_pod} ) {
          $pod_data .= "$line\n";
        }
        next;
      }
      elsif ( $is_cut ) {
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
        next;
      }
  
      # Skip after __END__
      next if $in_end;
  
      # Skip comments in code
      next if $line =~ /^\s*#/;
  
      # Would be nice if we could also check $in_string or something too
      if ($line eq '__END__') {
        $in_end++;
        next;
      }
  
      last if $line eq '__DATA__';
  
      # parse $line to see if it's a $VERSION declaration
      my( $version_sigil, $version_fullname, $version_package ) =
        index($line, 'VERSION') >= 1
          ? $self->_parse_version_expression( $line )
          : ();
  
      if ( $line =~ /$PKG_REGEXP/o ) {
        $package = $1;
        my $version = $2;
        push( @packages, $package ) unless grep( $package eq $_, @packages );
        $need_vers = defined $version ? 0 : 1;
  
        if ( not exists $vers{$package} and defined $version ){
          # Upgrade to a version object.
          my $dwim_version = eval { _dwim_version($version) };
          croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
            unless defined $dwim_version;  # "0" is OK!
          $vers{$package} = $dwim_version;
        }
      }
  
      # VERSION defined with full package spec, i.e. $Module::VERSION
      elsif ( $version_fullname && $version_package ) {
        # we do NOT save this package in found @packages
        $need_vers = 0 if $version_package eq $package;
  
        unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
          $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        }
      }
  
      # first non-comment line in undeclared package main is VERSION
      elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
        $need_vers = 0;
        my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        $vers{$package} = $v;
        push( @packages, 'main' );
      }
  
      # first non-comment line in undeclared package defines package main
      elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
        $need_vers = 1;
        $vers{main} = '';
        push( @packages, 'main' );
      }
  
      # only keep if this is the first $VERSION seen
      elsif ( $version_fullname && $need_vers ) {
        $need_vers = 0;
        my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
  
        unless ( defined $vers{$package} && length $vers{$package} ) {
          $vers{$package} = $v;
        }
      }
    } # end loop over each line
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@packages;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  sub __uniq (@)
  {
      my (%seen, $key);
      grep { not $seen{ $key = $_ }++ } @_;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $variable_name, $line ) = @_;
  
    # We compile into a local sub because 'use version' would cause
    # compiletime/runtime issues with local()
    $pn++; # everybody gets their own package
    my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        return \$$variable_name if defined \$$variable_name;
        return \$Module::Metadata::_version::p${pn}::$variable_name;
      };
    };
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    my $vsub = __clean_eval($eval);
    # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      $vsub = __clean_eval($eval);
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
  
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
  
    my $result = eval { $vsub->() };
    # FIXME: $eval is not the right thing to print here
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    # FIXME: $eval is not the right thing to print here
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
           exists( $self->{versions}{$mod} ) ) {
          return $self->{versions}{$mod};
      }
      else {
          return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
           exists( $self->{pod}{$sect} ) ) {
          return $self->{pod}{$sect};
      }
      else {
          return undef;
      }
  }
  
  sub is_indexable {
    my ($self, $package) = @_;
  
    my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;
  
    # check for specific package, if provided
    return !! grep { $_ eq $package } @indexable_packages if $package;
  
    # otherwise, check for any indexable packages at all
    return !! @indexable_packages;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 VERSION
  
  version 1.000033
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 CLASS METHODS
  
  =head2 C<< new_from_file($filename, collect_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  =head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> argument as described above,
  this method accepts a C<inc> argument which is a reference to an array of
  directories to search for the module.  If none are given, the default is
  @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =head2 C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =head2 C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =head2 C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =head1 OBJECT METHODS
  
  =head2 C<< name() >>
  
  Returns the name of the package represented by this module. If there
  is more than one package, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =head2 C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =head2 C<< filename() >>
  
  Returns the absolute path to the file.
  Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
  
  =head2 C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =head2 C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =head2 C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =head2 C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
  
  Available since version 1.000020.
  
  Returns a boolean indicating whether the package (if provided) or any package
  (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
  Note This only checks for valid C<package> declarations, and does not take any
  ownership information into account.
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata>
  (or L<bug-Module-Metadata@rt.cpan.org|mailto:bug-Module-Metadata@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/cpan-workers.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge David Golden Vincent Pit Matt S Trout Chris Nehren Graham Knop Olivier Mengué Tomas Doran Tatsuhiko Miyagawa tokuhirom Kent Fredric Peter Rabbitson Steve Hay Jerry D. Hedden Craig A. Berry Mitchell Steinbrunner Edward Zborowski Gareth Harper James Raspass 'BinGOs' Williams Josh Jore
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Vincent Pit <perl@profvince.com>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Tomas Doran <bobtfish@bobtfish.net>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  tokuhirom <tokuhirom@gmail.com>
  
  =item *
  
  Kent Fredric <kentnl@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Steve Hay <steve.m.hay@googlemail.com>
  
  =item *
  
  Jerry D. Hedden <jdhedden@cpan.org>
  
  =item *
  
  Craig A. Berry <cberry@cpan.org>
  
  =item *
  
  Craig A. Berry <craigberry@mac.com>
  
  =item *
  
  David Mitchell <davem@iabyn.com>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  Gareth Harper <gareth@broadbean.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =item *
  
  Josh Jore <jjore@cpan.org>
  
  =back
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
MODULE_METADATA

$fatpacked{"darwin-2level/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
DARWIN-2LEVEL_VERSION

$fatpacked{"darwin-2level/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
DARWIN-2LEVEL_VERSION_REGEX

$fatpacked{"darwin-2level/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
DARWIN-2LEVEL_VERSION_VPP

$fatpacked{"darwin-2level/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
DARWIN-2LEVEL_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl 

use strict;
use Module::Build 0.25;
use Getopt::Long;

my %opt_defs = (
		module      => {type => '=s',
				desc => 'The name of the module to configure (required)'},
		feature     => {type => ':s',
				desc => 'Print the value of a feature or all features'},
		config      => {type => ':s',
				desc => 'Print the value of a config option'},
		set_feature => {type => '=s%',
				desc => "Set a feature to 'true' or 'false'"},
		set_config  => {type => '=s%',
				desc => 'Set a config option to the given value'},
		eval        => {type => '',
				desc => 'eval() config values before setting'},
		help        => {type => '',
				desc => 'Print a help message and exit'},
	       );

my %opts;
GetOptions( \%opts, map "$_$opt_defs{$_}{type}", keys %opt_defs ) or die usage(%opt_defs);
print usage(%opt_defs) and exit(0)
  if $opts{help};

my @exclusive = qw(feature config set_feature set_config);
die "Exactly one of the options '" . join("', '", @exclusive) . "' must be specified\n" . usage(%opt_defs)
  unless grep(exists $opts{$_}, @exclusive) == 1;

die "Option --module is required\n" . usage(%opt_defs)
  unless $opts{module};

my $cf = load_config($opts{module});

if (exists $opts{feature}) {

  if (length $opts{feature}) {
    print $cf->feature($opts{feature});
  } else {
    my %auto;
    # note: need to support older ConfigData.pm's
    @auto{$cf->auto_feature_names} = () if $cf->can("auto_feature_names");

    print " Features defined in $cf:\n";
    foreach my $name (sort $cf->feature_names) {
      print "  $name => ", $cf->feature($name), (exists $auto{$name} ? " (dynamic)" : ""), "\n";
    }
  }

} elsif (exists $opts{config}) {

  require Data::Dumper;
  local $Data::Dumper::Terse = 1;

  if (length $opts{config}) {
    print Data::Dumper::Dumper($cf->config($opts{config})), "\n";
  } else {
    print " Configuration defined in $cf:\n";
    foreach my $name (sort $cf->config_names) {
      print "  $name => ", Data::Dumper::Dumper($cf->config($name)), "\n";
    }
  }

} elsif (exists $opts{set_feature}) {
  my %to_set = %{$opts{set_feature}};
  while (my ($k, $v) = each %to_set) {
    die "Feature value must be 0 or 1\n" unless $v =~ /^[01]$/;
    $cf->set_feature($k, 0+$v); # Cast to a number, not a string
  }
  $cf->write;
  print "Feature" . 's'x(keys(%to_set)>1) . " saved\n";

} elsif (exists $opts{set_config}) {

  my %to_set = %{$opts{set_config}};
  while (my ($k, $v) = each %to_set) {
    if ($opts{eval}) {
      $v = eval($v);
      die $@ if $@;
    }
    $cf->set_config($k, $v);
  }
  $cf->write;
  print "Config value" . 's'x(keys(%to_set)>1) . " saved\n";
}

sub load_config {
  my $mod = shift;

  $mod =~ /^([\w:]+)$/
    or die "Invalid module name '$mod'";

  my $cf = $mod . "::ConfigData";
  eval "require $cf";
  die $@ if $@;

  return $cf;
}

sub usage {
  my %defs = @_;

  my $out = "\nUsage: $0 [options]\n\n  Options include:\n";

  foreach my $name (sort keys %defs) {
    $out .= "  --$name";

    for ($defs{$name}{type}) {
      /^=s$/  and      $out .= " <string>";
      /^=s%$/ and      $out .= " <string>=<value>";
    }

    pad_line($out, 35);
    $out .= "$defs{$name}{desc}\n";
  }

  $out .= <<EOF;

  Examples:
   $0 --module Foo::Bar --feature bazzable
   $0 --module Foo::Bar --config magic_number
   $0 --module Foo::Bar --set_feature bazzable=1
   $0 --module Foo::Bar --set_config magic_number=42

EOF

  return $out;
}

sub pad_line {  $_[0] .= ' ' x ($_[1] - length($_[0]) + rindex($_[0], "\n")) }


__END__

=head1 NAME

config_data - Query or change configuration of Perl modules

=head1 SYNOPSIS

  # Get config/feature values
  config_data --module Foo::Bar --feature bazzable
  config_data --module Foo::Bar --config magic_number

  # Set config/feature values
  config_data --module Foo::Bar --set_feature bazzable=1
  config_data --module Foo::Bar --set_config magic_number=42

  # Print a usage message
  config_data --help

=head1 DESCRIPTION

The C<config_data> tool provides a command-line interface to the
configuration of Perl modules.  By "configuration", we mean something
akin to "user preferences" or "local settings".  This is a
formalization and abstraction of the systems that people like Andreas
Koenig (C<CPAN::Config>), Jon Swartz (C<HTML::Mason::Config>), Andy
Wardley (C<Template::Config>), and Larry Wall (perl's own Config.pm)
have developed independently.

The configuration system employed here was developed in the context of
C<Module::Build>.  Under this system, configuration information for a
module C<Foo>, for example, is stored in a module called
C<Foo::ConfigData>) (I would have called it C<Foo::Config>, but that
was taken by all those other systems mentioned in the previous
paragraph...).  These C<...::ConfigData> modules contain the
configuration data, as well as publicly accessible methods for
querying and setting (yes, actually re-writing) the configuration
data.  The C<config_data> script (whose docs you are currently
reading) is merely a front-end for those methods.  If you wish, you
may create alternate front-ends.

The two types of data that may be stored are called C<config> values
and C<feature> values.  A C<config> value may be any perl scalar,
including references to complex data structures.  It must, however, be
serializable using C<Data::Dumper>.  A C<feature> is a boolean (1 or
0) value.

=head1 USAGE

This script functions as a basic getter/setter wrapper around the
configuration of a single module.  On the command line, specify which
module's configuration you're interested in, and pass options to get
or set C<config> or C<feature> values.  The following options are
supported:

=over 4

=item module

Specifies the name of the module to configure (required).

=item feature

When passed the name of a C<feature>, shows its value.  The value will
be 1 if the feature is enabled, 0 if the feature is not enabled, or
empty if the feature is unknown.  When no feature name is supplied,
the names and values of all known features will be shown.

=item config

When passed the name of a C<config> entry, shows its value.  The value
will be displayed using C<Data::Dumper> (or similar) as perl code.
When no config name is supplied, the names and values of all known
config entries will be shown.

=item set_feature

Sets the given C<feature> to the given boolean value.  Specify the value
as either 1 or 0.

=item set_config

Sets the given C<config> entry to the given value.

=item eval

If the C<--eval> option is used, the values in C<set_config> will be
evaluated as perl code before being stored.  This allows moderately
complicated data structures to be stored.  For really complicated
structures, you probably shouldn't use this command-line interface,
just use the Perl API instead.

=item help

Prints a help message, including a few examples, and exits.

=back

=head1 AUTHOR

Ken Williams, kwilliams@cpan.org

=head1 COPYRIGHT

Copyright (c) 1999, Ken Williams.  All rights reserved.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 SEE ALSO

Module::Build(3), perl(1).

=cut
