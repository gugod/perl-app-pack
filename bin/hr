#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE



### code_after_shebang
# Note: This script is a CLI  for Riap function /App/hr/hr_app
# and generated automatically using Perinci::CmdLine::Gen version 0.31

# PERICMD_INLINE_SCRIPT: {"url":"/App/hr/hr_app","shebang":"perl","script_name":"hr","script_summary":null,"code_after_shebang":"...","log":null,"script_version":"0.25","include":["App::hr"],"subcommands":null,"skip_format":1}

# This script is generated by Perinci::CmdLine::Inline version 0.38 on Fri Jun 17 13:12:00 2016.
# You probably should not manually edit this file.

our $DATE = '2016-06-17'; # DATE
our $VERSION = '0.25'; # VERSION
# PODNAME: hr
# ABSTRACT: Print horizontal bar on the terminal

# BEGIN DATAPACK CODE
{
    my $toc;
    my $data_linepos = 1;
    unshift @INC, sub {
        $toc ||= do {

            my $fh = \*DATA;

        my $header_line;
        my $header_found;
        while (1) {
            my $header_line = <$fh>;
            defined($header_line)
                or die "Unexpected end of data section while reading header line";
            chomp($header_line);
            if ($header_line eq 'Data::Section::Seekable v1') {
                $header_found++;
                last;
            }
        }
        die "Can't find header 'Data::Section::Seekable v1'"
            unless $header_found;

        my %toc;
        my $i = 0;
        while (1) {
            $i++;
            my $toc_line = <$fh>;
            defined($toc_line)
                or die "Unexpected end of data section while reading TOC line #$i";
            chomp($toc_line);
            $toc_line =~ /\S/ or last;
            $toc_line =~ /^([^,]+),(\d+),(\d+)(?:,(.*))?$/
                or die "Invalid TOC line #$i in data section: $toc_line";
            $toc{$1} = [$2, $3, $4];
        }
        my $pos = tell $fh;
        $toc{$_}[0] += $pos for keys %toc;


            # calculate the line number of data section
            my $data_pos = tell(DATA);
            seek DATA, 0, 0;
            my $pos = 0;
            while (1) {
                my $line = <DATA>;
                $pos += length($line);
                $data_linepos++;
                last if $pos >= $data_pos;
            }
            seek DATA, $data_pos, 0;

            \%toc;
        };
        if ($toc->{$_[1]}) {
            seek DATA, $toc->{$_[1]}[0], 0;
            read DATA, my($content), $toc->{$_[1]}[1];
            my ($order, $lineoffset) = split(';', $toc->{$_[1]}[2]);
            $content =~ s/^#//gm;
            $content = "# line ".($data_linepos + $order+1 + $lineoffset)." \"".__FILE__."\"\n" . $content;
            open my $fh, '<', \$content
                or die "DataPacker error loading $_[1]: $!";
            return $fh;
        }
        return;
    };
}
# END DATAPACK CODE

package main;
use 5.010001;
use strict;
#use warnings;

### declare global variables

my $_pci_r = {naked_res=>0};
my %_pci_args;

### declare subroutines

sub _pci_err {
    my $res = shift;
    print STDERR "ERROR $res->[0]: $res->[1]\n";
    exit $res->[0]-300;
}

sub _pci_json {
    state $json = do {
        if    (eval { require JSON::XS; 1 }) { JSON::XS->new->canonical(1)->allow_nonref }
        elsif (eval { require JSON::PP; 1 }) { JSON::PP->new->canonical(1)->allow_nonref }
        else { require JSON::Tiny::Subclassable; JSON::Tiny::Subclassable->new }
    };
    $json;
}

### parse cmdline options

{
require Getopt::Long::EvenLess;
my %mentioned_args;
my $go_spec = {
    'H=i' => sub {
        $_pci_args{'height'} = $_[1];
    },
    'a=i' => sub {
        $_pci_args{'space_after'} = $_[1];
    },
    'b=i' => sub {
        $_pci_args{'space_before'} = $_[1];
    },
    'c=s' => sub {
        $_pci_args{'color'} = $_[1];
    },
    'color=s' => sub {
        $_pci_args{'color'} = $_[1];
    },
    'height=i' => sub {
        $_pci_args{'height'} = $_[1];
    },
    'help|h|?' => sub {
        print "hr - Print horizontal bar on the terminal\n\nUsage:\n  hr --help (or -h, -?)\n  hr --version (or -v)\n  hr [options] [pattern]\n\n`hr` can be useful as a marker/separator, especially if you use other commands\nthat might produce a lot of output, and you need to scroll back lots of pages to\nsee previous output. Example:\n\n    % hr; command-that-produces-lots-of-output\n    ============================================================================\n    Command output\n    ...\n    ...\n    ...\n\n    % hr -r; some-command; hr -r; another-command\n\nUsage:\n\n    % hr\n    ============================================================================\n\n    % hr -c red  ;# will output the same bar, but in red\n\n    % hr --random-color  ;# will output the same bar, but in random color\n\n    % hr x----\n    x----x----x----x----x----x----x----x----x----x----x----x----x----x----x----x\n\n    % hr -- -x-  ;# specify a pattern that starts with a dash\n    % hr -p -x-  ;# ditto\n\n    % hr --random-pattern\n    vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\n    % hr --random-pattern\n    *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---\n\n    % hr -r  ;# shortcut for --random-pattern --random-color\n\n    % hr --help\n\nIf you use Perl, you can also use the `hr` function in `App::hr` module.\n\nOther options:\n  --color=s, -c         Specify a color (see Term::ANSIColor)\n  --height=i, -H        Specify height (number of rows) [1]\n  --help, -h, -?        Display help message and exit\n  --pattern=s, -p       Specify a pattern (=arg[0])\n  --random-color        \n  --random-pattern      \n  --space-after=i, -a   Number of empty rows after drawing the bar [0]\n  --space-before=i, -b  Number of empty rows before drawing the bar [0]\n  --version, -v         Display program's version and exit\n  -r                    Alias for --random-pattern --random-color\n"; exit 0;
    },
    'p=s' => sub {
        $_pci_args{'pattern'} = $_[1];
    },
    'pattern=s' => sub {
        $_pci_args{'pattern'} = $_[1];
    },
    'r' => sub {
        my $code = sub{package App::hr;use warnings;use strict 'subs', 'vars';use feature 'say';$_[0]{'random_color'} = 1;$_[0]{'random_pattern'} = 1}; $code->(\%_pci_args);
    },
    'random-color' => sub {
        $_pci_args{'random_color'} = $_[1];
    },
    'random-pattern' => sub {
        $_pci_args{'random_pattern'} = $_[1];
    },
    'space-after=i' => sub {
        $_pci_args{'space_after'} = $_[1];
    },
    'space-before=i' => sub {
        $_pci_args{'space_before'} = $_[1];
    },
    'version|v' => sub {
        no warnings 'once';
        require App::hr;
        print "hr version ", "0.25", ($App::hr::DATE ? " ($App::hr::DATE)" : ''), "\n";
        print "  Generated by Perinci::CmdLine::Inline version 0.38 (2016-06-02)\n";
        exit 0;
    },
};
my $res = Getopt::Long::EvenLess::GetOptions(%$go_spec);
_pci_err([500, "GetOptions failed"]) unless $res;
require Local::_pci_check_args; $res = _pci_check_args(\%_pci_args);
_pci_err($res) if $res->[0] != 200;
$_pci_r->{args} = \%_pci_args;
}

### call function

{
require App::hr;
eval { $_pci_r->{res} = App::hr::hr_app(%_pci_args) };
if ($@) { $_pci_r->{res} = [500, "Function died: $@"] }
}

### format & display result

{
my $fres;
my $save_res; if (exists $_pci_r->{res}[3]{"cmdline.result"}) { $save_res = $_pci_r->{res}[2]; $_pci_r->{res}[2] = $_pci_r->{res}[3]{"cmdline.result"} }
my $is_success = $_pci_r->{res}[0] =~ /\A2/ || $_pci_r->{res}[0] == 304;
my $is_stream = $_pci_r->{res}[3]{stream} // undef // 0;
if ($is_success && (1 || $_pci_r->{res}[3]{"cmdline.skip_format"})) { $fres = $_pci_r->{res}[2] }
elsif ($is_success && $is_stream) {}
else { require Local::_pci_clean_json; require Perinci::Result::Format::Lite; $is_stream=0; _pci_clean_json($_pci_r->{res}); $fres = Perinci::Result::Format::Lite::format($_pci_r->{res}, ($_pci_r->{format} // $_pci_r->{res}[3]{"cmdline.default_format"} // "text"), $_pci_r->{naked_res}, 0) }

my $use_utf8 = $_pci_r->{res}[3]{"x.hint.result_binary"} ? 0 : 0;
if ($use_utf8) { binmode STDOUT, ":utf8" }
if ($is_stream) {
    my $code = $_pci_r->{res}[2]; if (ref($code) ne "CODE") { die "Result is a stream but no coderef provided" } if (0) { while(defined(my $l=$code->())) { print $l; print "\n" unless "" eq "buf"; } } else { while (defined(my $rec=$code->())) { print _pci_json()->encode($rec),"\n" } }
} else {
    print $fres;
}
if (defined $save_res) { $_pci_r->{res}[2] = $save_res }
}

### exit

{
my $status = $_pci_r->{res}[0];
my $exit_code = $_pci_r->{res}[3]{"cmdline.exit_code"} // ($status =~ /200|304/ ? 0 : ($status-300));
exit($exit_code);
}

=pod

=encoding UTF-8

=head1 NAME

hr - Print horizontal bar on the terminal

=head1 VERSION

This document describes version 0.25 of main (from Perl distribution App-hr), released on 2016-06-17.

=head1 SYNOPSIS

Usage:

 % hr [options] [pattern]

=head1 DESCRIPTION

C<hr> can be useful as a marker/separator, especially if you use other commands
that might produce a lot of output, and you need to scroll back lots of pages to
see previous output. Example:

 % hr; command-that-produces-lots-of-output
 ============================================================================
 Command output
 ...
 ...
 ...
 
 % hr -r; some-command; hr -r; another-command

Usage:

 % hr
 ============================================================================
 
 % hr -c red  ;# will output the same bar, but in red
 
 % hr --random-color  ;# will output the same bar, but in random color
 
 % hr x----
 x----x----x----x----x----x----x----x----x----x----x----x----x----x----x----x
 
 % hr -- -x-  ;# specify a pattern that starts with a dash
 % hr -p -x-  ;# ditto
 
 % hr --random-pattern
 vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
 
 % hr --random-pattern
 *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---
 
 % hr -r  ;# shortcut for --random-pattern --random-color
 
 % hr --help

If you use Perl, you can also use the C<hr> function in C<App::hr> module.

=head1 OPTIONS

C<*> marks required options.

=over

=item B<--color>=I<s>, B<-c>

Specify a color (see Term::ANSIColor).

=item B<--height>=I<i>, B<-H>

Specify height (number of rows).

Default value:

 1

=item B<--help>, B<-h>, B<-?>

Display help message and exit.

=item B<--pattern>=I<s>, B<-p>

Specify a pattern.

=item B<--random-color>

=item B<--random-pattern>

=item B<--space-after>=I<i>, B<-a>

Number of empty rows after drawing the bar.

Default value:

 0

=item B<--space-before>=I<i>, B<-b>

Number of empty rows before drawing the bar.

Default value:

 0

=item B<--version>, B<-v>

Display program's version and exit.

=item B<-r>

Alias for --random-pattern --random-color.

See C<--random-pattern>.

=back

=head1 COMPLETION

The distribution comes with a shell completer script (L<_hr>) for
this script.

=head2 bash

To activate bash completion for this script, put:

 complete -C _hr hr

in your bash startup (e.g. C<~/.bashrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is recommended, however, that you install L<shcompgen> which allows you to
activate completion scripts for several kinds of scripts on multiple shells.
Some CPAN distributions (those that are built with
L<Dist::Zilla::Plugin::GenShellCompletion>) will even automatically enable shell
completion for their included scripts (using C<shcompgen>) at installation time,
so you can immadiately have tab completion.

=head2 tcsh

To activate tcsh completion for this script, put:

 complete _hr 'p/*/`hr`/'

in your tcsh startup (e.g. C<~/.tcshrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is also recommended to install C<shcompgen> (see above).

=head2 other shells

For fish and zsh, install C<shcompgen> as described above.

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/App-hr>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-App-hr>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-hr>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2016 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

__DATA__
Data::Section::Seekable v1
App/hr.pm,18,5278,0;0
Getopt/Long/EvenLess.pm,5328,4721,1;207
Local/_pci_check_args.pm,10082,4647,2;376
Local/_pci_clean_json.pm,14762,3184,3;487
Scalar/Util/Numeric/PP.pm,17980,1353,4;538

### App/hr.pm ###
#package App::hr;
#
#
#use feature 'say';
#use strict 'subs', 'vars';
#use warnings;
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       hr
#                       hr_r
#               );
#
#our %SPEC;
#
#sub pick {
#    return undef unless @_;
#    return $_[@_*rand];
#}
#
#my $term_width;
#if (defined $ENV{COLUMNS}) {
#    $term_width = $ENV{COLUMNS};
#} elsif (eval { require Term::Size; 1 }) {
#    ($term_width, undef) = Term::Size::chars();
#} else {
#    $term_width = 80;
#}
#
#sub hr {
#    my ($pattern, $color) = @_;
#    $pattern = "=" if !defined($pattern) || !length($pattern);
#    my $n  = int($term_width / length($pattern))+1;
#    my $hr = substr(($pattern x $n), 0, $term_width);
#    if ($^O =~ /MSWin/) {
#        substr($hr, -1, 1) = '';
#    }
#    if ($color) {
#        require Term::ANSIColor;
#        $hr = Term::ANSIColor::colored([$color], $hr);
#    }
#    return $hr if defined(wantarray);
#    say $hr;
#}
#
#$SPEC{hr_app} = {
#    v => 1.1,
#    summary => 'Print horizontal bar on the terminal',
#    description => <<'_',
#
#`hr` can be useful as a marker/separator, especially if you use other commands
#that might produce a lot of output, and you need to scroll back lots of pages to
#see previous output. Example:
#
#    % hr; command-that-produces-lots-of-output
#    ============================================================================
#    Command output
#    ...
#    ...
#    ...
#
#    % hr -r; some-command; hr -r; another-command
#
#Usage:
#
#    % hr
#    ============================================================================
#
#    % hr -c red  ;# will output the same bar, but in red
#
#    % hr --random-color  ;# will output the same bar, but in random color
#
#    % hr x----
#    x----x----x----x----x----x----x----x----x----x----x----x----x----x----x----x
#
#    % hr -- -x-  ;# specify a pattern that starts with a dash
#    % hr -p -x-  ;# ditto
#
#    % hr --random-pattern
#    vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
#
#    % hr --random-pattern
#    *---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---*---
#
#    % hr -r  ;# shortcut for --random-pattern --random-color
#
#    % hr --help
#
#If you use Perl, you can also use the `hr` function in `App::hr` module.
#
#_
#    args_rels => {
#        'choose_one&' => [
#            [qw/color random_color/],
#            [qw/pattern random_pattern/],
#        ],
#    },
#    args => {
#        color => {
#            summary => 'Specify a color (see Term::ANSIColor)',
#            schema => 'str*',
#            cmdline_aliases => {c=>{}},
#        },
#        random_color => {
#            schema => ['bool', is=>1],
#        },
#        height => {
#            summary => 'Specify height (number of rows)',
#            schema => ['int*', min=>1],
#            default => 1,
#            cmdline_aliases => {H=>{}},
#        },
#        space_before => {
#            summary => 'Number of empty rows before drawing the bar',
#            schema => ['int*', min=>0],
#            default => 0,
#            cmdline_aliases => {b=>{}},
#        },
#        space_after => {
#            summary => 'Number of empty rows after drawing the bar',
#            schema => ['int*', min=>0],
#            default => 0,
#            cmdline_aliases => {a=>{}},
#        },
#        pattern => {
#            summary => 'Specify a pattern',
#            schema => 'str*',
#            pos => 0,
#            cmdline_aliases => {p=>{}},
#        },
#        random_pattern => {
#            schema => ['bool', is=>1],
#            cmdline_aliases => {
#                r => {
#                    summary => 'Alias for --random-pattern --random-color',
#                    is_flag => 1,
#                    code => sub {
#                        $_[0]{random_color} = 1;
#                        $_[0]{random_pattern} = 1;
#                    },
#                },
#            },
#        },
#    },
#};
#sub hr_app {
#    my %args = @_;
#
#    if ($args{random_color}) {
#        $args{color} = pick(
#            'red',
#            'bright_red',
#            'green',
#            'bright_green',
#            'blue',
#            'bright_blue',
#            'cyan',
#            'bright_cyan',
#            'magenta',
#            'bright_magenta',
#            'yellow',
#            'bright_yellow',
#            'white',
#            'bright_white',
#        );
#    }
#
#    if ($args{random_pattern}) {
#        $args{pattern} = pick(
#            '.',
#            '-',
#            '=',
#            'x',
#            'x-',
#            'x---',
#            'x-----',
#            '*',
#            '*-',
#            '*---',
#            '*-----',
#            '/\\',
#            'v',
#            'V',
#        );
#    }
#
#    my $res = hr($args{pattern}, $args{color});
#    $res = join(
#        "",
#        ("\n" x ($args{space_before} // 0)),
#        ("$res\n" x ($args{height} // 1)),
#        ("\n" x ($args{space_after} // 0)),
#    );
#
#    [200, "OK", $res];
#}
#
#sub hr_r {
#    my $res = hr_app(random_color=>1, random_pattern=>1);
#    my $hr  = $res->[2];
#    return $hr if defined(wantarray);
#    print $hr;
#}
#
#1;
#
### Getopt/Long/EvenLess.pm ###
#package Getopt::Long::EvenLess;
#
#our $DATE = '2015-06-19'; 
#our $VERSION = '0.04'; 
#
#use 5.010001;
#use strict 'subs', 'vars';
#
#our @EXPORT   = qw(GetOptions);
#our @EXPORT_OK = qw(GetOptionsFromArray);
#
#sub import {
#    my $pkg = shift;
#    my $caller = caller;
#    my @imp = @_ ? @_ : @EXPORT;
#    for my $imp (@imp) {
#        if (grep {$_ eq $imp} (@EXPORT, @EXPORT_OK)) {
#            *{"$caller\::$imp"} = \&{$imp};
#        } else {
#            die "$imp is not exported by ".__PACKAGE__;
#        }
#    }
#}
#
#sub GetOptionsFromArray {
#    my ($argv, %spec) = @_;
#
#    my $success = 1;
#
#    my %spec_by_opt_name;
#    for (keys %spec) {
#        my $orig = $_;
#        s/=[fios]\@?\z//;
#        s/\|.+//;
#        $spec_by_opt_name{$_} = $orig;
#    }
#
#    my $code_find_opt = sub {
#        my ($wanted, $short_mode) = @_;
#        my @candidates;
#      OPT_SPEC:
#        for my $spec (keys %spec) {
#            $spec =~ s/=[fios]\@?\z//;
#            my @opts = split /\|/, $spec;
#            for my $o (@opts) {
#                next if $short_mode && length($o) > 1;
#                if ($o eq $wanted) {
#                    @candidates = ($opts[0]);
#                    last OPT_SPEC;
#                } elsif (index($o, $wanted) == 0) {
#                    push @candidates, $opts[0];
#                    next OPT_SPEC;
#                }
#            }
#        }
#        if (!@candidates) {
#            warn "Unknown option: $wanted\n";
#            $success = 0;
#            return undef; 
#        } elsif (@candidates > 1) {
#            warn "Option $wanted is ambiguous (" .
#                join(", ", @candidates) . ")\n";
#            $success = 0;
#            return ''; 
#        }
#        return $candidates[0];
#    };
#
#    my $code_set_val = sub {
#        my $name = shift;
#
#        my $spec_key = $spec_by_opt_name{$name};
#        my $handler  = $spec{$spec_key};
#
#        $handler->({name=>$name}, @_ ? $_[0] : 1);
#    };
#
#    my $i = -1;
#    my @remaining;
#  ELEM:
#    while (++$i < @$argv) {
#        if ($argv->[$i] eq '--') {
#
#            push @remaining, @{$argv}[$i+1 .. @$argv-1];
#            last ELEM;
#
#        } elsif ($argv->[$i] =~ /\A--(.+?)(?:=(.*))?\z/) {
#
#            my ($used_name, $val_in_opt) = ($1, $2);
#            my $opt = $code_find_opt->($used_name);
#            if (!defined($opt)) {
#                push @remaining, $argv->[$i];
#                next ELEM;
#            } elsif (!length($opt)) {
#                next ELEM; 
#            }
#
#            my $spec = $spec_by_opt_name{$opt};
#            if ($spec =~ /=[fios]\@?\z/) {
#                if (defined $val_in_opt) {
#                    if (length $val_in_opt) {
#                        $code_set_val->($opt, $val_in_opt);
#                    } else {
#                        warn "Option $used_name requires an argument\n";
#                        $success = 0;
#                        next ELEM;
#                    }
#                } else {
#                    if ($i+1 >= @$argv) {
#                        warn "Option $used_name requires an argument\n";
#                        $success = 0;
#                        last ELEM;
#                    }
#                    $i++;
#                    $code_set_val->($opt, $argv->[$i]);
#                }
#            } else {
#                $code_set_val->($opt);
#            }
#
#        } elsif ($argv->[$i] =~ /\A-(.*)/) {
#
#            my $str = $1;
#          SHORT_OPT:
#            while ($str =~ s/(.)//) {
#                my $used_name = $1;
#                my $opt = $code_find_opt->($1, 'short');
#                next SHORT_OPT unless defined($opt) && length($opt);
#
#                my $spec = $spec_by_opt_name{$opt};
#                if ($spec =~ /=[fios]\@?\z/) {
#                    if (length $str) {
#                        $code_set_val->($opt, $str);
#                        next ELEM;
#                    } else {
#                        if ($i+1 >= @$argv) {
#                            warn "Option $used_name requires an argument\n";
#                            $success = 0;
#                            last ELEM;
#                        }
#                        $i++;
#                        $code_set_val->($opt, $argv->[$i]);
#                    }
#                } else {
#                    $code_set_val->($opt);
#                }
#            }
#
#        } else { 
#
#            push @remaining, $argv->[$i];
#            next;
#
#        }
#    }
#
#  RETURN:
#    splice @$argv, 0, ~~@$argv, @remaining; 
#    return $success;
#}
#
#sub GetOptions {
#    GetOptionsFromArray(\@ARGV, @_);
#}
#
#1;
#
#__END__
#
### Local/_pci_check_args.pm ###
#sub _pci_check_args {
#    my $args = shift;
#  FILL_FROM_POS: {
#        1;
#        if (@ARGV > 0) { if (exists $args->{"pattern"}) { return [400, "You specified --pattern but also argument #0"]; } else { $args->{"pattern"} = delete($ARGV[0]); } }
#    }
#    my @check_argv = @ARGV;
#
#    no warnings ('void');
#    require Scalar::Util::Numeric::PP;
#    my $_sahv_dpath;
#    my $_sahv_err;
#    if (exists $args->{"color"}) {
#        $_sahv_dpath = [];
#        ((defined($args->{"color"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
#        
#        &&
#        
#        ((!ref($args->{"color"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#    $args->{"height"} //= 1;
#    if (exists $args->{"height"}) {
#        $_sahv_dpath = [];
#        ((defined($args->{"height"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
#        
#        &&
#        
#        ((Scalar::Util::Numeric::PP::isint($args->{"height"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
#        
#        &&
#        
#        (
#        (($args->{"height"} >= 1) ? 1 : (($_sahv_err //= "Must be at least 1"),0)))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#    if (exists $args->{"pattern"}) {
#        $_sahv_dpath = [];
#        ((defined($args->{"pattern"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
#        
#        &&
#        
#        ((!ref($args->{"pattern"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#    if (exists $args->{"random_color"}) {
#        $_sahv_dpath = [];
#        (!defined($args->{"random_color"}) ? 1 : 
#        
#        (
#        ((!ref($args->{"random_color"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))
#        
#        &&
#        
#        (
#        (($args->{"random_color"} ? 1:0) == (1 ? 1:0) ? 1 : (($_sahv_err //= "Must have the value 1"),0)))))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#    if (exists $args->{"random_pattern"}) {
#        $_sahv_dpath = [];
#        (!defined($args->{"random_pattern"}) ? 1 : 
#        
#        (
#        ((!ref($args->{"random_pattern"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))
#        
#        &&
#        
#        (
#        (($args->{"random_pattern"} ? 1:0) == (1 ? 1:0) ? 1 : (($_sahv_err //= "Must have the value 1"),0)))))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#    $args->{"space_after"} //= 0;
#    if (exists $args->{"space_after"}) {
#        $_sahv_dpath = [];
#        ((defined($args->{"space_after"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
#        
#        &&
#        
#        ((Scalar::Util::Numeric::PP::isint($args->{"space_after"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
#        
#        &&
#        
#        (
#        (($args->{"space_after"} >= 0) ? 1 : (($_sahv_err //= "Must be at least 0"),0)))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#    $args->{"space_before"} //= 0;
#    if (exists $args->{"space_before"}) {
#        $_sahv_dpath = [];
#        ((defined($args->{"space_before"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
#        
#        &&
#        
#        ((Scalar::Util::Numeric::PP::isint($args->{"space_before"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
#        
#        &&
#        
#        (
#        (($args->{"space_before"} >= 0) ? 1 : (($_sahv_err //= "Must be at least 0"),0)))
#         ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
#    } 
#
#    return [400, "Missing required value for argument: color"] if exists($args->{"color"}) && !defined($args->{"color"});
#    return [400, "Missing required value for argument: height"] if exists($args->{"height"}) && !defined($args->{"height"});
#    return [400, "Missing required value for argument: pattern"] if exists($args->{"pattern"}) && !defined($args->{"pattern"});
#    return [400, "Missing required value for argument: space_after"] if exists($args->{"space_after"}) && !defined($args->{"space_after"});
#    return [400, "Missing required value for argument: space_before"] if exists($args->{"space_before"}) && !defined($args->{"space_before"});
#    _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
#    [200];
#}
#1;
### Local/_pci_clean_json.pm ###
#require Scalar::Util; use feature 'state'; sub _pci_clean_json { state $cleanser = sub {
#require Scalar::Util;
#my $data = shift;
#state %refs;
#state $ctr_circ;
#state $process_array;
#state $process_hash;
#if (!$process_array) { $process_array = sub { my $a = shift; for my $e (@$a) { my $ref=ref($e);
#    if ($ref && $refs{ $e }++) { if (++$ctr_circ <= 1) { $e = Data::Clone::clone($e); redo } else { $e = 'CIRCULAR'; $ref = '' } }
#    elsif ($ref eq 'DateTime') { $e = $e->epoch; $ref = ref($e) }
#    elsif ($ref eq 'Regexp') { $e = "$e"; $ref = "" }
#    elsif ($ref eq 'SCALAR') { $e = ${ $e }; $ref = ref($e) }
#    elsif ($ref eq 'Time::Moment') { $e = $e->epoch; $ref = ref($e) }
#    elsif ($ref eq 'version') { $e = "$e"; $ref = "" }
#    elsif (Scalar::Util::blessed($e)) { if (!$Data::Clean::_clone && 0) { $e = Acme::Damn::damn($e) } else { $e = Function::Fallback::CoreOrPP::_unbless_fallback($e) } $ref = ref($e) }
#    my $reftype=Scalar::Util::reftype($e)//"";
#    if ($reftype eq "ARRAY") { $process_array->($e) }
#    elsif ($reftype eq "HASH") { $process_hash->($e) }
#    elsif ($ref) { $e = $ref; $ref = "" }
#} } }
#if (!$process_hash) { $process_hash = sub { my $h = shift; for my $k (keys %$h) { my $ref=ref($h->{$k});
#    if ($ref && $refs{ $h->{$k} }++) { if (++$ctr_circ <= 1) { $h->{$k} = Data::Clone::clone($h->{$k}); redo } else { $h->{$k} = 'CIRCULAR'; $ref = '' } }
#    elsif ($ref eq 'DateTime') { $h->{$k} = $h->{$k}->epoch; $ref = ref($h->{$k}) }
#    elsif ($ref eq 'Regexp') { $h->{$k} = "$h->{$k}"; $ref = "" }
#    elsif ($ref eq 'SCALAR') { $h->{$k} = ${ $h->{$k} }; $ref = ref($h->{$k}) }
#    elsif ($ref eq 'Time::Moment') { $h->{$k} = $h->{$k}->epoch; $ref = ref($h->{$k}) }
#    elsif ($ref eq 'version') { $h->{$k} = "$h->{$k}"; $ref = "" }
#    elsif (Scalar::Util::blessed($h->{$k})) { if (!$Data::Clean::_clone && 0) { $h->{$k} = Acme::Damn::damn($h->{$k}) } else { $h->{$k} = Function::Fallback::CoreOrPP::_unbless_fallback($h->{$k}) } $ref = ref($h->{$k}) }
#    my $reftype=Scalar::Util::reftype($h->{$k})//"";
#    if ($reftype eq "ARRAY") { $process_array->($h->{$k}) }
#    elsif ($reftype eq "HASH") { $process_hash->($h->{$k}) }
#    elsif ($ref) { $h->{$k} = $ref; $ref = "" }
#} } }
#%refs = (); $ctr_circ=0;
#for ($data) { my $ref=ref($_);
#    if ($ref && $refs{ $_ }++) { if (++$ctr_circ <= 1) { $_ = Data::Clone::clone($_); redo } else { $_ = 'CIRCULAR'; $ref = '' } }
#    elsif ($ref eq 'DateTime') { $_ = $_->epoch; $ref = ref($_) }
#    elsif ($ref eq 'Regexp') { $_ = "$_"; $ref = "" }
#    elsif ($ref eq 'SCALAR') { $_ = ${ $_ }; $ref = ref($_) }
#    elsif ($ref eq 'Time::Moment') { $_ = $_->epoch; $ref = ref($_) }
#    elsif ($ref eq 'version') { $_ = "$_"; $ref = "" }
#    elsif (Scalar::Util::blessed($_)) { if (!$Data::Clean::_clone && 0) { $_ = Acme::Damn::damn($_) } else { $_ = Function::Fallback::CoreOrPP::_unbless_fallback($_) } $ref = ref($_) }
#    my $reftype=Scalar::Util::reftype($_)//"";
#    if ($reftype eq "ARRAY") { $process_array->($_) }
#    elsif ($reftype eq "HASH") { $process_hash->($_) }
#    elsif ($ref) { $_ = $ref; $ref = "" }
#}
#$data
#}
#;; $cleanser->(shift) }
#1;
### Scalar/Util/Numeric/PP.pm ###
#package Scalar::Util::Numeric::PP;
#
#our $DATE = '2016-01-22'; 
#our $VERSION = '0.04'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       isint
#                       isnum
#                       isnan
#                       isinf
#                       isneg
#                       isfloat
#               );
#
#sub isint {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?(?:0|[1-9][0-9]*)\s*\z/s;
#    0;
#}
#
#sub isnan($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?nan\s*\z/is;
#    0;
#}
#
#sub isinf($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?inf(?:inity)?\s*\z/is;
#    0;
#}
#
#sub isneg($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*-/;
#    0;
#}
#
#sub isnum($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if isint($_);
#    return 1 if isfloat($_);
#    0;
#}
#
#sub isfloat($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?
#                 (?: (?:0|[1-9][0-9]*)(\.[0-9]+)? | (\.[0-9]+) )
#                 ([eE][+-]?[0-9]+)?\s*\z/sx && $1 || $2 || $3;
#    return 1 if isnan($_) || isinf($_);
#    0;
#}
#
#1;
#
#__END__
#
