#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Encode/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENCODE_LOCALE';
  package Encode::Locale;
  
  use strict;
  our $VERSION = "1.05";
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetACP) {
  		    require Win32;
                      eval { Win32::GetACP() };
  		    *GetACP = sub { &Win32::GetACP } unless $@;
  		}
  		unless (defined &GetACP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetACP()');
  		}
  		if (defined &GetACP) {
  		    my $cp = GetACP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
              # only test one since set together
              unless (defined &GetInputCP) {
                  eval {
                      require Win32;
                      eval { Win32::GetConsoleCP() };
                      # manually "import" it since Win32->import refuses
                      *GetInputCP = sub { &Win32::GetConsoleCP } unless $@;
                      *GetOutputCP = sub { &Win32::GetConsoleOutputCP } unless $@;
                  };
                  unless (defined &GetInputCP) {
                      eval {
                          # try Win32::Console module for codepage to use
                          require Win32::Console;
                          eval { Win32::Console::InputCP() };
                          *GetInputCP = sub { &Win32::Console::InputCP }
                              unless $@;
                          *GetOutputCP = sub { &Win32::Console::OutputCP }
                              unless $@;
                      };
                  }
                  unless (defined &GetInputCP) {
                      # final fallback
                      *GetInputCP = *GetOutputCP = sub {
                          # another fallback that could work is:
                          # reg query HKLM\System\CurrentControlSet\Control\Nls\CodePage /v ACP
                          ((qx(chcp) || '') =~ /^Active code page: (\d+)/)
                              ? $1 : ();
                      };
                  }
  	    }
              my $cp = GetInputCP();
              $ENCODING_CONSOLE_IN = "cp$cp" if $cp;
              $cp = GetOutputCP();
              $ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode::Locale - Determine the locale encoding
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output to the terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suitable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>, L<Term::Encoding>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
ENCODE_LOCALE

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @EXPORT @EXPORT_OK $IMPLEMENTED_BY};    ## no critic qw(AutomaticExportation)
  use base qw(Exporter);
  
  BEGIN
  {
      $VERSION = '1.004';
  
      # Inherit manually
      require Exporter;
      @EXPORT    = qw{home};
      @EXPORT_OK = qw{
        home
        my_home
        my_desktop
        my_documents
        my_music
        my_pictures
        my_videos
        my_data
        my_dist_config
        my_dist_data
        users_home
        users_desktop
        users_documents
        users_music
        users_pictures
        users_videos
        users_data
      };
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($)    ## no critic qw(SubroutinePrototypes)
  {
      (defined $_[0] and not ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  
  sub _DRIVER ($$)    ## no critic qw(SubroutinePrototypes)
  {
      (defined _CLASS($_[0]) and eval "require $_[0]; 1" and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ($IMPLEMENTED_BY)
  {
      # Allow for custom HomeDir classes
      # Leave it as the existing value
  }
  elsif ($^O eq 'MSWin32')
  {
      # All versions of Windows
      $IMPLEMENTED_BY = 'File::HomeDir::Windows';
  }
  elsif ($^O eq 'darwin')
  {
      # 1st: try Mac::SystemDirectory by chansen
      if (eval "require Mac::SystemDirectory; 1")
      {
          $IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
      }
      elsif (eval "require Mac::Files; 1")
      {
          # 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
          $IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
      }
      else
      {
          # 3rd: fallback: pure perl
          $IMPLEMENTED_BY = 'File::HomeDir::Darwin';
      }
  }
  elsif ($^O eq 'MacOS')
  {
      # Legacy Mac OS
      $IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  }
  elsif (File::Which::which('xdg-user-dir'))
  {
      # freedesktop unixes
      $IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  }
  else
  {
      # Default to Unix semantics
      $IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  
  unless (_DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver'))
  {
      Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      $IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop
  {
      $IMPLEMENTED_BY->can('my_desktop')
        ? $IMPLEMENTED_BY->my_desktop
        : Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents
  {
      $IMPLEMENTED_BY->can('my_documents')
        ? $IMPLEMENTED_BY->my_documents
        : Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music
  {
      $IMPLEMENTED_BY->can('my_music')
        ? $IMPLEMENTED_BY->my_music
        : Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures
  {
      $IMPLEMENTED_BY->can('my_pictures')
        ? $IMPLEMENTED_BY->my_pictures
        : Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos
  {
      $IMPLEMENTED_BY->can('my_videos')
        ? $IMPLEMENTED_BY->my_videos
        : Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data
  {
      $IMPLEMENTED_BY->can('my_data')
        ? $IMPLEMENTED_BY->my_data
        : Carp::croak("The my_data method is not implemented on this platform");
  }
  
  sub my_dist_data
  {
      my $params = ref $_[-1] eq 'HASH' ? pop : {};
      my $dist = pop or Carp::croak("The my_dist_data method requires an argument");
      my $data = my_data();
  
      # If datadir is not defined, there's nothing we can do: bail out
      # and return nothing...
      return undef unless defined $data;
  
      # On traditional unixes, hide the top-level directory
      my $var =
        $data eq home()
        ? File::Spec->catdir($data, '.perl', 'dist', $dist)
        : File::Spec->catdir($data, 'Perl',  'dist', $dist);
  
      # directory exists: return it
      return $var if -d $var;
  
      # directory doesn't exist: check if we need to create it...
      return undef unless $params->{create};
  
      # user requested directory creation
      require File::Path;
      File::Path::mkpath($var);
      return $var;
  }
  
  sub my_dist_config
  {
      my $params = ref $_[-1] eq 'HASH' ? pop : {};
      my $dist = pop or Carp::croak("The my_dist_config method requires an argument");
  
      # not all platforms support a specific my_config() method
      my $config =
          $IMPLEMENTED_BY->can('my_config')
        ? $IMPLEMENTED_BY->my_config
        : $IMPLEMENTED_BY->my_documents;
  
      # If neither configdir nor my_documents is defined, there's
      # nothing we can do: bail out and return nothing...
      return undef unless defined $config;
  
      # On traditional unixes, hide the top-level dir
      my $etc =
        $config eq home()
        ? File::Spec->catdir($config, '.perl', $dist)
        : File::Spec->catdir($config, 'Perl',  $dist);
  
      # directory exists: return it
      return $etc if -d $etc;
  
      # directory doesn't exist: check if we need to create it...
      return undef unless $params->{create};
  
      # user requested directory creation
      require File::Path;
      File::Path::mkpath($etc);
      return $etc;
  }
  
  #####################################################################
  # General User Methods
  
  sub users_home
  {
      $IMPLEMENTED_BY->can('users_home')
        ? $IMPLEMENTED_BY->users_home($_[-1])
        : Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop
  {
      $IMPLEMENTED_BY->can('users_desktop')
        ? $IMPLEMENTED_BY->users_desktop($_[-1])
        : Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents
  {
      $IMPLEMENTED_BY->can('users_documents')
        ? $IMPLEMENTED_BY->users_documents($_[-1])
        : Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music
  {
      $IMPLEMENTED_BY->can('users_music')
        ? $IMPLEMENTED_BY->users_music($_[-1])
        : Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures
  {
      $IMPLEMENTED_BY->can('users_pictures')
        ? $IMPLEMENTED_BY->users_pictures($_[-1])
        : Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos
  {
      $IMPLEMENTED_BY->can('users_videos')
        ? $IMPLEMENTED_BY->users_videos($_[-1])
        : Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data
  {
      $IMPLEMENTED_BY->can('users_data')
        ? $IMPLEMENTED_BY->users_data($_[-1])
        : Carp::croak("The users_data method is not implemented on this platform");
  }
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$)    ## no critic qw(SubroutinePrototypes)
  {
      # Allow to be called as a method
      if ($_[0] and $_[0] eq 'File::HomeDir')
      {
          shift();
      }
  
      # No params means my home
      return my_home() unless @_;
  
      # Check the param
      my $name = shift;
      if (!defined $name)
      {
          Carp::croak("Can't use undef as a username");
      }
      if (!length $name)
      {
          Carp::croak("Can't use empty-string (\"\") as a username");
      }
  
      # A dot also means my home
      ### Is this meant to mean File::Spec->curdir?
      if ($name eq '.')
      {
          return my_home();
      }
  
      # Now hand off to the implementor
      $IMPLEMENTED_BY->users_home($name);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =begin html
  
  <a href="https://travis-ci.org/perl5-utils/File-HomeDir"><img src="https://travis-ci.org/perl5-utils/File-HomeDir.svg?branch=master" alt="Travis CI"/></a>
  <a href='https://coveralls.io/github/perl5-utils/File-HomeDir?branch=master'><img src='https://coveralls.io/repos/github/perl5-utils/File-HomeDir/badge.svg?branch=master' alt='Coverage Status'/></a>
  
  =end html
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typically your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementations required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalization. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should store their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's home directory,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's home directory, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single parameter and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head2 users_desktop
  
    $docs = File::HomeDir->users_desktop('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a desktop directory, or dies on error.
  
  =head2 users_music
  
    $docs = File::HomeDir->users_music('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a music directory, or dies on error.
  
  =head2 users_pictures
  
    $docs = File::HomeDir->users_pictures('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a pictures directory, or dies on error.
  
  =head2 users_videos
  
    $docs = File::HomeDir->users_videos('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a videos directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no parameter, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jérôme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.008003;
  use strict;
  use warnings;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Unix";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  #####################################################################
  # Current User Methods
  
  sub _my_home
  {
      my ($class, $path) = @_;
      my $home = $class->my_home;
      return undef unless defined $home;
  
      my $folder = "$home/$path";
      unless (-d $folder)
      {
          # Make sure that symlinks resolve to directories.
          return undef unless -l $folder;
          my $dir = readlink $folder or return;
          return undef unless -d $dir;
      }
  
      return Cwd::abs_path($folder);
  }
  
  sub my_desktop
  {
      my $class = shift;
      $class->_my_home('Desktop');
  }
  
  sub my_documents
  {
      my $class = shift;
      $class->_my_home('Documents');
  }
  
  sub my_data
  {
      my $class = shift;
      $class->_my_home('Library/Application Support');
  }
  
  sub my_music
  {
      my $class = shift;
      $class->_my_home('Music');
  }
  
  sub my_pictures
  {
      my $class = shift;
      $class->_my_home('Pictures');
  }
  
  sub my_videos
  {
      my $class = shift;
      $class->_my_home('Movies');
  }
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home
  {
      my $class = shift;
      my $home  = $class->SUPER::users_home(@_);
      return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_desktop, $name);
  }
  
  sub users_documents
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_documents, $name);
  }
  
  sub users_data
  {
      my ($class, $name) = @_;
      $class->_to_user($class->my_data, $name)
        || $class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user
  {
      my ($class, $path, $name) = @_;
      my $my_home    = $class->my_home;
      my $users_home = $class->users_home($name);
      defined $users_home or return undef;
      $path =~ s/^\Q$my_home/$users_home/;
      return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.008003;
  use strict;
  use warnings;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION};
  
  # This is only a child class of the pure Perl darwin
  # class so that we can do homedir detection of all three
  # drivers at one via ->isa.
  use base "File::HomeDir::Darwin";
  
  BEGIN
  {
      $VERSION = '1.004';
  
      # Load early if in a forking environment and we have
      # prefork, or at run-time if not.
      local $@;                           ## no critic (Variables::RequireInitializationForLocalVars)
      eval "use prefork 'Mac::Files'";    ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
  }
  
  #####################################################################
  # Current User Methods
  
  ## no critic qw(UnusedPrivateSubroutines)
  sub _guess_determined_home
  {
      my $class = shift;
  
      require Mac::Files;
      my $home = $class->_find_folder(Mac::Files::kCurrentUserFolderType(),);
      $home ||= $class->SUPER::_guess_determined_home($@);
      return $home;
  }
  
  sub my_desktop
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kDesktopFolderType(),);
  }
  
  sub my_documents
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kDocumentsFolderType(),);
  }
  
  sub my_data
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kApplicationSupportFolderType(),);
  }
  
  sub my_music
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kMusicDocumentsFolderType(),);
  }
  
  sub my_pictures
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kPictureDocumentsFolderType(),);
  }
  
  sub my_videos
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kMovieDocumentsFolderType(),);
  }
  
  sub _find_folder
  {
      my $class = shift;
      my $name  = shift;
  
      require Mac::Files;
      my $folder = Mac::Files::FindFolder(Mac::Files::kUserDomain(), $name,);
      return undef unless defined $folder;
  
      unless (-d $folder)
      {
          # Make sure that symlinks resolve to directories.
          return undef unless -l $folder;
          my $dir = readlink $folder or return;
          return undef unless -d $dir;
      }
  
      return Cwd::abs_path($folder);
  }
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home
  {
      my $class = shift;
      my $home  = $class->SUPER::users_home(@_);
      return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_desktop, $name);
  }
  
  sub users_documents
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_documents, $name);
  }
  
  sub users_data
  {
      my ($class, $name) = @_;
      $class->_to_user($class->my_data, $name)
        || $class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user
  {
      my ($class, $path, $name) = @_;
      my $my_home    = $class->my_home;
      my $users_home = $class->users_home($name);
      defined $users_home or return undef;
      $path =~ s/^\Q$my_home/$users_home/;
      return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.008003;
  use strict;
  use warnings;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Darwin";
  
  BEGIN
  {
      $VERSION = '1.004';
  
      # Load early if in a forking environment and we have
      # prefork, or at run-time if not.
      local $@;                                     ## no critic (Variables::RequireInitializationForLocalVars)
      eval "use prefork 'Mac::SystemDirectory'";    ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
  }
  
  #####################################################################
  # Current User Methods
  
  ## no critic qw(UnusedPrivateSubroutines)
  sub _guess_determined_home
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      my $home = Mac::SystemDirectory::HomeDirectory();
      $home ||= $class->SUPER::_guess_determined_home($@);
      return $home;
  }
  
  # from 10.4
  sub my_desktop
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory()) }
        || $class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory()) }
        || $class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory()) }
        || $class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSMusicDirectory()) }
        || $class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory()) }
        || $class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory()) }
        || $class->SUPER::my_videos;
  }
  
  sub _find_folder
  {
      my $class = shift;
      my $name  = shift;
  
      require Mac::SystemDirectory;
      my $folder = Mac::SystemDirectory::FindDirectory($name);
      return undef unless defined $folder;
  
      unless (-d $folder)
      {
          # Make sure that symlinks resolve to directories.
          return undef unless -l $folder;
          my $dir = readlink $folder or return;
          return undef unless -d $dir;
      }
  
      return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp ();
  
  use vars qw{$VERSION};
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  sub my_home
  {
      Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Unix";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my
  {
      # No quoting because input is hard-coded and only comes from this module
      my $thingy = qx($xdgprog $_[1]);
      chomp $thingy;
      return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP') }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC') }
  sub my_pictures  { shift->_my('PICTURES') }
  sub my_videos    { shift->_my('VIDEOS') }
  
  sub my_data
  {
      $ENV{XDG_DATA_HOME}
        or File::Spec->catdir(shift->my_home, qw{ .local share });
  }
  
  sub my_config
  {
      $ENV{XDG_CONFIG_HOME}
        or File::Spec->catdir(shift->my_home, qw{ .config });
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD') }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES') }
  
  sub my_cache
  {
      $ENV{XDG_CACHE_HOME}
        || File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.'); }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.'); }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.'); }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.'); }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.'); }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module can operate only when the command C<xdg-user-dir> is available
  and executable, which is typically achieved by installed a package named
  C<xdg-user-dirs> or similar.
  
  One can find the latest spec at L<https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home     = File::HomeDir->my_home;        # /home/mylogin
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $config   = File::HomeDir->my_config;
    
    # Some undocumented ones, expect they don't work - use with caution
    $download    = File::HomeDir->my_download;
    $publicshare = File::HomeDir->my_publicshare;
    $templates   = File::HomeDir->my_templates;
    $cache       = File::HomeDir->my_cache;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE:
  {
      ## no critic qw(RequireInitializationForLocalVars, RequireCheckingReturnValueOfEval)
      local $@;
      eval "use prefork 'Mac::Files'";
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      my $class = shift;
  
      # Try for $ENV{HOME} if we have it
      if (defined $ENV{HOME})
      {
          return $ENV{HOME};
      }
  
      ### DESPERATION SETS IN
  
      # We could use the desktop
    SCOPE:
      {
          ## no critic qw(RequireInitializationForLocalVars, RequireCheckingReturnValueOfEval)
          local $@;
          eval {
              my $home = $class->my_desktop;
              return $home if $home and -d $home;
          };
      }
  
      # Desperation on any platform
    SCOPE:
      {
          # On some platforms getpwuid dies if called at all
          local $SIG{'__DIE__'} = '';
          my $home = (getpwuid($<))[7];
          return $home if $home and -d $home;
      }
  
      Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop
  {
      my $class = shift;
  
      # Find the desktop via Mac::Files
      local $SIG{'__DIE__'} = '';
      require Mac::Files;
      my $home = Mac::Files::FindFolder(Mac::Files::kOnSystemDisk(), Mac::Files::kDesktopFolderType(),);
      return $home if $home and -d $home;
  
      Carp::croak("Could not locate current user's desktop");
  }
  
  #####################################################################
  # General User Methods
  
  sub users_home
  {
      my ($class, $name) = @_;
  
    SCOPE:
      {
          # On some platforms getpwnam dies if called at all
          local $SIG{'__DIE__'} = '';
          my $home = (getpwnam($name))[7];
          return $home if defined $home and -d $home;
      }
  
      Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macintosh systems
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION %DIR $ENABLED};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
      %DIR     = ();
      $ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import
  {
      my $class = shift;
      Carp::croak "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
      # Fill the test directories
      my $BASE = File::Temp::tempdir(CLEANUP => 1);
      %DIR = map { $_ => File::Spec->catdir($BASE, $_) } qw{
        my_home
        my_desktop
        my_documents
        my_data
        my_music
        my_pictures
        my_videos
      };
  
      # Hijack HOME to the home directory
      $ENV{HOME} = $DIR{my_home};    ## no critic qw(LocalizedPunctuationVars)
  
      # Make File::HomeDir load us instead of the native driver
      $File::HomeDir::IMPLEMENTED_BY =    # Prevent a warning
        $File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
      # Ready to go
      $ENABLED = 1;
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      mkdir($DIR{my_home}, oct(755)) unless -d $DIR{my_home};
      return $DIR{my_home};
  }
  
  sub my_desktop
  {
      mkdir($DIR{my_desktop}, oct(755)) unless -d $DIR{my_desktop};
      return $DIR{my_desktop};
  }
  
  sub my_documents
  {
      mkdir($DIR{my_documents}, oct(755)) unless -f $DIR{my_documents};
      return $DIR{my_documents};
  }
  
  sub my_data
  {
      mkdir($DIR{my_data}, oct(755)) unless -d $DIR{my_data};
      return $DIR{my_data};
  }
  
  sub my_music
  {
      mkdir($DIR{my_music}, oct(755)) unless -d $DIR{my_music};
      return $DIR{my_music};
  }
  
  sub my_pictures
  {
      mkdir($DIR{my_pictures}, oct(755)) unless -d $DIR{my_pictures};
      return $DIR{my_pictures};
  }
  
  sub my_videos
  {
      mkdir($DIR{my_videos}, oct(755)) unless -d $DIR{my_videos};
      return $DIR{my_videos};
  }
  
  sub users_home
  {
      return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      my $class = shift;
      my $home  = $class->_guess_home(@_);
  
      # On Unix in general, a non-existent home means "no home"
      # For example, "nobody"-like users might use /nonexistent
      if (defined $home and not -d $home)
      {
          $home = undef;
      }
  
      return $home;
  }
  
  sub _guess_env_home
  {
      my $class = shift;
      if (exists $ENV{HOME} and defined $ENV{HOME} and length $ENV{HOME})
      {
          return $ENV{HOME};
      }
  
      # This is from the original code, but I'm guessing
      # it means "login directory" and exists on some Unixes.
      if (exists $ENV{LOGDIR} and $ENV{LOGDIR})
      {
          return $ENV{LOGDIR};
      }
  
      return;
  }
  
  sub _guess_determined_home
  {
      my $class = shift;
  
      # Light desperation on any (Unixish) platform
    SCOPE:
      {
          my $home = (getpwuid($<))[7];
          return $home if $home and -d $home;
      }
  
      return;
  }
  
  sub _guess_home
  {
      my $class = shift;
      my $home  = $class->_guess_env_home($@);
      $home ||= $class->_guess_determined_home($@);
      return $home;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop
  {
      shift->my_home;
  }
  
  sub my_documents
  {
      shift->my_home;
  }
  
  sub my_data
  {
      shift->my_home;
  }
  
  sub my_music
  {
      shift->my_home;
  }
  
  sub my_pictures
  {
      shift->my_home;
  }
  
  sub my_videos
  {
      shift->my_home;
  }
  
  #####################################################################
  # General User Methods
  
  sub users_home
  {
      my ($class, $name) = @_;
  
      # IF and only if we have getpwuid support, and the
      # name of the user is our own, shortcut to my_home.
      # This is needed to handle HOME environment settings.
      if ($name eq getpwuid($<))
      {
          return $class->my_home;
      }
  
    SCOPE:
      {
          my $home = (getpwnam($name))[7];
          return $home if $home and -d $home;
      }
  
      return undef;
  }
  
  sub users_desktop
  {
      shift->users_home(@_);
  }
  
  sub users_documents
  {
      shift->users_home(@_);
  }
  
  sub users_data
  {
      shift->users_home(@_);
  }
  
  sub users_music
  {
      shift->users_home(@_);
  }
  
  sub users_pictures
  {
      shift->users_home(@_);
  }
  
  sub users_videos
  {
      shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  sub CREATE () { 1 }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      my $class = shift;
  
      # A lot of unix people and unix-derived tools rely on
      # the ability to overload HOME. We will support it too
      # so that they can replace raw HOME calls with File::HomeDir.
      if (exists $ENV{HOME} and defined $ENV{HOME} and length $ENV{HOME})
      {
          return $ENV{HOME};
      }
  
      # Do we have a user profile?
      if (exists $ENV{USERPROFILE} and $ENV{USERPROFILE})
      {
          return $ENV{USERPROFILE};
      }
  
      # Some Windows use something like $ENV{HOME}
      if (exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH})
      {
          return File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',);
      }
  
      return undef;
  }
  
  sub my_desktop
  {
      my $class = shift;
  
      # The most correct way to find the desktop
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      # MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
      foreach my $e ('USERPROFILE', 'WINDIR')
      {
          next unless $ENV{$e};
          my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
          return $desktop if $desktop and $class->_d($desktop);
      }
  
      # As a last resort, try some hard-wired values
      foreach my $fixed (
          # The reason there are both types of slash here is because
          # this set of paths has been kept from the original version
          # of File::HomeDir::Win32 (before it was rewritten).
          # I can only assume this is Cygwin-related stuff.
          "C:\\windows\\desktop",
          "C:\\win95\\desktop",
          "C:/win95/desktop",
          "C:/windows/desktop",
        )
      {
          return $fixed if $class->_d($fixed);
      }
  
      return undef;
  }
  
  sub my_documents
  {
      my $class = shift;
  
      # The most correct way to find my documents
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_data
  {
      my $class = shift;
  
      # The most correct way to find my documents
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_music
  {
      my $class = shift;
  
      # The most correct way to find my music
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_pictures
  {
      my $class = shift;
  
      # The most correct way to find my pictures
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_videos
  {
      my $class = shift;
  
      # The most correct way to find my videos
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  # Special case version of -d
  sub _d
  {
      my $self = shift;
      my $path = shift;
  
      # Window can legally return a UNC path from GetFolderPath.
      # Not only is the meaning of -d complicated in this situation,
      # but even on a local network calling -d "\\\\cifs\\path" can
      # take several seconds. UNC can also do even weirder things,
      # like launching processes and such.
      # To avoid various crazy bugs caused by this, we do NOT attempt
      # to validate UNC paths at all so that the code that is calling
      # us has an opportunity to take special actions without our
      # blundering getting in the way.
      if ($path =~ /\\\\/)
      {
          return 1;
      }
  
      # Otherwise do a stat as normal
      return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organizations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use strict;
  use warnings;
  use Exporter   ();
  use File::Spec ();
  
  # ABSTRACT: Perl implementation of the which utility as an API
  our $VERSION = '1.22'; # VERSION
  
  
  our @ISA       = 'Exporter';
  our @EXPORT    = 'which';
  our @EXPORT_OK = 'where';
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  use constant IS_CYG => ($^O eq 'cygwin' || $^O eq 'msys');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
    # WinNT. PATHEXT might be set on Cygwin, but not used.
    if ( $ENV{PATHEXT} ) {
      push @PATHEXT, split ';', $ENV{PATHEXT};
    } else {
      # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
      push @PATHEXT, qw{.com .exe .bat};
    }
  } elsif ( IS_VMS ) {
    push @PATHEXT, qw{.exe .com};
  } elsif ( IS_CYG ) {
    # See this for more info
    # http://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-exe
    push @PATHEXT, qw{.exe .com};
  }
  
  
  sub which {
    my ($exec) = @_;
  
    return undef unless defined $exec;
    return undef if $exec eq '';
  
    my $all = wantarray;
    my @results = ();
  
    # check for aliases first
    if ( IS_VMS ) {
      my $symbol = `SHOW SYMBOL $exec`;
      chomp($symbol);
      unless ( $? ) {
        return $symbol unless $all;
        push @results, $symbol;
      }
    }
    if ( IS_MAC ) {
      my @aliases = split /\,/, $ENV{Aliases};
      foreach my $alias ( @aliases ) {
        # This has not been tested!!
        # PPT which says MPW-Perl cannot resolve `Alias $alias`,
        # let's just hope it's fixed
        if ( lc($alias) eq lc($exec) ) {
          chomp(my $file = `Alias $alias`);
          last unless $file;  # if it failed, just go on the normal way
          return $file unless $all;
          push @results, $file;
          # we can stop this loop as if it finds more aliases matching,
          # it'll just be the same result anyway
          last;
        }
      }
    }
  
    return $exec
            if !IS_VMS and !IS_MAC and !IS_DOS and $exec =~ /\// and -f $exec and -x $exec;
  
    my @path = File::Spec->path;
    if ( IS_DOS or IS_VMS or IS_MAC ) {
      unshift @path, File::Spec->curdir;
    }
  
    foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
      for my $ext ( @PATHEXT ) {
        my $file = $base.$ext;
  
        # We don't want dirs (as they are -x)
        next if -d $file;
  
        if (
          # Executable, normal case
          -x _
          or (
            # MacOS doesn't mark as executable so we check -e
            IS_MAC
            ||
            (
              ( IS_DOS or IS_CYG )
              and
              grep {
                $file =~ /$_\z/i
              } @PATHEXT[1..$#PATHEXT]
            )
            # DOSish systems don't pass -x on
            # non-exe/bat/com files. so we check -e.
            # However, we don't want to pass -e on files
            # that aren't in PATHEXT, like README.
            and -e _
          )
        ) {
          return $file unless $all;
          push @results, $file;
        }
      }
    }
  
    if ( $all ) {
      return @results;
    } else {
      return undef;
    }
  }
  
  
  sub where {
    # force wantarray
    my @res = which($_[0]);
    return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Which - Perl implementation of the which utility as an API
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
   use File::Which;                  # exports which()
   use File::Which qw(which where);  # exports which() and where()
   
   my $exe_path = which 'perldoc';
   
   my @paths = where 'perl';
   # Or
   my @paths = which 'perl'; # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  L<File::Which> finds the full or relative paths to executable programs on
  the system.  This is normally the function of C<which> utility.  C<which> is
  typically implemented as either a program or a built in shell command.  On
  some platforms, such as Microsoft Windows it is not provided as part of the
  core operating system.  This module provides a consistent API to this
  functionality regardless of the underlying platform.
  
  The focus of this module is correctness and portability.  As a consequence
  platforms where the current directory is implicitly part of the search path
  such as Microsoft Windows will find executables in the current directory,
  whereas on platforms such as UNIX where this is not the case executables 
  in the current directory will only be found if the current directory is
  explicitly added to the path.
  
  If you need a portable C<which> on the command line in an environment that
  does not provide it, install L<App::pwhich> which provides a command line
  interface to this API.
  
  =head2 Implementations
  
  L<File::Which> searches the directories of the user's C<PATH> (the current
  implementation uses L<File::Spec#path> to determine the correct C<PATH>),
  looking for executable files having the name specified as a parameter to
  L</which>. Under Win32 systems, which do not have a notion of directly
  executable files, but uses special extensions such as C<.exe> and C<.bat>
  to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head3 Linux, *BSD and other UNIXes
  
  There should not be any surprises here.  The current directory will not be
  searched unless it is explicitly added to the path.
  
  =head3 Modern Windows (including NT, XP, Vista, 7, 8, 10 etc)
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head3 Cygwin
  
  Cygwin provides a Unix-like environment for Microsoft Windows users.  In most
  ways it works like other Unix and Unix-like environments, but in a few key
  aspects it works like Windows.  As with other Unix environments, the current
  directory is not included in the search unless it is explicitly included in
  the search path.  Like on Windows, files with C<.EXE> or <.BAT> extensions will
  be discovered even if they are not part of the query.  C<.COM> or extensions
  specified using the C<PATHEXT> environment variable will NOT be discovered
  without the fully qualified name, however.
  
  =head3 Windows 95, 98, ME, MS-DOS, OS/2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  As of 2015 none of these platforms are tested frequently (or perhaps ever),
  but the current maintainer is determined not to intentionally remove support
  for older operating systems.
  
  =head3 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  As of 2015 the current maintainer does not test on VMS, and is in fact not
  certain it has ever been tested on VMS.  If this platform is important to you
  and you can help me verify and or support it on that platform please contact
  me.
  
  =head1 FUNCTIONS
  
  =head2 which
  
   my $path = which $short_exe_name;
   my @paths = which $short_exe_name;
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where
  
   my @paths = where $short_exe_name;
  
  Not exported by default.
  
  Same as L</which> in array context. Same as the
  C<where> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 CAVEATS
  
  This module has no non-core requirements for Perl 5.6.2 and better.
  
  This module is fully supported back to Perl 5.8.1.  It may work on 5.8.0.  
  It should work on Perl 5.6.x and I may even test on 5.6.2.  I will accept
  patches to maintain compatibility for such older Perls, but you may
  need to fix it on 5.6.x / 5.8.0 and send me a patch.
  
  Not tested on VMS although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  =head1 SUPPORT
  
  Bugs should be reported via the GitHub issue tracker
  
  L<https://github.com/plicease/File-Which/issues>
  
  For other issues, contact the maintainer.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<pwhich>, L<App::pwhich>
  
  Command line interface to this module.
  
  =item L<IPC::Cmd>
  
  Comes with a C<can_run> function with slightly different semantics that
  the traditional UNIX where.  It will find executables in the current
  directory, even though the current directory is not searched for by
  default on Unix.
  
  =item L<Devel::CheckBin>
  
  This module purports to "check that a command is available", but does not
  provide any documentation on how you might use it.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Per Einar Ellefsen <pereinar@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2002 by Per Einar Ellefsen <pereinar@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_WHICH

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Term/ANSIScreen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_ANSISCREEN';
  use 5.005;
  package Term::ANSIScreen;
  $Term::ANSIScreen::VERSION = '1.50';
  
  use strict;
  use vars qw/@ISA @EXPORT %EXPORT_TAGS $VERSION $AUTOLOAD
              %attributes %attributes_r %sequences $AUTORESET $EACHLINE/;
  use Exporter;
  
  =head1 NAME
  
  Term::ANSIScreen - Terminal control using ANSI escape sequences
  
  =head1 SYNOPSIS
  
      # qw/:color/ is exported by default, i.e. color() & colored()
  
      use Term::ANSIScreen qw/:color :cursor :screen :keyboard/;
  
      print setmode(1), setkey('a','b');
      print "40x25 mode now, with 'a' mapped to 'b'.";
      <STDIN>; resetkey; setmode 3; cls;
  
      locate 1, 1; print "@ This is (1,1)", savepos;
      print locate(24,60), "@ This is (24,60)"; loadpos;
      print down(2), clline, "@ This is (3,15)\n";
  
      setscroll 1, 20;
  
      color 'black on white'; clline;
      print "This line is black on white.\n";
      print color 'reset'; print "This text is normal.\n";
  
      print colored ("This text is bold blue.\n", 'bold blue');
      print "This text is normal.\n";
      print colored ['bold blue'], "This text is bold blue.\n";
      print "This text is normal.\n";
  
      use Term::ANSIScreen qw/:constants/; # constants mode
      print BLUE ON GREEN . "Blue on green.\n";
  
      $Term::ANSIScreen::AUTORESET = 1;
      print BOLD GREEN . ON_BLUE "Bold green on blue.", CLEAR;
      print "\nThis text is normal.\n";
  
      # Win32::Console emulation mode
      # this returns a Win32::Console object on a Win32 platform
      my $console = Term::ANSIScreen->new;
      $console->Cls;	# also works on non-Win32 platform
  
  =cut
  
  # -----------------------
  # Internal data structure
  # -----------------------
  
  %attributes = (
      'clear'      => 0,    'reset'      => 0,
      'bold'       => 1,    'dark'       => 2,
      'underline'  => 4,    'underscore' => 4,
      'blink'      => 5,    'reverse'    => 7,
      'concealed'  => 8,
  
      'black'      => 30,   'on_black'   => 40,
      'red'        => 31,   'on_red'     => 41,
      'green'      => 32,   'on_green'   => 42,
      'yellow'     => 33,   'on_yellow'  => 43,
      'blue'       => 34,   'on_blue'    => 44,
      'magenta'    => 35,   'on_magenta' => 45,
      'cyan'       => 36,   'on_cyan'    => 46,
      'white'      => 37,   'on_white'   => 47,
  );
  
  %sequences = (
      'up'        => '?A',      'down'      => '?B',
      'right'     => '?C',      'left'      => '?D',
      'savepos'   => 's',       'loadpos'   => 'u',
      'cls'       => '2J',      'clline'    => 'K',
      'cldown'    => '0J',      'clup'      => '1J',
      'locate'    => '?;?H',    'setmode'   => '?h',
      'wrapon'    => '7h',      'wrapoff'   => '7l',
      'setscroll'	=> '?;?r',
  );
  
  my %mapped;
  
  # ----------------
  # Exporter section
  # ----------------
  
  @ISA         = qw/Exporter/;
  %EXPORT_TAGS = (
      'color'     => [qw/color colored uncolor/],
      'cursor'    => [qw/locate up down right left savepos loadpos/],
      'screen'    => [qw/cls clline cldown clup setmode wrapon wrapoff setscroll/],
      'keyboard'  => [qw/setkey resetkey/],
      'constants' => [map {uc($_)} keys(%attributes), 'ON'],
  );
  
  $EXPORT_TAGS{all} = [map {@{$_}} values (%EXPORT_TAGS)];
  
  @EXPORT = qw(color colored);
  Exporter::export_ok_tags (keys(%EXPORT_TAGS));
  
  sub new {
      my $class = shift;
  
      if ($^O eq 'MSWin32' and eval { require Win32::Console } ) {
          return Win32::Console->new(@_);
      }
  
      no strict 'refs';
      unless ($main::FG_WHITE) {
          foreach my $color (grep { $attributes{$_} >= 30 } keys %attributes) {
              my $name = "FG_\U$color";
              $name =~ s/^FG_ON_/BG_/;
              ${"main::$name"} = color($color);
              $name =~ s/_/_LIGHT/;
              ${"main::$name"} = color('bold', $color);
          }
          $main::FG_LIGHTWHITE = $main::FG_WHITE;
          $main::FG_BROWN      = $main::FG_YELLOW;
          $main::FG_YELLOW     = $main::FG_LIGHTYELLOW;
          $main::FG_WHITE      = color('clear');
      }
      
      return bless([ @_ ], $class);
  }
  
  sub Attr {
      shift;
      print STDERR @_;
  }
  
  sub Cls {
      print STDERR cls();
  }
  
  sub Cursor {
      shift;
      print STDERR locate($_[1]+1, $_[0]+1);
  }
  
  sub Write {
      shift;
      print STDERR @_;
  }
  
  sub Display {
  }
  
  
  # --------------
  # Implementation
  # --------------
  
  sub AUTOLOAD {
      my $enable_colors = !defined $ENV{ANSI_COLORS_DISABLED};
      my $sub = $AUTOLOAD;
      $sub =~ s/^.*:://;
  
      if (my $seq = $sequences{$sub}) {
  	return '' unless $enable_colors;
  
          $seq =~ s/\?/defined($_[0]) ? shift(@_) : 1/eg;
          return((defined wantarray) ? "\e[$seq"
                                     : print("\e[$seq"));
      }
      elsif (defined(my $attr = $attributes{lc($sub)}) and $sub =~ /^[A-Z_]+$/) {
  	my $out = "@_";
  	if ($enable_colors) {
  	    $out = "\e[${attr}m" . $out;
  	    $out .= "\e[0m" if ($AUTORESET and @_ and $out !~ /\e\[0m$/s);
  	}
          return((defined wantarray) ? $out
                                     : print($out));
      }
      else {
  	require Carp;
          Carp::croak("Undefined subroutine &$AUTOLOAD called");
      }
  }
  
  # ------------------------------------------------
  # Convert foreground constants to background ones,
  # for sequences like (XXX ON YYY "text")
  # ------------------------------------------------
  
  sub ON {
      return '' if defined $ENV{ANSI_COLORS_DISABLED};
  
      my $out = "@_";
      $out =~ s/^\e\[3(\d)m/\e\[4$1m/;
      return $out;
  }
  
  # ---------------------------------------
  # Color subroutines, from Term::ANSIColor
  # ---------------------------------------
  
  sub color {
      return '' if defined $ENV{ANSI_COLORS_DISABLED};
  
      my @codes = map { split } @_;
      my $attribute;
  
      no warnings 'uninitialized';
      while (my $code = lc(shift(@codes))) {
          $code .= '_' . shift(@codes) if ($code eq 'on');
  
          if (defined $attributes{$code}) {
              $attribute .= $attributes{$code} . ';';
          }
          else {
              warn "Invalid attribute name $code";
          }
      }
  
      if ($attribute) {
          chop $attribute;
          return (defined wantarray) ? "\e[${attribute}m"
                                     : print("\e[${attribute}m");
      }
  }
  
  sub colored {
      my $output;
      my ($string, $attr) = (ref $_[0])
          ? (join('', @_[1..$#_]), color(@{$_[0]}))
          : (+shift, color(@_));
  
      return $string if defined $ENV{ANSI_COLORS_DISABLED};
  
      if (defined $EACHLINE) {
          $output  = join '',
              map { ($_ && $_ ne $EACHLINE) ? $attr . $_ . "\e[0m" : $_ }
                  split (/(\Q$EACHLINE\E)/, $string);
      } else {
          $output = "$attr$string\e[0m";
      }
  
      return (defined wantarray) ? $output
                                 : print($output);
  }
  
  sub uncolor {
      my (@nums, @result);
  
      foreach my $seq (@_) {
          my $escape = $seq;
          $escape =~ s/^\e\[//;
          $escape =~ s/m$//;
          unless ($escape =~ /^((?:\d+;)*\d*)$/) {
              require Carp;
              Carp::croak("Bad escape sequence $seq");
          }
          push (@nums, split (/;/, $1));
      }
  
      _init_attributes_r();
  
      foreach my $num (@nums) {
          $num += 0; # Strip leading zeroes
          my $name = $attributes_r{$num};
          if (!defined $name) {
              require Carp;
              Carp::croak("No name for escape sequence $num" );
          }
          push (@result, $name);
      }
  
      return @result;
  }
  
  sub _init_attributes_r {
      return if %attributes_r;
  
      # Reverse lookup.  Alphabetically first name for a sequence is preferred.
      for (reverse sort keys %attributes) {
  	$attributes_r{$attributes{$_}} = $_;
      }
  }
  
  sub setkey {
      my ($key, $mapto) = @_;
  
      if ($key eq $mapto) {
          delete $mapped{$key} if exists $mapped{$key};
      }
      else {
          $mapped{$key} = 1;
      }
  
      $key   = ord($key)    unless ($key =~ /^\d+;\d+$/);
      $mapto = qq("$mapto") unless ($mapto =~ /^\d+;\d+$/);
  
      return (defined wantarray) ? "\e[$key;${mapto}p"
                                 : print("\e[$key;${mapto}p");
  }
  
  sub resetkey {
      my $output;
  
      foreach my $key (@_ ? @_ : keys(%mapped)) {
          $output .= setkey($key, $key);
      }
  
      return (defined wantarray) ? $output
                                 : print($output);
  }
  
  sub DESTROY {
      return;
  }
  
  1;
  
  __END__
  
  =head1 DESCRIPTION
  
  Term::ANSIScreen is a superset of B<Term::ANSIColor> (as of version 1.04
  of that module).  In addition to color-sequence generating subroutines
  exported by C<:color> and C<:constants>, this module also features
  C<:cursor> for cursor positioning, C<:screen> for screen control, as
  well as C<:keyboard> for key mapping.
  
  =head2 NOTES
  
  =over 4
  
  =item *
  
  All subroutines in B<Term::ANSIScreen> will print its return value if
  called under a void context.
  
  =item *
  
  The cursor position, current color, screen mode and keyboard
  mappings affected by B<Term::ANSIScreen> will last after the program
  terminates. You might want to reset them before the end of
  your program.
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 B<Win32::Console> emulation mode
  
  When used in a object-oriented fashion, B<Term::ANSIScreen> acts as a
  B<Win32::Console> clone:
  
      use Term::ANSIScreen;
      my $console = Term::ANSIScreen->new;
      $console->Cls();		# unbuffered
      $console->Cursor(0, 0);	# same as locate(1, 1)
      $console->Display();	# really a no-op
  
  On the Win32 platform, the C<new> constructor simply returns a geniune
  B<Win32::Console> object, if that module exists in the system.
  
  This feature is intended for people who has to port Win32 console
  applications to other platforms, or to write cross-platform application
  that needs terminal controls.
  
  =head2 The C<:color> function set (exported by default)
  
  B<Term::ANSIScreen> recognizes (case-insensitively) following color
  attributes: clear, reset, bold, underline, underscore, blink,
  reverse, concealed, black, red, green, blue, white, yellow, magenta,
  cyan, on_black, on_red, on_green, on_blue, on_white, on_yellow,
  on_magenta, and on_cyan.
  
  The color alone sets the foreground color, and on_color sets
  the background color. You may also use on_color without the
  underscore, e.g. "black on white".
  
  =over 4
  
  =item color LIST
  
  Takes any number of strings as arguments and considers them
  to be space-separated lists of attributes.  It then forms
  and returns the escape sequence to set those attributes.
  
  =item colored EXPR, LIST
  
  Takes a scalar as the first argument and any number of
  attribute strings as the second argument, then returns the
  scalar wrapped in escape codes so that the attributes will
  be set as requested before the string and reset to normal
  after the string.
  
  Alternately, you can pass a reference to an array as the
  first argument, and then the contents of that array will
  be taken as attributes and color codes and the remainder
  of the arguments as text to colorize.
  
  Normally, this function just puts attribute codes at the
  beginning and end of the string, but if you set
  $Term::ANSIScreen::EACHLINE to some string, that string will
  be considered the line delimiter and the attribute will be set
  at the beginning of each line of the passed string and reset
  at the end of each line.  This is often desirable if the
  output is being sent to a program like a pager, which can
  be confused by attributes that span lines.
  
  Normally you'll want to set C<$Term::ANSIScreen::EACHLINE> to
  C<"\n"> to use this feature.
  
  =back
  
  =head2 The C<:constants> function set
  
  If you import C<:constants> you can use the constants CLEAR,
  RESET, BOLD, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
  BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED,
  ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE
  directly.  These are the same as color('attribute') and can be
  used if you prefer typing:
  
      print BOLD BLUE ON_WHITE "Text\n", RESET;
      print BOLD BLUE ON WHITE "Text\n", RESET; # _ is optional
  
  to
      print colored ("Text\n", 'bold blue on_white');
  
  When using the constants, if you don't want to have to remember
  to add the C<, RESET> at the end of each print line, you can set
  C<$Term::ANSIScreen::AUTORESET> to a true value.  Then, the display
  mode will automatically be reset if there is no comma after the
  constant.  In other words, with that variable set:
  
      print BOLD BLUE "Text\n";
  
  will reset the display mode afterwards, whereas:
  
      print BOLD, BLUE, "Text\n";
  
  will not.
  
  =head2 The C<:cursor> function set
  
  =over 4
  
  =item locate [EXPR, EXPR]
  
  Sets the cursor position. The first argument is its row number,
  and the second one its column number.  If omitted, the cursor
  will be located at (1,1).
  
  =item up    [EXPR]
  
  =item down  [EXPR]
  
  =item left  [EXPR]
  
  =item right [EXPR]
  
  Moves the cursor toward any direction for EXPR characters. If
  omitted, EXPR is 1.
  
  =item savepos
  
  =item loadpos
  
  Saves/restores the current cursor position.
  
  =back
  
  =head2 The C<:screen> function set
  
  =over 4
  
  =item cls
  
  Clears the screen with the current background color, and set
  cursor to (1,1).
  
  =item clline
  
  Clears the current row with the current background color, and
  set cursor to the 1st column.
  
  =item clup
  
  Clears everything above the cursor.
  
  =item cldown
  
  Clears everything below the cursor.
  
  =item setmode EXPR
  
  Sets the screen mode to EXPR. Under DOS, ANSI.SYS recognizes
  following values:
  
       0:  40 x  25 x   2 (text)   1:  40 x  25 x 16 (text)
       2:  80 x  25 x   2 (text)   3:  80 x  25 x 16 (text)
       4: 320 x 200 x   4          5: 320 x 200 x  2
       6: 640 x 200 x   2          7: Enables line wrapping
      13: 320 x 200 x   4         14: 640 x 200 x 16
      15: 640 x 350 x   2         16: 640 x 350 x 16
      17: 640 x 480 x   2         18: 640 x 480 x 16
      19: 320 x 200 x 256
  
  =item wrapon
  
  =item wrapoff
  
  Enables/disables the line-wraping mode.
  
  =item setscroll EXPR, EXPR
  
  Causes scrolling to occur only on the lines numbered between
  the first and second arguments, inclusive.
  
  =back
  
  =head2 The C<:keyboard> function set
  
  =over 4
  
  =item setkey EXPR, EXPR
  
  Takes a scalar representing a single keystroke as the first
  argument (either a character or an escape sequence in the
  form of C<"num1;num2">), and maps it to a string defined by
  the second argument.  Afterwards, when the user presses the
  mapped key, the string will get outputed instead.
  
  =item resetkey [LIST]
  
  Resets each keys in the argument list to its original mapping.
  If called without an argument, resets all previously mapped
  keys.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Invalid attribute name %s
  
  You passed an invalid attribute name to either color() or
  colored().
  
  =item Identifier %s used only once: possible typo
  
  You probably mistyped a constant color name such as:
  
      print FOOBAR "This text is color FOOBAR\n";
  
  It's probably better to always use commas after constant names
  in order to force the next error.
  
  =item No comma allowed after filehandle
  
  You probably mistyped a constant color name such as:
  
      print FOOBAR, "This text is color FOOBAR\n";
  
  Generating this fatal compile error is one of the main advantages
  of using the constants interface, since you'll immediately know
  if you mistype a color name.
  
  =item Bareword %s not allowed while "strict subs" in use
  
  You probably mistyped a constant color name such as:
  
      $Foobar = FOOBAR . "This line should be blue\n";
  
  or:
  
      @Foobar = FOOBAR, "This line should be blue\n";
  
  This will only show up under use strict (another good reason
  to run under use strict).
  
  =back
  
  =head1 SEE ALSO
  
  L<Term::ANSIColor>, L<Win32::Console>
  
  =head1 AUTHORS
  
  唐鳳 E<lt>cpan@audreyt.orgE<gt>
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to Term-ANSIScreen.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
TERM_ANSISCREEN

$fatpacked{"Term/Choose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_CHOOSE';
  package Term::Choose;
  
  use warnings;
  use strict;
  use 5.008003;
  
  our $VERSION = '1.600';
  use Exporter 'import';
  our @EXPORT_OK = qw( choose );
  
  use Carp qw( croak carp );
  
  use Term::Choose::Constants qw( :choose );
  use Term::Choose::LineFold  qw( line_fold print_columns cut_to_printwidth );
  
  no warnings 'utf8';
  
  my $Plugin_Package;
  
  BEGIN {
      if ( $^O eq 'MSWin32' ) {
          require Term::Choose::Win32;
          $Plugin_Package = 'Term::Choose::Win32';
      }
      else {
          require Term::Choose::Linux;
          $Plugin_Package = 'Term::Choose::Linux';
      }
  }
  
  
  sub new {
      my $class = shift;
      my ( $opt ) = @_;
      croak "new: called with " . @_ . " arguments - 0 or 1 arguments expected" if @_ > 1;
      my $self = bless {}, $class;
      if ( defined $opt ) {
          croak "new: the (optional) argument must be a HASH reference" if ref $opt ne 'HASH';
          $self->__validate_and_add_options( $opt );
      }
      $self->{plugin} = $Plugin_Package->new();
      my $backup_self = { map{ $_ => $self->{$_} } keys %$self };
      $self->{backup_self} = $backup_self;
      return $self;
  }
  
  
  sub DESTROY {
      my ( $self ) = @_;
      $self->__reset_term();
  }
  
  
  sub __defaults {        #hae
      my ( $self ) = @_;
      my $prompt = defined $self->{wantarray} ? 'Your choice:' : 'Close with ENTER';
      return {
          prompt              => $prompt,
          info                => '',
          beep                => 0,
          clear_screen        => 0,
          #default            => undef,
          empty               => '<empty>',
          hide_cursor         => 1,
          include_highlighted => 0,
          index               => 0,
          justify             => 0,
          keep                => 5,
          layout              => 1,
          #lf                 => undef,
          #ll                 => undef,
          #mark               => undef,
          #max_height         => undef,
          #max_width          => undef,
          mouse               => 0,
          #no_spacebar        => undef,
          #meta_items         => undef,
          order               => 1,
          pad                 => 2,
          page                => 1,
          undef               => '<undef>',
      };
  }
  
  
  sub __undef_to_defaults {
      my ( $self ) = @_;
      my $defaults = $self->__defaults();
      for my $option ( keys %$defaults ) {
          $self->{$option} = $defaults->{$option} if ! defined $self->{$option};
      }
  }
  
  
  sub __valid_options {       #hae
      return {
          beep                => '[ 0 1 ]',
          clear_screen        => '[ 0 1 ]',
          hide_cursor         => '[ 0 1 ]',
          index               => '[ 0 1 ]',
          order               => '[ 0 1 ]',
          page                => '[ 0 1 ]',
          include_highlighted => '[ 0 1 2 ]',
          justify             => '[ 0 1 2 ]',
          layout              => '[ 0 1 2 3 ]',
          mouse               => '[ 0 1 2 3 4 ]',
          keep                => '[ 1-9 ][ 0-9 ]*',
          ll                  => '[ 1-9 ][ 0-9 ]*',
          max_height          => '[ 1-9 ][ 0-9 ]*',
          max_width           => '[ 1-9 ][ 0-9 ]*',
          default             => '[ 0-9 ]+',
          pad                 => '[ 0-9 ]+',
          lf                  => 'ARRAY',
          mark                => 'ARRAY',
          no_spacebar         => 'ARRAY',
          meta_items          => 'ARRAY',
          empty               => 'Str',
          info                => 'Str',
          prompt              => 'Str',
          undef               => 'Str',
      };
  };
  
  
  sub __validate_and_add_options {
      my ( $self, $opt ) = @_;
      return if ! defined $opt;
      my $valid = $self->__valid_options();
      my $sub =  ( caller( 1 ) )[3];
      $sub =~ s/^.+::(?:__)?([^:]+)\z/$1/;
      $sub .= ':';
      for my $key ( keys %$opt ) {
          if ( ! exists $valid->{$key} ) {
              croak "$sub '$key' is not a valid option name";
          }
          next if ! defined $opt->{$key};
          if ( $valid->{$key} eq 'ARRAY' ) {
              croak "$sub $key => the passed value has to be an ARRAY reference." if ref $opt->{$key} ne 'ARRAY';
              {
                  no warnings 'uninitialized';
                  for ( @{$opt->{$key}} ) {
                      /^[0-9]+\z/ or croak "$sub $key => $_ is an invalid array element";
                  }
              }
              if ( $key eq 'lf' ) {
                  croak "$sub $key => too many array elements." if @{$opt->{$key}} > 2;
              }
          }
          elsif ( $valid->{$key} eq 'Str' ) {
              croak "$sub $key => references are not valid values." if ref $opt->{$key} ne '';
          }
          elsif ( $opt->{$key} !~ m/^$valid->{$key}\z/x ) {
              croak "$sub $key => '$opt->{$key}' is not a valid value.";
          }
          $self->{$key} = $opt->{$key};
      }
  }
  
  
  sub __init_term {
      my ( $self ) = @_;
      $self->{mouse} = $self->{plugin}->__set_mode( $self->{mouse}, $self->{hide_cursor} );
  }
  
  
  sub __reset_term {
      my ( $self, $from_choose ) = @_;
      if ( $from_choose ) {
          print CR;
          my $up = $self->{i_row} + $self->{nr_prompt_lines};
          $self->{plugin}->__up( $up ) if $up;
          $self->{plugin}->__clear_to_end_of_screen();
      }
      if ( defined $self->{plugin} ) {
          $self->{plugin}->__reset_mode( $self->{mouse}, $self->{hide_cursor} );
      }
      if ( defined $self->{backup_self} ) {
          my $backup_self = delete $self->{backup_self};
          for my $key ( keys %$self ) {
              if ( defined $backup_self->{$key} ) {
                  $self->{$key} = $backup_self->{$key};
              }
              else {
                  delete $self->{$key};
              }
          }
      }
  }
  
  
  sub __get_key {
      my ( $self ) = @_;
      my $key = $self->{plugin}->__get_key_OS( $self->{mouse} );
      return $key if ref $key ne 'ARRAY';
      return $self->__mouse_info_to_key( @$key );
  }
  
  
  sub choose {      #hae
      if ( ref $_[0] ne 'Term::Choose' ) {
          #return Term::Choose->new()->__choose( @_ );
          return __choose( bless( { plugin => $Plugin_Package->new() }, 'Term::Choose' ), @_ );
      }
      my $self = shift;
      return $self->__choose( @_ ); # 1 backup_self
  }
  
  sub __choose {
      my $self = shift;
      my ( $orig_list_ref, $opt ) = @_;
      croak "choose: called with " . @_ . " arguments - 1 or 2 arguments expected" if @_ < 1 || @_ > 2;
      croak "choose: the first argument must be an ARRAY reference" if ref $orig_list_ref ne 'ARRAY';
      if ( defined $opt ) {
          croak "choose: the (optional) second argument must be a HASH reference" if ref $opt ne 'HASH';
          $self->__validate_and_add_options( $opt );
      }
      if ( ! @$orig_list_ref ) {
          return;
      }
  
      local $\ = undef;
      local $, = undef;
      local $| = 1;
      $self->{wantarray} = wantarray;
      $self->__undef_to_defaults();
      $self->__copy_orig_list( $orig_list_ref );
      $self->__length_longest(); #
      $self->{col_width} = $self->{length_longest} + $self->{pad};
      local $SIG{'INT'} = sub {
          # my $signame = shift;
          exit 1;
      };
      $self->__init_term();
      $self->__write_first_screen();
  
      GET_KEY: while ( 1 ) {
          my $key = $self->__get_key();
          if ( ! defined $key ) {
              $self->__reset_term( 1 );
              carp "EOT: $!";
              return;
          }
          my ( $new_width, $new_height ) = $self->{plugin}->__get_term_size();
          if ( $new_width != $self->{term_width} || $new_height != $self->{term_height} ) {
              if ( $self->{ll} ) {
                  return -1;
              }
              $self->__copy_orig_list( $orig_list_ref );
              $self->{default} = $self->{rc2idx}[$self->{pos}[ROW]][$self->{pos}[COL]];
              if ( $self->{wantarray} && @{$self->{marked}} ) {
                  $self->{mark} = $self->__marked_rc2idx();
              }
              print CR;
              my $up = $self->{i_row} + $self->{nr_prompt_lines};
              $self->{plugin}->__up( $up ) if $up;
              $self->{plugin}->__clear_to_end_of_screen();
              $self->__write_first_screen();
              next GET_KEY;
          }
          next GET_KEY if $key == NEXT_get_key;
          next GET_KEY if $key == KEY_Tilde;
          if ( exists $ENV{TC_RESET_AUTO_UP} ) {
              $ENV{TC_RESET_AUTO_UP} = 1 if $key != KEY_ENTER;
          }
  
          # $self->{rc2idx} holds the new list (AoA) formatted in "__size_and_layout" appropriate to the chosen layout.
          # $self->{rc2idx} does not hold the values directly but the respective list indexes from the original list.
          # If the original list would be ( 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' ) and the new formatted list should be
          #     a d g
          #     b e h
          #     c f
          # then the $self->{rc2idx} would look like this
          #     0 3 6
          #     1 4 7
          #     2 5
          # So e.g. the second value in the second row of the new list would be $self->{list}[ $self->{rc2idx}[1][1] ].
          # On the other hand the index of the last row of the new list would be $#{$self->{rc2idx}}
          # or the index of the last column in the first row would be $#{$self->{rc2idx}[0]}.
  
          if ( $key == KEY_j || $key == VK_DOWN ) {
              if (     ! $self->{rc2idx}[$self->{pos}[ROW]+1]
                    || ! $self->{rc2idx}[$self->{pos}[ROW]+1][$self->{pos}[COL]]
              ) {
                  $self->__beep();
              }
              else {
                  $self->{pos}[ROW]++;
                  if ( $self->{pos}[ROW] <= $self->{p_end} ) {
                      $self->__wr_cell( $self->{pos}[ROW] - 1, $self->{pos}[COL] );
                      $self->__wr_cell( $self->{pos}[ROW],     $self->{pos}[COL] );
                  }
                  else {
                      $self->{p_begin} = $self->{p_end} + 1;
                      $self->{p_end}   = $self->{p_end} + $self->{avail_height};
                      $self->{p_end}   = $#{$self->{rc2idx}} if $self->{p_end} > $#{$self->{rc2idx}};
                      $self->__wr_screen();
                  }
              }
          }
          elsif ( $key == KEY_k || $key == VK_UP ) {
              if ( $self->{pos}[ROW] == 0 ) {
                  $self->__beep();
              }
              else {
                  $self->{pos}[ROW]--;
                  if ( $self->{pos}[ROW] >= $self->{p_begin} ) {
                      $self->__wr_cell( $self->{pos}[ROW] + 1, $self->{pos}[COL] );
                      $self->__wr_cell( $self->{pos}[ROW],     $self->{pos}[COL] );
                  }
                  else {
                      $self->{p_end}   = $self->{p_begin} - 1;
                      $self->{p_begin} = $self->{p_begin} - $self->{avail_height};
                      $self->{p_begin} = 0 if $self->{p_begin} < 0;
                      $self->__wr_screen();
                  }
              }
          }
          elsif ( $key == KEY_TAB || $key == CONTROL_I ) {
              if (    $self->{pos}[ROW] == $#{$self->{rc2idx}}
                   && $self->{pos}[COL] == $#{$self->{rc2idx}[$self->{pos}[ROW]]}
              ) {
                  $self->__beep();
              }
              else {
                  if ( $self->{pos}[COL] < $#{$self->{rc2idx}[$self->{pos}[ROW]]} ) {
                      $self->{pos}[COL]++;
                      $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] - 1 );
                      $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
                  }
                  else {
                      $self->{pos}[ROW]++;
                      if ( $self->{pos}[ROW] <= $self->{p_end} ) {
                          $self->{pos}[COL] = 0;
                          $self->__wr_cell( $self->{pos}[ROW] - 1, $#{$self->{rc2idx}[$self->{pos}[ROW] - 1]} );
                          $self->__wr_cell( $self->{pos}[ROW],     $self->{pos}[COL] );
                      }
                      else {
                          $self->{p_begin} = $self->{p_end} + 1;
                          $self->{p_end}   = $self->{p_end} + $self->{avail_height};
                          $self->{p_end}   = $#{$self->{rc2idx}} if $self->{p_end} > $#{$self->{rc2idx}};
                          $self->{pos}[COL] = 0;
                          $self->__wr_screen();
                      }
                  }
              }
          }
          elsif ( $key == KEY_BSPACE || $key == CONTROL_H || $key == KEY_BTAB ) {
              if ( $self->{pos}[COL] == 0 && $self->{pos}[ROW] == 0 ) {
                  $self->__beep();
              }
              else {
                  if ( $self->{pos}[COL] > 0 ) {
                      $self->{pos}[COL]--;
                      $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] + 1 );
                      $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
                  }
                  else {
                      $self->{pos}[ROW]--;
                      if ( $self->{pos}[ROW] >= $self->{p_begin} ) {
                          $self->{pos}[COL] = $#{$self->{rc2idx}[$self->{pos}[ROW]]};
                          $self->__wr_cell( $self->{pos}[ROW] + 1, 0 );
                          $self->__wr_cell( $self->{pos}[ROW],     $self->{pos}[COL] );
                      }
                      else {
                          $self->{p_end}   = $self->{p_begin} - 1;
                          $self->{p_begin} = $self->{p_begin} - $self->{avail_height};
                          $self->{p_begin} = 0 if $self->{p_begin} < 0;
                          $self->{pos}[COL] = $#{$self->{rc2idx}[$self->{pos}[ROW]]};
                          $self->__wr_screen();
                      }
                  }
              }
          }
          elsif ( $key == KEY_l || $key == VK_RIGHT ) {
              if ( $self->{pos}[COL] == $#{$self->{rc2idx}[$self->{pos}[ROW]]} ) {
                  $self->__beep();
              }
              else {
                  $self->{pos}[COL]++;
                  $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] - 1 );
                  $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
              }
          }
          elsif ( $key == KEY_h || $key == VK_LEFT ) {
              if ( $self->{pos}[COL] == 0 ) {
                  $self->__beep();
              }
              else {
                  $self->{pos}[COL]--;
                  $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] + 1 );
                  $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
              }
          }
          elsif ( $key == CONTROL_B || $key == VK_PAGE_UP ) {
              if ( $self->{p_begin} <= 0 ) {
                  $self->__beep();
              }
              else {
                  $self->{p_begin} = $self->{avail_height} * ( int( $self->{pos}[ROW] / $self->{avail_height} ) - 1 );;
                  $self->{p_end}   = $self->{p_begin} + $self->{avail_height} - 1;
                  $self->{pos}[ROW] -= $self->{avail_height};
                  $self->__wr_screen();
              }
          }
          elsif ( $key == CONTROL_F || $key == VK_PAGE_DOWN ) {
              if ( $self->{p_end} >= $#{$self->{rc2idx}} ) {
                  $self->__beep();
              }
              else {
                  $self->{p_begin} = $self->{avail_height} * ( int( $self->{pos}[ROW] / $self->{avail_height} ) + 1 );
                  $self->{p_end}   = $self->{p_begin} + $self->{avail_height} - 1;
                  $self->{p_end}   = $#{$self->{rc2idx}} if $self->{p_end} > $#{$self->{rc2idx}};
                  $self->{pos}[ROW] += $self->{avail_height};
                  if ( $self->{pos}[ROW] >= $#{$self->{rc2idx}} ) {
                      if ( $#{$self->{rc2idx}} == $self->{p_begin} || ! $self->{rest} || $self->{pos}[COL] <= $self->{rest} - 1 ) {
                          if ( $self->{pos}[ROW] != $#{$self->{rc2idx}} ) {
                              $self->{pos}[ROW] = $#{$self->{rc2idx}};
                          }
                          if ( $self->{rest} && $self->{pos}[COL] > $self->{rest} - 1 ) {
                              $self->{pos}[COL] = $#{$self->{rc2idx}[$self->{pos}[ROW]]};
                          }
                      }
                      else {
                          $self->{pos}[ROW] = $#{$self->{rc2idx}} - 1;
                      }
                  }
                  $self->__wr_screen();
              }
          }
          elsif ( $key == CONTROL_A || $key == VK_HOME ) {
              if ( $self->{pos}[COL] == 0 && $self->{pos}[ROW] == 0 ) {
                  $self->__beep();
              }
              else {
                  $self->{pos}[ROW] = 0;
                  $self->{pos}[COL] = 0;
                  $self->{p_begin} = 0;
                  $self->{p_end}   = $self->{p_begin} + $self->{avail_height} - 1;
                  $self->{p_end}   = $#{$self->{rc2idx}} if $self->{p_end} > $#{$self->{rc2idx}};
                  $self->__wr_screen();
              }
          }
          elsif ( $key == CONTROL_E || $key == VK_END ) {
              if ( $self->{order} == 1 && $self->{rest} ) {
                  if (    $self->{pos}[ROW] == $#{$self->{rc2idx}} - 1
                       && $self->{pos}[COL] == $#{$self->{rc2idx}[$self->{pos}[ROW]]}
                  ) {
                      $self->__beep();
                  }
                  else {
                      $self->{p_begin} = @{$self->{rc2idx}} - ( @{$self->{rc2idx}} % $self->{avail_height} || $self->{avail_height} );
                      $self->{pos}[ROW] = $#{$self->{rc2idx}} - 1;
                      $self->{pos}[COL] = $#{$self->{rc2idx}[$self->{pos}[ROW]]};
                      if ( $self->{p_begin} == $#{$self->{rc2idx}} ) {
                          $self->{p_begin} = $self->{p_begin} - $self->{avail_height};
                          $self->{p_end}   = $self->{p_begin} + $self->{avail_height} - 1;
                      }
                      else {
                          $self->{p_end}   = $#{$self->{rc2idx}};
                      }
                      $self->__wr_screen();
                  }
              }
              else {
                  if (    $self->{pos}[ROW] == $#{$self->{rc2idx}}
                       && $self->{pos}[COL] == $#{$self->{rc2idx}[$self->{pos}[ROW]]}
                  ) {
                      $self->__beep();
                  }
                  else {
                      $self->{p_begin} = @{$self->{rc2idx}} - ( @{$self->{rc2idx}} % $self->{avail_height} || $self->{avail_height} );
                      $self->{p_end}   = $#{$self->{rc2idx}};
                      $self->{pos}[ROW] = $#{$self->{rc2idx}};
                      $self->{pos}[COL] = $#{$self->{rc2idx}[$self->{pos}[ROW]]};
                      $self->__wr_screen();
                  }
              }
          }
          elsif ( $key == KEY_q || $key == CONTROL_D ) {
              $self->__reset_term( 1 );
              return;
          }
          elsif ( $key == CONTROL_C ) {
              $self->__reset_term( 1 );
              print STDERR "^C\n";
              exit 1;
          }
          elsif ( $key == KEY_ENTER ) {
              my $index = $self->{index} || $self->{ll};
              if ( ! defined $self->{wantarray} ) {
                  $self->__reset_term( 1 );
                  return;
              }
              elsif ( $self->{wantarray} ) {
                  if ( $self->{include_highlighted} == 1 ) {
                      $self->{marked}[$self->{pos}[ROW]][$self->{pos}[COL]] = 1;
                  }
                  elsif ( $self->{include_highlighted} == 2 ) {
                      my $chosen = $self->__marked_rc2idx();
                      if ( ! @$chosen ) {
                          $self->{marked}[$self->{pos}[ROW]][$self->{pos}[COL]] = 1;
                      }
                  }
                  elsif ( defined $self->{meta_items} ) {
                      for my $meta_item ( @{$self->{meta_items}} ) {
                          if ( $meta_item == $self->{rc2idx}[$self->{pos}[ROW]][$self->{pos}[COL]] ) {
                              $self->{marked}[$self->{pos}[ROW]][$self->{pos}[COL]] = 1;
                              last;
                          }
                      }
                  }
                  my $chosen = $self->__marked_rc2idx();
                  $self->__reset_term( 1 );
                  return $index ? @$chosen : @{$orig_list_ref}[@$chosen];
              }
              else {
                  my $i = $self->{rc2idx}[$self->{pos}[ROW]][$self->{pos}[COL]];
                  my $chosen = $index ? $i : $orig_list_ref->[$i];
                  $self->__reset_term( 1 );
                  return $chosen;
              }
          }
          elsif ( $key == KEY_SPACE ) {
              if ( $self->{wantarray} ) {
                  my $locked = 0;
                  if ( defined $self->{no_spacebar} || defined $self->{meta_items} ) {
                      for my $no_spacebar ( @{$self->{no_spacebar}||[]}, @{$self->{meta_items}||[]} ) {
                          if ( $self->{rc2idx}[$self->{pos}[ROW]][$self->{pos}[COL]] == $no_spacebar ) {
                              ++$locked;
                              last;
                          }
                      }
                  }
                  if ( $locked ) {
                      $self->__beep();
                  }
                  else {
                      $self->{marked}[$self->{pos}[ROW]][$self->{pos}[COL]] = ! $self->{marked}[$self->{pos}[ROW]][$self->{pos}[COL]];
                      $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
                  }
              }
          }
          elsif ( $key == CONTROL_SPACE ) {
              if ( $self->{wantarray} ) {
                  for my $i ( 0 .. $#{$self->{rc2idx}} ) {
                      for my $j ( 0 .. $#{$self->{rc2idx}[$i]} ) {
                          $self->{marked}[$i][$j] = ! $self->{marked}[$i][$j];
                      }
                  }
                  if ( defined $self->{no_spacebar} ) {
                      $self->__marked_idx2rc( $self->{no_spacebar}, 0 );
                  }
                  $self->__wr_screen();
              }
              else {
                  $self->__beep();
              }
          }
          else {
              $self->__beep();
          }
      }
  }
  
  
  sub __marked_idx2rc {
      my ( $self, $list_of_indexes, $boolean ) = @_;
      my $last_list_idx = $#{$self->{list}};
      if ( $self->{current_layout} == 3 ) {
          for my $idx ( @$list_of_indexes ) {
              next if $idx > $last_list_idx;
              $self->{marked}[$idx][0] = $boolean;
          }
          return;
      }
      my ( $row, $col );
      my $cols_per_row = @{$self->{rc2idx}[0]};
      if ( $self->{order} == 0 ) {
          for my $idx ( @$list_of_indexes ) {
              next if $idx > $last_list_idx;
              $row = int( $idx / $cols_per_row );
              $col = $idx % $cols_per_row;
              $self->{marked}[$row][$col] = $boolean;
          }
      }
      elsif ( $self->{order} == 1 ) {
          my $rows_per_col = @{$self->{rc2idx}};
          my $end_last_full_col = $rows_per_col * ( $self->{rest} || $cols_per_row );
          for my $idx ( @$list_of_indexes ) {
              next if $idx > $last_list_idx;
              if ( $idx <= $end_last_full_col ) {
                  $row = $idx % $rows_per_col;
                  $col = int( $idx / $rows_per_col );
              }
              else {
                  my $rows_per_col_short = $rows_per_col - 1;
                  $row = ( $idx - $end_last_full_col ) % $rows_per_col_short;
                  $col = int( ( $idx - $self->{rest} ) / $rows_per_col_short );
              }
              $self->{marked}[$row][$col] = $boolean;
          }
      }
  }
  
  
  sub __marked_rc2idx {
      my ( $self ) = @_;
      my $idx = [];
      if ( $self->{order} == 1 ) {
          for my $col ( 0 .. $#{$self->{rc2idx}[0]} ) {
              for my $row ( 0 .. $#{$self->{rc2idx}} ) {
                  if ( $self->{marked}[$row][$col] ) {
                      push @$idx, $self->{rc2idx}[$row][$col];
                  }
              }
          }
      }
      else {
          for my $row ( 0 .. $#{$self->{rc2idx}} ) {
              for my $col ( 0 .. $#{$self->{rc2idx}[$row]} ) {
                  if ( $self->{marked}[$row][$col] ) {
                      push @$idx, $self->{rc2idx}[$row][$col];
                  }
              }
          }
      }
      return $idx;
  }
  
  
  sub __beep {
      my ( $self ) = @_;
      print BEEP if $self->{beep};
  }
  
  
  sub __copy_orig_list {      #hae
      my ( $self, $orig_list_ref ) = @_;
      $self->{list} = [ @$orig_list_ref ];
      if ( $self->{ll} ) {
          for ( @{$self->{list}} ) {
              $_ = $self->{undef} if ! defined $_;
          }
      }
      else {
          for ( @{$self->{list}} ) {
              if ( ! $_ ) {
                  $_ = $self->{undef} if ! defined $_;
                  $_ = $self->{empty} if $_ eq '';
              }
              if ( ref ) {
                  $_ = sprintf "%s(0x%x)", ref $_, $_;
              }
              s/\p{Space}/ /g;  # replace, but don't squash sequences of spaces
              s/\p{C}//g;
          }
      }
  }
  
  
  sub __length_longest {
      my ( $self ) = @_;
      my $list = $self->{list};
      if ( $self->{ll} ) {
          $self->{length_longest} = $self->{ll};
          $self->{length} = [ ( $self->{length_longest} ) x @$list ];
      }
      else {
          my $len = [];
          my $longest = 0;
          for my $i ( 0 .. $#$list ) {
              $len->[$i] = $self->__print_columns( $list->[$i] );
              $longest = $len->[$i] if $len->[$i] > $longest;
          }
          $self->{length_longest} = $longest;
          $self->{length} = $len;
      }
  }
  
  
  sub __write_first_screen {
      my ( $self ) = @_;
      ( $self->{term_width}, $self->{term_height} ) = $self->{plugin}->__get_term_size();
      ( $self->{avail_width}, $self->{avail_height} ) = ( $self->{term_width}, $self->{term_height} );
      if ( $self->{length_longest} > $self->{avail_width} && $^O ne 'MSWin32' ) {
          $self->{avail_width} += WIDTH_CURSOR;
          # + WIDTH_CURSOR: use also the last terminal column if there is only one print-column;
          #                 with only one print-column the output doesn't get messed up if an item
          #                 reaches the right edge of the terminal on a non-MSWin32-OS
      }
      if ( $self->{max_width} && $self->{avail_width} > $self->{max_width} ) {
          $self->{avail_width} = $self->{max_width};
      }
      if ( $self->{mouse} == 2 ) {
          $self->{avail_width}  = MAX_COL_MOUSE_1003 if $self->{avail_width}  > MAX_COL_MOUSE_1003;
          $self->{avail_height} = MAX_ROW_MOUSE_1003 if $self->{avail_height} > MAX_ROW_MOUSE_1003;
      }
      if ( $self->{avail_width} < 1 ) {
          $self->{avail_width} = 1;
      }
      $self->__prepare_promptline();
      $self->{pp_row} = $self->{page} ? 1 : 0;
      $self->{avail_height} -= $self->{nr_prompt_lines} + $self->{pp_row};
      if ( $self->{avail_height} < $self->{keep} ) {
          $self->{avail_height} = $self->{term_height} >= $self->{keep} ? $self->{keep} : $self->{term_height};
      }
      if ( $self->{max_height} && $self->{max_height} < $self->{avail_height} ) {
          $self->{avail_height} = $self->{max_height};
      }
      $self->__size_and_layout();
      if ( $self->{page} ) {
          $self->__prepare_page_number();
      }
      $self->{avail_height_idx} = $self->{avail_height} - 1;
      $self->{p_begin}    = 0;
      $self->{p_end}      = $self->{avail_height_idx} > $#{$self->{rc2idx}} ? $#{$self->{rc2idx}} : $self->{avail_height_idx};
      $self->{i_row}      = 0;
      $self->{i_col}      = 0;
      $self->{pos}        = [ 0, 0 ];
      $self->{marked}     = [];
      if ( $self->{wantarray} && defined $self->{mark} ) {
          $self->__marked_idx2rc( $self->{mark}, 1 );
      }
      if ( defined $self->{default} && $self->{default} <= $#{$self->{list}} ) {
          $self->__set_default_cell();
      }
      if ( $self->{clear_screen} ) {
          $self->{plugin}->__clear_screen();
      }
      if ( $self->{prompt_copy} ne '' ) {
          print $self->{prompt_copy};
      }
      $self->__wr_screen();
      if ( $self->{mouse} ) {
          $self->{plugin}->__get_cursor_position();
      }
      $self->{cursor_row} = $self->{i_row};
  }
  
  
  sub __prepare_promptline {
      my ( $self ) = @_;
      my $prompt = '';
      if ( length $self->{info} ) {
          $prompt .= $self->{info};
          $prompt .= "\n" if length $self->{prompt};
      }
      $prompt .= $self->{prompt};
      if ( $prompt eq '' ) {
          $self->{prompt_copy} = '';
          $self->{nr_prompt_lines} = 0;
          return;
      }
      my $init   = $self->{lf}[0] ? $self->{lf}[0] : 0;
      my $subseq = $self->{lf}[1] ? $self->{lf}[1] : 0;
      $self->{prompt_copy} = line_fold( $prompt, $self->{avail_width}, ' ' x $init, ' ' x $subseq );
      $self->{prompt_copy} .= "\n\r";
      $self->{nr_prompt_lines} = $self->{prompt_copy} =~ s/\n/\n\r/g;
  }
  
  
  sub __size_and_layout {
      my ( $self ) = @_;
      my $layout = $self->{layout};
      $self->{rc2idx} = [];
      if ( $self->{length_longest} > $self->{avail_width} ) {
          $self->{avail_col_width} = $self->{avail_width};
          $layout = 3;
      }
      else {
          $self->{avail_col_width} = $self->{length_longest};
      }
      $self->{current_layout} = $layout;
      my $all_in_first_row = '';
      if ( $layout == 0 || $layout == 1 ) {
          for my $idx ( 0 .. $#{$self->{list}} ) {
              $all_in_first_row .= $self->{list}[$idx];
              $all_in_first_row .= ' ' x $self->{pad} if $idx < $#{$self->{list}};
              if ( $self->__print_columns( $all_in_first_row ) > $self->{avail_width} ) {
                  $all_in_first_row = '';
                  last;
              }
          }
      }
      if ( $all_in_first_row ) {
          $self->{rc2idx}[0] = [ 0 .. $#{$self->{list}} ];
      }
      elsif ( $layout == 3 ) {
          for my $idx ( 0 .. $#{$self->{list}} ) {
              $self->{rc2idx}[$idx][0] = $idx;
          }
      }
      else {
          my $tmp_avail_width = $self->{avail_width} + $self->{pad};
          # auto_format
          if ( $layout == 1 || $layout == 2 ) {
              my $tmc = int( @{$self->{list}} / $self->{avail_height} );
              $tmc++ if @{$self->{list}} % $self->{avail_height};
              $tmc *= $self->{col_width};
              if ( $tmc < $tmp_avail_width ) {
                  $tmc = int( $tmc + ( ( $tmp_avail_width - $tmc ) / 1.5 ) ) if $layout == 1;
                  $tmc = int( $tmc + ( ( $tmp_avail_width - $tmc ) / 4 ) )   if $layout == 2;
                  $tmp_avail_width = $tmc;
              }
          }
          # order
          my $cols_per_row = int( $tmp_avail_width / $self->{col_width} );
          $cols_per_row = 1 if $cols_per_row < 1;
          $self->{rest} = @{$self->{list}} % $cols_per_row;
          if ( $self->{order} == 1 ) {
              my $rows = int( ( @{$self->{list}} - 1 + $cols_per_row ) / $cols_per_row );
              my @rearranged_idx;
              my $begin = 0;
              my $end = $rows - 1;
              for my $c ( 0 .. $cols_per_row - 1 ) {
                  --$end if $self->{rest} && $c >= $self->{rest};
                  $rearranged_idx[$c] = [ $begin .. $end ];
                  $begin = $end + 1;
                  $end = $begin + $rows - 1;
              }
              for my $r ( 0 .. $rows - 1 ) {
                  my @temp_idx;
                  for my $c ( 0 .. $cols_per_row - 1 ) {
                      next if $r == $rows - 1 && $self->{rest} && $c >= $self->{rest};
                      push @temp_idx, $rearranged_idx[$c][$r];
                  }
                  push @{$self->{rc2idx}}, \@temp_idx;
              }
          }
          else {
              my $begin = 0;
              my $end = $cols_per_row - 1;
              $end = $#{$self->{list}} if $end > $#{$self->{list}};
              push @{$self->{rc2idx}}, [ $begin .. $end ];
              while ( $end < $#{$self->{list}} ) {
                  $begin += $cols_per_row;
                  $end   += $cols_per_row;
                  $end    = $#{$self->{list}} if $end > $#{$self->{list}};
                  push @{$self->{rc2idx}}, [ $begin .. $end ];
              }
          }
      }
  }
  
  
  sub __set_default_cell {
      my ( $self ) = @_;
      LOOP: for my $i ( 0 .. $#{$self->{rc2idx}} ) {
          for my $j ( 0 .. $#{$self->{rc2idx}[$i]} ) {
              if ( $self->{default} == $self->{rc2idx}[$i][$j] ) {
                  $self->{pos} = [ $i, $j ];
                  last LOOP;
              }
          }
      }
      $self->{p_begin} = $self->{avail_height} * int( $self->{pos}[ROW] / $self->{avail_height} );
      $self->{p_end} = $self->{p_begin} + $self->{avail_height} - 1;
      $self->{p_end} = $#{$self->{rc2idx}} if $self->{p_end} > $#{$self->{rc2idx}};
  }
  
  
  sub __goto {
      my ( $self, $newrow, $newcol ) = @_;
      if ( $newrow > $self->{i_row} ) {
          print CR, LF x ( $newrow - $self->{i_row} );
          $self->{i_row} += ( $newrow - $self->{i_row} );
          $self->{i_col} = 0;
      }
      elsif ( $newrow < $self->{i_row} ) {
          $self->{plugin}->__up( $self->{i_row} - $newrow );
          $self->{i_row} -= ( $self->{i_row} - $newrow );
      }
      if ( $newcol > $self->{i_col} ) {
          $self->{plugin}->__right( $newcol - $self->{i_col} );
          $self->{i_col} += ( $newcol - $self->{i_col} );
      }
      elsif ( $newcol < $self->{i_col} ) {
          $self->{plugin}->__left( $self->{i_col} - $newcol );
          $self->{i_col} -= ( $self->{i_col} - $newcol );
      }
  }
  
  
  sub __prepare_page_number {
      my ( $self ) = @_;
      if ( $#{$self->{rc2idx}} / ( $self->{avail_height} + $self->{pp_row} ) > 1 ) {
          my $total_pp = int( $#{$self->{rc2idx}} / $self->{avail_height} ) + 1;
          my $total_pp_w = length $total_pp;
          $self->{footer_fmt} = '--- Page %0' . $total_pp_w . 'd/' . $total_pp . ' ---';
          if ( length( sprintf $self->{footer_fmt}, $total_pp ) > $self->{avail_width} ) {
              $self->{footer_fmt} = '%0' . $total_pp_w . 'd/' . $total_pp;
              if ( length( sprintf $self->{footer_fmt}, $total_pp ) > $self->{avail_width} ) {
                  $total_pp_w = $self->{avail_width} if $total_pp_w > $self->{avail_width};
                  $self->{footer_fmt} = '%0' . $total_pp_w . '.' . $total_pp_w . 's';
              }
          }
      }
      else {
          $self->{avail_height} += $self->{pp_row};
          $self->{pp_row} = 0;
      }
  }
  
  
  sub __wr_screen {
      my ( $self ) = @_;
      $self->__goto( 0, 0 );
      $self->{plugin}->__clear_to_end_of_screen();
      if ( $self->{pp_row} ) {
          $self->__goto( $self->{avail_height_idx} + $self->{pp_row}, 0 );
          my $pp_line = sprintf $self->{footer_fmt}, int( $self->{p_begin} / $self->{avail_height} ) + 1;
          print $pp_line;
          $self->{i_col} += length $pp_line;
       }
      for my $row ( $self->{p_begin} .. $self->{p_end} ) {
          for my $col ( 0 .. $#{$self->{rc2idx}[$row]} ) {
              $self->__wr_cell( $row, $col );
          }
      }
      $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
  }
  
  
  sub __wr_cell {     # hae
      my( $self, $row, $col ) = @_;
      my $is_current_pos = $row == $self->{pos}[ROW] && $col == $self->{pos}[COL];
      my $idx = $self->{rc2idx}[$row][$col];
      if ( $#{$self->{rc2idx}} == 0 && $#{$self->{rc2idx}[0]} > 0 ) {
          my $lngth = 0;
          if ( $col > 0 ) {
              for my $cl ( 0 .. $col - 1 ) {
                  my $i = $self->{rc2idx}[$row][$cl];
                  $lngth += $self->__print_columns( $self->{list}[$i] );
                  $lngth += $self->{pad};
              }
          }
          $self->__goto( $row - $self->{p_begin}, $lngth );
          $self->{plugin}->__bold_underline() if $self->{marked}[$row][$col];
          $self->{plugin}->__reverse()        if $is_current_pos;
          print $self->{list}[$idx];
          $self->{i_col} += $self->__print_columns( $self->{list}[$idx] );
      }
      else {
          $self->__goto( $row - $self->{p_begin}, $col * $self->{col_width} );
          $self->{plugin}->__bold_underline() if $self->{marked}[$row][$col];
          $self->{plugin}->__reverse()        if $is_current_pos;
          print $self->__unicode_sprintf( $idx );
          $self->{i_col} += $self->{avail_col_width};
      }
      $self->{plugin}->__reset() if $self->{marked}[$row][$col] || $is_current_pos;
  }
  
  
  # Term::Choose_HAE overwrites __valid_options, __defaults, choose,
  # __copy_orig_list, __wr_cell, __print_columns, __unicode_trim
  
  
  sub __print_columns {       #hae
      #my $self = $_[0];
      print_columns( $_[1] );
  }
  
  sub __unicode_trim {        #hae
      #my $self = $_[0];
      cut_to_printwidth( $_[1], $_[2] ); # , 0
  }
  
  sub __unicode_sprintf {
      my ( $self, $idx ) = @_;
      my $unicode;
      my $str_length = $self->{length}[$idx];
      if ( $str_length > $self->{avail_col_width} ) {
          if ( $self->{avail_col_width} > 3 ) {
              $unicode = $self->__unicode_trim( $self->{list}[$idx], $self->{avail_col_width} - 3 ) . '...';
          }
          else {
              $unicode = $self->__unicode_trim( $self->{list}[$idx], $self->{avail_col_width} );
          }
      }
      elsif ( $str_length < $self->{avail_col_width} ) {
          if ( $self->{justify} == 0 ) {
              $unicode = $self->{list}[$idx] . " " x ( $self->{avail_col_width} - $str_length );
          }
          elsif ( $self->{justify} == 1 ) {
              $unicode = " " x ( $self->{avail_col_width} - $str_length ) . $self->{list}[$idx];
          }
          elsif ( $self->{justify} == 2 ) {
              my $all = $self->{avail_col_width} - $str_length;
              my $half = int( $all / 2 );
              $unicode = " " x $half . $self->{list}[$idx] . " " x ( $all - $half );
          }
      }
      else {
          $unicode = $self->{list}[$idx];
      }
      return $unicode;
  }
  
  
  sub __mouse_info_to_key {
      my ( $self, $abs_cursor_y, $button, $abs_mouse_x, $abs_mouse_y ) = @_;
      if ( $button == 4 ) {
          return VK_PAGE_UP;
      }
      elsif ( $button == 5 ) {
          return VK_PAGE_DOWN;
      }
      my $abs_y_top_row = $abs_cursor_y - $self->{cursor_row};
      if ( $abs_mouse_y < $abs_y_top_row ) {
          return NEXT_get_key;
      }
      my $mouse_row = $abs_mouse_y - $abs_y_top_row;
      my $mouse_col = $abs_mouse_x;
      if ( $mouse_row > $#{$self->{rc2idx}} ) {
          return NEXT_get_key;
      }
      my $matched_col;
      my $end_last_col = 0;
      my $row = $mouse_row + $self->{p_begin};
  
      COL: for my $col ( 0 .. $#{$self->{rc2idx}[$row]} ) {
          my $end_this_col;
          if ( $#{$self->{rc2idx}} == 0 ) {
              my $idx = $self->{rc2idx}[$row][$col];
              $end_this_col = $end_last_col + $self->__print_columns( $self->{list}[$idx] ) + $self->{pad};
          }
          else { #
              $end_this_col = $end_last_col + $self->{col_width};
          }
          if ( $col == 0 ) {
              $end_this_col -= int( $self->{pad} / 2 );
          }
          if ( $col == $#{$self->{rc2idx}[$row]} && $end_this_col > $self->{avail_width} ) {
              $end_this_col = $self->{avail_width};
          }
          if ( $end_last_col < $mouse_col && $end_this_col >= $mouse_col ) {
              $matched_col = $col;
              last COL;
          }
          $end_last_col = $end_this_col;
      }
      if ( ! defined $matched_col ) {
          return NEXT_get_key;
      }
      my $return_char = '';
      if ( $button == 1 ) {
          $return_char = KEY_ENTER;
      }
      elsif ( $button == 3 ) {
          $return_char = KEY_SPACE;
      }
      else {
          return NEXT_get_key;
      }
      if ( $row != $self->{pos}[ROW] || $matched_col != $self->{pos}[COL] ) {
          my $not_pos = $self->{pos};
          $self->{pos} = [ $row, $matched_col ];
          $self->__wr_cell( $not_pos->[0], $not_pos->[1] );
          $self->__wr_cell( $self->{pos}[ROW], $self->{pos}[COL] );
      }
      return $return_char;
  }
  
  
  
  1;
  
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Term::Choose - Choose items from a list interactively.
  
  =head1 VERSION
  
  Version 1.600
  
  =cut
  
  =head1 SYNOPSIS
  
  Functional interface:
  
      use Term::Choose qw( choose );
  
      my $array_ref = [ qw( one two three four five ) ];
  
      my $choice = choose( $array_ref );                            # single choice
      print "$choice\n";
  
      my @choices = choose( [ 1 .. 100 ], { justify => 1 } );       # multiple choice
      print "@choices\n";
  
      choose( [ 'Press ENTER to continue' ], { prompt => '' } );    # no choice
  
  Object-oriented interface:
  
      use Term::Choose;
  
      my $array_ref = [ qw( one two three four five ) ];
  
      my $new = Term::Choose->new();
  
      my $choice = $new->choose( $array_ref );                       # single choice
      print "$choice\n";
  
      my @choices = $new->choose( [ 1 .. 100 ] );                    # multiple choice
      print "@choices\n";
  
      my $stopp = Term::Choose->new( { prompt => '' } );
      $stopp->choose( [ 'Press ENTER to continue' ] );               # no choice
  
  =head1 DESCRIPTION
  
  Choose interactively from a list of items.
  
  C<Term::Choose> provides a functional interface (L</SUBROUTINES>) and an object-oriented interface (L</METHODS>).
  
  =head1 EXPORT
  
  Nothing by default.
  
      use Term::Choose qw( choose );
  
  =head1 METHODS
  
  =head2 new
  
      $new = Term::Choose->new( [ \%options] );
  
  This constructor returns a new C<Term::Choose> object.
  
  To set the different options it can be passed a reference to a hash as an optional argument.
  
  For detailed information about the options see L</OPTIONS>.
  
  =head2 choose
  
  The method C<choose> allows the user to choose from a list.
  
  The first argument is an array reference which holds the list of the available choices.
  
  As a second and optional argument it can be passed a reference to a hash where the keys are the option names and the
  values the option values.
  
  Options set with C<choose> overwrite options set with C<new>. Before leaving C<choose> restores the
  overwritten options.
  
      $choice = $new->choose( $array_ref [, \%options] );
  
      @choices= $new->choose( $array_ref [, \%options] );
  
                $new->choose( $array_ref [, \%options] );
  
  When in the documentation is mentioned "array" or "list" or "elements" or "items" (of the array/list) than these
  refer to this array passed as a reference as the first argument.
  
  For more information how to use C<choose> and its return values see L<USAGE AND RETURN VALUES>.
  
  =head1 SUBROUTINES
  
  =head2 choose
  
  The function C<choose> allows the user to choose from a list. It takes the same arguments as the method L</choose>.
  
      $choice = choose( $array_ref [, \%options] );
  
      @choices= choose( $array_ref [, \%options] );
  
                choose( $array_ref [, \%options] );
  
  See the L</OPTIONS> section for more details about the different options and how to set them.
  
  See also the following section L<USAGE AND RETURN VALUES>.
  
  =head1 USAGE AND RETURN VALUES
  
  =over
  
  =item *
  
  If C<choose> is called in a I<scalar context>, the user can choose an item by using the L</Keys to move around> and
  confirming with C<Return>.
  
  C<choose> then returns the chosen item.
  
  =item *
  
  If C<choose> is called in an I<list context>, the user can also mark an item with the C<SpaceBar>.
  
  C<choose> then returns - when C<Return> is pressed - the list of marked items (including the highlighted item if the
  option I<include_highlighted> is set to C<1>).
  
  In I<list context> C<Ctrl-SpaceBar> (or C<Ctrl-@>) inverts the choices: marked items are unmarked and unmarked items are
  marked.
  
  =item *
  
  If C<choose> is called in an I<void context>, the user can move around but mark nothing; the output shown by C<choose>
  can be closed with C<Return>.
  
  Called in void context C<choose> returns nothing.
  
  If the first argument refers to an empty array, C<choose> returns nothing.
  
  =back
  
  If the items of the list don't fit on the screen, the user can scroll to the next (previous) page(s).
  
  If the window size is changed, then as soon as the user enters a keystroke C<choose> rewrites the screen.
  
  C<choose> returns C<undef> or an empty list in list context if the C<q> key (or C<Ctrl-D>) is pressed.
  
  With a I<mouse> mode enabled (and if supported by the terminal) the item can be chosen with the left mouse key, in list
  context the right mouse key can be used instead the C<SpaceBar> key.
  
  =head2 Keys to move around
  
  =over
  
  =item *
  
  the C<Arrow> keys (or the C<h,j,k,l> keys) to move up and down or to move to the right and to the left,
  
  =item *
  
  the C<Tab> key (or C<Ctrl-I>) to move forward, the C<BackSpace> key (or C<Ctrl-H> or C<Shift-Tab>) to move backward,
  
  =item *
  
  the C<PageUp> key (or C<Ctrl-B>) to go back one page, the C<PageDown> key (or C<Ctrl-F>) to go forward one page,
  
  =item *
  
  the C<Home> key (or C<Ctrl-A>) to jump to the beginning of the list, the C<End> key (or C<Ctrl-E>) to jump to the end of
  the list.
  
  =back
  
  =head2 Modifications for the output
  
  For the output on the screen the array elements are modified.
  
  All the modifications are made on a copy of the original array so C<choose> returns the chosen elements as they were
  passed to the function without modifications.
  
  Modifications:
  
  =over
  
  =item *
  
  If an element is not defined the value from the option I<undef> is assigned to the element.
  
  =item *
  
  If an element holds an empty string the value from the option I<empty> is assigned to the element.
  
  =item *
  
  White-spaces in elements are replaced with simple spaces.
  
      $element =~ s/\p{Space}/ /g;
  
  =item *
  
  If the length of an element is greater than the width of the screen the element is cut and at the end of the string are
  added three dots.
  
  =back
  
  The following should be without meaning if you comply with the requirements.
  
  =over
  
  =item *
  
  Characters which match the Unicode character property C<Other> are removed.
  
      $element =~ s/\p{C}//g;
  
  C<ESC> characters are removed by this substitution so it is not possible to color the output with ANSI escape sequences.
  For colored output see L<Term::Choose_HAE>.
  
  =item *
  
  If an element is a reference it will be replaced with a string: the reference type followed with the hexadecimal value
  of the reference enclosed in parentheses.
  
      if ( ref $element ) {
          $element = sprintf "%s(0x%x)", ref $element, $element;
      }
  
  =item *
  
  The category of C<utf8> C<warnings> is disabled.
  
      no warnings 'utf8';
  
  =back
  
  =head1 OPTIONS
  
  Options which expect a number as their value expect integers.
  
  =head3 beep
  
  0 - off (default)
  
  1 - on
  
  =head3 clear_screen
  
  0 - off (default)
  
  1 - clears the screen before printing the choices
  
  =head3 default
  
  With the option I<default> it can be selected an element, which will be highlighted as the default instead of the first
  element.
  
  I<default> expects a zero indexed value, so e.g. to highlight the third element the value would be I<2>.
  
  If the passed value is greater than the index of the last array element the first element is highlighted.
  
  Allowed values: 0 or greater
  
  (default: undefined)
  
  =head3 empty
  
  Sets the string displayed on the screen instead an empty string.
  
  (default: "<empty>")
  
  =head3 hide_cursor
  
  0 - keep the terminals highlighting of the cursor position
  
  1 - hide the terminals highlighting of the cursor position (default)
  
  =head3 info
  
  Expects as its value a string. The string is printed above the prompt string.
  
  (default: not set)
  
  =head3 index
  
  0 - off (default)
  
  1 - return the index of the chosen element instead of the chosen element respective the indices of the chosen elements
  instead of the chosen elements.
  
  =head3 justify
  
  0 - elements ordered in columns are left justified (default)
  
  1 - elements ordered in columns are right justified
  
  2 - elements ordered in columns are centered
  
  =head3 keep
  
  I<keep> prevents that all the terminal rows are used by the prompt lines.
  
  Setting I<keep> ensures that at least I<keep> terminal rows are available for printing list rows.
  
  If the terminal height is less than I<keep> I<keep> is set to the terminal height.
  
  Allowed values: 1 or greater
  
  (default: 5)
  
  =head3 layout
  
  From broad to narrow: 0 > 1 > 2 > 3
  
  =over
  
  =item *
  
  0 - layout off
  
   .----------------------.   .----------------------.   .----------------------.   .----------------------.
   | .. .. .. .. .. .. .. |   | .. .. .. .. .. .. .. |   | .. .. .. .. .. .. .. |   | .. .. .. .. .. .. .. |
   |                      |   | .. .. .. .. .. .. .. |   | .. .. .. .. .. .. .. |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   | .. .. .. .. ..       |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   |                      |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   |                      |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   |                      |   | .. .. .. .. .. .. .. |
   '----------------------'   '----------------------'   '----------------------'   '----------------------'
  
  =item *
  
  1 - layout "H" (default)
  
   .----------------------.   .----------------------.   .----------------------.   .----------------------.
   | .. .. .. .. .. .. .. |   | .. .. .. .. ..       |   | .. .. .. .. .. ..    |   | .. .. .. .. .. .. .. |
   |                      |   | .. .. .. .. ..       |   | .. .. .. .. .. ..    |   | .. .. .. .. .. .. .. |
   |                      |   | .. ..                |   | .. .. .. .. .. ..    |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   | .. .. .. .. .. ..    |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   | .. .. ..             |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   |                      |   | .. .. .. .. .. .. .. |
   '----------------------'   '----------------------'   '----------------------'   '----------------------'
  
  =item *
  
  2 - layout "V"
  
   .----------------------.   .----------------------.   .----------------------.   .----------------------.
   | .. ..                |   | .. .. ..             |   | .. .. .. ..          |   | .. .. .. .. .. .. .. |
   | .. ..                |   | .. .. ..             |   | .. .. .. ..          |   | .. .. .. .. .. .. .. |
   | ..                   |   | .. .. ..             |   | .. .. .. ..          |   | .. .. .. .. .. .. .. |
   |                      |   | .. ..                |   | .. .. ..             |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   | .. .. ..             |   | .. .. .. .. .. .. .. |
   |                      |   |                      |   |                      |   | .. .. .. .. .. .. .. |
   '----------------------'   '----------------------'   '----------------------'   '----------------------'
  
  =item *
  
  3 - all in a single column
  
   .----------------------.   .----------------------.   .----------------------.   .----------------------.
   | ..                   |   | ..                   |   | ..                   |   | ..                   |
   | ..                   |   | ..                   |   | ..                   |   | ..                   |
   | ..                   |   | ..                   |   | ..                   |   | ..                   |
   |                      |   | ..                   |   | ..                   |   | ..                   |
   |                      |   |                      |   | ..                   |   | ..                   |
   |                      |   |                      |   |                      |   | ..                   |
   '----------------------'   '----------------------'   '----------------------'   '----------------------'
  
  =back
  
  =head3 lf
  
  If I<prompt> lines are folded the option I<lf> allows one to insert spaces at beginning of the folded lines.
  
  The option I<lf> expects a reference to an array with one or two elements:
  
  - the first element (C<INITIAL_TAB>) sets the number of spaces inserted at beginning of paragraphs
  
  - a second element (C<SUBSEQUENT_TAB>) sets the number of spaces inserted at the beginning of all broken lines apart
  from the beginning of paragraphs
  
  Allowed values for the two elements are: 0 or greater.
  
  See C<INITIAL_TAB> and C<SUBSEQUENT_TAB> in L<Text::LineFold>.
  
  (default: undefined)
  
  =head3 ll
  
  If all elements have the same length, the length can be passed with this option.
  
  If I<ll> is set, then C<choose> doesn't calculate the length of the longest element itself but uses the value passed
  with this option.
  
  I<length> refers here to the number of print columns the element will use on the terminal.
  
  The length of undefined elements depends on the value of the option I<undef>.
  
  If the option I<ll> is set, only undefined values are replaced. The replacements described in L</Modifications for the
  output> are not applied. If elements contain unsupported characters the output might break if the width (number of print
  columns) of the replacement character does not correspond to the width of the replaced character - for example when a
  unsupported non-spacing character is replaced by a replacement character with a normal width.
  
  If I<ll> is set to a value less than the length of the elements, the output could break.
  
  If the value of I<ll> is greater than the screen width, the elements will be trimmed to fit into the screen.
  
  If I<ll> is set, C<choose> returns (in list or scalar context) always the indexes of the chosen items regardless of how
  I<index> is set.
  
  If I<ll> is set and the window size has changed, choose returns immediately C<-1>.
  
  Allowed values: 1 or greater
  
  (default: undefined)
  
  =head3 max_height
  
  If defined sets the maximal number of rows used for printing list items.
  
  If the available height is less than I<max_height> I<max_height> is set to the available height.
  
  Height in this context means print rows.
  
  I<max_height> overwrites I<keep> if I<max_height> is set to a value less than I<keep>.
  
  Allowed values: 1 or greater
  
  (default: undefined)
  
  =head3 max_width
  
  If defined, sets the maximal output width to I<max_width> if the terminal width is greater than I<max_width>.
  
  To prevent the "auto-format" to use a width less than I<max_width> set I<layout> to 0.
  
  Width refers here to the number of print columns.
  
  Allowed values: 1 or greater
  
  (default: undefined)
  
  =head3 mouse
  
  For MSWin32 see also the end of this section.
  
  0 - no mouse mode (default)
  
  1 - mouse mode 1003 enabled
  
  2 - mouse mode 1003 enabled; the output width is limited to 223 print-columns and the height to 223 rows (mouse mode
  1003 doesn't work above 223)
  
  3 - extended mouse mode (1005) - uses utf8
  
  4 - extended SGR mouse mode (1006)
  
  If a mouse mode is enabled layers for C<STDIN> are changed. Then before leaving C<choose> as a cleanup C<STDIN> is
  marked as C<UTF-8> with C<:encoding(UTF-8)>. This doesn't apply if the OS is MSWin32.
  
  If the OS is MSWin32 there is no difference between the mouse modes 1, 3, and 4 - the all enable the mouse with the help
  of L<Win32::Console>.
  
  =head3 order
  
  If the output has more than one row and more than one column:
  
  0 - elements are ordered horizontally
  
  1 - elements are ordered vertically (default)
  
  Default may change in a future release.
  
  =head3 pad
  
  Sets the number of whitespaces between columns. (default: 2)
  
  Allowed values: 0 or greater
  
  =head3 page
  
  0 - off
  
  1 - print the page number on the bottom of the screen if there is more then one page. (default)
  
  =head3 prompt
  
  If I<prompt> is undefined a default prompt-string will be shown.
  
  If the I<prompt> value is an empty string ("") no prompt-line will be shown.
  
  default in list and scalar context: C<Your choice:>
  
  default in void context: C<Close with ENTER>
  
  =head3 undef
  
  Sets the string displayed on the screen instead an undefined element.
  
  default: "<undef>"
  
  =head2 Options List Context
  
  =head3 include_highlighted
  
  In list context when C<Return> is pressed
  
  0 - C<choose> returns the items marked with the C<SpaceBar>. (default)
  
  1 - C<choose> returns the items marked with the C<SpaceBar> plus the highlighted item.
  
  2 - C<choose> returns the items marked with the C<SpaceBar>. If no items are marked with the C<SpaceBar>, the
  highlighted item is returned.
  
  =head3 mark
  
  I<mark> expects as its value a reference to an array. The elements of the array are list indexes. C<choose> preselects
  the list-elements correlating to these indexes.
  
  Elements greater than the last index of the list are ignored.
  
  This option has only meaning in list context.
  
  (default: undefined)
  
  =head3 meta_items
  
  I<meta_items> expects as its value a reference to an array. The elements of the array are list indexes. These elements
  can not be marked with the C<SpaceBar> or with the right mouse key but if one of these elements is the highlighted item
  it is added to the chosen items when C<Return> is pressed.
  
  Elements greater than the last index of the list are ignored.
  
  This option has only meaning in list context.
  
  (default: undefined)
  
  =head3 no_spacebar
  
  I<no_spacebar> expects as its value a reference to an array. The elements of the array are indexes of the list which
  should not be markable with the C<SpaceBar> or with the right mouse key.
  
  If an element is preselected with the option I<mark> and also marked as not selectable with the option I<no_spacebar>,
  the user can not remove the preselection of this element.
  
  I<no_spacebar> elements greater than the last index of the list are ignored.
  
  This option has only meaning in list context.
  
  (default: undefined)
  
  =head1 ERROR HANDLING
  
  =head2 croak
  
  C<new|choose> dies if passed invalid arguments.
  
  =head2 carp
  
  If after pressing a key L<Term::ReadKey>::ReadKey returns C<undef> C<choose> warns with C<EOT: $!> and returns
  I<undef> or an empty list in list context.
  
  =head1 REQUIREMENTS
  
  =head2 Perl version
  
  Requires Perl version 5.8.3 or greater.
  
  =head2 Decoded strings
  
  C<choose> expects decoded strings as array elements.
  
  =head2 Encoding layer for STDOUT
  
  For a correct output it is required an appropriate encoding layer for STDOUT matching the terminal's character set.
  
  =head2 Monospaced font
  
  It is required a terminal that uses a monospaced font which supports the printed characters.
  
  =head2 Escape sequences
  
  It is required a terminal that supports ANSI escape sequences.
  
  If the option "hide_cursor" is enabled, it is also required the support for the following escape sequences:
  
      "\e[?25l"   Hide Cursor
  
      "\e[?25h"   Show Cursor
  
  If a I<mouse> mode is enabled
  
      "\e[?1003h", "\e[?1005h", "\e[?1006h"   Enable Mouse Tracking
  
      "\e[?1003l", "\e[?1005l", "\e[?1006l"   Disable Mouse Tracking
  
  are used to enable/disable the different I<mouse> modes.
  
  If the OS is MSWin32 L<Win32::Console> is used, to emulate the behavior of the escape sequences.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Term::Choose
  
  =head1 AUTHOR
  
  Matthäus Kiem <cuer2s@gmail.com>
  
  =head1 CREDITS
  
  Based on the C<choose> function from the L<Term::Clui> module.
  
  Thanks to the L<Perl-Community.de|http://www.perl-community.de> and the people form
  L<stackoverflow|http://stackoverflow.com> for the help.
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (C) 2012-2018 Matthäus Kiem.
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl 5.10.0. For
  details, see the full text of the licenses in the file LICENSE.
  
  =cut
TERM_CHOOSE

$fatpacked{"Term/Choose/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_CHOOSE_CONSTANTS';
  package Term::Choose::Constants;
  
  use warnings;
  use strict;
  use 5.008003;
  
  our $VERSION = '1.600';
  
  use Exporter qw( import );
  
  our @EXPORT_OK = qw(
          ROW COL
          LF CR
          HIDE_CURSOR SHOW_CURSOR WIDTH_CURSOR
          MAX_ROW_MOUSE_1003 MAX_COL_MOUSE_1003
          GET_CURSOR_POSITION
          SET_ANY_EVENT_MOUSE_1003 SET_EXT_MODE_MOUSE_1005 SET_SGR_EXT_MODE_MOUSE_1006
          UNSET_ANY_EVENT_MOUSE_1003 UNSET_EXT_MODE_MOUSE_1005 UNSET_SGR_EXT_MODE_MOUSE_1006
          BEEP CLEAR_SCREEN CLEAR_TO_END_OF_SCREEN RESET REVERSE BOLD_UNDERLINE
          NEXT_get_key
          CONTROL_SPACE CONTROL_A CONTROL_B CONTROL_C CONTROL_D CONTROL_E CONTROL_F CONTROL_H KEY_BTAB CONTROL_I KEY_TAB
          KEY_ENTER KEY_ESC KEY_SPACE KEY_h KEY_j KEY_k KEY_l KEY_q KEY_Tilde KEY_BSPACE
          VK_PAGE_UP VK_PAGE_DOWN VK_END VK_HOME VK_LEFT VK_UP VK_RIGHT VK_DOWN VK_INSERT VK_DELETE
          MOUSE_WHEELED
          LEFTMOST_BUTTON_PRESSED RIGHTMOST_BUTTON_PRESSED FROM_LEFT_2ND_BUTTON_PRESSED
  );
  
  our %EXPORT_TAGS = (
      choose => [ qw(
          ROW COL
          LF CR
          WIDTH_CURSOR
          MAX_ROW_MOUSE_1003 MAX_COL_MOUSE_1003
          BEEP
          NEXT_get_key
          CONTROL_SPACE CONTROL_A CONTROL_B CONTROL_C CONTROL_D CONTROL_E CONTROL_F CONTROL_H KEY_BTAB CONTROL_I KEY_TAB
          KEY_ENTER KEY_SPACE KEY_h KEY_j KEY_k KEY_l KEY_q KEY_Tilde KEY_BSPACE
          VK_PAGE_UP VK_PAGE_DOWN VK_END VK_HOME VK_LEFT VK_UP VK_RIGHT VK_DOWN
      ) ],
      linux  => [ qw(
          CLEAR_SCREEN CLEAR_TO_END_OF_SCREEN RESET REVERSE BOLD_UNDERLINE
          HIDE_CURSOR SHOW_CURSOR WIDTH_CURSOR
          GET_CURSOR_POSITION
          SET_ANY_EVENT_MOUSE_1003 SET_EXT_MODE_MOUSE_1005 SET_SGR_EXT_MODE_MOUSE_1006
          UNSET_ANY_EVENT_MOUSE_1003 UNSET_EXT_MODE_MOUSE_1005 UNSET_SGR_EXT_MODE_MOUSE_1006
          NEXT_get_key
          KEY_BTAB KEY_ESC
          VK_PAGE_UP VK_PAGE_DOWN VK_END VK_HOME VK_LEFT VK_UP VK_RIGHT VK_DOWN VK_INSERT VK_DELETE
      ) ],
      win32  => [ qw(
          NEXT_get_key
          CONTROL_SPACE
          VK_PAGE_UP VK_PAGE_DOWN VK_END VK_HOME VK_LEFT VK_UP VK_RIGHT VK_DOWN VK_INSERT VK_DELETE
          MOUSE_WHEELED
          LEFTMOST_BUTTON_PRESSED RIGHTMOST_BUTTON_PRESSED FROM_LEFT_2ND_BUTTON_PRESSED
      ) ]
  );
  
  
  use constant {
      ROW => 0,
      COL => 1,
  };
  
  use constant {
      LF => "\n",
      CR => "\r",
  
      BEEP                   => "\a",
      CLEAR_SCREEN           => "\e[H\e[J",
      CLEAR_TO_END_OF_SCREEN => "\e[0J",
      RESET                  => "\e[0m",
      BOLD_UNDERLINE         => "\e[1m\e[4m",
      REVERSE                => "\e[7m",
  
      HIDE_CURSOR  => "\e[?25l",
      SHOW_CURSOR  => "\e[?25h",
      WIDTH_CURSOR => 1,
  };
  
  use constant {
      GET_CURSOR_POSITION => "\e[6n",
  
      SET_ANY_EVENT_MOUSE_1003      => "\e[?1003h",
      SET_EXT_MODE_MOUSE_1005       => "\e[?1005h",
      SET_SGR_EXT_MODE_MOUSE_1006   => "\e[?1006h",
      UNSET_ANY_EVENT_MOUSE_1003    => "\e[?1003l",
      UNSET_EXT_MODE_MOUSE_1005     => "\e[?1005l",
      UNSET_SGR_EXT_MODE_MOUSE_1006 => "\e[?1006l",
  
      MAX_ROW_MOUSE_1003 => 223,
      MAX_COL_MOUSE_1003 => 223,
  
      MOUSE_WHEELED                => 0x0004,
  
      LEFTMOST_BUTTON_PRESSED      => 0x0001,
      RIGHTMOST_BUTTON_PRESSED     => 0x0002,
      FROM_LEFT_2ND_BUTTON_PRESSED => 0x0004,
  };
  
  use constant {
      NEXT_get_key  => -1,
  
      CONTROL_SPACE => 0x00,
      CONTROL_A     => 0x01,
      CONTROL_B     => 0x02,
      CONTROL_C     => 0x03,
      CONTROL_D     => 0x04,
      CONTROL_E     => 0x05,
      CONTROL_F     => 0x06,
      CONTROL_H     => 0x08,
      KEY_BTAB      => 0x08,
      CONTROL_I     => 0x09,
      KEY_TAB       => 0x09,
      KEY_ENTER     => 0x0d,
      KEY_ESC       => 0x1b,
      KEY_SPACE     => 0x20,
      KEY_h         => 0x68,
      KEY_j         => 0x6a,
      KEY_k         => 0x6b,
      KEY_l         => 0x6c,
      KEY_q         => 0x71,
      KEY_Tilde     => 0x7e,
      KEY_BSPACE    => 0x7f,
  
      VK_PAGE_UP    => 33,
      VK_PAGE_DOWN  => 34,
      VK_END        => 35,
      VK_HOME       => 36,
      VK_LEFT       => 37,
      VK_UP         => 38,
      VK_RIGHT      => 39,
      VK_DOWN       => 40,
      VK_INSERT     => 45, # unused
      VK_DELETE     => 46, # unused
  };
  
  
  
  1;
  
  __END__
TERM_CHOOSE_CONSTANTS

$fatpacked{"Term/Choose/LineFold.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_CHOOSE_LINEFOLD';
  package Term::Choose::LineFold;
  
  use warnings;
  use strict;
  use 5.008003;
  
  our $VERSION = '1.600';
  
  use Exporter qw( import );
  
  our @EXPORT_OK = qw( line_fold print_columns cut_to_printwidth );
  
  # *) filtered away with: $s =~ s/\p{Space}/ /; $s =~ s/\p{C}//;
  # all chars with width 1 commented out because 1 is default
  # where `columns` form Unicode::GCString returns a higher value (width) this higher values is used
  
  # table from https://github.com/unicode-rs/unicode-width/blob/master/src/tables.rs
  
  my $table = [
  ###[0x00, 0x1f, 0], *)
  ###[0x7f, 0x9f, 0], *)
  #[0xa1, 0xa1, 1],
  #[0xa4, 0xa4, 1],
  #[0xa7, 0xa8, 1],
  #[0xaa, 0xaa, 1],
  ###[0xad, 0xad, 0], *)
  #[0xae, 0xae, 1],
  #[0xb0, 0xb4, 1],
  #[0xb6, 0xba, 1],
  #[0xbc, 0xbf, 1],
  #[0xc6, 0xc6, 1],
  #[0xd0, 0xd0, 1],
  #[0xd7, 0xd8, 1],
  #[0xde, 0xe1, 1],
  #[0xe6, 0xe6, 1],
  #[0xe8, 0xea, 1],
  #[0xec, 0xed, 1],
  #[0xf0, 0xf0, 1],
  #[0xf2, 0xf3, 1],
  #[0xf7, 0xfa, 1],
  #[0xfc, 0xfc, 1],
  #[0xfe, 0xfe, 1],
  #[0x101, 0x101, 1],
  #[0x111, 0x111, 1],
  #[0x113, 0x113, 1],
  #[0x11b, 0x11b, 1],
  #[0x126, 0x127, 1],
  #[0x12b, 0x12b, 1],
  #[0x131, 0x133, 1],
  #[0x138, 0x138, 1],
  #[0x13f, 0x142, 1],
  #[0x144, 0x144, 1],
  #[0x148, 0x14b, 1],
  #[0x14d, 0x14d, 1],
  #[0x152, 0x153, 1],
  #[0x166, 0x167, 1],
  #[0x16b, 0x16b, 1],
  #[0x1ce, 0x1ce, 1],
  #[0x1d0, 0x1d0, 1],
  #[0x1d2, 0x1d2, 1],
  #[0x1d4, 0x1d4, 1],
  #[0x1d6, 0x1d6, 1],
  #[0x1d8, 0x1d8, 1],
  #[0x1da, 0x1da, 1],
  #[0x1dc, 0x1dc, 1],
  #[0x251, 0x251, 1],
  #[0x261, 0x261, 1],
  #[0x2c4, 0x2c4, 1],
  #[0x2c7, 0x2c7, 1],
  #[0x2c9, 0x2cb, 1],
  #[0x2cd, 0x2cd, 1],
  #[0x2d0, 0x2d0, 1],
  #[0x2d8, 0x2db, 1],
  #[0x2dd, 0x2dd, 1],
  #[0x2df, 0x2df, 1],
  [0x300, 0x36f, 0],
  #[0x391, 0x3a1, 1],
  #[0x3a3, 0x3a9, 1],
  #[0x3b1, 0x3c1, 1],
  #[0x3c3, 0x3c9, 1],
  #[0x401, 0x401, 1],
  #[0x410, 0x44f, 1],
  #[0x451, 0x451, 1],
  [0x483, 0x489, 0],
  [0x591, 0x5bd, 0],
  [0x5bf, 0x5bf, 0],
  [0x5c1, 0x5c2, 0],
  [0x5c4, 0x5c5, 0],
  [0x5c7, 0x5c7, 0],
  [0x600, 0x605, 0],
  [0x610, 0x61a, 0],
  [0x61c, 0x61c, 0],
  [0x64b, 0x65f, 0],
  [0x670, 0x670, 0],
  [0x6d6, 0x6dd, 0],
  [0x6df, 0x6e4, 0],
  [0x6e7, 0x6e8, 0],
  [0x6ea, 0x6ed, 0],
  ###[0x70f, 0x70f, 0], *)
  [0x711, 0x711, 0],
  [0x730, 0x74a, 0],
  [0x7a6, 0x7b0, 0],
  [0x7eb, 0x7f3, 0],
  [0x816, 0x819, 0],
  [0x81b, 0x823, 0],
  [0x825, 0x827, 0],
  [0x829, 0x82d, 0],
  [0x859, 0x85b, 0],
  
  #################### # Unicode::GCString
  # [0x8d4, 0x902, 0], # orig
   #[0x8d4, 0x8e2, 1],
    [0x8e3, 0x902, 0],
  ####################
  
  [0x93a, 0x93a, 0],
  [0x93c, 0x93c, 0],
  [0x941, 0x948, 0],
  [0x94d, 0x94d, 0],
  [0x951, 0x957, 0],
  [0x962, 0x963, 0],
  [0x981, 0x981, 0],
  [0x9bc, 0x9bc, 0],
  [0x9c1, 0x9c4, 0],
  [0x9cd, 0x9cd, 0],
  [0x9e2, 0x9e3, 0],
  [0xa01, 0xa02, 0],
  [0xa3c, 0xa3c, 0],
  [0xa41, 0xa42, 0],
  [0xa47, 0xa48, 0],
  [0xa4b, 0xa4d, 0],
  [0xa51, 0xa51, 0],
  [0xa70, 0xa71, 0],
  [0xa75, 0xa75, 0],
  [0xa81, 0xa82, 0],
  [0xabc, 0xabc, 0],
  [0xac1, 0xac5, 0],
  [0xac7, 0xac8, 0],
  [0xacd, 0xacd, 0],
  [0xae2, 0xae3, 0],
  
  #################### # Unicode::GCString
  # [0xafa, 0xaff, 0], # -> 1
  ####################
  
  [0xb01, 0xb01, 0],
  [0xb3c, 0xb3c, 0],
  [0xb3f, 0xb3f, 0],
  [0xb41, 0xb44, 0],
  [0xb4d, 0xb4d, 0],
  [0xb56, 0xb56, 0],
  [0xb62, 0xb63, 0],
  [0xb82, 0xb82, 0],
  [0xbc0, 0xbc0, 0],
  [0xbcd, 0xbcd, 0],
  [0xc00, 0xc00, 0],
  [0xc3e, 0xc40, 0],
  [0xc46, 0xc48, 0],
  [0xc4a, 0xc4d, 0],
  [0xc55, 0xc56, 0],
  [0xc62, 0xc63, 0],
  [0xc81, 0xc81, 0],
  [0xcbc, 0xcbc, 0],
  [0xcbf, 0xcbf, 0],
  [0xcc6, 0xcc6, 0],
  [0xccc, 0xccd, 0],
  [0xce2, 0xce3, 0],
  
  #################### # Unicode::GCString
  # [0xd00, 0xd01, 0], # orig
   #[0xd00, 0xd00, 1],
    [0xd01, 0xd01, 0],
  ####################
  
  ##################### # Unicode::GCString
   # [0xd3b, 0xd3c, 0], # -> 1
  #####################
  
  [0xd41, 0xd44, 0],
  [0xd4d, 0xd4d, 0],
  [0xd62, 0xd63, 0],
  [0xdca, 0xdca, 0],
  [0xdd2, 0xdd4, 0],
  [0xdd6, 0xdd6, 0],
  [0xe31, 0xe31, 0],
  [0xe34, 0xe3a, 0],
  [0xe47, 0xe4e, 0],
  [0xeb1, 0xeb1, 0],
  [0xeb4, 0xeb9, 0],
  [0xebb, 0xebc, 0],
  [0xec8, 0xecd, 0],
  [0xf18, 0xf19, 0],
  [0xf35, 0xf35, 0],
  [0xf37, 0xf37, 0],
  [0xf39, 0xf39, 0],
  [0xf71, 0xf7e, 0],
  [0xf80, 0xf84, 0],
  [0xf86, 0xf87, 0],
  [0xf8d, 0xf97, 0],
  [0xf99, 0xfbc, 0],
  [0xfc6, 0xfc6, 0],
  [0x102d, 0x1030, 0],
  [0x1032, 0x1037, 0],
  [0x1039, 0x103a, 0],
  [0x103d, 0x103e, 0],
  [0x1058, 0x1059, 0],
  [0x105e, 0x1060, 0],
  [0x1071, 0x1074, 0],
  [0x1082, 0x1082, 0],
  [0x1085, 0x1086, 0],
  [0x108d, 0x108d, 0],
  [0x109d, 0x109d, 0],
  [0x1100, 0x115f, 2],
  
  ###################### # Unicode::GCString
  # [0x1160, 0x11ff, 0],
    [0x1160, 0x11ff, 2],
  ######################
  
  [0x135d, 0x135f, 0],
  [0x1712, 0x1714, 0],
  [0x1732, 0x1734, 0],
  [0x1752, 0x1753, 0],
  [0x1772, 0x1773, 0],
  [0x17b4, 0x17b5, 0],
  [0x17b7, 0x17bd, 0],
  [0x17c6, 0x17c6, 0],
  [0x17c9, 0x17d3, 0],
  [0x17dd, 0x17dd, 0],
  [0x180b, 0x180e, 0],
  
  ###################### # Unicode::GCString
  # [0x1885, 0x1886, 0], # -> 1
  ######################
  
  [0x18a9, 0x18a9, 0],
  [0x1920, 0x1922, 0],
  [0x1927, 0x1928, 0],
  [0x1932, 0x1932, 0],
  [0x1939, 0x193b, 0],
  [0x1a17, 0x1a18, 0],
  [0x1a1b, 0x1a1b, 0],
  [0x1a56, 0x1a56, 0],
  [0x1a58, 0x1a5e, 0],
  [0x1a60, 0x1a60, 0],
  [0x1a62, 0x1a62, 0],
  [0x1a65, 0x1a6c, 0],
  [0x1a73, 0x1a7c, 0],
  [0x1a7f, 0x1a7f, 0],
  [0x1ab0, 0x1abe, 0],
  [0x1b00, 0x1b03, 0],
  [0x1b34, 0x1b34, 0],
  [0x1b36, 0x1b3a, 0],
  [0x1b3c, 0x1b3c, 0],
  [0x1b42, 0x1b42, 0],
  [0x1b6b, 0x1b73, 0],
  [0x1b80, 0x1b81, 0],
  [0x1ba2, 0x1ba5, 0],
  [0x1ba8, 0x1ba9, 0],
  [0x1bab, 0x1bad, 0],
  [0x1be6, 0x1be6, 0],
  [0x1be8, 0x1be9, 0],
  [0x1bed, 0x1bed, 0],
  [0x1bef, 0x1bf1, 0],
  [0x1c2c, 0x1c33, 0],
  [0x1c36, 0x1c37, 0],
  [0x1cd0, 0x1cd2, 0],
  [0x1cd4, 0x1ce0, 0],
  [0x1ce2, 0x1ce8, 0],
  [0x1ced, 0x1ced, 0],
  [0x1cf4, 0x1cf4, 0],
  [0x1cf8, 0x1cf9, 0],
  
  ###################### # Unicode::GCString
  # [0x1dc0, 0x1df9, 0], # orig
  # [0x1dfb, 0x1dff, 0], # orig
    [0x1dc0, 0x1df5, 0],
   #[0x1df6, 0x1dfb, 1],
    [0x1dfc, 0x1dff, 0],
  ######################
  
  ###[0x200b, 0x200f, 0], *)
  #[0x2010, 0x2010, 1],
  #[0x2013, 0x2016, 1],
  #[0x2018, 0x2019, 1],
  #[0x201c, 0x201d, 1],
  #[0x2020, 0x2022, 1],
  #[0x2024, 0x2027, 1],
  ###[0x2028, 0x2029, 0], *)
  ###[0x202a, 0x202e, 0], *)
  ###[0x206a, 0x206f, 0], *)
  #[0x2030, 0x2030, 1],
  #[0x2032, 0x2033, 1],
  #[0x2035, 0x2035, 1],
  #[0x203b, 0x203b, 1],
  #[0x203e, 0x203e, 1],
  [0x2060, 0x2064, 0],
  [0x2066, 0x206f, 0],
  #[0x2074, 0x2074, 1],
  #[0x207f, 0x207f, 1],
  #[0x2081, 0x2084, 1],
  #[0x20ac, 0x20ac, 1],
  [0x20d0, 0x20f0, 0],
  #[0x2103, 0x2103, 1],
  #[0x2105, 0x2105, 1],
  #[0x2109, 0x2109, 1],
  #[0x2113, 0x2113, 1],
  #[0x2116, 0x2116, 1],
  #[0x2121, 0x2122, 1],
  #[0x2126, 0x2126, 1],
  #[0x212b, 0x212b, 1],
  #[0x2153, 0x2154, 1],
  #[0x215b, 0x215e, 1],
  #[0x2160, 0x216b, 1],
  #[0x2170, 0x2179, 1],
  #[0x2189, 0x2189, 1],
  #[0x2190, 0x2199, 1],
  #[0x21b8, 0x21b9, 1],
  #[0x21d2, 0x21d2, 1],
  #[0x21d4, 0x21d4, 1],
  #[0x21e7, 0x21e7, 1],
  #[0x2200, 0x2200, 1],
  #[0x2202, 0x2203, 1],
  #[0x2207, 0x2208, 1],
  #[0x220b, 0x220b, 1],
  #[0x220f, 0x220f, 1],
  #[0x2211, 0x2211, 1],
  #[0x2215, 0x2215, 1],
  #[0x221a, 0x221a, 1],
  #[0x221d, 0x2220, 1],
  #[0x2223, 0x2223, 1],
  #[0x2225, 0x2225, 1],
  #[0x2227, 0x222c, 1],
  #[0x222e, 0x222e, 1],
  #[0x2234, 0x2237, 1],
  #[0x223c, 0x223d, 1],
  #[0x2248, 0x2248, 1],
  #[0x224c, 0x224c, 1],
  #[0x2252, 0x2252, 1],
  #[0x2260, 0x2261, 1],
  #[0x2264, 0x2267, 1],
  #[0x226a, 0x226b, 1],
  #[0x226e, 0x226f, 1],
  #[0x2282, 0x2283, 1],
  #[0x2286, 0x2287, 1],
  #[0x2295, 0x2295, 1],
  #[0x2299, 0x2299, 1],
  #[0x22a5, 0x22a5, 1],
  #[0x22bf, 0x22bf, 1],
  #[0x2312, 0x2312, 1],
  [0x231a, 0x231b, 2],
  [0x2329, 0x232a, 2],
  [0x23e9, 0x23ec, 2],
  [0x23f0, 0x23f0, 2],
  [0x23f3, 0x23f3, 2],
  #[0x2460, 0x24e9, 1],
  #[0x24eb, 0x254b, 1],
  #[0x2550, 0x2573, 1],
  #[0x2580, 0x258f, 1],
  #[0x2592, 0x2595, 1],
  #[0x25a0, 0x25a1, 1],
  #[0x25a3, 0x25a9, 1],
  #[0x25b2, 0x25b3, 1],
  #[0x25b6, 0x25b7, 1],
  #[0x25bc, 0x25bd, 1],
  #[0x25c0, 0x25c1, 1],
  #[0x25c6, 0x25c8, 1],
  #[0x25cb, 0x25cb, 1],
  #[0x25ce, 0x25d1, 1],
  #[0x25e2, 0x25e5, 1],
  #[0x25ef, 0x25ef, 1],
  [0x25fd, 0x25fe, 2],        # ?
  #[0x2605, 0x2606, 1],
  #[0x2609, 0x2609, 1],
  #[0x260e, 0x260f, 1],
  [0x2614, 0x2615, 2],        # ?
  #[0x261c, 0x261c, 1],
  #[0x261e, 0x261e, 1],
  #[0x2640, 0x2640, 1],
  #[0x2642, 0x2642, 1],
  [0x2648, 0x2653, 2],        # 0x2648 .. 0x2649,  0x0264a .. 0x02653 ?
  #[0x2660, 0x2661, 1],
  #[0x2663, 0x2665, 1],
  #[0x2667, 0x266a, 1],
  #[0x266c, 0x266d, 1],
  #[0x266f, 0x266f, 1],
  [0x267f, 0x267f, 2],
  [0x2693, 0x2693, 2],
  #[0x269e, 0x269f, 1],
  [0x26a1, 0x26a1, 2],
  [0x26aa, 0x26ab, 2],
  [0x26bd, 0x26be, 2],
  #[0x26bf, 0x26bf, 1],
  [0x26c4, 0x26c5, 2],
  #[0x26c6, 0x26cd, 1],
  [0x26ce, 0x26ce, 2],
  #[0x26cf, 0x26d3, 1],
  [0x26d4, 0x26d4, 2],
  #[0x26d5, 0x26e1, 1],
  #[0x26e3, 0x26e3, 1],
  #[0x26e8, 0x26e9, 1],
  [0x26ea, 0x26ea, 2],
  #[0x26eb, 0x26f1, 1],
  [0x26f2, 0x26f3, 2],
  #[0x26f4, 0x26f4, 1],
  [0x26f5, 0x26f5, 2],
  #[0x26f6, 0x26f9, 1],
  [0x26fa, 0x26fa, 2],
  #[0x26fb, 0x26fc, 1],
  [0x26fd, 0x26fd, 2],
  #[0x26fe, 0x26ff, 1],
  [0x2705, 0x2705, 2],
  [0x270a, 0x270b, 2],
  [0x2728, 0x2728, 2],
  #[0x273d, 0x273d, 1],
  [0x274c, 0x274c, 2],
  [0x274e, 0x274e, 2],
  [0x2753, 0x2755, 2],
  [0x2757, 0x2757, 2],
  #[0x2776, 0x277f, 1],
  [0x2795, 0x2797, 2],
  [0x27b0, 0x27b0, 2],
  [0x27bf, 0x27bf, 2],
  [0x2b1b, 0x2b1c, 2],
  [0x2b50, 0x2b50, 2],
  [0x2b55, 0x2b55, 2],
  #[0x2b56, 0x2b59, 1],
  [0x2cef, 0x2cf1, 0],
  [0x2d7f, 0x2d7f, 0],
  [0x2de0, 0x2dff, 0],
  [0x2e80, 0x2e99, 2],
  [0x2e9b, 0x2ef3, 2],
  [0x2f00, 0x2fd5, 2],
  [0x2ff0, 0x2ffb, 2],
  [0x3000, 0x3029, 2],
  [0x302a, 0x302d, 0],
  [0x302e, 0x303e, 2],
  [0x3041, 0x3096, 2],
  [0x3099, 0x309a, 0],
  [0x309b, 0x30ff, 2],
  [0x3105, 0x312e, 2],
  [0x3131, 0x318e, 2],
  [0x3190, 0x31ba, 2],
  [0x31c0, 0x31e3, 2],
  [0x31f0, 0x321e, 2],
  [0x3220, 0x3247, 2],
  #[0x3248, 0x324f, 1],
  [0x3250, 0x32fe, 2],
  [0x3300, 0x4dbf, 2],
  [0x4e00, 0xa48c, 2],
  [0xa490, 0xa4c6, 2],
  [0xa66f, 0xa672, 0],
  [0xa674, 0xa67d, 0],
  [0xa69e, 0xa69f, 0],
  [0xa6f0, 0xa6f1, 0],
  [0xa802, 0xa802, 0],
  [0xa806, 0xa806, 0],
  [0xa80b, 0xa80b, 0],
  [0xa825, 0xa826, 0],
  
  ###################### # Unicode::GCString
  # [0xa8c4, 0xa8c5, 0], # orig
    [0xa8c4, 0xa8c4, 0],
   #[0xa8c5, 0xa8c5, 1],
  ######################
  
  [0xa8e0, 0xa8f1, 0],
  [0xa926, 0xa92d, 0],
  [0xa947, 0xa951, 0],
  [0xa960, 0xa97c, 2],
  [0xa980, 0xa982, 0],
  [0xa9b3, 0xa9b3, 0],
  [0xa9b6, 0xa9b9, 0],
  [0xa9bc, 0xa9bc, 0],
  [0xa9e5, 0xa9e5, 0],
  [0xaa29, 0xaa2e, 0],
  [0xaa31, 0xaa32, 0],
  [0xaa35, 0xaa36, 0],
  [0xaa43, 0xaa43, 0],
  [0xaa4c, 0xaa4c, 0],
  [0xaa7c, 0xaa7c, 0],
  [0xaab0, 0xaab0, 0],
  [0xaab2, 0xaab4, 0],
  [0xaab7, 0xaab8, 0],
  [0xaabe, 0xaabf, 0],
  [0xaac1, 0xaac1, 0],
  [0xaaec, 0xaaed, 0],
  [0xaaf6, 0xaaf6, 0],
  [0xabe5, 0xabe5, 0],
  [0xabe8, 0xabe8, 0],
  [0xabed, 0xabed, 0],
  [0xac00, 0xd7a3, 2],
  
  ####################### # Unicode::GCString
    [0xd7b0, 0x0d7fb, 2], # Hangul Jamo Extended-B
  #######################
  
  ### [0xd800, 0xdfff, 0], *)    Unicode surrogate
  
  #[0xe000, 0xf8ff, 1], # ###
  
  
  [0xf900, 0xfaff, 2],
  [0xfb1e, 0xfb1e, 0],
  [0xfe00, 0xfe0f, 0],
  [0xfe10, 0xfe19, 2],
  [0xfe20, 0xfe2f, 0],
  [0xfe30, 0xfe52, 2],
  [0xfe54, 0xfe66, 2],
  [0xfe68, 0xfe6b, 2],
  ### [0xfeff, 0xfeff, 0], *)
  [0xff01, 0xff60, 2],
  [0xffe0, 0xffe6, 2],
  ### [0xfff9, 0xfffb, 0], *)
  #[0xfffd, 0xfffd, 1],
  ### [0xfffe, 0xffff, 0], *)
  [0x101fd, 0x101fd, 0],
  [0x102e0, 0x102e0, 0],
  [0x10376, 0x1037a, 0],
  [0x10a01, 0x10a03, 0],
  [0x10a05, 0x10a06, 0],
  [0x10a0c, 0x10a0f, 0],
  [0x10a38, 0x10a3a, 0],
  [0x10a3f, 0x10a3f, 0],
  [0x10ae5, 0x10ae6, 0],
  [0x11001, 0x11001, 0],
  [0x11038, 0x11046, 0],
  [0x1107f, 0x11081, 0],
  [0x110b3, 0x110b6, 0],
  [0x110b9, 0x110ba, 0],
  [0x110bd, 0x110bd, 0],
  [0x11100, 0x11102, 0],
  [0x11127, 0x1112b, 0],
  [0x1112d, 0x11134, 0],
  [0x11173, 0x11173, 0],
  [0x11180, 0x11181, 0],
  [0x111b6, 0x111be, 0],
  [0x111ca, 0x111cc, 0],
  [0x1122f, 0x11231, 0],
  [0x11234, 0x11234, 0],
  [0x11236, 0x11237, 0],
  
  ######################### # Unicode::GCString
  #  [0x1123e, 0x1123e, 0], # -> 1
  #########################
  
  [0x112df, 0x112df, 0],
  [0x112e3, 0x112ea, 0],
  [0x11300, 0x11301, 0],
  [0x1133c, 0x1133c, 0],
  [0x11340, 0x11340, 0],
  [0x11366, 0x1136c, 0],
  [0x11370, 0x11374, 0],
  
  ######################## # Unicode::GCString
  # [0x11438, 0x1143f, 0], # -> 1
  # [0x11442, 0x11444, 0], # -> 1
  # [0x11446, 0x11446, 0], # -> 1
  ########################
  
  [0x114b3, 0x114b8, 0],
  [0x114ba, 0x114ba, 0],
  [0x114bf, 0x114c0, 0],
  [0x114c2, 0x114c3, 0],
  [0x115b2, 0x115b5, 0],
  [0x115bc, 0x115bd, 0],
  [0x115bf, 0x115c0, 0],
  [0x115dc, 0x115dd, 0],
  [0x11633, 0x1163a, 0],
  [0x1163d, 0x1163d, 0],
  [0x1163f, 0x11640, 0],
  [0x116ab, 0x116ab, 0],
  [0x116ad, 0x116ad, 0],
  [0x116b0, 0x116b5, 0],
  [0x116b7, 0x116b7, 0],
  [0x1171d, 0x1171f, 0],
  [0x11722, 0x11725, 0],
  [0x11727, 0x1172b, 0],
  
  ######################## # Unicode::GCString
  # [0x11a01, 0x11a06, 0], # -> 1
  # [0x11a09, 0x11a0a, 0], # -> 1
  # [0x11a33, 0x11a38, 0], # -> 1
  # [0x11a3b, 0x11a3e, 0], # -> 1
  # [0x11a47, 0x11a47, 0], # -> 1
  # [0x11a51, 0x11a56, 0], # -> 1
  # [0x11a59, 0x11a5b, 0], # -> 1
  # [0x11a8a, 0x11a96, 0], # -> 1
  # [0x11a98, 0x11a99, 0], # -> 1
  # [0x11c30, 0x11c36, 0], # -> 1
  # [0x11c38, 0x11c3d, 0], # -> 1
  # [0x11c3f, 0x11c3f, 0], # -> 1
  # [0x11c92, 0x11ca7, 0], # -> 1
  # [0x11caa, 0x11cb0, 0], # -> 1
  # [0x11cb2, 0x11cb3, 0], # -> 1
  # [0x11cb5, 0x11cb6, 0], # -> 1
  # [0x11d31, 0x11d36, 0], # -> 1
  # [0x11d3a, 0x11d3a, 0], # -> 1
  # [0x11d3c, 0x11d3d, 0], # -> 1
  # [0x11d3f, 0x11d45, 0], # -> 1
  # [0x11d47, 0x11d47, 0], # -> 1
  ########################
  
  [0x16af0, 0x16af4, 0],
  [0x16b30, 0x16b36, 0],
  [0x16f8f, 0x16f92, 0],
  [0x16fe0, 0x16fe1, 2],
  [0x17000, 0x187ec, 2],
  [0x18800, 0x18af2, 2],
  [0x1b000, 0x1b11e, 2],
  [0x1b170, 0x1b2fb, 2],
  [0x1bc9d, 0x1bc9e, 0],
  [0x1bca0, 0x1bca3, 0],
  [0x1d167, 0x1d169, 0],
  [0x1d173, 0x1d182, 0],
  [0x1d185, 0x1d18b, 0],
  [0x1d1aa, 0x1d1ad, 0],
  [0x1d242, 0x1d244, 0],
  [0x1da00, 0x1da36, 0],
  [0x1da3b, 0x1da6c, 0],
  [0x1da75, 0x1da75, 0],
  [0x1da84, 0x1da84, 0],
  [0x1da9b, 0x1da9f, 0],
  [0x1daa1, 0x1daaf, 0],
  
  ######################## # Unicode::GCString
  # [0x1e000, 0x1e006, 0], # -> 1
  # [0x1e008, 0x1e018, 0], # -> 1
  # [0x1e01b, 0x1e021, 0], # -> 1
  # [0x1e023, 0x1e024, 0], # -> 1
  # [0x1e026, 0x1e02a, 0], # -> 1
  ########################
  
  [0x1e8d0, 0x1e8d6, 0],
  
  ######################## # Unicode::GCString
  # [0x1e944, 0x1e94a, 0], # -> 1
  ########################
  
  [0x1f004, 0x1f004, 2],
  [0x1f0cf, 0x1f0cf, 2],
  #[0x1f100, 0x1f10a, 1],
  #[0x1f110, 0x1f12d, 1],
  #[0x1f130, 0x1f169, 1],
  #[0x1f170, 0x1f18d, 1],
  [0x1f18e, 0x1f18e, 2],
  #[0x1f18f, 0x1f190, 1],
  [0x1f191, 0x1f19a, 2],
  #[0x1f19b, 0x1f1ac, 1],
  [0x1f200, 0x1f202, 2],
  [0x1f210, 0x1f23b, 2],
  [0x1f240, 0x1f248, 2],
  [0x1f250, 0x1f251, 2],
  [0x1f260, 0x1f265, 2],
  [0x1f300, 0x1f320, 2],
  [0x1f32d, 0x1f335, 2],
  [0x1f337, 0x1f37c, 2],
  [0x1f37e, 0x1f393, 2],
  [0x1f3a0, 0x1f3ca, 2],
  [0x1f3cf, 0x1f3d3, 2],
  [0x1f3e0, 0x1f3f0, 2],
  [0x1f3f4, 0x1f3f4, 2],
  [0x1f3f8, 0x1f43e, 2],
  [0x1f440, 0x1f440, 2],
  [0x1f442, 0x1f4fc, 2],
  [0x1f4ff, 0x1f53d, 2],
  [0x1f54b, 0x1f54e, 2],
  [0x1f550, 0x1f567, 2],
  [0x1f57a, 0x1f57a, 2],
  [0x1f595, 0x1f596, 2],
  [0x1f5a4, 0x1f5a4, 2],
  [0x1f5fb, 0x1f64f, 2],
  [0x1f680, 0x1f6c5, 2],
  [0x1f6cc, 0x1f6cc, 2],
  [0x1f6d0, 0x1f6d2, 2],
  [0x1f6eb, 0x1f6ec, 2],
  [0x1f6f4, 0x1f6f8, 2],
  [0x1f910, 0x1f93e, 2],
  [0x1f940, 0x1f94c, 2],
  [0x1f950, 0x1f96b, 2],
  [0x1f980, 0x1f997, 2],
  [0x1f9c0, 0x1f9c0, 2],
  [0x1f9d0, 0x1f9e6, 2],
  [0x20000, 0x2fffd, 2],
  [0x30000, 0x3fffd, 2],
  [0xe0001, 0xe0001, 0],
  [0xe0020, 0xe007f, 0],
  [0xe0100, 0xe01ef, 0],
  #[0xf0000, 0xffffd, 1],
  #[0x100000, 0x10fffd, 1]
  ];
  
  
  my $cache = [];
  
  
  sub char_width {
      # $_[0] == ord $char
      my $min = 0;
      my $mid;
      my $max = $#$table;
      if ($_[0] < $table->[0][0] || $_[0] > $table->[$max][1] ) {
          return 1;
      }
      while ( $max >= $min ) {
          $mid = int( ( $min + $max) / 2 );
          if ( $_[0] > $table->[$mid][1] ) {
              $min = $mid + 1;
          }
          elsif ( $_[0] < $table->[$mid][0] ) {
              $max = $mid - 1;
          }
          else {
              return $table->[$mid][2];
          }
      }
      return 1;
  }
  
  
  sub print_columns {
      # $_[0] == string
      my $width = 0;
      for my $i ( 0 .. ( length( $_[0] ) - 1 ) ) {
          my $c = ord substr $_[0], $i, 1;
          if ( ! defined $cache->[$c] ) {
              $cache->[$c] = char_width( $c )
          }
          $width = $width + $cache->[$c];
      }
      return $width;
  }
  
  
  sub cut_to_printwidth {
      # $_[0] == string
      # $_[1] == available width
      # $_[2] == return the rest (yes/no)
      my $count = 0;
      my $total = 0;
      for my $i ( 0 .. ( length( $_[0] ) - 1 ) ) {
          my $c = ord substr $_[0], $i, 1;
          if ( ! defined $cache->[$c] ) {
              $cache->[$c] = char_width( $c )
          }
          if ( ( $total = $total + $cache->[$c] ) > $_[1] ) {
              if ( $cache->[$c] == 1 ) {
                  return substr( $_[0], 0, $count ), substr( $_[0], $count ) if $_[2];
                  return substr( $_[0], 0, $count );
              }
              return substr( $_[0], 0, $count ) . ' ', substr( $_[0], $count ) if $_[2];
              return substr( $_[0], 0, $count ) . ' ';
          }
          ++$count;
      }
      return $_[0], '' if $_[2];
      return $_[0];
  }
  
  
  sub line_fold {
      my ( $string, $avail_width, $init_tab, $subseq_tab ) = @_; #copy
      # return if ! length $string;
      for ( $init_tab, $subseq_tab ) {
          if ( $_ ) {
              s/\s/ /g;
              s/\p{C}//g;
              if ( length > $avail_width / 4 ) {
                  $_ = cut_to_printwidth( $_, int( $avail_width / 2 ) );
              }
          }
          else {
              $_ = '';
          }
      }
      $string =~ s/[^\n\P{Space}]/ /g;
      $string =~ s/[^\n\P{C}]//g;
      if ( $string !~ /\n/ && print_columns( $init_tab . $string ) <= $avail_width ) {
          return $init_tab . $string;
      }
      my @paragraph;
  
      for my $row ( split "\n", $string, -1 ) { # -1 to keep trailing empty fields
          my @lines;
          $row =~ s/\s+\z//;
          my @words = split( /(?<=\S)(?=\s)/, $row );
          my $line = $init_tab;
  
          for my $i ( 0 .. $#words ) {
              if ( print_columns( $line . $words[$i] ) <= $avail_width ) {
                  $line .= $words[$i];
              }
              else {
                  my $tmp;
                  if ( $i == 0 ) {
                      $tmp = $init_tab . $words[$i];;
                  }
                  else {
                      push( @lines, $line );
                      $words[$i] =~ s/^\s+//;
                      $tmp = $subseq_tab . $words[$i];
                  }
                  ( $line, my $remainder ) = cut_to_printwidth( $tmp, $avail_width, 1 );
                  while ( length $remainder ) {
                      push( @lines, $line );
                      $tmp = $subseq_tab . $remainder;
                      ( $line, $remainder ) = cut_to_printwidth( $tmp, $avail_width, 1 );
                  }
              }
              if ( $i == $#words ) {
                  push( @lines, $line );
              }
          }
          push( @paragraph, join( "\n", @lines ) );
      }
      return join( "\n", @paragraph );
  }
  
  
  
  
  
  
  
  
  
  
  
  
  1;
TERM_CHOOSE_LINEFOLD

$fatpacked{"Term/Choose/Linux.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_CHOOSE_LINUX';
  package Term::Choose::Linux;
  
  use warnings;
  use strict;
  use 5.008003;
  
  our $VERSION = '1.600';
  
  use Term::ReadKey qw( GetTerminalSize ReadKey ReadMode );
  
  use Term::Choose::Constants qw( :linux );
  
  
  
  sub new {
      return bless {}, $_[0];
  }
  
  
  sub __get_key_OS {
      my ( $self, $mouse ) = @_;
      my $c1 = ReadKey( 0 );
      return if ! defined $c1;
      if ( $c1 eq "\e" ) {
          my $c2 = ReadKey( 0.10 );
          if    ( ! defined $c2 ) { return KEY_ESC; } # unused
          #elsif ( $c3 eq 'A' ) { return VK_UP; }     vt 52
          #elsif ( $c3 eq 'B' ) { return VK_DOWN; }
          #elsif ( $c3 eq 'C' ) { return VK_RIGHT; }
          #elsif ( $c3 eq 'D' ) { return VK_LEFT; }
          #elsif ( $c3 eq 'H' ) { return VK_HOME; }
           elsif ( $c2 eq 'O' ) {
              my $c3 = ReadKey( 0 );
              if    ( $c3 eq 'A' ) { return VK_UP; }
              elsif ( $c3 eq 'B' ) { return VK_DOWN; }
              elsif ( $c3 eq 'C' ) { return VK_RIGHT; }
              elsif ( $c3 eq 'D' ) { return VK_LEFT; }
              elsif ( $c3 eq 'F' ) { return VK_END; }
              elsif ( $c3 eq 'H' ) { return VK_HOME; }
              elsif ( $c3 eq 'Z' ) { return KEY_BTAB; }
              else {
                  return NEXT_get_key;
              }
          }
          elsif ( $c2 eq '[' ) {
              my $c3 = ReadKey( 0 );
              if    ( $c3 eq 'A' ) { return VK_UP; }
              elsif ( $c3 eq 'B' ) { return VK_DOWN; }
              elsif ( $c3 eq 'C' ) { return VK_RIGHT; }
              elsif ( $c3 eq 'D' ) { return VK_LEFT; }
              elsif ( $c3 eq 'F' ) { return VK_END; }
              elsif ( $c3 eq 'H' ) { return VK_HOME; }
              elsif ( $c3 eq 'Z' ) { return KEY_BTAB; }
              elsif ( $c3 =~ m/^[0-9]$/ ) {
                  my $c4 = ReadKey( 0 );
                  if ( $c4 eq '~' ) {
                      if    ( $c3 eq '2' ) { return VK_INSERT; } # unused
                      elsif ( $c3 eq '3' ) { return VK_DELETE; } # unused
                      elsif ( $c3 eq '5' ) { return VK_PAGE_UP; }
                      elsif ( $c3 eq '6' ) { return VK_PAGE_DOWN; }
                      else {
                          return NEXT_get_key;
                      }
                  }
                  elsif ( $c4 =~ m/^[;0-9]$/ ) { # response to "\e[6n"
                      my $abs_curs_y = $c3;
                      my $ry = $c4;
                      while ( $ry =~ m/^[0-9]$/ ) {
                          $abs_curs_y .= $ry;
                          $ry = ReadKey( 0 );
                      }
                      return NEXT_get_key if $ry ne ';';
                      my $abs_curs_x = '';
                      my $rx = ReadKey( 0 );
                      while ( $rx =~ m/^[0-9]$/ ) {
                          $abs_curs_x .= $rx;
                          $rx = ReadKey( 0 );
                      }
                      if ( $rx eq 'R' ) {
                          #$self->{abs_cursor_x} = $abs_curs_x; # unused
                          $self->{abs_cursor_y} = $abs_curs_y;
                      }
                      return NEXT_get_key;
                  }
                  else {
                      return NEXT_get_key;
                  }
              }
              # http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
              elsif ( $c3 eq 'M' && $mouse ) {
                  my $event_type = ord( ReadKey( 0 ) ) - 32;
                  my $x          = ord( ReadKey( 0 ) ) - 32;
                  my $y          = ord( ReadKey( 0 ) ) - 32;
                  my $button = $self->__mouse_event_to_button( $event_type );
                  return NEXT_get_key if $button == NEXT_get_key;
                  return [ $self->{abs_cursor_y}, $button, $x, $y ];
              }
              elsif ( $c3 eq '<' && $mouse ) {  # SGR 1006
                  my $event_type = '';
                  my $m1;
                  while ( ( $m1 = ReadKey( 0 ) ) =~ m/^[0-9]$/ ) {
                      $event_type .= $m1;
                  }
                  return NEXT_get_key if $m1 ne ';';
                  my $x = '';
                  my $m2;
                  while ( ( $m2 = ReadKey( 0 ) ) =~ m/^[0-9]$/ ) {
                      $x .= $m2;
                  }
                  return NEXT_get_key if $m2 ne ';';
                  my $y = '';
                  my $m3;
                  while ( ( $m3 = ReadKey( 0 ) ) =~ m/^[0-9]$/ ) {
                      $y .= $m3;
                  }
                  return NEXT_get_key if $m3 !~ m/^[mM]$/;
                  my $button_released = $m3 eq 'm' ? 1 : 0;
                  return NEXT_get_key if $button_released;
                  my $button = $self->__mouse_event_to_button( $event_type );
                  return NEXT_get_key if $button == NEXT_get_key;
                  return [ $self->{abs_cursor_y}, $button, $x, $y ];
              }
              else {
                  return NEXT_get_key;
              }
          }
          else {
              return NEXT_get_key;
          }
      }
      else {
          return ord $c1;
      }
  };
  
  
  sub __mouse_event_to_button {
      my ( $self, $event_type ) = @_;
      my $button_drag = ( $event_type & 0x20 ) >> 5;
      return NEXT_get_key if $button_drag;
      my $button;
      my $low_2_bits = $event_type & 0x03;
      if ( $low_2_bits == 3 ) {
          $button = 0;
      }
      else {
          if ( $event_type & 0x40 ) {
              $button = $low_2_bits + 4; # 4,5
          }
          else {
              $button = $low_2_bits + 1; # 1,2,3
          }
      }
      return $button;
  }
  
  
  sub __set_mode {
      my ( $self, $mouse, $hide_cursor ) = @_;
      if ( $mouse ) {
          if ( $mouse == 3 ) {
              my $return = binmode STDIN, ':utf8';
              if ( $return ) {
                  print SET_ANY_EVENT_MOUSE_1003;
                  print SET_EXT_MODE_MOUSE_1005;
              }
              else {
                  $mouse = 0;
                  warn "binmode STDIN, :utf8: $!\n";
                  warn "mouse-mode disabled\n";
              }
          }
          elsif ( $mouse == 4 ) {
              my $return = binmode STDIN, ':raw';
              if ( $return ) {
                  print SET_ANY_EVENT_MOUSE_1003;
                  print SET_SGR_EXT_MODE_MOUSE_1006;
              }
              else {
                  $mouse = 0;
                  warn "binmode STDIN, :raw: $!\n";
                  warn "mouse-mode disabled\n";
              }
          }
          else {
              my $return = binmode STDIN, ':raw';
              if ( $return ) {
                  print SET_ANY_EVENT_MOUSE_1003;
              }
              else {
                  $mouse = 0;
                  warn "binmode STDIN, :raw: $!\n";
                  warn "mouse-mode disabled\n";
              }
          }
      }
      Term::ReadKey::ReadMode( 'ultra-raw' );
      print HIDE_CURSOR if $hide_cursor;
      return $mouse;
  };
  
  
  sub __reset_mode {
      my ( $self, $mouse, $hide_cursor ) = @_;
      print SHOW_CURSOR if $hide_cursor;
      if ( $mouse ) {
          binmode STDIN, ':encoding(UTF-8)' or warn "binmode STDIN, :encoding(UTF-8): $!\n";
          print UNSET_EXT_MODE_MOUSE_1005     if $mouse == 3;
          print UNSET_SGR_EXT_MODE_MOUSE_1006 if $mouse == 4;
          print UNSET_ANY_EVENT_MOUSE_1003;
      }
      $self->__reset();
      Term::ReadKey::ReadMode( 'restore' );
  }
  
  
  sub __get_term_size {
      #my ( $self ) = @_;
      my ( $width, $height ) = ( GetTerminalSize() )[ 0, 1 ];
      return $width - WIDTH_CURSOR, $height;
      # $width - WIDTH_CURSOR: don't let items reach the right edge of the terminal;
      #                        selecting an item which reaches the right edge of the terminal
      #                        messes up the output - maybe because the (hidden) terminal-cursor needs a space
  }
  
  
  sub __get_cursor_position {
      my ( $self ) = @_;
      #$self->{abs_cursor_x} = 0; # unused
      $self->{abs_cursor_y} = 0;
      print GET_CURSOR_POSITION;
  }
  
  
  sub __clear_screen {
      #my ( $self ) = @_;
      print CLEAR_SCREEN;
  }
  
  
  sub __clear_to_end_of_screen {
      #my ( $self ) = @_;
      print CLEAR_TO_END_OF_SCREEN;
  }
  
  
  sub __bold_underline {
      #my ( $self ) = @_;
      print BOLD_UNDERLINE;
  }
  
  
  sub __reverse {
      #my ( $self ) = @_;
      print REVERSE;
  }
  
  
  sub __reset {
      #my ( $self ) = @_;
      print RESET;
  }
  
  
  sub __up {
      #my ( $self ) = @_;
      print "\e[${_[1]}A";
  }
  
  
  sub __left {
      #my ( $self ) = @_;
      print "\e[${_[1]}D";
  }
  
  
  sub __right {
      #my ( $self ) = @_;
      print "\e[${_[1]}C";
  }
  
  
  1;
  
  __END__
TERM_CHOOSE_LINUX

$fatpacked{"Term/Choose/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_CHOOSE_WIN32';
  package Term::Choose::Win32;
  
  use warnings;
  use strict;
  use 5.008003;
  
  our $VERSION = '1.600';
  
  use Win32::Console qw( STD_INPUT_HANDLE ENABLE_MOUSE_INPUT ENABLE_PROCESSED_INPUT STD_OUTPUT_HANDLE
                         RIGHT_ALT_PRESSED LEFT_ALT_PRESSED RIGHT_CTRL_PRESSED LEFT_CTRL_PRESSED SHIFT_PRESSED
                         FOREGROUND_INTENSITY BACKGROUND_INTENSITY );
  
  use Term::Choose::Constants qw( :win32 );
  
  
  sub SHIFTED_MASK () {
        RIGHT_ALT_PRESSED
      | LEFT_ALT_PRESSED
      | RIGHT_CTRL_PRESSED
      | LEFT_CTRL_PRESSED
      | SHIFT_PRESSED
  }
  
  
  
  sub new {
      return bless {}, $_[0];
  }
  
  
  sub __get_key_OS {
      my ( $self, $mouse ) = @_;
      my @event = $self->{input}->Input;
      my $event_type = shift @event;
      return NEXT_get_key if ! defined $event_type;
      if ( $event_type == 1 ) {
          my ( $key_down, $repeat_count, $v_key_code, $v_scan_code, $char, $ctrl_key_state ) = @event;
          return NEXT_get_key if ! $key_down;
          if ( $char ) {
              if ( $char == 32 && $ctrl_key_state & ( RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED ) ) {
                  return CONTROL_SPACE;
              }
              else {
                  return $char;
              }
          }
          else{
              if ( $ctrl_key_state & SHIFTED_MASK ) {
                  return NEXT_get_key;
              }
              elsif ( $v_key_code == VK_PAGE_UP )   { return VK_PAGE_UP }
              elsif ( $v_key_code == VK_PAGE_DOWN ) { return VK_PAGE_DOWN }
              elsif ( $v_key_code == VK_END )       { return VK_END }
              elsif ( $v_key_code == VK_HOME )      { return VK_HOME }
              elsif ( $v_key_code == VK_LEFT )      { return VK_LEFT }
              elsif ( $v_key_code == VK_UP )        { return VK_UP }
              elsif ( $v_key_code == VK_RIGHT )     { return VK_RIGHT }
              elsif ( $v_key_code == VK_DOWN )      { return VK_DOWN }
              elsif ( $v_key_code == VK_INSERT )    { return VK_INSERT } # unused
              elsif ( $v_key_code == VK_DELETE )    { return VK_DELETE } # unused
              else                                  { return NEXT_get_key }
          }
      }
      elsif ( $mouse && $event_type == 2 ) {
          my( $x, $y, $button_state, $control_key, $event_flags ) = @event;
          my $button;
          if ( ! $event_flags ) {
              if ( $button_state & LEFTMOST_BUTTON_PRESSED ) {
                  $button = 1;
              }
              elsif ( $button_state & RIGHTMOST_BUTTON_PRESSED ) {
                  $button = 3;
              }
              elsif ( $button_state & FROM_LEFT_2ND_BUTTON_PRESSED ) {
                  $button = 2;
              }
              else {
                  return NEXT_get_key;
              }
          }
          elsif ( $event_flags & MOUSE_WHEELED ) {
              $button = $button_state >> 24 ? 5 : 4;
          }
          else {
              return NEXT_get_key;
          }
          return [ $self->{abs_cursor_y}, $button, $x, $y ];
      }
      else {
          return NEXT_get_key;
      }
  }
  
  
  sub __set_mode {
      my ( $self, $mouse, $hide_cursor ) = @_;
      $self->{input} = Win32::Console->new( STD_INPUT_HANDLE );
      $self->{old_in_mode} = $self->{input}->Mode();
      $self->{input}->Mode( !ENABLE_PROCESSED_INPUT )                    if ! $mouse;
      $self->{input}->Mode( !ENABLE_PROCESSED_INPUT|ENABLE_MOUSE_INPUT ) if   $mouse;
      $self->{output} = Win32::Console->new( STD_OUTPUT_HANDLE );
      $self->{def_attr} = $self->{output}->Attr();
      $self->{fg_color} = $self->{def_attr} & 0x7;
      $self->{bg_color} = $self->{def_attr} & 0x70;
      $self->{inverse}  = ( $self->{bg_color} >> 4 ) | ( $self->{fg_color} << 4 );
      $self->{output}->Cursor( -1, -1, -1, 0 ) if $hide_cursor;
      return $mouse;
  }
  
  
  sub __reset_mode {
      my ( $self, $mouse, $hide_cursor ) = @_;  # no use for $mouse on win32
      if ( defined $self->{input} ) {
          if ( defined $self->{old_in_mode} ) {
              $self->{input}->Mode( $self->{old_in_mode} );
              delete $self->{old_in_mode};
          }
          $self->{input}->Flush;
          # workaround Bug #33513:
          delete $self->{input}{handle};
          #
      }
      if ( defined $self->{output} ) {
          $self->__reset;
          $self->{output}->Cursor( -1, -1, -1, 1 ) if $hide_cursor;
          #$self->{output}->Free();
          delete $self->{output}{handle}; # ?
      }
  }
  
  
  sub __get_term_size {
      my ( $self ) = @_;
      my ( $term_width, $term_height ) = Win32::Console->new()->Size();
      return $term_width - 1, $term_height;
  }
  
  
  sub __get_cursor_position {
      my ( $self ) = @_;
      ( $self->{abs_cursor_x}, $self->{abs_cursor_y} ) = $self->{output}->Cursor();
  }
  
  sub __set_cursor_position {
      my ( $self, $col, $row ) = @_;
      $self->{output}->Cursor( $col, $row );
  }
  
  
  sub __clear_screen {
      my ( $self ) = @_;
      $self->{output}->Cls( $self->{def_attr} );
  }
  
  
  sub __clear_to_end_of_screen {
      my ( $self ) = @_;
      my ( $width, $height ) = $self->{output}->Size();
      $self->__get_cursor_position();
      $self->{output}->FillAttr(
              $self->{bg_color} | $self->{bg_color},
              $width * $height,
              $self->{abs_cursor_x}, $self->{abs_cursor_y} );
  }
  
  
  sub __bold_underline {
      my ( $self ) = @_;
      $self->{output}->Attr( $self->{def_attr} | FOREGROUND_INTENSITY | BACKGROUND_INTENSITY  );
  }
  
  
  sub __reverse {
      my ( $self ) = @_;
      $self->{output}->Attr( $self->{inverse} );
  }
  
  
  sub __reset {
      my ( $self ) = @_;
      $self->{output}->Attr( $self->{def_attr} );
  }
  
  
  sub __up {
      #my ( $self, $rows_up ) = @_;
      my ( $col, $row ) = $_[0]->__get_cursor_position;
      $_[0]->__set_cursor_position( $col, $row - $_[1] );
  }
  
  sub __left {
      #my ( $self, $cols_left ) = @_;
      my ( $col, $row ) = $_[0]->__get_cursor_position;
      $_[0]->__set_cursor_position( $col - $_[1], $row );
  }
  
  sub __right {
      #my ( $self, $cols_right ) = @_;
      my ( $col, $row ) = $_[0]->__get_cursor_position;
      $_[0]->__set_cursor_position( $col + $_[1], $row );
  }
  
  1;
  
  __END__
TERM_CHOOSE_WIN32

$fatpacked{"darwin-2level/Mac/SystemDirectory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MAC_SYSTEMDIRECTORY';
  package Mac::SystemDirectory; # git description: v0.09-2-g9008eff
  # ABSTRACT: Locate Mac OS X Standard System Directories
  
  use 5.006000;
  use strict;
  use warnings;
  
  our $VERSION = '0.10';
  
  our @EXPORT_OK   = ('FindDirectory', 'HomeDirectory', 'TemporaryDirectory');
  
  require XSLoader;
  XSLoader::load('Mac::SystemDirectory', $VERSION);
  
  our %EXPORT_TAGS = (
      'all'        => [ @EXPORT_OK ],
      'DomainMask' => [ grep { /^NS.*DomainMask/ } @EXPORT_OK ],
      'Directory'  => [ grep { /^NS.*Directory/  } @EXPORT_OK ],
  );
  
  require Exporter;
  *import = \&Exporter::import;
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Mac::SystemDirectory - Locate Mac OS X Standard System Directories
  
  =head1 VERSION
  
  version 0.10
  
  =head1 SYNOPSIS
  
    use Mac::SystemDirectory qw[:all];
    
    $path = FindDirectory(NSDocumentDirectory);
    $path = HomeDirectory();
    $path = TemporaryDirectory();
  
  =head1 DESCRIPTION
  
  Locate Mac OS X Standard System Directories
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item FindDirectory(Directory [, DomainMask])
  
  Creates a list of path strings for the specified directories in the specified 
  domains. The list is in the order in which you should search the directories.
  
  I<Usage>
  
      $path  = FindDirectory(NSApplicationDirectory);
      @paths = FindDirectory(NSApplicationDirectory);
  
  I<Arguments>
  
  =over 4
  
  =item Directory
  
  L</Directory> constant.
  
  =item DomainMask (optional)
  
  L</DomainMask> constant. Defaults to C<NSUserDomainMask>.
  
  =back
  
  I<Returns>
  
  When called in scalar context this function returns the first matching 
  directory. In list context it returns all matching directories.
  If no directories are found, undef is returned in a scalar context and an 
  empty list in a list context.
  
  =item HomeDirectory()
  
  Path to the current user's home directory.
  
  I<Usage>
  
      $path = HomeDirectory();
  
  I<Returns>
  
  A string containing the path of the current user's home directory.
  
  =item TemporaryDirectory()
  
  Path to the current user's temporary directory.
  
  I<Usage>
  
      $path = TemporaryDirectory();
  
  I<Returns>
  
  A string containing the path of the temporary directory for the current user. 
  If no such directory is currently available, returns undef.
  
  =back
  
  =head1 CONSTANTS
  
  =head2 DomainMask
  
  Bitmask constants that identify the file-system domain (User, System, Local, Network) or all domains.
  
  =over 4
  
  =item NSUserDomainMask
  
  The user's home directory-the place to install user's personal items (~).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSLocalDomainMask
  
  Local to the current machine-the place to install items available to everyone on this machine.
  
  Available in Mac OS X v10.0 and later.
  
  =item NSNetworkDomainMask
  
  Publicly available location in the local area network-the place to install items available on the network (/Network).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSSystemDomainMask
  
  Provided by Apple - can't be modified (/System).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSAllDomainsMask
  
  All domains. Includes all of the above and future items.
  
  Available in Mac OS X v10.0 and later.
  
  =back
  
  =head2 Directory
  
  Constants that identify the name or type of directory (for example, Library, Documents, or Applications).
  
  =over 4
  
  =item NSApplicationDirectory
  
  Supported applications (/Applications).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSDemoApplicationDirectory
  
  Unsupported applications and demonstration versions.
  
  Available in Mac OS X v10.0 and later.
  
  =item NSDeveloperApplicationDirectory
  
  Developer applications (/Developer/Applications).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSAdminApplicationDirectory
  
  System and network administration applications.
  
  Available in Mac OS X v10.0 and later.
  
  =item NSLibraryDirectory
  
  Various user-visible documentation, support, and configuration files (/Library).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSDeveloperDirectory
  
  Developer resources (/Developer).
  Deprecated: Beginning with Xcode 3.0, developer tools can be installed in any location.
  
  Available in Mac OS X v10.0 and later.
  
  =item NSUserDirectory
  
  User home directories (/Users).
  
  Available in Mac OS X v10.0 and later.
  
  =item NSDocumentationDirectory
  
  Documentation.
  
  Available in Mac OS X v10.0 and later.
  
  =item NSDocumentDirectory
  
  Document directory.
  
  Available in Mac OS X v10.2 and later.
  
  =item NSCoreServiceDirectory
  
  Location of core services (System/Library/CoreServices).
  
  Available in Mac OS X v10.4 and later.
  
  =item NSAutosavedInformationDirectory
  
  Location of user's autosaved documents Documents/Autosaved
  
  Available in Mac OS X v10.6 and later.
  
  =item NSDesktopDirectory
  
  Location of user's desktop directory.
  
  Available in Mac OS X v10.4 and later.
  
  =item NSCachesDirectory
  
  Location of discardable cache files (Library/Caches).
  
  Available in Mac OS X v10.4 and later.
  
  =item NSApplicationSupportDirectory
  
  Location of application support files (Library/Application Support).
  
  Available in Mac OS X v10.4 and later.
  
  =item NSDownloadsDirectory
  
  Location of the user's downloads directory.
  
  Available in Mac OS X v10.5 and later.
  
  =item NSInputMethodsDirectory
  
  Location of Input Methods (Library/Input Methods)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSMoviesDirectory
  
  Location of user's Movies directory (~/Movies)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSMusicDirectory
  
  Location of user's Movies directory (~/Music)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSPicturesDirectory
  
  Location of user's Movies directory (~/Pictures)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSPrinterDescriptionDirectory
  
  Location of system's PPDs directory (Library/Printers/PPDs)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSSharedPublicDirectory
  
  Location of user's Public sharing directory (~/Public)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSPreferencePanesDirectory
  
  Location of the PreferencePanes directory for use with System Preferences (Library/PreferencePanes)
  
  Available in Mac OS X v10.6 and later.
  
  =item NSItemReplacementDirectory
  
  For use with NSFileManager method URLForDirectory:inDomain:appropriateForURL:create:error:
  
  Available in Mac OS X v10.6 and later.
  
  =item NSAllApplicationsDirectory
  
  All directories where applications can occur.
  
  Available in Mac OS X v10.0 and later.
  
  =item NSAllLibrariesDirectory
  
  All directories where resources can occur.
  
  Available in Mac OS X v10.0 and later.
  
  =back
  
  =head1 EXPORT
  
  None by default. Functions and constants can either be imported individually or
  in sets grouped by tag names. The tag names are:
  
  =over 4
  
  =item C<:all> exports all functions and constants.
  
  =item C<:DomainMask> exports all L</DomainMask> constants.
  
  =item C<:Directory> exports all L</Directory> constants.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://developer.apple.com/mac/library/DOCUMENTATION/Cocoa/Conceptual/LowLevelFileMgmt/Articles/StandardDirectories.html>
  L<http://developer.apple.com/mac/library/documentation/MacOSX/Conceptual/BPFileSystem/BPFileSystem.html>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Mac-SystemDirectory>
  (or L<bug-Mac-SystemDirectory@rt.cpan.org|mailto:bug-Mac-SystemDirectory@rt.cpan.org>).
  
  =head1 AUTHOR
  
  Christian Hansen <chansen@cpan.org>
  
  =head1 CONTRIBUTOR
  
  =for stopwords Karen Etheridge
  
  Karen Etheridge <ether@cpan.org>
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2009 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MAC_SYSTEMDIRECTORY

$fatpacked{"darwin-2level/Term/ReadKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_TERM_READKEY';
  # -*- buffer-read-only: t -*-
  #
  # This file is auto-generated. ***ANY*** changes here will be lost
  #
  package Term::ReadKey;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  Term::ReadKey - A perl module for simple terminal control
  
  =head1 SYNOPSIS
  
      use Term::ReadKey;
      ReadMode 4; # Turn off controls keys
      while (not defined ($key = ReadKey(-1))) {
          # No key yet
      }
      print "Get key $key\n";
      ReadMode 0; # Reset tty mode before exiting
  
  =head1 DESCRIPTION
  
  Term::ReadKey is a compiled perl module dedicated to providing simple
  control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
  non-blocking reads, if the architecture allows, and some generalized handy
  functions for working with terminals. One of the main goals is to have the
  functions as portable as possible, so you can just plug in "use
  Term::ReadKey" on any architecture and have a good likelihood of it working.
  
  Version 2.30.01:
  Added handling of arrows, page up/down, home/end, insert/delete keys 
  under Win32. These keys emit xterm-compatible sequences.
  Works with Term::ReadLine::Perl.
  
  =over 4
  
  =item ReadMode MODE [, Filehandle]
  
  Takes an integer argument or a string synonym (case insensitive), which
  can currently be one of the following values:
  
      INT   SYNONYM    DESCRIPTION
  
      0    'restore'   Restore original settings.
  
      1    'normal'    Change to what is commonly the default mode,
                       echo on, buffered, signals enabled, Xon/Xoff
                       possibly enabled, and 8-bit mode possibly disabled.
  
      2    'noecho'    Same as 1, just with echo off. Nice for
                       reading passwords.
  
      3    'cbreak'    Echo off, unbuffered, signals enabled, Xon/Xoff
                       possibly enabled, and 8-bit mode possibly enabled.
  
      4    'raw'       Echo off, unbuffered, signals disabled, Xon/Xoff
                       disabled, and 8-bit mode possibly disabled.
  
      5    'ultra-raw' Echo off, unbuffered, signals disabled, Xon/Xoff 
                       disabled, 8-bit mode enabled if parity permits,
                       and CR to CR/LF translation turned off. 
  
  
  These functions are automatically applied to the STDIN handle if no
  other handle is supplied. Modes 0 and 5 have some special properties
  worth mentioning: not only will mode 0 restore original settings, but it
  cause the next ReadMode call to save a new set of default settings. Mode
  5 is similar to mode 4, except no CR/LF translation is performed, and if
  possible, parity will be disabled (only if not being used by the terminal,
  however. It is no different from mode 4 under Windows.)
  
  If you just need to read a key at a time, then modes 3 or 4 are probably
  sufficient. Mode 4 is a tad more flexible, but needs a bit more work to
  control. If you use ReadMode 3, then you should install a SIGINT or END
  handler to reset the terminal (via ReadMode 0) if the user aborts the
  program via C<^C>. (For any mode, an END handler consisting of "ReadMode 0"
  is actually a good idea.)
  
  If you are executing another program that may be changing the terminal mode,
  you will either want to say
  
      ReadMode 1;             # same as ReadMode 'normal'
      system('someprogram');
      ReadMode 1;
  
  which resets the settings after the program has run, or:
  
      $somemode=1;
      ReadMode 0;             # same as ReadMode 'restore'
      system('someprogram');
      ReadMode 1;
  
  which records any changes the program may have made, before resetting the
  mode.
  
  =item ReadKey MODE [, Filehandle]
  
  Takes an integer argument, which can currently be one of the following 
  values:
  
      0    Perform a normal read using getc
      -1   Perform a non-blocked read
      >0	 Perform a timed read
  
  If the filehandle is not supplied, it will default to STDIN. If there is
  nothing waiting in the buffer during a non-blocked read, then undef will be
  returned.  In most situations, you will probably want to use C<ReadKey -1>.
  
  I<NOTE> that if the OS does not provide any known mechanism for non-blocking
  reads, then a C<ReadKey -1> can die with a fatal error. This will hopefully
  not be common.
  
  If MODE is greater then zero, then ReadKey will use it as a timeout value in
  seconds (fractional seconds are allowed), and won't return C<undef> until
  that time expires.
  
  I<NOTE>, again, that some OS's may not support this timeout behaviour.
  
  If MODE is less then zero, then this is treated as a timeout
  of zero, and thus will return immediately if no character is waiting. A MODE
  of zero, however, will act like a normal getc.
  
  I<NOTE>, there are currently some limitations with this call under Windows.
  It may be possible that non-blocking reads will fail when reading repeating
  keys from more then one console.
  
  
  =item ReadLine MODE [, Filehandle]
  
  Takes an integer argument, which can currently be one of the following 
  values:
  
      0    Perform a normal read using scalar(<FileHandle>)
      -1   Perform a non-blocked read
      >0	 Perform a timed read
  
  If there is nothing waiting in the buffer during a non-blocked read, then
  undef will be returned.
  
  I<NOTE>, that if the OS does not provide any known mechanism for
  non-blocking reads, then a C<ReadLine 1> can die with a fatal
  error. This will hopefully not be common.
  
  I<NOTE> that a non-blocking test is only performed for the first character
  in the line, not the entire line.  This call will probably B<not> do what
  you assume, especially with C<ReadMode> MODE values higher then 1. For
  example, pressing Space and then Backspace would appear to leave you
  where you started, but any timeouts would now be suspended.
  
  B<This call is currently not available under Windows>.
  
  =item GetTerminalSize [Filehandle]
  
  Returns either an empty array if this operation is unsupported, or a four
  element array containing: the width of the terminal in characters, the
  height of the terminal in character, the width in pixels, and the height in
  pixels. (The pixel size will only be valid in some environments.)
  
  I<NOTE>, under Windows, this function must be called with an B<output>
  filehandle, such as C<STDOUT>, or a handle opened to C<CONOUT$>.
  
  =item SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]
  
  Return -1 on failure, 0 otherwise.
  
  I<NOTE> that this terminal size is only for B<informative> value, and
  changing the size via this mechanism will B<not> change the size of
  the screen. For example, XTerm uses a call like this when
  it resizes the screen. If any of the new measurements vary from the old, the
  OS will probably send a SIGWINCH signal to anything reading that tty or pty.
  
  B<This call does not work under Windows>.
  
  =item GetSpeed [, Filehandle]
  
  Returns either an empty array if the operation is unsupported, or a two
  value array containing the terminal in and out speeds, in B<decimal>. E.g,
  an in speed of 9600 baud and an out speed of 4800 baud would be returned as
  (9600,4800). Note that currently the in and out speeds will always be
  identical in some OS's.
  
  B<No speeds are reported under Windows>.
  
  =item GetControlChars [, Filehandle]
  
  Returns an array containing key/value pairs suitable for a hash. The pairs
  consist of a key, the name of the control character/signal, and the value
  of that character, as a single character.
  
  B<This call does nothing under Windows>.
  
  Each key will be an entry from the following list:
  
  	DISCARD
  	DSUSPEND
  	EOF
  	EOL
  	EOL2
  	ERASE
  	ERASEWORD
  	INTERRUPT
  	KILL
  	MIN
  	QUIT
  	QUOTENEXT
  	REPRINT
  	START
  	STATUS
  	STOP
  	SUSPEND
  	SWITCH
  	TIME
  
  Thus, the following will always return the current interrupt character,
  regardless of platform.
  
  	%keys = GetControlChars;
  	$int = $keys{INTERRUPT};
  
  =item SetControlChars [, Filehandle]
  
  Takes an array containing key/value pairs, as a hash will produce. The pairs
  should consist of a key that is the name of a legal control
  character/signal, and the value should be either a single character, or a
  number in the range 0-255. SetControlChars will die with a runtime error if
  an invalid character name is passed or there is an error changing the
  settings. The list of valid names is easily available via
  
  	%cchars = GetControlChars();
  	@cnames = keys %cchars;
  
  B<This call does nothing under Windows>.
  
  =back
  
  =head1 AUTHOR
  
  Kenneth Albanowski <kjahds@kjahds.com>
  
  Currently maintained by Jonathan Stowe <jns@gellyfish.co.uk>
  
  =head1 SUPPORT
  
  The code is maintained at 
  
       https://github.com/jonathanstowe/TermReadKey
  
  Please feel free to fork and suggest patches.
  
  
  =head1 LICENSE
  
  Prior to the 2.31 release the license statement was:
  
   Copyright (C) 1994-1999 Kenneth Albanowski.
                 2001-2005 Jonathan Stowe and others
  
                 Unlimited distribution and/or modification is allowed as long as this
                 copyright notice remains intact.
  
  And was only stated in the README file.
  
  Because I believe the original author's intent was to be more open than the
  other commonly used licenses I would like to leave that in place. However if
  you or your lawyers require something with some more words you can optionally
  choose to license this under the standard Perl license:
  
        This module is free software; you can redistribute it and/or modify it
        under the terms of the Artistic License. For details, see the full
        text of the license in the file "Artistic" that should have been provided
        with the version of perl you are using.
  
        This program is distributed in the hope that it will be useful, but
        without any warranty; without even the implied warranty of merchantability
        or fitness for a particular purpose.
  
  
  =cut
  
  use vars qw($VERSION);
  
  $VERSION = '2.37';
  
  require Exporter;
  require DynaLoader;
  
  use vars qw(@ISA @EXPORT_OK @EXPORT);
  
  @ISA = qw(Exporter DynaLoader);
  
  # Items to export into callers namespace by default
  # (move infrequently used names to @EXPORT_OK below)
  
  @EXPORT = qw(
    ReadKey
    ReadMode
    ReadLine
    GetTerminalSize
    SetTerminalSize
    GetSpeed
    GetControlChars
    SetControlChars
  );
  
  @EXPORT_OK = qw();
  
  bootstrap Term::ReadKey;
  
  # Should we use LINES and COLUMNS to try and get the terminal size?
  # Change this to zero if you have systems where these are commonly
  # set to erroneous values. (But if either are near zero, they won't be
  # used anyhow.)
  
  use vars qw($UseEnv $CurrentMode %modes);
  
  $UseEnv = 1;
  
  $CurrentMode = 0;
  
  %modes = (                            # lowercase is canonical
      original    => 0,
      restore     => 0,
      normal      => 1,
      noecho      => 2,
      cbreak      => 3,
      raw         => 4,
      'ultra-raw' => 5
  );
  
  # reduce Carp memory footprint, only load when needed
  sub croak { require Carp; goto &Carp::croak; }
  sub carp  { require Carp; goto &Carp::carp; }
  
  sub ReadMode
  {
      my $mode = $modes{ lc $_[0] };  # lowercase is canonical
      my $fh = normalizehandle( ( @_ > 1 ? $_[1] : \*STDIN ) );
  
      if ( defined($mode) )    { $CurrentMode = $mode }
      elsif ( $_[0] =~ /^\d/ ) { $CurrentMode = $_[0] }
      else                     { croak("Unknown terminal mode `$_[0]'"); }
  
      SetReadMode($CurrentMode, $fh);
  }
  
  sub normalizehandle
  {
      my ($file) = @_; # allows fake signature optimization
  
      no strict;
      #	print "Handle = $file\n";
      if ( ref($file) ) { return $file; }    # Reference is fine
  
      #	if ($file =~ /^\*/) { return $file; } # Type glob is good
      if ( ref( \$file ) eq 'GLOB' ) { return $file; }    # Glob is good
  
      #	print "Caller = ",(caller(1))[0],"\n";
      return \*{ ( ( caller(1) )[0] ) . "::$file" };
  }
  
  sub GetTerminalSize
  {
      my $file = normalizehandle( ( @_ > 0 ? $_[0] : \*STDOUT ) );
  
      my (@results, @fail);
  
      if ( &termsizeoptions() & 1 )                       # VIO
      {
          @results = GetTermSizeVIO($file);
          push( @fail, "VIOGetMode call" );
      }
      elsif ( &termsizeoptions() & 2 )                    # GWINSZ
      {
          @results = GetTermSizeGWINSZ($file);
          push( @fail, "TIOCGWINSZ ioctl" );
      }
      elsif ( &termsizeoptions() & 4 )                    # GSIZE
      {
          @results = GetTermSizeGSIZE($file);
          push( @fail, "TIOCGSIZE ioctl" );
      }
      elsif ( &termsizeoptions() & 8 )                    # WIN32
      {
          @results = GetTermSizeWin32($file);
          push( @fail, "Win32 GetConsoleScreenBufferInfo call" );
      }
      else
      {
          @results = ();
      }
  
      if ( @results < 4 and $UseEnv )
      {
          my ($C) = defined( $ENV{COLUMNS} ) ? $ENV{COLUMNS} : 0;
          my ($L) = defined( $ENV{LINES} )   ? $ENV{LINES}   : 0;
          if ( ( $C >= 2 ) and ( $L >= 2 ) )
          {
              @results = ( $C + 0, $L + 0, 0, 0 );
          }
          push( @fail, "COLUMNS and LINES environment variables" );
      }
  
      if ( @results < 4 && $^O ne 'MSWin32')
      {
          my ($prog) = "resize";
  
          # Workaround for Solaris path silliness
          if ( -f "/usr/openwin/bin/resize" ) {
              $prog = "/usr/openwin/bin/resize";
          }
  
          my ($resize) = scalar(`$prog 2>/dev/null`);
          if (defined $resize
              and (  $resize =~ /COLUMNS\s*=\s*(\d+)/
                  or $resize =~ /setenv\s+COLUMNS\s+'?(\d+)/ )
             )
          {
              $results[0] = $1;
              if (   $resize =~ /LINES\s*=\s*(\d+)/
                  or $resize =~ /setenv\s+LINES\s+'?(\d+)/ )
              {
                  $results[1] = $1;
                  @results[ 2, 3 ] = ( 0, 0 );
              }
              else
              {
                  @results = ();
              }
          }
          else
          {
              @results = ();
          }
          push( @fail, "resize program" );
      }
  
      if ( @results < 4 && $^O ne 'MSWin32' )
      {
          my ($prog) = "stty size";
  
          my ($stty) = scalar(`$prog 2>/dev/null`);
          if (defined $stty
              and (  $stty =~ /(\d+) (\d+)/ )
             )
          {
              $results[0] = $2;
              $results[1] = $1;
              @results[ 2, 3 ] = ( 0, 0 );
          }
          else
          {
              @results = ();
          }
          push( @fail, "stty program" );
      }
  
      if ( @results != 4 )
      {
          carp("Unable to get Terminal Size."
               . join( "", map( " The $_ didn't work.", @fail ) ));
  	return undef;
      }
  
      @results;
  }
  
  # blockoptions: 
  #nodelay
  #select
  sub ReadKey {
      my $File = normalizehandle((@_>1?$_[1]:\*STDIN));
      if (defined $_[0] && $_[0] > 0) {
          if ($_[0]) { return undef if &selectfile($File,$_[0]) == 0 }
      }
      if (defined $_[0] && $_[0] < 0) { &setnodelay($File,1); }
      my $value = getc $File;
      if (defined $_[0] && $_[0] < 0) { &setnodelay($File,0); }
      $value;
  }
  sub ReadLine {
      my $File = normalizehandle((@_>1?$_[1]:\*STDIN));
      if (defined $_[0] && $_[0] > 0) {
          if ($_[0]) { return undef if &selectfile($File,$_[0]) == 0 }
      }
      if (defined $_[0] && $_[0] < 0) { &setnodelay($File,1) };
      my $value = scalar(<$File>);
      if (defined $_[0] && $_[0] < 0) { &setnodelay($File,0) };
      $value;
  }
  1;
  # ex: set ro:
DARWIN-2LEVEL_TERM_READKEY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use warnings;
use strict;
use 5.010000;
use utf8;

our $VERSION = '0.302';

use Encode                qw( encode decode );
use File::Path            qw( make_path );
use File::Spec::Functions qw( catdir catfile curdir );
use Getopt::Long          qw( GetOptions );
use Pod::Usage            qw( pod2usage );

use Encode::Locale   qw( decode_argv );
use File::HomeDir    qw();
use File::Which      qw( which );
use Term::ANSIScreen qw( :cursor :screen );
use Term::Choose     qw( choose );
use Term::Form       qw();

use if $^O eq 'MSWin32', 'Win32::Console::ANSI';
print "\e(U" if $^O eq 'MSWin32';

use App::YTDL::Arguments  qw( from_arguments_to_choices );
use App::YTDL::Download   qw( download_youtube );
use App::YTDL::Helper     qw( uni_capture );
use App::YTDL::History    qw( add_uploaders_to_history read_history_files uploader_history_menu );
use App::YTDL::Video_Info qw( gather_video_infos );
use App::YTDL::Options    qw( read_config_file set_options );

binmode STDIN,  ':encoding(console_in)';
binmode STDOUT, ':encoding(console_out)';
binmode STDERR, ':encoding(console_out)';


my ( $arg_file, $help );
GetOptions( 'f|file=s@' => \$arg_file, 'h|?|help' => \$help )
or pod2usage( -message => $!, -verbose => 99, -sections => "SYNOPSIS" );


my $my_videos = File::HomeDir->my_videos || curdir; ##
if ( ! -d $my_videos ) {
    say "Could not find the video directory '$my_videos'!";
    exit 1;
}

my $config_home;
if ( which( 'xdg-user-dir' ) ) {
    $config_home = File::HomeDir::FreeDesktop->my_config(); ##
}
else {
    $config_home = File::HomeDir->my_data();
}
my $config_dir = catdir $config_home, 'getvideo';
make_path $config_dir;


my $opt = {
    ffmpeg                      => which( 'ffmpeg' ),
    ffprobe                     => which( 'ffprobe' ),

    config_dir                  => $config_dir,
    config_file                 => catfile( $config_dir, 'config.json' ),
    log_file                    => catfile( $config_dir, 'download_info.log' ),
    history_file                => catfile( $config_dir, 'uploader_history.json' ),
    sticky_file                 => catfile( $config_dir, 'uploader_sticky.json' ),

    video_dir                   => $my_videos,
    use_extractor_dir           => 1,
    use_uploader_dir            => 1,

    quality                     => 3,
    no_height_ok                => 1,
    prefer_free_formats         => 1,

    useragent                   => 'Mozilla/5.0',
    retries                     => 7,
    timeout                     => 60,

    max_info_width              => 120,
    no_warnings                 => 0,
    right_margin                => $^O eq 'MSWin32' ? 1 : 2,

    max_size_history            => 50,
    sort_history_by_timestamp   => 1,

    list_type_vimeo             => 2,
    list_type_youtube           => 2,

    list_sort_item              => 'upload_date',
    list_sort_order             => 'Desc',
    show_view_count             => 0,

    yt_dl_config_file           => undef,
    yt_dl_ignore_config         => 0,

    no_upload_datetime          => '0000-00-00T00:00:00',
    error_get_download_infos    => [], ##
};

my $youtube_dl = which( 'youtube-dl' );
if ( ! $youtube_dl ) {
    say "Could not find 'youtube-dl' - 'youtube-dl' is required - http://rg3.github.io/youtube-dl/.";
    exit 1;
};
$opt->{youtube_dl} = [ $youtube_dl ];

read_config_file( $opt, $opt->{config_file} );
set_options( $opt ) if $help;

push @{$opt->{youtube_dl}}, '--config-location', $opt->{yt_dl_config_file} if $opt->{yt_dl_config_file};
push @{$opt->{youtube_dl}}, '--ignore-config',                             if $opt->{yt_dl_ignore_config};
push @{$opt->{youtube_dl}}, '--no-warnings'                                if $opt->{no_warnings};
push @{$opt->{youtube_dl}}, '--user-agent',      $opt->{useragent}         if defined $opt->{useragent};
push @{$opt->{youtube_dl}}, '--retries',         $opt->{retries}           if defined $opt->{retries};
push @{$opt->{youtube_dl}}, '--socket-timeout',  $opt->{timeout}           if defined $opt->{timeout};
push @{$opt->{youtube_dl}}, '--prefer-free-formats'                        if $opt->{prefer_free_formats};


local $| = 1;
print locate( 1, 1 ), cldown;


read_history_files( $opt );


my @ids = @ARGV;

for my $file ( @$arg_file ) {
    open my $fh, '<:encoding(utf-8)', $file or die $!;
    while ( my $line = <$fh> ) {
        next if $line =~ /^\s*\z/;
        next if $line =~ /^\s*#/;
        $line =~ s/^\s+|\s+\z//g;
        push @ids, split /\s+/, $line;
    }
    close $fh or die $!;
}

if ( ! @ids ) {
    my $trs = Term::Form->new();
    my $ids = $trs->readline( 'Enter url/id: ' );
    @ids = split /\s+/, $ids;
    print up( 1 ), cldown;
}

if ( ! @ids && ( %{$opt->{history}} || %{$opt->{sticky}} ) ) {
    @ids = uploader_history_menu( $opt );
}

if ( ! @ids ) {
    say "No arguments" and exit;
}


my $info = from_arguments_to_choices( $opt, @ids );

gather_video_infos( $opt, $info );

download_youtube( $opt, $info );

add_uploaders_to_history( $opt, $info ) if $opt->{max_size_history};


if ( @{$opt->{error_get_download_infos}} ) { ##
    say "\nError fetching download infos:";
    for my $video_id ( @{$opt->{error_get_download_infos}} ) {
        say '  ' . $video_id;
    }
}



__END__

=pod

=encoding UTF-8

=head1 NAME

getvideo - Download YouTube and other videos.

=head1 VERSION

Version 0.302

=cut

=head1 SYNOPSIS

    getvideo -h|-?|--help

    getvideo

    getvideo url [url ...]

    getvideo -f|--file filename

=head1 DESCRIPTION

Download single videos or choose videos from a playlist or an uploader.

Call C<getvideo> followed by the space separated urls or enter the urls after calling C<getviedo>. If the urls are
entered after calling C<getvideo> shell metacharacters are escaped automatically.

The urls can also be passed with a file: C<getvideo -f|--file filename>. The urls in the file have to be space separated.

If a passed url results in more than one video, it is shown a menu with the video titles. The user can then choose from
the menu which videos to download. It is possible to filter the video titles of the list menu with a regexp. The filter
can be inverted by adding C<!~> and a space in front of the regexp. Use the C<SpaceBar> to select more than one video -
see L<Term::Choose/USAGE-AND-RETURN-VALUES>.

The different options of C<getvideo> can be reached by calling C<getvideo -h>.

C<App::YTDL> uses L<youtube-dl|http://rg3.github.io/youtube-dl/> to get the info data and to download the videos. To
list the extractors supported by C<youtube-dl> call C<getvideo -h> and select the entry I<Extractors>.

=head1 Options

=head2 HELP

Shows this HELP text.

=head2 INFO

Shows the path and the version of the running C<getvideo>, the path of the video and configuration directories and the
version of C<youtube-dl>. If C<ffmpeg> and C<ffprobe> are available, their version is also shown.

=head2 Directory

=head3 Video directory

Choose an alternative main video directory.

=head3 Extractor directory

Create/use extractor directories.

- no

- yes

=head3 Uploader directory

Create/use uploader directories

- no

- yes

- if chosen from an uploader or a playlist

=head2 Quality

=head3 Resolution

Set the video height.

=head3 No video height

Download videos whose height is unknown.

- no

- yes

=head3 Prefer free formats

Prefer free video formats (I<--prefer-free-formats>).

- no

- yes

=head2 Download

=head3 UserAgent

Set the useragent string (I<--user-agent>).

=head3 Download retries

Set the number of download retries (I<--retries>).

=head3 Timeout

Connection timeout in seconds (I<--socket-timeout>).

=head2 History

=head3 Size history

If no arguments are passed to C<getvideo>, the user can choose videos from uploaders saved in the history file and the
sticky file.

I<Size history> sets the limit of the number of uploaders saved in the history file. Setting I<size history> to C<0>
disables the uploader-history.

An uploader can be made sticky. Uploaders made sticky don't count regarding the I<size history> limit. An uploader made
sticky gets also a new timestamp.

When added to the uploader-history an uploader gets the current timestamp. If the I<size history> limit is reached, the
uploader with the oldest timestamp is removed first.

The supported extractors are YouTube and Vimeo.

=head3 History sort

Sort the history

- by name

- by timestamp

=head2 Uploader videos

=head3 List type

- all standard (list all uploader/playlist videos in the menu).

- all fast (list all uploader/playlist videos in the menu).

- latest (list only the latest videos in the menu - Vimeo: 48, YouTube: 50).

If I<all fast> or I<latest fast> is chosen, the download of the required data for the list-menu takes less time since
the data required for the video downloads is fetched later only for the chosen videos.

With I<all fast> or I<latest fast> enabled a progress info is shown.

Supported extractors:

- Vimeo (no view-count available).

- YouTube (the upload-date is relative to now).

=head3 Sort order

Sort the videos in the list-menu by

- upload date (fallback title);

- title

- view count (fallback upload date)

- duration (fallback upload date)

Fallback is used, if the chosen entry is not available.

=head3 Show view count

- if sorted by view count

- always

=head2 Info Output

=head3 Disable warnings

Ignore C<youtube-dl> warnings (I<--no-warnings>).

=head3 Max info width

Set the maximum width of the video info output.

=head2 Youtube-dl config file

=head3 youtube-dl config file

Location of the C<youtube-dl> configuration file (I<--config-location>).

=head3 Ignore youtube-dl config file

Do not read C<youtube-dl> configuration files (I<--ignore-config>).

=head2 Available extractors

=head3 List Extractors

List the extractors supported by C<youtube-dl>.

=head3 Extractor descriptions

Output descriptions of supported extractors.

=head1 REQUIREMENTS

=head2 Perl version

Requires Perl version 5.10.0 or greater.

=head2 youtube-dl

A recent version of L<youtube-dl|http://rg3.github.io/youtube-dl/> is required.

=head2 ffmpeg and ffprobe

The I<merge> feature requires C<ffmpeg> and C<ffprobe>.

=head2 Monospaced font

It is required a terminal that uses a monospaced font which supports the printed characters.

=head1 CREDITS

C<App::YTDL> uses L<youtube-dl|http://rg3.github.io/youtube-dl/> to get the data required for the video download.

Thanks to the L<Perl-Community.de|http://www.perl-community.de> and the people form
L<stackoverflow|http://stackoverflow.com> for the help.

=head1 AUTHOR

Kuerbis <cuer2s@gmail.com>

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2013-2018 Kuerbis.

This program is free software; you can redistribute it and/or modify it under the same terms as Perl 5.10.0. For
details, see the full text of the licenses in the file LICENSE.

=cut
