#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Encode/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENCODE_LOCALE';
  package Encode::Locale;
  
  use strict;
  our $VERSION = "1.05";
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetACP) {
  		    require Win32;
                      eval { Win32::GetACP() };
  		    *GetACP = sub { &Win32::GetACP } unless $@;
  		}
  		unless (defined &GetACP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetACP()');
  		}
  		if (defined &GetACP) {
  		    my $cp = GetACP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
              # only test one since set together
              unless (defined &GetInputCP) {
                  eval {
                      require Win32;
                      eval { Win32::GetConsoleCP() };
                      # manually "import" it since Win32->import refuses
                      *GetInputCP = sub { &Win32::GetConsoleCP } unless $@;
                      *GetOutputCP = sub { &Win32::GetConsoleOutputCP } unless $@;
                  };
                  unless (defined &GetInputCP) {
                      eval {
                          # try Win32::Console module for codepage to use
                          require Win32::Console;
                          eval { Win32::Console::InputCP() };
                          *GetInputCP = sub { &Win32::Console::InputCP }
                              unless $@;
                          *GetOutputCP = sub { &Win32::Console::OutputCP }
                              unless $@;
                      };
                  }
                  unless (defined &GetInputCP) {
                      # final fallback
                      *GetInputCP = *GetOutputCP = sub {
                          # another fallback that could work is:
                          # reg query HKLM\System\CurrentControlSet\Control\Nls\CodePage /v ACP
                          ((qx(chcp) || '') =~ /^Active code page: (\d+)/)
                              ? $1 : ();
                      };
                  }
  	    }
              my $cp = GetInputCP();
              $ENCODING_CONSOLE_IN = "cp$cp" if $cp;
              $cp = GetOutputCP();
              $ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode::Locale - Determine the locale encoding
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output to the terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suitable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>, L<Term::Encoding>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
ENCODE_LOCALE

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @EXPORT @EXPORT_OK $IMPLEMENTED_BY};    ## no critic qw(AutomaticExportation)
  use base qw(Exporter);
  
  BEGIN
  {
      $VERSION = '1.004';
  
      # Inherit manually
      require Exporter;
      @EXPORT    = qw{home};
      @EXPORT_OK = qw{
        home
        my_home
        my_desktop
        my_documents
        my_music
        my_pictures
        my_videos
        my_data
        my_dist_config
        my_dist_data
        users_home
        users_desktop
        users_documents
        users_music
        users_pictures
        users_videos
        users_data
      };
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($)    ## no critic qw(SubroutinePrototypes)
  {
      (defined $_[0] and not ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  
  sub _DRIVER ($$)    ## no critic qw(SubroutinePrototypes)
  {
      (defined _CLASS($_[0]) and eval "require $_[0]; 1" and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ($IMPLEMENTED_BY)
  {
      # Allow for custom HomeDir classes
      # Leave it as the existing value
  }
  elsif ($^O eq 'MSWin32')
  {
      # All versions of Windows
      $IMPLEMENTED_BY = 'File::HomeDir::Windows';
  }
  elsif ($^O eq 'darwin')
  {
      # 1st: try Mac::SystemDirectory by chansen
      if (eval "require Mac::SystemDirectory; 1")
      {
          $IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
      }
      elsif (eval "require Mac::Files; 1")
      {
          # 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
          $IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
      }
      else
      {
          # 3rd: fallback: pure perl
          $IMPLEMENTED_BY = 'File::HomeDir::Darwin';
      }
  }
  elsif ($^O eq 'MacOS')
  {
      # Legacy Mac OS
      $IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  }
  elsif (File::Which::which('xdg-user-dir'))
  {
      # freedesktop unixes
      $IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  }
  else
  {
      # Default to Unix semantics
      $IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  
  unless (_DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver'))
  {
      Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      $IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop
  {
      $IMPLEMENTED_BY->can('my_desktop')
        ? $IMPLEMENTED_BY->my_desktop
        : Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents
  {
      $IMPLEMENTED_BY->can('my_documents')
        ? $IMPLEMENTED_BY->my_documents
        : Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music
  {
      $IMPLEMENTED_BY->can('my_music')
        ? $IMPLEMENTED_BY->my_music
        : Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures
  {
      $IMPLEMENTED_BY->can('my_pictures')
        ? $IMPLEMENTED_BY->my_pictures
        : Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos
  {
      $IMPLEMENTED_BY->can('my_videos')
        ? $IMPLEMENTED_BY->my_videos
        : Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data
  {
      $IMPLEMENTED_BY->can('my_data')
        ? $IMPLEMENTED_BY->my_data
        : Carp::croak("The my_data method is not implemented on this platform");
  }
  
  sub my_dist_data
  {
      my $params = ref $_[-1] eq 'HASH' ? pop : {};
      my $dist = pop or Carp::croak("The my_dist_data method requires an argument");
      my $data = my_data();
  
      # If datadir is not defined, there's nothing we can do: bail out
      # and return nothing...
      return undef unless defined $data;
  
      # On traditional unixes, hide the top-level directory
      my $var =
        $data eq home()
        ? File::Spec->catdir($data, '.perl', 'dist', $dist)
        : File::Spec->catdir($data, 'Perl',  'dist', $dist);
  
      # directory exists: return it
      return $var if -d $var;
  
      # directory doesn't exist: check if we need to create it...
      return undef unless $params->{create};
  
      # user requested directory creation
      require File::Path;
      File::Path::mkpath($var);
      return $var;
  }
  
  sub my_dist_config
  {
      my $params = ref $_[-1] eq 'HASH' ? pop : {};
      my $dist = pop or Carp::croak("The my_dist_config method requires an argument");
  
      # not all platforms support a specific my_config() method
      my $config =
          $IMPLEMENTED_BY->can('my_config')
        ? $IMPLEMENTED_BY->my_config
        : $IMPLEMENTED_BY->my_documents;
  
      # If neither configdir nor my_documents is defined, there's
      # nothing we can do: bail out and return nothing...
      return undef unless defined $config;
  
      # On traditional unixes, hide the top-level dir
      my $etc =
        $config eq home()
        ? File::Spec->catdir($config, '.perl', $dist)
        : File::Spec->catdir($config, 'Perl',  $dist);
  
      # directory exists: return it
      return $etc if -d $etc;
  
      # directory doesn't exist: check if we need to create it...
      return undef unless $params->{create};
  
      # user requested directory creation
      require File::Path;
      File::Path::mkpath($etc);
      return $etc;
  }
  
  #####################################################################
  # General User Methods
  
  sub users_home
  {
      $IMPLEMENTED_BY->can('users_home')
        ? $IMPLEMENTED_BY->users_home($_[-1])
        : Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop
  {
      $IMPLEMENTED_BY->can('users_desktop')
        ? $IMPLEMENTED_BY->users_desktop($_[-1])
        : Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents
  {
      $IMPLEMENTED_BY->can('users_documents')
        ? $IMPLEMENTED_BY->users_documents($_[-1])
        : Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music
  {
      $IMPLEMENTED_BY->can('users_music')
        ? $IMPLEMENTED_BY->users_music($_[-1])
        : Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures
  {
      $IMPLEMENTED_BY->can('users_pictures')
        ? $IMPLEMENTED_BY->users_pictures($_[-1])
        : Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos
  {
      $IMPLEMENTED_BY->can('users_videos')
        ? $IMPLEMENTED_BY->users_videos($_[-1])
        : Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data
  {
      $IMPLEMENTED_BY->can('users_data')
        ? $IMPLEMENTED_BY->users_data($_[-1])
        : Carp::croak("The users_data method is not implemented on this platform");
  }
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$)    ## no critic qw(SubroutinePrototypes)
  {
      # Allow to be called as a method
      if ($_[0] and $_[0] eq 'File::HomeDir')
      {
          shift();
      }
  
      # No params means my home
      return my_home() unless @_;
  
      # Check the param
      my $name = shift;
      if (!defined $name)
      {
          Carp::croak("Can't use undef as a username");
      }
      if (!length $name)
      {
          Carp::croak("Can't use empty-string (\"\") as a username");
      }
  
      # A dot also means my home
      ### Is this meant to mean File::Spec->curdir?
      if ($name eq '.')
      {
          return my_home();
      }
  
      # Now hand off to the implementor
      $IMPLEMENTED_BY->users_home($name);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =begin html
  
  <a href="https://travis-ci.org/perl5-utils/File-HomeDir"><img src="https://travis-ci.org/perl5-utils/File-HomeDir.svg?branch=master" alt="Travis CI"/></a>
  <a href='https://coveralls.io/github/perl5-utils/File-HomeDir?branch=master'><img src='https://coveralls.io/repos/github/perl5-utils/File-HomeDir/badge.svg?branch=master' alt='Coverage Status'/></a>
  
  =end html
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typically your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementations required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalization. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should store their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's home directory,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's home directory, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single parameter and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head2 users_desktop
  
    $docs = File::HomeDir->users_desktop('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a desktop directory, or dies on error.
  
  =head2 users_music
  
    $docs = File::HomeDir->users_music('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a music directory, or dies on error.
  
  =head2 users_pictures
  
    $docs = File::HomeDir->users_pictures('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a pictures directory, or dies on error.
  
  =head2 users_videos
  
    $docs = File::HomeDir->users_videos('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a videos directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no parameter, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jérôme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.008003;
  use strict;
  use warnings;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Unix";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  #####################################################################
  # Current User Methods
  
  sub _my_home
  {
      my ($class, $path) = @_;
      my $home = $class->my_home;
      return undef unless defined $home;
  
      my $folder = "$home/$path";
      unless (-d $folder)
      {
          # Make sure that symlinks resolve to directories.
          return undef unless -l $folder;
          my $dir = readlink $folder or return;
          return undef unless -d $dir;
      }
  
      return Cwd::abs_path($folder);
  }
  
  sub my_desktop
  {
      my $class = shift;
      $class->_my_home('Desktop');
  }
  
  sub my_documents
  {
      my $class = shift;
      $class->_my_home('Documents');
  }
  
  sub my_data
  {
      my $class = shift;
      $class->_my_home('Library/Application Support');
  }
  
  sub my_music
  {
      my $class = shift;
      $class->_my_home('Music');
  }
  
  sub my_pictures
  {
      my $class = shift;
      $class->_my_home('Pictures');
  }
  
  sub my_videos
  {
      my $class = shift;
      $class->_my_home('Movies');
  }
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home
  {
      my $class = shift;
      my $home  = $class->SUPER::users_home(@_);
      return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_desktop, $name);
  }
  
  sub users_documents
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_documents, $name);
  }
  
  sub users_data
  {
      my ($class, $name) = @_;
      $class->_to_user($class->my_data, $name)
        || $class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user
  {
      my ($class, $path, $name) = @_;
      my $my_home    = $class->my_home;
      my $users_home = $class->users_home($name);
      defined $users_home or return undef;
      $path =~ s/^\Q$my_home/$users_home/;
      return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.008003;
  use strict;
  use warnings;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION};
  
  # This is only a child class of the pure Perl darwin
  # class so that we can do homedir detection of all three
  # drivers at one via ->isa.
  use base "File::HomeDir::Darwin";
  
  BEGIN
  {
      $VERSION = '1.004';
  
      # Load early if in a forking environment and we have
      # prefork, or at run-time if not.
      local $@;                           ## no critic (Variables::RequireInitializationForLocalVars)
      eval "use prefork 'Mac::Files'";    ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
  }
  
  #####################################################################
  # Current User Methods
  
  ## no critic qw(UnusedPrivateSubroutines)
  sub _guess_determined_home
  {
      my $class = shift;
  
      require Mac::Files;
      my $home = $class->_find_folder(Mac::Files::kCurrentUserFolderType(),);
      $home ||= $class->SUPER::_guess_determined_home($@);
      return $home;
  }
  
  sub my_desktop
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kDesktopFolderType(),);
  }
  
  sub my_documents
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kDocumentsFolderType(),);
  }
  
  sub my_data
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kApplicationSupportFolderType(),);
  }
  
  sub my_music
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kMusicDocumentsFolderType(),);
  }
  
  sub my_pictures
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kPictureDocumentsFolderType(),);
  }
  
  sub my_videos
  {
      my $class = shift;
  
      require Mac::Files;
      $class->_find_folder(Mac::Files::kMovieDocumentsFolderType(),);
  }
  
  sub _find_folder
  {
      my $class = shift;
      my $name  = shift;
  
      require Mac::Files;
      my $folder = Mac::Files::FindFolder(Mac::Files::kUserDomain(), $name,);
      return undef unless defined $folder;
  
      unless (-d $folder)
      {
          # Make sure that symlinks resolve to directories.
          return undef unless -l $folder;
          my $dir = readlink $folder or return;
          return undef unless -d $dir;
      }
  
      return Cwd::abs_path($folder);
  }
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home
  {
      my $class = shift;
      my $home  = $class->SUPER::users_home(@_);
      return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_desktop, $name);
  }
  
  sub users_documents
  {
      my ($class, $name) = @_;
      return undef if $name eq 'root';
      $class->_to_user($class->my_documents, $name);
  }
  
  sub users_data
  {
      my ($class, $name) = @_;
      $class->_to_user($class->my_data, $name)
        || $class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user
  {
      my ($class, $path, $name) = @_;
      my $my_home    = $class->my_home;
      my $users_home = $class->users_home($name);
      defined $users_home or return undef;
      $path =~ s/^\Q$my_home/$users_home/;
      return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.008003;
  use strict;
  use warnings;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Darwin";
  
  BEGIN
  {
      $VERSION = '1.004';
  
      # Load early if in a forking environment and we have
      # prefork, or at run-time if not.
      local $@;                                     ## no critic (Variables::RequireInitializationForLocalVars)
      eval "use prefork 'Mac::SystemDirectory'";    ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
  }
  
  #####################################################################
  # Current User Methods
  
  ## no critic qw(UnusedPrivateSubroutines)
  sub _guess_determined_home
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      my $home = Mac::SystemDirectory::HomeDirectory();
      $home ||= $class->SUPER::_guess_determined_home($@);
      return $home;
  }
  
  # from 10.4
  sub my_desktop
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory()) }
        || $class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory()) }
        || $class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory()) }
        || $class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSMusicDirectory()) }
        || $class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory()) }
        || $class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos
  {
      my $class = shift;
  
      require Mac::SystemDirectory;
      eval { $class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory()) }
        || $class->SUPER::my_videos;
  }
  
  sub _find_folder
  {
      my $class = shift;
      my $name  = shift;
  
      require Mac::SystemDirectory;
      my $folder = Mac::SystemDirectory::FindDirectory($name);
      return undef unless defined $folder;
  
      unless (-d $folder)
      {
          # Make sure that symlinks resolve to directories.
          return undef unless -l $folder;
          my $dir = readlink $folder or return;
          return undef unless -d $dir;
      }
  
      return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp ();
  
  use vars qw{$VERSION};
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  sub my_home
  {
      Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Unix";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my
  {
      # No quoting because input is hard-coded and only comes from this module
      my $thingy = qx($xdgprog $_[1]);
      chomp $thingy;
      return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP') }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC') }
  sub my_pictures  { shift->_my('PICTURES') }
  sub my_videos    { shift->_my('VIDEOS') }
  
  sub my_data
  {
      $ENV{XDG_DATA_HOME}
        or File::Spec->catdir(shift->my_home, qw{ .local share });
  }
  
  sub my_config
  {
      $ENV{XDG_CONFIG_HOME}
        or File::Spec->catdir(shift->my_home, qw{ .config });
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD') }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES') }
  
  sub my_cache
  {
      $ENV{XDG_CACHE_HOME}
        || File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.'); }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.'); }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.'); }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.'); }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.'); }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module can operate only when the command C<xdg-user-dir> is available
  and executable, which is typically achieved by installed a package named
  C<xdg-user-dirs> or similar.
  
  One can find the latest spec at L<https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home     = File::HomeDir->my_home;        # /home/mylogin
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $config   = File::HomeDir->my_config;
    
    # Some undocumented ones, expect they don't work - use with caution
    $download    = File::HomeDir->my_download;
    $publicshare = File::HomeDir->my_publicshare;
    $templates   = File::HomeDir->my_templates;
    $cache       = File::HomeDir->my_cache;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE:
  {
      ## no critic qw(RequireInitializationForLocalVars, RequireCheckingReturnValueOfEval)
      local $@;
      eval "use prefork 'Mac::Files'";
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      my $class = shift;
  
      # Try for $ENV{HOME} if we have it
      if (defined $ENV{HOME})
      {
          return $ENV{HOME};
      }
  
      ### DESPERATION SETS IN
  
      # We could use the desktop
    SCOPE:
      {
          ## no critic qw(RequireInitializationForLocalVars, RequireCheckingReturnValueOfEval)
          local $@;
          eval {
              my $home = $class->my_desktop;
              return $home if $home and -d $home;
          };
      }
  
      # Desperation on any platform
    SCOPE:
      {
          # On some platforms getpwuid dies if called at all
          local $SIG{'__DIE__'} = '';
          my $home = (getpwuid($<))[7];
          return $home if $home and -d $home;
      }
  
      Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop
  {
      my $class = shift;
  
      # Find the desktop via Mac::Files
      local $SIG{'__DIE__'} = '';
      require Mac::Files;
      my $home = Mac::Files::FindFolder(Mac::Files::kOnSystemDisk(), Mac::Files::kDesktopFolderType(),);
      return $home if $home and -d $home;
  
      Carp::croak("Could not locate current user's desktop");
  }
  
  #####################################################################
  # General User Methods
  
  sub users_home
  {
      my ($class, $name) = @_;
  
    SCOPE:
      {
          # On some platforms getpwnam dies if called at all
          local $SIG{'__DIE__'} = '';
          my $home = (getpwnam($name))[7];
          return $home if defined $home and -d $home;
      }
  
      Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macintosh systems
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION %DIR $ENABLED};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
      %DIR     = ();
      $ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import
  {
      my $class = shift;
      Carp::croak "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
      # Fill the test directories
      my $BASE = File::Temp::tempdir(CLEANUP => 1);
      %DIR = map { $_ => File::Spec->catdir($BASE, $_) } qw{
        my_home
        my_desktop
        my_documents
        my_data
        my_music
        my_pictures
        my_videos
      };
  
      # Hijack HOME to the home directory
      $ENV{HOME} = $DIR{my_home};    ## no critic qw(LocalizedPunctuationVars)
  
      # Make File::HomeDir load us instead of the native driver
      $File::HomeDir::IMPLEMENTED_BY =    # Prevent a warning
        $File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
      # Ready to go
      $ENABLED = 1;
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      mkdir($DIR{my_home}, oct(755)) unless -d $DIR{my_home};
      return $DIR{my_home};
  }
  
  sub my_desktop
  {
      mkdir($DIR{my_desktop}, oct(755)) unless -d $DIR{my_desktop};
      return $DIR{my_desktop};
  }
  
  sub my_documents
  {
      mkdir($DIR{my_documents}, oct(755)) unless -f $DIR{my_documents};
      return $DIR{my_documents};
  }
  
  sub my_data
  {
      mkdir($DIR{my_data}, oct(755)) unless -d $DIR{my_data};
      return $DIR{my_data};
  }
  
  sub my_music
  {
      mkdir($DIR{my_music}, oct(755)) unless -d $DIR{my_music};
      return $DIR{my_music};
  }
  
  sub my_pictures
  {
      mkdir($DIR{my_pictures}, oct(755)) unless -d $DIR{my_pictures};
      return $DIR{my_pictures};
  }
  
  sub my_videos
  {
      mkdir($DIR{my_videos}, oct(755)) unless -d $DIR{my_videos};
      return $DIR{my_videos};
  }
  
  sub users_home
  {
      return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      my $class = shift;
      my $home  = $class->_guess_home(@_);
  
      # On Unix in general, a non-existent home means "no home"
      # For example, "nobody"-like users might use /nonexistent
      if (defined $home and not -d $home)
      {
          $home = undef;
      }
  
      return $home;
  }
  
  sub _guess_env_home
  {
      my $class = shift;
      if (exists $ENV{HOME} and defined $ENV{HOME} and length $ENV{HOME})
      {
          return $ENV{HOME};
      }
  
      # This is from the original code, but I'm guessing
      # it means "login directory" and exists on some Unixes.
      if (exists $ENV{LOGDIR} and $ENV{LOGDIR})
      {
          return $ENV{LOGDIR};
      }
  
      return;
  }
  
  sub _guess_determined_home
  {
      my $class = shift;
  
      # Light desperation on any (Unixish) platform
    SCOPE:
      {
          my $home = (getpwuid($<))[7];
          return $home if $home and -d $home;
      }
  
      return;
  }
  
  sub _guess_home
  {
      my $class = shift;
      my $home  = $class->_guess_env_home($@);
      $home ||= $class->_guess_determined_home($@);
      return $home;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop
  {
      shift->my_home;
  }
  
  sub my_documents
  {
      shift->my_home;
  }
  
  sub my_data
  {
      shift->my_home;
  }
  
  sub my_music
  {
      shift->my_home;
  }
  
  sub my_pictures
  {
      shift->my_home;
  }
  
  sub my_videos
  {
      shift->my_home;
  }
  
  #####################################################################
  # General User Methods
  
  sub users_home
  {
      my ($class, $name) = @_;
  
      # IF and only if we have getpwuid support, and the
      # name of the user is our own, shortcut to my_home.
      # This is needed to handle HOME environment settings.
      if ($name eq getpwuid($<))
      {
          return $class->my_home;
      }
  
    SCOPE:
      {
          my $home = (getpwnam($name))[7];
          return $home if $home and -d $home;
      }
  
      return undef;
  }
  
  sub users_desktop
  {
      shift->users_home(@_);
  }
  
  sub users_documents
  {
      shift->users_home(@_);
  }
  
  sub users_data
  {
      shift->users_home(@_);
  }
  
  sub users_music
  {
      shift->users_home(@_);
  }
  
  sub users_pictures
  {
      shift->users_home(@_);
  }
  
  sub users_videos
  {
      shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.008003;
  use strict;
  use warnings;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION};
  use base "File::HomeDir::Driver";
  
  BEGIN
  {
      $VERSION = '1.004';
  }
  
  sub CREATE () { 1 }
  
  #####################################################################
  # Current User Methods
  
  sub my_home
  {
      my $class = shift;
  
      # A lot of unix people and unix-derived tools rely on
      # the ability to overload HOME. We will support it too
      # so that they can replace raw HOME calls with File::HomeDir.
      if (exists $ENV{HOME} and defined $ENV{HOME} and length $ENV{HOME})
      {
          return $ENV{HOME};
      }
  
      # Do we have a user profile?
      if (exists $ENV{USERPROFILE} and $ENV{USERPROFILE})
      {
          return $ENV{USERPROFILE};
      }
  
      # Some Windows use something like $ENV{HOME}
      if (exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH})
      {
          return File::Spec->catpath($ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',);
      }
  
      return undef;
  }
  
  sub my_desktop
  {
      my $class = shift;
  
      # The most correct way to find the desktop
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      # MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
      foreach my $e ('USERPROFILE', 'WINDIR')
      {
          next unless $ENV{$e};
          my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
          return $desktop if $desktop and $class->_d($desktop);
      }
  
      # As a last resort, try some hard-wired values
      foreach my $fixed (
          # The reason there are both types of slash here is because
          # this set of paths has been kept from the original version
          # of File::HomeDir::Win32 (before it was rewritten).
          # I can only assume this is Cygwin-related stuff.
          "C:\\windows\\desktop",
          "C:\\win95\\desktop",
          "C:/win95/desktop",
          "C:/windows/desktop",
        )
      {
          return $fixed if $class->_d($fixed);
      }
  
      return undef;
  }
  
  sub my_documents
  {
      my $class = shift;
  
      # The most correct way to find my documents
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_data
  {
      my $class = shift;
  
      # The most correct way to find my documents
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_music
  {
      my $class = shift;
  
      # The most correct way to find my music
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_pictures
  {
      my $class = shift;
  
      # The most correct way to find my pictures
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  sub my_videos
  {
      my $class = shift;
  
      # The most correct way to find my videos
    SCOPE:
      {
          require Win32;
          my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
          return $dir if $dir and $class->_d($dir);
      }
  
      return undef;
  }
  
  # Special case version of -d
  sub _d
  {
      my $self = shift;
      my $path = shift;
  
      # Window can legally return a UNC path from GetFolderPath.
      # Not only is the meaning of -d complicated in this situation,
      # but even on a local network calling -d "\\\\cifs\\path" can
      # take several seconds. UNC can also do even weirder things,
      # like launching processes and such.
      # To avoid various crazy bugs caused by this, we do NOT attempt
      # to validate UNC paths at all so that the code that is calling
      # us has an opportunity to take special actions without our
      # blundering getting in the way.
      if ($path =~ /\\\\/)
      {
          return 1;
      }
  
      # Otherwise do a stat as normal
      return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organizations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use strict;
  use warnings;
  use Exporter   ();
  use File::Spec ();
  
  # ABSTRACT: Perl implementation of the which utility as an API
  our $VERSION = '1.22'; # VERSION
  
  
  our @ISA       = 'Exporter';
  our @EXPORT    = 'which';
  our @EXPORT_OK = 'where';
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  use constant IS_CYG => ($^O eq 'cygwin' || $^O eq 'msys');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
    # WinNT. PATHEXT might be set on Cygwin, but not used.
    if ( $ENV{PATHEXT} ) {
      push @PATHEXT, split ';', $ENV{PATHEXT};
    } else {
      # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
      push @PATHEXT, qw{.com .exe .bat};
    }
  } elsif ( IS_VMS ) {
    push @PATHEXT, qw{.exe .com};
  } elsif ( IS_CYG ) {
    # See this for more info
    # http://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-exe
    push @PATHEXT, qw{.exe .com};
  }
  
  
  sub which {
    my ($exec) = @_;
  
    return undef unless defined $exec;
    return undef if $exec eq '';
  
    my $all = wantarray;
    my @results = ();
  
    # check for aliases first
    if ( IS_VMS ) {
      my $symbol = `SHOW SYMBOL $exec`;
      chomp($symbol);
      unless ( $? ) {
        return $symbol unless $all;
        push @results, $symbol;
      }
    }
    if ( IS_MAC ) {
      my @aliases = split /\,/, $ENV{Aliases};
      foreach my $alias ( @aliases ) {
        # This has not been tested!!
        # PPT which says MPW-Perl cannot resolve `Alias $alias`,
        # let's just hope it's fixed
        if ( lc($alias) eq lc($exec) ) {
          chomp(my $file = `Alias $alias`);
          last unless $file;  # if it failed, just go on the normal way
          return $file unless $all;
          push @results, $file;
          # we can stop this loop as if it finds more aliases matching,
          # it'll just be the same result anyway
          last;
        }
      }
    }
  
    return $exec
            if !IS_VMS and !IS_MAC and !IS_DOS and $exec =~ /\// and -f $exec and -x $exec;
  
    my @path = File::Spec->path;
    if ( IS_DOS or IS_VMS or IS_MAC ) {
      unshift @path, File::Spec->curdir;
    }
  
    foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
      for my $ext ( @PATHEXT ) {
        my $file = $base.$ext;
  
        # We don't want dirs (as they are -x)
        next if -d $file;
  
        if (
          # Executable, normal case
          -x _
          or (
            # MacOS doesn't mark as executable so we check -e
            IS_MAC
            ||
            (
              ( IS_DOS or IS_CYG )
              and
              grep {
                $file =~ /$_\z/i
              } @PATHEXT[1..$#PATHEXT]
            )
            # DOSish systems don't pass -x on
            # non-exe/bat/com files. so we check -e.
            # However, we don't want to pass -e on files
            # that aren't in PATHEXT, like README.
            and -e _
          )
        ) {
          return $file unless $all;
          push @results, $file;
        }
      }
    }
  
    if ( $all ) {
      return @results;
    } else {
      return undef;
    }
  }
  
  
  sub where {
    # force wantarray
    my @res = which($_[0]);
    return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Which - Perl implementation of the which utility as an API
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
   use File::Which;                  # exports which()
   use File::Which qw(which where);  # exports which() and where()
   
   my $exe_path = which 'perldoc';
   
   my @paths = where 'perl';
   # Or
   my @paths = which 'perl'; # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  L<File::Which> finds the full or relative paths to executable programs on
  the system.  This is normally the function of C<which> utility.  C<which> is
  typically implemented as either a program or a built in shell command.  On
  some platforms, such as Microsoft Windows it is not provided as part of the
  core operating system.  This module provides a consistent API to this
  functionality regardless of the underlying platform.
  
  The focus of this module is correctness and portability.  As a consequence
  platforms where the current directory is implicitly part of the search path
  such as Microsoft Windows will find executables in the current directory,
  whereas on platforms such as UNIX where this is not the case executables 
  in the current directory will only be found if the current directory is
  explicitly added to the path.
  
  If you need a portable C<which> on the command line in an environment that
  does not provide it, install L<App::pwhich> which provides a command line
  interface to this API.
  
  =head2 Implementations
  
  L<File::Which> searches the directories of the user's C<PATH> (the current
  implementation uses L<File::Spec#path> to determine the correct C<PATH>),
  looking for executable files having the name specified as a parameter to
  L</which>. Under Win32 systems, which do not have a notion of directly
  executable files, but uses special extensions such as C<.exe> and C<.bat>
  to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head3 Linux, *BSD and other UNIXes
  
  There should not be any surprises here.  The current directory will not be
  searched unless it is explicitly added to the path.
  
  =head3 Modern Windows (including NT, XP, Vista, 7, 8, 10 etc)
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head3 Cygwin
  
  Cygwin provides a Unix-like environment for Microsoft Windows users.  In most
  ways it works like other Unix and Unix-like environments, but in a few key
  aspects it works like Windows.  As with other Unix environments, the current
  directory is not included in the search unless it is explicitly included in
  the search path.  Like on Windows, files with C<.EXE> or <.BAT> extensions will
  be discovered even if they are not part of the query.  C<.COM> or extensions
  specified using the C<PATHEXT> environment variable will NOT be discovered
  without the fully qualified name, however.
  
  =head3 Windows 95, 98, ME, MS-DOS, OS/2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  As of 2015 none of these platforms are tested frequently (or perhaps ever),
  but the current maintainer is determined not to intentionally remove support
  for older operating systems.
  
  =head3 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  As of 2015 the current maintainer does not test on VMS, and is in fact not
  certain it has ever been tested on VMS.  If this platform is important to you
  and you can help me verify and or support it on that platform please contact
  me.
  
  =head1 FUNCTIONS
  
  =head2 which
  
   my $path = which $short_exe_name;
   my @paths = which $short_exe_name;
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where
  
   my @paths = where $short_exe_name;
  
  Not exported by default.
  
  Same as L</which> in array context. Same as the
  C<where> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 CAVEATS
  
  This module has no non-core requirements for Perl 5.6.2 and better.
  
  This module is fully supported back to Perl 5.8.1.  It may work on 5.8.0.  
  It should work on Perl 5.6.x and I may even test on 5.6.2.  I will accept
  patches to maintain compatibility for such older Perls, but you may
  need to fix it on 5.6.x / 5.8.0 and send me a patch.
  
  Not tested on VMS although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  =head1 SUPPORT
  
  Bugs should be reported via the GitHub issue tracker
  
  L<https://github.com/plicease/File-Which/issues>
  
  For other issues, contact the maintainer.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<pwhich>, L<App::pwhich>
  
  Command line interface to this module.
  
  =item L<IPC::Cmd>
  
  Comes with a C<can_run> function with slightly different semantics that
  the traditional UNIX where.  It will find executables in the current
  directory, even though the current directory is not searched for by
  default on Unix.
  
  =item L<Devel::CheckBin>
  
  This module purports to "check that a command is available", but does not
  provide any documentation on how you might use it.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Per Einar Ellefsen <pereinar@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2002 by Per Einar Ellefsen <pereinar@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_WHICH

$fatpacked{"Term/ANSIScreen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_ANSISCREEN';
  use 5.005;
  package Term::ANSIScreen;
  $Term::ANSIScreen::VERSION = '1.50';
  
  use strict;
  use vars qw/@ISA @EXPORT %EXPORT_TAGS $VERSION $AUTOLOAD
              %attributes %attributes_r %sequences $AUTORESET $EACHLINE/;
  use Exporter;
  
  =head1 NAME
  
  Term::ANSIScreen - Terminal control using ANSI escape sequences
  
  =head1 SYNOPSIS
  
      # qw/:color/ is exported by default, i.e. color() & colored()
  
      use Term::ANSIScreen qw/:color :cursor :screen :keyboard/;
  
      print setmode(1), setkey('a','b');
      print "40x25 mode now, with 'a' mapped to 'b'.";
      <STDIN>; resetkey; setmode 3; cls;
  
      locate 1, 1; print "@ This is (1,1)", savepos;
      print locate(24,60), "@ This is (24,60)"; loadpos;
      print down(2), clline, "@ This is (3,15)\n";
  
      setscroll 1, 20;
  
      color 'black on white'; clline;
      print "This line is black on white.\n";
      print color 'reset'; print "This text is normal.\n";
  
      print colored ("This text is bold blue.\n", 'bold blue');
      print "This text is normal.\n";
      print colored ['bold blue'], "This text is bold blue.\n";
      print "This text is normal.\n";
  
      use Term::ANSIScreen qw/:constants/; # constants mode
      print BLUE ON GREEN . "Blue on green.\n";
  
      $Term::ANSIScreen::AUTORESET = 1;
      print BOLD GREEN . ON_BLUE "Bold green on blue.", CLEAR;
      print "\nThis text is normal.\n";
  
      # Win32::Console emulation mode
      # this returns a Win32::Console object on a Win32 platform
      my $console = Term::ANSIScreen->new;
      $console->Cls;	# also works on non-Win32 platform
  
  =cut
  
  # -----------------------
  # Internal data structure
  # -----------------------
  
  %attributes = (
      'clear'      => 0,    'reset'      => 0,
      'bold'       => 1,    'dark'       => 2,
      'underline'  => 4,    'underscore' => 4,
      'blink'      => 5,    'reverse'    => 7,
      'concealed'  => 8,
  
      'black'      => 30,   'on_black'   => 40,
      'red'        => 31,   'on_red'     => 41,
      'green'      => 32,   'on_green'   => 42,
      'yellow'     => 33,   'on_yellow'  => 43,
      'blue'       => 34,   'on_blue'    => 44,
      'magenta'    => 35,   'on_magenta' => 45,
      'cyan'       => 36,   'on_cyan'    => 46,
      'white'      => 37,   'on_white'   => 47,
  );
  
  %sequences = (
      'up'        => '?A',      'down'      => '?B',
      'right'     => '?C',      'left'      => '?D',
      'savepos'   => 's',       'loadpos'   => 'u',
      'cls'       => '2J',      'clline'    => 'K',
      'cldown'    => '0J',      'clup'      => '1J',
      'locate'    => '?;?H',    'setmode'   => '?h',
      'wrapon'    => '7h',      'wrapoff'   => '7l',
      'setscroll'	=> '?;?r',
  );
  
  my %mapped;
  
  # ----------------
  # Exporter section
  # ----------------
  
  @ISA         = qw/Exporter/;
  %EXPORT_TAGS = (
      'color'     => [qw/color colored uncolor/],
      'cursor'    => [qw/locate up down right left savepos loadpos/],
      'screen'    => [qw/cls clline cldown clup setmode wrapon wrapoff setscroll/],
      'keyboard'  => [qw/setkey resetkey/],
      'constants' => [map {uc($_)} keys(%attributes), 'ON'],
  );
  
  $EXPORT_TAGS{all} = [map {@{$_}} values (%EXPORT_TAGS)];
  
  @EXPORT = qw(color colored);
  Exporter::export_ok_tags (keys(%EXPORT_TAGS));
  
  sub new {
      my $class = shift;
  
      if ($^O eq 'MSWin32' and eval { require Win32::Console } ) {
          return Win32::Console->new(@_);
      }
  
      no strict 'refs';
      unless ($main::FG_WHITE) {
          foreach my $color (grep { $attributes{$_} >= 30 } keys %attributes) {
              my $name = "FG_\U$color";
              $name =~ s/^FG_ON_/BG_/;
              ${"main::$name"} = color($color);
              $name =~ s/_/_LIGHT/;
              ${"main::$name"} = color('bold', $color);
          }
          $main::FG_LIGHTWHITE = $main::FG_WHITE;
          $main::FG_BROWN      = $main::FG_YELLOW;
          $main::FG_YELLOW     = $main::FG_LIGHTYELLOW;
          $main::FG_WHITE      = color('clear');
      }
      
      return bless([ @_ ], $class);
  }
  
  sub Attr {
      shift;
      print STDERR @_;
  }
  
  sub Cls {
      print STDERR cls();
  }
  
  sub Cursor {
      shift;
      print STDERR locate($_[1]+1, $_[0]+1);
  }
  
  sub Write {
      shift;
      print STDERR @_;
  }
  
  sub Display {
  }
  
  
  # --------------
  # Implementation
  # --------------
  
  sub AUTOLOAD {
      my $enable_colors = !defined $ENV{ANSI_COLORS_DISABLED};
      my $sub = $AUTOLOAD;
      $sub =~ s/^.*:://;
  
      if (my $seq = $sequences{$sub}) {
  	return '' unless $enable_colors;
  
          $seq =~ s/\?/defined($_[0]) ? shift(@_) : 1/eg;
          return((defined wantarray) ? "\e[$seq"
                                     : print("\e[$seq"));
      }
      elsif (defined(my $attr = $attributes{lc($sub)}) and $sub =~ /^[A-Z_]+$/) {
  	my $out = "@_";
  	if ($enable_colors) {
  	    $out = "\e[${attr}m" . $out;
  	    $out .= "\e[0m" if ($AUTORESET and @_ and $out !~ /\e\[0m$/s);
  	}
          return((defined wantarray) ? $out
                                     : print($out));
      }
      else {
  	require Carp;
          Carp::croak("Undefined subroutine &$AUTOLOAD called");
      }
  }
  
  # ------------------------------------------------
  # Convert foreground constants to background ones,
  # for sequences like (XXX ON YYY "text")
  # ------------------------------------------------
  
  sub ON {
      return '' if defined $ENV{ANSI_COLORS_DISABLED};
  
      my $out = "@_";
      $out =~ s/^\e\[3(\d)m/\e\[4$1m/;
      return $out;
  }
  
  # ---------------------------------------
  # Color subroutines, from Term::ANSIColor
  # ---------------------------------------
  
  sub color {
      return '' if defined $ENV{ANSI_COLORS_DISABLED};
  
      my @codes = map { split } @_;
      my $attribute;
  
      no warnings 'uninitialized';
      while (my $code = lc(shift(@codes))) {
          $code .= '_' . shift(@codes) if ($code eq 'on');
  
          if (defined $attributes{$code}) {
              $attribute .= $attributes{$code} . ';';
          }
          else {
              warn "Invalid attribute name $code";
          }
      }
  
      if ($attribute) {
          chop $attribute;
          return (defined wantarray) ? "\e[${attribute}m"
                                     : print("\e[${attribute}m");
      }
  }
  
  sub colored {
      my $output;
      my ($string, $attr) = (ref $_[0])
          ? (join('', @_[1..$#_]), color(@{$_[0]}))
          : (+shift, color(@_));
  
      return $string if defined $ENV{ANSI_COLORS_DISABLED};
  
      if (defined $EACHLINE) {
          $output  = join '',
              map { ($_ && $_ ne $EACHLINE) ? $attr . $_ . "\e[0m" : $_ }
                  split (/(\Q$EACHLINE\E)/, $string);
      } else {
          $output = "$attr$string\e[0m";
      }
  
      return (defined wantarray) ? $output
                                 : print($output);
  }
  
  sub uncolor {
      my (@nums, @result);
  
      foreach my $seq (@_) {
          my $escape = $seq;
          $escape =~ s/^\e\[//;
          $escape =~ s/m$//;
          unless ($escape =~ /^((?:\d+;)*\d*)$/) {
              require Carp;
              Carp::croak("Bad escape sequence $seq");
          }
          push (@nums, split (/;/, $1));
      }
  
      _init_attributes_r();
  
      foreach my $num (@nums) {
          $num += 0; # Strip leading zeroes
          my $name = $attributes_r{$num};
          if (!defined $name) {
              require Carp;
              Carp::croak("No name for escape sequence $num" );
          }
          push (@result, $name);
      }
  
      return @result;
  }
  
  sub _init_attributes_r {
      return if %attributes_r;
  
      # Reverse lookup.  Alphabetically first name for a sequence is preferred.
      for (reverse sort keys %attributes) {
  	$attributes_r{$attributes{$_}} = $_;
      }
  }
  
  sub setkey {
      my ($key, $mapto) = @_;
  
      if ($key eq $mapto) {
          delete $mapped{$key} if exists $mapped{$key};
      }
      else {
          $mapped{$key} = 1;
      }
  
      $key   = ord($key)    unless ($key =~ /^\d+;\d+$/);
      $mapto = qq("$mapto") unless ($mapto =~ /^\d+;\d+$/);
  
      return (defined wantarray) ? "\e[$key;${mapto}p"
                                 : print("\e[$key;${mapto}p");
  }
  
  sub resetkey {
      my $output;
  
      foreach my $key (@_ ? @_ : keys(%mapped)) {
          $output .= setkey($key, $key);
      }
  
      return (defined wantarray) ? $output
                                 : print($output);
  }
  
  sub DESTROY {
      return;
  }
  
  1;
  
  __END__
  
  =head1 DESCRIPTION
  
  Term::ANSIScreen is a superset of B<Term::ANSIColor> (as of version 1.04
  of that module).  In addition to color-sequence generating subroutines
  exported by C<:color> and C<:constants>, this module also features
  C<:cursor> for cursor positioning, C<:screen> for screen control, as
  well as C<:keyboard> for key mapping.
  
  =head2 NOTES
  
  =over 4
  
  =item *
  
  All subroutines in B<Term::ANSIScreen> will print its return value if
  called under a void context.
  
  =item *
  
  The cursor position, current color, screen mode and keyboard
  mappings affected by B<Term::ANSIScreen> will last after the program
  terminates. You might want to reset them before the end of
  your program.
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 B<Win32::Console> emulation mode
  
  When used in a object-oriented fashion, B<Term::ANSIScreen> acts as a
  B<Win32::Console> clone:
  
      use Term::ANSIScreen;
      my $console = Term::ANSIScreen->new;
      $console->Cls();		# unbuffered
      $console->Cursor(0, 0);	# same as locate(1, 1)
      $console->Display();	# really a no-op
  
  On the Win32 platform, the C<new> constructor simply returns a geniune
  B<Win32::Console> object, if that module exists in the system.
  
  This feature is intended for people who has to port Win32 console
  applications to other platforms, or to write cross-platform application
  that needs terminal controls.
  
  =head2 The C<:color> function set (exported by default)
  
  B<Term::ANSIScreen> recognizes (case-insensitively) following color
  attributes: clear, reset, bold, underline, underscore, blink,
  reverse, concealed, black, red, green, blue, white, yellow, magenta,
  cyan, on_black, on_red, on_green, on_blue, on_white, on_yellow,
  on_magenta, and on_cyan.
  
  The color alone sets the foreground color, and on_color sets
  the background color. You may also use on_color without the
  underscore, e.g. "black on white".
  
  =over 4
  
  =item color LIST
  
  Takes any number of strings as arguments and considers them
  to be space-separated lists of attributes.  It then forms
  and returns the escape sequence to set those attributes.
  
  =item colored EXPR, LIST
  
  Takes a scalar as the first argument and any number of
  attribute strings as the second argument, then returns the
  scalar wrapped in escape codes so that the attributes will
  be set as requested before the string and reset to normal
  after the string.
  
  Alternately, you can pass a reference to an array as the
  first argument, and then the contents of that array will
  be taken as attributes and color codes and the remainder
  of the arguments as text to colorize.
  
  Normally, this function just puts attribute codes at the
  beginning and end of the string, but if you set
  $Term::ANSIScreen::EACHLINE to some string, that string will
  be considered the line delimiter and the attribute will be set
  at the beginning of each line of the passed string and reset
  at the end of each line.  This is often desirable if the
  output is being sent to a program like a pager, which can
  be confused by attributes that span lines.
  
  Normally you'll want to set C<$Term::ANSIScreen::EACHLINE> to
  C<"\n"> to use this feature.
  
  =back
  
  =head2 The C<:constants> function set
  
  If you import C<:constants> you can use the constants CLEAR,
  RESET, BOLD, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
  BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED,
  ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE
  directly.  These are the same as color('attribute') and can be
  used if you prefer typing:
  
      print BOLD BLUE ON_WHITE "Text\n", RESET;
      print BOLD BLUE ON WHITE "Text\n", RESET; # _ is optional
  
  to
      print colored ("Text\n", 'bold blue on_white');
  
  When using the constants, if you don't want to have to remember
  to add the C<, RESET> at the end of each print line, you can set
  C<$Term::ANSIScreen::AUTORESET> to a true value.  Then, the display
  mode will automatically be reset if there is no comma after the
  constant.  In other words, with that variable set:
  
      print BOLD BLUE "Text\n";
  
  will reset the display mode afterwards, whereas:
  
      print BOLD, BLUE, "Text\n";
  
  will not.
  
  =head2 The C<:cursor> function set
  
  =over 4
  
  =item locate [EXPR, EXPR]
  
  Sets the cursor position. The first argument is its row number,
  and the second one its column number.  If omitted, the cursor
  will be located at (1,1).
  
  =item up    [EXPR]
  
  =item down  [EXPR]
  
  =item left  [EXPR]
  
  =item right [EXPR]
  
  Moves the cursor toward any direction for EXPR characters. If
  omitted, EXPR is 1.
  
  =item savepos
  
  =item loadpos
  
  Saves/restores the current cursor position.
  
  =back
  
  =head2 The C<:screen> function set
  
  =over 4
  
  =item cls
  
  Clears the screen with the current background color, and set
  cursor to (1,1).
  
  =item clline
  
  Clears the current row with the current background color, and
  set cursor to the 1st column.
  
  =item clup
  
  Clears everything above the cursor.
  
  =item cldown
  
  Clears everything below the cursor.
  
  =item setmode EXPR
  
  Sets the screen mode to EXPR. Under DOS, ANSI.SYS recognizes
  following values:
  
       0:  40 x  25 x   2 (text)   1:  40 x  25 x 16 (text)
       2:  80 x  25 x   2 (text)   3:  80 x  25 x 16 (text)
       4: 320 x 200 x   4          5: 320 x 200 x  2
       6: 640 x 200 x   2          7: Enables line wrapping
      13: 320 x 200 x   4         14: 640 x 200 x 16
      15: 640 x 350 x   2         16: 640 x 350 x 16
      17: 640 x 480 x   2         18: 640 x 480 x 16
      19: 320 x 200 x 256
  
  =item wrapon
  
  =item wrapoff
  
  Enables/disables the line-wraping mode.
  
  =item setscroll EXPR, EXPR
  
  Causes scrolling to occur only on the lines numbered between
  the first and second arguments, inclusive.
  
  =back
  
  =head2 The C<:keyboard> function set
  
  =over 4
  
  =item setkey EXPR, EXPR
  
  Takes a scalar representing a single keystroke as the first
  argument (either a character or an escape sequence in the
  form of C<"num1;num2">), and maps it to a string defined by
  the second argument.  Afterwards, when the user presses the
  mapped key, the string will get outputed instead.
  
  =item resetkey [LIST]
  
  Resets each keys in the argument list to its original mapping.
  If called without an argument, resets all previously mapped
  keys.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Invalid attribute name %s
  
  You passed an invalid attribute name to either color() or
  colored().
  
  =item Identifier %s used only once: possible typo
  
  You probably mistyped a constant color name such as:
  
      print FOOBAR "This text is color FOOBAR\n";
  
  It's probably better to always use commas after constant names
  in order to force the next error.
  
  =item No comma allowed after filehandle
  
  You probably mistyped a constant color name such as:
  
      print FOOBAR, "This text is color FOOBAR\n";
  
  Generating this fatal compile error is one of the main advantages
  of using the constants interface, since you'll immediately know
  if you mistype a color name.
  
  =item Bareword %s not allowed while "strict subs" in use
  
  You probably mistyped a constant color name such as:
  
      $Foobar = FOOBAR . "This line should be blue\n";
  
  or:
  
      @Foobar = FOOBAR, "This line should be blue\n";
  
  This will only show up under use strict (another good reason
  to run under use strict).
  
  =back
  
  =head1 SEE ALSO
  
  L<Term::ANSIColor>, L<Win32::Console>
  
  =head1 AUTHORS
  
  唐鳳 E<lt>cpan@audreyt.orgE<gt>
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to Term-ANSIScreen.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
TERM_ANSISCREEN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use warnings;
use strict;
use 5.010000;
use utf8;

our $VERSION = '0.302';

use Encode                qw( encode decode );
use File::Path            qw( make_path );
use File::Spec::Functions qw( catdir catfile curdir );
use Getopt::Long          qw( GetOptions );
use Pod::Usage            qw( pod2usage );

use Encode::Locale   qw( decode_argv );
use File::HomeDir    qw();
use File::Which      qw( which );
use Term::ANSIScreen qw( :cursor :screen );
use Term::Choose     qw( choose );
use Term::Form       qw();

use if $^O eq 'MSWin32', 'Win32::Console::ANSI';
print "\e(U" if $^O eq 'MSWin32';

use App::YTDL::Arguments  qw( from_arguments_to_choices );
use App::YTDL::Download   qw( download_youtube );
use App::YTDL::Helper     qw( uni_capture );
use App::YTDL::History    qw( add_uploaders_to_history read_history_files uploader_history_menu );
use App::YTDL::Video_Info qw( gather_video_infos );
use App::YTDL::Options    qw( read_config_file set_options );

binmode STDIN,  ':encoding(console_in)';
binmode STDOUT, ':encoding(console_out)';
binmode STDERR, ':encoding(console_out)';


my ( $arg_file, $help );
GetOptions( 'f|file=s@' => \$arg_file, 'h|?|help' => \$help )
or pod2usage( -message => $!, -verbose => 99, -sections => "SYNOPSIS" );


my $my_videos = File::HomeDir->my_videos || curdir; ##
if ( ! -d $my_videos ) {
    say "Could not find the video directory '$my_videos'!";
    exit 1;
}

my $config_home;
if ( which( 'xdg-user-dir' ) ) {
    $config_home = File::HomeDir::FreeDesktop->my_config(); ##
}
else {
    $config_home = File::HomeDir->my_data();
}
my $config_dir = catdir $config_home, 'getvideo';
make_path $config_dir;


my $opt = {
    ffmpeg                      => which( 'ffmpeg' ),
    ffprobe                     => which( 'ffprobe' ),

    config_dir                  => $config_dir,
    config_file                 => catfile( $config_dir, 'config.json' ),
    log_file                    => catfile( $config_dir, 'download_info.log' ),
    history_file                => catfile( $config_dir, 'uploader_history.json' ),
    sticky_file                 => catfile( $config_dir, 'uploader_sticky.json' ),

    video_dir                   => $my_videos,
    use_extractor_dir           => 1,
    use_uploader_dir            => 1,

    quality                     => 3,
    no_height_ok                => 1,
    prefer_free_formats         => 1,

    useragent                   => 'Mozilla/5.0',
    retries                     => 7,
    timeout                     => 60,

    max_info_width              => 120,
    no_warnings                 => 0,
    right_margin                => $^O eq 'MSWin32' ? 1 : 2,

    max_size_history            => 50,
    sort_history_by_timestamp   => 1,

    list_type_vimeo             => 2,
    list_type_youtube           => 2,

    list_sort_item              => 'upload_date',
    list_sort_order             => 'Desc',
    show_view_count             => 0,

    yt_dl_config_file           => undef,
    yt_dl_ignore_config         => 0,

    no_upload_datetime          => '0000-00-00T00:00:00',
    error_get_download_infos    => [], ##
};

my $youtube_dl = which( 'youtube-dl' );
if ( ! $youtube_dl ) {
    say "Could not find 'youtube-dl' - 'youtube-dl' is required - http://rg3.github.io/youtube-dl/.";
    exit 1;
};
$opt->{youtube_dl} = [ $youtube_dl ];

read_config_file( $opt, $opt->{config_file} );
set_options( $opt ) if $help;

push @{$opt->{youtube_dl}}, '--config-location', $opt->{yt_dl_config_file} if $opt->{yt_dl_config_file};
push @{$opt->{youtube_dl}}, '--ignore-config',                             if $opt->{yt_dl_ignore_config};
push @{$opt->{youtube_dl}}, '--no-warnings'                                if $opt->{no_warnings};
push @{$opt->{youtube_dl}}, '--user-agent',      $opt->{useragent}         if defined $opt->{useragent};
push @{$opt->{youtube_dl}}, '--retries',         $opt->{retries}           if defined $opt->{retries};
push @{$opt->{youtube_dl}}, '--socket-timeout',  $opt->{timeout}           if defined $opt->{timeout};
push @{$opt->{youtube_dl}}, '--prefer-free-formats'                        if $opt->{prefer_free_formats};


local $| = 1;
print locate( 1, 1 ), cldown;


read_history_files( $opt );


my @ids = @ARGV;

for my $file ( @$arg_file ) {
    open my $fh, '<:encoding(utf-8)', $file or die $!;
    while ( my $line = <$fh> ) {
        next if $line =~ /^\s*\z/;
        next if $line =~ /^\s*#/;
        $line =~ s/^\s+|\s+\z//g;
        push @ids, split /\s+/, $line;
    }
    close $fh or die $!;
}

if ( ! @ids ) {
    my $trs = Term::Form->new();
    my $ids = $trs->readline( 'Enter url/id: ' );
    @ids = split /\s+/, $ids;
    print up( 1 ), cldown;
}

if ( ! @ids && ( %{$opt->{history}} || %{$opt->{sticky}} ) ) {
    @ids = uploader_history_menu( $opt );
}

if ( ! @ids ) {
    say "No arguments" and exit;
}


my $info = from_arguments_to_choices( $opt, @ids );

gather_video_infos( $opt, $info );

download_youtube( $opt, $info );

add_uploaders_to_history( $opt, $info ) if $opt->{max_size_history};


if ( @{$opt->{error_get_download_infos}} ) { ##
    say "\nError fetching download infos:";
    for my $video_id ( @{$opt->{error_get_download_infos}} ) {
        say '  ' . $video_id;
    }
}



__END__

=pod

=encoding UTF-8

=head1 NAME

getvideo - Download YouTube and other videos.

=head1 VERSION

Version 0.302

=cut

=head1 SYNOPSIS

    getvideo -h|-?|--help

    getvideo

    getvideo url [url ...]

    getvideo -f|--file filename

=head1 DESCRIPTION

Download single videos or choose videos from a playlist or an uploader.

Call C<getvideo> followed by the space separated urls or enter the urls after calling C<getviedo>. If the urls are
entered after calling C<getvideo> shell metacharacters are escaped automatically.

The urls can also be passed with a file: C<getvideo -f|--file filename>. The urls in the file have to be space separated.

If a passed url results in more than one video, it is shown a menu with the video titles. The user can then choose from
the menu which videos to download. It is possible to filter the video titles of the list menu with a regexp. The filter
can be inverted by adding C<!~> and a space in front of the regexp. Use the C<SpaceBar> to select more than one video -
see L<Term::Choose/USAGE-AND-RETURN-VALUES>.

The different options of C<getvideo> can be reached by calling C<getvideo -h>.

C<App::YTDL> uses L<youtube-dl|http://rg3.github.io/youtube-dl/> to get the info data and to download the videos. To
list the extractors supported by C<youtube-dl> call C<getvideo -h> and select the entry I<Extractors>.

=head1 Options

=head2 HELP

Shows this HELP text.

=head2 INFO

Shows the path and the version of the running C<getvideo>, the path of the video and configuration directories and the
version of C<youtube-dl>. If C<ffmpeg> and C<ffprobe> are available, their version is also shown.

=head2 Directory

=head3 Video directory

Choose an alternative main video directory.

=head3 Extractor directory

Create/use extractor directories.

- no

- yes

=head3 Uploader directory

Create/use uploader directories

- no

- yes

- if chosen from an uploader or a playlist

=head2 Quality

=head3 Resolution

Set the video height.

=head3 No video height

Download videos whose height is unknown.

- no

- yes

=head3 Prefer free formats

Prefer free video formats (I<--prefer-free-formats>).

- no

- yes

=head2 Download

=head3 UserAgent

Set the useragent string (I<--user-agent>).

=head3 Download retries

Set the number of download retries (I<--retries>).

=head3 Timeout

Connection timeout in seconds (I<--socket-timeout>).

=head2 History

=head3 Size history

If no arguments are passed to C<getvideo>, the user can choose videos from uploaders saved in the history file and the
sticky file.

I<Size history> sets the limit of the number of uploaders saved in the history file. Setting I<size history> to C<0>
disables the uploader-history.

An uploader can be made sticky. Uploaders made sticky don't count regarding the I<size history> limit. An uploader made
sticky gets also a new timestamp.

When added to the uploader-history an uploader gets the current timestamp. If the I<size history> limit is reached, the
uploader with the oldest timestamp is removed first.

The supported extractors are YouTube and Vimeo.

=head3 History sort

Sort the history

- by name

- by timestamp

=head2 Uploader videos

=head3 List type

- all standard (list all uploader/playlist videos in the menu).

- all fast (list all uploader/playlist videos in the menu).

- latest (list only the latest videos in the menu - Vimeo: 48, YouTube: 50).

If I<all fast> or I<latest fast> is chosen, the download of the required data for the list-menu takes less time since
the data required for the video downloads is fetched later only for the chosen videos.

With I<all fast> or I<latest fast> enabled a progress info is shown.

Supported extractors:

- Vimeo (no view-count available).

- YouTube (the upload-date is relative to now).

=head3 Sort order

Sort the videos in the list-menu by

- upload date (fallback title);

- title

- view count (fallback upload date)

- duration (fallback upload date)

Fallback is used, if the chosen entry is not available.

=head3 Show view count

- if sorted by view count

- always

=head2 Info Output

=head3 Disable warnings

Ignore C<youtube-dl> warnings (I<--no-warnings>).

=head3 Max info width

Set the maximum width of the video info output.

=head2 Youtube-dl config file

=head3 youtube-dl config file

Location of the C<youtube-dl> configuration file (I<--config-location>).

=head3 Ignore youtube-dl config file

Do not read C<youtube-dl> configuration files (I<--ignore-config>).

=head2 Available extractors

=head3 List Extractors

List the extractors supported by C<youtube-dl>.

=head3 Extractor descriptions

Output descriptions of supported extractors.

=head1 REQUIREMENTS

=head2 Perl version

Requires Perl version 5.10.0 or greater.

=head2 youtube-dl

A recent version of L<youtube-dl|http://rg3.github.io/youtube-dl/> is required.

=head2 ffmpeg and ffprobe

The I<merge> feature requires C<ffmpeg> and C<ffprobe>.

=head2 Monospaced font

It is required a terminal that uses a monospaced font which supports the printed characters.

=head1 CREDITS

C<App::YTDL> uses L<youtube-dl|http://rg3.github.io/youtube-dl/> to get the data required for the video download.

Thanks to the L<Perl-Community.de|http://www.perl-community.de> and the people form
L<stackoverflow|http://stackoverflow.com> for the help.

=head1 AUTHOR

Kuerbis <cuer2s@gmail.com>

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2013-2018 Kuerbis.

This program is free software; you can redistribute it and/or modify it under the same terms as Perl 5.10.0. For
details, see the full text of the licenses in the file LICENSE.

=cut
