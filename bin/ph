#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Array/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR';
  package Array::Iterator;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  ### constructor
  
  sub new {
  	my ($_class, @array) = @_;
  	(@array)
          || die "Insufficient Arguments : you must provide something to iterate over";
  	my $class = ref($_class) || $_class;
  	my $_array;
  	if (scalar @array == 1) {
  		if (ref $array[0] eq "ARRAY") {
  		    $_array = $array[0];
  		}
  		elsif (ref $array[0] eq "HASH") {
  		    die "Incorrect type : HASH reference must contain the key __array__"
  		        unless exists $array[0]->{__array__};
  		    die "Incorrect type : __array__ value must be an ARRAY reference"
  		        unless ref $array[0]->{__array__} eq 'ARRAY';
  		    $_array = $array[0]->{__array__};
  		}
  		else {
  		    die "Incorrect Type : the argument must be an array or hash reference";
  		}
  	}
  	else {
  		$_array = \@array;
  	}
  	my $iterator = {
          _current_index => 0,
          _length => 0,
          _iteratee => [],
          _iterated => 0,
          };
  	bless($iterator, $class);
  	$iterator->_init(scalar(@{$_array}), $_array);
  	return $iterator;
  }
  
  ### methods
  
  # private methods
  
  sub _init {
  	my ($self, $length, $iteratee) = @_;
  	(defined($length) && defined($iteratee))
          || die "Insufficient Arguments : you must provide an length and an iteratee";
  	$self->{_current_index} = 0;
  	$self->{_length} = $length;
  	$self->{_iteratee} = $iteratee;
  }
  
  # protected method
  
  # this can be used in a subclass to access the value
  
  # we need to alter this so its an lvalue
  sub _current_index : lvalue {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
      $_[0]->{_current_index}
  }
  
  # this we should never need to alter
  # so we dont make it a lvalue
  sub _iteratee {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
      $_[0]->{_iteratee}
  }
  
  # we move this from a private method
  # to a protected one, and check our access
  # as well
  sub _getItem {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
  	my ($self, $iteratee, $index) = @_;
  	return $iteratee->[$index];
  }
  
  sub _get_item { my $self = shift; $self->_getItem(@_) }
  
  # we need to alter this so its an lvalue
  sub _iterated : lvalue {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
      $_[0]->{_iterated}
  }
  
  # public methods
  
  # this defines the interface
  # an iterator object will have
  
  sub iterated {
      my ($self) = @_;
      return $self->{_iterated};
  }
  
  sub has_next {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "has_next(0) doesn't make sense, did you mean current()?" }
      elsif($n < 0)      { die "has_next() with negative argument doesn't make sense, perhaps you should use a BiDirectional iterator" }
  
      my $idx = $self->{_current_index} + ($n - 1);
  
  	return ($idx < $self->{_length}) ? 1 : 0;
  }
  
  sub hasNext { my $self = shift; $self->has_next(@_) }
  
  sub next {
  	my ($self) = @_;
      ($self->{_current_index} < $self->{_length})
          || die "Out Of Bounds : no more elements";
          $self->{_iterated} = 1;
  	return $self->_getItem($self->{_iteratee}, $self->{_current_index}++);
  }
  
  sub get_next {
  	my ($self) = @_;
          $self->{_iterated} = 1;
      return undef unless ($self->{_current_index} < $self->{_length});
  	return $self->_getItem($self->{_iteratee}, $self->{_current_index}++);
  }
  
  sub getNext { my $self = shift; $self->get_next(@_) }
  
  sub peek {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "peek(0) doesn't make sense, did you mean get_next()?" }
      elsif($n < 0)      { die "peek() with negative argument doesn't make sense, perhaps you should use a BiDirectional iterator" }
  
      my $idx = $self->{_current_index} + ($n - 1);
  
      return undef unless ($idx < $self->{_length});
  	return $self->_getItem($self->{_iteratee}, $idx);
  }
  
  sub current {
  	my ($self) = @_;
  	return $self->_getItem($self->{_iteratee}, $self->currentIndex());
  }
  
  sub current_index {
  	my ($self) = @_;
  	return ($self->{_current_index} != 0) ? $self->{_current_index} - 1 : 0;
  }
  
  sub currentIndex { my $self = shift; $self->current_index(@_) }
  
  sub get_length {
      my ($self) = @_;
      return $self->{_length};
  }
  
  sub getLength { my $self = shift; $self->get_length(@_) }
  
  1;
  #ABSTRACT: A simple class for iterating over Perl arrays
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator - A simple class for iterating over Perl arrays
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator;
  
    # create an iterator with an array
    my $i = Array::Iterator->new(1 .. 100);
  
    # create an iterator with an array reference
    my $i = Array::Iterator->new(\@array);
  
    # create an iterator with a hash reference
    my $i = Array::Iterator->new({ __array__ => \@array });
  
    # a base iterator example
    while ($i->has_next()) {
        if ($i->peek() < 50) {
            # ... do something because
            # the next element is over 50
        }
        my $current = $i->next();
        # ... do something with current
    }
  
    # shortcut style
    my @accumulation;
    push @accumulation => { item => $iterator->next() } while $iterator->has_next();
  
    # C++ ish style iterator
    for (my $i = Array::Iterator->new(@array); $i->has_next(); $i->next()) {
      my $current = $i->current();
      # .. do something with current
    }
  
    # common perl iterator idiom
    my $current;
    while ($current = $i->get_next()) {
      # ... do something with $current
    }
  
  =head1 DESCRIPTION
  
  This class provides a very simple iterator interface. It is is uni-directional
  and can only be used once. It provides no means of reverseing or reseting the
  iterator. It is not recommended to alter the array during iteration, however
  no attempt is made to enforce this (although I will if I can find an efficient
  means of doing so). This class only intends to provide a clear and simple
  means of generic iteration, nothing more (yet).
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  =head2 Public Methods
  
  =over 4
  
  =item B<new (@array | $array_ref | $hash_ref)>
  
  The constructor can be passed either a plain perl array, an array reference,
  or a hash reference (with the array specified as a single key off the hash,
  __array__). Single element arrays are not supported by either of the first
  two calling conventions, since it is not possible to distinguish between an
  array of a single element which happens to be an array reference, and an
  array reference of a single element, thus previous versions of the constructor
  would raise an exception. If you expect to pass arrays to the constructor which
  may have only a single element, then the array can be passed as the element
  of a HASH reference, with the key, __array__:
  
    my $i = Array::Iterator->new({ __array__ => \@array });
  
  =item B<has_next([$n])>
  
  This methods returns a boolean. True (1) if there are still more elements in
  the iterator, false (0) if there are not.
  
  Takes an optional positive integer (E<gt> 0) that specifies the position you
  want to check. This allows you to check if there an element at arbitrary position.
  Think of it as an ordinal number you want to check:
  
    $i->has_next(2);  # 2nd next element
    $i->has_next(10); # 10th next element
  
  Note that C<has_next(1)> is the same as C<has_next()>.
  
  Throws an exception if C<$n> E<lt>= 0.
  
  =item B<next>
  
  This method returns the next item in the iterator, be sure to only call this
  once per iteration as it will advance the index pointer to the next item. If
  this method is called after all elements have been exhausted, an exception
  will be thrown.
  
  =item B<get_next>
  
  This method returns the next item in the iterator, be sure to only call this
  once per iteration as it will advance the index pointer to the next item. If
  this method is called after all elements have been exhausted, it will return
  undef.
  
  This method was added to allow for a faily common perl iterator idiom of:
  
    my $current;
    while ($current = $i->get_next()) {
        ...
    }
  
  In this the loop terminates once C<$current> is assigned to a false value.
  The only problem with this idiom for me is that it does not allow for
  undefined or false values in the iterator. Of course, if this fits your
  data, then there is no problem. Otherwise I would recommend the C<has_next>/C<next>
  idiom instead.
  
  =item B<peek([$n])>
  
  This method can be used to peek ahead at the next item in the iterator. It
  is non-destructuve, meaning it does not advance the internal pointer. If
  this method is called and attempts to reach beyond the bounds of the iterator,
  it will return undef.
  
  Takes an optional positive integer (E<gt> 0) that specifies how far ahead you want to peek:
  
    $i->peek(2);  # gives you 2nd next element
    $i->peek(10); # gives you 10th next element
  
  Note that C<peek(1)> is the same as C<peek()>.
  
  Throws an exception if C<$n> E<lt>= 0.
  
  B<NOTE:> Prior to version 0.03 this method would throw an exception if called
  out of bounds. I decided this was not a good practice, as it made it difficult
  to be able to peek ahead effectively. This not the case when calling with an argument
  that is E<lt>= 0 though, as it's clearly a sign of incorrect usage.
  
  =item B<current>
  
  This method can be used to get the current item in the iterator. It is non-destructive,
  meaning that it does not advance the internal pointer. This value will match the
  last value dispensed by C<next> or C<get_next>.
  
  =item B<current_index>
  
  This method can be used to get the current index in the iterator. It is non-destructive,
  meaning that it does not advance the internal pointer. This value will match the index
  of the last value dispensed by C<next> or C<get_next>.
  
  =item B<get_length>
  
  This is a basic accessor for getting the length of the array being iterated over.
  
  =back
  
  =head2 Protected Methods
  
  These methods are I<protected>, in the Java/C++ sense of the word. They can only be
  called internally by subclasses of Array::Iterator, an exception is thrown if that
  condition is violated. They are documented here only for people interested in
  subclassing Array::Iterator.
  
  =over 4
  
  =item B<_current_index>
  
  An lvalue-ed subroutine which allows access to the iterator's internal pointer.
  
  =item B<_iteratee>
  
  This returns the item being iteratated over, in our case an array.
  
  =item B<_get_item ($iteratee, $index)>
  
  This method is used by all other routines to access items with. Given the iteratee
  and an index, it will return the item being stored in the C<$iteratee> at the index
  of C<$index>.
  
  =back
  
  =head1 TO DO
  
  =over 4
  
  =item Improve BiDirectional Test suite
  
  I want to test the back and forth a little more, make sure they work well with
  one another.
  
  =item Other Iterators
  
  Array::Iterator::BiDirectional::Circular, Array::Iterator::Skipable and
  Array::Iterator::BiDirectional::Skipable are just a few ideas I have had. I am going
  to hold off for now until I am sure they are actually useful.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of. The code is pretty thoroughly tested (see L<CODE COVERAGE> below)
  and is based on an (non-publicly released) module which I had used in production systems
  for about 2 years without incident. Of course, if you find a bug, let me know, and I will
  be sure to fix it.
  
  =head1 CODE COVERAGE
  
  I use B<Devel::Cover> to test the code coverage of my tests, below is the B<Devel::Cover>
  report on this module's test suite.
  
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
   File                              stmt   bran   cond    sub    pod   time  total
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
   Array/Iterator.pm                100.0  100.0   66.7  100.0  100.0   67.6   98.2
   Array/Iterator/BiDirectional.pm  100.0  100.0    n/a  100.0  100.0   20.2  100.0
   Array/Iterator/Circular.pm       100.0  100.0    n/a  100.0  100.0    7.1  100.0
   Array/Iterator/Reusable.pm       100.0    n/a    n/a  100.0  100.0    5.0  100.0
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
   Total                            100.0  100.0   66.7  100.0  100.0  100.0   99.0
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
  
  =head1 SEE ALSO
  
  This module now includes several subclasses of Array::Iterator which add certain behaviors
  to Array::Iterator, they are:
  
  =over 4
  
  =item B<Array::Iterator::BiDirectional>
  
  Adds the ability to move backwards and forwards through the array.
  
  =item B<Array::Iterator::Circular>
  
  When this iterator reaches the end of its list, it will loop back to the start again.
  
  =item B<Array::Iterator::Reusable>
  
  This iterator can be reset to its beginning and used again.
  
  =back
  
  The Design Patterns book by the Gang of Four, specifically the Iterator pattern.
  
  Some of the interface for this class is based upon the Java Iterator interface.
  
  =head1 OTHER ITERATOR MODULES
  
  There are a number of modules on CPAN with the word Iterator in them. Most of them are
  actually iterators included inside other modules, and only really useful within that
  parent modules context. There are however some other modules out there that are just
  for pure iteration. I have provided a list below of the ones I have found, if perhaps
  you don't happen to like the way I do it.
  
  =over 4
  
  =item B<Tie::Array::Iterable>
  
  This module ties the array, something we do not do. But it also makes an attempt to
  account for, and allow the array to be changed during iteration. It accomplishes this
  control because the underlying array is tied. As we all know, tie-ing things can be a
  performance issue, but if you need what this module provides, then it will likely be
  an acceptable compromise. Array::Iterator makes no attempt to deal with this mid-iteration
  manipulation problem. In fact it is recommened to not alter your array with Array::Iterator,
  and if possible we will enforce this in later versions.
  
  =item B<Data::Iter>
  
  This module allows for simple iteratation over both hashes and arrays. It does it by
  importing several functions which can be used to loop over either type (hash or array)
  in the same way. It is an interesting module, it differs from Array::Iterator in
  paradigm (Array::Iterator is more OO) as well as in intent.
  
  =item B<Class::Iterator>
  
  This is essentially a wrapper around a closure based iterator. This method can be very
  flexible, but at times is difficult to manage due to the inherent complextity of using
  closures. I actually was a closure-as-iterator fan for a while, but eventually moved
  away from it in favor of the more plain vanilla means of iteration, like that found
  Array::Iterator.
  
  =item B<Class::Iter>
  
  This is part of the Class::Visitor module, and is a Visitor and Iterator extensions to
  Class::Template. Array::Iterator is a standalone module not associated with others.
  
  =item B<Data::Iterator::EasyObj>
  
  Data::Iterator::EasyObj makes your array of arrays into iterator objects. It also has
  the ability to further nest additional data structures including Data::Iterator::EasyObj
  objects. Array::Iterator is one dimensional only, and does not attempt to do many of
  the more advanced features of this module.
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item Thanks to Hugo Cornelis for pointing out a bug in C<peek()>
  
  =item Thanks to Phillip Moore for providing the patch to allow single element iteration
  through the hash-ref constructor parameter.
  
  =back
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004, 2005 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR

$fatpacked{"Array/Iterator/BiDirectional.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR_BIDIRECTIONAL';
  
  package Array::Iterator::BiDirectional;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  use Array::Iterator;
  our @ISA = qw(Array::Iterator);
  
  sub has_previous {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "has_previous(0) doesn't make sense, did you mean current()?" }
      elsif($n < 0)      { die "has_previous() with negative argument doesn't make sense, did you mean has_next()?" }
  
      my $idx = $self->_current_index - $n;
  
  	return ($idx > 0) ? 1 : 0;
  }
  
  sub hasPrevious { my $self = shift; $self->has_previous(@_) }
  
  sub previous {
  	my ($self) = @_;
      (($self->_current_index - 1) > 0)
          || die "Out Of Bounds : no more elements";
          $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee, --$self->_current_index);
  }
  
  sub get_previous {
  	my ($self) = @_;
      return undef unless (($self->_current_index - 1) > 0);
          $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee, --$self->_current_index);
  }
  
  sub getPrevious { my $self = shift; $self->get_previous(@_) }
  
  sub look_back {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "look_back(0) doesn't make sense, did you mean get_previous()?" }
      elsif($n < 0)      { die "look_back() with negative argument doesn't make sense, did you mean get_next()?" }
  
      my $idx = $self->_current_index - ($n + 1);
  
      return undef unless ($idx > 0);
      $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee, $idx);
  }
  
  sub lookBack { my $self = shift; $self->look_back(@_) }
  
  1;
  #ABSTRACT: A subclass of Array::Iterator to allow forwards and backwards iteration
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator::BiDirectional - A subclass of Array::Iterator to allow forwards and backwards iteration
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator::BiDirectional;
  
    # create an instance of the iterator
    my $i = Array::Iterator::BiDirectional->new(1 .. 100);
  
    while ($some_condition_exists) {
        # get the latest item from
        # the iterator
        my $current = $i->get_next();
        # ...
        if ($something_happens) {
            # back up the iterator
            $current = $i->get_previous();
        }
    }
  
  =head1 DESCRIPTION
  
  Occasionally it is useful for an iterator to go in both directions, forward and backward. One example would be token processing. When looping though tokens it is sometimes necessary to advance forward looking for a match to a rule. If the match fails, a bi-directional iterator can be moved back so that the next rule can be tried.
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  This is a subclass of Array::Iterator, only those methods that have been added are documented here, refer to the Array::Iterator documentation for more information.
  
  =over 4
  
  =item B<has_previous([$n])>
  
  This method works much like C<hasNext> does, it will return true (C<1>) unless the beginning of the array has been reached, and false (C<0>) otherwise.
  
  Optional argument has the same meaning except that it specifies C<$n>th previous element.
  
  =item B<previous>
  
  This method is much like C<next>. It will return the previous item in the iterator, and throw an exception if it attempts to reach past the beginning of the array.
  
  =item B<get_previous>
  
  This method is much like C<get_next>. It will return the previous item in the iterator, and return undef if it attempts to reach past the beginning of the array.
  
  =item B<look_back([$n])>
  
  This is the counterpart to C<peek>, it will return the previous items in the iterator, but will not affect the internal counter.
  
  Optional argument has the same meaning except that it specifies C<$n>th previous element.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of, if you find a bug, let me know, and I will be sure to fix it.
  
  =head1 CODE COVERAGE
  
  See the B<CODE COVERAGE> section of the B<Array::Iterator> documentation for information about the code coverage of this module's test suite.
  
  =head1 SEE ALSO
  
  This is a subclass of B<Array::Iterator>, please refer to it for more documenation.
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR_BIDIRECTIONAL

$fatpacked{"Array/Iterator/Circular.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR_CIRCULAR';
  
  package Array::Iterator::Circular;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  use Array::Iterator;
  our @ISA = qw(Array::Iterator);
  
  sub _init {
      my ($self, @args) = @_;
      $self->{loop_counter} = 0;
      $self->SUPER::_init(@args);
  }
  
  # always return true, since
  # we just keep looping
  sub has_next { 1 }
  
  sub next {
  	my ($self) = @_;
      unless ($self->_current_index < $self->getLength()) {
          $self->_current_index = 0;
          $self->{loop_counter}++;
      }
          $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee(), $self->_current_index++);
  }
  
  # since neither of them will
  # ever stop dispensing items
  # they can just be aliases of
  # one another.
  *get_next = \&next;
  
  sub is_start {
      my ($self) = @_;
      return ($self->_current_index() == 0);
  }
  
  sub isStart { my $self = shift; $self->is_start(@_) }
  
  sub is_end {
      my ($self) = @_;
      return ($self->_current_index() == $self->getLength());
  }
  
  sub isEnd { my $self = shift; $self->is_end(@_) }
  
  sub get_loop_count {
      my ($self) = @_;
      return $self->{loop_counter};
  }
  
  sub getLoopCount { my $self = shift; $self->get_loop_count(@_) }
  
  1;
  #ABSTRACT: A subclass of Array::Iterator to allow circular iteration
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator::Circular - A subclass of Array::Iterator to allow circular iteration
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator::Circular;
  
    # create an instance with a
    # small array
    my $color_iterator = Array::Iterator::Circular->new(qw(red green blue orange));
  
    # this is a large list of
    # arbitrary items
    my @long_list_of_items = ( ... );
  
    # as we loop through the items ...
    foreach my $item (@long_list_of_items) {
        # we assign color from our color
        # iterator, which will keep dispensing
        # as it loops through its set
        $item->set_color($color_iterator->next());
    }
  
    # tell us how many times the set
    # was looped through
    print $color_iterator->get_loop_count();
  
  =head1 DESCRIPTION
  
  This iterator will loop continuosly as long as C<next> or C<get_next> is called. The C<has_next> method will always return true (C<1>), since the list will always loop back. This is useful when you need a list to repeat itself, but don't want to (or care to) know that it is doing so.
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  This is a subclass of Array::Iterator, only those methods that have been added or altered are documented here, refer to the Array::Iterator documentation for more information.
  
  =over 4
  
  =item B<has_next>
  
  Since we endlessly loop, this will always return true (C<1>).
  
  =item B<next>
  
  This will return the next item in the array, and when it reaches the end of the array, it will loop back to the beginning again.
  
  =item B<get_next>
  
  This method is now defined in terms of C<next>, since neither will even stop dispensing items, there is no need to differentiate.
  
  =item B<is_start>
  
  If at anytime during your looping, you want to know if you have arrived back at the start of you list, you can ask this method.
  
  =item B<is_end>
  
  If at anytime during your looping, you want to know if you have gotten to the end of you list, you can ask this method.
  
  =item B<get_loop_count>
  
  This method will tell you how many times the iterator has looped back to its start.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of, if you find a bug, let me know, and I will be sure to fix it.
  
  =head1 CODE COVERAGE
  
  See the B<CODE COVERAGE> section of the B<Array::Iterator> documentation for information about the code coverage of this module's test suite.
  
  =head1 SEE ALSO
  
  This is a subclass of B<Array::Iterator>, please refer to it for more documenation.
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR_CIRCULAR

$fatpacked{"Array/Iterator/Reusable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR_REUSABLE';
  
  package Array::Iterator::Reusable;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  use Array::Iterator;
  our @ISA = qw(Array::Iterator);
  
  sub reset {
      my ($self) = @_;
      $self->_iterated = 0;
      $self->_current_index = 0;
  }
  
  1;
  #ABSTRACT: A subclass of Array::Iterator to allow reuse of iterators
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator::Reusable - A subclass of Array::Iterator to allow reuse of iterators
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator::Reusable;
  
    # create an iterator with an array
    my $i = Array::Iterator::Reusable->new(1 .. 100);
  
    # do something with the iterator
    my @accumulation;
    push @accumulation => { item => $iterator->next() } while $iterator->has_next();
  
    # now reset the iterator so we can do it again
    $iterator->reset();
  
  =head1 DESCRIPTION
  
  Sometimes you don't want to have to throw out your iterator each time you have exhausted it. This class adds the C<reset> method to allow reuse of an iterator. This is a very simple addition to the Array::Iterator class of a single method.
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  This is a subclass of Array::Iterator, only those methods that have been added are documented here, refer to the Array::Iterator documentation for more information.
  
  =over 4
  
  =item B<reset>
  
  This resets the interal counter of the iterator back to the start of the array.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of, if you find a bug, let me know, and I will be sure to fix it.
  
  =head1 CODE COVERAGE
  
  See the B<CODE COVERAGE> section of the B<Array::Iterator> documentation for information about the code coverage of this module's test suite.
  
  =head1 SEE ALSO
  
  This is a subclass of B<Array::Iterator>, please refer to it for more documenation.
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR_REUSABLE

$fatpacked{"Cache/LRU.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CACHE_LRU';
  package Cache::LRU;
  
  use strict;
  use warnings;
  
  use 5.008_001;
  
  use Scalar::Util qw();
  
  our $VERSION = '0.04';
  
  sub GC_FACTOR () { 10 }
  
  sub new {
      my ($klass, %args) = @_;
      return bless {
          size    => 1024,
          %args,
          _entries => {}, # $key => $weak_valueref
          _fifo    => [], # fifo queue of [ $key, $valueref ]
      }, $klass;
  }
  
  sub set {
      my ($self, $key, $value) = @_;
  
      my $entries = $self->{_entries};
  
      if (my $old_value_ref = $entries->{$key}) {
          $$old_value_ref = undef;
      }
  
      # register
      my $value_ref = \$value;
      Scalar::Util::weaken($entries->{$key} = $value_ref);
      $self->_update_fifo($key, $value_ref);
  
      # expire the oldest entry if full
      while (scalar(keys %$entries) > $self->{size}) {
          my $exp_key = shift(@{$self->{_fifo}})->[0];
          delete $entries->{$exp_key}
              unless $entries->{$exp_key};
      }
  
      $value;
  }
  
  sub remove {
      my ($self, $key) = @_;
      my $value_ref = delete $self->{_entries}->{$key};
      return undef unless $value_ref;
      my $value = $$value_ref;
      $$value_ref = undef;
      $value;
  }
  
  sub get {
      my ($self, $key) = @_;
  
      my $value_ref = $self->{_entries}->{$key};
      return undef unless $value_ref;
  
      $self->_update_fifo($key, $value_ref);
      $$value_ref;
  }
  
  sub clear {
      my $self = shift;
  
      $self->{_entries} = {};
      $self->{_fifo} = [];    
  }
  
  sub _update_fifo {
      # precondition: $self->{_entries} should contain given key
      my ($self, $key, $value_ref) = @_;
      my $fifo = $self->{_fifo};
  
      push @$fifo, [ $key, $value_ref ];
      if (@$fifo >= $self->{size} * GC_FACTOR) {
          my $entries = $self->{_entries};
          my @new_fifo;
          my %need = map { $_ => 1 } keys %$entries;
          while (%need) {
              my $fifo_entry = pop @$fifo;
              unshift @new_fifo, $fifo_entry
                  if delete $need{$fifo_entry->[0]};
          }
          $self->{_fifo} = \@new_fifo;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Cache::LRU - a simple, fast implementation of LRU cache in pure perl
  
  =head1 SYNOPSIS
  
      use Cache::LRU;
  
      my $cache = Cache::LRU->new(
          size => $max_num_of_entries,
      );
  
      $cache->set($key => $value);
  
      $value = $cache->get($key);
  
      $removed_value = $cache->remove($key);
  
  =head1 DESCRIPTION
  
  Cache::LRU is a simple, fast implementation of an in-memory LRU cache in pure perl.
  
  =head1 FUNCTIONS
  
  =head2 Cache::LRU->new(size => $max_num_of_entries)
  
  Creates a new cache object.  Takes a hash as the only argument.  The only parameter currently recognized is the C<size> parameter that specifies the maximum number of entries to be stored within the cache object.
  
  =head2 $cache->get($key)
  
  Returns the cached object if exists, or undef otherwise.
  
  =head2 $cache->set($key => $value)
  
  Stores the given key-value pair.
  
  =head2 $cache->remove($key)
  
  Removes data associated to the given key and returns the old value, if any.
  
  =head2 $cache->clear($key)
  
  Removes all entries from the cache.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  =head1 SEE ALSO
  
  L<Cache>
  
  L<Cache::Ref>
  
  L<Tie::Cache::LRU>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  See <http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
CACHE_LRU

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.14';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"HTTP/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  use URI;
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              no warnings 'uninitialized';
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuration object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Configuration for request and response objects
  
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.02";
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  will be the full 4-digit year, and $month numbers start with 1 (for January).
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned (C<undef> in
  scalar context).
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  use Carp ();
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  our $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      if (exists $self->{'::std_case'}) {
  	$c->{'::std_case'} = $self->{'::std_case'};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      Carp::croak("Illegal field name '$field'")
          if rindex($field, ':') > 1 || !length($field);
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless($standard_case{$field} || $self->{'::std_case'}{$field}) {
  	    # generate a %std_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $self->{'::std_case'}{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } grep !/^::/, keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $self->{'::std_case'}{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return grep !/^::/, keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $vals);
  	}
      }
  }
  
  sub flatten {
  	my($self)=@_;
  
  	(
  		map {
  			my $k = $_;
  			map {
  				( $k => $_ )
  			} $self->header($_);
  		} $self->header_field_names
  	);
  }
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		$val = '' if not defined $val;
  		my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    $vals = '' if not defined $vals;
  	    my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promises that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->flatten()
  
  Returns the list of pairs of keys and values.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Class encapsulating HTTP Message headers
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  use HTTP::Headers;
  
  package
      HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::Auth
  
  =head1 VERSION
  
  version 6.18
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package
      HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::ETag
  
  =head1 VERSION
  
  version 6.18
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  use base 'Exporter';
  
  our @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessarily be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Header value parsing utility functions
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  unless ($HTTP::URI_CLASS) {
      if ($ENV{PERL_HTTP_URI_CLASS}
      &&  $ENV{PERL_HTTP_URI_CLASS} =~ /^([\w:]+)$/) {
          $HTTP::URI_CLASS = $1;
      } else {
          $HTTP::URI_CLASS = "URI";
      }
  }
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = defined( $_[1] ) ? $_[1] : '';
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = defined( $_[1] ) ? $_[1] : '';
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16LE" if /^\xFF\xFE/;
  	return "UTF-16BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32BE" if /^\x00\x00\x00</;
  	    return "UTF-32LE" if /^<\x00\x00\x00/;
  	    return "UTF-16BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	require IO::HTML;
  	# Use relaxed search to match previous versions of HTTP::Message:
  	my $encoding = IO::HTML::find_charset_in($$cref, { encoding    => 1,
  	                                                   need_pragma => 0 });
  	return $encoding->mime_name if $encoding;
      }
      elsif ($self->content_type eq "application/json") {
  	for ($$cref) {
  	    # RFC 4627, ch 3
  	    return "UTF-32BE" if /^\x00\x00\x00./s;
  	    return "UTF-32LE" if /^.\x00\x00\x00/s;
  	    return "UTF-16BE" if /^\x00.\x00./s;
  	    return "UTF-16LE" if /^.\x00.\x00/s;
  	    return "UTF-8";
  	}
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity" || $ce eq "none";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2" or $ce eq "bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it as is
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2", "bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity" || $encoding eq "none") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2" || $encoding eq "bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = $opt{no_content};
  	$no_content = "(no content)" unless defined $no_content;
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = $no_content;
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  # allow subclasses to override what will handle individual parts
  sub _part_class {
      return __PACKAGE__;
  }
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = $self->_part_class->new(
  	    $self->remove_content_headers,
  	    $self->content(""),
  	);
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls to the headers object.
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { local $Carp::Internal{+__PACKAGE__} = 1; shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map $self->_part_class->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ $self->_part_class->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  If the C<undef> argument is given, the content is reset to its default value,
  which is an empty string.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If a @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item no_content => $str
  
  Replaces the "(no content)" marker.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style message (base class)
  
HTTP_MESSAGE

$fatpacked{"HTTP/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST';
  package HTTP::Request;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  use base 'HTTP::Message';
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      Carp::carp('Undefined argument to parse()') if $^W && ! defined $str;
      my $request_line;
      if (defined $str && $str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      if (defined $request_line) {
          my($method, $uri, $protocol) = split(' ', $request_line);
          $self->method($method);
          $self->uri($uri) if defined($uri);
          $self->protocol($protocol) if $protocol;
      }
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme') && $uri->can('canonical');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT", "PATCH" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parsable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 EXAMPLES
  
  Creating requests to be sent with L<LWP::UserAgent> or others can be easy. Here
  are a few examples.
  
  =head2 Simple POST
  
  Here, we'll create a simple POST request that could be used to send JSON data
  to an endpoint.
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
  
      use Encode qw(encode_utf8);
      use HTTP::Request ();
      use JSON::MaybeXS qw(encode_json);
  
      my $url = 'https://www.example.com/api/user/123';
      my $header = ['Content-Type' => 'application/json; charset=UTF-8'];
      my $data = {foo => 'bar', baz => 'quux'};
      my $encoded_data = encode_utf8(encode_json($data));
  
      my $r = HTTP::Request->new('POST', $url, $header, $encoded_data);
      # at this point, we could send it via LWP::UserAgent
      # my $ua = LWP::UserAgent->new();
      # my $res = $ua->request($r);
  
  =head2 Batch POST Request
  
  Some services, like Google, allow multiple requests to be sent in one batch.
  L<https://developers.google.com/drive/v3/web/batch> for example. Using the
  C<add_part> method from L<HTTP::Message> makes this simple.
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
  
      use Encode qw(encode_utf8);
      use HTTP::Request ();
      use JSON::MaybeXS qw(encode_json);
  
      my $auth_token = 'auth_token';
      my $batch_url = 'https://www.googleapis.com/batch';
      my $url = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id';
      my $url_no_email = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id&sendNotificationEmail=false';
  
      # generate a JSON post request for one of the batch entries
      my $req1 = build_json_request($url, {
          emailAddress => 'example@appsrocks.com',
          role => "writer",
          type => "user",
      });
  
      # generate a JSON post request for one of the batch entries
      my $req2 = build_json_request($url_no_email, {
          domain => "appsrocks.com",
          role => "reader",
          type => "domain",
      });
  
      # generate a multipart request to send all of the other requests
      my $r = HTTP::Request->new('POST', $batch_url, [
          'Accept-Encoding' => 'gzip',
          # if we don't provide a boundary here, HTTP::Message will generate
          # one for us. We could use UUID::uuid() here if we wanted.
          'Content-Type' => 'multipart/mixed; boundary=END_OF_PART'
      ]);
  
      # add the two POST requests to the main request
      $r->add_part($req1, $req2);
      # at this point, we could send it via LWP::UserAgent
      # my $ua = LWP::UserAgent->new();
      # my $res = $ua->request($r);
      exit();
  
      sub build_json_request {
          my ($url, $href) = @_;
          my $header = ['Authorization' => "Bearer $auth_token", 'Content-Type' => 'application/json; charset=UTF-8'];
          return HTTP::Request->new('POST', $url, $header, encode_utf8(encode_json($href)));
      }
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style request message
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  our $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  use Exporter 5.57 'import';
  
  our @EXPORT =qw(GET HEAD PUT PATCH POST);
  our @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  sub PATCH { request_type_with_data('PATCH', @_); }
  sub POST { request_type_with_data('POST', @_); }
  sub PUT { request_type_with_data('PUT', @_); }
  
  sub request_type_with_data
  {
      my $type = shift;
      my $url  = shift;
      my $req = HTTP::Request->new($type => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  
  	    # HTML/4.01 says that line breaks are represented as "CR LF" pairs (i.e., `%0D%0A')
  	    $content =~ s/(?<!%0D)%0A/%0D%0A/g if defined($content);
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      while (my ($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
              no warnings 'uninitialized';
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
    $ua->request(PATCH 'http://somewhere/foo', [foo => bar, bar => foo]);
    $ua->request(PUT 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provides functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.
  
  Note that L<LWP::UserAgent> has several convenience methods, including
  C<get>, C<head>, C<delete>, C<post> and C<put>.
  
  The following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The C<GET> function returns an L<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the C<PUT>, C<PATCH>
   and C<POST> functions described below.
  
  The C<get(...)> method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(GET ...) >>.
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The C<head(...)>  method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(HEAD ...) >>.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like C<GET> but the method in the request is C<DELETE>.  This function
  is not exported by default.
  
  =item PATCH $url
  
  =item PATCH $url, Header => Value,...
  
  =item PATCH $url, $form_ref, Header => Value,...
  
  =item PATCH $url, Header => Value,..., Content => $form_ref
  
  =item PATCH $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<PATCH>.
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, $form_ref, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $form_ref
  
  =item PUT $url, Header => Value,..., Content => $content
  
  The same as C<POST> below, but the method in the request is C<PUT>
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  C<POST>, C<PATCH> and C<PUT> all work with the same parameters.
  
    %data = ( title => 'something', body => something else' );
    $ua = LWP::UserAgent->new();
    $request = HTTP::Request::Common::POST( $url, [ %data ] );
    $response = $ua->request($request);
  
  They take a second optional array or hash reference
  parameter C<$form_ref>.  The content can also be specified
  directly using the C<Content> pseudo-header, and you may also provide
  the C<$form_ref> this way.
  
  The C<Content> pseudo-header steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  The C<$form_ref> argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate an HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create an L<HTTP::Request> object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the C<$form_ref> is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by C<LWP::MediaTypes::guess_media_type()>
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create an L<HTTP::Request> object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the C<$DYNAMIC_FILE_UPLOAD> variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no C<Content-Length> header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the C<Content-Length> is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The C<post(...)>  method of L<LWP::UserAgent> exists as a shortcut for
  C<< $ua->request(POST ...) >>.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  Also, there are some examples in L<HTTP::Request/"EXAMPLES"> that you might
  find useful. For example, batch requests are explained there.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: Construct common HTTP::Request objects
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_RESPONSE';
  package HTTP::Response;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  use base 'HTTP::Message';
  
  use HTTP::Status ();
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      Carp::carp('Undefined argument to parse()') if $^W && ! defined $str;
      my $status_line;
      if (defined $str && $str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      $status_line =~ s/\r\z// if defined $status_line;
  
      my $self = $class->SUPER::parse($str);
      if (defined $status_line) {
          my($protocol, $code, $message);
          if ($status_line =~ /^\d{3} /) {
             # Looks like a response created by HTTP::Response->new
             ($code, $message) = split(' ', $status_line, 2);
          } else {
             ($protocol, $code, $message) = split(' ', $status_line, 3);
          }
          $self->protocol($protocol) if $protocol;
          $self->code($code) if defined($code);
          $self->message($message) if defined($message);
      }
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  sub is_client_error { HTTP::Status::is_client_error (shift->{'_rc'}); }
  sub is_server_error { HTTP::Status::is_server_error (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request);
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meanings of these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of an HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then any base
  URI embedded in the document (step 1) will already have initialized the
  "Content-Base:" header. (See L<LWP::UserAgent/parse_head>).  This means that
  this method only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  =item $r->is_client_error
  
  =item $r->is_server_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP style response message
  
HTTP_RESPONSE

$fatpacked{"HTTP/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.18';
  
  require 5.002;   # because we use prototypes
  
  use base 'Exporter';
  our @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  our @EXPORT_OK = qw(is_client_error is_server_error is_cacheable_by_default);
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 7231 (2017-12-20)
  # See also:
  # https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518: WebDAV
      103 => 'Early Hints',                     # RFC 8297: Indicating Hints
  #   104 .. 199
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',                 # RFC 7233: Range Requests
      207 => 'Multi-Status',                    # RFC 4918: WebDAV
      208 => 'Already Reported',                # RFC 5842: WebDAV bindings
  #   209 .. 225
      226 => 'IM used',                         # RFC 3229: Delta encoding
  #   227 .. 299
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',                    # RFC 7232: Conditional Request
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      308 => 'Permanent Redirect',              # RFC 7528: Permanent Redirect
  #   309 .. 399
      400 => 'Bad Request',
      401 => 'Unauthorized',                    # RFC 7235: Authentication
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',   # RFC 7235: Authentication
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',             # RFC 7232: Conditional Request
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',   # RFC 7233: Range Requests
      417 => 'Expectation Failed',
  #   418 .. 420
      421 => 'Misdirected Request',             # RFC 7540: HTTP/2
      422 => 'Unprocessable Entity',            # RFC 4918: WebDAV
      423 => 'Locked',                          # RFC 4918: WebDAV
      424 => 'Failed Dependency',               # RFC 4918: WebDAV
  #   425
      426 => 'Upgrade Required',
  #   427
      428 => 'Precondition Required',           # RFC 6585: Additional Codes
      429 => 'Too Many Requests',               # RFC 6585: Additional Codes
  #   430
      431 => 'Request Header Fields Too Large', # RFC 6585: Additional Codes
  #   432 .. 450
      451 => 'Unavailable For Legal Reasons',   # RFC 7724: Legal Obstacles
  #   452 .. 499
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295: Transparant Ngttn
      507 => 'Insufficient Storage',            # RFC 4918: WebDAV
      508 => 'Loop Detected',                   # RFC 5842: WebDAV bindings
  #   509
      510 => 'Not Extended',                    # RFC 2774: Extension Framework
      511 => 'Network Authentication Required', # RFC 6585: Additional Codes
  );
  
  # keep some unofficial codes that used to be in this distribution
  %StatusCode = (
      %StatusCode,
      418 => 'I\'m a teapot',                   # RFC 2324: HTCPC/1.0  1-april
      425 => 'Unordered Collection',            #           WebDAV Draft
      449 => 'Retry with',                      #           microsoft
      509 => 'Bandwidth Limit Exceeded',        #           Apache / cPanel
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ s/I'm/I am/;
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  *RC_NO_CODE = \&RC_UNORDERED_COLLECTION;
  push(@EXPORT, "RC_NO_CODE");
  
  our %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info                 ($) { $_[0] && $_[0] >= 100 && $_[0] < 200; }
  sub is_success              ($) { $_[0] && $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect             ($) { $_[0] && $_[0] >= 300 && $_[0] < 400; }
  sub is_error                ($) { $_[0] && $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error         ($) { $_[0] && $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error         ($) { $_[0] && $_[0] >= 500 && $_[0] < 600; }
  sub is_cacheable_by_default ($) { $_[0] && ( $_[0] == 200 # OK
                                            || $_[0] == 203 # Non-Authoritative Information
                                            || $_[0] == 204 # No Content
                                            || $_[0] == 206 # Not Acceptable
                                            || $_[0] == 300 # Multiple Choices
                                            || $_[0] == 301 # Moved Permanently
                                            || $_[0] == 404 # Not Found
                                            || $_[0] == 405 # Method Not Allowed
                                            || $_[0] == 410 # Gone
                                            || $_[0] == 414 # Request-URI Too Large
                                            || $_[0] == 451 # Unavailable For Legal Reasons
                                            || $_[0] == 501 # Not Implemented
                                              );
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 VERSION
  
  version 6.18
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of an HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
     HTTP_EARLY_HINTS                     (103)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
     HTTP_ALREADY_REPORTED                (208)
  
     HTTP_IM_USED                         (226)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
     HTTP_PERMANENT_REDIRECT              (308)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_MISDIRECTED REQUEST             (421)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_PRECONDITION_REQUIRED           (428)
     HTTP_TOO_MANY_REQUESTS               (429)
     HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
     HTTP_UNAVAILABLE_FOR_LEGAL_REASONS   (451)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_LOOP_DETECTED                   (508)
     HTTP_NOT_EXTENDED                    (510)
     HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above. If the $code is not registered in the L<list of IANA HTTP Status
  Codes|https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>
  then C<undef> is returned. 
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  returns TRUE for both client and server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is a I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is a I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =item is_cacheable_by_default( $code )
  
  Return TRUE if C<$code> indicates that a response is cacheable by default, and
  it can be reused by a cache with heuristic expiration. All other status codes
  are not cacheable by default. See L<RFC 7231 - HTTP/1.1 Semantics and Content,
  Section 6.1. Overview of Status Codes|https://tools.ietf.org/html/rfc7231#section-6.1>.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 SEE ALSO
  
  L<IANA HTTP Status Codes|https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explicit imports and
  the C<:constants> tag instead of relying on this.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@activestate.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 1994-2017 by Gisle Aas.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  #ABSTRACT: HTTP Status code processing
HTTP_STATUS

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use Exporter;
  BEGIN { @JSON::ISA = 'Exporter' }
  
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.97001';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my %RequiredVersion = (
      'JSON::PP' => '2.27203',
      'JSON::XS' => '2.34',
  );
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw/allow_tags/; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1') {
          $backend = 'JSON::XS,JSON::PP';
      }
      elsif ($backend eq '0') {
          $backend = 'JSON::PP';
      }
      elsif ($backend eq '2') {
          $backend = 'JSON::XS';
      }
      $backend =~ s/\s+//g;
  
      my @backend_modules = split /,/, $backend;
      while(my $module = shift @backend_modules) {
          if ($module =~ /JSON::XS/) {
              _load_xs($module, @backend_modules ? $_INSTALL_DONT_DIE : 0);
          }
          elsif ($module =~ /JSON::PP/) {
              _load_pp($module);
          }
          elsif ($module =~ /JSON::backportPP/) {
              _load_pp($module);
          }
          else {
              Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
          }
          last if $JSON::Backend;
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend->is_xs);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              my $org_encode = $JSON::Backend->can('encode');
              eval q|
                  require B;
                  local $^W;
                  no strict 'refs';
                  *{"${JSON::Backend}\::encode"} = sub {
                      # only works with Perl 5.18+
                      local *UNIVERSAL::TO_JSON = sub {
                          my $b_obj = B::svref_2object( $_[0] );
                          return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                                  : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                                  : undef
                                  ;
                      };
                      $org_encode->(@_);
                  };
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $RequiredVersion{'JSON::XS'}; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend->is_xs;
  }
  
  
  sub is_pp {
      return $_[0]->backend->is_pp;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub __load_xs {
      my ($module, $opt) = @_;
  
      $JSON::DEBUG and Carp::carp "Load $module.";
      my $required_version = $RequiredVersion{$module} || '';
  
      eval qq|
          use $module $required_version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $module...($@)";
              return 0;
          }
          Carp::croak $@;
      }
      $JSON::BackendModuleXS = $module;
      return 1;
  }
  
  sub _load_xs {
      my ($module, $opt) = @_;
      __load_xs($module, $opt) or return;
  
      my $data = join("", <DATA>); # this code is from Jcode 2.xx.
      close(DATA);
      eval $data;
      JSON::Backend::XS->init($module);
  
      return 1;
  };
  
  
  sub __load_pp {
      my ($module, $opt) = @_;
  
      $JSON::DEBUG and Carp::carp "Load $module.";
      my $required_version = $RequiredVersion{$module} || '';
  
      eval qq| use $module $required_version () |;
  
      if ($@) {
          if ( $module eq 'JSON::PP' ) {
              $JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";
              $module = 'JSON::backportPP';
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $module |;
          }
          Carp::croak $@ if $@;
      }
      $JSON::BackendModulePP = $module;
      return 1;
  }
  
  sub _load_pp {
      my ($module, $opt) = @_;
      __load_pp($module, $opt);
  
      JSON::Backend::PP->init($module);
  };
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      my ($class, $module) = @_;
  
      # name may vary, but the module should (always) be a JSON::PP
  
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::is_bool"} = \&{"JSON::PP::is_bool"};
  
      $JSON::true  = ${"JSON::PP::true"};
      $JSON::false = ${"JSON::PP::false"};
  
      push @JSON::Backend::PP::ISA, 'JSON::PP';
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      for my $method (@XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 0 };
  sub is_pp { 1 };
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  sub init {
      my ($class, $module) = @_;
  
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"$module\::decode_json"};
      *{"JSON::encode_json"} = \&{"$module\::encode_json"};
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::Backend::XS::ISA, $module;
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      if ( $module->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      for my $method (@PPOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 1 };
  sub is_pp { 0 };
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      JSON::__load_pp('JSON::PP');
  
      local $^W;
      no strict qw(refs);
  
      for my $method (@methods) {
          my $pp_method = JSON::PP->can($method) or next;
          *{"JSON::$method"} = sub {
              if (!$_[0]->isa('JSON::PP')) {
                  my $xs_self = $_[0];
                  my $pp_self = JSON::PP->new;
                  for (@Properties) {
                       my $getter = "get_$_";
                      $pp_self->$_($xs_self->$getter);
                  }
                  $_[0] = $pp_self;
              }
              $pp_method->(@_);
          };
      }
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
  
  =head1 VERSION
  
      2.97001
  
  =head1 DESCRIPTION
  
  This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
  additional features. All the backend modules convert a Perl data structure
  to a JSON text as of RFC4627 (which we know is obsolete but we still stick
  to; see below for an option to support part of RFC7159) and vice versa.
  This module uses L<JSON::XS> by default, and when JSON::XS is not available,
  this module falls back on L<JSON::PP>, which is in the Perl core since 5.14.
  If JSON::PP is not available either, this module then falls back on
  JSON::backportPP (which is actually JSON::PP in a different .pm file)
  bundled in the same distribution as this module. You can also explicitly
  specify to use L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban.
  
  All these backend modules have slight incompatibilities between them,
  including extra features that other modules don't support, but as long as you
  use only common features (most important ones are described below), migration
  from backend to backend should be reasonably easy. For details, see each
  backend module you use.
  
  =head1 CHOOSING BACKEND
  
  This module respects an environmental variable called C<PERL_JSON_BACKEND>
  when it decides a backend module to use. If this environmental variable is
  not set, it tries to load JSON::XS, and if JSON::XS is not available, it
  falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
  either.
  
  If you always don't want it to fall back on pure perl modules, set the
  variable like this (C<export> may be C<setenv>, C<set> and the likes,
  depending on your environment):
  
    > export PERL_JSON_BACKEND=JSON::XS
  
  If you prefer Cpanel::JSON::XS to JSON::XS, then:
  
    > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
  
  You may also want to set this variable at the top of your test files, in order
  not to be bothered with incompatibilities between backends (you need to wrap
  this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
  its backend as soon as it's loaded):
  
    BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
    use JSON;
  
  =head1 USING OPTIONAL FEATURES
  
  There are a few options you can set when you C<use> this module:
  
  =over
  
  =item -support_by_pp
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     # escape_slash is for JSON::PP only.
     $json->allow_nonref->escape_slash->encode("/");
  
  With this option, this module loads its pure perl backend along with
  its XS backend (if available), and lets the XS backend to watch if you set
  a flag only JSON::PP supports. When you do, the internal JSON::XS object
  is replaced with a newly created JSON::PP object with the setting copied
  from the XS object, so that you can use JSON::PP flags (and its slower
  C<decode>/C<encode> methods) from then on. In other words, this is not
  something that allows you to hook JSON::XS to change its behavior while
  keeping its speed. JSON::XS and JSON::PP objects are quite different
  (JSON::XS object is a blessed scalar reference, while JSON::PP object is
  a blessed hash reference), and can't share their internals.
  
  To avoid needless overhead (by copying settings), you are advised not
  to use this option and just to use JSON::PP explicitly when you need
  JSON::PP features.
  
  =item -convert_blessed_universally
  
     use JSON -convert_blessed_universally;
  
     my $json = JSON->new->allow_nonref->convert_blessed;
     my $object = bless {foo => 'bar'}, 'Foo';
     $json->encode($object); # => {"foo":"bar"}
  
  JSON::XS-compatible backend modules don't encode blessed objects by
  default (except for their boolean values, which are typically blessed
  JSON::PP::Boolean objects). If you need to encode a data structure
  that may contain objects, you usually need to look into the structure
  and replace objects with alternative non-blessed values, or enable
  C<convert_blessed> and provide a C<TO_JSON> method for each object's
  (base) class that may be found in the structure, in order to let the
  methods replace the objects with whatever scalar values the methods
  return.
  
  If you need to serialise data structures that may contain arbitrary
  objects, it's probably better to use other serialisers (such as
  L<Sereal> or L<Storable> for example), but if you do want to use
  this module for that purpose, C<-convert_blessed_universally> option
  may help, which tweaks C<encode> method of the backend to install
  C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
  all the objects that don't have their own C<TO_JSON> method can
  fall back on the method in the C<UNIVERSAL> namespace. Note that you
  still need to enable C<convert_blessed> flag to actually encode
  objects in a data structure, and C<UNIVERSAL::TO_JSON> method
  installed by this option only converts blessed hash/array references
  into their unblessed clone (including private keys/values that are
  not supposed to be exposed). Other blessed references will be
  converted into null.
  
  This feature is experimental and may be removed in the future.
  
  =item -no_export
  
  When you don't want to import functional interfaces from a module, you
  usually supply C<()> to its C<use> statement.
  
      use JSON (); # no functional interfaces
  
  If you don't want to import functional interfaces, but you also want to
  use any of the above options, add C<-no_export> to the option list.
  
     # no functional interfaces, while JSON::PP support is enabled.
     use JSON -support_by_pp, -no_export;
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS. C<encode_json> and C<decode_json>
  are exported by default.
  
  This module also exports C<to_json> and C<from_json> for backward
  compatibility. These are slower, and may expect/generate different stuff
  from what C<encode_json> and C<decode_json> do, depending on their
  options. It's better just to use Object-Oriented interfaces than using
  these two functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar[, $optional_hashref])
  
  Converts the given Perl data structure to a Unicode string by default.
  Croaks on error.
  
  Basically, this function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Except being slower.
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<to_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
     # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text[, $optional_hashref])
  
  The opposite of C<to_json>: expects a Unicode string and tries
  to parse it, returning the resulting reference. Croaks on error.
  
  Basically, this function call is functionally identical to:
  
      $perl_scalar = JSON->new->decode($json_text)
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<from_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
      # => JSON->new->utf8(1)->decode($json_text)
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON->new
  
  Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the backend object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 ADDITIONAL METHODS
  
  The following methods are for this module only.
  
  =head2 backend
  
      $backend = $json->backend
  
  Since 2.92, C<backend> method returns an abstract backend module used currently,
  which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
  or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
  backend module globally.
  
  If you need to know what is used actually, use C<isa>, instead of string comparison.
  
  =head2 is_xs
  
      $boolean = $json->is_xs
  
  Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
  
  =head2 is_pp
  
      $boolean = $json->is_pp
  
  Returns true if the backend inherits JSON::PP.
  
  =head2 property
  
      $settings = $json->property()
  
  Returns a reference to a hash that holds all the common flag settings.
  
      $json = $json->property('utf8' => 1)
      $value = $json->property('utf8') # 1
  
  You can use this to get/set a value of a particular flag.
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how the backend modules map Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, this module will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, this module only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. This module can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same data structure will
  serialise to the same JSON text (given same settings and version of
  the same backend), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     encode_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: this module will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As for Perl objects, this module only supports a pure JSON representation
  (without the ability to deserialise the object automatically again).
  
  =head3 SERIALISATION
  
  What happens when this module encounters a Perl object depends on the
  C<allow_blessed> and C<convert_blessed> settings, which are used in
  this order:
  
  =over 4
  
  =item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 3. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  this module throws an exception.
  
  =back
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BACKWARD INCOMPATIBILITY
  
  Since version 2.90, stringification (and string comparison) for
  C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
  matter as long as you treat them as boolean values, but a code that
  expects they are stringified as "true" or "false" doesn't work as
  you have expected any more.
  
      if (JSON::true eq 'true') {  # now fails
  
      print "The result is $JSON::true now."; # => The result is 1 now.
  
  And now these boolean values don't inherit JSON::Boolean, either.
  When you need to test a value is a JSON boolean value or not, use
  C<JSON::is_bool> function, instead of testing the value inherits
  a particular boolean class or not.
  
  =head1 BUGS
  
  Please report bugs on backend selection and additional features
  this module provides to RT or GitHub issues for this module:
  
  =over 4
  
  =item https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON
  
  =item https://github.com/makamaka/JSON/issues
  
  =back
  
  Please report bugs and feature requests on decoding/encoding
  and boolean behaviors to the author of the backend module you
  are using.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
  
  L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/MaybeXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_MAYBEXS';
  package JSON::MaybeXS;
  
  use strict;
  use warnings FATAL => 'all';
  use base qw(Exporter);
  
  our $VERSION = '1.004000';
  $VERSION = eval $VERSION;
  
  sub _choose_json_module {
      return 'Cpanel::JSON::XS' if $INC{'Cpanel/JSON/XS.pm'};
      return 'JSON::XS'         if $INC{'JSON/XS.pm'};
  
      my @err;
  
      return 'Cpanel::JSON::XS' if eval { require Cpanel::JSON::XS; 1; };
      push @err, "Error loading Cpanel::JSON::XS: $@";
  
      return 'JSON::XS' if eval { require JSON::XS; 1; };
      push @err, "Error loading JSON::XS: $@";
  
      return 'JSON::PP' if eval { require JSON::PP; 1 };
      push @err, "Error loading JSON::PP: $@";
  
      die join( "\n", "Couldn't load a JSON module:", @err );
  
  }
  
  BEGIN {
      our $JSON_Class = _choose_json_module();
      $JSON_Class->import(qw(encode_json decode_json));
      no strict 'refs';
      *$_ = $JSON_Class->can($_)
        for qw(true false);
  }
  
  our @EXPORT = qw(encode_json decode_json JSON);
  my @EXPORT_ALL = qw(is_bool);
  our @EXPORT_OK = qw(is_bool to_json from_json);
  our %EXPORT_TAGS = ( all => [ @EXPORT, @EXPORT_ALL ],
                       legacy => [ @EXPORT, @EXPORT_OK ],
                     );
  
  sub JSON () { our $JSON_Class }
  
  sub new {
    shift;
    my %args = @_ == 1 ? %{$_[0]} : @_;
    my $new = (our $JSON_Class)->new;
    $new->$_($args{$_}) for keys %args;
    return $new;
  }
  
  use Scalar::Util ();
  
  sub is_bool {
    die 'is_bool is not a method' if $_[1];
  
    Scalar::Util::blessed($_[0])
      and ($_[0]->isa('JSON::XS::Boolean')
        or $_[0]->isa('Cpanel::JSON::XS::Boolean')
        or $_[0]->isa('JSON::PP::Boolean'));
  }
  
  # (mostly) CopyPasta from JSON.pm version 2.90
  use Carp ();
  
  sub from_json ($@) {
      if ( ref($_[0]) =~ /^JSON/ or $_[0] =~ /^JSON/ ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON()->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  sub to_json ($@) {
      if (
          ref($_[0]) =~ /^JSON/
          or (@_ > 2 and $_[0] =~ /^JSON/)
            ) {
                 Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON()->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  1;
  
  =head1 NAME
  
  JSON::MaybeXS - Use L<Cpanel::JSON::XS> with a fallback to L<JSON::XS> and L<JSON::PP>
  
  =head1 SYNOPSIS
  
    use JSON::MaybeXS;
  
    my $data_structure = decode_json($json_input);
  
    my $json_output = encode_json($data_structure);
  
    my $json = JSON()->new;
  
    my $json_with_args = JSON::MaybeXS->new(utf8 => 1); # or { utf8 => 1 }
  
  =head1 DESCRIPTION
  
  This module first checks to see if either L<Cpanel::JSON::XS> or
  L<JSON::XS> is already loaded, in which case it uses that module. Otherwise
  it tries to load L<Cpanel::JSON::XS>, then L<JSON::XS>, then L<JSON::PP>
  in order, and either uses the first module it finds or throws an error.
  
  It then exports the C<encode_json> and C<decode_json> functions from the
  loaded module, along with a C<JSON> constant that returns the class name
  for calling C<new> on.
  
  If you're writing fresh code rather than replacing L<JSON.pm|JSON> usage, you might
  want to pass options as constructor args rather than calling mutators, so
  we provide our own C<new> method that supports that.
  
  =head1 EXPORTS
  
  C<encode_json>, C<decode_json> and C<JSON> are exported by default; C<is_bool>
  is exported on request.
  
  To import only some symbols, specify them on the C<use> line:
  
    use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only
  
    use JSON::MaybeXS qw(JSON); # JSON constant only
  
  To import all available sensible symbols (C<encode_json>, C<decode_json>, and
  C<is_bool>), use C<:all>:
  
    use JSON::MaybeXS ':all';
  
  To import all symbols including those needed by legacy apps that use L<JSON::PP>:
  
    use JSON::MaybeXS ':legacy';
  
  This imports the C<to_json> and C<from_json> symbols as well as everything in
  C<:all>.  NOTE: This is to support legacy code that makes extensive
  use of C<to_json> and C<from_json> which you are not yet in a position to
  refactor.  DO NOT use this import tag in new code, in order to avoid
  the crawling horrors of getting UTF-8 support subtly wrong.  See the
  documentation for L<JSON> for further details.
  
  =head2 encode_json
  
  This is the C<encode_json> function provided by the selected implementation
  module, and takes a perl data structure which is serialised to JSON text.
  
    my $json_text = encode_json($data_structure);
  
  =head2 decode_json
  
  This is the C<decode_json> function provided by the selected implementation
  module, and takes a string of JSON text to deserialise to a perl data structure.
  
    my $data_structure = decode_json($json_text);
  
  =head2 to_json, from_json
  
  See L<JSON> for details.  These are included to support legacy code
  B<only>.
  
  =head2 JSON
  
  The C<JSON> constant returns the selected implementation module's name for
  use as a class name - so:
  
    my $json_obj = JSON()->new; # returns a Cpanel::JSON::XS or JSON::PP object
  
  and that object can then be used normally:
  
    my $data_structure = $json_obj->decode($json_text); # etc.
  
  The use of parentheses here is optional, and only used as a hint to the reader
  that this use of C<JSON> is a I<subroutine> call, I<not> a class name.
  
  =head2 is_bool
  
    $is_boolean = is_bool($scalar)
  
  Returns true if the passed scalar represents either C<true> or
  C<false>, two constants that act like C<1> and C<0>, respectively
  and are used to represent JSON C<true> and C<false> values in Perl.
  
  Since this is a bare sub in the various backend classes, it cannot be called as
  a class method like the other interfaces; it must be called as a function, with
  no invocant.  It supports the representation used in all JSON backends.
  
  =head1 CONSTRUCTOR
  
  =head2 new
  
  With L<JSON::PP>, L<JSON::XS> and L<Cpanel::JSON::XS> you are required to call
  mutators to set options, such as:
  
    my $json = $class->new->utf8(1)->pretty(1);
  
  Since this is a trifle irritating and noticeably un-perlish, we also offer:
  
    my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);
  
  which works equivalently to the above (and in the usual tradition will accept
  a hashref instead of a hash, should you so desire).
  
  The resulting object is blessed into the underlying backend, which offers (at
  least) the methods C<encode> and C<decode>.
  
  =head1 BOOLEANS
  
  To include JSON-aware booleans (C<true>, C<false>) in your data, just do:
  
      use JSON::MaybeXS;
      my $true = JSON()->true;
      my $false = JSON()->false;
  
  The booleans are also available as subs or methods on JSON::MaybeXS.
  
      use JSON::MaybeXS ();
      my $true = JSON::MaybeXS::true;
      my $true = JSON::MaybeXS->true;
      my $false = JSON::MaybeXS::false;
      my $false = JSON::MaybeXS->false;
  
  =head1 CONVERTING FROM JSON::Any
  
  L<JSON::Any> used to be the favoured compatibility layer above the various
  JSON backends, but over time has grown a lot of extra code to deal with legacy
  backends (e.g. L<JSON::Syck>) that are no longer needed.  This is a rough guide of translating such code:
  
  Change code from:
  
      use JSON::Any;
      my $json = JSON::Any->new->objToJson($data);    # or to_json($data), or Dump($data)
  
  to:
  
      use JSON::MaybeXS;
      my $json = encode_json($data);
  
  
  Change code from:
  
      use JSON::Any;
      my $data = JSON::Any->new->jsonToObj($json);    # or from_json($json), or Load($json)
  
  to:
  
      use JSON::MaybeXS;
      my $json = decode_json($data);
  
  =head1 CAVEATS
  
  The C<new()> method in this module is technically a factory, not a
  constructor, because the objects it returns will I<NOT> be blessed into the
  C<JSON::MaybeXS> class.
  
  If you are using an object returned by this module as a Moo(se) attribute,
  this type constraint code:
  
      is 'json' => ( isa => 'JSON::MaybeXS' );
  
  will I<NOT> do what you expect. Instead, either rely on the C<JSON> class
  constant described above, as so:
  
      is 'json' => ( isa => JSON::MaybeXS::JSON() );
  
  Alternatively, you can use duck typing:
  
      use Moose::Util::TypeConstraints 'duck_type';
      is 'json' => ( isa => Object , duck_type([qw/ encode decode /]));
  
  =head1 INSTALLATION
  
  At installation time, F<Makefile.PL> will attempt to determine if you have a
  working compiler available, and therefore whether you are able to run XS code.
  If so, L<Cpanel::JSON::XS> will be added to the prerequisite list, unless
  L<JSON::XS> is already installed at a high enough version. L<JSON::XS> may
  also be upgraded to fix any incompatibility issues.
  
  Because running XS code is not mandatory and L<JSON::PP> (which is in perl
  core) is used as a fallback backend, this module is safe to be used in a suite
  of code that is fatpacked or installed into a restricted-resource environment.
  
  You can also prevent any XS dependencies from being installed by setting
  C<PUREPERL_ONLY=1> in F<Makefile.PL> options (or in the C<PERL_MM_OPT>
  environment variable), or using the C<--pp> or C<--pureperl> flags with the
  L<cpanminus client|cpanm>.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item * Clinton Gormley <drtech@cpan.org>
  
  =item * Karen Etheridge <ether@cpan.org>
  
  =item * Kieren Diment <diment@gmail.com>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2013 the C<JSON::MaybeXS> L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
JSON_MAYBEXS

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  
  use Exporter ();
  BEGIN { @JSON::backportPP::ISA = ('Exporter') }
  
  use overload ();
  use JSON::backportPP::Boolean;
  
  use Carp ();
  #use Devel::Peek;
  
  $JSON::backportPP::VERSION = '2.97001';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  use constant USE_B => 0;
  
  BEGIN {
  if (USE_B) {
      require B;
  }
  }
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enabled?
      # Helper module sets @JSON::PP::_properties.
      if ( OLD_PERL ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $property_id = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      if (defined $_[1] and ref $_[1] eq 'CODE') {
          $_[0]->{cb_object} = $_[1];
      } else {
          delete $_[0]->{cb_object};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ == 1 or @_ > 3) {
          Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)");
      }
      if (defined $_[2] and ref $_[2] eq 'CODE') {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      } else {
          delete $_[0]->{cb_sk_object}->{$_[1]};
          delete $_[0]->{cb_sk_object} unless %{$_[0]->{cb_sk_object} || {}};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
      $_[0]->allow_bignum;
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $props = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$props}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$props->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($props->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
  
                  if ($allow_blessed) {
                      return $self->blessed_to_json($obj) if ($as_nonblessed); # will be removed.
                      return 'null';
                  }
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  );
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, $self->string_to_json( $k )
                            .  $del
                            . ( ref $obj->{$k} ? $self->object_to_json( $obj->{$k} ) : $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '{}' unless @res;
          return '{' . $pre . join( ",$pre", @res ) . $post . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, ref($v) ? $self->object_to_json($v) : $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[]' unless @res;
          return '[' . $pre . join( ",$pre", @res ) . $post . ']';
      }
  
      sub _looks_like_number {
          my $value = shift;
          if (USE_B) {
              my $b_obj = B::svref_2object(\$value);
              my $flags = $b_obj->FLAGS;
              return 1 if $flags & ( B::SVp_IOK() | B::SVp_NOK() ) and !( $flags & B::SVp_POK() );
              return;
          } else {
              no warnings 'numeric';
              # if the utf8 flag is on, it almost certainly started as a string
              return if utf8::is_utf8($value);
              # detect numbers
              # string & "" -> ""
              # number & "" -> 0 (with warning)
              # nan and inf can detect as numbers, so check with * 0
              return unless length((my $dummy = "") & $value);
              return unless 0 + $value eq $value;
              return 1 if $value * 0 == 0;
              return -1; # inf/nan
          }
      }
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $type = ref($value);
  
          if (!$type) {
              if (_looks_like_number($value)) {
                  return $value;
              }
              return $self->string_to_json($value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          else {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
              if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                  return 'null';
              }
              else {
                  if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                  }
                  else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                  }
              }
  
          }
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # first character
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bignum;   # using Math::BigInt/BigFloat
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      sub _detect_utf_encoding {
          my $text = shift;
          my @octets = unpack('C4', $text);
          return 'unknown' unless defined $octets[3];
          return ( $octets[0] and  $octets[1]) ? 'UTF-8'
               : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
               : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
               : ( $octets[2]                ) ? 'UTF-16LE'
               : (!$octets[2]                ) ? 'UTF-32LE'
               : 'unknown';
      }
  
      sub PP_decode_json {
          my ($self, $want_offset);
  
          ($self, $text, $want_offset) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $props = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bignum, $allow_barekey, $singlequote)
              = @{$props}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              $encoding = _detect_utf_encoding($text);
              if ($encoding ne 'UTF-8' and $encoding ne 'unknown') {
                  require Encode;
                  Encode::from_to($text, $encoding, 'utf-8');
              } else {
                  utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
              }
          }
          else {
              utf8::upgrade( $text );
              utf8::encode( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          white(); # remove head white space
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          if ( !$props->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          return ( $result, $consumed ) if $want_offset; # all right if decode_prefix
  
          decode_error("garbage after JSON object") if defined $ch;
  
          $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          my $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          unless( $ch = is_valid_utf8($ch) ) {
                              $at -= 1;
                              decode_error("malformed UTF-8 character in JSON string");
                          }
                          else {
                              $at += $utf8_len - 1;
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){
                  next_chr();
              }
              elsif($relaxed and $ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
          my $is_dec;
          my $is_exp;
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              if($peek =~ /^[0-9a-dfA-DF]/){ # e may be valid (exponential)
                  decode_error("malformed number (leading zero must not be followed by another digit)");
              }
              $n .= $ch;
              next_chr;
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
              $is_dec = 1;
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              $is_exp = 1;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($is_dec or $is_exp) {
              if ($allow_bignum) {
                  require Math::BigFloat;
                  return Math::BigFloat->new($v);
              }
          } else {
              if (length $v > $max_intsize) {
                  if ($allow_bignum) { # from Adam Sussman
                      require Math::BigInt;
                      return Math::BigInt->new($v);
                  }
                  else {
                      return "$v";
                  }
              }
          }
  
          return $is_dec ? $v/1.0 : 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = 'U*';
  
          if ( OLD_PERL ) {
              my $type   =  $] <  5.006           ? 'C*'
                          : utf8::is_utf8( $str ) ? 'U*' # 5.6
                          : 'C*'
                          ;
          }
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( !OLD_PERL ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
          if ($] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
              package # hide from PAUSE
                JSON::PP;
              require subs;
              subs->import('join');
              eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |;
          }
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          require B;
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { blessed $_[0] and $_[0]->isa("JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::backportPP::IncrParser::VERSION = '1.01';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_pos     => 0,
          incr_mode    => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
      if ( defined wantarray ) {
          my $max_size = $coder->get_max_size;
          my $p = $self->{incr_pos};
          my @ret;
          {
              do {
                  unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->_incr_parse( $coder );
  
                      if ( $max_size and $self->{incr_pos} > $max_size ) {
                          Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size");
                      }
                      unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                          # as an optimisation, do not accumulate white space in the incr buffer
                          if ( $self->{incr_mode} == INCR_M_WS and $self->{incr_pos} ) {
                              $self->{incr_pos} = 0;
                              $self->{incr_text} = '';
                          }
                          last;
                      }
                  }
  
                  my ($obj, $offset) = $coder->PP_decode_json( $self->{incr_text}, 0x00000001 );
                  push @ret, $obj;
                  use bytes;
                  $self->{incr_text} = substr( $self->{incr_text}, $offset || 0 );
                  $self->{incr_pos} = 0;
                  $self->{incr_nest} = 0;
                  $self->{incr_mode} = 0;
                  last unless wantarray;
              } while ( wantarray );
          }
  
          if ( wantarray ) {
              return @ret;
          }
          else { # in scalar context
              return $ret[0] ? $ret[0] : undef;
          }
      }
  }
  
  
  sub _incr_parse {
      my ($self, $coder) = @_;
      my $text = $self->{incr_text};
      my $len = length $text;
      my $p = $self->{incr_pos};
  
  INCR_PARSE:
      while ( $len > $p ) {
          my $s = substr( $text, $p, 1 );
          last INCR_PARSE unless defined $s;
          my $mode = $self->{incr_mode};
  
          if ( $mode == INCR_M_WS ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( ord($s) > 0x20 ) {
                      if ( $s eq '#' ) {
                          $self->{incr_mode} = INCR_M_C0;
                          redo INCR_PARSE;
                      } else {
                          $self->{incr_mode} = INCR_M_JSON;
                          redo INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_BS ) {
              $p++;
              $self->{incr_mode} = INCR_M_STR;
              redo INCR_PARSE;
          } elsif ( $mode == INCR_M_C0 or $mode == INCR_M_C1 ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq "\n" ) {
                      $self->{incr_mode} = $self->{incr_mode} == INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;
                      last;
                  }
                  $p++;
              }
              next;
          } elsif ( $mode == INCR_M_STR ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq '"' ) {
                      $p++;
                      $self->{incr_mode} = INCR_M_JSON;
  
                      last INCR_PARSE unless $self->{incr_nest};
                      redo INCR_PARSE;
                  }
                  elsif ( $s eq '\\' ) {
                      $p++;
                      if ( !defined substr($text, $p, 1) ) {
                          $self->{incr_mode} = INCR_M_BS;
                          last INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_JSON ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p++, 1 );
                  if ( $s eq "\x00" ) {
                      $p--;
                      last INCR_PARSE;
                  } elsif ( $s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20" ) {
                      if ( !$self->{incr_nest} ) {
                          $p--; # do not eat the whitespace, let the next round do it
                          last INCR_PARSE;
                      }
                      next;
                  } elsif ( $s eq '"' ) {
                      $self->{incr_mode} = INCR_M_STR;
                      redo INCR_PARSE;
                  } elsif ( $s eq '[' or $s eq '{' ) {
                      if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                          Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                      }
                      next;
                  } elsif ( $s eq ']' or $s eq '}' ) {
                      if ( --$self->{incr_nest} <= 0 ) {
                          last INCR_PARSE;
                      }
                  } elsif ( $s eq '#' ) {
                      $self->{incr_mode} = INCR_M_C1;
                      redo INCR_PARSE;
                  }
              }
          }
      }
  
      $self->{incr_pos} = $p;
      $self->{incr_parsing} = $p ? 1 : 0; # for backward compatibility
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_pos} ) {
          Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_pos} );
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $json = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $pretty_printed_json_text = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.97001
  
  =head1 DESCRIPTION
  
  JSON::PP is a pure perl JSON decoder/encoder (as of RFC4627, which
  we know is obsolete but we still stick to; see below for an option
  to support part of RFC7159), and (almost) compatible to much
  faster L<JSON::XS> written by Marc Lehmann in C. JSON::PP works as
  a fallback module when you use L<JSON> module without having
  installed JSON::XS.
  
  Because of this fallback feature of JSON.pm, JSON::PP tries not to
  be more JavaScript-friendly than JSON::XS (i.e. not to escape extra
  characters such as U+2028 and U+2029 nor support RFC7159/ECMA-404),
  in order for you not to lose such JavaScript-friendliness silently
  when you use JSON.pm and install JSON::XS for speed or by accident.
  If you need JavaScript-friendly RFC7159-compliant pure perl module,
  try L<JSON::Tiny>, which is derived from L<Mojolicious> web
  framework and is also smaller and faster than JSON::PP.
  
  JSON::PP has been in the Perl core since Perl 5.14, mainly for
  CPAN toolchain modules to parse META.json.
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS almost verbatim. C<encode_json>
  and C<decode_json> are exported by default.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Creates a new JSON::PP object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON::PP object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::PP->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =item * C-style multiple-line '/* */'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C-style multiple-line comments are additionally
  allowed. Everything between C</*> and C<*/> is a comment, after which
  more white-space and comments are allowed.
  
    [
       1, /* this comment not allowed in JSON */
          /* neither this one... */
    ]
  
  =item * C++-style one-line '//'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C++-style one-line comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, // this comment not allowed in JSON
          // neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk (i.e. downgraded if possible).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is false, then JSON::PP does nothing.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::PP->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 FLAGS FOR JSON::PP ONLY
  
  The following flags and properties are for JSON::PP only. If you use
  any of these, you can't make your application run faster by replacing
  JSON::PP with JSON::XS. If you need these and also speed boost,
  try L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban, which
  supports some of these.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
      $enabled = $json->get_allow_singlequote
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain strings that begin and end with
  single quotation marks. C<encode> will not be affected in anyway.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_singlequote->decode(qq|{"foo":'bar'}|);
      $json->allow_singlequote->decode(qq|{'foo':"bar"}|);
      $json->allow_singlequote->decode(qq|{'foo':'bar'}|);
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
      $enabled = $json->get_allow_barekey
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain JSON objects whose names don't
  begin and end with quotation marks. C<encode> will not be affected
  in anyway. I<Be aware that this option makes you accept invalid JSON
  texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_barekey->decode(qq|{foo:"bar"}|);
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
      $enabled = $json->get_allow_bignum
  
  If C<$enable> is true (or missing), then C<decode> will convert
  big integers Perl cannot handle as integer into L<Math::BigInt>
  objects and convert floating numbers into L<Math::BigFloat>
  objects. C<encode> will convert C<Math::BigInt> and C<Math::BigFloat>
  objects into JSON numbers.
  
     $json->allow_nonref->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See also L<MAPPING>.
  
  =head2 loose
  
      $json = $json->loose([$enable])
      $enabled = $json->get_loose
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c]
  characters. C<encode> will not be affected in anyway.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
      $enabled = $json->get_escape_slash
  
  If C<$enable> is true (or missing), then C<encode> will explicitly
  escape I<slash> (solidus; C<U+002F>) characters to reduce the risk of
  XSS (cross site scripting) that may be caused by C<< </script> >>
  in a JSON text, with the cost of bloating the size of JSON texts.
  
  This option may be useful when you embed JSON in HTML, but embedding
  arbitrary JSON in HTML (by some HTML template toolkit or by string
  interpolation) is risky in general. You must escape necessary
  characters in correct order, depending on the context.
  
  C<decode> will not be affected in anyway.
  
  =head2 indent_length
  
      $json = $json->indent_length($number_of_spaces)
      $length = $json->get_indent_length
  
  This option is only useful when you also enable C<indent> or C<pretty>.
  
  JSON::XS indents with three spaces when you C<encode> (if requested
  by C<indent> or C<pretty>), and the number cannot be changed.
  JSON::PP allows you to change/get the number of indent spaces with these
  mutator/accessor. The default number of spaces is three (the same as
  JSON::XS), and the acceptable range is from C<0> (no indentation;
  it'd be better to disable indentation by C<indent(0)>) to C<15>.
  
  =head2 sort_by
  
      $json = $json->sort_by($code_ref)
      $json = $json->sort_by($subroutine_name)
  
  If you just want to sort keys (names) in JSON objects when you
  C<encode>, enable C<canonical> option (see above) that allows you to
  sort object keys alphabetically.
  
  If you do need to sort non-alphabetically for whatever reasons,
  you can give a code reference (or a subroutine name) to C<sort_by>,
  then the argument will be passed to Perl's C<sort> built-in function.
  
  As the sorting is done in the JSON::PP scope, you usually need to
  prepend C<JSON::PP::> to the subroutine name, and the special variables
  C<$a> and C<$b> used in the subrontine used by C<sort> function.
  
  Example:
  
     my %ORDER = (id => 1, class => 2, name => 3);
     $json->sort_by(sub {
         ($ORDER{$JSON::PP::a} // 999) <=> ($ORDER{$JSON::PP::b} // 999)
         or $JSON::PP::a cmp $JSON::PP::b
     });
     print $json->encode([
         {name => 'CPAN', id => 1, href => 'http://cpan.org'}
     ]);
     # [{"id":1,"name":"CPAN","href":"http://cpan.org"}]
  
  Note that C<sort_by> affects all the plain hashes in the data structure.
  If you need finer control, C<tie> necessary hashes with a module that
  implements ordered hash (such as L<Hash::Ordered> and L<Tie::IxHash>).
  C<canonical> and C<sort_by> don't affect the key order in C<tie>d
  hashes.
  
     use Hash::Ordered;
     tie my %hash, 'Hash::Ordered',
         (name => 'CPAN', id => 1, href => 'http://cpan.org');
     print $json->encode([\%hash]);
     # [{"name":"CPAN","id":1,"href":"http://cpan.org"}] # order is kept
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::PP will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON::PP->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how JSON::PP maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::PP will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::PP only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enabled, big integer values and any numeric
  values will be converted into L<Math::BigInt> and L<Math::BigFloat>
  objects respectively, without becoming string scalars or losing
  precision.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::PP::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::PP can optionally sort the hash keys
  (determined by the I<canonical> flag and/or I<sort_by> property), so
  the same data structure will serialise to the same JSON text (given
  same settings and version of JSON::PP), but this incurs a runtime
  overhead and is only rarely useful, e.g. when you want to compare some
  JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::PP::false> and C<JSON::PP::true> to improve
  readability.
  
     to_json [\0, JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item JSON::PP::null
  
  This special value becomes JSON null.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::PP>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
                  # (but for older perls)
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You cannot currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON::PP (and JSON::XS) trusts what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON::PP considers tainted and
  doesn't trust). As JSON::PP doesn't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As for Perl objects, JSON::PP only supports a pure JSON representation (without the ability to deserialise the object automatically again).
  
  =head3 SERIALISATION
  
  What happens when C<JSON::PP> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_bignum> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<allow_bignum> is enabled and the object is a C<Math::BigInt> or C<Math::BigFloat>.
  
  The object will be serialised as a JSON number value.
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::PP> throws an exception.
  
  =back
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 SEE ALSO
  
  The F<json_pp> command line utility for quick experiments.
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, and L<JSON::Tiny> for faster alternatives.
  L<JSON> and L<JSON::MaybeXS> for easy migration.
  
  L<JSON::backportPP::Compat5005> and L<JSON::backportPP::Compat5006> for older perl users.
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2016 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  package # This is JSON::backportPP
      JSON::PP::Boolean;
  
  use strict;
  use overload (
      "0+"     => sub { ${$_[0]} },
      "++"     => sub { $_[0] = ${$_[0]} + 1 },
      "--"     => sub { $_[0] = ${$_[0]} - 1 },
      fallback => 1,
  );
  
  $JSON::backportPP::Boolean::VERSION = '2.97001';
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP';
  package LWP;
  
  our $VERSION = '6.34';
  
  require LWP::UserAgent;  # this should load everything you need
  
  sub Version { $VERSION; }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to C<http>, C<https>, C<gopher>,
  C<ftp>, C<news>, C<file>, and C<mailto> resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/Protocols/>:
  
  =over 3
  
  =item *
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name L<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send L<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  B<headers> contains additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name L<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  B<headers> contains additional information about the
  response and describe the content.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is L<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an L<HTTP::Request> object as
  argument and (eventually) returns a L<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  B<agent> specifies the name that your application uses when it
  presents itself on the network.
  
  =item *
  
  B<from> can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  B<proxy> and B<no_proxy> specify if and when to go through
  a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
  
  =item *
  
  B<credentials> provides a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  L<LWP::UserAgent>.  The library includes a
  sub-class, L<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The L<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the C<MDTM> command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-download>, L<lwp-dump>
  and L<lwp-mirror> are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The L<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_ENV_PROXY
  
  If set to a TRUE value, then the L<LWP::UserAgent> will by default call
  C<env_proxy> during initialization.  This makes LWP honor the proxy variables
  described above.
  
  =item PERL_LWP_SSL_VERIFY_HOSTNAME
  
  The default C<verify_hostname> setting for L<LWP::UserAgent>.  If
  not set the default will be 1.  Set it as 0 to disable hostname
  verification (the default prior to libwww-perl 5.840.
  
  =item PERL_LWP_SSL_CA_FILE
  
  =item PERL_LWP_SSL_CA_PATH
  
  The file and/or directory
  where the trusted Certificate Authority certificates
  is located.  See L<LWP::UserAgent> for details.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is L<URI>.
  You might want to set it to L<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas König,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krüger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip Guenther, Daniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skyttä, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/libwww-perl/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  
  use strict;
  
  our $VERSION = '6.34';
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  
  use strict;
  use base 'LWP::Authen::Basic';
  
  our $VERSION = '6.34';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  
  	# RFC2617 says that qop-value and nc-value should be unquoted.
  	if ( $_ eq 'qop' || $_ eq 'nc' ) {
  		push(@pairs, "$_=" . $resp{$_});
  	}
  	else {
  		push(@pairs, "$_=" . qq("$resp{$_}"));
  	}
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  
  our $VERSION = '6.34';
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate');
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) {
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) {
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  L<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an
  entirely different interface, it is necessary to ensure that you have the correct
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is
  necessary to ensure that your Mime::Base64 module supports exporting of the
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your
  code.  The LWP system will invoke the NTLM authentication when it encounters the
  authentication scheme while attempting to retrieve a URL from a server.  In order
  for the NTLM authentication to work, you must have a few things set up in your
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
  
  =cut
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  
  our $VERSION = '6.34';
  our $DEBUG;
  
  sub new {
      my($class, %cnf) = @_;
  
      my $total_capacity = 1;
      if (exists $cnf{total_capacity}) {
          $total_capacity = delete $cnf{total_capacity};
      }
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for L<LWP::UserAgent>.
  
  =head1 METHODS
  
  The following basic methods are provided:
  
  =head2 new
  
      my $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new L<LWP::ConnCache> object.  The only
  option currently accepted is C<total_capacity>.  If specified it
  initialize the L<LWP::ConnCache/total_capacity> option. It defaults to C<1>.
  
  =head2 total_capacity
  
      my $cap = $cache->total_capacity;
      $cache->total_capacity(0); # drop all immediately
      $cache->total_capacity(undef); # no limit
      $cache->total_capacity($number);
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =head2 capacity
  
      my $http_capacity = $cache->capacity('http');
      $cache->capacity('http', 2 );
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The first parameter is a short string like
  "http" or "ftp".
  
  =head2 drop
  
      $cache->drop(); # Drop ALL connections
      # which is just a synonym for:
      $cache->drop(sub{1}); # Drop ALL connections
      # drop all connections older than 22 seconds and add a reason for it!
      $cache->drop(22, "Older than 22 secs dropped");
      # which is just a synonym for:
      $cache->drop(sub {
          my ($conn, $type, $key, $deposit_time) = @_;
          if ($deposit_time < 22) {
              # true values drop the connection
              return 1;
          }
          # false values don't drop the connection
          return 0;
      }, "Older than 22 secs dropped" );
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The C<reason> is passed on to the L<LWP::ConnCache/dropped> method.
  
  =head2 prune
  
      $cache->prune();
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the L<LWP::ConnCache/ping> method on the connections. If
  the L<LWP::ConnCache/ping> method exists and returns a false value, then the
  connection is dropped.
  
  =head2 get_types
  
      my @types = $cache->get_types();
  
  This returns all the C<type> fields used for the currently cached
  connections.
  
  =head2 get_connections
  
      my @conns = $cache->get_connections(); # all connections
      my @conns = $cache->get_connections('http'); # connections for http
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =head1 PROTOCOL METHODS
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =head2 deposit
  
      $cache->deposit($type, $key, $conn);
  
  This method adds a new connection to the cache.  As a result, other
  already cached connections might be dropped.  Multiple connections with
  the same type/key might be added.
  
  =head2 withdraw
  
      my $conn = $cache->withdraw($type, $key);
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =head1 INTERNAL METHODS
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =head2 enforce_limits
  
      $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =head2 dropping
  
      $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  C<$LWP::ConnCache::DEBUG> variable is set and nothing more.
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the L<LWP::ConnCache/deposit>,
  L<LWP::ConnCache/enforce_limits>, and L<LWP::ConnCache/dropping> methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG';
  package LWP::Debug;    # legacy
  
  our $VERSION = '6.34';
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  our %current_level = ();
  
  sub import {
      my $pack    = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels  = ();
      for (@_) {
          if (/^[-+]/) {
              push(@levels, $_);
          }
          else {
              push(@symbols, $_);
          }
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  sub level {
      for (@_) {
          if ($_ eq '+') {    # all on
                              # switch on all levels
              %current_level = map { $_ => 1 } @levels;
          }
          elsif ($_ eq '-') {    # all off
              %current_level = ();
          }
          elsif (/^([-+])(\w+)$/) {
              $current_level{$2} = $1 eq '+';
          }
          else {
              Carp::croak("Illegal level format $_");
          }
      }
  }
  
  sub trace { _log(@_) if $current_level{'trace'}; }
  sub debug { _log(@_) if $current_level{'debug'}; }
  sub conns { _log(@_) if $current_level{'conns'}; }
  
  sub _log {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;    # ensure trailing "\n"
  
      my ($package, $filename, $line, $sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  This module has been deprecated.  Please see L<LWP::ConsoleLogger> for your
  debugging needs.
  
  LWP::Debug is used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happens to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provides some hints about recommended replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The
  L<WireShark|http://www.wireshark.org/> program is highly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::ConsoleLogger>, L<LWP::ConsoleLogger::Everywhere>, L<LWP::UserAgent>
  
  =cut
LWP_DEBUG

$fatpacked{"LWP/Debug/TraceHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG_TRACEHTTP';
  package LWP::Debug::TraceHTTP;
  
  # Just call:
  #
  #   require LWP::Debug::TraceHTTP;
  #   LWP::Protocol::implementor('http', 'LWP::Debug::TraceHTTP');
  #
  # to use this module to trace all calls to the HTTP socket object in
  # programs that use LWP.
  
  use strict;
  use base 'LWP::Protocol::http';
  
  our $VERSION = '6.34';
  
  package # hide from PAUSE
      LWP::Debug::TraceHTTP::Socket;
  
  use Data::Dump 1.13;
  use Data::Dump::Trace qw(autowrap mcall);
  
  autowrap("LWP::Protocol::http::Socket" => "sock");
  
  sub new {
      my $class = shift;
      return mcall("LWP::Protocol::http::Socket" => "new", undef, @_);
  }
  
  1;
LWP_DEBUG_TRACEHTTP

$fatpacked{"LWP/DebugFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  
  our $VERSION = '6.34';
  
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MemberMixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  
  our $VERSION = '6.34';
  
  sub _elem {
      my $self = shift;
      my $elem = shift;
      my $old  = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   use base qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the C<%$self>.
  Ideally there should be better Perl language support for this.
  
  =head1 METHODS
  
  There is only one method provided:
  
  =head2 _elem
  
      _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =cut
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  use base 'LWP::MemberMixin';
  
  our $VERSION = '6.34';
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response ();
  use Try::Tiny qw(try catch);
  
  my %ImplementedBy = (); # scheme => classname
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ tr/.+-/_/;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # try to autoload it
          try {
              (my $class = $ic) =~ s{::}{/}g;
              $class .= '.pm' unless $class =~ /\.pm$/;
              require $class;
          }
          catch {
              my $error = $_;
              if ($error =~ /Can't locate/) {
                  $ic = '';
              }
              else {
                  die "$error\n";
              }
          };
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      try {
          local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      }
      catch {
          my $error = $_;
          chomp($error);
          $response->push_header('X-Died' => $error);
          $response->push_header("Client-Aborted", "die");
      };
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   use base qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used as the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialized subclass
  appropriate for that access method. In other words, the
  L<LWP::Protocol/create> function calls the constructor for one of its
  subclasses.
  
  All derived C<LWP::Protocol> classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  =head1 METHODS
  
  The following methods and functions are provided:
  
  =head2 new
  
      my $prot = LWP::Protocol->new();
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =head2 create
  
      my $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =head2 implementor
  
      my $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns C<''> if the
  specified scheme is not supported.
  
  =head2 request
  
      $response = $protocol->request($request, $proxy, undef);
      $response = $protocol->request($request, $proxy, '/tmp/sss');
      $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =head2 collect
  
      my $res = $prot->collect(undef, $response, $collector); # stored in $response
      my $res = $prot->collect($filename, $response, $collector);
      my $res = $prot->collect(sub { ... }, $response, $collector);
  
  Collect the content of a request, and process it appropriately into a scalar,
  file, or by calling a callback. If the first parameter is undefined, then the
  content is stored within the C<$response>. If it's a simple scalar, then it's
  interpreted as a file name and the content is written to this file.  If it's a
  code reference, then content is passed to this routine.
  
  The collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The C<$collector> signals C<EOF> by returning a reference to an
  empty string.
  
  The return value is the L<HTTP::Response> object reference.
  
  B<Note:> We will only use the callback or file argument if
  C<< $response->is_success() >>.  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =head2 collect_once
  
      $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as content. This
  will invoke L<LWP::Protocol/collect> with a collector callback that
  returns a reference to C<$content> the first time and an empty string the
  next.
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/cpan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  
  use strict;
  
  use base qw(LWP::Protocol);
  
  our $VERSION = '6.34';
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  
  our $VERSION = '6.34';
  
  require HTTP::Response;
  require HTTP::Status;
  
  use base qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  
  use base qw(LWP::Protocol);
  
  use strict;
  
  our $VERSION = '6.34';
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(my $fh, '<', $path) or return new
  	    HTTP::Response(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode($fh);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread($fh, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close($fh);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  use base qw(LWP::Protocol);
  use strict;
  
  our $VERSION = '6.34';
  
  use Carp            ();
  use HTTP::Status    ();
  use HTTP::Negotiate ();
  use HTTP::Response  ();
  use LWP::MediaTypes ();
  use File::Listing   ();
  
  
  {
  
      package # hide from PAUSE
          LWP::Protocol::MyFTP;
  
      use strict;
      use base qw(Net::FTP);
  
      sub new {
          my $class = shift;
  
          my $self = $class->SUPER::new(@_) || return undef;
  
          my $mess = $self->message;    # welcome message
          $mess =~ s|\n.*||s;           # only first line left
          $mess =~ s|\s*ready\.?$||;
  
          # Make the version number more HTTP like
          $mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
          ${*$self}{myftp_server} = $mess;
  
          #$response->header("Server", $mess);
  
          $self;
      }
  
      sub http_server {
          my $self = shift;
          ${*$self}{myftp_server};
      }
  
      sub home {
          my $self = shift;
          my $old  = ${*$self}{myftp_home};
          if (@_) {
              ${*$self}{myftp_home} = shift;
          }
          $old;
      }
  
      sub go_home {
          my $self = shift;
          $self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
          my $self = shift;
          ++${*$self}{myftp_reqcount};
      }
  
      sub ping {
          my $self = shift;
          return $self->go_home;
      }
  }
  
  sub _connect {
      my ($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
          $key = "$host:$port:$user";
          $key .= ":$account" if defined($account);
          if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
              if ($ftp->ping) {
  
                  # save it again
                  $conn_cache->deposit("ftp", $key, $ftp);
                  return $ftp;
              }
          }
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new(
          $host,
          Port      => $port,
          Timeout   => $timeout,
          LocalAddr => $self->{ua}{local_address},
      );
  
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
          $@ =~ s/^Net::FTP: //;
          return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  
          # Unauthorized.  Let's fake a RC_UNAUTHORIZED response
          my $mess = scalar($ftp->message);
          $mess =~ s/\n$//;
          my $res = HTTP::Response->new(HTTP::Status::RC_UNAUTHORIZED, $mess);
          $res->header("Server",           $ftp->http_server);
          $res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
          return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request {
      my ($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
          my $scheme = $url->scheme;
          return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
              "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              'Library does not allow method ' . "$method for 'ftp:' URLs");
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic authorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
          my ($u, $p) = $request->authorization_basic;
          if (defined $u) {
              $user     = $u;
              $password = $p;
          }
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp
          = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response";    # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(HTTP::Status::RC_OK, "OK");
      $response->header(Server               => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path = grep {length} $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
          my @params;
          ($remote_file, @params) = @$remote_file;
          for (@params) {
              $type = $_ if s/^type=//;
          }
      }
  
      if ($type && $type eq 'a') {
          $ftp->ascii;
      }
      else {
          $ftp->binary;
      }
  
      for (@path) {
          unless ($ftp->cwd($_)) {
              return HTTP::Response->new(HTTP::Status::RC_NOT_FOUND,
                  "Can't chdir to $_");
          }
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
          if (my $mod_time = $ftp->mdtm($remote_file)) {
              $response->last_modified($mod_time);
              if (my $ims = $request->if_modified_since) {
                  if ($mod_time <= $ims) {
                      $response->code(HTTP::Status::RC_NOT_MODIFIED);
                      $response->message("Not modified");
                      return $response;
                  }
              }
          }
  
          # We'll use this later to abort the transfer if necessary.
          # if $max_size is defined, we need to abort early. Otherwise, it's
          # a normal transfer
          my $max_size = undef;
  
          # Set resume location, if the client requested it
          if ($request->header('Range') && $ftp->supported('REST')) {
              my $range_info = $request->header('Range');
  
              # Change bytes=2772992-6781209 to just 2772992
              my ($start_byte, $end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
              if (defined $start_byte && !defined $end_byte) {
  
                  # open range -- only the start is specified
  
                  $ftp->restart($start_byte);
  
                  # don't define $max_size, we don't want to abort early
              }
              elsif (defined $start_byte
                  && defined $end_byte
                  && $start_byte >= 0
                  && $end_byte >= $start_byte)
              {
  
                  $ftp->restart($start_byte);
                  $max_size = $end_byte - $start_byte;
              }
              else {
  
                  return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
                      'Incorrect syntax for Range request');
              }
          }
          elsif ($request->header('Range') && !$ftp->supported('REST')) {
              return HTTP::Response->new(HTTP::Status::RC_NOT_IMPLEMENTED,
                  "Server does not support resume."
              );
          }
  
          my $data;    # the data handle
          if (length($remote_file) and $data = $ftp->retr($remote_file)) {
              my ($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
              $response->header('Content-Type', $type) if $type;
              for (@enc) {
                  $response->push_header('Content-Encoding', $_);
              }
              my $mess = $ftp->message;
              if ($mess =~ /\((\d+)\s+bytes\)/) {
                  $response->header('Content-Length', "$1");
              }
  
              if ($method ne 'HEAD') {
  
                  # Read data from server
                  $response = $self->collect(
                      $arg,
                      $response,
                      sub {
                          my $content = '';
                          my $result = $data->read($content, $size);
  
                          # Stop early if we need to.
                          if (defined $max_size) {
  
                          # We need an interface to Net::FTP::dataconn for getting
                          # the number of bytes already read
                              my $bytes_received = $data->bytes_read();
  
                             # We were already over the limit. (Should only happen
                             # once at the end.)
                              if ($bytes_received - length($content) > $max_size)
                              {
                                  $content = '';
                              }
  
                              # We just went over the limit
                              elsif ($bytes_received > $max_size) {
  
                                  # Trim content
                                  $content = substr($content, 0,
                                      $max_size
                                          - ($bytes_received - length($content)));
                              }
  
                              # We're under the limit
                              else {
                              }
                          }
  
                          return \$content;
                      }
                  );
              }
  
              # abort is needed for HEAD, it's == close if the transfer has
              # already completed.
              unless ($data->abort) {
  
                  # Something did not work too well.  Note that we treat
                  # responses to abort() with code 0 in case of HEAD as ok
                  # (at least wu-ftpd 2.6.1(1) does that).
                  if ($method ne 'HEAD' || $ftp->code != 0) {
                      $response->code(HTTP::Status::RC_INTERNAL_SERVER_ERROR);
                      $response->message("FTP close response: "
                              . $ftp->code . " "
                              . $ftp->message);
                  }
              }
          }
          elsif (!length($remote_file) || ($ftp->code >= 400 && $ftp->code < 600))
          {
              # not a plain file, try to list instead
              if (length($remote_file) && !$ftp->cwd($remote_file)) {
                  return HTTP::Response->new(HTTP::Status::RC_NOT_FOUND,
                      "File '$remote_file' not found"
                  );
              }
  
              # It should now be safe to try to list the directory
              my @lsl = $ftp->dir;
  
              # Try to figure out if the user want us to convert the
              # directory listing to HTML.
              my @variants = (
                  ['html', 0.60, 'text/html'],
                  ['dir',  1.00, 'text/ftp-dir-listing']
              );
  
              #$HTTP::Negotiate::DEBUG=1;
              my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
              my $content = '';
  
              if (!defined($prefer)) {
                  return HTTP::Response->new(HTTP::Status::RC_NOT_ACCEPTABLE,
                      "Neither HTML nor directory listing wanted");
              }
              elsif ($prefer eq 'html') {
                  $response->header('Content-Type' => 'text/html');
                  $content = "<HEAD><TITLE>File Listing</TITLE>\n";
                  my $base = $request->uri->clone;
                  my $path = $base->path;
                  $base->path("$path/") unless $path =~ m|/$|;
                  $content .= qq(<BASE HREF="$base">\n</HEAD>\n);
                  $content .= "<BODY>\n<UL>\n";
                  for (File::Listing::parse_dir(\@lsl, 'GMT')) {
                      my ($name, $type, $size, $mtime, $mode) = @$_;
                      $content .= qq(  <LI> <a href="$name">$name</a>);
                      $content .= " $size bytes" if $type eq 'f';
                      $content .= "\n";
                  }
                  $content .= "</UL></body>\n";
              }
              else {
                  $response->header('Content-Type', 'text/ftp-dir-listing');
                  $content = join("\n", @lsl, '');
              }
  
              $response->header('Content-Length', length($content));
  
              if ($method ne 'HEAD') {
                  $response = $self->collect_once($arg, $response, $content);
              }
          }
          else {
              my $res = HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
                  "FTP return code " . $ftp->code);
              $res->content_type("text/plain");
              $res->content($ftp->message);
              return $res;
          }
      }
      elsif ($method eq 'PUT') {
  
          # method must be PUT
          unless (length($remote_file)) {
              return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
                  "Must have a file name to PUT to"
              );
          }
          my $data;
          if ($data = $ftp->stor($remote_file)) {
              my $content = $request->content;
              my $bytes   = 0;
              if (defined $content) {
                  if (ref($content) eq 'SCALAR') {
                      $bytes = $data->write($$content, length($$content));
                  }
                  elsif (ref($content) eq 'CODE') {
                      my ($buf, $n);
                      while (length($buf = &$content)) {
                          $n = $data->write($buf, length($buf));
                          last unless $n;
                          $bytes += $n;
                      }
                  }
                  elsif (!ref($content)) {
                      if (defined $content && length($content)) {
                          $bytes = $data->write($content, length($content));
                      }
                  }
                  else {
                      die "Bad content";
                  }
              }
              $data->close;
  
              $response->code(HTTP::Status::RC_CREATED);
              $response->header('Content-Type', 'text/plain');
              $response->content("$bytes bytes stored as $remote_file on $host\n")
  
          }
          else {
              my $res = HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
                  "FTP return code " . $ftp->code);
              $res->content_type("text/plain");
              $res->content($ftp->message);
              return $res;
          }
      }
      else {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  
  our $VERSION = '6.34';
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  use base qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
  
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ tr/\015//d;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  
  use strict;
  
  our $VERSION = '6.34';
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use base qw(LWP::Protocol);
  
  our @EXTRA_SOCK_OPTS;
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
  
      # IPv6 literal IP address should be [bracketed] to remove
      # ambiguity between ip address and port number.
      if ( ($host =~ /:/) && ($host !~ /^\[/) ) {
        $host = "[$host]";
      }
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$self->{ua}{conn_cache},
  					SendTE    => $self->{ua}{send_te},
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	my $status = "Can't connect to $host:$port";
  	if ($@ =~ /\bconnect: (.*)/ ||
  	    $@ =~ /\b(Bad hostname)\b/ ||
  	    $@ =~ /\b(nodename nor servname provided, or not known)\b/ ||
  	    $@ =~ /\b(certificate verify failed)\b/ ||
  	    $@ =~ /\b(Crypt-SSLeay can't verify hostnames)\b/
  	) {
  	    $status .= " ($1)";
  	} elsif ($@) {
  	    $status .= " ($@)";
  	}
  	die "$status\n\n$@";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy && $url->scheme ne 'https') {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port".
  	# For https only the initial CONNECT requests needs authorization.
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
  
      # Proxying SSL with a http proxy needs issues a CONNECT request to build a
      # tunnel and then upgrades the tunnel to SSL. But when doing keep-alive the
      # https request does not need to be the first request in the connection, so
      # we need to distinguish between
      # - not yet connected (create socket and ssl upgrade)
      # - connected but not inside ssl tunnel (ssl upgrade)
      # - inside ssl tunnel to the target - once we are in the tunnel to the
      #   target we cannot only reuse the tunnel for more https requests with the
      #   same target
  
      my $ssl_tunnel = $proxy && $url->scheme eq 'https'
  	&& $url->host.":".$url->port;
  
      my ($host,$port) = $proxy
  	? ($proxy->host,$proxy->port)
  	: ($url->host,$url->port);
      my $fullpath =
  	$method eq 'CONNECT' ? $url->host . ":" . $url->port :
  	$proxy && ! $ssl_tunnel ? $url->as_string :
  	do {
  	    my $path = $url->path_query;
  	    $path = "/$path" if $path !~m{^/};
  	    $path
  	};
  
      my $socket;
      my $conn_cache = $self->{ua}{conn_cache};
      my $cache_key;
      if ( $conn_cache ) {
  	$cache_key = "$host:$port";
  	# For https we reuse the socket immediately only if it has an established
  	# tunnel to the target. Otherwise a CONNECT request followed by an SSL
  	# upgrade need to be done first. The request itself might reuse an
  	# existing non-ssl connection to the proxy
  	$cache_key .= "!".$ssl_tunnel if $ssl_tunnel;
  	if ( $socket = $conn_cache->withdraw($self->socket_type,$cache_key)) {
  	    if ($socket->can_read(0)) {
  		# if the socket is readable, then either the peer has closed the
  		# connection or there are some garbage bytes on it.  In either
  		# case we abandon it.
  		$socket->close;
  		$socket = undef;
  	    } # else use $socket
  	    else {
  		$socket->timeout($timeout);
  	    }
  	}
      }
  
      if ( ! $socket && $ssl_tunnel ) {
  	my $proto_https = LWP::Protocol::create('https',$self->{ua})
  	    or die "no support for scheme https found";
  
  	# only if ssl socket class is IO::Socket::SSL we can upgrade
  	# a plain socket to SSL. In case of Net::SSL we fall back to
  	# the old version
  	if ( my $upgrade_sub = $proto_https->can('_upgrade_sock')) {
  	    my $response = $self->request(
  		HTTP::Request->new('CONNECT',"http://$ssl_tunnel"),
  		$proxy,
  		undef,$size,$timeout
  	    );
  	    $response->is_success or die
  		"establishing SSL tunnel failed: ".$response->status_line;
  	    $socket = $upgrade_sub->($proto_https,
  		$response->{client_socket},$url)
  		or die "SSL upgrade failed: $@";
  	} else {
  	    $socket = $proto_https->_new_socket($url->host,$url->port,$timeout);
  	}
      }
  
      if ( ! $socket ) {
  	# connect to remote site w/o reusing established socket
  	$socket = $self->_new_socket($host, $port, $timeout );
      }
  
      my $http_version = "";
      if (my $proto = $request->protocol) {
  	if ($proto =~ /^(?:HTTP\/)?(1.\d+)$/) {
  	    $http_version = $1;
  	    $socket->http_version($http_version);
  	    $socket->send_te(0) if $http_version eq "1.0";
  	}
      }
  
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ tr/\n/ /;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EWOULDBLOCK} || $!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
        INITIAL_READ:
  	if ($write_wait) {
  	    # skip filling $wbuf when waiting for 100-continue
  	    # because if the response is a redirect or auth required
  	    # the request will be cloned and there is no way
  	    # to reset the input stream
  	    # return here via the label after the 100-continue is read
  	}
  	elsif (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($write_wait || $woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  			goto INITIAL_READ;
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN} || $!{ENOTTY};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if ($cache_key) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, $cache_key, $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package # hide from PAUSE
      LWP::Protocol::http::SocketMethods;
  
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package # hide from PAUSE
      LWP::Protocol::http::Socket;
  
  use parent -norequire, qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/loopback.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  
  use strict;
  
  our $VERSION = '6.34';
  
  require HTTP::Response;
  
  use base qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  
  our $VERSION = '6.34';
  
  use base qw(LWP::Protocol);
  our $SENDMAIL;
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  use base qw(LWP::Protocol);
  
  our $VERSION = '6.34';
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request {
      my ($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url    = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
          return HTTP::Response->new(HTTP::Status::RC_INTERNAL_SERVER_ERROR,
              "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              'Library does not allow method ' . "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art   = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
          return HTTP::Response->new(HTTP::Status::RC_BAD_REQUEST,
              "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new(
          $url->host,
  
          #Port    => 18574,
          Timeout => $timeout,
  
          #Debug   => 1,
      );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
          return HTTP::Response->new(HTTP::Status::RC_SERVICE_UNAVAILABLE,
              $nntp->message);
      }
      my $response = HTTP::Response->new(HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
          $nntp->quit;
          $nntp = undef;
          $response->code(HTTP::Status::RC_NOT_IMPLEMENTED);
          $response->message("POST not implemented yet");
          return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
          if (!$nntp->group($groupart)) {
              $response->code(HTTP::Status::RC_NOT_FOUND);
              $response->message($nntp->message);
          }
          $nntp->quit;
          $nntp = undef;
  
          # HEAD: just check if the group exists
          if ($method eq 'GET' && $response->is_success) {
              $response->code(HTTP::Status::RC_NOT_IMPLEMENTED);
              $response->message("GET newsgroup not implemented yet");
          }
          return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
          $nntp->quit;
          $response->code(HTTP::Status::RC_NOT_FOUND);
          $response->message($nntp->message);
          $nntp = undef;
          return $response;
      }
  
      # Parse headers
      my ($key, $val);
      local $_;
      while ($_ = shift @$art) {
          if (/^\s+$/) {
              last;    # end of headers
          }
          elsif (/^(\S+):\s*(.*)/) {
              $response->push_header($key, $val) if $key;
              ($key, $val) = ($1, $2);
          }
          elsif (/^\s+(.*)/) {
              next unless $key;
              $val .= $1;
          }
          else {
              unshift(@$art, $_);
              last;
          }
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
          unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art)) if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  
  use strict;
  
  our $VERSION = '6.34';
  
  require HTTP::Response;
  require HTTP::Status;
  use base qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
  
      return HTTP::Response->new(
        HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  use base qw(LWP::UserAgent);
  
  our $VERSION = '6.34';
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'});
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, "");
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $parse_head = $self->parse_head(0);
  	my $robot_res = $self->request($robot_req);
  	$self->parse_head($parse_head);
  	my $fresh_until = $robot_res->fresh_until;
  	my $content = "";
  	if ($robot_res->is_success && $robot_res->content_is_text) {
  	    $content = $robot_res->decoded_content;
  	    $content = "" unless $content && $content =~ /^\s*Disallow\s*:/mi;
  	}
  	$self->{'rules'}->parse($robot_url, $content, $fresh_until);
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  L<URL:http://www.robotstxt.org/>.
  
  When you use an I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of L<LWP::UserAgent> and implements the
  same methods. In addition the following methods are provided:
  
  =head2 new
  
      my $ua = LWP::RobotUA->new( %options )
      my $ua = LWP::RobotUA->new( $agent, $from )
      my $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =head2 delay
  
      my $delay = $ua->delay;
      $ua->delay( $minutes );
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is C<1> minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to C<10> seconds:
  
      $ua->delay(10/60);
  
  =head2 use_sleep
  
      my $bool = $ua->use_sleep;
      $ua->use_sleep( $boolean );
  
  Get/set a value indicating whether the UA should L<LWP::RobotUA/sleep> if
  requests arrive too fast, defined as C<< $ua->delay >> minutes not passed since
  last request to the given server.  The default is true.  If this value is
  false then an internal C<SERVICE_UNAVAILABLE> response will be generated.
  It will have a C<Retry-After> header that indicates when it is OK to
  send another request to this server.
  
  =head2 rules
  
      my $rules = $ua->rules;
      $ua->rules( $rules );
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =head2 no_visits
  
      my $num = $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named C<num_visits> or
  something like that. :-(
  
  =head2 host_wait
  
      my $num = $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =head2 as_string
  
      my $string = $ua->as_string;
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  
  our $VERSION = '6.34';
  
  require Exporter;
  
  our @EXPORT = qw(get head getprint getstore mirror);
  our @EXPORT_OK = qw($ua);
  
  # I really hate this.  It was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Date ();
  
  our $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the L<LWP::UserAgent> module.
  
  The module will also export the L<LWP::UserAgent> object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  C<LWP::Simple/#.##>
  and will initialize its proxy defaults from the environment (by
  calling C<< $ua->env_proxy >>).
  
  =head1 FUNCTIONS
  
  The following functions are provided (and exported) by this module:
  
  =head2 get
  
      my $res = get($url);
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The C<$url> argument can
  be either a string or a reference to a L<URI> object.
  
  You will not be able to examine the response code or response headers
  (like C<Content-Type>) when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =head2 head
  
      my $res = head($url);
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =head2 getprint
  
      my $code = getprint($url);
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =head2 getstore
  
      my $code = getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =head2 mirror
  
      my $code = mirror($url, $file);
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =head1 STATUS CONSTANTS
  
  This module also exports the L<HTTP::Status> constants and procedures.
  You can use them when you check the response code from L<LWP::Simple/getprint>,
  L<LWP::Simple/getstore> or L<LWP::Simple/mirror>.  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  =head1 CLASSIFICATION FUNCTIONS
  
  The L<HTTP::Status> classification functions are:
  
  =head2 is_success
  
      my $bool = is_success($rc);
  
  True if response code indicated a successful request.
  
  =head2 is_error
  
      my $bool = is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular L<CGI>
  module, you may be importing a C<head> function from each module,
  producing a warning like C<Prototype mismatch: sub main::head ($) vs none>.
  Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
  
  =cut
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  
  use base qw(LWP::MemberMixin);
  
  use Carp ();
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Scalar::Util qw(blessed);
  use Try::Tiny qw(try catch);
  
  our $VERSION = '6.34';
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference")
          if ref($_[1]) eq 'HASH';
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $ssl_opts = delete $cnf{ssl_opts} || {};
      unless (exists $ssl_opts->{verify_hostname}) {
  	# The processing of HTTPS_CA_* below is for compatibility with Crypt::SSLeay
  	if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
  	    $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
  	}
  	elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
  	    # Crypt-SSLeay compatibility (verify peer certificate; but not the hostname)
  	    $ssl_opts->{verify_hostname} = 0;
  	    $ssl_opts->{SSL_verify_mode} = 1;
  	}
  	else {
  	    $ssl_opts->{verify_hostname} = 1;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_file}) {
  	if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
  	    $ssl_opts->{SSL_ca_file} = $ca_file;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_path}) {
  	if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
  	    $ssl_opts->{SSL_ca_path} = $ca_path;
  	}
      }
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $send_te = delete $cnf{send_te};
      $send_te = 1 unless defined $send_te;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = exists $cnf{env_proxy} ? delete $cnf{env_proxy} : $ENV{PERL_LWP_ENV_PROXY};
      my $no_proxy = exists $cnf{no_proxy} ? delete $cnf{no_proxy} : [];
      Carp::croak(qq{no_proxy must be an arrayref, not $no_proxy!}) if ref $no_proxy ne 'ARRAY';
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
  
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
  
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
          def_headers           => $def_headers,
          timeout               => $timeout,
          local_address         => $local_address,
          ssl_opts              => $ssl_opts,
          use_eval              => $use_eval,
          show_progress         => $show_progress,
          max_size              => $max_size,
          max_redirect          => $max_redirect,
          # We set proxy later as we do validation on the values
          proxy                 => {},
          no_proxy              => [ @{ $no_proxy } ],
          protocols_allowed     => $protocols_allowed,
          protocols_forbidden   => $protocols_forbidden,
          requests_redirectable => $requests_redirectable,
          send_te               => $send_te,
      }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
          if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      if (exists $cnf{proxy}) {
          Carp::croak(qq{proxy must be an arrayref, not $cnf{proxy}!})
              if ref $cnf{proxy} ne 'ARRAY';
          $self->proxy($cnf{proxy});
      }
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              try {
                  $protocol = LWP::Protocol::create($scheme, $self);
              }
              catch {
                  my $error = $_;
                  $error =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, HTTP::Status::RC_NOT_IMPLEMENTED, $error);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (LWP::Protocol::https not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if the LWP::Protocol::https module
  is installed.
  EOT
                  }
              };
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              try {
                  $response = $protocol->request($request, $proxy, $arg, $size, $self->{timeout}) || die "No response returned by $protocol";
              }
              catch {
                  my $error = $_;
                  if (blessed($error) && $error->isa("HTTP::Response")) {
                      $response = $error;
                      $response->request($request);
                  }
                  else {
                      my $full = $error;
                      (my $status = $error) =~ s/\n.*//s;
                      $status =~ s/ at .* line \d+.*//s;  # remove file/line number
                      my $code = ($status =~ s/^(\d\d\d)\s+//) ? $1 : HTTP::Status::RC_INTERNAL_SERVER_ERROR;
                      $response = _new_response($request, $code, $status, $full);
                  }
              };
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      my $error;
      try {
          $request = $self->prepare_request($request);
      }
      catch {
          $error = $_;
          $error =~ s/ at .* line \d+.*//s;  # remove file/line number
      };
  
      if ($error) {
          return _new_response($request, HTTP::Status::RC_BAD_REQUEST, $error);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request {
      my ($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                  "Redirect loop detected (max_redirect = $self->{max_redirect})"
          );
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if (   $code == HTTP::Status::RC_MOVED_PERMANENTLY
          or $code == HTTP::Status::RC_FOUND
          or $code == HTTP::Status::RC_SEE_OTHER
          or $code == HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
          my $referral = $request->clone;
  
          # These headers should never be forwarded
          $referral->remove_header('Host', 'Cookie');
  
          if (   $referral->header('Referer')
              && $request->uri->scheme eq 'https'
              && $referral->uri->scheme eq 'http')
          {
              # RFC 2616, section 15.1.3.
              # https -> http redirect, suppressing Referer
              $referral->remove_header('Referer');
          }
  
          if (   $code == HTTP::Status::RC_SEE_OTHER
              || $code == HTTP::Status::RC_FOUND)
          {
              my $method = uc($referral->method);
              unless ($method eq "GET" || $method eq "HEAD") {
                  $referral->method("GET");
                  $referral->content("");
                  $referral->remove_content_headers;
              }
          }
  
          # And then we update the URL based on the Location:-header.
          my $referral_uri = $response->header('Location');
          {
              # Some servers erroneously return a relative URL for redirects,
              # so make it absolute if it not already is.
              local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
              my $base = $response->base;
              $referral_uri = "" unless defined $referral_uri;
              $referral_uri
                  = $HTTP::URI_CLASS->new($referral_uri, $base)->abs($base);
          }
          $referral->uri($referral_uri);
  
          return $response unless $self->redirect_ok($referral, $response);
          return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == HTTP::Status::RC_UNAUTHORIZED
          || $code == HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED)
      {
          my $proxy = ($code == HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
          my $ch_header
              = $proxy || $request->method eq 'CONNECT'
              ? "Proxy-Authenticate"
              : "WWW-Authenticate";
          my @challenges = $response->header($ch_header);
          unless (@challenges) {
              $response->header(
                  "Client-Warning" => "Missing Authenticate header");
              return $response;
          }
  
          require HTTP::Headers::Util;
          CHALLENGE: for my $challenge (@challenges) {
              $challenge =~ tr/,/;/;    # "," is used to separate auth-params!!
              ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
              my $scheme = shift(@$challenge);
              shift(@$challenge);       # no value
              $challenge = {@$challenge};    # make rest into a hash
  
              unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
                  $response->header(
                      "Client-Warning" => "Bad authentication scheme '$scheme'");
                  return $response;
              }
              $scheme = $1;                  # untainted now
              my $class = "LWP::Authen::\u$scheme";
              $class =~ tr/-/_/;
  
              no strict 'refs';
              unless (%{"$class\::"}) {
                  # try to load it
                  my $error;
                  try {
                      (my $req = $class) =~ s{::}{/}g;
                      $req .= '.pm' unless $req =~ /\.pm$/;
                      require $req;
                  }
                  catch {
                      $error = $_;
                  };
                  if ($error) {
                      if ($error =~ /^Can\'t locate/) {
                          $response->header("Client-Warning" =>
                                  "Unsupported authentication scheme '$scheme'");
                      }
                      else {
                          $response->header("Client-Warning" => $error);
                      }
                      next CHALLENGE;
                  }
              }
              unless ($class->can("authenticate")) {
                  $response->header("Client-Warning" =>
                          "Unsupported authentication scheme '$scheme'");
                  next CHALLENGE;
              }
              return $class->authenticate($self, $proxy, $challenge, $response,
                  $request, $arg, $size);
          }
          return $response;
      }
      return $response;
  }
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  sub _has_raw_content {
      my $self = shift;
      shift; # drop url
  
      # taken from HTTP::Request::Common::request_type_with_data
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
          if (lc($k) eq 'content') {
              $content = $v;
          }
      }
  
      # We were given Content => 'string' ...
      if (defined $content && ! ref ($content)) {
          return 1;
      }
  
      return;
  }
  
  sub _maybe_copy_default_content_type {
      my ($self, $req, @parameters) = @_;
  
      # If we have a default Content-Type and someone passes in a POST/PUT
      # with Content => 'some-string-value', use that Content-Type instead
      # of x-www-form-urlencoded
      my $ct = $self->default_header('Content-Type');
      return unless defined $ct && $self->_has_raw_content(@parameters);
  
      $req->header('Content-Type' => $ct);
  }
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      my $req = HTTP::Request::Common::POST(@parameters);
      $self->_maybe_copy_default_content_type($req, @parameters);
      return $self->request($req, @suff);
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub put {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      my $req = HTTP::Request::Common::PUT(@parameters);
      $self->_maybe_copy_default_content_type($req, @parameters);
      return $self->request($req, @suff);
  }
  
  
  sub delete {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::DELETE( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  
  sub is_online {
      my $self = shift;
      return 1 if $self->get("http://www.msftncsi.com/ncsi.txt")->content eq "Microsoft NCSI";
      return 1 if $self->get("http://www.apple.com")->content =~ m,<title>Apple</title>,;
      return 0;
  }
  
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
  
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
  
      # Otherwise it's apparently okay...
      return 1;
  }
  
  sub credentials {
      my $self   = shift;
      my $netloc = lc(shift || '');
      my $realm  = shift || "";
      my $old    = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  sub send_te      { shift->_elem('send_te',      @_); }
  
  sub ssl_opts {
      my $self = shift;
      if (@_ == 1) {
  	my $k = shift;
  	return $self->{ssl_opts}{$k};
      }
      if (@_) {
  	my $old;
  	while (@_) {
  	    my($k, $v) = splice(@_, 0, 2);
  	    $old = $self->{ssl_opts}{$k} unless @_;
  	    if (defined $v) {
  		$self->{ssl_opts}{$k} = $v;
  	    }
  	    else {
  		delete $self->{ssl_opts}{$k};
  	    }
  	}
  	%{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
  	return $old;
      }
  
      return keys %{$self->{ssl_opts}};
  }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent { "libwww-perl/$VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
  
      # here we pass $_[2] to the callbacks, instead of $o, so that they
      # can assign to it; e.g. request_prepare is documented to allow
      # that
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($_[2], $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($_[2], $self, $h);
      }
  }
  
  
  # deprecated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length.
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some DOSish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy {
      my $self = shift;
      my $key  = shift;
      if (!@_ && ref $key eq 'ARRAY') {
          die 'odd number of items in proxy arrayref!' unless @{$key} % 2 == 0;
  
          # This map reads the elements of $key 2 at a time
          return
              map { $self->proxy($key->[2 * $_], $key->[2 * $_ + 1]) }
              (0 .. @{$key} / 2 - 1);
      }
      return map { $self->proxy($_, @_) } @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      require Encode;
      require Encode::Locale;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, Encode::decode(locale => $v));
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message, $content) = @_;
      $message ||= HTTP::Status::status_message($code);
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content($content || "$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   use strict;
   use warnings;
   use LWP::UserAgent ();
  
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
  
   my $response = $ua->get('http://search.cpan.org/');
  
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The L<LWP::UserAgent> is a class implementing a web user agent.
  L<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an L<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of L<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a L<HTTP::Response> object.  There are
  convenience methods for sending the most common request types:
  L<LWP::UserAgent/get>, L<LWP::UserAgent/head>, L<LWP::UserAgent/post>,
  L<LWP::UserAgent/put> and L<LWP::UserAgent/delete>.  When using these
  methods, the creation of the request object is hidden as shown in the
  synopsis above.
  
  The basic approach of the library is to use HTTP-style communication
  for all protocol schemes.  This means that you will construct
  L<HTTP::Request> objects and receive L<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP-style communications, I<gopher> menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =head2 clone
  
      my $ua2 = $ua->clone;
  
  Returns a copy of the L<LWP::UserAgent> object.
  
  B<CAVEAT>: Please be aware that the clone method does not copy or clone your
  C<cookie_jar> attribute. Due to the limited restrictions on what can be used
  for your cookie jar, there is no way to clone the attribute. The C<cookie_jar>
  attribute will be C<undef> in the new object instance.
  
  =head2 new
  
      my $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new L<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     ssl_opts                { verify_hostname => 1 }
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
     proxy                   undef
     no_proxy                []
  
  The following additional options are also accepted: If the C<env_proxy> option
  is passed in with a true value, then proxy settings are read from environment
  variables (see L<LWP::UserAgent/env_proxy>). If C<env_proxy> isn't provided, the
  C<PERL_LWP_ENV_PROXY> environment variable controls if
  L<LWP::UserAgent/env_proxy> is called during initialization.  If the
  C<keep_alive> option is passed in, then a C<LWP::ConnCache> is set up (see
  L<LWP::UserAgent/conn_cache>).  The C<keep_alive> value is passed on as the
  C<total_capacity> for the connection cache.
  
  C<proxy> must be set as an arrayref of key/value pairs. C<no_proxy> takes an
  arrayref of domains.
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  L<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =head2 agent
  
      my $agent = $ua->agent;
      $ua->agent('Checkbot/0.4 ');    # append the default to the end
      $ua->agent('Mozilla/5.0');
      $ua->agent("");                 # don't identify
  
  Get/set the product token that is used to identify the user agent on
  the network. The agent value is sent as the C<User-Agent> header in
  the requests.
  
  The default is a string of the form C<libwww-perl/#.###>, where C<#.###> is
  substituted with the version number of this library.
  
  If the provided string ends with space, the default C<libwww-perl/#.###>
  string is appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the C</> character.
  
  =head2 conn_cache
  
      my $cache_obj = $ua->conn_cache;
      $ua->conn_cache( $cache_obj );
  
  Get/set the L<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =head2 cookie_jar
  
      my $jar = $ua->cookie_jar;
      $ua->cookie_jar( $cookie_jar_obj );
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the C<extract_cookies($response)> and
  C<add_cookie_header($request)> methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a L<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie jar, i.e. never automatically add
  C<Cookie> headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in, it is replaced with an
  instance of L<HTTP::Cookies> that is initialized based on the hash. This form
  also automatically loads the L<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =head2 credentials
  
      my $creds = $ua->credentials();
      $ua->credentials( $netloc, $realm );
      $ua->credentials( $netloc, $realm, $uname, $pass );
      $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  Get/set the user name and password to be used for a realm.
  
  The C<$netloc> is a string of the form C<< <host>:<port> >>.  The username and
  password will only be passed to this server.
  
  =head2 default_header
  
      $ua->default_header( $field );
      $ua->default_header( $field => $value );
      $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
      $ua->default_header('Accept-Language' => "no, en");
  
  This is just a shortcut for
  C<< $ua->default_headers->header( $field => $value ) >>.
  
  =head2 default_headers
  
      my $headers = $ua->default_headers;
      $ua->default_headers( $headers_obj );
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty L<HTTP::Headers>
  object.
  
  =head2 from
  
      my $from = $ua->from;
      $ua->from('foo@bar.com');
  
  Get/set the email address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in L<RFC2822|https://tools.ietf.org/html/rfc2822>. The C<from> value
  is sent as the C<From> header in the requests.
  
  The default is to not send a C<From> header.  See
  L<LWP::UserAgent/default_headers> for the more general interface that allow
  any header to be defaulted.
  
  
  =head2 local_address
  
      my $address = $ua->local_address;
      $ua->local_address( $address );
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =head2 max_redirect
  
      my $max = $ua->max_redirect;
      $ua->max_redirect( $n );
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is C<7>. This means that if you call L<LWP::UserAgent/request>
  and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =head2 max_size
  
      my $size = $ua->max_size;
      $ua->max_size( $bytes );
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  C<Client-Aborted> header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The C<Content-Length>
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =head2 parse_head
  
      my $bool = $ua->parse_head;
      $ua->parse_head( $boolean );
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  true. I<Do not turn this off> unless you know what you are doing.
  
  =head2 protocols_allowed
  
      my $aref = $ua->protocols_allowed;      # get allowed protocols
      $ua->protocols_allowed( \@protocols );  # allow ONLY these
      $ua->protocols_allowed(undef);          # delete the list
      $ua->protocols_allowed(['http',]);      # ONLY allow http
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  L<LWP::UserAgent/protocols_forbidden> list.
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<< $ua->protocols_allowed( [ 'http', 'https'] ); >>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like C<ftp://...>) will result in a 500 error.
  
  Note that having a C<protocols_allowed> list causes any
  L<LWP::UserAgent/protocols_forbidden> list to be ignored.
  
  =head2 protocols_forbidden
  
      my $aref = $ua->protocols_forbidden;    # get the forbidden list
      $ua->protocols_forbidden(\@protocols);  # do not allow these
      $ua->protocols_forbidden(['http',]);    # All http reqs get a 500
      $ua->protocols_forbidden(undef);        # delete the list
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<< $ua->protocols_forbidden( [ 'file', 'mailto'] ); >>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  =head2 requests_redirectable
  
      my $aref = $ua->requests_redirectable;
      $ua->requests_redirectable( \@requests );
      $ua->requests_redirectable(['GET', 'HEAD',]); # the default
  
  This reads or sets the object's list of request names that
  L<LWP::UserAgent/redirect_ok> will allow redirection for. By default, this
  is C<['GET', 'HEAD']>, as per L<RFC 2616|https://tools.ietf.org/html/rfc2616>.
  To change to include C<POST>, consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =head2 send_te
  
      my $bool = $ua->send_te;
      $ua->send_te( $boolean );
  
  If true, will send a C<TE> header along with the request. The default is
  true. Set it to false to disable the C<TE> header for systems who can't
  handle it.
  
  =head2 show_progress
  
      my $bool = $ua->show_progress;
      $ua->show_progress( $boolean );
  
  Get/set a value indicating whether a progress bar should be displayed
  on the terminal as requests are processed. The default is false.
  
  =head2 ssl_opts
  
      my @keys = $ua->ssl_opts;
      my $val = $ua->ssl_opts( $key );
      $ua->ssl_opts( $key => $value );
  
  Get/set the options for SSL connections.  Without argument return the list
  of options keys currently set.  With a single argument return the current
  value for the given option.  With 2 arguments set the option value and return
  the old.  Setting an option to the value C<undef> removes this option.
  
  The options that LWP relates to are:
  
  =over
  
  =item C<verify_hostname> => $bool
  
  When TRUE LWP will for secure protocol schemes ensure it connects to servers
  that have a valid certificate matching the expected hostname.  If FALSE no
  checks are made and you can't be sure that you communicate with the expected peer.
  The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
  
  This option is initialized from the C<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
  variable.  If this environment variable isn't set; then C<verify_hostname>
  defaults to 1.
  
  =item C<SSL_ca_file> => $path
  
  The path to a file containing Certificate Authority certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order.
  
  =item C<SSL_ca_path> => $path
  
  The path to a directory containing files containing Certificate Authority
  certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
  
  =back
  
  Other options can be set and are processed directly by the SSL Socket implementation
  in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
  
  The libwww-perl core no longer bundles protocol plugins for SSL.  You will need
  to install L<LWP::Protocol::https> separately to enable support for processing
  https-URLs.
  
  =head2 timeout
  
      my $secs = $ua->timeout;
      $ua->timeout( $secs );
  
  Get/set the timeout value in seconds. The default value is
  180 seconds, i.e. 3 minutes.
  
  The request is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the L<LWP::UserAgent/request> method to
  actually return might be longer.
  
  When a request times out, a response object is still returned.  The response
  will have a standard HTTP Status Code (500).  This response will have the
  "Client-Warning" header set to the value of "Internal response".  See the
  L<LWP::UserAgent/get> method description below for further details.
  
  =head1 PROXY ATTRIBUTES
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =head2 env_proxy
  
      $ua->env_proxy;
  
  Load proxy settings from C<*_proxy> environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by C<env_proxy>.  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =head2 no_proxy
  
      $ua->no_proxy( @domains );
      $ua->no_proxy('localhost', 'example.com');
      $ua->no_proxy(); # clear the list
  
  Do not proxy requests to the given domains.  Calling C<no_proxy> without
  any domains clears the list of domains.
  
  =head2 proxy
  
      $ua->proxy(\@schemes, $proxy_url)
      $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
  
      # For a single scheme:
      $ua->proxy($scheme, $proxy_url)
      $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
      # To set multiple proxies at once:
      $ua->proxy([
          ftp => 'http://ftp.example.com:8001/',
          [ 'http', 'https' ] => 'http://http.example.com:8001/',
      ]);
  
  Set/retrieve proxy URL for a scheme.
  
  The first form specifies that the URL is to be used as a proxy for
  access methods listed in the list in the first method argument,
  i.e. C<http> and C<ftp>.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  The third form demonstrates setting multiple proxies at once. This is also
  the only form accepted by the constructor.
  
  =head1 HANDLERS
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =head2 add_handler
  
      $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify C<%matchspec> see L<HTTP::Config/"Matching">.
  
  The possible values C<$phase> and the corresponding callback signatures are:
  
  =over
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handler is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler needs to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exception is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler gets a chance of handling requests before they're sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler returns an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =head2 get_my_handler
  
      $ua->get_my_handler( $phase, %matchspec );
      $ua->get_my_handler( $phase, %matchspec, $init );
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed as a true value, create and add the
  handler if it's not found.  If C<$init> is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  C<$init> is a hash reference, merge the hashes.
  
  =head2 handlers
  
      $ua->handlers( $phase, $request )
      $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =head2 remove_handler
  
      $ua->remove_handler( undef, %matchspec );
      $ua->remove_handler( $phase, %matchspec );
      $ua->remove_handlers(); # REMOVE ALL HANDLERS IN ALL PHASES
  
  Remove handlers that match the given C<%matchspec>.  If C<$phase> is not
  provided, remove handlers from all phases.
  
  Be careful as calling this function with C<%matchspec> that is not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the L<LWP::UserAgent/set_my_handler> method instead.
  
  The removed handlers are returned.
  
  =head2 set_my_handler
  
      $ua->set_my_handler( $phase, $cb, %matchspec );
      $ua->set_my_handler($phase, undef); # remove handler for phase
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the C<%matchspec> that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =head2 delete
  
      my $res = $ua->delete( $url );
      my $res = $ua->delete( $url, $field_name => $value, ... );
  
  This method will dispatch a C<DELETE> request on the given URL.  Additional
  headers and content options are the same as for the L<LWP::UserAgent/get>
  method.
  
  This method will use the DELETE() function from L<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =head2 get
  
      my $res = $ua->get( $url );
      my $res = $ua->get( $url , $field_name => $value, ... );
  
  This method will dispatch a C<GET> request on the given URL.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.  Note that errors
  writing to the content file (for example due to permission denied
  or the filesystem being full) will be reported via the C<Client-Aborted>
  or C<X-Died> response headers, and not the C<is_success> method.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =head2 head
  
      my $res = $ua->head( $url );
      my $res = $ua->head( $url , $field_name => $value, ... );
  
  This method will dispatch a C<HEAD> request on the given URL.
  Otherwise it works like the L<LWP::UserAgent/get> method described above.
  
  =head2 is_protocol_supported
  
      my $bool = $ua->is_protocol_supported( $scheme );
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like C<http> or
  C<ftp>) or it might be an L<URI> object reference.)
  
  Whether a scheme is supported is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return true only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =head2 is_online
  
      my $bool = $ua->is_online;
  
  Tries to determine if you have access to the Internet. Returns C<1> (true)
  if the built-in heuristics determine that the user agent is
  able to access the Internet (over HTTP) or C<0> (false).
  
  See also L<LWP::Online>.
  
  =head2 mirror
  
      my $res = $ua->mirror( $url, $filename );
  
  This method will get the document identified by URL and store it in
  file called C<$filename>.  If the file already exists, then the request
  will contain an C<If-Modified-Since> header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is an L<HTTP::Response> object.
  
  =head2 post
  
      my $res = $ua->post( $url, \%form );
      my $res = $ua->post( $url, \@form );
      my $res = $ua->post( $url, \%form, $field_name => $value, ... );
      my $res = $ua->post( $url, $field_name => $value, Content => \%form );
      my $res = $ua->post( $url, $field_name => $value, Content => \@form );
      my $res = $ua->post( $url, $field_name => $value, Content => $content );
  
  This method will dispatch a C<POST> request on the given URL, with
  C<%form> or C<@form> providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the L<LWP::UserAgent/get> method.
  
  This method will use the C<POST> function from L<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =head2 put
  
      # Any version of HTTP::Message works with this form:
      my $res = $ua->put( $url, $field_name => $value, Content => $content );
  
      # Using hash or array references requires HTTP::Message >= 6.07
      use HTTP::Request 6.07;
      my $res = $ua->put( $url, \%form );
      my $res = $ua->put( $url, \@form );
      my $res = $ua->put( $url, \%form, $field_name => $value, ... );
      my $res = $ua->put( $url, $field_name => $value, Content => \%form );
      my $res = $ua->put( $url, $field_name => $value, Content => \@form );
  
  This method will dispatch a C<PUT> request on the given URL, with
  C<%form> or C<@form> providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the L<LWP::UserAgent/get> method.
  
  CAVEAT:
  
  This method can only accept content that is in key-value pairs when using
  L<HTTP::Request::Common> prior to version C<6.07>. Any use of hash or array
  references will result in an error prior to version C<6.07>.
  
  This method will use the C<PUT> function from L<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =head2 request
  
      my $res = $ua->request( $request );
      my $res = $ua->request( $request, $content_file );
      my $res = $ua->request( $request, $content_cb );
      my $res = $ua->request( $request, $content_cb, $read_size_hint );
  
  This method will dispatch the given C<$request> object. Normally this
  will be an instance of the L<HTTP::Request> class, but any object with
  a similar interface will do. The return value is an L<HTTP::Response> object.
  
  The C<request> method will process redirects and authentication
  responses transparently. This means that it may actually send several
  simple requests via the L<LWP::UserAgent/simple_request> method described below.
  
  The request methods described above; L<LWP::UserAgent/get>, L<LWP::UserAgent/head>,
  L<LWP::UserAgent/post> and L<LWP::UserAgent/mirror> will all dispatch the request
  they build via this method. They are convenience methods that simply hide the
  creation of the request object for you.
  
  The C<$content_file>, C<$content_cb> and C<$read_size_hint> all correspond to
  options described with the L<LWP::UserAgent/get> method above. Note that errors
  writing to the content file (for example due to permission denied
  or the filesystem being full) will be reported via the C<Client-Aborted>
  or C<X-Died> response headers, and not the C<is_success> method.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =head2 simple_request
  
      my $request = HTTP::Request->new( ... );
      my $res = $ua->simple_request( $request );
      my $res = $ua->simple_request( $request, $content_file );
      my $res = $ua->simple_request( $request, $content_cb );
      my $res = $ua->simple_request( $request, $content_cb, $read_size_hint );
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for the L<LWP::UserAgent/request> described above.
  
  The difference from L<LWP::UserAgent/request> is that C<simple_request> will not try to
  handle redirects or authentication responses.  The L<LWP::UserAgent/request> method
  will, in fact, invoke this method for each simple request it sends.
  
  =head1 CALLBACK METHODS
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of L<LWP::UserAgent>
  might want to override their behaviour.
  
  =head2 get_basic_credentials
  
      # This checks wantarray and can either return an array:
      my ($user, $pass) = $ua->get_basic_credentials( $realm, $uri, $isproxy );
      # or a string that looks like "user:pass"
      my $creds = $ua->get_basic_credentials($realm, $uri, $isproxy);
  
  This is called by L<LWP::UserAgent/request> to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the C<$realm> provided by the server, the C<$uri> requested and a
  C<boolean flag> to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the L<LWP::UserAgent/credentials> method.
  
  =head2 prepare_request
  
      $request = $ua->prepare_request( $request );
  
  This method is invoked by L<LWP::UserAgent/simple_request>. Its task is
  to modify the given C<$request> object by setting up various headers based
  on the attributes of the user agent. The return value should normally be the
  C<$request> object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; C<User-Agent>,
  C<From>, C<Range> and C<Cookie>.
  
  =head2 progress
  
      my $prog = $ua->progress( $status, $request_or_response );
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with C<$status>
  "begin" at the start of processing the request and with C<$state> "end"
  before the request method returns.  In between these C<$status> will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When C<$status> is "begin" the second argument is the L<HTTP::Request> object,
  otherwise it is the L<HTTP::Response> object.
  
  =head2 redirect_ok
  
      my $bool = $ua->redirect_ok( $prospective_request, $response );
  
  This method is called by L<LWP::UserAgent/request> before it tries to follow a
  redirection to the request in C<$response>.  This should return a true
  value if this redirection is permissible.  The C<$prospective_request>
  will be the request to be sent if this method returns true.
  
  The base implementation will return false unless the method
  is in the object's C<requests_redirectable> list,
  false if the proposed redirection is to a C<file://...>
  URL, and true otherwise.
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on L<LWP::UserAgent>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
LWP_USERAGENT

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use Moo::_strictures;
  use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);
  use Scalar::Util 'blessed';
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Moo::_Utils) }
  BEGIN {
    *_CAN_WEAKEN_READONLY = (
      "$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583}
    ) ? sub(){0} : sub(){1};
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  BEGIN {
    package
      Method::Generate::Accessor::_Generated;
    $Carp::Internal{+__PACKAGE__} = 1;
  }
  
  my $module_name_only = qr/\A$Module::Runtime::module_name_rx\z/;
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    croak "You cannot overwrite a locally defined method ($method) with "
      . ( $type || 'an accessor' );
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $quote_opts = {
      no_defer => 1,
      package => 'Method::Generate::Accessor::_Generated',
      %{ $quote_opts||{} },
    };
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    croak "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      croak "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      croak "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ $module_name_only;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
    if (($spec->{coerce}||0) eq 1) {
      my $isa = $spec->{isa};
      if (blessed $isa and $isa->can('coercion')) {
        $spec->{coerce} = $isa->coercion;
      } elsif (blessed $isa and $isa->can('coerce')) {
        $spec->{coerce} = sub { $isa->coerce(@_) };
      } else {
        croak "Invalid coercion for $into->$name - no appropriate type constraint";
      }
    }
  
    foreach my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name",
          'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      foreach my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$pred} =
          quote_sub "${into}::${pred}"
            => $self->_generate_simple_has('$_[0]', $name, $spec)."\n"
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $builder = delete $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $builder );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
      $self->{captures} = {};
      $methods{$cl} =
        quote_sub "${into}::${cl}"
          => $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
          => delete $self->{captures}
          => $quote_opts
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          require Moo::Role;
          _load_module $hspec;
          map [ $_ => $_ ], Moo::Role->methods_provided_by($hspec)
        } else {
          croak "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}"
            => $self->_generate_delegation($asserter, $target, \@args)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      _die_overwrite($into, $asserter, 'an asserter')
        if !$spec->{allow_overwrite} && defined &{"${into}::${asserter}"};
      local $self->{captures} = {};
      $methods{$asserter} =
        quote_sub "${into}::${asserter}"
          => $self->_generate_asserter($name, $spec)
          => delete $self->{captures}
          => $quote_opts
        ;
    }
    \%methods;
  }
  
  sub merge_specs {
    my ($self, @specs) = @_;
    my $spec = shift @specs;
    for my $old_spec (@specs) {
      foreach my $key (keys %$old_spec) {
        if ($key eq 'handles') {
        }
        elsif ($key eq 'moosify') {
          $spec->{$key} = [
            map { ref $_ eq 'ARRAY' ? @$_ : $_ }
            grep defined,
            ($old_spec->{$key}, $spec->{$key})
          ];
        }
        elsif (!exists $spec->{$key}) {
          $spec->{$key} = $old_spec->{$key};
        }
      }
    }
    $spec;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_default {
    my ($self, $name, $spec) = @_;
    $spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\quotify $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\quotify $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa} ?
         "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
    );
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : quotify $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_simple_get(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    my ($me, $source) = ('$_[0]', '$_[1]');
    if ($self->is_simple_set($name, $spec)) {
      return $self->_generate_simple_set($me, $name, $spec, $source);
    }
  
    my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
    if ($coerce) {
      $source = $self->_generate_coerce($name, $source, $coerce);
    }
    if ($isa_check) {
      'scalar do { my $value = '.$source.";\n"
      .'  ('.$self->_generate_isa_check($name, '$value', $isa_check)."),\n"
      .'  ('.$self->_generate_simple_set($me, $name, $spec, '$value')."),\n"
      .($trigger
        ? '('.$self->_generate_trigger($name, $me, '$value', $trigger)."),\n"
        : '')
      .'  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
      ."}";
    }
    elsif ($trigger) {
      my $set = $self->_generate_simple_set($me, $name, $spec, $source);
      "scalar (\n"
      . '  ('.$self->_generate_trigger($name, $me, "($set)", $trigger)."),\n"
      . '  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
      . ")";
    }
    else {
      '('.$self->_generate_simple_set($me, $name, $spec, $source).')';
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return quotify($name) if !defined($init_arg) or $init_arg eq $name;
    return quotify($name).' (constructor argument: '.quotify($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce),
      1,
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _wrap_attr_exception {
    my ($self, $name, $step, $arg, $code, $want_return) = @_;
    my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
    .'    init_arg => '.quotify($arg).",\n"
    .'    name     => '.quotify($name).",\n"
    .'    step     => '.quotify($step).",\n"
    ."  };\n"
    .($want_return ? '  (my $_return),'."\n" : '')
    .'  (my $_error), (my $_old_error = $@);'."\n"
    ."  (eval {\n"
    .'    ($@ = $_old_error),'."\n"
    .'    ('
    .($want_return ? '$_return ='."\n" : '')
    .$code."),\n"
    ."    1\n"
    ."  } or\n"
    .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n"
    .'  ($@ = $_old_error),'."\n"
    .'  (defined $_error and CORE::die $_error);'."\n"
    .($want_return ? '  $_return;'."\n" : '')
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.sanitize_identifier($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify($code, $values,
          Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.sanitize_identifier($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name { sanitize_identifier($_[1]) }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
  
    my $has_default = $self->has_eager_default($name, $spec);
    if (!($has_default || $test)) {
      return '';
    }
    if ($has_default) {
      my $get_default = $self->_generate_get_default($me, $name, $spec);
      $source =
        $test
          ? "(\n  ${test}\n"
              ."   ? ${source}\n   : "
              .$get_default
              .")"
          : $get_default;
    }
    if ($spec->{coerce}) {
      $source = $self->_generate_coerce(
        $name, $source,
        $spec->{coerce}, $init_arg
      )
    }
    if ($spec->{isa}) {
      $source = 'scalar do { my $value = '.$source.";\n"
      .'  ('.$self->_generate_isa_check(
          $name, '$value', $spec->{isa}, $init_arg
        )."),\n"
      ."  \$value\n"
      ."}\n";
    }
    my $set = $self->_generate_simple_set($me, $name, $spec, $source);
    my $trigger = $spec->{trigger} ? $self->_generate_trigger(
      $name, $me, $self->_generate_simple_get($me, $name, $spec),
      $spec->{trigger}
    ) : undef;
    if ($has_default) {
      "($set)," . ($trigger && $test ? "($test and $trigger)," : '') . "\n";
    }
    else {
      "($test and ($set)" . ($trigger ? ", ($trigger)" : '') . "),\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      # &Internals::SvREADONLY($foo, 0);
      # Scalar::Util::weaken($foo);
      # &Internals::SvREADONLY($foo, 1);
      #
      # but requires Internal functions and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = _CAN_WEAKEN_READONLY
        ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }"
        : <<"EOC"
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
    my $name_str = quotify($name);
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  ".$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
     ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using quotify
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
  
    my $error;
  
    if (blessed $value) {
      local $@;
      no warnings 'void';
      eval { \&$value; 1 }
        and return 1;
      $error = "could not be converted to a coderef: $@";
    }
    elsif (ref $value eq 'CODE') {
      return 1;
    }
    else {
      $error = 'is not a coderef or code-convertible object';
    }
  
    croak "Invalid $setting '"
      . ($INC{'overload.pm'} ? overload::StrVal($value) : $value)
      . "' for $into " . $error
      . ($appended ? " $appended" : '');
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils qw(_getglob);
  use Moo::_mro;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL"
      => join('',
        $self->_handle_subbuild($into),
        qq{    my \$self = shift;\n},
        $self->buildall_body_for($into, '$self', '@_'),
        qq{    return \$self\n},
      )
      => {}
      => { no_defer => 1 }
    ;
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{mro::get_linear_isa($into)};
    '    (('.$args.')[0]->{__no_BUILD__} or ('."\n"
    .join('', map qq{      ${me}->${_}(${args}),\n}, @builds)
    ."    )),\n";
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use Moo::_strictures;
  use Sub::Quote qw(quote_sub quotify);
  use Sub::Defer;
  use Moo::_Utils qw(_getstash _getglob);
  use Moo::_mro;
  use Scalar::Util qw(weaken);
  use Carp qw(croak);
  use Carp::Heavy ();
  BEGIN { our @CARP_NOT = qw(Sub::Defer) }
  BEGIN {
    local $Moo::sification::disabled = 1;
    require Moo;
    Moo->import;
  }
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    $self->assert_constructor;
    my $specs = $self->{attribute_specs}||={};
    my $ag = $self->accessor_generator;
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        croak "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        $ag->merge_specs($new_spec, $old_spec);
      }
      if ($new_spec->{required}
        && !(
          $ag->has_default($name, $new_spec)
          || !exists $new_spec->{init_arg}
          || defined $new_spec->{init_arg}
        )
      ) {
        croak "You cannot have a required attribute (${name})"
          . " without a default, builder, or an init_arg";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    $self->assert_constructor;
    my $package = $self->{package};
    my (undef, @isa) = @{mro::get_linear_isa($package)};
    my $isa = join ',', @isa;
    my (undef, $from_file, $from_line) = caller(Carp::short_error_loc());
    my $constructor = defer_sub "${package}::new" => sub {
      my (undef, @new_isa) = @{mro::get_linear_isa($package)};
      if (join(',', @new_isa) ne $isa) {
        my ($expected_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa;
        my ($found_new) = grep { *{_getglob($_.'::new')}{CODE} } @new_isa;
        if (($found_new||'') ne ($expected_new||'')) {
          $found_new ||= 'none';
          $expected_new ||= 'none';
          croak "Expected parent constructor of $package to be"
          . " $expected_new, but found $found_new: changing the inheritance"
          . " chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported";
        }
      }
  
      my $constructor = $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1, no_defer => 1 }
      );
      $self->{inlined} = 1;
      weaken($self->{constructor} = $constructor);
      $constructor;
    };
    $self->{inlined} = 0;
    weaken($self->{constructor} = $constructor);
    $self;
  }
  
  sub current_constructor {
    my ($self, $package) = @_;
    return *{_getglob("${package}::new")}{CODE};
  }
  
  sub assert_constructor {
    my ($self) = @_;
    my $package = $self->{package} or return 1;
    my $current = $self->current_constructor($package)
      or return 1;
    my $constructor = $self->{constructor}
      or croak "Unknown constructor for $package already exists";
    croak "Constructor for $package has been replaced with an unknown sub"
      if $constructor != $current;
    croak "Constructor for $package has been inlined and cannot be updated"
      if $self->{inlined};
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $quote_opts = {
      %{$quote_opts||{}},
      package => $into,
    };
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
  
    my $into_buildargs = $into->can('BUILDARGS');
  
    my $body
      = '    my $invoker = CORE::shift();'."\n"
      . '    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n"
      . $self->_handle_subconstructor($into, $name)
      . ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS
        ? $self->_generate_args_via_buildargs
        : $self->_generate_args
      )
      . $self->_check_required($spec)
      . '    my $new = '.$self->construction_string.";\n"
      . $self->_assign_new($spec)
      . ( $into->can('BUILD')
        ? $self->buildall_generator->buildall_body_for( $into, '$new', '$args' )
        : ''
      )
      . '    return $new;'."\n";
  
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.quotify($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg = $test{$_};
      my $arg_key = quotify($arg);
      my $test = defined $arg ? "exists \$args->{$arg_key}" : undef;
      my $source = defined $arg ? "\$args->{$arg_key}" : undef;
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $arg,
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my $s = $spec->{$_}; # ignore required if default or builder set
          $s->{required} and not($s->{builder} or exists $s->{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, '
      .join(', ', map quotify($_), @required_init).') {'."\n"
      .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n"
      ."    }\n";
  }
  
  # bootstrap our own constructor
  sub new {
    my $class = shift;
    delete _getstash(__PACKAGE__)->{new};
    bless $class->BUILDARGS(@_), $class;
  }
  Moo->_constructor_maker_for(__PACKAGE__)
  ->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'bare' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'bare' },
  );
  if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
    Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__);
  }
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils qw(_getglob);
  use Moo::_mro;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{mro::get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use Moo::_strictures;
  use Moo::_mro;
  use Moo::_Utils qw(
    _getglob
    _getstash
    _install_coderef
    _install_modifier
    _load_module
    _set_loaded
    _unimport_coderefs
  );
  use Scalar::Util qw(reftype);
  use Carp qw(croak);
  BEGIN {
    our @CARP_NOT = qw(
      Method::Generate::Constructor
      Method::Generate::Accessor
      Moo::sification
      Moo::_Utils
      Moo::Role
    );
  }
  
  our $VERSION = '2.003004';
  $VERSION =~ tr/_//d;
  
  require Moo::sification;
  Moo::sification->import;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
  
    strict->import;
    warnings->import;
  
    if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
      croak "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        croak "Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_;
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map +(
      !ref($_) ? *$_{CODE}||() : reftype($_) eq 'CODE' ? $_ : ()
    ), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
        croak "Can't extend role '$superclass'";
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      $old->assert_constructor;
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              require Sub::Defer;
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
  
      my %construct_opts = (
        package => $target,
        accessor_generator => $class->_accessor_maker_for($target),
        subconstructor_handler => (
          '      if ($Moo::MAKERS{$class}) {'."\n"
          .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
          .'          package '.$target.';'."\n"
          .'          return $invoker->SUPER::new(@_);'."\n"
          .'        }'."\n"
          .'        '.$class.'->_constructor_maker_for($class);'."\n"
          .'        return $invoker->new(@_)'.";\n"
          .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
          .'        return $meta->new_object('."\n"
          .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
          .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
          .'        );'."\n"
          .'      }'."\n"
        ),
      );
  
      my $con;
      my @isa = @{mro::get_linear_isa($target)};
      shift @isa;
      no strict 'refs';
      if (my ($parent_new) = grep +(defined &{$_.'::new'}), @isa) {
        if ($parent_new eq 'Moo::Object') {
          # no special constructor needed
        }
        elsif (my $makers = $MAKERS{$parent_new}) {
          $con = $makers->{constructor};
          $construct_opts{construction_string} = $con->construction_string
            if $con;
        }
        elsif ($parent_new->can('BUILDALL')) {
          $construct_opts{construction_builder} = sub {
            my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
            'do {'
            .'  my $args = $class->'.$inv.'BUILDARGS(@_);'
            .'  $args->{__no_BUILD__} = 1;'
            .'  $invoker->'.$target.'::SUPER::new($args);'
            .'}'
          };
        }
        else {
          $construct_opts{construction_builder} = sub {
            '$invoker->'.$target.'::SUPER::new('
              .($target->can('FOREIGNBUILDARGS') ?
                '$class->FOREIGNBUILDARGS(@_)' : '@_')
              .')'
          };
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(%construct_opts)
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $class) = @_;
    my $makers = $MAKERS{$class};
    # grab class symbol table
    my $stash = _getstash($class);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${class}::$_"} ? \&{"${class}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || reftype($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
    package Cat::Food;
  
    use Moo;
    use strictures 2;
    use namespace::clean;
  
    sub feed_lion {
      my $self = shift;
      my $amount = shift || 1;
  
      $self->pounds( $self->pounds - $amount );
    }
  
    has taste => (
      is => 'ro',
    );
  
    has brand => (
      is  => 'ro',
      isa => sub {
        die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
      },
    );
  
    has pounds => (
      is  => 'rw',
      isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
    );
  
    1;
  
  And elsewhere:
  
    my $full = Cat::Food->new(
        taste  => 'DELICIOUS.',
        brand  => 'SWEET-TREATZ',
        pounds => 10,
    );
  
    $full->feed_lion;
  
    say $full->pounds;
  
  =head1 DESCRIPTION
  
  C<Moo> is an extremely light-weight Object Orientation system. It allows one to
  concisely define objects and roles with a convenient syntax that avoids the
  details of Perl's object system.  C<Moo> contains a subset of L<Moose> and is
  optimised for rapid startup.
  
  C<Moo> avoids depending on any XS modules to allow for simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite --
  two thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead to provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  But if you don't want to use L<Moose>, you may not want "less metaprotocol"
  like L<Mouse> offers, but you probably want "no metaprotocol", which is what
  Moo provides. C<Moo> is ideal for some situations where deployment or startup
  time precludes using L<Moose> and L<Mouse>:
  
  =over 2
  
  =item a command line or CGI script where fast startup is essential
  
  =item code designed to be deployed as a single file via L<App::FatPacker>
  
  =item a CPAN module that may be used by others in the above situations
  
  =back
  
  C<Moo> maintains transparent compatibility with L<Moose> so if you install and
  load L<Moose> you can use Moo classes and roles in L<Moose> code without
  modification.
  
  Moo -- Minimal Object Orientation -- aims to make it smooth to upgrade to
  L<Moose> when you need more than the minimal features offered by Moo.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without modification.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  L<Moo> classes and roles, so that in Moose classes C<< isa => 'MyMooClass' >>
  and C<< isa => 'MyMooRole' >> work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  Extending a L<Mouse> class or consuming a L<Mouse::Role> will also work. But
  note that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  global and turns the mechanism off entirely so don't put this in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it will be used
  to generate simple accessors, readers, and writers for better performance.
  Simple accessors are those without lazy defaults, type checks/coercions, or
  triggers.  Simple readers are those without lazy defaults. Readers and writers
  generated by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 PUBLIC METHODS
  
  Moo provides several methods to any class using it.
  
  =head2 new
  
    Foo::Bar->new( attr1 => 3 );
  
  or
  
    Foo::Bar->new({ attr1 => 3 });
  
  The constructor for the class.  By default it will accept attributes either as a
  hashref, or a list of key value pairs.  This can be customized with the
  L</BUILDARGS> method.
  
  =head2 does
  
    if ($foo->does('Some::Role1')) {
      ...
    }
  
  Returns true if the object composes in the passed role.
  
  =head2 DOES
  
    if ($foo->DOES('Some::Role1') || $foo->DOES('Some::Class1')) {
      ...
    }
  
  Similar to L</does>, but will also return true for both composed roles and
  superclasses.
  
  =head2 meta
  
    my $meta = Foo::Bar->meta;
    my @methods = $meta->get_method_list;
  
  Returns an object that will behave as if it is a
  L<Moose metaclass|Moose::Meta::Class> object for the class. If you call
  anything other than C<make_immutable> on it, the object will be transparently
  upgraded to a genuine L<Moose::Meta::Class> instance, loading Moose in the
  process if required. C<make_immutable> itself is a no-op, since we generate
  metaclasses that are already immutable, and users converting from Moose had
  an unfortunate tendency to accidentally load Moose by calling it.
  
  =head1 LIFECYCLE METHODS
  
  There are several methods that you can define in your class to control
  construction and destruction of objects.  They should be used rather than trying
  to modify C<new> or C<DESTROY> yourself.
  
  =head2 BUILDARGS
  
    around BUILDARGS => sub {
      my ( $orig, $class, @args ) = @_;
  
      return { attr1 => $args[0] }
        if @args == 1 && !ref $args[0];
  
      return $class->$orig(@args);
    };
  
    Foo::Bar->new( 3 );
  
  This class method is used to transform the arguments to C<new> into a hash
  reference of attribute values.
  
  The default implementation accepts a hash or hash reference of named parameters.
  If it receives a single argument that isn't a hash reference it will throw an
  error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
    sub FOREIGNBUILDARGS {
      my ( $class, $options ) = @_;
      return $options->{foo};
    }
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as L</BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
    sub BUILD {
      my ($self, $args) = @_;
      die "foo and bar cannot be used at the same time"
        if exists $args->{foo} && exists $args->{bar};
    }
  
  On object creation, any C<BUILD> methods in the class's inheritance hierarchy
  will be called on the object and given the results of L</BUILDARGS>.  They each
  will be called in order from the parent classes down to the child, and thus
  should not themselves call the parent's method.  Typically this is used for
  object validation or possibly logging.
  
  =head2 DEMOLISH
  
    sub DEMOLISH {
      my ($self, $in_global_destruction) = @_;
      ...
    }
  
  When an object is destroyed, any C<DEMOLISH> methods in the inheritance
  hierarchy will be called on the object.  They are given boolean to inform them
  if global destruction is in progress, and are called from the child class upwards
  to the parent.  This is similar to L</BUILD> methods but in the opposite order.
  
  Note that this is implemented by a C<DESTROY> method, which is only created on
  on the first construction of an object of your class.  This saves on overhead for
  classes that are never instantiated or those without C<DEMOLISH> methods.  If you
  try to define your own C<DESTROY>, this will cause undefined results.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
    extends 'Parent::Class';
  
  Declares a base class. Multiple superclasses can be passed for multiple
  inheritance but please consider using L<roles|Moo::Role> instead.  The class
  will be loaded but no errors will be triggered if the class can't be found and
  there are already subs in the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
    with 'Some::Role1';
  
  or
  
    with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles cannot be composed because they
  have conflicting method definitions.  The roles will be loaded using the same
  mechanism as C<extends> uses.
  
  =head2 has
  
    has attr => (
      is => 'ro',
    );
  
  Declares an attribute for the class.
  
    package Foo;
    use Moo;
    has 'attr' => (
      is => 'ro'
    );
  
    package Bar;
    use Moo;
    extends 'Foo';
    has '+attr' => (
      default => sub { "blah" },
    );
  
  Using the C<+> notation, it's possible to override an attribute.
  
    has [qw(attr1 attr2 attr3)] => (
      is => 'ro',
    );
  
  Using an arrayref with multiple attribute names, it's possible to declare
  multiple attributes with the same options.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item C<is>
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> stands for "read-only" and generates an accessor that dies if you attempt
  to write to it - i.e.  a getter only - by defaulting C<reader> to the name of
  the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> stands for "read-write protected" and generates a reader like C<ro>, but
  also sets C<writer> to C<_set_${attribute_name}> for attributes that are
  designed to be written from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> stands for "read-write" and generates a normal getter/setter by
  defaulting the C<accessor> to the name of the attribute specified.
  
  =item C<isa>
  
  Takes a coderef which is used to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
    use Scalar::Util qw(looks_like_number);
    ...
    isa => sub {
      die "$_[0] is not a number!" unless looks_like_number $_[0]
    },
  
  Note that the return value for C<isa> is discarded. Only if the sub dies does
  type validation fail.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<Moose> compatible or L<MooseX::Types> style named types, look at
  L<Type::Tiny>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item C<coerce>
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always execute your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  If the C<isa> option is a blessed object providing a C<coerce> or
  C<coercion> method, then the C<coerce> option may be set to just C<1>.
  
  =item C<handles>
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a L<role|Moo::Role> that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
    handles => [ qw( one two ) ]
  
  Takes a hashref
  
    handles => {
      un => 'one',
    }
  
  =item C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. The coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item C<default>
  
  Takes a coderef which will get called with $self as its only argument to
  populate an attribute if no value for that attribute was supplied to the
  constructor. Alternatively, if the attribute is lazy, C<default> executes when
  the attribute is first retrieved if no value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  B<NOTE:> If the attribute is C<lazy>, it will be regenerated from C<default> or
  C<builder> the next time it is accessed. If it is not lazy, it will be C<undef>.
  
  =item C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on object instantiation.
  
  =item C<reader>
  
  The name of the method that returns the value of the attribute.  If you like
  Java style methods, you might set this to C<get_foo>
  
  =item C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened. Use this when circular references, which cause memory leaks, are
  possible.
  
  =item C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
    before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 around
  
    around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 after
  
    after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... }; >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
    package Record;
  
    use Digest::MD5 qw(md5_hex);
  
    use Moo;
    use namespace::clean;
  
    has name => (is => 'ro', required => 1);
    has id => (is => 'lazy');
    sub _build_id {
      my ($self) = @_;
      return md5_hex($self->name);
    }
  
    1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> Older versions of L<namespace::autoclean> would
  inflate Moo classes to full L<Moose> classes, losing the benefits of Moo.  If
  you want to use L<namespace::autoclean> with a Moo class, make sure you are
  using version 0.16 or newer.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, L<Type::Tiny> can provide types, type libraries, and
  will work seamlessly with both L<Moo> and L<Moose>.  L<Type::Tiny> can be
  considered the successor to L<MooseX::Types> and provides a similar API, so
  that you can write
  
    use Types::Standard qw(Int);
    has days_to_live => (is => 'ro', isa => Int);
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you need
  L<Moose> - Moo is small because it explicitly does not provide a metaprotocol.
  However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and
  L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  Handling of warnings: when you C<use Moo> we enable strict and warnings, in a
  similar way to Moose. The authors recommend the use of C<strictures>, which
  enables FATAL warnings, and several extra pragmas when used in development:
  L<indirect>, L<multidimensional>, and L<bareword::filehandles>.
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
    package MyClass;
    use Moo;
    use strictures 2;
  
  The nearest L<Moose> invocation would be:
  
    package MyClass;
  
    use Moose;
    use warnings FATAL => "all";
    use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
    package MyClass;
  
    use Moose;
    use MooseX::NonMoose;
    use warnings FATAL => "all";
    use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
    __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  bubaflub - Bob Kuo (cpan:BUBAFLUB) <bubaflub@cpan.org>
  
  ether = Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2015 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  use Moo::_strictures;
  use Moo::_Utils qw(_getstash);
  use Sub::Quote qw(quotify);
  use Carp qw(croak);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    croak "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', keys %Moo::MAKERS;
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
    @Moo::HandleMoose::FakeMeta::ISA = 'Moose::Meta::Method::Meta';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    require Sub::Defer;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $am_class, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, 0, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, 1, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, 0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    {
      local $DID_INJECT{$name} = 1;
      foreach my $spec (values %$attr_specs) {
        if (my $inflators = delete $spec->{moosify}) {
          $_->($spec) for @$inflators;
        }
      }
  
      my %methods
        = %{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};
  
      # if stuff gets added afterwards, _maybe_reset_handlemoose should
      # trigger the recreation of the metaclass but we need to ensure the
      # Moo::Role cache is cleared so we don't confuse Moo itself.
      if (my $info = $Moo::Role::INFO{$name}) {
        delete $info->{methods};
      }
  
      # needed to ensure the method body is stable and get things named
      $methods{$_} = Sub::Defer::undefer_sub($methods{$_})
        for
          grep $_ ne 'new',
          keys %methods;
      my @attrs;
      {
        # This local is completely not required for roles but harmless
        local @{_getstash($name)}{keys %methods};
        my %seen_name;
        foreach my $attr_name (@$attr_order) {
          $seen_name{$attr_name} = 1;
          my %spec = %{$attr_specs->{$attr_name}};
          my %spec_map = (
            map { $_->name => $_->init_arg||$_->name }
            (
              (grep { $_->has_init_arg }
                $meta->attribute_metaclass->meta->get_all_attributes),
              grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
              map {
                my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                            ->meta;
                map $meta->get_attribute($_), $meta->get_attribute_list
              }  @{$spec{traits}||[]}
            )
          );
          # have to hard code this because Moose's role meta-model is lacking
          $spec_map{traits} ||= 'traits';
  
          $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
          my $coerce = $spec{coerce};
          if (my $isa = $spec{isa}) {
            my $tc = $spec{isa} = do {
              if (my $mapped = $TYPE_MAP{$isa}) {
                my $type = $mapped->();
                unless ( Scalar::Util::blessed($type)
                    && $type->isa("Moose::Meta::TypeConstraint") ) {
                  croak "error inflating attribute '$attr_name' for package '$name': "
                    ."\$TYPE_MAP{$isa} did not return a valid type constraint'";
                }
                $coerce ? $type->create_child_type(name => $type->name) : $type;
              } else {
                Moose::Meta::TypeConstraint->new(
                  constraint => sub { eval { &$isa; 1 } }
                );
              }
            };
            if ($coerce) {
              $tc->coercion(Moose::Meta::TypeCoercion->new)
                ->_compiled_type_coercion($coerce);
              $spec{coerce} = 1;
            }
          } elsif ($coerce) {
            my $attr = quotify($attr_name);
            my $tc = Moose::Meta::TypeConstraint->new(
                      constraint => sub { die "This is not going to work" },
                      inlined => sub {
                          'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                      },
                    );
            $tc->coercion(Moose::Meta::TypeCoercion->new)
              ->_compiled_type_coercion($coerce);
            $spec{isa} = $tc;
            $spec{coerce} = 1;
          }
          %spec =
            map { $spec_map{$_} => $spec{$_} }
            grep { exists $spec_map{$_} }
            keys %spec;
          push @attrs, $meta->add_attribute($attr_name => %spec);
        }
        foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
          foreach my $attr ($mouse->get_all_attributes) {
            my %spec = %{$attr};
            delete @spec{qw(
              associated_class associated_methods __METACLASS__
              provides curries
            )};
            my $attr_name = delete $spec{name};
            next if $seen_name{$attr_name}++;
            push @attrs, $meta->add_attribute($attr_name => %spec);
          }
        }
      }
      foreach my $meth_name (keys %methods) {
        my $meth_code = $methods{$meth_name};
        $meta->add_method($meth_name, $meth_code);
      }
  
      if ($am_role) {
        my $info = $Moo::Role::INFO{$name};
        $meta->add_required_methods(@{$info->{requires}});
        foreach my $modifier (@{$info->{modifiers}}) {
          my ($type, @args) = @$modifier;
          my $code = pop @args;
          $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
        }
      }
      elsif ($am_class) {
        foreach my $attr (@attrs) {
          foreach my $method (@{$attr->associated_methods}) {
            $method->{body} = $name->can($method->name);
          }
        }
        bless(
          $meta->find_method_by_name('new'),
          'Moo::HandleMoose::FakeConstructor',
        );
        my $meta_meth;
        if (
          $meta_meth = $meta->find_method_by_name('meta')
          and $meta_meth->body == \&Moo::Object::meta
        ) {
          bless($meta_meth, 'Moo::HandleMoose::FakeMeta');
        }
        # a combination of Moo and Moose may bypass a Moo constructor but still
        # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
        # global destruction.
        require Method::Generate::DemolishAll;
      }
      $meta->add_role(Class::MOP::class_of($_))
        for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
          keys %{$Moo::Role::APPLIED_TO{$name}}
    }
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  use Moo::_strictures;
  use Carp ();
  BEGIN { our @CARP_NOT = qw(Moo::HandleMoose) }
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    my $self = shift;
    Carp::croak "Can't call $meth without object instance"
      if !ref $self;
    Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)
  }
  sub can {
    my $self = shift;
    return $self->SUPER::can(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)
  }
  sub isa {
    my $self = shift;
    return $self->SUPER::isa(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use Moo::_strictures;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  use Config;
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/) {
      my $type = $1;
      my $id = do { no warnings 'portable'; hex "$2" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref or Scalar::Util::reftype($ref) ne $type) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  if ($Config{useithreads}) {
    my @types = %TYPE_MAP;
    tie %TYPE_MAP, __PACKAGE__;
    %TYPE_MAP = @types;
  }
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use Moo::_strictures;
  use Carp ();
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    my $proto = $class->BUILDARGS(@_);
    $NO_BUILD{$class} and
      return bless({}, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({}, $class)
      : bless({}, $class)->BUILDALL($proto);
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
    my $class = shift;
    scalar @_ == 1
      ? ref $_[0] eq 'HASH'
        ? { %{ $_[0] } }
        : Carp::croak("Single parameters to new() must be a HASH ref"
            . " data => ". $_[0])
      : @_ % 2
        ? Carp::croak("The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments")
        : {@_}
    ;
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    return !!0
      unless ($INC{'Moose/Role.pm'} || $INC{'Role/Tiny.pm'});
    require Moo::Role;
    my $does = Moo::Role->can("does_role");
    { no warnings 'redefine'; *does = $does }
    goto &$does;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use Moo::_strictures;
  use Moo::_Utils qw(
    _getglob
    _getstash
    _install_coderef
    _install_modifier
    _load_module
    _name_coderef
    _set_loaded
    _unimport_coderefs
  );
  use Carp qw(croak);
  use Role::Tiny ();
  BEGIN { our @ISA = qw(Role::Tiny) }
  BEGIN {
    our @CARP_NOT = qw(
      Method::Generate::Accessor
      Method::Generate::Constructor
      Moo::sification
      Moo::_Utils
    );
  }
  
  our $VERSION = '2.003004';
  $VERSION =~ tr/_//d;
  
  require Moo::sification;
  Moo::sification->import;
  
  BEGIN {
      *INFO = \%Role::Tiny::INFO;
      *APPLIED_TO = \%Role::Tiny::APPLIED_TO;
      *COMPOSED = \%Role::Tiny::COMPOSED;
      *ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
  }
  
  our %INFO;
  our %APPLIED_TO;
  our %APPLY_DEFAULTS;
  our %COMPOSED;
  our @ON_ROLE_CREATE;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      croak "Cannot import Moo::Role into a Moo class";
    }
    _set_loaded(caller);
    goto &Role::Tiny::import;
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    *{_getglob("${target}::meta")} = $me->can('meta');
  }
  
  push @ON_ROLE_CREATE, sub {
    my $target = shift;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  };
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    _load_module($role);
    $self->_inhale_if_moose($role);
    croak "${role} is not a Moo::Role" unless $self->is_role($role);
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub is_role {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    $self->SUPER::is_role($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    my $meta;
    if (!$self->SUPER::is_role($role)
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
            require Sub::Quote;
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
            my $tc_var = '$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);
  
            $spec->{isa} = Sub::Quote::quote_sub(
              qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },
              { $tc_var => \$check },
              {
                package => $role,
              },
            );
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub _undefer_subs {
    my ($self, $target, $role) = @_;
    if ($INC{'Sub/Defer.pm'}) {
      Sub::Defer::undefer_package($role);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _undefer_subs _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      croak "${role} is not a Moo::Role" unless $me->is_role($role);
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    _load_module($role);
    $me->_inhale_if_moose($role);
    croak "${role} is not a Moo::Role" unless $me->is_role($role);
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      croak "${role} is not a Moo::Role" unless $me->is_role($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      @{*{_getglob("${new_name}::ISA")}{ARRAY}} = ($superclass);
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->apply_roles_to_package($new_name, @roles);
    }
    else {
      $me->SUPER::create_class_with_roles($superclass, @roles);
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->_handle_constructor($new_name, $_) for @roles;
    }
  
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($new_name);
    }
    $COMPOSED{class}{$new_name} = 1;
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    my $class = ref $new;
    _set_loaded($class, (caller)[1]);
  
    my $apply_defaults = exists $APPLY_DEFAULTS{$class} ? $APPLY_DEFAULTS{$class}
      : $APPLY_DEFAULTS{$class} = do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for($class)
          and my $m = Moo->_accessor_maker_for($class)) {
  
        my $specs = $con_gen->all_attribute_specs;
  
        my %captures;
        my $code = join('',
          ( map {
            my $name = $_;
            my $spec = $specs->{$name};
            if ($m->has_eager_default($name, $spec)) {
              my ($has, $has_cap)
                = $m->generate_simple_has('$_[0]', $name, $spec);
              my ($set, $pop_cap)
                = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
              @captures{keys %$has_cap, keys %$pop_cap}
                = (values %$has_cap, values %$pop_cap);
              "($set),";
            }
            else {
              ();
            }
          } sort keys %attrs ),
        );
        if ($code) {
          require Sub::Quote;
          Sub::Quote::quote_sub(
            "${class}::_apply_defaults",
            "no warnings 'void';\n$code",
            \%captures,
            {
              package => $class,
              no_install => 1,
            }
          );
        }
        else {
          0;
        }
      }
      else {
        0;
      }
    };
    if ($apply_defaults) {
      local $Carp::Internal{+__PACKAGE__} = 1;
      local $Carp::Internal{$class} = 1;
      $new->$apply_defaults;
    }
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _install_does {
      my ($me, $to) = @_;
  
      # If Role::Tiny actually installed the DOES, give it a name
      my $new = $me->SUPER::_install_does($to) or return;
      return _name_coderef("${to}::DOES", $new);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return 1
      if Role::Tiny::does_role($proto, $role);
    my $meta;
    if ($INC{'Moose.pm'}
        and $meta = Class::MOP::class_of($proto)
        and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
        and $meta->can('does_role')
    ) {
      return $meta->does_role($role);
    }
    return 0;
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    my $info = $INFO{$to};
    my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
    my %existing
      = $info ? @{$info->{attributes} || []}
      : $con  ? %{$con->all_attribute_specs || {}}
      : ();
  
    my @attr_info =
      map { @{$attr_info}[$_, $_+1] }
      grep { ! $existing{$attr_info->[$_]} }
      map { 2 * $_ } 0..@$attr_info/2-1;
  
    if ($info) {
      push @{$info->{attributes}||=[]}, @attr_info;
    }
    elsif ($con) {
      # shallow copy of the specs since the constructor will assign an index
      $con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
    package My::Role;
  
    use Moo::Role;
    use strictures 2;
  
    sub foo { ... }
  
    sub bar { ... }
  
    has baz => (
      is => 'ro',
    );
  
    1;
  
  And elsewhere:
  
    package Some::Class;
  
    use Moo;
    use strictures 2;
  
    # bar gets imported, but not foo
    with('My::Role');
  
    sub foo { ... }
  
    1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
    has attr => (
      is => 'ro',
    );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
    package My::Role::ID;
  
    use Digest::MD5 qw(md5_hex);
    use Moo::Role;
    use Digest::SHA qw(sha1_hex);
  
    requires 'name';
  
    sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
    sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
    1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  use Moo::_strictures;
  
  {
    no strict 'refs';
    sub _getglob { \*{$_[0]} }
    sub _getstash { \%{"$_[0]::"} }
  }
  
  BEGIN {
    my ($su, $sn);
    $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname
      or $sn = $INC{'Sub/Name.pm'}
      or $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname
      or $sn = eval { require Sub::Name; };
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_CAN_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use Exporter qw(import);
  use Config;
  use Carp qw(croak);
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _getstash _install_coderef _name_coderef
      _unimport_coderefs _set_loaded
  );
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if ($INC{'Sub/Defer.pm'} and my $to_modify = $into->can($name)) { # CMM will throw for us if not
      Sub::Defer::undefer_sub($to_modify);
    }
  
    require Class::Method::Modifiers;
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  sub _load_module {
    my $module = $_[0];
    my $file = eval { module_notional_filename($module) } or croak $@;
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(ref($_) || *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    croak $error;
  }
  
  our %MAYBE_LOADED;
  sub _maybe_load_module {
    my $module = $_[0];
    return $MAYBE_LOADED{$module}
      if exists $MAYBE_LOADED{$module};
    if(! eval { use_package_optimistically($module) }) {
      warn "$module exists but failed to load with error: $@";
    }
    elsif ( $INC{module_notional_filename($module)} ) {
      return $MAYBE_LOADED{$module} = 1;
    }
    return $MAYBE_LOADED{$module} = 0;
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    _CAN_SUBNAME ? _subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  use Moo::_strictures;
  
  if ("$]" >= 5.010_000) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;
  use strict;
  use warnings;
  
  sub import {
    if ($ENV{MOO_FATAL_WARNINGS}) {
      require strictures;
      strictures->VERSION(2);
      @_ = ('strictures');
      goto &strictures::import;
    }
    else {
      strict->import;
      warnings->import;
      warnings->unimport('once');
    }
  }
  
  1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use Moo::_strictures;
  no warnings 'once';
  use Devel::GlobalDestruction qw(in_global_destruction);
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Moo::HandleMoose) }
  
  sub unimport {
    croak "Can't disable Moo::sification after inflation has been done"
      if $Moo::HandleMoose::SETUP_DONE;
    our $disabled = 1;
  }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disabled or in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  sub import {
    return
      if our $setup_done;
    if ($INC{"Moose.pm"}) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    } else {
      $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
    }
    $setup_done = 1;
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Pithub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB';
  package Pithub;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 API
  
  use Moo;
  use Pithub::Events;
  use Pithub::Gists;
  use Pithub::GitData;
  use Pithub::Issues;
  use Pithub::Orgs;
  use Pithub::PullRequests;
  use Pithub::Repos;
  use Pithub::Search;
  use Pithub::SearchV3;
  use Pithub::Users;
  use Carp 'croak';
  extends 'Pithub::Base';
  
  
  sub _validate_search_api {
      my %search_apis = map { $_ => 1 } qw(legacy v3);
      croak "unknown search api '$_[0]'"
          unless exists $search_apis{$_[0]};
  }
  
  
  has search_api => (
      is  => 'ro',
      isa => \&_validate_search_api,
      default => 'legacy',
  );
  
  sub _search_class {
      my ($self, $search_api) = @_;
  
      _validate_search_api($search_api);
  
      return $search_api eq 'legacy'
          ? 'Pithub::Search'
          : 'Pithub::SearchV3';
  }
  
  
  sub events {
      return shift->_create_instance('Pithub::Events', @_);
  }
  
  
  sub gists {
      return shift->_create_instance('Pithub::Gists', @_);
  }
  
  
  sub git_data {
      return shift->_create_instance('Pithub::GitData', @_);
  }
  
  
  sub issues {
      return shift->_create_instance('Pithub::Issues', @_);
  }
  
  
  sub markdown {
      return shift->_create_instance('Pithub::Markdown', @_);
  }
  
  
  sub orgs {
      return shift->_create_instance('Pithub::Orgs', @_);
  }
  
  
  sub pull_requests {
      return shift->_create_instance('Pithub::PullRequests', @_);
  }
  
  
  sub repos {
      return shift->_create_instance('Pithub::Repos', @_);
  }
  
  
  sub search {
      my ($self, %args) = @_;
      my $class = $self->_search_class(
          exists $args{search_api}
              ? delete $args{search_api}
              : $self->search_api,
      );
      return shift->_create_instance($class, @_);
  }
  
  
  sub users {
      return shift->_create_instance('Pithub::Users', @_);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub - Github v3 API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 SYNOPSIS
  
      use Pithub;
      use Data::Dumper;
  
      my $p = Pithub->new;
      # my $p = Pithub->new(utf8 => 0); # enable compatibility options for version 0.01029 or lower
      my $result = $p->repos->get( user => 'plu', repo => 'Pithub' );
  
      # $result->content is either an arrayref or an hashref
      # depending on the API call that has been made
      printf "%s\n", $result->content->{html_url};     # prints https://github.com/plu/Pithub
      printf "%s\n", $result->content->{clone_url};    # prints https://github.com/plu/Pithub.git
  
      # if the result is an arrayref, you can use the result iterator
      my $result = $p->repos->list( user => 'plu' );
      while ( my $row = $result->next ) {
          printf "%s\n", $row->{name};
      }
  
      # Connect to your local GitHub Enterprise instance
      my $p = Pithub->new(
          api_uri => 'https://github.yourdomain.com/api/v3/'
      );
  
      # No need to provide user/repo to each module:
      my $pit = Pithub->new(
        user  => 'plu',
        repo  => 'pithub',
        token => 'my_oauth_token',
      );
  
      $pit->repos->get;
      $pit->repos->commits->list;
  
  =head1 DESCRIPTION
  
  L<Pithub> (B<P>erl + GB<ithub>) provides a set of modules to access the
  L<Github v3 API|http://developer.github.com/v3/> in an object
  oriented way. There is also L<Net::GitHub> which does the same for
  all the versions (v1, v2, v3) of the Github API.
  L<Pithub> supports all API calls so far, but only for v3.
  
  =head1 ATTRIBUTES
  
  =head2 search_api
  
      my $p = Pithub->new({ search_api => 'v3' });
      my $search = $p->search; # $search->isa('Pithub::SearchV3');
  
  This attribute allows the default for the API to use for searches to be
  specified. The two accepted values are C<v3> and C<legacy>. For compatibility
  reasons the default is C<legacy>.
  
  =head1 METHODS
  
  =head2 events
  
  Provides access to L<Pithub::Events>.
  
  =head2 gists
  
  Provides access to L<Pithub::Gists>.
  
  =head2 git_data
  
  Provides access to L<Pithub::GitData>.
  
  =head2 issues
  
  Provides access to L<Pithub::Issues>.
  
  =head2 markdown
  
  Provides access to L<Pithub::Markdown>.
  
  =head2 orgs
  
  Provides access to L<Pithub::Orgs>.
  
  =head2 pull_requests
  
  Provides access to L<Pithub::PullRequests>.
  
  =head2 repos
  
  Provides access to L<Pithub::Repos>.
  
  =head2 search
  
    my $legacy_search  = $p->search(search_api => 'legacy');
    my $v3_search      = $p->search(search_api => 'v3');
    my $default_search = $p->search;
  
  Provides access to L<Pithub::Search> and L<Pithub::SearchV3>. When no
  C<search_api> option is given, the value provided by the C<search_api>
  attribute is used.
  
  =head2 users
  
  Provides access to L<Pithub::Users>.
  
  =head1 DOCUMENTATION
  
  Quite a lot of the L<Pithub> documentation has been taken directly
  from the great API documentation at
  L<Github|http://developer.github.com/v3/>. Please also read the
  documentation there, since it might be more complete and more
  up-to-date.
  
  L<Pithub::Base> contains documentation for attributes inherited by all
  Pithub modules.
  
  =head1 WARNING
  
  L<Pithub> as well as the
  L<Github v3 API|http://developer.github.com/v3/> are still under
  development. So there might be things broken on both sides. Besides
  that it's possible that the API will change. This applies to
  L<Pithub> itself as well as the
  L<Github v3 API|http://developer.github.com/v3/>.
  
  =head1 CONTRIBUTE
  
  This module is hosted on L<Github|https://github.com/plu/Pithub>, so
  feel free to fork it and send pull requests.
  There are two different kinds of test suites, one is just checking
  the HTTP requests that are created by the method calls, without
  actually sending them. The second one is sending real requests to
  the Github API. If you want to contribute to this project, I highly
  recommend to run the live tests on a test account, because it will
  generate a lof of activity.
  
  =head1 MODULES
  
  There are different ways of using the Pithub library. You can either
  use the main module L<Pithub> to get access to all other
  modules, like L<Pithub::Repos> for example. Or you can use
  L<Pithub::Repos> directly and create an instance of it. All
  modules accept the same L<attributes|Pithub::Base/ATTRIBUTES>,
  either in the constructor or later by calling the setters.
  
  Besides that there are other modules involved. Every method call
  which maps directly to a Github API call returns a
  L<Pithub::Result> object. This contains everything interesting
  about the response returned from the API call.
  
  L<Pithub::Base> might be interesting for two reasons:
  
  =over
  
  =item *
  
  The list of L<attributes|Pithub::Base/ATTRIBUTES> which all modules
  accept.
  
  =item *
  
  The L<request|Pithub::Base/request> method: In case Github adds a
  new API call which is not supported yet by L<Pithub> the
  L<request|Pithub::Base/request> method can be used directly to
  perform this new API call, there's some documentation on how to
  use it.
  
  =over
  
  =item *
  
  L<Pithub::Events>
  
  See also: L<http://developer.github.com/v3/events/>
  
      my $events = Pithub->new->events;
      my $events = Pithub::Events->new;
  
  =item *
  
  L<Pithub::Gists>
  
  See also: L<http://developer.github.com/v3/gists/>
  
      my $gists = Pithub->new->gists;
      my $gists = Pithub::Gists->new;
  
  =over
  
  =item *
  
  L<Pithub::Gists::Comments>
  
  See also: L<http://developer.github.com/v3/gists/comments/>
  
      my $comments = Pithub->new->gists->comments;
      my $comments = Pithub::Gists->new->comments;
      my $comments = Pithub::Gists::Comments->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::GitData>
  
  See also: L<http://developer.github.com/v3/git/>
  
      my $git_data = Pithub->new->git_data;
      my $git_data = Pithub::GitData->new;
  
  =over
  
  =item *
  
  L<Pithub::GitData::Blobs>
  
  See also: L<http://developer.github.com/v3/git/blobs/>
  
      my $blobs = Pithub->new->git_data->blobs;
      my $blobs = Pithub::GitData->new->blobs;
      my $blobs = Pithub::GitData::Blobs->new;
  
  =item *
  
  L<Pithub::GitData::Commits>
  
  See also: L<http://developer.github.com/v3/git/commits/>
  
      my $commits = Pithub->new->git_data->commits;
      my $commits = Pithub::GitData->new->commits;
      my $commits = Pithub::GitData::Commits->new;
  
  =item *
  
  L<Pithub::GitData::References>
  
  See also: L<http://developer.github.com/v3/git/refs/>
  
      my $references = Pithub->new->git_data->references;
      my $references = Pithub::GitData->new->references;
      my $references = Pithub::GitData::References->new;
  
  =item *
  
  L<Pithub::GitData::Tags>
  
  See also: L<http://developer.github.com/v3/git/tags/>
  
      my $tags = Pithub->new->git_data->tags;
      my $tags = Pithub::GitData->new->tags;
      my $tags = Pithub::GitData::Tags->new;
  
  =item *
  
  L<Pithub::GitData::Trees>
  
  See also: L<http://developer.github.com/v3/git/trees/>
  
      my $trees = Pithub->new->git_data->trees;
      my $trees = Pithub::GitData->new->trees;
      my $trees = Pithub::GitData::Trees->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Issues>
  
  See also: L<http://developer.github.com/v3/issues/>
  
      my $issues = Pithub->new->issues;
      my $issues = Pithub::Issues->new;
  
  =over
  
  =item *
  
  L<Pithub::Issues::Assignees>
  
  See also: L<http://developer.github.com/v3/issues/assignees/>
  
      my $assignees = Pithub->new->issues->assignees;
      my $assignees = Pithub::Issues->new->assignees;
      my $assignees = Pithub::Issues::Assignees->new;
  
  =item *
  
  L<Pithub::Issues::Comments>
  
  See also: L<http://developer.github.com/v3/issues/comments/>
  
      my $comments = Pithub->new->issues->comments;
      my $comments = Pithub::Issues->new->comments;
      my $comments = Pithub::Issues::Comments->new;
  
  =item *
  
  L<Pithub::Issues::Events>
  
  See also: L<http://developer.github.com/v3/issues/events/>
  
      my $events = Pithub->new->issues->events;
      my $events = Pithub::Issues->new->events;
      my $events = Pithub::Issues::Events->new;
  
  =item *
  
  L<Pithub::Issues::Labels>
  
  See also: L<http://developer.github.com/v3/issues/labels/>
  
      my $labels = Pithub->new->issues->labels;
      my $labels = Pithub::Issues->new->labels;
      my $labels = Pithub::Issues::Labels->new;
  
  =item *
  
  L<Pithub::Issues::Milestones>
  
  See also: L<http://developer.github.com/v3/issues/milestones/>
  
      my $milestones = Pithub->new->issues->milestones;
      my $milestones = Pithub::Issues->new->milestones;
      my $milestones = Pithub::Issues::Milestones->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Orgs>
  
  See also: L<http://developer.github.com/v3/orgs/>
  
      my $orgs = Pithub->new->orgs;
      my $orgs = Pithub::Orgs->new;
  
  =over
  
  =item *
  
  L<Pithub::Orgs::Members>
  
  See also: L<http://developer.github.com/v3/orgs/members/>
  
      my $members = Pithub->new->orgs->members;
      my $members = Pithub::Orgs->new->members;
      my $members = Pithub::Orgs::Members->new;
  
  =item *
  
  L<Pithub::Orgs::Teams>
  
  See also: L<http://developer.github.com/v3/orgs/teams/>
  
      my $teams = Pithub->new->orgs->teams;
      my $teams = Pithub::Orgs->new->teams;
      my $teams = Pithub::Orgs::Teams->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::PullRequests>
  
  See also: L<http://developer.github.com/v3/pulls/>
  
      my $pull_requests = Pithub->new->pull_requests;
      my $pull_requests = Pithub::PullRequests->new;
  
  =over
  
  =item *
  
  L<Pithub::PullRequests::Comments>
  
  See also: L<http://developer.github.com/v3/pulls/comments/>
  
      my $comments = Pithub->new->pull_requests->comments;
      my $comments = Pithub::PullRequests->new->comments;
      my $comments = Pithub::PullRequests::Comments->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Repos>
  
  See also: L<http://developer.github.com/v3/repos/>
  
      my $repos = Pithub->new->repos;
      my $repos = Pithub::Repos->new;
  
  =over
  
  =item *
  
  L<Pithub::Repos::Collaborators>
  
  See also: L<http://developer.github.com/v3/repos/collaborators/>
  
      my $collaborators = Pithub->new->repos->collaborators;
      my $collaborators = Pithub::Repos->new->collaborators;
      my $collaborators = Pithub::Repos::Collaborators->new;
  
  =item *
  
  L<Pithub::Repos::Commits>
  
  See also: L<http://developer.github.com/v3/repos/commits/>
  
      my $commits = Pithub->new->repos->commits;
      my $commits = Pithub::Repos->new->commits;
      my $commits = Pithub::Repos::Commits->new;
  
  =item *
  
  L<Pithub::Repos::Contents>
  
  See also: L<http://developer.github.com/v3/repos/contents/>
  
      my $contents = Pithub->new->repos->contents;
      my $contents = Pithub::Repos->new->contents;
      my $contents = Pithub::Repos::Contents->new;
  
  =item *
  
  L<Pithub::Repos::Downloads>
  
  Github says: The Downloads API (described below) was deprecated on
  December 11, 2012. It will be removed at a future date. We recommend
  using L<Pithub::Repos::Releases> instead.
  
  See also: L<http://developer.github.com/v3/repos/downloads/>
  
      my $downloads = Pithub->new->repos->downloads;
      my $downloads = Pithub::Repos->new->downloads;
      my $downloads = Pithub::Repos::Downloads->new;
  
  =item *
  
  L<Pithub::Repos::Forks>
  
  See also: L<http://developer.github.com/v3/repos/forks/>
  
      my $forks = Pithub->new->repos->forks;
      my $forks = Pithub::Repos->new->forks;
      my $forks = Pithub::Repos::Forks->new;
  
  =item *
  
  L<Pithub::Repos::Keys>
  
  See also: L<http://developer.github.com/v3/repos/keys/>
  
      my $keys = Pithub->new->repos->keys;
      my $keys = Pithub::Repos->new->keys;
      my $keys = Pithub::Repos::Keys->new;
  
  =item *
  
  L<Pithub::Repos::Releases>
  
  See also: L<http://developer.github.com/v3/repos/releases/>
  
      my $releases = Pithub->new->repos->releases;
      my $releases = Pithub::Repos->new->releases;
      my $releases = Pithub::Repos::Releases->new;
  
  =over
  
  =item *
  
  L<Pithub::Repos::Releases::Assets>
  
  See also: L<http://developer.github.com/v3/repos/releases/>
  
      my $assets = Pithub->new->repos->releases->assets;
      my $assets = Pithub::Repos->new->releases->assets;
      my $assets = Pithub::Repos::Releases->new->assets;
      my $assets = Pithub::Repos::Releases::Assets->new;
  
  =back
  
  =item *
  
  L<Pithub::Repos::Stats>
  
  See also: L<http://developer.github.com/v3/repos/statistics/>
  
      my $watching = Pithub->new->repos->stats;
      my $watching = Pithub::Repos->new->stats;
      my $watching = Pithub::Repos::Stats->new;
  
  =item *
  
  L<Pithub::Repos::Statuses>
  
  See also: L<http://developer.github.com/v3/repos/statuses/>
  
      my $watching = Pithub->new->repos->statuses;
      my $watching = Pithub::Repos->new->statuses;
      my $watching = Pithub::Repos::Statuses->new;
  
  =item *
  
  L<Pithub::Repos::Watching>
  
  See also: L<http://developer.github.com/v3/repos/watching/>
  
      my $watching = Pithub->new->repos->watching;
      my $watching = Pithub::Repos->new->watching;
      my $watching = Pithub::Repos::Watching->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Users>
  
  See also: L<http://developer.github.com/v3/users/>
  
      my $users = Pithub->new->users;
      my $users = Pithub::Users->new;
  
  =over
  
  =item *
  
  L<Pithub::Users::Emails>
  
  See also: L<http://developer.github.com/v3/users/emails/>
  
      my $emails = Pithub->new->users->emails;
      my $emails = Pithub::Users->new->emails;
      my $emails = Pithub::Users::Emails->new;
  
  =item *
  
  L<Pithub::Users::Followers>
  
  See also: L<http://developer.github.com/v3/users/followers/>
  
      my $followers = Pithub->new->users->followers;
      my $followers = Pithub::Users->new->followers;
      my $followers = Pithub::Users::Followers->new;
  
  =item *
  
  L<Pithub::Users::Keys>
  
  See also: L<http://developer.github.com/v3/users/keys/>
  
      my $keys = Pithub->new->users->keys;
      my $keys = Pithub::Users->new->keys;
      my $keys = Pithub::Users::Keys->new;
  
  =back
  
  =back
  
  =back
  
  =head1 CONTRIBUTORS
  
  =over
  
  =item *
  
  Andreas Marienborg
  
  =item *
  
  Alessandro Ghedini
  
  =item *
  
  Michael G Schwern
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB

$fatpacked{"Pithub/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_BASE';
  package Pithub::Base;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 base class for all Pithub modules
  
  use Moo;
  use Carp qw(croak);
  use HTTP::Headers;
  use HTTP::Request;
  use JSON::MaybeXS;
  use LWP::UserAgent;
  use Pithub::Result;
  use URI;
  
  with 'Pithub::Result::SharedCache';
  
  
  has 'auto_pagination' => (
      default => sub { 0 },
      is      => 'rw',
  );
  
  
  has 'api_uri' => (
      default => sub { URI->new('https://api.github.com') },
      is      => 'rw',
      trigger => sub {
          my ( $self, $uri ) = @_;
          $self->{api_uri} = URI->new("$uri");
      },
  );
  
  
  has 'jsonp_callback' => (
      clearer   => 'clear_jsonp_callback',
      is        => 'rw',
      predicate => 'has_jsonp_callback',
      required  => 0,
  );
  
  
  has 'per_page' => (
      clearer   => 'clear_per_page',
      is        => 'rw',
      predicate => 'has_per_page',
      default   => 100,
      required  => 0,
  );
  
  
  has 'prepare_request' => (
      clearer   => 'clear_prepare_request',
      is        => 'rw',
      predicate => 'has_prepare_request',
      required  => 0,
  );
  
  
  has 'repo' => (
      clearer   => 'clear_repo',
      is        => 'rw',
      predicate => 'has_repo',
      required  => 0,
  );
  
  
  has 'token' => (
      clearer   => 'clear_token',
      is        => 'rw',
      predicate => '_has_token',
      required  => 0,
  );
  
  
  has 'ua' => (
      builder => '_build_ua',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'user' => (
      clearer   => 'clear_user',
      is        => 'rw',
      predicate => 'has_user',
      required  => 0,
  );
  
  
  has 'utf8' => (
      is      => 'ro',
      default => 1,
  );
  
  has '_json' => (
      builder => '_build__json',
      is      => 'ro',
      lazy    => 1,
  );
  
  my @TOKEN_REQUIRED = (
      'DELETE /user/emails',
      'GET /user',
      'GET /user/emails',
      'GET /user/followers',
      'GET /user/following',
      'GET /user/keys',
      'GET /user/repos',
      'PATCH /user',
      'POST /user/emails',
      'POST /user/keys',
      'POST /user/repos',
  );
  
  my @TOKEN_REQUIRED_REGEXP = (
      qr{^DELETE },
      qr{^GET /gists/starred$},
      qr{^GET /gists/[^/]+/star$},
      qr{^GET /issues$},
      qr{^GET /orgs/[^/]+/members/.*$},
      qr{^GET /orgs/[^/]+/teams$},
      qr{^GET /repos/[^/]+/[^/]+/collaborators$},
      qr{^GET /repos/[^/]+/[^/]+/collaborators/.*$},
      qr{^GET /repos/[^/]+/[^/]+/hooks$},
      qr{^GET /repos/[^/]+/[^/]+/hooks/.*$},
      qr{^GET /repos/[^/]+/[^/]+/keys$},
      qr{^GET /repos/[^/]+/[^/]+/keys/.*$},
      qr{^GET /teams/.*$},
      qr{^GET /teams/[^/]+/members$},
      qr{^GET /teams/[^/]+/members/.*$},
      qr{^GET /teams/[^/]+/repos$},
      qr{^GET /teams/[^/]+/repos/.*$},
      qr{^GET /user/following/.*$},
      qr{^GET /user/keys/.*$},
      qr{^GET /user/orgs$},
      qr{^GET /user/starred/[^/]+/.*$},
      qr{^GET /user/watched$},
      qr{^GET /user/watched/[^/]+/.*$},
      qr{^GET /users/[^/]+/events/orgs/.*$},
      qr{^PATCH /gists/.*$},
      qr{^PATCH /gists/[^/]+/comments/.*$},
      qr{^PATCH /orgs/.*$},
      qr{^PATCH /repos/[^/]+/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/comments/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/git/refs/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/hooks/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/issues/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/issues/comments/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/keys/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/labels/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/milestones/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/pulls/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/releases/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/pulls/comments/.*$},
      qr{^PATCH /teams/.*$},
      qr{^PATCH /user/keys/.*$},
      qr{^PATCH /user/repos/.*$},
      qr{^POST /repos/[^/]+/[^/]+/releases/[^/]+/assets.*$},
      qr{^POST /gists/[^/]+/comments$},
      qr{^POST /orgs/[^/]+/repos$},
      qr{^POST /orgs/[^/]+/teams$},
      qr{^POST /repos/[^/]+/[^/]+/commits/[^/]+/comments$},
      qr{^POST /repos/[^/]+/[^/]+/downloads$},
      qr{^POST /repos/[^/]+/[^/]+/forks},
      qr{^POST /repos/[^/]+/[^/]+/git/blobs$},
      qr{^POST /repos/[^/]+/[^/]+/git/commits$},
      qr{^POST /repos/[^/]+/[^/]+/git/refs},
      qr{^POST /repos/[^/]+/[^/]+/git/tags$},
      qr{^POST /repos/[^/]+/[^/]+/git/trees$},
      qr{^POST /repos/[^/]+/[^/]+/hooks$},
      qr{^POST /repos/[^/]+/[^/]+/hooks/[^/]+/test$},
      qr{^POST /repos/[^/]+/[^/]+/issues$},
      qr{^POST /repos/[^/]+/[^/]+/issues/[^/]+/comments},
      qr{^POST /repos/[^/]+/[^/]+/issues/[^/]+/labels$},
      qr{^POST /repos/[^/]+/[^/]+/keys$},
      qr{^POST /repos/[^/]+/[^/]+/labels$},
      qr{^POST /repos/[^/]+/[^/]+/milestones$},
      qr{^POST /repos/[^/]+/[^/]+/pulls$},
      qr{^POST /repos/[^/]+/[^/]+/releases$},
      qr{^POST /repos/[^/]+/[^/]+/pulls/[^/]+/comments$},
      qr{^PUT /gists/[^/]+/star$},
      qr{^PUT /orgs/[^/]+/public_members/.*$},
      qr{^PUT /repos/[^/]+/[^/]+/collaborators/.*$},
      qr{^PUT /repos/[^/]+/[^/]+/issues/[^/]+/labels$},
      qr{^PUT /repos/[^/]+/[^/]+/pulls/[^/]+/merge$},
      qr{^PUT /teams/[^/]+/members/.*$},
      qr{^PUT /teams/[^/]+/memberships/.*$},
      qr{^PUT /teams/[^/]+/repos/.*$},
      qr{^PUT /user/following/.*$},
      qr{^PUT /user/starred/[^/]+/.*$},
      qr{^PUT /user/watched/[^/]+/.*$},
  );
  
  
  sub request {
      my ( $self, %args ) = @_;
  
      my $method  = delete $args{method} || croak 'Missing mandatory key in parameters: method';
      my $path    = delete $args{path}   || croak 'Missing mandatory key in parameters: path';
      my $data    = delete $args{data};
      my $options = delete $args{options};
      my $params  = delete $args{params};
  
      croak "Invalid method: $method" unless grep $_ eq $method, qw(DELETE GET PATCH POST PUT);
  
      my $uri = $self->_uri_for($path);
  
      if (my $host = delete $args{host}) {
          $uri->host($host);
      }
  
      if (my $query = delete $args{query}) {
          $uri->query_form(%$query);
      }
  
      my $request = $self->_request_for( $method, $uri, $data );
  
      if (my $headers = delete $args{headers}) {
          foreach my $header (keys %$headers) {
              $request->header($header, $headers->{$header});
          }
      }
  
      if ( $self->_token_required( $method, $path ) && !$self->has_token($request) ) {
          croak sprintf "Access token required for: %s %s (%s)", $method, $path, $uri;
      }
  
      if ($options) {
          croak 'The key options must be a hashref' unless ref $options eq 'HASH';
          croak 'The key prepare_request in the options hashref must be a coderef' if $options->{prepare_request} && ref $options->{prepare_request} ne 'CODE';
  
          if ( $options->{prepare_request} ) {
              $options->{prepare_request}->($request);
          }
      }
  
      if ($params) {
          croak 'The key params must be a hashref' unless ref $params eq 'HASH';
          my %query = ( $request->uri->query_form, %$params );
          $request->uri->query_form(%query);
      }
  
      my $response = $self->_make_request($request);
  
      return Pithub::Result->new(
          auto_pagination => $self->auto_pagination,
          response        => $response,
          utf8            => $self->utf8,
          _request        => sub { $self->request(@_) },
      );
  }
  
  
  sub _make_request {
      my($self, $request) = @_;
  
      if( my $cached_response = $self->shared_cache->get($request->uri) ) {
          # Add the If-None-Match header from the cache's ETag
          # and make the request
          $request->header( "If-None-Match" => $cached_response->header("ETag") );
          my $response = $self->ua->request($request);
  
          # Got 304 Not Modified, cache is still valid
          return $cached_response if ($response->code || 0) == 304;
  
          # The response changed, cache it and return it.
          $self->shared_cache->set( $request->uri, $response );
          return $response;
      }
      else {
          my $response = $self->ua->request($request);
          $self->shared_cache->set( $request->uri, $response );
          return $response;
      }
  }
  
  
  
  sub has_token {
      my ($self, $request) = @_;
  
      # If we have one specified in the object, return true
      return 1 if $self->_has_token;
      # If no request object here, we don't have a token
      return 0  unless $request;
  
      return 1 if $request->header('Authorization');
      return 0;
  }
  
  
  sub rate_limit {
      return shift->request( method => 'GET', path => '/rate_limit' );
  }
  
  sub _build__json {
      my ($self) = @_;
      return JSON->new->utf8($self->utf8);
  }
  
  sub _build_ua {
      my ($self) = @_;
      return LWP::UserAgent->new;
  }
  
  sub _get_user_repo_args {
      my ( $self, $args ) = @_;
      $args->{user} = $self->user unless defined $args->{user};
      $args->{repo} = $self->repo unless defined $args->{repo};
      return $args;
  }
  
  sub _create_instance {
      my ( $self, $class, @args ) = @_;
  
      my %args = (
          api_uri         => $self->api_uri,
          auto_pagination => $self->auto_pagination,
          ua              => $self->ua,
          utf8            => $self->utf8,
          @args
      );
  
      for my $attr (qw(repo token user per_page jsonp_callback prepare_request)) {
          # Allow overrides to set attributes to undef
          next if exists $args{$attr};
  
          my $has_attr = "has_$attr";
          $args{$attr} = $self->$attr if $self->$has_attr;
      }
  
      return $class->new(%args);
  }
  
  sub _request_for {
      my ( $self, $method, $uri, $data ) = @_;
  
      my $headers = HTTP::Headers->new;
  
      if ( $self->has_token ) {
          $headers->header( 'Authorization' => sprintf( 'token %s', $self->token ) );
      }
  
      my $request = HTTP::Request->new( $method, $uri, $headers );
  
      if ($data) {
          $data = $self->_json->encode($data) if ref $data;
          $request->content($data);
      }
  
      $request->header( 'Content-Length' => length $request->content );
  
      if ( $self->has_prepare_request ) {
          $self->prepare_request->($request);
      }
  
      return $request;
  }
  
  my %TOKEN_REQUIRED = map { ($_ => 1) } @TOKEN_REQUIRED;
  sub _token_required {
      my ( $self, $method, $path ) = @_;
  
      my $key = "${method} ${path}";
  
      return 1 if $TOKEN_REQUIRED{$key};
  
      foreach my $regexp (@TOKEN_REQUIRED_REGEXP) {
          return 1 if $key =~ /$regexp/;
      }
  
      return 0;
  }
  
  sub _uri_for {
      my ( $self, $path ) = @_;
  
      my $uri = $self->api_uri->clone;
      my $base_path = $uri->path;
      $path =~ s/^$base_path//;
      my @parts;
      push @parts, split qr{/+}, $uri->path;
      push @parts, split qr{/+}, $path;
      $uri->path( join '/',  grep { $_ } @parts );
  
      if ( $self->has_per_page ) {
          my %query = ( $uri->query_form, per_page => $self->per_page );
          $uri->query_form(%query);
      }
  
      if ( $self->has_jsonp_callback ) {
          my %query = ( $uri->query_form, callback => $self->jsonp_callback );
          $uri->query_form(%query);
      }
  
      return $uri;
  }
  
  sub _validate_user_repo_args {
      my ( $self, $args ) = @_;
      $args = $self->_get_user_repo_args($args);
      croak 'Missing key in parameters: user' unless $args->{user};
      croak 'Missing key in parameters: repo' unless $args->{repo};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Base - Github v3 base class for all Pithub modules
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 DESCRIPTION
  
  All L<Pithub> L<modules|Pithub/MODULES> inherit from
  L<Pithub::Base>, even L<Pithub> itself. So all
  L<attributes|/ATTRIBUTES> listed here can either be set in the
  constructor or via the setter on the objects.
  
  If any attribute is set on a L<Pithub> object it gets
  automatically set on objects that get created by a method call on
  the L<Pithub> object. This is very convenient for attributes like
  the L</token> or the L</user> and L</repo> attributes.
  
  The L</user> and L</repo> attributes are special: They get even
  set on method calls that require B<both> of them. This is to reduce
  verbosity, especially if you want to do a lot of things on the
  same repo. This also works for other objects: If you create an
  object of L<Pithub::Repos> where you set the L</user> and L</repo>
  attribute in the constructor, this will also be set once you
  get to the L<Pithub::Repos::Keys> object via the C<< keys >> method.
  
  Attributes passed along from the parent can be changed in the method
  call.
  
      my $p = Pithub->new( per_page => 50 );
      my $r1 = $p->repos;                         # $r->per_page == 50
      my $r2 = $p->repos( per_page => 100 );      # $r->per_page == 100
  
  Examples:
  
      # just to demonstrate the "magic"
      print Pithub->new( user => 'plu' )->repos->user;          # plu
      print Pithub::Repos->new( user => 'plu' )->keys->user;    # plu
  
      # and now some real use cases
      my $p = Pithub->new( user => 'plu', repo => 'Pithub' );
      my $r = $p->repos;
  
      print $r->user;    # plu
      print $r->repo;    # pithub
  
      # usually you would do
      print $r->get( user => 'plu', repo => 'Pithub' )->content->{html_url};
  
      # but since user + repo has been set already
      print $r->get->content->{html_url};
  
      # of course parameters to the method take precedence
      print $r->get( user => 'miyagawa', repo => 'Plack' )->content->{html_url};
  
      # it even works on other objects
      my $repo = Pithub::Repos->new( user => 'plu', repo => 'Pithub' );
      print $repo->watching->list->first->{login};
  
  =head1 ATTRIBUTES
  
  =head2 auto_pagination
  
  Off by default.
  
  See also: L<Pithub::Result/auto_pagination>.
  
  =head2 api_uri
  
  Defaults to L<https://api.github.com>.  For GitHub Enterprise, you'll likely
  need an URL like L<https://github.yourdomain.com/api/v3/>.
  
  Examples:
  
      my $users = Pithub::Users->new( api_uri => 'https://api-foo.github.com' );
  
      # ... is the same as ...
  
      my $users = Pithub::Users->new;
      $users->api_uri('https://api-foo.github.com');
  
  =head2 jsonp_callback
  
  If you want to use the response directly in JavaScript for example,
  Github supports setting a JSONP callback parameter.
  
  See also: L<http://developer.github.com/v3/#json-p-callbacks>.
  
  Examples:
  
      my $p = Pithub->new( jsonp_callback => 'loadGithubData' );
      my $result = $p->users->get( user => 'plu' );
      print $result->raw_content;
  
  The result will look like this:
  
      loadGithubData({
          "meta": {
              "status": 200,
              "X-RateLimit-Limit": "5000",
              "X-RateLimit-Remaining": "4661"
          },
          "data": {
              "type": "User",
              "location": "Dubai",
              "url": "https://api.github.com/users/plu",
              "login": "plu",
              "name": "Johannes Plunien",
              ...
          }
      })
  
  B<Be careful:> The L<content|Pithub::Result/content> method will
  try to decode the JSON into a Perl data structure. This is not
  possible if the C<< jsonp_callback >> is set:
  
      # calling this ...
      print $result->content;
  
      # ... will throw an exception like this ...
      Runtime error: malformed JSON string, neither array, object, number, string or atom,
      at character offset 0 (before "loadGithubData( ...
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_jsonp_callback>: reset the jsonp_callback attribute
  
  =item *
  
  =head2 per_page
  
  Controls how many items are fetched per API call, aka "page".  See
  also: L<http://developer.github.com/v3/#pagination> and
  L</auto_pagination>.
  
  To minimize the number of API calls to get a complete listing, this
  defaults to the maximum allowed by Github, which is currently 100.
  This may change in the future if Github changes their maximum.
  
  Examples:
  
      my $users = Pithub::Users->new( per_page => 30 );
  
      # ... is the same as ...
  
      my $users = Pithub::Users->new;
      $users->per_page(30);
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_per_page>: reset the per_page attribute
  
  =item *
  
  =head2 prepare_request
  
  This is a CodeRef and can be used to modify the L<HTTP::Request>
  object on a global basis, before it's being sent to the Github
  API. It's useful for setting MIME types for example. See also:
  L<http://developer.github.com/v3/mimes/>. This is the right way
  to go if you want to modify the HTTP request of B<all> API
  calls. If you just want to change a few, consider sending the
  C<< prepare_request >> parameter on any method call.
  
  Let's use this example from the Github docs:
  
  B<Html>
  
  C<< application/vnd.github-issue.html+json >>
  
  Return html rendered from the body's markdown. Response will
  include body_html.
  
  Examples:
  
      my $p = Pithub::Issues->new(
          prepare_request => sub {
              my ($request) = @_;
              $request->header( Accept => 'application/vnd.github-issue.html+json' );
          }
      );
  
      my $result = $p->get(
          user     => 'miyagawa',
          repo     => 'Plack',
          issue_id => 209,
      );
  
      print $result->content->{body_html};
  
  Please compare to the solution where you set the custom HTTP header
  on the method call, instead globally on the object:
  
      my $p = Pithub::Issues->new;
  
      my $result = $p->get(
          user     => 'miyagawa',
          repo     => 'Plack',
          issue_id => 209,
          options  => {
              prepare_request => sub {
                  my ($request) = @_;
                  $request->header( Accept => 'application/vnd.github-issue.html+json' );
              },
          }
      );
  
      print $result->content->{body_html};
  
  =head2 repo
  
  This can be set as a default repo to use for API calls that require
  the repo parameter to be set. There are many of them and it can get
  kind of verbose to include the repo and the user for all of the
  calls, especially if you want to do many operations on the same
  user/repo.
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new( repo => 'Pithub' );
      my $result = $c->list( user => 'plu' );
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_repo>: reset the repo attribute
  
  =item *
  
  =head2 token
  
  If the OAuth token is set, L<Pithub> will sent it via an HTTP header
  on each API request. Currently the basic authentication method is
  not supported.
  
  See also: L<http://developer.github.com/v3/oauth/>
  
  =head2 ua
  
  By default a L<LWP::UserAgent> object, but it can be anything that
  implements the same interface.
  
  =head2 user
  
  This can be set as a default user to use for API calls that require
  the user parameter to be set.
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new( user => 'plu' );
      my $result = $c->list( repo => 'Pithub' );
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_user>: reset the user attribute
  
  =item *
  
  =head2 utf8
  
  This can set utf8 flag.
  
  Examples:
  
      my $p = Pithub->new(utf8 => 0); # disable utf8 en/decoding
      my $p = Pithub->new(utf8 => 1); # enable utf8 en/decoding (default)
  
  =head1 METHODS
  
  =head2 request
  
  This method is the central point: All L<Pithub> are using this method
  for making requests to the Github. If Github adds a new API call that
  is not yet supported, this method can be used directly. It accepts
  an hash with following keys:
  
  =over
  
  =item *
  
  B<method>: mandatory string, one of the following:
  
  =over
  
  =item *
  
  DELETE
  
  =item *
  
  GET
  
  =item *
  
  PATCH
  
  =item *
  
  POST
  
  =item *
  
  PUT
  
  =back
  
  =item *
  
  B<path>: mandatory string of the relative path used for making the
  API call.
  
  =item *
  
  B<data>: optional data reference, usually a reference to an array
  or hash. It must be possible to serialize this using L<JSON>.
  This will be the HTTP request body.
  
  =item *
  
  B<options>: optional hash reference to set additional options on
  the request. So far C<< prepare_request >> is supported. See
  more about that in the examples below. So this can be used on
  B<every> method which maps directly to an API call.
  
  =item *
  
  B<params>: optional hash reference to set additional C<< GET >>
  parameters. This could be achieved using the C<< prepare_request >>
  in the C<< options >> hashref as well, but this is shorter. It's
  being used in L<list method of Pithub::Issues|Pithub::Issues/list>
  for example.
  
  =back
  
  Usually you should not end up using this method at all. It's only
  available if L<Pithub> is missing anything from the Github v3 API.
  Though here are some examples how to use it:
  
  =over
  
  =item *
  
  Same as L<Pithub::Issues/list>:
  
      my $p      = Pithub->new;
      my $result = $p->request(
          method => 'GET',
          path   => '/repos/plu/Pithub/issues',
          params => {
              state     => 'closed',
              direction => 'asc',
          }
      );
  
  =item *
  
  Same as L<Pithub::Users/get>:
  
      my $p = Pithub->new;
      my $result = $p->request(
          method => 'GET',
          path   => '/users/plu',
      );
  
  =item *
  
  Same as L<Pithub::Gists/create>:
  
      my $p      = Pithub->new;
      my $method = 'POST';
      my $path   = '/gists';
      my $data   = {
          description => 'the description for this gist',
          public      => 1,
          files       => { 'file1.txt' => { content => 'String file content' } }
      };
      my $result = $p->request(
          method => $method,
          path   => $path,
          data   => $data,
      );
  
  =item *
  
  Same as L<Pithub::GitData::Trees/get>:
  
      my $p       = Pithub->new;
      my $method  = 'GET';
      my $path    = '/repos/miyagawa/Plack/issues/209';
      my $data    = undef;
      my $options = {
          prepare_request => sub {
              my ($request) = @_;
              $request->header( Accept => 'application/vnd.github-issue.html+json' );
          },
      };
      my $result = $p->request(
          method  => $method,
          path    => $path,
          data    => $data,
          options => $options,
      );
  
  =back
  
  This method always returns a L<Pithub::Result> object.
  
  =head2 has_token (?$request)
  
  This method checks if a token has been specified, or if not, and a request
  object is passed, then it looks for an Authorization header in the request.
  
  =head2 rate_limit
  
  Query the rate limit for the current object and authentication method.
  
  =for Pod::Coverage has_jsonp_callback
  
  B<has_jsonp_callback>: check if the jsonp_callback attribute is set
  
  =back
  
  =for Pod::Coverage has_per_page
  
  B<has_per_page>: check if the per_page attribute is set
  
  =back
  
  =for Pod::Coverage has_prepare_request
  
  =for Pod::Coverage has_repo
  
  B<has_repo>: check if the repo attribute is set
  
  =back
  
  =for Pod::Coverage has_user
  
  B<has_user>: check if the user attribute is set
  
  =back
  
  It might make sense to use this together with the repo attribute:
  
      my $c = Pithub::Repos::Commits->new( user => 'plu', repo => 'Pithub' );
      my $result = $c->list;
      my $result = $c->list_comments;
      my $result = $c->get('6b6127383666e8ecb41ec20a669e4f0552772363');
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_BASE

$fatpacked{"Pithub/Events.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_EVENTS';
  package Pithub::Events;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Events API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub issue {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub network {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/networks/%s/%s/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub org {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/events', delete $args{org} ),
          %args,
      );
  }
  
  
  sub org_for_user {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/users/%s/events/orgs/%s', delete $args{user}, delete $args{org} ),
          %args,
      );
  }
  
  
  sub public {
      my ( $self, %args ) = @_;
      return $self->request(
          method => 'GET',
          path   => '/events',
          %args,
      );
  }
  
  
  sub repos {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub user_performed {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      my $path = sprintf( '/users/%s/events', delete $args{user} );
      if ( $args{public} ) {
          $path .= '/public';
      }
      return $self->request(
          method => 'GET',
          path   => $path,
          %args,
      );
  }
  
  
  sub user_received {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      my $path = sprintf( '/users/%s/received_events', delete $args{user} );
      if ( $args{public} ) {
          $path .= '/public';
      }
      return $self->request(
          method => 'GET',
          path   => $path,
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Events - Github v3 Events API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 issue
  
  =over
  
  =item *
  
  List issue events for a repository
  
      GET /repos/:user/:repo/issues/events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->issue(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 network
  
  =over
  
  =item *
  
  List public events for a network of repositories
  
      GET /networks/:user/:repo/events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->network(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 org
  
  =over
  
  =item *
  
  List public events for an organization
  
      GET /orgs/:org/events
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->org( org => 'CPAN-API' );
  
  =back
  
  =head2 org_for_user
  
  =over
  
  =item *
  
  List events for an organization
  
      GET /users/:user/events/orgs/:org
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->org(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 public
  
  =over
  
  =item *
  
  List public events
  
      GET /events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->public;
  
  =back
  
  =head2 repos
  
  =over
  
  =item *
  
  List repository events
  
      GET /repos/:user/:repo/events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->repos(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 user_performed
  
  =over
  
  =item *
  
  List events performed by a user
  
      GET /users/:user/events
  
  If you are authenticated as the given user, you will see your
  private events. Otherwise, you'll only see public events.
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->user_performed( user => 'plu' );
  
      # List public events performed by a user
      my $e      = Pithub::Events->new;
      my $result = $e->user_performed(
          user   => 'plu',
          public => 1,
      );
  
  =back
  
  =head2 user_received
  
  =over
  
  =item *
  
  List events that a user has received
  
      GET /users/:user/received_events
  
  These are events that you've received by watching repos and
  following users. If you are authenticated as the given user,
  you will see private events. Otherwise, you'll only see
  public events.
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->user_received( user => 'plu' );
  
      # List public events that a user has received
      my $e      = Pithub::Events->new;
      my $result = $e->user_received(
          user   => 'plu',
          public => 1,
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_EVENTS

$fatpacked{"Pithub/Gists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GISTS';
  package Pithub::Gists;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Gists API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Gists::Comments
  extends 'Pithub::Base';
  
  
  sub comments {
      return shift->_create_instance('Pithub::Gists::Comments', @_);
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => '/gists',
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/gists/%s', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub fork {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'POST',
          path   => sprintf( '/gists/%s/forks', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub is_starred {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s/star', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/gists', $user ),
              %args,
          );
      }
      elsif ( delete $args{starred} ) {
          return $self->request(
              method => 'GET',
              path   => '/gists/starred',
              %args,
          );
      }
      elsif ( delete $args{public} ) {
          return $self->request(
              method => 'GET',
              path   => '/gists/public',
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/gists',
          %args,
      );
  }
  
  
  sub star {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/gists/%s/star', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub unstar {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/gists/%s/star', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/gists/%s', delete $args{gist_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Gists - Github v3 Gists API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 comments
  
  Provides access to L<Pithub::Gists::Comments>.
  
  =head2 create
  
  =over
  
  =item *
  
  Create a gist
  
      POST /gists
  
  Parameters:
  
  =over
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<description>: optional string
  
  =item *
  
  B<public>: mandatory boolean
  
  =item *
  
  B<files>: mandatory hashref, please see examples section below
  
  =back
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->create(
          data => {
              description => 'the description for this gist',
              public      => 1,
              files       => { 'file1.txt' => { content => 'String file content' } }
          }
      );
      if ( $result->success ) {
          printf "The new gist is available at %s\n", $result->content->{html_url};
      }
  
  Response: B<Status: 201 Created>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z",
          "forks": [
          {
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "url": "https://api.github.com/gists/5",
              "created_at": "2011-04-14T16:00:49Z"
          }
          ],
          "history": [
          {
              "url": "https://api.github.com/gists/1/57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "version": "57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "change_status": {
                  "deletions": 0,
                  "additions": 180,
                  "total": 180
              },
              "committed_at": "2010-04-14T02:15:15Z"
          }
          ]
      }
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a gist
  
      DELETE /gists/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->delete( gist_id => 784612 );
      if ( $result->success ) {
          print "The gist 784612 has been deleted\n";
      }
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 fork
  
  =over
  
  =item *
  
  Fork a gist
  
      POST /gists/:id/forks
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->fork( gist_id => 784612 );
      if ( $result->success ) {
          printf "The gist 784612 has been forked: %s\n", $result->content->{html_url};
      }
  
  Response: B<Status: 201 Created>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z"
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single gist
  
      GET /gists/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->get( gist_id => 784612 );
      if ( $result->success ) {
          print $result->content->{html_url};
      }
  
  Response: B<Status: 200 OK>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z",
          "forks": [
          {
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "url": "https://api.github.com/gists/5",
              "created_at": "2011-04-14T16:00:49Z"
          }
          ],
          "history": [
          {
              "url": "https://api.github.com/gists/1/57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "version": "57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "change_status": {
                  "deletions": 0,
                  "additions": 180,
                  "total": 180
              },
              "committed_at": "2010-04-14T02:15:15Z"
          }
          ]
      }
  
  =back
  
  =head2 is_starred
  
  =over
  
  =item *
  
  Check if a gist is starred
  
      GET /gists/:id/star
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->is_starred( gist_id => 784612 );
  
  Response: B<Status: 204 No Content> / C<< Status: 404 Not Found >>
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List a user's gists:
  
      GET /users/:user/gists
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: string
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list( user => 'miyagawa' );
      if ( $result->success ) {
          while ( my $row = $result->next ) {
              printf "%s => %s\n", $row->{html_url}, $row->{description} || 'no description';
          }
      }
  
  =item *
  
  List the authenticated user's gists or if called anonymously,
  this will returns all public gists:
  
      GET /gists
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list;
  
  =item *
  
  List all public gists:
  
      GET /gists/public
  
  Parameters:
  
  =over
  
  =item *
  
  B<public>: boolean
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list( public => 1 );
  
  =item *
  
  List the authenticated user's starred gists:
  
      GET /gists/starred
  
  Parameters:
  
  =over
  
  =item *
  
  B<starred>: boolean
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list( starred => 1 );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "url": "https://api.github.com/gists/1",
              "id": "1",
              "description": "description of gist",
              "public": true,
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "files": {
                  "ring.erl": {
                      "size": 932,
                      "filename": "ring.erl",
                      "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                      "content": "contents of gist"
                  }
              },
              "comments": 0,
              "git_pull_url": "git://gist.github.com/1.git",
              "git_push_url": "git@gist.github.com:1.git",
              "created_at": "2010-04-14T02:15:15Z"
          }
      ]
  
  =back
  
  =head2 star
  
  =over
  
  =item *
  
  Star a gist
  
      PUT /gists/:id/star
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->star( gist_id => 784612 );
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 unstar
  
  =over
  
  =item *
  
  Unstar a gist
  
      DELETE /gists/:id/star
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->unstar( gist_id => 784612 );
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a gist
  
      PATCH /gists/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<description>: optional string
  
  =item *
  
  B<public>: mandatory boolean
  
  =item *
  
  B<files>: mandatory hashref, please see examples section below
  
  NOTE: All files from the previous version of the gist are carried
  over by default if not included in the hash. Deletes can be
  performed by including the filename with a null hash.
  
  =back
  
  =back
  
  Examples:
  
      my $g      = Pithub::Gists->new;
      my $result = $g->update(
          gist_id => 784612,
          data    => {
              description => 'the description for this gist',
              files       => {
                  'file1.txt'    => { content => 'updated file contents' },
                  'old_name.txt' => {
                      filename => 'new_name.txt',
                      content  => 'modified contents'
                  },
                  'new_file.txt'         => { content => 'a new file' },
                  'delete_this_file.txt' => undef
              }
          }
      );
  
  Response: B<Status: 200 OK>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z",
          "forks": [
          {
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "url": "https://api.github.com/gists/5",
              "created_at": "2011-04-14T16:00:49Z"
          }
          ],
          "history": [
          {
              "url": "https://api.github.com/gists/1/57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "version": "57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "change_status": {
                  "deletions": 0,
                  "additions": 180,
                  "total": 180
              },
              "committed_at": "2010-04-14T02:15:15Z"
          }
          ]
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GISTS

$fatpacked{"Pithub/Gists/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GISTS_COMMENTS';
  package Pithub::Gists::Comments;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Gist Comments API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => sprintf( '/gists/%s/comments', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/gists/%s/comments/%s', delete $args{gist_id}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s/comments/%s', delete $args{gist_id}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s/comments', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/gists/%s/comments/%s', delete $args{gist_id}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Gists::Comments - Github v3 Gist Comments API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a comment
  
      POST /gists/:gist_id/comments
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<body>: mandatory string
  
  =back
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->create(
          gist_id => 'c0ff33',
          data    => { body => 'Just commenting for the sake of commenting' },
      );
  
  Response: B<Status: 201 Created>
  
      {
          "id": 1,
          "url": "https://api.github.com/gists/c0ff33/comments/1",
          "body": "Just commenting for the sake of commenting",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "created_at": "2011-04-18T23:23:56Z"
      }
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a comment
  
      DELETE /gists/:gist_id/comments/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<comment_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->delete(
          gist_id    => 'c0ff33',
          comment_id => 1
      );
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single comment
  
      GET /gists/:gist_id/comments/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<comment_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->get(
          gist_id    => 'c0ff33',
          comment_id => 1
      );
  
  Response: B<Status: 200 OK>
  
      {
          "id": 1,
          "url": "https://api.github.com/gists/c0ff33/comments/1",
          "body": "Just commenting for the sake of commenting",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "created_at": "2011-04-18T23:23:56Z"
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List comments on a gist
  
      GET /gists/:gist_id/comments
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->list( gist_id => 1 );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "id": 1,
              "url": "https://api.github.com/gists/c0ff33/comments/1",
              "body": "Just commenting for the sake of commenting",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "created_at": "2011-04-18T23:23:56Z"
          }
      ]
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a comment
  
      PATCH /gists/:gist_id/comments/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<comment_id>: mandatory integer
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<body>: mandatory string
  
  =back
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->update(
          gist_id    => 'c0ff33',
          comment_id => 1,
          data       => { body => 'some comment' }
      );
  
  Response: B<Status: 200 OK>
  
      {
          "id": 1,
          "url": "https://api.github.com/gists/c0ff33/comments/1",
          "body": "Just commenting for the sake of commenting",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "created_at": "2011-04-18T23:23:56Z"
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GISTS_COMMENTS

$fatpacked{"Pithub/GitData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA';
  package Pithub::GitData;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Git Data API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::GitData::Blobs;
  use Pithub::GitData::Commits;
  use Pithub::GitData::References;
  use Pithub::GitData::Tags;
  use Pithub::GitData::Trees;
  extends 'Pithub::Base';
  
  
  sub blobs {
      return shift->_create_instance('Pithub::GitData::Blobs', @_);
  }
  
  
  sub commits {
      return shift->_create_instance('Pithub::GitData::Commits', @_);
  }
  
  
  sub references {
      return shift->_create_instance('Pithub::GitData::References', @_);
  }
  
  
  sub tags {
      return shift->_create_instance('Pithub::GitData::Tags', @_);
  }
  
  
  sub trees {
      return shift->_create_instance('Pithub::GitData::Trees', @_);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData - Github v3 Git Data API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 blobs
  
  Provides access to L<Pithub::GitData::Blobs>.
  
  =head2 commits
  
  Provides access to L<Pithub::GitData::Commits>.
  
  =head2 references
  
  Provides access to L<Pithub::GitData::References>.
  
  =head2 tags
  
  Provides access to L<Pithub::GitData::Tags>.
  
  =head2 trees
  
  Provides access to L<Pithub::GitData::Trees>.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA

$fatpacked{"Pithub/GitData/Blobs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_BLOBS';
  package Pithub::GitData::Blobs;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Git Data Blobs API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/blobs', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/blobs/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Blobs - Github v3 Git Data Blobs API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 DESCRIPTION
  
  Since blobs can be any arbitrary binary data, the input and responses
  for the blob api takes an encoding parameter that can be either
  C<< utf-8 >> or C<< base64 >>. If your data cannot be losslessly sent
  as a UTF-8 string, you can base64 encode it.
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Blob
  
      POST /repos/:user/:repo/git/blobs
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<content>: mandatory string
  
  =item *
  
  B<encoding>: mandatory string, C<< utf-8 >> or C<< base64 >>
  
  =back
  
  =back
  
  Examples:
  
      my $b = Pithub::GitData::Blobs->new;
      my $result = $b->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              content  => 'Content of the blob',
              encoding => 'utf-8',
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "sha": "3a0f86fb8db8eea7ccbb9a95f325ddbedfb25e15"
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Blob
  
      GET /repos/:user/:repo/git/blobs/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =back
  
  Examples:
  
      my $b = Pithub::GitData::Blobs->new;
      my $result = $b->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'b7cdea6830e128bc16c2b75efd99842d971666e2',
      );
  
  Response: B<Status: 200 OK>
  
      {
          "content": "Content of the blob",
          "encoding": "utf-8"
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_BLOBS

$fatpacked{"Pithub/GitData/Commits.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_COMMITS';
  package Pithub::GitData::Commits;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Git Data Commits API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/commits', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/commits/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Commits - Github v3 Git Data Commits API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Commit
  
      POST /repos/:user/:repo/git/commits
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<message>: mandatory string, the commit message
  
  =item *
  
  B<tree>: mandatory string, the SHA of the tree object this commit
  points to
  
  =item *
  
  B<parents>: mandatory arrayref of the SHAs of the commits that were
  the parents of this commit. If omitted or empty, the commit will be
  written as a root commit. For a single parent, an array of one SHA
  should be provided, for a merge commit, an array of more than one
  should be provided points to.
  
  =back
  
  Optional Parameters in the C<< data >> hashref:
  
  The committer section is optional and will be filled with the author
  data if omitted. If the author section is omitted, it will be filled
  in with the authenticated users information and the current date.
  
  =over
  
  =item *
  
  B<author>: hashref, having following keys:
  
  =over
  
  =item *
  
  B<name>: string of the name of the author of the commit
  
  =item *
  
  B<email>: string of the email of the author of the commit
  
  =item *
  
  B<date>: timestamp of when this commit was authored
  
  =back
  
  =item *
  
  B<committer>: hashref, having following keys:
  
  =over
  
  =item *
  
  B<name>: string of the name of the committer of the commit
  
  =item *
  
  B<email>: string of the email of the committer of the commit
  
  =item *
  
  B<date>: timestamp of when this commit was committed
  
  =back
  
  =back
  
  =back
  
  Examples:
  
      my $c = Pithub::GitData::Commits->new;
      my $result = $c->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              author => {
                  date  => '2008-07-09T16:13:30+12:00',
                  email => 'schacon@gmail.com',
                  name  => 'Scott Chacon',
              },
              message => 'my commit message',
              parents => ['7d1b31e74ee336d15cbd21741bc88a537ed063a0'],
              tree    => '827efc6d56897b048c772eb4087f854f46256132',
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "sha": "7638417db6d59f3c431d3e1f261cc637155684cd",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd",
          "author": {
              "date": "2008-07-09T16:13:30+12:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "committer": {
              "date": "2008-07-09T16:13:30+12:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "message": "my commit message",
          "tree": {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/trees/827efc6d56897b048c772eb4087f854f46256132",
              "sha": "827efc6d56897b048c772eb4087f854f46256132"
          },
          "parents": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/7d1b31e74ee336d15cbd21741bc88a537ed063a0",
              "sha": "7d1b31e74ee336d15cbd21741bc88a537ed063a0"
          }
          ]
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Commit
  
      GET /repos/:user/:repo/git/commits/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =back
  
  Examples:
  
      my $c = Pithub::GitData::Commits->new;
      my $result = $c->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'b7cdea6830e128bc16c2b75efd99842d971666e2',
      );
  
  Response: B<Status: 200 OK>
  
      {
          "sha": "7638417db6d59f3c431d3e1f261cc637155684cd",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd",
          "author": {
              "date": "2010-04-10T14:10:01-07:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "committer": {
              "date": "2010-04-10T14:10:01-07:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "message": "added readme, because im a good github citizen\n",
          "tree": {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/trees/691272480426f78a0138979dd3ce63b77f706feb",
              "sha": "691272480426f78a0138979dd3ce63b77f706feb"
          },
          "parents": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/1acc419d4d6a9ce985db7be48c6349a0475975b5",
              "sha": "1acc419d4d6a9ce985db7be48c6349a0475975b5"
          }
          ]
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_COMMITS

$fatpacked{"Pithub/GitData/References.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_REFERENCES';
  package Pithub::GitData::References;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Git Data References API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/refs', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: ref' unless $args{ref};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/refs/%s', delete $args{user}, delete $args{repo}, delete $args{ref} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $ref = $args{ref} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/git/refs/%s', delete $args{user}, delete $args{repo}, delete $args{ref} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/refs', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: ref' unless $args{ref};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/git/refs/%s', delete $args{user}, delete $args{repo}, delete $args{ref} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::References - Github v3 Git Data References API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Reference
  
      POST /repos/:user/:repo/git/refs
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<ref>: mandatory string of the name of the fully qualified
  reference (ie: refs/heads/master). If it doesn't start with
  'refs' and have at least two slashes, it will be rejected.
  
  =item *
  
  B<sha>: mandatory string of the SHA1 value to set this
  reference to.
  
  =back
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              ref => 'refs/heads/master',
              sha => '827efc6d56897b048c772eb4087f854f46256132' .
          }
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Reference
  
      GET /repos/:user/:repo/git/refs/:ref
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<ref>: mandatory string
  
  The key B<ref> must be formatted as C<< heads/branch >>, not just
  C<< branch >>. For example, the call to get the data for a branch
  named C<< sc/featureA >> would be: C<< heads/sc/featureA >>
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->get(
          user => 'plu',
          repo => 'Pithub',
          ref  => 'heads/master'
      );
  
  Response: B<Status: 200 OK>
  
      {
          "ref": "refs/heads/sc/featureA",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/refs/heads/sc/featureA",
          "object": {
              "type": "commit",
              "sha": "aa218f56b14c9653891f9e74264a383fa43fefbd",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/aa218f56b14c9653891f9e74264a383fa43fefbd"
          }
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  Get all References
  
      GET /repos/:user/:repo/git/refs
  
  This will return an array of all the references on the system,
  including things like notes and stashes if they exist on the server.
  Anything in the namespace, not just heads and tags, though that
  would be the most common.
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =item *
  
  You can also request a sub-namespace. For example, to get all the
  tag references, you can call:
  
      GET /repos/:user/:repo/git/refs/tags
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<ref>: mandatory string
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->list(
          user => 'plu',
          repo => 'Pithub',
          ref  => 'tags',
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "object": {
                  "type": "commit",
                  "sha": "1c5230f42d6d3e376162591f223fc4130d671937",
                  "url": "https://api.github.com/repos/plu/Pithub/git/commits/1c5230f42d6d3e376162591f223fc4130d671937"
              },
              "ref": "refs/tags/v0.01000",
              "url": "https://api.github.com/repos/plu/Pithub/git/refs/tags/v0.01000"
          },
          {
              "object": {
                  "type": "tag",
                  "sha": "ef328a0679a992bd2c0ac537cf19d379f1c8d177",
                  "url": "https://api.github.com/repos/plu/Pithub/git/tags/ef328a0679a992bd2c0ac537cf19d379f1c8d177"
              },
              "ref": "refs/tags/v0.01001",
              "url": "https://api.github.com/repos/plu/Pithub/git/refs/tags/v0.01001"
          }
      ]
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a Reference
  
      PATCH /repos/:user/:repo/git/refs/:ref
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<ref>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<sha>: mandatory string of the SHA1 value to set this
  reference to.
  
  =item *
  
  B<force>: optional boolean indicating whether to force the update or
  to make sure the update is a fast-forward update. The default is
  C<< false >> so leaving this out or setting it to C<< false >> will
  make sure you're not overwriting work.
  
  =back
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->update(
          user => 'plu',
          repo => 'Pithub',
          ref  => 'tags/v1.0',
          data => {
              force => 1,
              sha   => 'aa218f56b14c9653891f9e74264a383fa43fefbd',
          }
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "ref": "refs/heads/sc/featureA",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/refs/heads/sc/featureA",
              "object": {
                  "type": "commit",
                  "sha": "aa218f56b14c9653891f9e74264a383fa43fefbd",
                  "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/aa218f56b14c9653891f9e74264a383fa43fefbd"
              }
          }
      ]
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_REFERENCES

$fatpacked{"Pithub/GitData/Tags.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_TAGS';
  package Pithub::GitData::Tags;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Git Data Tags API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/tags', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/tags/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Tags - Github v3 Git Data Tags API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 DESCRIPTION
  
  This tags api only deals with tag objects - so only annotated tags,
  not lightweight tags.
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Tag
  
  Note that creating a tag object does not create the reference that
  makes a tag in Git. If you want to create an annotated tag in Git,
  you have to do this call to create the tag object, and then create
  the C<< refs/tags/[tag] >> reference. If you want to create a
  lightweight tag, you simply have to create the reference - this
  call would be unnecessary.
  
      POST /repos/:user/:repo/git/tags
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<tag>: mandatory string of the tag
  
  =item *
  
  B<message>: mandatory string of the tag message
  
  =item *
  
  B<object>: mandatory stringof the SHA of the git object this is tagging
  
  =item *
  
  B<type>: mandatory string of the type of the object we're tagging.
  Normally this is a C<< commit >> but it can also be a C<< tree >>
  or a C<< blob >>.
  
  =item *
  
  B<tagger>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<name>: string of the name of the author of the tag
  
  =item *
  
  B<email>: string of the email of the author of the tag
  
  =item *
  
  B<date>: timestamp of when this commit was tagged
  
  =back
  
  =back
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Tags->new;
      my $result = $t->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              tagger => {
                  date  => '2011-06-17T14:53:35-07:00',
                  email => 'schacon@gmail.com',
                  name  => 'Scott Chacon',
              },
              message => 'initial version',
              object  => 'c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c',
              tag     => 'v0.0.1',
              type    => 'commit',
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "tag": "v0.0.1",
          "sha": "940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "message": "initial version\n",
          "tagger": {
              "name": "Scott Chacon",
              "email": "schacon@gmail.com",
              "date": "2011-06-17T14:53:35-07:00"
          },
          "object": {
              "type": "commit",
              "sha": "c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c"
          }
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Tag
  
      GET /repos/:user/:repo/git/tags/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Tags->new;
      my $result = $t->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
      );
  
  Response: B<Status: 200 OK>
  
      {
          "tag": "v0.0.1",
          "sha": "940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "message": "initial version\n",
          "tagger": {
              "name": "Scott Chacon",
              "email": "schacon@gmail.com",
              "date": "2011-06-17T14:53:35-07:00"
          },
          "object": {
              "type": "commit",
              "sha": "c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c"
          }
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_TAGS

$fatpacked{"Pithub/GitData/Trees.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_TREES';
  package Pithub::GitData::Trees;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Git Data Trees API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/trees', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      my $path = sprintf( '/repos/%s/%s/git/trees/%s', $args{user}, $args{repo}, $args{sha} );
      my %params = ();
      if ( $args{recursive} ) {
          $params{recursive} = 1;
      }
      return $self->request(
          method => 'GET',
          path   => $path,
          params => \%params,
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Trees - Github v3 Git Data Trees API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  The tree creation API will take nested entries as well. If both a
  tree and a nested path modifying that tree are specified, it will
  overwrite the contents of that tree with the new path contents and
  write a new tree out.
  
  =over
  
  =item *
  
  Create a Tree
  
      POST /repos/:user/:repo/git/trees
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<base_tree>: optional String of the SHA1 of the tree you want to
  update with new data.
  
  =item *
  
  B<tree>: mandatory arrayref of hashrefs, having following keys:
  
  =over
  
  =item *
  
  B<path>: mandatory string of the file referenced in the tree.
  
  =item *
  
  B<mode>: mandatory string of the file mode - one of C<< 100644 >>
  for file (blob), C<< 100755 >> for executable (blob), C<< 040000 >>
  for subdirectory (tree), C<< 160000 >> for submodule (commit) or
  C<< 120000 >> for a blob that specifies the path of a symlink.
  
  =item *
  
  B<type>: mandatory string of C<< blob >>, C<< tree >>, C<< commit >>.
  
  =item *
  
  B<sha>: mandatory string of SHA1 checksum ID of the object in the tree.
  
  =item *
  
  B<content>: String of content you want this file to have - GitHub will
  write this blob out and use that SHA for this entry. Use either this
  or C<< tree.sha >>.
  
  =back
  
  =back
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Trees->new;
      my $result = $t->create(
          user => 'octocat',
          repo => 'Hello-World',
          data => {
              tree => [
                  {
                      path => 'file.rb',
                      mode => '100644',
                      type => 'blob',
                      sha  => '7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b',
                  }
              ]
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "sha": "cd8274d15fa3ae2ab983129fb037999f264ba9a7",
          "url": "https://api.github.com/repo/octocat/Hello-World/trees/cd8274d15fa3ae2ab983129fb037999f264ba9a7",
          "tree": [
          {
              "path": "file.rb",
              "mode": "100644",
              "type": "blob",
              "size": 132,
              "sha": "7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b"
          }
          ]
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Tree
  
      GET /repos/:user/:repo/git/trees/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =item *
  
  B<recursive>: optional boolean
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Trees->new;
      my $result = $t->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6'
      );
  
  Response: B<Status: 200 OK>
  
      {
          "sha": "9fb037999f264ba9a7fc6274d15fa3ae2ab98312",
          "url": "https://api.github.com/repo/octocat/Hello-World/trees/9fb037999f264ba9a7fc6274d15fa3ae2ab98312",
          "tree": [
          {
              "path": "file.rb",
              "mode": "100644",
              "type": "blob",
              "size": 30,
              "sha": "44b4fc6d56897b048c772eb4087f854f46256132",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/44b4fc6d56897b048c772eb4087f854f46256132"
          },
          {
              "path": "subdir",
              "mode": "040000",
              "type": "tree",
              "sha": "f484d249c660418515fb01c2b9662073663c242e",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/f484d249c660418515fb01c2b9662073663c242e"
          },
          {
              "path": "exec_file",
              "mode": "100755",
              "type": "blob",
              "size": 75,
              "sha": "45b983be36b73c0788dc9cbcb76cbb80fc7bb057",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/45b983be36b73c0788dc9cbcb76cbb80fc7bb057"
          }
          ]
      }
  
  =item *
  
  Get a Tree Recursively
  
      GET /repos/:user/:repo/git/trees/:sha?recursive=1
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =item *
  
  B<recursive>: optional boolean
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Trees->new;
      my $result = $t->get(
          user      => 'plu',
          repo      => 'Pithub',
          sha       => 'df21b2660fb6',
          recursive => 1,
      );
  
  Response: B<Status: 200 OK>
  
      {
          "sha": "fc6274d15fa3ae2ab983129fb037999f264ba9a7",
          "url": "https://api.github.com/repo/octocat/Hello-World/trees/fc6274d15fa3ae2ab983129fb037999f264ba9a7",
          "tree": [
          {
              "path": "subdir/file.txt",
              "mode": "100644",
              "type": "blob",
              "size": 132,
              "sha": "7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b",
              "url": "https://api.github.com/octocat/Hello-World/git/7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b"
          }
          ]
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_TREES

$fatpacked{"Pithub/Issues.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES';
  package Pithub::Issues;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Issues API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Issues::Assignees;
  use Pithub::Issues::Comments;
  use Pithub::Issues::Events;
  use Pithub::Issues::Labels;
  use Pithub::Issues::Milestones;
  extends 'Pithub::Base';
  
  
  sub assignees {
      return shift->_create_instance('Pithub::Issues::Assignees', @_);
  }
  
  
  sub comments {
      return shift->_create_instance('Pithub::Issues::Comments', @_);
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/issues', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub events {
      return shift->_create_instance('Pithub::Issues::Events', @_);
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/%s', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub labels {
      return shift->_create_instance('Pithub::Issues::Labels', @_);
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_get_user_repo_args( \%args );
      if ( $args{user} && $args{repo} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/issues', delete $args{user}, delete $args{repo} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf('/issues'),
          %args,
      );
  }
  
  
  sub milestones {
      return shift->_create_instance('Pithub::Issues::Milestones', @_);
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/issues/%s', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues - Github v3 Issues API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 assignees
  
  Provides access to L<Pithub::Issues::Assignees>.
  
  =head2 comments
  
  Provides access to L<Pithub::Issues::Comments>.
  
  =head2 create
  
  =over
  
  =item *
  
  Create an issue
  
      POST /repos/:user/:repo/issues
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<title>: mandatory string
  
  =item *
  
  B<body>: optional string
  
  =item *
  
  B<assignee>: optional string - Login for the user that this issue
  should be assigned to.
  
  =item *
  
  B<milestone>: optional number - Milestone to associate this issue
  with.
  
  =item *
  
  B<labels>: optional arrayref of strings - Labels to associate with this
  issue.
  
  =back
  
  =back
  
  Examples:
  
      my $i = Pithub::Issues->new;
      my $result = $i->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              assignee  => 'octocat',
              body      => "I'm having a problem with this.",
              labels    => [ 'Label1', 'Label2' ],
              milestone => 1,
              title     => 'Found a bug'
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
          "html_url": "https://github.com/octocat/Hello-World/issues/1",
          "number": 1347,
          "state": "open",
          "title": "Found a bug",
          "body": "I'm having a problem with this.",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "labels": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
              "name": "bug",
              "color": "f29513"
          }
          ],
          "assignee": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "milestone": {
              "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
              "number": 1,
              "state": "open",
              "title": "v1.0",
              "description": "",
              "creator": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "open_issues": 4,
              "closed_issues": 8,
              "created_at": "2011-04-10T20:09:31Z",
              "due_on": null
          },
          "comments": 0,
          "pull_request": {
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
              "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
          },
          "closed_at": null,
          "created_at": "2011-04-22T13:33:48Z",
          "updated_at": "2011-04-22T13:33:48Z"
      }
  
  =back
  
  =head2 events
  
  Provides access to L<Pithub::Issues::Events>.
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single issue
  
      GET /repos/:user/:repo/issues/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<issue_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $i = Pithub::Issues->new;
      my $result = $i->get(
          user => 'plu',
          repo => 'Pithub',
          issue_id => 1,
      );
  
  Response: B<Status: 200 OK>
  
      {
          "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
          "html_url": "https://github.com/octocat/Hello-World/issues/1",
          "number": 1347,
          "state": "open",
          "title": "Found a bug",
          "body": "I'm having a problem with this.",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "labels": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
              "name": "bug",
              "color": "f29513"
          }
          ],
          "assignee": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "milestone": {
              "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
              "number": 1,
              "state": "open",
              "title": "v1.0",
              "description": "",
              "creator": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "open_issues": 4,
              "closed_issues": 8,
              "created_at": "2011-04-10T20:09:31Z",
              "due_on": null
          },
          "comments": 0,
          "pull_request": {
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
              "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
          },
          "closed_at": null,
          "created_at": "2011-04-22T13:33:48Z",
          "updated_at": "2011-04-22T13:33:48Z"
      }
  
  =back
  
  =head2 labels
  
  Provides access to L<Pithub::Issues::Labels>.
  
  =head2 list
  
  =over
  
  =item *
  
  List the issues of the authenticated user
  
      GET /issues
  
  This API call can be influenced via the C<< params >>
  hashref with following parameters:
  
  =over
  
  =item *
  
  B<filter>: one of the following:
  
  =over
  
  =item *
  
  B<assigned>: Issues assigned to you (default)
  
  =item *
  
  B<created>: Issues created by you
  
  =item *
  
  B<mentioned>: Issues mentioning you
  
  =item *
  
  B<subscribed>: Issues you're subscribed to updates for
  
  =back
  
  =item *
  
  B<state>: one of the following:
  
  =over
  
  =item *
  
  B<open> (default)
  
  =item *
  
  B<closed>
  
  =back
  
  =item *
  
  B<labels>: String list of comma separated Label names.
  Example: C<< bug,ui,@high >>
  
  =item *
  
  B<sort>: one of the following:
  
  =over
  
  =item *
  
  B<created> (default)
  
  =item *
  
  B<updated>
  
  =item *
  
  B<comments>
  
  =back
  
  =item *
  
  B<direction>: one of the following:
  
  =over
  
  =item *
  
  B<asc>
  
  =item *
  
  B<desc> (default)
  
  =back
  
  =item *
  
  B<since>: optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
  
  =back
  
  Examples:
  
      my $i      = Pithub::Issues->new;
      my $result = $i->list(
          params => {
              filter    => 'assigned',
              state     => 'open',
              labels    => 'bug',
              sort      => 'updated',
              direction => 'asc',
          }
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "number": 1347,
              "state": "open",
              "title": "Found a bug",
              "body": "I'm having a problem with this.",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "labels": [
              {
                  "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
                  "name": "bug",
                  "color": "f29513"
              }
              ],
              "assignee": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "milestone": {
                  "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
                  "number": 1,
                  "state": "open",
                  "title": "v1.0",
                  "description": "",
                  "creator": {
                      "login": "octocat",
                      "id": 1,
                      "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                      "url": "https://api.github.com/users/octocat"
                  },
                  "open_issues": 4,
                  "closed_issues": 8,
                  "created_at": "2011-04-10T20:09:31Z",
                  "due_on": null
              },
              "comments": 0,
              "pull_request": {
                  "html_url": "https://github.com/octocat/Hello-World/issues/1",
                  "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
                  "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
              },
              "closed_at": null,
              "created_at": "2011-04-22T13:33:48Z",
              "updated_at": "2011-04-22T13:33:48Z"
          }
      ]
  
  =item *
  
  List issues for a repository
  
      GET /repos/:user/:repo/issues
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =back
  
  This API call can be influenced via the C<< params >>
  hashref with following parameters:
  
  =over
  
  =item *
  
  B<milestone>: one of the following:
  
  =over
  
  =item *
  
  C<< Integer >> Milestone number
  
  =item *
  
  C<< none >> for Issues with no Milestone
  
  =item *
  
  C<< * >> for Issues with any Milestone
  
  =back
  
  =item *
  
  B<state>: one of the following:
  
  =over
  
  =item *
  
  B<open> (default)
  
  =item *
  
  B<closed>
  
  =back
  
  =item *
  
  B<assignee>: one of the following:
  
  =over
  
  =item *
  
  C<< String >> User login
  
  =item *
  
  C<< none >> for Issues with no assigned User
  
  =item *
  
  C<< * >> for Issues with any assigned User
  
  =back
  
  =item *
  
  B<mentioned>: String User login
  
  =item *
  
  B<labels>: String list of comma separated Label names.
  Example: C<< bug,ui,@high >>
  
  =item *
  
  B<sort>: one of the following:
  
  =over
  
  =item *
  
  B<created> (default)
  
  =item *
  
  B<updated>
  
  =item *
  
  B<comments>
  
  =back
  
  =item *
  
  B<direction>: one of the following:
  
  =over
  
  =item *
  
  B<asc>
  
  =item *
  
  B<desc> (default)
  
  =back
  
  =item *
  
  B<since>: optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
  
  =back
  
  Examples:
  
      my $i      = Pithub::Issues->new;
      my $result = $i->list(
          user    => 'plu',
          repo    => 'Pithub',
          params => {
              milestone => 42,
              state     => 'open',
              labels    => 'bug',
              sort      => 'updated',
              direction => 'asc',
          }
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "number": 1347,
              "state": "open",
              "title": "Found a bug",
              "body": "I'm having a problem with this.",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "labels": [
              {
                  "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
                  "name": "bug",
                  "color": "f29513"
              }
              ],
              "assignee": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "milestone": {
                  "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
                  "number": 1,
                  "state": "open",
                  "title": "v1.0",
                  "description": "",
                  "creator": {
                      "login": "octocat",
                      "id": 1,
                      "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                      "url": "https://api.github.com/users/octocat"
                  },
                  "open_issues": 4,
                  "closed_issues": 8,
                  "created_at": "2011-04-10T20:09:31Z",
                  "due_on": null
              },
              "comments": 0,
              "pull_request": {
                  "html_url": "https://github.com/octocat/Hello-World/issues/1",
                  "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
                  "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
              },
              "closed_at": null,
              "created_at": "2011-04-22T13:33:48Z",
              "updated_at": "2011-04-22T13:33:48Z"
          }
      ]
  
  =back
  
  =head2 milestones
  
  Provides access to L<Pithub::Issues::Milestones>.
  
  =head2 update
  
  =over
  
  =item *
  
  Edit an issue
  
      PATCH /repos/:user/:repo/issues/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<title>: mandatory string
  
  =item *
  
  B<body>: optional string
  
  =item *
  
  B<assignee>: optional string - Login for the user that this issue
  should be assigned to.
  
  =item *
  
  B<milestone>: optional number - Milestone to associate this issue
  with.
  
  =item *
  
  B<labels>: optional arrayref of strings - Labels to associate with
  this issue. Pass one or more Labels to replace the set of Labels
  on this Issue. Send an empty arrayref (C<< [] >>) to clear all
  Labels from the Issue.
  
  =back
  
  =back
  
  Examples:
  
      my $i = Pithub::Issues->new;
      my $result = $i->update(
          user     => 'plu',
          repo     => 'Pithub',
          issue_id => 1,
          data     => {
              assignee  => 'octocat',
              body      => "I'm having a problem with this.",
              labels    => [ 'Label1', 'Label2' ],
              milestone => 1,
              state     => 'open',
              title     => 'Found a bug'
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES

$fatpacked{"Pithub/Issues/Assignees.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_ASSIGNEES';
  package Pithub::Issues::Assignees;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Issue Assignees API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub check {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: assignee' unless $args{assignee};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/assignees/%s', delete $args{user}, delete $args{repo}, delete $args{assignee} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/assignees', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Assignees - Github v3 Issue Assignees API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 check
  
  =over
  
  =item *
  
  You may also check to see if a particular user is an assignee for a repository.
  
      GET /repos/:user/:repo/assignees/:assignee
  
  If the given assignee login belongs to an assignee for the repository, a 204
  header with no content is returned.
  
  Examples:
  
      my $c      = Pithub::Issues::Assignees->new;
      my $result = $c->check(
          repo     => 'Pithub',
          user     => 'plu',
          assignee => 'plu',
      );
      if ( $result->success ) {
          print "plu is an assignee for the repo plu/Pithub.git";
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  This call lists all the available assignees (owner + collaborators)
  to which issues may be assigned.
  
      GET /repos/:user/:repo/assignees
  
  Examples:
  
      my $c      = Pithub::Issues::Assignees->new;
      my $result = $c->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_ASSIGNEES

$fatpacked{"Pithub/Issues/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_COMMENTS';
  package Pithub::Issues::Comments;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Issue Comments API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/issues/%s/comments', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/issues/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/%s/comments', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/issues/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Comments - Github v3 Issue Comments API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a comment
  
      POST /repos/:user/:repo/issues/:id/comments
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->create(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          data     => { body => 'some comment' }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a comment
  
      DELETE /repos/:user/:repo/issues/comments/:id
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->delete(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single comment
  
      GET /repos/:user/:repo/issues/comments/:id
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->get(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List comments on an issue
  
      GET /repos/:user/:repo/issues/:id/comments
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->list(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a comment
  
      PATCH /repos/:user/:repo/issues/comments/:id
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->update(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
          data       => { body => 'some comment' },
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_COMMENTS

$fatpacked{"Pithub/Issues/Events.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_EVENTS';
  package Pithub::Issues::Events;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Issue Events API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: event_id' unless $args{event_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/events/%s', delete $args{user}, delete $args{repo}, delete $args{event_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $issue_id = delete $args{issue_id} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/issues/%s/events', delete $args{user}, delete $args{repo}, $issue_id ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Events - Github v3 Issue Events API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single event
  
      GET /repos/:user/:repo/issues/events/:id
  
  Examples:
  
      my $e = Pithub::Issues::Events->new;
      my $result = $e->get(
          repo     => 'Pithub',
          user     => 'plu',
          event_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List events for an issue
  
      GET /repos/:user/:repo/issues/:issue_id/events
  
  Examples:
  
      my $e = Pithub::Issues::Events->new;
      my $result = $e->list(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =item *
  
  List events for a repository
  
      GET /repos/:user/:repo/issues/events
  
  Examples:
  
      my $e = Pithub::Issues::Events->new;
      my $result = $e->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_EVENTS

$fatpacked{"Pithub/Issues/Labels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_LABELS';
  package Pithub::Issues::Labels;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Issue Labels API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub add {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/labels', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: label' unless $args{label};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{label} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: label' unless $args{label};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{label} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $milestone_id = delete $args{milestone_id} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/milestones/%s/labels', delete $args{user}, delete $args{repo}, $milestone_id ),
              %args,
          );
      }
      elsif ( my $issue_id = delete $args{issue_id} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, $issue_id ),
              %args
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/labels', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub remove {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      if ( my $label = delete $args{label} ) {
          return $self->request(
              method => 'DELETE',
              path   => sprintf( '/repos/%s/%s/issues/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{issue_id}, $label ),
              %args,
          );
      }
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub replace {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: label' unless $args{label};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{label} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Labels - Github v3 Issue Labels API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 add
  
  =over
  
  =item *
  
  Add labels to an issue
  
      POST /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->add(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          data     => ['Label1', 'Label2'],
      );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a label
  
      POST /repos/:user/:repo/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->create(
          repo => 'Pithub',
          user => 'plu',
          data => {
              color => 'FFFFFF',
              name  => 'some label',
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a label
  
      DELETE /repos/:user/:repo/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->delete(
          repo     => 'Pithub',
          user     => 'plu',
          label => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single label
  
      GET /repos/:user/:repo/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->get(
          repo => 'Pithub',
          user => 'plu',
          label => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all labels for this repository
  
      GET /repos/:user/:repo/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->list(
          repo => 'Pithub',
          user => 'plu'
      );
  
  =item *
  
  List labels on an issue
  
      GET /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->list(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =item *
  
  Get labels for every issue in a milestone
  
      GET /repos/:user/:repo/milestones/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->get(
          repo         => 'Pithub',
          user         => 'plu',
          milestone_id => 1
      );
  
  =back
  
  =head2 remove
  
  =over
  
  =item *
  
  Remove a label from an issue
  
      DELETE /repos/:user/:repo/issues/:id/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->delete(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          label => 1,
      );
  
  =item *
  
  Remove all labels from an issue
  
      DELETE /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->delete(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =back
  
  =head2 replace
  
  =over
  
  =item *
  
  Replace all labels for an issue
  
      PUT /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->replace(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          data     => [qw(label3 label4)],
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a label
  
      PATCH /repos/:user/:repo/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->update(
          repo     => 'Pithub',
          user     => 'plu',
          label => 1,
          data     => {
              color => 'FFFFFF',
              name  => 'API',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_LABELS

$fatpacked{"Pithub/Issues/Milestones.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_MILESTONES';
  package Pithub::Issues::Milestones;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Issue Milestones API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/milestones', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: milestone_id' unless $args{milestone_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/milestones/%s', delete $args{user}, delete $args{repo}, delete $args{milestone_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: milestone_id' unless $args{milestone_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/milestones/%s', delete $args{user}, delete $args{repo}, delete $args{milestone_id} ),
          %args
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/milestones', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: milestone_id' unless $args{milestone_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/milestones/%s', delete $args{user}, delete $args{repo}, delete $args{milestone_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Milestones - Github v3 Issue Milestones API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a milestone
  
      POST /repos/:user/:repo/milestones
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->create(
          repo => 'Pithub',
          user => 'plu',
          data => {
              description => 'String',
              due_on      => 'Time',
              state       => 'open or closed',
              title       => 'String'
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a milestone
  
      DELETE /repos/:user/:repo/milestones/:id
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->delete(
          repo => 'Pithub',
          user => 'plu',
          milestone_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single milestone
  
      GET /repos/:user/:repo/milestones/:id
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->get(
          repo => 'Pithub',
          user => 'plu',
          milestone_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List milestones for an issue
  
      GET /repos/:user/:repo/milestones
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a milestone
  
      PATCH /repos/:user/:repo/milestones/:id
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->update(
          repo => 'Pithub',
          user => 'plu',
          data => {
              description => 'String',
              due_on      => 'Time',
              state       => 'open or closed',
              title       => 'String'
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_MILESTONES

$fatpacked{"Pithub/Markdown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_MARKDOWN';
  package Pithub::Markdown;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Markdown API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  has [qw( mode context )] => ( is => 'rw' );
  
  
  sub render {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless defined $args{data};
  
      for (qw( context mode )) {
          $args{data}{$_} = $self->$_ if !exists $args{data}{$_} and $self->$_;
      }
  
      return $self->request(
          method => 'POST',
          path   => '/markdown',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Markdown - Github v3 Markdown API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 ATTRIBUTES
  
  =head2 mode
  
  The rendering mode. Can be either:
  
  =over
  
  =item *
  
  C<markdown> to render a document in plain Markdown, just like README.md
  files are rendered.
  
  =item *
  
  C<gfm> to render a document in GitHub Flavored Markdown, which creates
  links for user mentions as well as references to SHA-1 hashes, issues,
  and pull requests.
  
  =back
  
  =head2 context
  
  The repository context to use when creating references in C<gfm> mode.
  Omit this parameter when using C<markdown> mode.
  
  =head1 METHODS
  
  =head2 render
  
  Render an arbitrary Markdown document
  
      POST /markdown
  
  Example:
  
      my $response = Pithub::Markdown->render(
          data => {
              text => "Hello world github/linguist#1 **cool**, and #1!",
              context => "github/gollum",
              mode => "gfm",
          },
      );
  
      # Note that response is NOT in JSON, so ->content will die
      my $html = $response->raw_content;
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_MARKDOWN

$fatpacked{"Pithub/Orgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ORGS';
  package Pithub::Orgs;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Orgs API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Orgs::Members;
  use Pithub::Orgs::Teams;
  extends 'Pithub::Base';
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s', delete $args{org} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/orgs', $user ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/orgs',
          %args,
      );
  }
  
  
  sub members {
      return shift->_create_instance('Pithub::Orgs::Members', @_);
  }
  
  
  sub teams {
      return shift->_create_instance('Pithub::Orgs::Teams', @_);
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/orgs/%s', delete $args{org} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Orgs - Github v3 Orgs API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 get
  
  =over
  
  =item *
  
  Get an organization
  
      GET /orgs/:org
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->get( org => 'CPAN-API' );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all public organizations for a user.
  
      GET /users/:user/orgs
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->list( user => 'plu' );
  
  =item *
  
  List public and private organizations for the authenticated user.
  
      GET /user/orgs
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->list;
  
  =back
  
  =head2 members
  
  Provides access to L<Pithub::Orgs::Members>.
  
  =head2 teams
  
  Provides access to L<Pithub::Orgs::Teams>.
  
  =head2 update
  
  =over
  
  =item *
  
  Edit an organization
  
      PATCH /orgs/:org
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->update(
          org  => 'CPAN-API',
          data => {
              billing_email => 'support@github.com',
              blog          => 'https://github.com/blog',
              company       => 'GitHub',
              email         => 'support@github.com',
              location      => 'San Francisco',
              name          => 'github',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ORGS

$fatpacked{"Pithub/Orgs/Members.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ORGS_MEMBERS';
  package Pithub::Orgs::Members;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Org Members API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub conceal {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/orgs/%s/public_members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/orgs/%s/members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub is_member {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub is_public {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/public_members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/members', delete $args{org} ),
          %args,
      );
  }
  
  
  sub list_public {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/public_members', delete $args{org} ),
          %args,
      );
  }
  
  
  sub publicize {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/orgs/%s/public_members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Orgs::Members - Github v3 Org Members API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 conceal
  
  =over
  
  =item *
  
  Conceal a user's membership
  
      DELETE /orgs/:org/public_members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->conceal(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Removing a user from this list will remove them from all teams and
  they will no longer have any access to the organization's
  repositories.
  
      DELETE /orgs/:org/members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->delete(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 is_member
  
  =over
  
  =item *
  
  Check if a user is a member of an organization
  
      GET /orgs/:org/members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->is_member(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 is_public
  
  =over
  
  =item *
  
  Get if a user is a public member
  
      GET /orgs/:org/public_members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->is_public(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all users who are members of an organization. A member is a user
  that belongs to at least 1 team in the organization. If the
  authenticated user is also a member of this organization then both
  concealed and public members will be returned. Otherwise only public
  members are returned.
  
      GET /orgs/:org/members
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->list( org => 'CPAN-API' );
  
  =back
  
  =head2 list_public
  
  =over
  
  =item *
  
  Members of an organization can choose to have their membership
  publicized or not.
  
      GET /orgs/:org/public_members
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->list_public( org => 'CPAN-API' );
  
  =back
  
  =head2 publicize
  
  =over
  
  =item *
  
  Publicize a user's membership
  
      PUT /orgs/:org/public_members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->publicize(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ORGS_MEMBERS

$fatpacked{"Pithub/Orgs/Teams.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ORGS_TEAMS';
  package Pithub::Orgs::Teams;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Org Teams API
  
  use Moo;
  use Carp qw(croak carp);
  extends 'Pithub::Base';
  
  
  sub add_member {
      my ( $self, %args ) = @_;
      carp '"Add team member" API is deprecated. Use add_membership method.';
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/teams/%s/members/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub add_membership {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      croak 'Missing key in parameters: data'    unless $args{data};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/teams/%s/memberships/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub add_repo {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: repo'    unless $args{repo};
      croak 'Missing key in parameters: org'     unless $args{org};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/teams/%s/repos/%s/%s',
              delete $args{team_id},
              delete $args{org},
              delete $args{repo} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => sprintf( '/orgs/%s/teams', delete $args{org} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub has_repo {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: repo'    unless $args{repo};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/repos/%s', delete $args{team_id}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub is_member {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/members/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/teams', delete $args{org} ),
          %args,
      );
  }
  
  
  sub list_members {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/members', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub list_repos {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/repos', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub remove_member {
      my ( $self, %args ) = @_;
      carp '"Remove team member" API is deprecated. Use remove_membership method.';
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s/members/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub remove_membership {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s/memberships/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub remove_repo {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: repo'    unless $args{repo};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s/repos/%s', delete $args{team_id}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/teams/%s', delete $args{team_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Orgs::Teams - Github v3 Org Teams API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 add_member
  
  =over
  
  The "Add team member" API (described below) is deprecated and is
  scheduled for removal in the next major version of the API. We
  recommend using the Add team membership API instead. It allows
  you to invite new organization members to your teams.
  
  In order to add a user to a team, the authenticated user must have
  'admin' permissions to the team or be an owner of the org that the
  team is associated with.
  
      PUT /teams/:id/members/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->add_member(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 add_membership
  
  =over
  
  If the user is already a member of the team’s organization, this
  endpoint will add the user to the team. In order to add a membership
  between an organization member and a team, the authenticated user
  must be an organization owner or a maintainer of the team.
  
      PUT /teams/:id/memberships/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->add_membership(
          team_id => 1,
          user    => 'plu',
          data    => {
              role => 'member',
          }
      );
  
  =back
  
  =head2 add_repo
  
  =over
  
  In order to add a repo to a team, the authenticated user must be
  an owner of the org that the team is associated with.
  
      PUT /teams/:id/repos/:repo
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->add_repo(
          team_id => 1,
          repo    => 'some_repo',
          org => 'our_organization',
      );
  
  =back
  
  =head2 create
  
  =over
  
  In order to create a team, the authenticated user must be an
  owner of the given organization.
  
      POST /orgs/:org/teams
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->create(
          org  => 'CPAN-API',
          data => {
              name       => 'new team',
              permission => 'push',
              repo_names => ['github/dotfiles']
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  In order to delete a team, the authenticated user must be an owner
  of the org that the team is associated with.
  
      DELETE /teams/:id
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->delete( team_id => 1 );
  
  =back
  
  =head2 get
  
  =over
  
  Get team
  
      GET /teams/:id
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->get( team_id => 1 );
  
  =back
  
  =head2 has_repo
  
  =over
  
  Get team repo
  
      GET /teams/:id/repos/:repo
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->has_repo(
          team_id => 1,
          repo    => 'some_repo',
      );
  
  =back
  
  =head2 is_member
  
  =over
  
  In order to get if a user is a member of a team, the authenticated
  user must be a member of the team.
  
      GET /teams/:id/members/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->is_member(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 list
  
  =over
  
  List teams
  
      GET /orgs/:org/teams
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->list( org => 'CPAN-API' );
  
  =back
  
  =head2 list_members
  
  =over
  
  In order to list members in a team, the authenticated user must be
  a member of the team.
  
      GET /teams/:id/members
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->list_members( team_id => 1 );
  
  =back
  
  =head2 list_repos
  
  =over
  
  List team repos
  
      GET /teams/:id/repos
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->list_repos( team_id => 1 );
  
  =back
  
  =head2 remove_member
  
  =over
  
  The "Remove team member" API (described below) is deprecated and
  is scheduled for removal in the next major version of the API. We
  recommend using the Remove team membership API instead. It allows
  you to remove both active and pending memberships.
  
  In order to remove a user from a team, the authenticated user must
  have 'admin' permissions to the team or be an owner of the org that
  the team is associated with. NOTE: This does not delete the user,
  it just remove them from the team.
  
      DELETE /teams/:id/members/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->remove_member(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 remove_membership
  
  =over
  
  In order to remove a membership between a user and a team,
  the authenticated user must have 'admin' permissions to
  the team or be an owner of the organization that the team
  is associated with. NOTE: This does not delete the user,
  it just removes their membership from the team.
  
      DELETE /teams/:id/memberships/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->remove_membership(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 remove_repo
  
  =over
  
  In order to remove a repo from a team, the authenticated user must be
  an owner of the org that the team is associated with.
  
      DELETE /teams/:id/repos/:repo
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->remove_repo(
          team_id => 1,
          repo    => 'some_repo',
      );
  
  =back
  
  =head2 update
  
  =over
  
  In order to edit a team, the authenticated user must be an owner
  of the org that the team is associated with.
  
      PATCH /teams/:id
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->update(
          team_id => 1,
          data    => {
              name       => 'new team name',
              permission => 'push',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ORGS_TEAMS

$fatpacked{"Pithub/PullRequests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_PULLREQUESTS';
  package Pithub::PullRequests;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Pull Requests API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::PullRequests::Comments;
  extends 'Pithub::Base';
  
  
  sub comments {
      return shift->_create_instance('Pithub::PullRequests::Comments', @_);
  }
  
  
  sub commits {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/commits', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/pulls', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub files {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/files', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub is_merged {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/merge', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub merge {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/repos/%s/%s/pulls/%s/merge', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/pulls/%s', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::PullRequests - Github v3 Pull Requests API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 comments
  
  Provides access to L<Pithub::PullRequests::Comments>.
  
  =head2 commits
  
  =over
  
  =item *
  
  List commits on a pull request
  
      GET /repos/:user/:repo/pulls/:id/commits
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->commits(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1
      );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a pull request
  
      POST /repos/:user/:repo/pulls
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->create(
          user   => 'plu',
          repo => 'Pithub',
          data   => {
              base  => 'master',
              body  => 'Please pull this in!',
              head  => 'octocat:new-feature',
              title => 'Amazing new feature',
          }
      );
  
  =back
  
  =head2 files
  
  =over
  
  =item *
  
  List pull requests files
  
      GET /repos/:user/:repo/pulls/:id/files
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->files(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single pull request
  
      GET /repos/:user/:repo/pulls/:id
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->get(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 is_merged
  
  =over
  
  =item *
  
  Get if a pull request has been merged
  
      GET /repos/:user/:repo/pulls/:id/merge
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->is_merged(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List pull requests
  
      GET /repos/:user/:repo/pulls
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->list(
          user => 'plu',
          repo => 'Pithub'
      );
  
  =back
  
  =head2 merge
  
  =over
  
  =item *
  
  Merge a pull request
  
      PUT /repos/:user/:repo/pulls/:id/merge
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->merge(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a pull request
  
      PATCH /repos/:user/:repo/pulls/:id
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->update(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
          data            => {
              base  => 'master',
              body  => 'Please pull this in!',
              head  => 'octocat:new-feature',
              title => 'Amazing new feature',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_PULLREQUESTS

$fatpacked{"Pithub/PullRequests/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_PULLREQUESTS_COMMENTS';
  package Pithub::PullRequests::Comments;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Pull Request Comments API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/pulls/%s/comments', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/pulls/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/comments', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/pulls/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::PullRequests::Comments - Github v3 Pull Request Comments API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a comment
  
      POST /repos/:user/:repo/pulls/:id/comments
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->create(
          repo            => 'Pithub',
          user            => 'plu',
          pull_request_id => 1,
          data            => {
              body      => 'Nice change',
              commit_id => '6dcb09b5b57875f334f61aebed695e2e4193db5e',
              path      => 'file1.txt',
              position  => 4,
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a comment
  
      DELETE /repos/:user/:repo/pulls/comments/:id
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->delete(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single comment
  
      GET /repos/:user/:repo/pulls/comments/:id
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->get(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List comments on a pull request
  
      GET /repos/:user/:repo/pulls/:id/comments
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->list(
          repo            => 'Pithub',
          user            => 'plu',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a comment
  
      PATCH /repos/:user/:repo/pulls/comments/:id
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->update(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
          data       => { body => 'some updated comment' },
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_PULLREQUESTS_COMMENTS

$fatpacked{"Pithub/Repos.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS';
  package Pithub::Repos;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repos API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Issues;
  use Pithub::Markdown;
  use Pithub::PullRequests;
  use Pithub::Repos::Collaborators;
  use Pithub::Repos::Commits;
  use Pithub::Repos::Contents;
  use Pithub::Repos::Downloads;
  use Pithub::Repos::Forks;
  use Pithub::Repos::Hooks;
  use Pithub::Repos::Keys;
  use Pithub::Repos::Releases;
  use Pithub::Repos::Starring;
  use Pithub::Repos::Stats;
  use Pithub::Repos::Statuses;
  use Pithub::Repos::Watching;
  extends 'Pithub::Base';
  
  
  sub branch {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: branch (string)' unless defined $args{branch};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf(
              '/repos/%s/%s/branches/%s', delete $args{user},
                                          delete $args{repo},
                                          delete $args{branch},
          ),
          %args,
      );
  }
  
  
  sub branches {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/branches', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub collaborators {
      return shift->_create_instance('Pithub::Repos::Collaborators', @_);
  }
  
  
  sub commits {
      return shift->_create_instance('Pithub::Repos::Commits', @_);
  }
  
  
  sub contents {
      return shift->_create_instance('Pithub::Repos::Contents', @_);
  }
  
  
  sub contributors {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/contributors', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      if ( my $org = delete $args{org} ) {
          return $self->request(
              method => 'POST',
              path   => sprintf( '/orgs/%s/repos', $org ),
              %args,
          );
      }
      else {
          return $self->request(
              method => 'POST',
              path   => '/user/repos',
              %args,
          );
      }
  }
  
  
  sub delete {
      my( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub downloads {
      return shift->_create_instance('Pithub::Repos::Downloads', @_);
  }
  
  
  sub forks {
      return shift->_create_instance('Pithub::Repos::Forks', @_);
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub hooks {
      return shift->_create_instance('Pithub::Repos::Hooks', @_);
  }
  
  
  sub issues {
      return shift->_create_instance('Pithub::Issues', @_);
  }
  
  
  sub keys {
      return shift->_create_instance('Pithub::Repos::Keys', @_);
  }
  
  
  sub languages {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/languages', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/repos', $user ),
              %args,
          );
      }
      elsif ( my $org = delete $args{org} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/orgs/%s/repos', $org ),
              %args
          );
      }
      else {
          return $self->request(
              method => 'GET',
              path   => '/user/repos',
              %args,
          );
      }
  }
  
  
  sub markdown {
      my $self = shift;
      return $self->_create_instance('Pithub::Markdown',
          mode => 'gfm', context => sprintf( '%s/%s', $self->user, $self->repo ),
          @_);
  }
  
  
  sub pull_requests {
      return shift->_create_instance('Pithub::PullRequests', @_);
  }
  
  
  sub releases {
      return shift->_create_instance('Pithub::Repos::Releases', @_);
  }
  
  
  sub starring {
      return shift->_create_instance('Pithub::Repos::Starring', @_);
  }
  
  
  sub stats {
      return shift->_create_instance('Pithub::Repos::Stats', @_);
  }
  
  
  sub statuses {
      return shift->_create_instance('Pithub::Repos::Statuses', @_);
  }
  
  
  sub tags {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/tags', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub teams {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/teams', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub watching {
      return shift->_create_instance('Pithub::Repos::Watching', @_);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos - Github v3 Repos API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 branch
  
  Get information about a single branch.
  
      GET /repos/:owner/:repo/branches/:branch
  
  Example:
  
      my $result = Pithub->new->branch(
          user => 'plu',
          repo => 'Pithub',
          branch => "master"
      );
  
  See also L<branches> to get a list of all branches.
  
  =head2 branches
  
  =over
  
  =item *
  
  List Branches
  
      GET /repos/:user/:repo/branches
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->branches( user => 'plu', repo => 'Pithub' );
  
  See also L<branch> to get information about a single branch.
  
  =back
  
  =head2 collaborators
  
  Provides access to L<Pithub::Repos::Collaborators>.
  
  =head2 commits
  
  Provides access to L<Pithub::Repos::Commits>.
  
  =head2 contents
  
  Provides access to L<Pithub::Repos::Contents>.
  
  =head2 contributors
  
  =over
  
  =item *
  
  List contributors
  
      GET /repos/:user/:repo/contributors
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->contributors( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a new repository for the authenticated user.
  
      POST /user/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->create( data => { name => 'some-repo' } );
  
  =item *
  
  Create a new repository in this organization. The authenticated user
  must be a member of this organization.
  
      POST /orgs/:org/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->create(
          org  => 'CPAN-API',
          data => { name => 'some-repo' }
      );
  
  =back
  
  =head2 delete
  
  Delete a repository.
  
      DELETE /repos/:owner/:repo
  
  =head2 downloads
  
  Provides access to L<Pithub::Repos::Downloads>.
  
  =head2 forks
  
  Provides access to L<Pithub::Repos::Forks>.
  
  =head2 get
  
  =over
  
  =item *
  
  Get a repo
  
      GET /repos/:user/:repo
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->get( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 hooks
  
  Provides access to L<Pithub::Repos::Hooks>.
  
  =head2 issues
  
  Provides access to L<Pithub::Issues> for this repo.
  
  =head2 keys
  
  Provides access to L<Pithub::Repos::Keys>.
  
  =head2 languages
  
  =over
  
  =item *
  
  List languages
  
      GET /repos/:user/:repo/languages
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->languages( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List repositories for the authenticated user.
  
      GET /user/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->list;
  
  =item *
  
  List public repositories for the specified user.
  
      GET /users/:user/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->list( user => 'plu' );
  
  =item *
  
  List repositories for the specified org.
  
      GET /orgs/:org/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->list( org => 'CPAN-API' );
  
  =back
  
  =head2 markdown
  
  Provides access to L<Pithub::Markdown> setting the current repository as the
  default context. This also sets the mode to default to 'gfm'.
  
  =head2 pull_requests
  
  Provides access to L<Pithub::PullRequests>.
  
  =head2 releases
  
  Provides access to L<Pithub::Repos::Releases>.
  
  =head2 starring
  
  Provides access to L<Pithub::Repos::Starring>.
  
  =head2 stats
  
  Provide access to L<Pithub::Repos::Stats>.
  
  =head2 statuses
  
  Provide access to L<Pithub::Repos::Statuses>.
  
  =head2 tags
  
  =over
  
  =item *
  
  List Tags
  
      GET /repos/:user/:repo/tags
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->tags( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 teams
  
  =over
  
  =item *
  
  List Teams
  
      GET /repos/:user/:repo/teams
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->teams( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit
  
      PATCH /repos/:user/:repo
  
  Examples:
  
      # update a repo for the authenticated user
      my $repos  = Pithub::Repos->new;
      my $result = $repos->update(
          repo => 'Pithub',
          data => { description => 'Github API v3' },
      );
  
  =back
  
  =head2 watching
  
  Provides access to L<Pithub::Repos::Watching>.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS

$fatpacked{"Pithub/Repos/Collaborators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_COLLABORATORS';
  package Pithub::Repos::Collaborators;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Collaborators API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub add {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: collaborator' unless $args{collaborator};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/repos/%s/%s/collaborators/%s', delete $args{user}, delete $args{repo}, delete $args{collaborator} ),
          %args,
      );
  }
  
  
  sub is_collaborator {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: collaborator' unless $args{collaborator};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/collaborators/%s', delete $args{user}, delete $args{repo}, delete $args{collaborator} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/collaborators', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub remove {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: collaborator' unless $args{collaborator};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/collaborators/%s', delete $args{user}, delete $args{repo}, delete $args{collaborator} ),
          %args
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Collaborators - Github v3 Repo Collaborators API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 add
  
  =over
  
  =item *
  
  Add collaborator
  
      PUT /repos/:user/:repo/collaborators/:user
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->add(
          user         => 'plu',
          repo         => 'Pithub',
          collaborator => 'rbo',
      );
  
  =back
  
  =head2 is_collaborator
  
  =over
  
  =item *
  
  Get
  
      GET /repos/:user/:repo/collaborators/:user
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->is_collaborator(
          user         => 'plu',
          repo         => 'Pithub',
          collaborator => 'rbo',
      );
  
      if ( $result->is_success ) {
          print "rbo is added as collaborator to Pithub\n";
      }
      elsif ( $result->code == 404 ) {
          print "rbo is not added as collaborator to Pithub\n";
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List
  
      GET /repos/:user/:repo/collaborators
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 remove
  
  =over
  
  =item *
  
  Remove collaborator
  
      DELETE /repos/:user/:repo/collaborators/:user
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->remove(
          user         => 'plu',
          repo         => 'Pithub',
          collaborator => 'rbo',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_COLLABORATORS

$fatpacked{"Pithub/Repos/Commits.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_COMMITS';
  package Pithub::Repos::Commits;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Commits API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub compare {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: base' unless $args{base};
      croak 'Missing key in parameters: head' unless $args{head};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/compare/%s...%s', delete $args{user}, delete $args{repo}, delete $args{base}, delete $args{head} ),
          %args,
      );
  }
  
  
  sub create_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/commits/%s/comments', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  
  sub delete_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/commits/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  
  sub get_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/commits', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list_comments {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $sha = delete $args{sha} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/commits/%s/comments', delete $args{user}, delete $args{repo}, $sha ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/comments', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Commits - Github v3 Repo Commits API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 compare
  
  =over
  
  =item *
  
  Compare two commits
  
      GET /repos/:user/:repo/compare/:base...:head
  
  Examples:
  
      my $c      = Pithub::Repos::Commits->new;
      my $result = $c->compare(
          user => 'plu',
          repo => 'Pithub',
          base => 'v0.01008',
          head => ' master ',
      );
  
  =back
  
  =head2 create_comment
  
  =over
  
  =item *
  
  Create a commit comment
  
      POST /repos/:user/:repo/commits/:sha/comments
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->create_comment(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
          data => { body => 'some comment' },
      );
  
  =back
  
  =head2 delete_comment
  
  =over
  
  =item *
  
  Delete a commit comment
  
      DELETE /repos/:user/:repo/comments/:id
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->delete_comment(
          user       => 'plu',
          repo       => 'Pithub',
          comment_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single commit
  
      GET /repos/:user/:repo/commits/:sha
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
      );
  
  =back
  
  =head2 get_comment
  
  =over
  
  =item *
  
  Get a single commit comment
  
      GET /repos/:user/:repo/comments/:id
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->get_comment(
          user       => 'plu',
          repo       => 'Pithub',
          comment_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List commits on a repository
  
      GET /repos/:user/:repo/commits
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 list_comments
  
  =over
  
  =item *
  
  List commit comments for a repository
  
  Commit Comments leverage these custom mime types. You can read more
  about the use of mimes types in the API here. See also:
  L<http://developer.github.com/v3/mimes/>.
  
      GET /repos/:user/:repo/comments
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->list_comments(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =item *
  
  List comments for a single commit
  
      GET /repos/:user/:repo/commits/:sha/comments
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->list_comments(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
      );
  
  =back
  
  =head2 update_comment
  
  =over
  
  =item *
  
  Update a commit comment
  
      PATCH /repos/:user/:repo/comments/:id
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->update_comment(
          user       => 'plu',
          repo       => 'Pithub',
          comment_id => 1,
          data       => { body => 'updated comment' },
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_COMMITS

$fatpacked{"Pithub/Repos/Contents.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_CONTENTS';
  package Pithub::Repos::Contents;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Contents API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub archive {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: archive_format' unless $args{archive_format};
      croak 'Invalid archive_format. Valid formats: tarball, zipball' unless grep $args{archive_format} eq $_, qw(tarball zipball);
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/%s/%s', delete $args{user}, delete $args{repo}, delete $args{archive_format}, delete $args{ref} || '' ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $path = delete $args{path} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/contents/%s', delete $args{user}, delete $args{repo}, $path ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/contents', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub readme {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/readme', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Contents - Github v3 Repo Contents API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 archive
  
  =over
  
  =item *
  
  This method will return a C<< 302 >> to a URL to download a tarball
  or zipball archive for a repository.
  
  Note: For private repositories, these links are temporary and expire
  quickly.
  
      GET /repos/:user/:repo/:archive_format/:ref
  
  The C<< ref >> parameter is optional and will default to
  C<< master >>.
  
  Examples:
  
      use Path::Tiny;
  
      my $c = Pithub::Repos::Contents->new(
          repo => 'Pithub',
          user => 'plu'
      );
  
      my $result = $c->archive( archive_format => 'tarball' );
      if ( $result->success ) {
          path('Pithub-master.tgz')->spew($result->raw_content);
      }
  
      $result = $c->archive( archive_format => 'tarball', ref => 'other_branch' );
      if ( $result->success ) {
          path('Pithub-other_branch.tgz')->spew($result->raw_content);
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  This method returns the contents of any file or directory in a
  repository.
  
      GET /repos/:user/:repo/contents/:path
  
  Optional Parameters:
  
  =over
  
  =item *
  
  B<ref>: Optional string - The String name of the
  Commit/Branch/Tag. Defaults to C<< master >>.
  
  =back
  
  Examples:
  
      my $c = Pithub::Repos::Contents->new(
          repo => 'Pithub',
          user => 'plu'
      );
  
      # List all files/directories in the repo root
      my $result = $c->get;
      if ( $result->success ) {
          say $_->{name} for @{ $result->content };
      }
  
      # Get the Pithub.pm file
      $result = $c->get( path => 'lib/Pithub.pm' );
      print Dumper $result->content if $result->success;
  
  =back
  
  =head2 readme
  
  =over
  
  =item *
  
  This method returns the preferred README for a repository.
  
      GET /repos/:user/:repo/readme
  
  Optional Parameters:
  
  =over
  
  =item *
  
  B<ref>: Optional string - The String name of the
  Commit/Branch/Tag. Defaults to C<< master >>.
  
  =back
  
  Examples:
  
      my $c = Pithub::Repos::Contents->new(
          repo => 'dotfiles',
          user => 'plu'
      );
  
      my $result = $c->readme;
      if ( $result->success ) {
          print Dumper $result->content;
      }
  
      # Get the readme of branch 'other_branch'
      $result = $c->readme( params => { ref => 'other_branch' } );
      print Dumper $result->content if $result->success;
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_CONTENTS

$fatpacked{"Pithub/Repos/Downloads.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_DOWNLOADS';
  package Pithub::Repos::Downloads;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Downloads API
  
  use Moo;
  use Carp qw(croak);
  use HTTP::Request::Common qw(POST);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/downloads', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: download_id' unless $args{download_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/downloads/%s', delete $args{user}, delete $args{repo}, delete $args{download_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: download_id' unless $args{download_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/downloads/%s', delete $args{user}, delete $args{repo}, delete $args{download_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/downloads', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub upload {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: result (Pithub::Result object)' unless ref $args{result} eq 'Pithub::Result';
      croak 'Missing key in parameters: file' unless $args{file};
      my $result = $args{result}->content;
      foreach my $key (qw(path acl name accesskeyid policy signature mime_type)) {
          croak "Missing key in Pithub::Result content: ${key}" unless grep $_ eq $key, keys %$result;
      }
      my %data = (
          Content_Type => 'form-data',
          Content      => [
              'key'                   => $result->{path},
              'acl'                   => $result->{acl},
              'success_action_status' => 201,
              'Filename'              => $result->{name},
              'AWSAccessKeyId'        => $result->{accesskeyid},
              'Policy'                => $result->{policy},
              'Signature'             => $result->{signature},
              'Content-Type'          => $result->{mime_type},
              'file'                  => [ $args{file} ],
          ],
      );
      my $request = POST $result->{s3_url}, %data;
      return $self->ua->request($request);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Downloads - Github v3 Repo Downloads API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Creating a new download is a two step process. You must first
  create a new download resource using this call here. After
  that you take the return L<Pithub::Result> object and call
  L</upload> to upload the file to Amazon S3.
  
      POST /repos/:user/:repo/downloads
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              name         => 'new_file.jpg',
              size         => 114034,
              description  => 'Latest release',
              content_type => 'text/plain',
          },
      );
  
      $d->upload(
          result => $result,
          file   => '/path/to/file',
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a download
  
      DELETE /repos/:user/:repo/downloads/:id
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->delete(
          user        => 'plu',
          repo        => 'Pithub',
          download_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single download
  
      GET /repos/:user/:repo/downloads/:id
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->get(
          user        => 'plu',
          repo        => 'Pithub',
          download_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List downloads for a repository
  
      GET /repos/:user/:repo/downloads
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 upload
  
  =over
  
  =item *
  
  Upload a file to Amazon S3. See also: L</create>. This will use
  the C<< ua >> attribute's C<< request >> method to do a POST
  request to Amazon S3. It requires the L<Pithub::Result> object
  of a L</create> call to get the necessary data for S3 API call.
  This method returns an L<HTTP::Response> object directly, not
  a L<Pithub::Result> object (like all other methods do)! If the
  upload was successful the status will be C<< 201 >>.
  
  =back
  
  =head1 NOTE
  
  Github says: The Downloads API (described below) was deprecated on
  December 11, 2012. It will be removed at a future date. We recommend
  using L<Pithub::Repos::Releases> instead.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_DOWNLOADS

$fatpacked{"Pithub/Repos/Forks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_FORKS';
  package Pithub::Repos::Forks;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Forks API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $org = delete $args{org} ) {
          return $self->request(
              method => 'POST',
              path   => sprintf( '/repos/%s/%s/forks', delete $args{user}, delete $args{repo} ),
              data => { organization => $org },
              %args,
          );
      }
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/forks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/forks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Forks - Github v3 Repo Forks API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a fork for the authenicated user.
  
      POST /repos/:user/:repo/forks
  
  Examples:
  
      my $f = Pithub::Repos::Forks->new;
      my $result = $f->create(
          user => 'plu',
          repo => 'Pithub',
      );
  
      # or fork to an org
      my $result = $f->create(
          user => 'plu',
          repo => 'Pithub',
          org  => 'CPAN-API',
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List forks
  
      GET /repos/:user/:repo/forks
  
  Examples:
  
      my $f = Pithub::Repos::Forks->new;
      my $result = $f->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_FORKS

$fatpacked{"Pithub/Repos/Hooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_HOOKS';
  package Pithub::Repos::Hooks;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Hooks API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/hooks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/hooks/%d', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/hooks/%d', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/hooks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub test {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/hooks/%d/test', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/hooks/%d', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Hooks - Github v3 Repo Hooks API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a hook
  
      POST /repos/:user/:repo/hooks
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              name   => 'irc',
              active => 1,
              config => {
                  server => 'irc.perl.org',
                  port   => 6667,
                  room   => 'pithub',
              },
          },
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a hook
  
      DELETE /repos/:user/:repo/hooks/:id
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->delete(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get single hook
  
      GET /repos/:user/:repo/hooks/:id
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->get(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List Hooks
  
      GET /repos/:user/:repo/hooks
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->tags( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 test
  
  =over
  
  =item *
  
  Get single hook
  
      POST /repos/:user/:repo/hooks/:id/test
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->test(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update/edit a hook
  
      PATCH /repos/:user/:repo/hooks/:id
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->update(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
          data    => {
              name   => 'irc',
              active => 1,
              config => {
                  server => 'irc.freenode.net',
                  port   => 6667,
                  room   => 'pithub',
              },
          },
      );
  
  =back
  
  =head1 EVENTS
  
  Active hooks can be configured to trigger for one or more events.
  The default event is push. The available events are:
  
  =over
  
  =item *
  
  commit_comment - Any time a Commit is commented on.
  
  =item *
  
  download - Any time a Download is added to the Repository.
  
  =item *
  
  fork - Any time a Repository is forked.
  
  =item *
  
  fork_apply - Any time a patch is applied to the Repository from
  the Fork Queue.
  
  =item *
  
  gollum - Any time a Wiki page is updated.
  
  =item *
  
  issues - Any time an Issue is opened or closed.
  
  =item *
  
  issue_comment - Any time an Issue is commented on.
  
  =item *
  
  member - Any time a User is added as a collaborator to a
  non-Organization Repository.
  
  =item *
  
  public - Any time a Repository changes from private to public.
  
  =item *
  
  pull_request - Any time a Pull Request is opend, closed, or
  synchronized (updated due to a new push in the branch that
  the pull request is tracking).
  
  =item *
  
  push - Any git push to a Repository.
  
  =item *
  
  watch - Any time a User watches the Repository.
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_HOOKS

$fatpacked{"Pithub/Repos/Keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_KEYS';
  package Pithub::Repos::Keys;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Keys API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/keys', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/keys/%s', delete $args{user}, delete $args{repo}, delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/keys/%s', delete $args{user}, delete $args{repo}, delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/keys', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Keys - Github v3 Repo Keys API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create
  
      POST /repos/:user/:repo/keys
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              title => 'some key',
              key   => 'ssh-rsa AAA...',
          },
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete
  
      DELETE /repos/:user/:repo/keys/:id
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->delete(
          user   => 'plu',
          repo   => 'Pithub',
          key_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get
  
      GET /repos/:user/:repo/keys/:id
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->get(
          user   => 'plu',
          repo   => 'Pithub',
          key_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List
  
      GET /repos/:user/:repo/keys
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_KEYS

$fatpacked{"Pithub/Repos/Releases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_RELEASES';
  package Pithub::Repos::Releases;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Releases API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Repos::Releases::Assets;
  extends 'Pithub::Base';
  
  
  sub assets {
      return shift->_create_instance('Pithub::Repos::Releases::Assets', @_);
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases/%d', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/releases', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/releases/%d', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/releases/%d', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Releases - Github v3 Repo Releases API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 assets
  
  Provides access to L<Pithub::Repos::Releases::Assets>.
  
  =head2 list
  
  =over
  
  =item *
  
  List releases for a repository.
  
      GET /repos/:owner/:repo/releases
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->get(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single release.
  
      GET /repos/:owner/:repo/releases/:id
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->get(
          repo       => 'Pithub',
          user       => 'plu',
          release_id => 1,
      );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a release.
  
      POST /repos/:user/:repo/releases
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              tag_name         => 'v1.0.0',
              target_commitish => 'master',
              name             => 'v1.0.0',
              body             => 'Description of the release',
              draft            => 0,
              prerelease       => 0,
          }
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a release.
  
      PATCH /repos/:user/:repo/releases/:id
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->update(
          user       => 'plu',
          repo       => 'Pithub',
          release_id => 1,
          data       => {
              tag_name         => 'v1.0.0',
              target_commitish => 'master',
              name             => 'v1.0.0',
              body             => 'Description of the release',
              draft            => 0,
              prerelease       => 0,
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a release.
  
      DELETE /repos/:user/:repo/releases:id
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->delete(
          user       => 'plu',
          repo       => 'Pithub',
          release_id => 1,
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_RELEASES

$fatpacked{"Pithub/Repos/Releases/Assets.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_RELEASES_ASSETS';
  package Pithub::Repos::Releases::Assets;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Releases Assets API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: name' unless $args{name};
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      croak 'Missing key in parameters: data' unless $args{data};
      croak 'Missing key in parameters: content_type' unless $args{content_type};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method  => 'POST',
          path    => sprintf( '/repos/%s/%s/releases/%s/assets', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          host    => 'uploads.github.com',
          query   => { name => delete $args{name} },
          headers => {
              'Content-Type' => delete $args{content_type},
          },
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: asset_id' unless $args{asset_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/releases/assets/%s', delete $args{user}, delete $args{repo}, delete $args{asset_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: asset_id' unless $args{asset_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases/assets/%s', delete $args{user}, delete $args{repo}, delete $args{asset_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases/%s/assets', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: asset_id' unless $args{asset_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method  => 'PATCH',
          path    => sprintf( '/repos/%s/%s/releases/assets/%s', delete $args{user}, delete $args{repo}, delete $args{asset_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Releases::Assets - Github v3 Repo Releases Assets API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Upload a release asset.
  
      POST https://uploads.github.com/repos/:owner/:repo/releases/:id/assets?name=foo.zip
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->create(
          repo         => 'graylog2-server',
          user         => 'Graylog2',
          release_id   => 81148,
          name         => 'Some Asset',
          data         => 'the asset data',
          content_type => 'text/plain',
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a release asset.
  
      DELETE /repos/:owner/:repo/releases/assets/:id
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->delete(
          repo     => 'graylog2-server',
          user     => 'Graylog2',
          asset_id => 81148,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single release asset.
  
      GET /repos/:owner/:repo/releases/assets/:id
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->get(
          repo     => 'graylog2-server',
          user     => 'Graylog2',
          asset_id => 81148,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List assets for a release.
  
      GET /repos/:owner/:repo/releases/:id/assets
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->list(
          repo       => 'graylog2-server',
          user       => 'Graylog2',
          release_id => 198110,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a release asset.
  
      PATCH /repos/:owner/:repo/releases/assets/:id
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->update(
          repo     => 'graylog2-server',
          user     => 'Graylog2',
          asset_id => 81148,
          data     => {
              name  => 'Some Name',
              label => 'Some Label',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_RELEASES_ASSETS

$fatpacked{"Pithub/Repos/Starring.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_STARRING';
  package Pithub::Repos::Starring;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Starring API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub has_starred {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/starred/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/stargazers', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list_repos {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/starred', $user ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/starred',
          %args,
      );
  }
  
  
  sub star {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/user/starred/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub unstar {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/starred/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Starring - Github v3 Repo Starring API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 has_starred
  
  =over
  
  =item *
  
  Check if you are starring a repository.
  
  Requires for the user to be authenticated.
  
      GET /user/starred/:user/:repo
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->has_starred(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all stargazers of a repository
  
      GET /repos/:user/:repo/stargazers
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 list_repos
  
  =over
  
  =item *
  
  List repositories being starred by a user.
  
      GET /users/:user/starred
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->list_repos(
          user => 'plu',
      );
  
  =item *
  
  List repos being starred by the authenticated user
  
      GET /user/starred
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->list_repos;
  
  =back
  
  =head2 star
  
  =over
  
  =item *
  
  Star a repository.
  
  Requires for the user to be authenticated.
  
      PUT /user/starred/:user/:repo
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->star(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 unstar
  
  =over
  
  =item *
  
  Unstar a repository.
  
  Requires for the user to be authenticated.
  
      DELETE /user/starred/:user/:repo
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->unstar(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_STARRING

$fatpacked{"Pithub/Repos/Stats.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_STATS';
  package Pithub::Repos::Stats;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 repos / stats API
  
  use Moo;
  
  extends 'Pithub::Base';
  
  
  sub contributors {
      my ( $self, %args ) = @_;
      # The default is to not wait for 200
      my $sleep = delete $args{wait_for_200} || 0;
      $self->_validate_user_repo_args( \%args );
      my $req = {
          method => 'GET',
          path => sprintf(
              '/repos/%s/%s/stats/contributors',
              delete $args{user}, delete $args{repo}
          ),
          %args
      };
      my $res = $self->request(
          %$req
      );
  
      if ($sleep) {
          while ($res->response->code == 202) {
              sleep $sleep;
              $res = $self->request(%$req);
          }
      }
      return $res;
  }
  
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Stats - Github v3 repos / stats API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 contributors
  
  Extra arguments
  
  =over
  
  =item * wait_for_200
  
  If this is set, and we receive the 202 status from github, we will sleep for
  this many seconds before trying the request again. We will keep trying until we
  get anything else than 202 status
  
  =back
  
  List contributors with stats
  
      GET /repos/:user/:repo/stats/contributors
  
  Examples:
  
      my $repos  = Pithub::Repos::Stats->new;
      my $result = $repos->contributors( user => 'plu', repo => 'Pithub' );
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_STATS

$fatpacked{"Pithub/Repos/Statuses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_STATUSES';
  package Pithub::Repos::Statuses;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT:  Github v3 repos / statuses API
  
  use Moo;
  use Carp qw(croak);
  
  extends 'Pithub::Base';
  
  
  sub list {
      my ($self, %args) = @_;
  
      $self->_validate_user_repo_args( \%args );
      my $req = {
          method => 'GET',
          path => sprintf(
              '/repos/%s/%s/statuses/%s',
              delete $args{user}, delete $args{repo}, delete $args{ref}
          ),
          %args
      };
      return $self->request(%$req);
  }
  
  
  sub create {
      my ($self, %args) = @_;
      $self->_validate_user_repo_args( \%args );
      croak 'Missing state paramenter. Must be one of pending, success, error or failure'
          unless $args{data}->{state};
  
      unless ($args{data}->{state} =~ m/^(?:pending|success|error|failure)$/) {
          croak 'state param must be one of pending, success, error, failure. Was ' .
          $args{data}->{state};
      }
  
      my $req = {
          method => 'POST',
          path => sprintf(
              '/repos/%s/%s/statuses/%s',
              delete $args{user}, delete $args{repo}, delete $args{sha},
          ),
          %args
      };
  
      return $self->request(%$req);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Statuses - Github v3 repos / statuses API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 list
  
  Extra arguments
  
  =over
  
  =item * ref
  
  The SHA, branch, or tag-name to get statuses for
  
  =back
  
  List statuses for a ref
  
      GET /repos/:user/:repo/statuses/:ref
  
  Examples:
  
      my $statuses = Pithub::Repos::Statuses->new;
      my $result   = $statuses->list( ref => 'master' );
  
  =head2 create
  
  Extra arguments
  
  =over
  
  =item state (required)
  
  The state of the status. Can be one of 'pending', 'success', 'error' or 'failure'.
  
  =item target_url
  
  This URL will be used to link from the status to some related page, for instance
  the build result for this specific SHA.
  
  =item description
  
  A short description of the status
  
  =back
  
  Add a status to a SHA.
  
      POST /repos/:user/:repo/statuses/:sha
  
  Examples:
  
      my $statuses = Pithub::Repos::Statuses->new;
      my $result   = $statuses->create( user => 'plu', repo => 'Pithub',
          sha => '0123456', 
          data => {
              state => 'error',
              description => 'Build failed',
              target_url => 'https://travis-ci.org/some/url/0123456',
          },
      );
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_STATUSES

$fatpacked{"Pithub/Repos/Watching.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_WATCHING';
  package Pithub::Repos::Watching;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Repo Watching API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub is_watching {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/watched/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list_repos {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/watched', $user ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/watched',
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/watchers', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub start_watching {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/user/watched/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub stop_watching {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/watched/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Watching - Github v3 Repo Watching API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 is_watching
  
  =over
  
  =item *
  
  Check if you are watching a repo
  
      GET /user/watched/:user/:repo
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->is_watching(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 list_repos
  
  =over
  
  =item *
  
  List repos being watched by a user
  
      GET /users/:user/watched
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->list_repos( user => 'plu' );
  
  =item *
  
  List repos being watched by the authenticated user
  
      GET /user/watched
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->list_repos;
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List watchers
  
      GET /repos/:user/:repo/watchers
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 start_watching
  
  =over
  
  =item *
  
  Watch a repo
  
      PUT /user/watched/:user/:repo
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->start_watching(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 stop_watching
  
  =over
  
  =item *
  
  Stop watching a repo
  
      DELETE /user/watched/:user/:repo
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->stop_watching(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_WATCHING

$fatpacked{"Pithub/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_RESULT';
  package Pithub::Result;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 result object
  
  use Moo;
  use Array::Iterator;
  use JSON::MaybeXS;
  use URI;
  use Carp;
  
  sub _isa_isa_maker {
      my $class = shift;
      return sub {
          confess "must be an instance of $class but isn't a reference" if !ref $_[0];
          confess "must be an instance of $class, but is a ".ref $_[0]
            unless eval { $_[0]->isa($class) };
      };
  }
  
  
  has 'auto_pagination' => (
      default => sub { 0 },
      is      => 'rw',
  );
  
  
  has 'content' => (
      builder => '_build_content',
      clearer => 'clear_content',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'first_page_uri' => (
      builder => '_build_first_page_uri',
      clearer => 'clear_first_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'last_page_uri' => (
      builder => '_build_last_page_uri',
      clearer => 'clear_last_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'next_page_uri' => (
      builder => '_build_next_page_uri',
      clearer => 'clear_next_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'prev_page_uri' => (
      builder => '_build_prev_page_uri',
      clearer => 'clear_prev_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'response' => (
      handles => {
          code        => 'code',
          raw_content => 'content',
          request     => 'request',
          success     => 'is_success',
      },
      is       => 'ro',
      isa      => _isa_isa_maker('HTTP::Response'),
      required => 1,
  );
  
  
  # required for next_page etc
  has '_request' => (
      is       => 'ro',
      isa      => sub {
          croak 'must be a coderef, but is ' . ref $_[0] unless ref $_[0] eq 'CODE'
      },
      required => 1,
  );
  
  # required for next
  has '_iterator' => (
      builder => '_build__iterator',
      clearer => '_clear_iterator',
      is      => 'ro',
      isa     => _isa_isa_maker('Array::Iterator'),
      lazy    => 1,
  );
  
  
  has 'utf8' => (
      is      => 'ro',
      default => 1,
  );
  
  has '_json' => (
      builder => '_build__json',
      is      => 'ro',
      isa     => sub {
          confess "$_[0] is not a suitable JSON object"
            unless eval { $_[0]->can("decode") };
      },
      lazy    => 1,
  );
  
  
  sub count {
      my ($self) = @_;
      return 0 unless $self->success;
      my $content = $self->content;
      if ( ref $content eq 'HASH' && scalar keys %$content == 0 ) {
          return 0;
      }
      return $self->_iterator->getLength;
  }
  
  
  sub first {
      my ($self) = @_;
      my $content = $self->content;
      if ( ref $content eq 'ARRAY' ) {
          return $content->[0];
      }
      return $content;
  }
  
  
  sub first_page {
      my ($self) = @_;
      return unless $self->first_page_uri;
      return $self->_paginate( $self->first_page_uri );
  }
  
  
  sub get_page {
      my ( $self, $page ) = @_;
  
      # First we need to get an URI we can work with and replace
      # the page GET parameter properly with the given value. If
      # we cannot get the first or last page URI, then there is
      # only one page.
      my $uri_str = $self->first_page_uri || $self->last_page_uri;
      return unless $uri_str;
  
      my $uri   = URI->new($uri_str);
      my %query = $uri->query_form;
  
      $query{page} = $page;
  
      my $options = {
          prepare_request => sub {
              my ($request) = @_;
              %query = ( $request->uri->query_form, %query );
              $request->uri->query_form(%query);
          },
      };
  
      return $self->_request->(
          method  => 'GET',
          path    => $uri->path,
          options => $options,
      );
  }
  
  
  sub last_page {
      my ($self) = @_;
      return unless $self->last_page_uri;
      return $self->_paginate( $self->last_page_uri );
  }
  
  
  sub next {
      my ($self) = @_;
      my $row = $self->_iterator->getNext;
      return $row if $row;
      if ( $self->auto_pagination ) {
          my $result = $self->next_page;
          return unless $result;
          $self->_reset;
          $self->{response} = $result->response;
          return $self->_iterator->getNext;
      }
      return;
  }
  
  
  sub next_page {
      my ($self) = @_;
      return unless $self->next_page_uri;
      return $self->_paginate( $self->next_page_uri );
  }
  
  
  sub prev_page {
      my ($self) = @_;
      return unless $self->prev_page_uri;
      return $self->_paginate( $self->prev_page_uri );
  }
  
  
  sub etag {
      my ($self) = @_;
      return $self->response->header('ETag');
  }
  
  
  sub ratelimit {
      my ($self) = @_;
      return $self->response->header('X-RateLimit-Limit');
  }
  
  
  sub ratelimit_remaining {
      my ($self) = @_;
      return $self->response->header('X-RateLimit-Remaining');
  }
  
  sub _build_content {
      my ($self) = @_;
      if ( $self->raw_content ) {
          return $self->_json->decode( $self->raw_content );
      }
      return {};
  }
  
  sub _build_first_page_uri {
      return shift->_get_link_header('first');
  }
  
  sub _build__iterator {
      my ($self) = @_;
      my $content = $self->content;
      $content = [$content] unless ref $content eq 'ARRAY';
      return Array::Iterator->new($content);
  }
  
  sub _build_last_page_uri {
      return shift->_get_link_header('last');
  }
  
  sub _build_next_page_uri {
      return shift->_get_link_header('next');
  }
  
  sub _build_prev_page_uri {
      return shift->_get_link_header('prev');
  }
  
  sub _build__json {
      my ($self) = @_;
      return JSON->new->utf8($self->utf8);
  }
  
  sub _get_link_header {
      my ( $self, $type ) = @_;
      return $self->{_get_link_header}{$type} if $self->{_get_link_header}{$type};
      my $link = $self->response->header('Link');
      return unless $link;
      return unless $link =~ /(next|first|last|prev)/;
      foreach my $item ( split /,/, $link ) {
          my @result = $item =~ /<([^>]+)>; rel="([^"]+)"/g;
          next if !$result[1] || !$result[0];
          $self->{_get_link_header}{ $result[1] } = $result[0];
      }
      return $self->{_get_link_header}{$type};
  }
  
  sub _paginate {
      my ( $self, $uri_str ) = @_;
      my $uri     = URI->new($uri_str);
      my $options = {
          prepare_request => sub {
              my ($request) = @_;
              my %query = ( $request->uri->query_form, $uri->query_form );
              $request->uri->query_form(%query);
          },
      };
      return $self->_request->(
          method  => 'GET',
          path    => $uri->path,
          options => $options,
      );
  }
  
  sub _reset {
      my ($self) = @_;
      $self->clear_content;
      $self->clear_first_page_uri;
      $self->clear_last_page_uri;
      $self->clear_next_page_uri;
      $self->clear_prev_page_uri;
      $self->_clear_iterator;
      delete $self->{_get_link_header};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Result - Github v3 result object
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 DESCRIPTION
  
  Every method call which maps directly to a Github API call returns a
  L<Pithub::Result> object. Once you got the result object, you can
  set L<attributes|/ATTRIBUTES> on them or call L<methods|/METHODS>.
  
  =head1 ATTRIBUTES
  
  =head2 auto_pagination
  
  If you set this to true and use the L</next> method to iterate
  over the result rows, it will call automatically L</next_page>
  for you until you got all the results. Be careful using this
  feature, if there are 100 pages, this will make 100 API calls.
  By default it's off. Instead of setting it per L<Pithub::Result>
  you can also set it directly on any of the L<Pithub> API objects.
  
  Examples:
  
      my $r = Pithub::Repos->new;
      my $result = $r->list( user => 'rjbs' );
  
      # This would just show the first 30 by default
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
      # Let's do the same thing using auto_pagination to fetch all
      $result = $r->list( user => 'rjbs' );
      $result->auto_pagination(1);
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
      # Turn auto_pagination on for all L<Pithub::Result> objects
      my $p = Pithub::Repos->new( auto_pagination => 1 );
      my $result = $p->list( user => 'rjbs' );
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
  =head2 content
  
  The decoded JSON response. May be an arrayref or hashref, depending
  on the API call. For some calls there is no content at all.
  
  =head2 first_page_uri
  
  The extracted value from the C<< Link >> header for the first page.
  This can return undef.
  
  =head2 last_page_uri
  
  The extracted value from the C<< Link >> header for the last page.
  This can return undef.
  
  =head2 next_page_uri
  
  The extracted value from the C<< Link >> header for the next page.
  This can return undef.
  
  =head2 prev_page_uri
  
  The extracted value from the C<< Link >> header for the previous
  page. This can return undef.
  
  =head2 response
  
  The L<HTTP::Response> object.
  
  =head2 utf8
  
  This can set utf8 flag.
  
  =head1 METHODS
  
  =head2 raw_content
  
  Returns the content of the API response as a string, it will probably
  be JSON.
  
  =head2 request
  
  Returns the L<HTTP::Request> object used to make the API call.
  
  =head2 code
  
  Returns the HTTP code from the API call.
  
  =head2 success
  
  Returns whether the API call was successful.
  
  =head2 count
  
  Returns the count of the elements in L</content>. If the result is
  not an arrayref but a hashref, it will still return C<< 1 >>. Some
  calls return an empty hashref, for those calls it returns C<< 0 >>.
  
  =head2 first
  
  Return the first element from L</content> if L</content> is an
  arrayref. If it's a hashref, it returns just that.
  
  =head2 first_page
  
  Get the L<Pithub::Result> of the first page. Returns undef if there
  is no first page (if you're on the first page already or if there
  is no pages at all).
  
  =head2 get_page
  
  Get the L<Pithub::Result> for a specific page. The parameter is not
  validated, if you hit a page that does not exist, the Github API will
  tell you so. If there is only one page, this method will return
  undef, no matter which page you ask for, even for page 1.
  
  =head2 last_page
  
  Get the L<Pithub::Result> of the last page. Returns undef if there
  is no last page (if you're on the last page already or if there
  is only one page or no pages at all).
  
  =head2 next
  
  Most of the results returned by the Github API calls are arrayrefs
  of hashrefs. The data structures can be retrieved directly by
  calling L</content>. Besides that it's possible to iterate over
  the results using this method.
  
  Examples:
  
      my $r = Pithub::Repos->new;
      my $result = $r->list( user => 'rjbs' );
  
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
  =head2 next_page
  
  Get the L<Pithub::Result> of the next page. Returns undef if there
  is no next page (there's only one page at all).
  
  Examples:
  
  =over
  
  =item *
  
  List all followers in order, from the first one on the first
  page to the last one on the last page. See also
  L</auto_pagination>.
  
      my $followers = Pithub->new->users->followers;
      my $result = $followers->list( user => 'rjbs' );
      do {
          if ( $result->success ) {
              while ( my $row = $result->next ) {
                  printf "%s\n", $row->{login};
              }
          }
      } while $result = $result->next_page;
  
  The nature of the implementation requires you here to do a
  C<< do { ... } while ... >> loop. If you're going to fetch
  all results of all pages, I suggest to use the
  L</auto_pagination> feature, it's much more convenient.
  
  =back
  
  =head2 prev_page
  
  Get the L<Pithub::Result> of the previous page. Returns undef if there
  is no previous page (you're on the first page).
  
  Examples:
  
  =over
  
  =item *
  
  List all followers in reverse order, from the last one on the last
  page to the first one on the first page. See also
  L</auto_pagination>.
  
      my $followers = Pithub->new->users->followers;
      my $result = $followers->list( user => 'rjbs' )->last_page;    # this makes two requests!
      do {
          if ( $result->success ) {
              while ( my $row = $result->next ) {
                  printf "%s\n", $row->{login};
              }
          }
      } while $result = $result->prev_page;
  
  =back
  
  =head2 etag
  
  Returns the value of the C<< ETag >> http header.
  
  =head2 ratelimit
  
  Returns the value of the C<< X-Ratelimit-Limit >> http header.
  
  =head2 ratelimit_remaining
  
  Returns the value of the C<< X-Ratelimit-Remaining >> http header.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_RESULT

$fatpacked{"Pithub/Result/SharedCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_RESULT_SHAREDCACHE';
  package Pithub::Result::SharedCache;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: A role to share the LRU cache with all Pithub objects
  
  use Moo::Role;
  use Cache::LRU;
  
  my $Shared_Cache = Cache::LRU->new(
      size        => 200
  );
  
  
  sub shared_cache {
      return $Shared_Cache;
  }
  
  
  sub set_shared_cache {
      my($self, $cache) = @_;
  
      $Shared_Cache = $cache;
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Result::SharedCache - A role to share the LRU cache with all Pithub objects
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 DESCRIPTION
  
  A role to share the least recently used cache with all Pithub objects.
  
  =head1 METHODS
  
  =head2 shared_cache
  
  Returns the Cache::LRU object shared by all Pithub objects.
  
  =head2 set_shared_cache
  
  Sets the Cache::LRU object shared by all Pithub objects.
  
  This should only be necessary for testing or to change the
  size of the cache.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_RESULT_SHAREDCACHE

$fatpacked{"Pithub/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_SEARCH';
  package Pithub::Search;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github legacy Search API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub email {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: email' unless $args{email};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/user/email/%s', delete $args{email} ),
          %args,
      );
  }
  
  
  sub issues {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      croak 'Missing key in parameters: state' unless $args{state};
      croak 'Missing key in parameters: keyword' unless $args{keyword};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/issues/search/%s/%s/%s/%s', delete $args{user}, delete $args{repo}, delete $args{state}, delete $args{keyword} ),
          %args,
      );
  }
  
  
  sub repos {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: keyword' unless $args{keyword};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/repos/search/%s', delete $args{keyword} ),
          %args,
      );
  }
  
  
  sub users {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: keyword' unless $args{keyword};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/user/search/%s', delete $args{keyword} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Search - Github legacy Search API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 email
  
  =over
  
  =item *
  
  This API call is added for compatibility reasons only. There's
  no guarantee that full email searches will always be available.
  
      GET /legacy/user/email/:email
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->email(
          email => 'plu@pqpq.de',
      );
  
  =back
  
  =head2 issues
  
  =over
  
  =item *
  
  Find issues by state and keyword.
  
      GET /legacy/issues/search/:owner/:repository/:state/:keyword
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->issues(
          user    => 'plu',
          repo    => 'Pithub',
          state   => 'open',
          keyword => 'some keyword',
      );
  
  =back
  
  =head2 repos
  
  =over
  
  =item *
  
  Find repositories by keyword. Note, this legacy method does not
  follow the v3 pagination pattern. This method returns up to 100
  results per page and pages can be fetched using the start_page
  parameter.
  
      GET /legacy/repos/search/:keyword
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->repos(
          keyword => 'github',
          params  => {
              language   => 'Perl',
              start_page => 0,
          }
      );
  
  =back
  
  =head2 users
  
  =over
  
  =item *
  
  Find users by keyword.
  
      GET /legacy/user/search/:keyword
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->users(
          keyword => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_SEARCH

$fatpacked{"Pithub/SearchV3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_SEARCHV3';
  package Pithub::SearchV3;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Search API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub issues {
      my $self = shift;
      return $self->_search('issues', @_);
  }
  
  
  sub repos {
      my $self = shift;
      return $self->_search('repositories', @_);
  }
  
  
  sub users {
      my $self = shift;
      return $self->_search('users', @_);
  }
  
  
  sub code {
      my $self = shift;
      return $self->_search('code', @_);
  }
  
  sub _search {
      my ( $self, $thing_to_search, %args ) = @_;
      croak 'Missing key in parameters: q' unless exists $args{q};
      return $self->request(
          method => 'GET',
          path   => '/search/' . $thing_to_search,
          query => {
              q => delete $args{q},
              (exists $args{sort}  ? (sort  => delete $args{sort})  : ()),
              (exists $args{order} ? (order => delete $args{order}) : ()),
          },
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::SearchV3 - Github v3 Search API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 issues
  
  =over
  
  =item *
  
  Find issues by state and keyword.
  
      GET /search/issues
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->issues(
          q => 'some keyword',
      );
  
  =back
  
  =head2 repos
  
  =over
  
  =item *
  
  Find repositories by keyword.
  
      GET /search/repositories
  
  Examples:
  
      my $search = Pithub::SearchV3->new;
      my $result = $search->repos(
          q => 'github language:Perl',
      );
  
  =back
  
  =head2 users
  
  =over
  
  =item *
  
  Find users by keyword.
  
      GET /search/users
  
  Examples:
  
      my $search = Pithub::SearchV3->new;
      my $result = $search->users(
          q => 'plu',
      );
  
  =back
  
  =head2 code
  
  =over
  
  =item *
  
  Search code by keyword.
  
      GET /search/code
  
  Examples:
  
      my $search = Pithub::SearchV3->new;
      my $result = $search->code(
          q => 'addClass repo:jquery/jquery',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_SEARCHV3

$fatpacked{"Pithub/Users.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS';
  package Pithub::Users;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 Users API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Users::Emails;
  use Pithub::Users::Followers;
  use Pithub::Users::Keys;
  extends 'Pithub::Base';
  
  
  sub emails {
      return shift->_create_instance('Pithub::Users::Emails', @_);
  }
  
  
  sub followers {
      return shift->_create_instance('Pithub::Users::Followers', @_);
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      if ( $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s', delete $args{user} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user',
          %args,
      );
  }
  
  
  sub keys {
      return shift->_create_instance('Pithub::Users::Keys', @_);
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => '/user',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users - Github v3 Users API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 emails
  
  Provides access to L<Pithub::Users::Emails>.
  
  =head2 followers
  
  Provides access to L<Pithub::Users::Followers>.
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single user
  
      GET /users/:user
  
  Examples:
  
      my $u = Pithub::Users->new;
      my $result = $u->get( user => 'plu');
  
  =item *
  
  Get the authenticated user
  
      GET /user
  
  Examples:
  
      my $u = Pithub::Users->new( token => 'b3c62c6' );
      my $result = $u->get;
  
  =back
  
  =head2 keys
  
  Provides access to L<Pithub::Users::Keys>.
  
  =head2 update
  
  =over
  
  =item *
  
  Update the authenticated user
  
      PATCH /user
  
  Examples:
  
      my $u = Pithub::Users->new( token => 'b3c62c6' );
      my $result = $u->update( data => { email => 'plu@cpan.org' } );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS

$fatpacked{"Pithub/Users/Emails.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS_EMAILS';
  package Pithub::Users::Emails;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 User Emails API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub add {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      return $self->request(
          method => 'POST',
          path   => '/user/emails',
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      return $self->request(
          method => 'DELETE',
          path   => '/user/emails',
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      return $self->request(
          method => 'GET',
          path   => '/user/emails',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users::Emails - Github v3 User Emails API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 add
  
  =over
  
  =item *
  
  Add email address(es)
  
      POST /user/emails
  
  Examples:
  
      my $e = Pithub::Users::Emails->new( token => 'b3c62c6' );
      my $result = $e->add( data => [ 'plu@cpan.org', 'plu@pqpq.de' ] );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete email address(es)
  
      DELETE /user/emails
  
  Examples:
  
      my $e = Pithub::Users::Emails->new( token => 'b3c62c6' );
      my $result = $e->delete( data => [ 'plu@cpan.org', 'plu@pqpq.de' ] );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List email addresses for a user
  
      GET /user/emails
  
  Examples:
  
      my $e = Pithub::Users::Emails->new( token => 'b3c62c6' );
      my $result = $e->list;
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS_EMAILS

$fatpacked{"Pithub/Users/Followers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS_FOLLOWERS';
  package Pithub::Users::Followers;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 User Followers API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub follow {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/user/following/%s', delete $args{user} ),
          %args,
      );
  }
  
  
  sub is_following {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/following/%s', delete $args{user} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/followers', delete $args{user} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/followers',
          %args,
      );
  }
  
  
  sub list_following {
      my ( $self, %args ) = @_;
      if ( $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/following', delete $args{user} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/following',
          %args,
      );
  }
  
  
  sub unfollow {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/following/%s', delete $args{user} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users::Followers - Github v3 User Followers API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 follow
  
  =over
  
  =item *
  
  Follow a user
  
      PUT /user/following/:user
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->follow( user => 'plu' );
  
  =back
  
  =head2 is_following
  
  =over
  
  =item *
  
  Check if the authenticated user is following another given user
  
      GET /user/following/:user
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->is_following( user => 'rafl' );
  
      if ( $result->is_success ) {
          print "plu is following rafl\n";
      }
      elsif ( $result->code == 404 ) {
          print "plu is not following rafl\n";
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List a user's followers:
  
      GET /users/:user/followers
  
  Examples:
  
      my $f = Pithub::Users::Followers->new;
      my $result = $f->list( user => 'plu' );
  
  =item *
  
  List the authenticated user's followers:
  
      GET /user/followers
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->list;
  
  =back
  
  =head2 list_following
  
  =over
  
  =item *
  
  List who a user is following:
  
      GET /users/:user/following
  
  Examples:
  
      my $f = Pithub::Users::Followers->new;
      my $result = $f->list_following( user => 'plu' );
  
  =item *
  
  List who the authenicated user is following:
  
      GET /user/following
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->list_following;
  
  =back
  
  =head2 unfollow
  
  =over
  
  =item *
  
  Unfollow a user
  
      DELETE /user/following/:user
  
  Examples:
  
      my $f = Pithub::Users::Followers->new;
      my $result = $f->unfollow( user => 'plu' );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS_FOLLOWERS

$fatpacked{"Pithub/Users/Keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS_KEYS';
  package Pithub::Users::Keys;
  our $AUTHORITY = 'cpan:PLU';
  our $VERSION = '0.01034';
  # ABSTRACT: Github v3 User Keys API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => '/user/keys',
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/keys/%s', delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/keys/%s', delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      return $self->request(
          method => 'GET',
          path   => '/user/keys',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users::Keys - Github v3 User Keys API
  
  =head1 VERSION
  
  version 0.01034
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a public key
  
      POST /user/keys
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->create(
          data => {
              title => 'plu@localhost',
              key   => 'ssh-rsa AAA...',
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a public key
  
      DELETE /user/keys/:id
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->delete( key_id => 123 );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single public key
  
      GET /user/keys/:id
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->get( key_id => 123 );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List public keys for a user
  
      GET /user/keys
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->list;
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS_KEYS

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION =~ tr/_//d;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_WORK_AROUND_HINT_LEAKAGE
      = "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
        ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub croak {
    require Carp;
    no warnings 'redefine';
    *croak = \&Carp::croak;
    goto &Carp::croak;
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    my ($module) = @_;
    (my $file = "$module.pm") =~ s{::}{/}g;
    return 1
      if $INC{$file};
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1
      if grep !/::\z/, keys %{_getstash($module)};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $file ], 'Role::Tiny::__GUARD__');
    local %^H if _WORK_AROUND_HINT_LEAKAGE;
    require $file;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    $me->_install_subs($target);
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = map +(ref $_ eq 'CODE' ? $_ : ref $_ ? () : *$_{CODE}||()), values %$stash;
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    foreach my $hook (@ON_ROLE_CREATE) {
      $hook->($target);
    }
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    return if $me->is_role($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    croak "This is apply_role_to_package" if ref($to);
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    croak "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    croak "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      if (my @dupes = grep 1 == $seen{$_}++, @roles) {
        croak "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join("' and '", sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      croak $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      croak $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || ref($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    my $info = $INFO{$to};
    my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
    my @modifiers = grep {
      my $modifier = $_;
      !grep $_ == $modifier, @$existing;
    } @{$modifiers||[]};
    push @$existing, @modifiers;
  
    if (!$info) {
      foreach my $modifier (@modifiers) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval {
        require Class::Method::Modifiers;
        Class::Method::Modifiers->VERSION(1.05);
        1;
      } ? 0 : $@;
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... };
  
   1;
  
  elsewhere
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role. A method inherited by a class gets overridden by the role's
  method of the same name, though.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly. Object is reblessed into the
  resulting class. Note that the object's methods get overridden by the role's
  ones with the same names.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to other copies of the object.
  
  =item * On perl 5.16 and earlier, applying a role to a class won't apply any
  overloads from the role to any existing instances of the class.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  use strict;
  use warnings;
  use Exporter qw(import);
  use Scalar::Util qw(weaken);
  use Carp qw(croak);
  
  our $VERSION = '2.005001';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  our @EXPORT_OK = qw(undefer_package defer_info);
  
  our %DEFERRED;
  
  sub _getglob { no strict 'refs'; \*{$_[0]} }
  
  BEGIN {
    my $no_subname;
    *_subname
      = defined &Sub::Util::set_subname ? \&Sub::Util::set_subname
      : defined &Sub::Name::subname     ? \&Sub::Name::subname
      : (eval { require Sub::Util } && defined &Sub::Util::set_subname) ? \&Sub::Util::set_subname
      : (eval { require Sub::Name } && defined &Sub::Name::subname    ) ? \&Sub::Name::subname
      : ($no_subname = 1, sub { $_[1] });
    *_CAN_SUBNAME = $no_subname ? sub(){0} : sub(){1};
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    _CAN_SUBNAME ? _subname(@_) : $_[1];
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub undefer_sub {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred} or return $deferred;
    my ($target, $maker, $options, $undeferred_ref, $deferred_sub) = @$info;
  
    if (!(
      $deferred_sub && $deferred eq $deferred_sub
      || ${$undeferred_ref} && $deferred eq ${$undeferred_ref}
    )) {
      return $deferred;
    }
  
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    my $undefer_info = [ $target, $maker, $options, \$$undeferred_ref ];
    $info->[5] = $DEFERRED{$made} = $undefer_info;
    weaken ${$undefer_info->[3]};
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub undefer_package {
    my $package = shift;
    undefer_sub($_)
      for grep {
        my $name = $DEFERRED{$_} && $DEFERRED{$_}[0];
        $name && $name =~ /^${package}::[^:]+$/
      } keys %DEFERRED;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred||''} or return undef;
  
    my ($target, $maker, $options, $undeferred_ref, $deferred_sub) = @$info;
    if (!(
      $deferred_sub && $deferred eq $deferred_sub
      || ${$undeferred_ref} && $deferred eq ${$undeferred_ref}
    )) {
      delete $DEFERRED{$deferred};
      return undef;
    }
    [
      $target, $maker, $options,
      ( $undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),
    ];
  }
  
  sub defer_sub {
    my ($target, $maker, $options) = @_;
    my $package;
    my $subname;
    ($package, $subname) = $target =~ /^(.*)::([^:]+)$/
      or croak "$target is not a fully qualified sub name!"
      if $target;
    $package ||= $options && $options->{package} || caller;
    my @attributes = @{$options && $options->{attributes} || []};
    if (@attributes) {
      /\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
        for @attributes;
    }
    my $deferred;
    my $undeferred;
    my $deferred_info = [ $target, $maker, $options, \$undeferred ];
    if (@attributes || $target && !_CAN_SUBNAME) {
      my $code
        =  q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n]
        . qq[package $package;\n]
        . ($target ? "sub $subname" : '+sub') . join('', map " :$_", @attributes)
        . q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[4]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n"
        . ($target ? "\\&$subname" : '');
      my $e;
      $deferred = do {
        no warnings qw(redefine closure);
        local $@;
        eval $code or $e = $@; # uncoverable branch true
      };
      die $e if defined $e; # uncoverable branch true
    }
    else {
      # duplicated from above
      $deferred = sub {
        $undeferred ||= undefer_sub($deferred_info->[4]);
        goto &$undeferred;
      };
      _install_coderef($target, $deferred)
        if $target;
    }
    weaken($deferred_info->[4] = $deferred);
    weaken($DEFERRED{$deferred} = $deferred_info);
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map {
      defined $_ ? (
          $_->[4] ? ($_->[4] => $_)
        : ($_->[3] && ${$_->[3]}) ? (${$_->[3]} => $_)
        : ()
      ) : ()
    } values %DEFERRED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - Defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... }, \%options;
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  Exported by default.
  
  =head3 Options
  
  A hashref of options can optionally be specified.
  
  =over 4
  
  =item package
  
  The package to generate the sub in.  Will be overridden by a fully qualified
  C<$name> option.  If not specified, will default to the caller's package.
  
  =item attributes
  
  The L<perlsub/Subroutine Attributes> to apply to the sub generated.  Should be
  specified as an array reference.
  
  =back
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  Exported by default.
  
  =head2 defer_info
  
   my $data = defer_info $sub;
   my ($name, $generator, $options, $undeferred_sub) = @$data;
  
  Returns original arguments to defer_sub, plus the undeferred version if this
  sub has already been undeferred.
  
  Note that $sub can be either the original deferred version or the undeferred
  version for convenience.
  
  Not exported by default.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all deferred subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.  Note this may bake the behavior of some subs that were intended to
  calculate their behavior later, so it shouldn't be used midway through a
  module load or class definition.
  
  Exported by default.
  
  =head2 undefer_package
  
    undefer_package($package);
  
  This undefers all deferred subs in a package.
  
  Not exported by default.
  
  =head1 SUPPORT
  
  See L<Sub::Quote> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Sub::Quote> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Sub::Quote> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  $Sub::Exporter::Progressive::VERSION = '0.001013';
  use strict;
  use warnings;
  
  # ABSTRACT: Only use Sub::Exporter if you need it
  
  sub _croak {
    require Carp;
    &Carp::croak;
  }
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     no warnings 'once';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if ( grep {
           length ref $_
              or
           $_ !~ / \A [:-]? \w+ \z /xm
        } @args ) {
           _croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif ( defined( (my ($num) = grep { m/^\d/ } @args)[0] ) ) {
           _croak "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ( ($setup||'') eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              _croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              _croak $too_complicated if grep { length ref $_ } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 _croak $too_complicated if grep {
                    length ref $_
                       or
                    $_ =~ / \A - (?! all \b ) /x
                 } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              _croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        _croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 VERSION
  
  version 0.001013
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 AUTHOR
  
  Arthur Axel "fREW" Schmidt <Sub-Exporter-Progressive@afoolishmanifesto.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Arthur Axel "fREW" Schmidt.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  sub _clean_eval { eval $_[0] }
  
  use strict;
  use warnings;
  
  use Sub::Defer qw(defer_sub);
  use Scalar::Util qw(weaken);
  use Exporter qw(import);
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Sub::Defer) }
  use B ();
  BEGIN {
    *_HAVE_IS_UTF8 = defined &utf8::is_utf8 ? sub(){1} : sub(){0};
    *_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.005001';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
  our @EXPORT_OK = qw(quotify capture_unroll inlinify sanitize_identifier);
  
  our %QUOTED;
  
  sub quotify {
    my $value = $_[0];
    no warnings 'numeric';
    ! defined $value     ? 'undef()'
    # numeric detection
    : (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))
      && length( (my $dummy = '') & $value )
      && 0 + $value eq $value
      && $value * 0 == 0
    ) ? $value
    : _HAVE_PERLSTRING  ? B::perlstring($value)
    : qq["\Q$value\E"];
  }
  
  sub sanitize_identifier {
    my $name = shift;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or croak "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms) {
      my ($pre, $indent, $code_args) = ($1, $2, $3);
      $do .= $pre;
      if ($code_args ne $args) {
        $do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    if ($name) {
      my $subname = $name;
      my $package = $subname =~ s/(.*)::// ? $1 : caller;
      $name = join '::', $package, $subname;
      croak qq{package name "$package" too long!}
        if length $package > 252;
      croak qq{package name "$package" is not valid!}
        unless $package =~ /^[^\d\W]\w*(?:::\w+)*$/;
      croak qq{sub name "$subname" too long!}
        if length $subname > 252;
      croak qq{sub name "$subname" is not valid!}
        unless $subname =~ /^[^\d\W]\w*$/;
    }
    my @caller = caller(0);
    my ($attributes, $file, $line) = @{$options}{qw(attributes file line)};
    if ($attributes) {
      /\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
        for @$attributes;
    }
    my $quoted_info = {
      name     => $name,
      code     => $code,
      captures => $captures,
      package      => (exists $options->{package}      ? $options->{package}      : $caller[0]),
      hints        => (exists $options->{hints}        ? $options->{hints}        : $caller[8]),
      warning_bits => (exists $options->{warning_bits} ? $options->{warning_bits} : $caller[9]),
      hintshash    => (exists $options->{hintshash}    ? $options->{hintshash}    : $caller[10]),
      ($attributes ? (attributes => $attributes) : ()),
      ($file       ? (file => $file) : ()),
      ($line       ? (line => $line) : ()),
    };
    my $unquoted;
    weaken($quoted_info->{unquoted} = \$unquoted);
    if ($options->{no_defer}) {
      my $fake = \my $var;
      local $QUOTED{$fake} = $quoted_info;
      my $sub = unquote_sub($fake);
      Sub::Defer::_install_coderef($name, $sub) if $name && !$options->{no_install};
      return $sub;
    }
    else {
      my $deferred = defer_sub(
        ($options->{no_install} ? undef : $name),
        sub {
          $unquoted if 0;
          unquote_sub($quoted_info->{deferred});
        },
        {
          ($attributes ? ( attributes => $attributes ) : ()),
          ($name ? () : ( package => $quoted_info->{package} )),
        },
      );
      weaken($quoted_info->{deferred} = $deferred);
      weaken($QUOTED{$deferred} = $quoted_info);
      return $deferred;
    }
  }
  
  sub _context {
    my $info = shift;
    $info->{context} ||= do {
      my ($package, $hints, $warning_bits, $hintshash, $file, $line)
        = @{$info}{qw(package hints warning_bits hintshash file line)};
  
      $line ||= 1
        if $file;
  
      my $line_mark = '';
      if ($line) {
        $line_mark = "#line ".($line-1);
        if ($file) {
          $line_mark .= qq{ "$file"};
        }
        $line_mark .= "\n";
      }
  
      $info->{context}
        ="# BEGIN quote_sub PRELUDE\n"
        ."package $package;\n"
        ."BEGIN {\n"
        ."  \$^H = ".quotify($hints).";\n"
        ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n"
        ."  \%^H = (\n"
        . join('', map
        "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",
          keys %$hintshash)
        ."  );\n"
        ."}\n"
        .$line_mark
        ."# END quote_sub PRELUDE\n";
    };
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub||''} or return undef;
    my ($name, $code, $captures, $unquoted, $deferred)
      = @{$quoted_info}{qw(name code captures unquoted deferred)};
    $code = _context($quoted_info) . $code;
    $unquoted &&= $$unquoted;
    if (($deferred && $deferred eq $sub)
        || ($unquoted && $unquoted eq $sub)) {
      return [ $name, $code, $captures, $unquoted, $deferred ];
    }
    return undef;
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub} or return undef;
    my $unquoted = $quoted_info->{unquoted};
    unless ($unquoted && $$unquoted) {
      my ($name, $code, $captures, $package, $attributes)
        = @{$quoted_info}{qw(name code captures package attributes)};
  
      ($package, $name) = $name =~ /(.*)::(.*)/
        if $name;
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_UNQUOTED'} = \$unquoted;
      $captures{'$_QUOTED'} = \$quoted_info;
  
      my $make_sub
        = "{\n"
        . capture_unroll("\$_[1]", \%captures, 2)
        . "  package ${package};\n"
        . (
          $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
            ? "  no warnings 'closure';\n  sub ${name} "
            : "  \$\$_UNQUOTED = sub "
        )
        . ($attributes ? join('', map ":$_ ", @$attributes) : '') . "{\n"
        . "  (\$_QUOTED,\$_UNQUOTED) if 0;\n"
        . _context($quoted_info)
        . $code
        . "  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '') . ";\n"
        . "}\n"
        . "1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{"${package}::${name}"} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          my $space = length($make_sub =~ tr/\n//);
          my $line = 0;
          $make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;
          croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
        weaken($QUOTED{$$unquoted} = $quoted_info);
      }
    }
    $$unquoted;
  }
  
  sub qsub ($) {
    goto &quote_sub;
  }
  
  sub CLONE {
    my @quoted = map { defined $_ ? (
      $_->{unquoted} && ${$_->{unquoted}} ? (${ $_->{unquoted} } => $_) : (),
      $_->{deferred} ? ($_->{deferred} => $_) : (),
    ) : () } values %QUOTED;
    %QUOTED = @quoted;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Sub::Quote - Efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  Exported by default.
  
  =head3 options
  
  =over 2
  
  =item C<no_install>
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =item C<no_defer>
  
  B<Boolean>.  Prevents a Sub::Defer wrapper from being generated for the quoted
  sub.  If the sub will most likely be called at some point, setting this is a
  good idea.  For a sub that will most likely be inlined, it is not recommended.
  
  =item C<package>
  
  The package that the quoted sub will be evaluated in.  If not specified, the
  package from sub calling C<quote_sub> will be used.
  
  =item C<hints>
  
  The value of L<< C<$^H> | perlvar/$^H >> to use for the code being evaluated.
  This captures the settings of the L<strict> pragma.  If not specified, the value
  from the calling code will be used.
  
  =item C<warning_bits>
  
  The value of L<< C<${^WARNING_BITS}> | perlvar/${^WARNING_BITS} >> to use for
  the code being evaluated.  This captures the L<warnings> set.  If not specified,
  the warnings from the calling code will be used.
  
  =item C<%^H>
  
  The value of L<< C<%^H> | perlvar/%^H >> to use for the code being evaluated.
  This captures additional pragma settings.  If not specified, the value from the
  calling code will be used if possible (on perl 5.10+).
  
  =item C<attributes>
  
  The L<perlsub/Subroutine Attributes> to apply to the sub generated.  Should be
  specified as an array reference.  The attributes will be applied to both the
  generated sub and the deferred wrapper, if one is used.
  
  =item C<file>
  
  The apparent filename to use for the code being evaluated.
  
  =item C<line>
  
  The apparent line number
  to use for the code being evaluated.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  Exported by default.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  Exported by default.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 quotify
  
   my $quoted_value = quotify $value;
  
  Quotes a single (non-reference) scalar value for use in a code string.  Numbers
  aren't treated specially and will be quoted as strings, but undef will quoted as
  C<undef()>.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head2 qsub
  
   my $hash = {
    coderef => qsub q{ print "hello"; },
    other   => 5,
   };
  
  Arguments: $code
  
  Works exactly like L</quote_sub>, but includes a prototype to only accept a
  single parameter.  This makes it easier to include in hash structures or lists.
  
  Exported by default.
  
  =head2 sanitize_identifier
  
   my $var_name = '$variable_for_' . sanitize_identifier('@name');
   quote_sub qq{ print \$${var_name} }, { $var_name => \$value };
  
  Arguments: $identifier
  
  Sanitizes a value so that it can be used in an identifier.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few
  caveats apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Sub-Quote>
  
  Git repository: L<git://github.com/moose/Sub-Quote.git>
  
  Git browser: L<https://github.com/moose/Sub-Quote>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  dolmen - Olivier Mengué (cpan:DOLMEN) <dolmen@cpan.org>
  
  alexbio - Alessandro Ghedini (cpan:ALEXBIO) <alexbio@cpan.org>
  
  getty - Torsten Raudssus (cpan:GETTY) <torsten@raudss.us>
  
  arcanez - Justin Hunter (cpan:ARCANEZ) <justin.d.hunter@gmail.com>
  
  kanashiro - Lucas Kanashiro (cpan:KANASHIRO) <kanashiro.duarte@gmail.com>
  
  djerius - Diab Jerius (cpan:DJERIUS) <djerius@cfa.harvard.edu>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2016 the Sub::Quote L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
SUB_QUOTE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.29-2-g3b23a06
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.30';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.30
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  my %require_attempted;
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          if (not exists $require_attempted{$ic}) {
              # Try to load it
              my $_old_error = $@;
              eval "require $ic";
              die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
              $@ = $_old_error;
          }
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      return undef unless defined $text;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = '1.74';
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = '1.74';
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = '1.74';
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = '1.74';
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = "$]" < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = '1.74';
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use strict;
    use warnings;
    use utf8;
  
    use URI::_punycode qw(encode_punycode decode_punycode);
  
    # encode a unicode string
    my $punycode = encode_punycode('http://☃.net'); # http://.net-xc8g
    $punycode = encode_punycode('bücher'); # bcher-kva
    $punycode = encode_punycode('他们为什么不说中文'); # ihqwcrb4cv8a8dqg056pqjye
  
    # decode a punycode string back into a unicode string
    my $unicode = decode_punycode('http://.net-xc8g'); # http://☃.net
    $unicode = decode_punycode('bcher-kva'); # bücher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 他们为什么不说中文
  
  =head1 DESCRIPTION
  
  L<URI::_punycode> is a module to encode / decode Unicode strings into
  L<Punycode|https://tools.ietf.org/html/rfc3492>, an efficient
  encoding of Unicode for use with L<IDNA|https://tools.ietf.org/html/rfc5890>.
  
  =head1 FUNCTIONS
  
  All functions throw exceptions on failure. You can C<catch> them with
  L<Syntax::Keyword::Try> or L<Try::Tiny>. The following functions are exported
  by default.
  
  =head2 encode_punycode
  
    my $punycode = encode_punycode('http://☃.net');  # http://.net-xc8g
    $punycode = encode_punycode('bücher'); # bcher-kva
    $punycode = encode_punycode('他们为什么不说中文') # ihqwcrb4cv8a8dqg056pqjye
  
  Takes a Unicode string (UTF8-flagged variable) and returns a Punycode
  encoding for it.
  
  =head2 decode_punycode
  
    my $unicode = decode_punycode('http://.net-xc8g'); # http://☃.net
    $unicode = decode_punycode('bcher-kva'); # bücher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 他们为什么不说中文
  
  Takes a Punycode encoding and returns original Unicode string.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa <F<miyagawa@bulknews.net>> is the author of
  L<IDNA::Punycode> which was the basis for this module.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, L<RFC 3492|https://tools.ietf.org/html/rfc3492>,
  L<RFC 5891|https://tools.ietf.org/html/rfc5891>
  
  =head1 COPYRIGHT AND LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.74';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn() || '') eq $host ||
  	lc(Net::Domain::hostname() || '') eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = '1.74';
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  my %require_attempted;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
              if (not exists $require_attempted{$impclass}) {
                  # Try to load it
                  my $_old_error = $@;
                  eval "require $impclass";
                  die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
                  $@ = $_old_error;
              }
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use Moo::_strictures;
  use Moo::_Utils qw(_load_module);
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  oo - syntactic sugar for Moo oneliners
  
  =head1 SYNOPSIS
  
    perl -Moo=Foo -e 'has bar => ( is => q[ro], default => q[baz] ); print Foo->new->bar'
  
    # loads an existing class and re-"opens" the package definition
    perl -Moo=+My::Class -e 'print __PACKAGE__->new->bar'
  
  =head1 DESCRIPTION
  
  oo.pm is a simple source filter that adds C<package $name; use Moo;> to the
  beginning of your script, intended for use on the command line via the -M
  option.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
OO

$fatpacked{"x86_64-linux/Cpanel/JSON/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CPANEL_JSON_XS';
  package Cpanel::JSON::XS;
  our $VERSION = '4.04';
  our $XS_VERSION = $VERSION;
  # $VERSION = eval $VERSION;
  
  =pod
  
  =head1 NAME
  
  Cpanel::JSON::XS - cPanel fork of JSON::XS, fast and correct serializing
  
  =head1 SYNOPSIS
  
   use Cpanel::JSON::XS;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = Cpanel::JSON::XS->new->ascii->pretty->allow_nonref;
   $pretty_printed_unencoded = $coder->encode ($perl_scalar);
   $perl_scalar = $coder->decode ($unicode_json_text);
  
   # Note that 5.6 misses most smart utf8 and encoding functionalities
   # of newer releases.
  
   # Note that L<JSON::MaybeXS> will automatically use Cpanel::JSON::XS
   # if available, at virtually no speed overhead either, so you should
   # be able to just:
   
   use JSON::MaybeXS;
  
   # and do the same things, except that you have a pure-perl fallback now.
  
  =head1 DESCRIPTION
  
  This module converts Perl data structures to JSON and vice versa. Its
  primary goal is to be I<correct> and its secondary goal is to be
  I<fast>. To reach the latter goal it was written in C.
  
  As this is the n-th-something JSON module on CPAN, what was the reason
  to write yet another JSON module? While it seems there are many JSON
  modules, none of them correctly handle all corner cases, and in most cases
  their maintainers are unresponsive, gone missing, or not listening to bug
  reports for other reasons.
  
  See below for the cPanel fork.
  
  See MAPPING, below, on how Cpanel::JSON::XS maps perl values to JSON
  values and vice versa.
  
  =head2 FEATURES
  
  =over 4
  
  =item * correct Unicode handling
  
  This module knows how to handle Unicode with Perl version higher than 5.8.5,
  documents how and when it does so, and even documents what "correct" means.
  
  =item * round-trip integrity
  
  When you serialize a perl data structure using only data types supported
  by JSON and Perl, the deserialized data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default. the latter is a security
  feature.
  
  =item * fast
  
  Compared to other JSON modules and other serializers such as Storable,
  this module usually compares favourably in terms of speed, too.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an object
  oriented interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format
  possible (nice for simple line-based protocols), a pure-ASCII format
  (for when your transport is not 8-bit clean, still supports the whole
  Unicode range), or a pretty-printed format (for when you want to read that
  stuff). Or you can combine those features in whatever way you like.
  
  =back
  
  =head2 cPanel fork
  
  Since the original author MLEHMANN has no public
  bugtracker, this cPanel fork sits now on github.
  
  src repo: L<https://github.com/rurban/Cpanel-JSON-XS>
  original: L<http://cvs.schmorp.de/JSON-XS/>
  
  RT:       L<https://github.com/rurban/Cpanel-JSON-XS/issues>
  or        L<https://rt.cpan.org/Public/Dist/Display.html?Queue=Cpanel-JSON-XS>
  
  B<Changes to JSON::XS>
  
  - stricter decode_json() as documented. non-refs are disallowed.
    added a 2nd optional argument. decode() honors now allow_nonref.
  
  - fixed encode of numbers for dual-vars. Different string
    representations are preserved, but numbers with temporary strings
    which represent the same number are here treated as numbers, not
    strings. Cpanel::JSON::XS is a bit slower, but preserves numeric
    types better.
  
  - numbers ending with .0 stay numbers, are not converted to
    integers. [#63] dual-vars which are represented as number not
    integer (42+"bar" != 5.8.9) are now encoded as number (=> 42.0)
    because internally it's now a NOK type.  However !!1 which is
    wrongly encoded in 5.8 as "1"/1.0 is still represented as integer.
  
  - different handling of inf/nan. Default now to null, optionally with
    stringify_infnan() to "inf"/"nan". [#28, #32]
  
  - added C<binary> extension, non-JSON and non JSON parsable, allows
    C<\xNN> and C<\NNN> sequences.
  
  - 5.6.2 support; sacrificing some utf8 features (assuming bytes
    all-over), no multi-byte unicode characters with 5.6.
  
  - interop for true/false overloading. JSON::XS, JSON::PP and Mojo::JSON 
    representations for booleans are accepted and JSON::XS accepts
    Cpanel::JSON::XS booleans [#13, #37]
    Fixed overloading of booleans. Cpanel::JSON::XS::true stringifies again
    to "1", not "true", analog to all other JSON modules.
  
  - native boolean mapping of yes and no to true and false, as in YAML::XS.
    In perl C<!0> is yes, C<!1> is no.
    The JSON value true maps to 1, false maps to 0. [#39]
  
  - support arbitrary stringification with encode, with convert_blessed
    and allow_blessed.
  
  - ithread support. Cpanel::JSON::XS is thread-safe, JSON::XS not
  
  - is_bool can be called as method, JSON::XS::is_bool not.
  
  - performance optimizations for threaded Perls
  
  - relaxed mode, allowing many popular extensions
  
  - additional fixes for:
  
    - [cpan #88061] AIX atof without USE_LONG_DOUBLE
  
    - #10 unshare_hek crash
  
    - #7, #29 avoid re-blessing where possible. It fails in JSON::XS for
     READONLY values, i.e. restricted hashes.
  
    - #41 overloading of booleans, use the object not the reference.
  
    - #62 -Dusequadmath conversion and no SEGV.
  
    - #72 parsing of values followed \0, like 1\0 does fail.
  
    - #72 parsing of illegal unicode or non-unicode characters.
  
    - #96 locale-insensitive numeric conversion
  
  - public maintenance and bugtracker
  
  - use ppport.h, sanify XS.xs comment styles, harness C coding style
  
  - common::sense is optional. When available it is not used in the
    published production module, just during development and testing.
  
  - extended testsuite, passes all http://seriot.ch/parsing_json.html
    tests.  In fact it is the only know JSON decoder which does so,
    while also being the fastest.
  
  - support many more options and methods from JSON::PP:
    stringify_infnan, allow_unknown, allow_stringify, allow_barekey,
    encode_stringify, allow_bignum, allow_singlequote, sort_by
    (partially), escape_slash, convert_blessed, ...  optional
    decode_json(, allow_nonref) arg.
    relaxed implements allow_dupkeys.
  
  - support all 5 unicode BOM's: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE,
    UTF-32BE, encoding internally to UTF-8.
  
  =cut
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(encode_json decode_json to_json from_json);
  
  sub to_json($@) {
     if ($] >= 5.008) {
       require Carp;
       Carp::croak ("Cpanel::JSON::XS::to_json has been renamed to encode_json,".
                    " either downgrade to pre-2.0 versions of Cpanel::JSON::XS or".
                    " rename the call");
     } else {
       _to_json(@_);
     }
  }
  
  sub from_json($@) {
     if ($] >= 5.008) {
       require Carp;
       Carp::croak ("Cpanel::JSON::XS::from_json has been renamed to decode_json,".
                    " either downgrade to pre-2.0 versions of Cpanel::JSON::XS or".
                    " rename the call");
     } else {
       _from_json(@_);
     }
  }
  
  use Exporter;
  use XSLoader;
  
  =head1 FUNCTIONAL INTERFACE
  
  The following convenience methods are provided by this module. They are
  exported by default:
  
  =over 4
  
  =item $json_text = encode_json $perl_scalar, [json_type]
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
     $json_text = Cpanel::JSON::XS->new->utf8->encode ($perl_scalar)
  
  Except being faster.
  
  For the type argument see L<Cpanel::JSON::XS::Type>.
  
  =item $perl_scalar = decode_json $json_text [, $allow_nonref ]
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string of an
  json reference and tries to parse that as an UTF-8 encoded JSON text,
  returning the resulting reference. Croaks on error.
  
  This function call is functionally identical to:
  
     $perl_scalar = Cpanel::JSON::XS->new->utf8->decode ($json_text)
  
  except being faster.
  
  Note that older decode_json versions in Cpanel::JSON::XS older than
  3.0116 and JSON::XS did not set allow_nonref but allowed them due to a
  bug in the decoder.
  
  If the new optional $allow_nonref argument is set and not false, the
  allow_nonref option will be set and the function will act is described
  as in the relaxed RFC 7159 allowing all values such as objects,
  arrays, strings, numbers, "null", "true", and "false".
  
  =item $is_boolean = Cpanel::JSON::XS::is_bool $scalar
  
  Returns true if the passed scalar represents either C<JSON::XS::true>
  or C<JSON::XS::false>, two constants that act like C<1> and C<0>,
  respectively and are used to represent JSON C<true> and C<false>
  values in Perl.
  
  See MAPPING, below, for more information on how JSON values are mapped
  to Perl.
  
  =back
  
  =head1 DEPRECATED FUNCTIONS
  
  =over
  
  =item from_json
  
  from_json has been renamed to decode_json
  
  =item to_json
  
  to_json has been renamed to encode_json
  
  =back
  
  
  =head1 A FEW NOTES ON UNICODE AND PERL
  
  Since this often leads to confusion, here are a few very clear words on
  how Unicode works in Perl, modulo bugs.
  
  =over 4
  
  =item 1. Perl strings can store characters with ordinal values > 255.
  
  This enables you to store Unicode characters as single characters in a
  Perl string - very natural.
  
  =item 2. Perl does I<not> associate an encoding with your strings.
  
  ... until you force it to, e.g. when matching it against a regex, or
  printing the scalar to a file, in which case Perl either interprets
  your string as locale-encoded text, octets/binary, or as Unicode,
  depending on various settings. In no case is an encoding stored
  together with your data, it is I<use> that decides encoding, not any
  magical meta data.
  
  =item 3. The internal utf-8 flag has no meaning with regards to the
  encoding of your string.
  
  =item 4. A "Unicode String" is simply a string where each character
  can be validly interpreted as a Unicode code point.
  
  If you have UTF-8 encoded data, it is no longer a Unicode string, but
  a Unicode string encoded in UTF-8, giving you a binary string.
  
  =item 5. A string containing "high" (> 255) character values is I<not>
  a UTF-8 string.
  
  =item 6. Unicode noncharacters only warn, as in core.
  
  The 66 Unicode noncharacters U+FDD0..U+FDEF, and U+*FFFE, U+*FFFF just
  warn, see L<http://www.unicode.org/versions/corrigendum9.html>.  But
  illegal surrogate pairs fail to parse.
  
  =item 7. Raw non-Unicode characters above U+10FFFF are disallowed.
  
  Raw non-Unicode characters outside the valid unicode range fail to
  parse, because "A string is a sequence of zero or more Unicode
  characters" RFC 7159 section 1 and "JSON text SHALL be encoded in
  Unicode RFC 7159 section 8.1. We use now the UTF8_DISALLOW_SUPER
  flag when parsing unicode.
  
  =back
  
  I hope this helps :)
  
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =over 4
  
  =item $json = new Cpanel::JSON::XS
  
  Creates a new JSON object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = Cpanel::JSON::XS->new->utf8->space_after->encode ({a => [1,2]})
     => {"a": [1, 2]}
  
  =item $json = $json->ascii ([$enable])
  
  =item $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single C<\uXXXX> (BMP characters) or a double C<\uHHHH\uLLLLL> escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    Cpanel::JSON::XS->new->ascii (1)->encode ([chr 0x10401])
    => ["\ud801\udc01"]
  
  =item $json = $json->latin1 ([$enable])
  
  =item $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or ISO-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    Cpanel::JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  
  =item $json = $json->binary ([$enable])
  
  =item $enabled = $json = $json->get_binary
  
  If the C<$enable> argument is true (or missing), then the C<encode>
  method will not try to detect an UTF-8 encoding in any JSON string, it
  will strictly interpret it as byte sequence.  The result might contain
  new C<\xNN> sequences, which is B<unparsable JSON>.  The C<decode>
  method forbids C<\uNNNN> sequences and accepts C<\xNN> and octal
  C<\NNN> sequences.
  
  There is also a special logic for perl 5.6 and utf8. 5.6 encodes any
  string to utf-8 automatically when seeing a codepoint >= C<0x80> and
  < C<0x100>. With the binary flag enabled decode the perl utf8 encoded
  string to the original byte encoding and encode this with C<\xNN>
  escapes. This will result to the same encodings as with newer
  perls. But note that binary multi-byte codepoints with 5.6 will
  result in C<illegal unicode character in binary string> errors,
  unlike with newer perls.
  
  If C<$enable> is false, then the C<encode> method will smartly try to
  detect Unicode characters unless required by the JSON syntax or other
  flags and hex and octal sequences are forbidden.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to avoid the smart unicode detection and
  possible double encoding. The disadvantage is that the resulting JSON
  text is encoded in new C<\xNN> and in latin1 characters and must
  correctly be treated as such when storing and transferring, a rare
  encoding for JSON. It will produce non-readable JSON strings in the
  browser.  It is therefore most useful when you want to store data
  structures known to contain binary data efficiently in files or
  databases, not when talking to other JSON encoders/decoders.  The
  binary decoding method can also be used when an encoder produced a
  non-JSON conformant hex or octal encoding C<\xNN> or C<\NNN>.
  
    Cpanel::JSON::XS->new->binary->encode (["\x{89}\x{abc}"])
    5.6:   Error: malformed or illegal unicode character in binary string
    >=5.8: ['\x89\xe0\xaa\xbc']
  
    Cpanel::JSON::XS->new->binary->encode (["\x{89}\x{bc}"])
    => ["\x89\xbc"]
  
    Cpanel::JSON::XS->new->binary->decode (["\x89\ua001"])
    Error: malformed or illegal unicode character in binary string
  
    Cpanel::JSON::XS->new->decode (["\x89"])
    Error: illegal hex character in non-binary string
  
  
  =item $json = $json->utf8 ([$enable])
  
  =item $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", Cpanel::JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = Cpanel::JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  =item $json = $json->pretty ([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Example, pretty-print some simple structure:
  
     my $json = Cpanel::JSON::XS->new->pretty(1)->encode ({a => [1,2]})
     =>
     {
        "a" : [
           1,
           2
        ]
     }
  
  
  =item $json = $json->indent ([$enable])
  
  =item $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use
  a multiline format as output, putting every array member or
  object/hash key-value pair into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =item $json = $json->indent_length([$number_of_spaces])
  
  =item $length = $json->get_indent_length()
  
  Set the indent length (default C<3>).
  This option is only useful when you also enable indent or pretty.
  The acceptable range is from 0 (no indentation) to 15
  
  =item $json = $json->space_before ([$enable])
  
  =item $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =item $json = $json->space_after ([$enable])
  
  =item $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add
  an extra optional space after the C<:> separating keys from values in
  JSON objects and extra whitespace after the C<,> separating key-value
  pairs and array members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =item $json = $json->relaxed ([$enable])
  
  =item $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =item * literal ASCII TAB characters in strings
  
  Literal ASCII TAB characters are now allowed in strings (and treated as
  C<\t>) in relaxed mode. Despite JSON mandates, that TAB character is
  substituted for "\t" sequence.
  
    [
       "Hello\tWorld",
       "Hello<TAB>World", # literal <TAB> would not normally be allowed
    ]
  
  =item * allow_singlequote
  
  Single quotes are accepted instead of double quotes. See the
  L</allow_singlequote> option.
  
      { "foo":'bar' }
      { 'foo':"bar" }
      { 'foo':'bar' }
  
  =item * allow_barekey
  
  Accept unquoted object keys instead of with mandatory double quotes. See the
  L</allow_barekey> option.
  
      { foo:"bar" }
  
  =item * duplicate keys
  
  With relaxed decoding of duplicate keys does not error and are silently accepted.
  See L<http://seriot.ch/parsing_json.php#24>:
  RFC 7159 section 4: "The names within an object should be unique."
  
  =back
  
  
  =item $json = $json->canonical ([$enable])
  
  =item $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will
  output JSON objects by sorting their keys. This is adding a
  comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  
  =item $json = $json->sort_by (undef, 0, 1 or a block)
  
  This currently only (un)sets the C<canonical> option, and ignores
  custom sort blocks.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  
  =item $json = $json->escape_slash ([$enable])
  
  =item $enabled = $json->get_escape_slash
  
  According to the JSON Grammar, the I<forward slash> character (U+002F)
  C<"/"> need to be escaped.  But by default strings are encoded without
  escaping slashes in all perl JSON encoders.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes,
  C<"\/">.
  
  This setting has no effect when decoding JSON texts.
  
  
  =item $json = $json->allow_singlequote ([$enable])
  
  =item $enabled = $json->get_allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  This is also enabled with C<relaxed>.
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =item $json = $json->allow_barekey ([$enable])
  
  =item $enabled = $json->get_allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  Same as with the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =item $json = $json->allow_bignum ([$enable])
  
  =item $enabled = $json->get_allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and
  C<Math::BigFloat> objects into JSON numbers with C<allow_blessed>
  enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See L</MAPPING> about the normal conversion of JSON number.
  
  
  =item $json = $json->allow_bigint ([$enable])
  
  This option is obsolete and replaced by allow_bignum.
  
  
  =item $json = $json->allow_nonref ([$enable])
  
  =item $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can
  convert a non-reference into its corresponding string, number or null
  JSON value, which is an extension to RFC4627. Likewise, C<decode> will
  accept those JSON values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     Cpanel::JSON::XS->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =item $json = $json->allow_unknown ([$enable])
  
  =item $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =item $json = $json->allow_stringify ([$enable])
  
  =item $enabled = $json->get_allow_stringify
  
  If C<$enable> is true (or missing), then C<encode> will stringify the
  non-object perl value or reference. Note that blessed objects are not
  included here and are handled separately by C<allow_blessed> and
  C<convert_blessed>.  String references are stringified to the string
  value, other references as in perl.
  
  This option does not affect C<decode> in any way.
  
  This option is special to this module, it is not supported by other
  encoders.  So it is not recommended to use it.
  
  =item $json = $json->allow_blessed ([$enable])
  
  =item $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->convert_blessed ([$enable])
  
  =item $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, a stringification overload method is tried next.
  If both are not found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->allow_tags ([$enable])
  
  =item $enabled = $json->get_allow_tags
  
  See L<OBJECT SERIALIZATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialize the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialize
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =item $json = $json->filter_json_object ([$coderef->($hashref)])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialized data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialized hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialized hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = Cpanel::JSON::XS->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]')
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialize Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialized Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     Cpanel::JSON::XS
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialization to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =item $json = $json->shrink ([$enable])
  
  =item $enabled = $json->get_shrink
  
  Perl usually over-allocates memory a bit when allocating space for
  strings. This flag optionally resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk-to-fit, while all strings generated by C<decode> will also be
  shrunk-to-fit.
  
  If C<$enable> is false, then the normal perl allocation algorithms are used.
  If you work with your data, then this is likely to be faster.
  
  In the future, this setting might control other things, such as converting
  strings that look like integers or floats into integers or floats
  internally (there is no difference on the Perl level), saving space.
  
  =item $json = $json->max_depth ([$maximum_nesting_depth])
  
  =item $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing.
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json = $json->max_size ([$maximum_string_size])
  
  =item $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L</SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =item $json->stringify_infnan ([$infnan_mode = 1])
  
  =item $infnan_mode = $json->get_stringify_infnan
  
  Get or set how Cpanel::JSON::XS encodes C<inf>, C<-inf> or C<nan> for numeric
  values. Also qnan, snan or negative nan on some platforms.
  
  C<null>:     infnan_mode = 0. Similar to most JSON modules in other languages.
  Always null.
  
  stringified: infnan_mode = 1. As in Mojo::JSON. Platform specific strings.
  Stringified via sprintf(%g), with double quotes.
  
  inf/nan:     infnan_mode = 2. As in JSON::XS, and older releases.
  Passes through platform dependent values, invalid JSON. Stringified via
  sprintf(%g), but without double quotes.
  
  "inf/-inf/nan": infnan_mode = 3. Platform independent inf/nan/-inf
  strings.  No QNAN/SNAN/negative NAN support, unified to "nan". Much
  easier to detect, but may conflict with valid strings.
  
  =item $json_text = $json->encode ($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to
  arrays become JSON arrays and references to hashes become JSON
  objects. Undefined Perl values (e.g. C<undef>) become JSON C<null>
  values. Neither C<true> nor C<false> values will be generated.
  
  =item $perl_scalar = $json->decode ($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1>, C<false> becomes C<0> and C<null> becomes C<undef>.
  
  =item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     Cpanel::JSON::XS->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =item $json->to_json ($perl_hash_or_arrayref)
  
  Deprecated method for perl 5.8 and newer. Use L<encode_json> instead.
  
  =item $json->from_json ($utf8_encoded_json_text)
  
  Deprecated method for perl 5.8 and newer. Use L<decode_json> instead.
  
  =back
  
  
  =head1 INCREMENTAL PARSING
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  Cpanel::JSON::XS will only attempt to parse the JSON text once it is
  sure it has enough text to get a decisive result, using a very simple
  but truly incremental parser. This means that it sometimes won't stop
  as early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding
  as soon as a syntactically valid JSON text has been seen. This means
  you need to set resource limits (e.g. C<max_size>) to ensure the
  parser will stop parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =over 4
  
  =item [void, scalar or list context] = $json->incr_parse ([$string])
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
     my @objs = Cpanel::JSON::XS->new->incr_parse ("[5][7][1,2]");
  
  =item $lvalue_string = $json->incr_text (>5.8 only)
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object, and
  2. only with Perl >= 5.8 
  
  Under all other circumstances you must not call this function (I mean
  it.  although in simple tests it might actually work, it I<will> fail
  under real world conditions). As a special exception, you can also
  call this method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =item $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =item $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =back
  
  =head2 LIMITATIONS
  
  All options that affect decoding are supported, except
  C<allow_nonref>. The reason for this is that it cannot be made to work
  sensibly: JSON objects and arrays are self-delimited, i.e. you can
  concatenate them back to back and still decode them perfectly. This
  does not hold true for JSON numbers, however.
  
  For example, is the string C<1> a single JSON number, or is it simply
  the start of C<12>? Or is C<12> a single JSON number, or the
  concatenation of C<1> and C<2>? In neither case you can tell, and this
  is why Cpanel::JSON::XS takes the conservative route and disallows
  this case.
  
  =head2 EXAMPLES
  
  Some examples will make all this clearer. First, a simple example that
  works similarly to C<decode_prefix>: We want to decode the JSON object at
  the start of a string and identify the portion after the JSON object:
  
     my $text = "[1,2,3] hello";
  
     my $json = new Cpanel::JSON::XS;
  
     my $obj = $json->incr_parse ($text)
        or die "expected JSON object or array at beginning of string";
  
     my $tail = $json->incr_text;
     # $tail now contains " hello"
  
  Easy, isn't it?
  
  Now for a more complicated example: Imagine a hypothetical protocol where
  you read some requests from a TCP stream, and each request is a JSON
  array, without any separation between them (in fact, it is often useful to
  use newlines as "separators", as these get interpreted as whitespace at
  the start of the JSON text, which makes it possible to test said protocol
  with C<telnet>...).
  
  Here is how you'd do it (it is trivial to write this in an event-based
  manner):
  
     my $json = new Cpanel::JSON::XS;
  
     # read some data from the socket
     while (sysread $socket, my $buf, 4096) {
  
        # split and decode as many requests as possible
        for my $request ($json->incr_parse ($buf)) {
           # act on the $request
        }
     }
  
  Another complicated example: Assume you have a string with JSON objects
  or arrays, all separated by (optional) comma characters (e.g. C<[1],[2],
  [3]>). To parse them, we have to skip the commas between the JSON texts,
  and here is where the lvalue-ness of C<incr_text> comes in useful:
  
     my $text = "[1],[2], [3]";
     my $json = new Cpanel::JSON::XS;
  
     # void context, so no parsing done
     $json->incr_parse ($text);
  
     # now extract as many objects as possible. note the
     # use of scalar context so incr_text can be called.
     while (my $obj = $json->incr_parse) {
        # do something with $obj
  
        # now skip the optional comma
        $json->incr_text =~ s/^ \s* , //x;
     }
  
  Now lets go for a very complex example: Assume that you have a gigantic
  JSON array-of-objects, many gigabytes in size, and you want to parse it,
  but you cannot load it into memory fully (this has actually happened in
  the real world :).
  
  Well, you lost, you have to implement your own JSON parser. But
  Cpanel::JSON::XS can still help you: You implement a (very simple)
  array parser and let JSON decode the array elements, which are all
  full JSON objects on their own (this wouldn't work if the array
  elements could be JSON numbers, for example):
  
     my $json = new Cpanel::JSON::XS;
  
     # open the monster
     open my $fh, "<bigfile.json"
        or die "bigfile: $!";
  
     # first parse the initial "["
     for (;;) {
        sysread $fh, my $buf, 65536
           or die "read error: $!";
        $json->incr_parse ($buf); # void context, so no parsing
  
        # Exit the loop once we found and removed(!) the initial "[".
        # In essence, we are (ab-)using the $json object as a simple scalar
        # we append data to.
        last if $json->incr_text =~ s/^ \s* \[ //x;
     }
  
     # now we have the skipped the initial "[", so continue
     # parsing all the elements.
     for (;;) {
        # in this loop we read data until we got a single JSON object
        for (;;) {
           if (my $obj = $json->incr_parse) {
              # do something with $obj
              last;
           }
  
           # add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
        # in this loop we read data until we either found and parsed the
        # separating "," between elements, or the final "]"
        for (;;) {
           # first skip whitespace
           $json->incr_text =~ s/^\s*//;
  
           # if we find "]", we are done
           if ($json->incr_text =~ s/^\]//) {
              print "finished.\n";
              exit;
           }
  
           # if we find ",", we can continue with the next element
           if ($json->incr_text =~ s/^,//) {
              last;
           }
  
           # if we find anything else, we have a parse error!
           if (length $json->incr_text) {
              die "parse error near ", $json->incr_text;
           }
  
           # else add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
  This is a complex example, but most of the complexity comes from the fact
  that we are trying to be correct (bear with me if I am wrong, I never ran
  the above example :).
  
  =head1 BOM
  
  Detect all unicode B<Byte Order Marks> on decode.
  Which are UTF-8, UTF-16LE, UTF-16BE, UTF-32LE and UTF-32BE.
  
  B<Warning>: With perls older than 5.20 you need load the Encode module
  before loading a multibyte BOM, i.e. >= UTF-16. Otherwise an error is
  thrown. This is an implementation limitation and might get fixed later.
  
  See L<https://tools.ietf.org/html/rfc7159#section-8.1>
  I<"JSON text SHALL be encoded in UTF-8, UTF-16, or UTF-32.">
  
  I<"Implementations MUST NOT add a byte order mark to the beginning of a
  JSON text", "implementations (...) MAY ignore the presence of a byte
  order mark rather than treating it as an error".>
  
  See also L<http://www.unicode.org/faq/utf_bom.html#BOM>.
  
  Beware that Cpanel::JSON::XS is currently the only JSON module which
  does accept and decode a BOM.
  
  The latest JSON spec
  L<https://www.greenbytes.de/tech/webdav/rfc8259.html#character.encoding>
  forbid the usage of UTF-16 or UTF-32, the character encoding is UTF-8.
  Thus in subsequent updates BOM's of UTF-16 or UTF-32 will throw an error.
  
  =head1 MAPPING
  
  This section describes how Cpanel::JSON::XS maps Perl values to JSON
  values and vice versa. These mappings are designed to "do the right
  thing" in most circumstances automatically, preserving round-tripping
  characteristics (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, Cpanel::JSON::XS will try to
  represent it as an integer value. If that fails, it will try to
  represent it as a numeric (floating point) value if that is possible
  without loss of precision. Otherwise it will preserve the number as a
  string value (in which case you lose roundtripping ability, as the
  JSON number will be re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values
  cannot represent most decimal fractions exactly, and when converting
  from and to floating point, C<Cpanel::JSON::XS> only guarantees precision
  up to but not including the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<Cpanel::JSON::XS::true> and
  C<Cpanel::JSON::XS::false>, respectively. They are C<JSON::PP::Boolean>
  objects and are overloaded to act almost exactly like the numbers C<1>
  and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<Cpanel::JSON::XS::is_bool> function.
  
  The other round, from perl to JSON, C<!0> which is represented as
  C<yes> becomes C<true>, and C<!1> which is represented as
  C<no> becomes C<false>.
  
  Via L<Cpanel::JSON::XS::Type> you can now even force negation in C<encode>,
  without overloading of C<!>:
  
      my $false = Cpanel::JSON::XS::false;
      print($json->encode([!$false], [JSON_TYPE_BOOL]));
      => [true]
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALIZATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. Cpanel::JSON::XS can
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialize to the same JSON text (given same
  settings and version of Cpanel::JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. 
  
  With the option C<allow_stringify>, you can ignore the exception and return
  the stringification of the perl value.
  
  With the option C<allow_unknown>, you can ignore the exception and
  return C<null> instead.
  
     encode_json [\"x"]        # => cannot encode reference to scalar 'SCALAR(0x..)'
                               # unless the scalar is 0 or 1
     encode_json [\0, \1]      # yields [false,true]
  
     allow_stringify->encode_json [\"x"] # yields "x" unlike JSON::PP
     allow_unknown->encode_json [\"x"]   # yields null as in JSON::PP
  
  =item Cpanel::JSON::XS::true, Cpanel::JSON::XS::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> or C<!0> and C<!1>
  directly if you want.
  
     encode_json [Cpanel::JSON::XS::true, Cpanel::JSON::XS::true] # yields [false,true]
     encode_json [!1, !0]      # yields [false,true]
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but
  C<Cpanel::JSON::XS> allows various optional ways of handling
  objects. See L<OBJECT SERIALIZATION>, below, for details.
  
  See the C<allow_blessed> and C<convert_blessed> methods on various
  options on how to deal with this: basically, you can choose between
  throwing an exception, encoding the reference as if it weren't
  blessed, use the objects overloaded stringification method or provide
  your own serializer method.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: Cpanel::JSON::XS will encode undefined
  scalars or inf/nan as JSON C<null> values, scalars that have last been
  used in a string context before encoding as JSON strings, and anything
  else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, but the two representations are for the same number
     print $value;
     encode_json [$value]                 # yields [5]
  
     # used as different string (non-matching dual-var)
     my $str = '0 but true';
     my $num = 1 + $str;
     encode_json [$num, $str]           # yields [1,"0 but true"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
     # inf or nan becomes null, unless you answered
     # "Do you want to handle inf/nan as strings" with yes
     encode_json [9**9**9]                # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and thus
  null is returned instead. Optionally you can configure it to stringify
  inf and nan values.
  
  =back
  
  =head2 OBJECT SERIALIZATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialize the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALIZATION
  
  What happens when C<Cpanel::JSON::XS> encounters a Perl object depends
  on the C<allow_blessed>, C<convert_blessed> and C<allow_tags>
  settings, which are used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<Cpanel::JSON::XS> uses the L<Types::Serialiser> object
  serialization protocol to create a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialize, and the second argument being the
  constant string C<JSON> to distinguish it from other serializers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serializer) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialized. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a stringification overload.
  
  In this case, the overloaded C<""> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<""> method will convert all L<URI>
  objects to JSON strings when serialized. The fact that these values
  originally were L<URI> objects is lost.
  
      package URI;
      use overload '""' => sub { shift->as_string };
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialized as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<Cpanel::JSON::XS> throws an exception.
  
  =back
  
  =head3 DESERIALIZATION
  
  For deserialization there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialized, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: I a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, C<Cpanel::JSON::XS> will look up the C<THAW> method
  of the package/classname used during serialization (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<enable_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serializer, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  See the L</SECURITY CONSIDERATIONS> section below. Allowing external
  json objects being deserialized to perl objects is usually a very bad
  idea.
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1>, C<binary> and
  C<ascii>. There seems to be some confusion on what these do, so here
  is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1>, C<binary> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape
  characters with ordinal values > 255 (> 127 with C<ascii>) and encode
  the remaining characters as specified by the C<utf8> flag.
  With C<binary> enabled, ordinal values > 255 are illegal.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1>, C<binary> nor C<ascii> are incompatible with the
  C<utf8> flag - they only govern when the JSON output engine escapes a
  character or not.
  
  The main use for C<latin1> or C<binary> is to relatively efficiently
  store binary data as JSON, at the expense of breaking compatibility
  with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  
  =head2 JSON and ECMAscript
  
  JSON syntax is based on how literals are represented in javascript (the
  not-standardized predecessor of ECMAscript) which is presumably why it is
  called "JavaScript Object Notation".
  
  However, JSON is not a subset (and also not a superset of course) of
  ECMAscript (the standard) or javascript (whatever browsers actually
  implement).
  
  If you want to use javascript's C<eval> function to "parse" JSON, you
  might run into parse errors for valid JSON texts, or the resulting data
  structure might not be queryable:
  
  One of the problems is that U+2028 and U+2029 are valid characters inside
  JSON strings, but are not allowed in ECMAscript string literals, so the
  following Perl fragment will not output something that can be guaranteed
  to be parsable by javascript's C<eval>:
  
     use Cpanel::JSON::XS;
  
     print encode_json [chr 0x2028];
  
  The right fix for this is to use a proper JSON parser in your javascript
  programs, and not rely on C<eval> (see for example Douglas Crockford's
  F<json2.js> parser).
  
  If this is not an option, you can, as a stop-gap measure, simply encode to
  ASCII-only JSON:
  
     use Cpanel::JSON::XS;
  
     print Cpanel::JSON::XS->new->ascii->encode ([chr 0x2028]);
  
  Note that this will enlarge the resulting JSON text quite a bit if you
  have many non-ASCII characters. You might be tempted to run some regexes
  to only escape U+2028 and U+2029, e.g.:
  
     # DO NOT USE THIS!
     my $json = Cpanel::JSON::XS->new->utf8->encode ([chr 0x2028]);
     $json =~ s/\xe2\x80\xa8/\\u2028/g; # escape U+2028
     $json =~ s/\xe2\x80\xa9/\\u2029/g; # escape U+2029
     print $json;
  
  Note that I<this is a bad idea>: the above only works for U+2028 and
  U+2029 and thus only for fully ECMAscript-compliant parsers. Many existing
  javascript implementations, however, have issues with other characters as
  well - using C<eval> naively simply I<will> cause problems.
  
  Another problem is that some javascript implementations reserve
  some property names for their own purposes (which probably makes
  them non-ECMAscript-compliant). For example, Iceweasel reserves the
  C<__proto__> property name for its own purposes.
  
  If that is a problem, you could parse try to filter the resulting JSON
  output for these property strings, e.g.:
  
     $json =~ s/"__proto__"\s*:/"__proto__renamed":/g;
  
  This works because C<__proto__> is not valid outside of strings, so every
  occurrence of C<"__proto__"\s*:> must be a string used as property name.
  
  Unicode non-characters between U+FFFD and U+10FFFF are decoded either
  to the recommended U+FFFD REPLACEMENT CHARACTER (see Unicode PR #121:
  Recommended Practice for Replacement Characters), or in the binary or
  relaxed mode left as is, keeping the illegal non-characters as before.
  
  Raw non-Unicode characters outside the valid unicode range fail now to
  parse, because "A string is a sequence of zero or more Unicode
  characters" RFC 7159 section 1 and "JSON text SHALL be encoded in
  Unicode RFC 7159 section 8.1. We use now the UTF8_DISALLOW_SUPER
  flag when parsing unicode.
  
  If you know of other incompatibilities, please let me know.
  
  
  =head2 JSON and YAML
  
  You often hear that JSON is a subset of YAML.  I<in general, there is
  no way to configure JSON::XS to output a data structure as valid YAML>
  that works in all cases.  If you really must use Cpanel::JSON::XS to
  generate YAML, you should use this algorithm (subject to change in
  future versions):
  
     my $to_yaml = Cpanel::JSON::XS->new->utf8->space_after (1);
     my $yaml = $to_yaml->encode ($ref) . "\n";
  
  This will I<usually> generate JSON texts that also parse as valid
  YAML.
  
  
  =head2 SPEED
  
  It seems that JSON::XS is surprisingly fast, as shown in the following
  tables. They have been generated with the help of the C<eg/bench> program
  in the JSON::XS distribution, to make it easy to compare on your own
  system.
  
  JSON::XS is with L<Data::MessagePack> and L<Sereal> one of the fastest
  serializers, because JSON and JSON::XS do not support backrefs (no
  graph structures), only trees. Storable supports backrefs,
  i.e. graphs. Data::MessagePack encodes its data binary (as Storable)
  and supports only very simple subset of JSON.
  
  First comes a comparison between various modules using
  a very short single-line JSON string (also available at
  L<http://dist.schmorp.de/misc/json/short.json>).
  
     {"method": "handleMessage", "params": ["user1",
     "we were just talking"], "id": null, "array":[1,11,234,-5,1e5,1e7,
     1,  0]}
  
  It shows the number of encodes/decodes per second (JSON::XS uses
  the functional interface, while Cpanel::JSON::XS/2 uses the OO interface
  with pretty-printing and hash key sorting enabled, Cpanel::JSON::XS/3 enables
  shrink. JSON::DWIW/DS uses the deserialize function, while JSON::DWIW::FJ
  uses the from_json method). Higher is better:
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |  86302.551 | 102300.098 |
     JSON::DWIW/FJ |  86302.551 |  75983.768 |
     JSON::PP      |  15827.562 |   6638.658 |
     JSON::Syck    |  63358.066 |  47662.545 |
     JSON::XS      | 511500.488 | 511500.488 |
     JSON::XS/2    | 291271.111 | 388361.481 |
     JSON::XS/3    | 361577.931 | 361577.931 |
     Storable      |  66788.280 | 265462.278 |
     --------------+------------+------------+
  
  That is, JSON::XS is almost six times faster than JSON::DWIW on encoding,
  about five times faster on decoding, and over thirty to seventy times
  faster than JSON's pure perl implementation. It also compares favourably
  to Storable for small amounts of data.
  
  Using a longer test string (roughly 18KB, generated from Yahoo! Locals
  search API (L<http://dist.schmorp.de/misc/json/long.json>).
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |   1647.927 |   2673.916 |
     JSON::DWIW/FJ |   1630.249 |   2596.128 |
     JSON::PP      |    400.640 |     62.311 |
     JSON::Syck    |   1481.040 |   1524.869 |
     JSON::XS      |  20661.596 |   9541.183 |
     JSON::XS/2    |  10683.403 |   9416.938 |
     JSON::XS/3    |  20661.596 |   9400.054 |
     Storable      |  19765.806 |  10000.725 |
     --------------+------------+------------+
  
  Again, JSON::XS leads by far (except for Storable which non-surprisingly
  decodes a bit faster).
  
  On large strings containing lots of high Unicode characters, some modules
  (such as JSON::PC) seem to decode faster than JSON::XS, but the result
  will be broken due to missing (or wrong) Unicode handling. Others refuse
  to decode or encode properly, so it was impossible to prepare a fair
  comparison table for that case.
  
  For updated graphs see L<https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs>
  
  
  =head1 INTEROP with JSON and JSON::XS and other JSON modules
  
  As long as you only serialize data that can be directly expressed in
  JSON, C<Cpanel::JSON::XS> is incapable of generating invalid JSON
  output (modulo bugs, but C<JSON::XS> has found more bugs in the
  official JSON testsuite (1) than the official JSON testsuite has found
  in C<JSON::XS> (0)).
  C<Cpanel::JSON::XS> is currently the only known JSON decoder which passes all
  L<http://seriot.ch/parsing_json.html> tests, while being the fastest also.
  
  When you have trouble decoding JSON generated by this module using other
  decoders, then it is very likely that you have an encoding mismatch or the
  other decoder is broken.
  
  When decoding, C<JSON::XS> is strict by default and will likely catch
  all errors. There are currently two settings that change this:
  C<relaxed> makes C<JSON::XS> accept (but not generate) some
  non-standard extensions, and C<allow_tags> or C<allow_blessed> will
  allow you to encode and decode Perl objects, at the cost of being
  totally insecure and not outputting valid JSON anymore.
  
  JSON-XS-3.01 broke interoperability with JSON-2.90 with booleans. See L<JSON>.
  
  Cpanel::JSON::XS needs to know the JSON and JSON::XS versions to be able work
  with those objects, especially when encoding a booleans like C<{"is_true":true}>.
  So you need to load these modules before.
  
  true/false overloading and boolean representations are supported.
  
  JSON::XS and JSON::PP representations are accepted and older JSON::XS
  accepts Cpanel::JSON::XS booleans. All JSON modules JSON, JSON, PP,
  JSON::XS, Cpanel::JSON::XS produce JSON::PP::Boolean objects, just
  Mojo and JSON::YAJL not.  Mojo produces Mojo::JSON::_Bool and
  JSON::YAJL::Parser just an unblessed IV.
  
  Cpanel::JSON::XS accepts JSON::PP::Boolean and Mojo::JSON::_Bool
  objects as booleans.
  
  I cannot think of any reason to still use JSON::XS anymore.
  
  
  =head2 TAGGED VALUE SYNTAX AND STANDARD JSON EN/DECODERS
  
  When you use C<allow_tags> to use the extended (and also nonstandard
  and invalid) JSON syntax for serialized objects, and you still want to
  decode the generated serialize objects, you can run a regex to replace
  the tagged syntax by standard JSON arrays (it only works for "normal"
  package names without comma, newlines or single colons). First, the
  readable Perl version:
  
     # if your FREEZE methods return no values, you need this replace first:
     $json =~ s/\( \s* (" (?: [^\\":,]+|\\.|::)* ") \s* \) \s* \[\s*\]/[$1]/gx;
  
     # this works for non-empty constructor arg lists:
     $json =~ s/\( \s* (" (?: [^\\":,]+|\\.|::)* ") \s* \) \s* \[/[$1,/gx;
  
  And here is a less readable version that is easy to adapt to other
  languages:
  
     $json =~ s/\(\s*("([^\\":,]+|\\.|::)*")\s*\)\s*\[/[$1,/g;
  
  Here is an ECMAScript version (same regex):
  
     json = json.replace (/\(\s*("([^\\":,]+|\\.|::)*")\s*\)\s*\[/g, "[$1,");
  
  Since this syntax converts to standard JSON arrays, it might be hard to
  distinguish serialized objects from normal arrays. You can prepend a
  "magic number" as first array element to reduce chances of a collision:
  
     $json =~ s/\(\s*("([^\\":,]+|\\.|::)*")\s*\)\s*\[/["XU1peReLzT4ggEllLanBYq4G9VzliwKF",$1,/g;
  
  And after decoding the JSON text, you could walk the data
  structure looking for arrays with a first element of
  C<XU1peReLzT4ggEllLanBYq4G9VzliwKF>.
  
  The same approach can be used to create the tagged format with another
  encoder. First, you create an array with the magic string as first member,
  the classname as second, and constructor arguments last, encode it as part
  of your JSON structure, and then:
  
     $json =~ s/\[\s*"XU1peReLzT4ggEllLanBYq4G9VzliwKF"\s*,\s*("([^\\":,]+|\\.|::)*")\s*,/($1)[/g;
  
  Again, this has some limitations - the magic string must not be encoded
  with character escapes, and the constructor arguments must be non-empty.
  
  
  =head1 RFC7159
  
  Since this module was written, Google has written a new JSON RFC, RFC 7159
  (and RFC7158). Unfortunately, this RFC breaks compatibility with both the
  original JSON specification on www.json.org and RFC4627.
  
  As far as I can see, you can get partial compatibility when parsing by
  using C<< ->allow_nonref >>. However, consider the security implications
  of doing so.
  
  I haven't decided yet when to break compatibility with RFC4627 by default
  (and potentially leave applications insecure) and change the default to
  follow RFC7159, but application authors are well advised to call C<<
  ->allow_nonref(0) >> even if this is the current default, if they cannot
  handle non-reference values, in preparation for the day when the default
  will change.
  
  =head1 SECURITY CONSIDERATIONS
  
  JSON::XS and Cpanel::JSON::XS are not only fast. JSON is generally the
  most secure serializing format, because it is the only one besides
  Data::MessagePack, which does not deserialize objects per default. For
  all languages, not just perl.  The binary variant BSON (MongoDB) does
  more but is unsafe.
  
  It is trivial for any attacker to create such serialized objects in
  JSON and trick perl into expanding them, thereby triggering certain
  methods. Watch L<https://www.youtube.com/watch?v=Gzx6KlqiIZE> for an
  exploit demo for "CVE-2015-1592 SixApart MovableType Storable Perl
  Code Execution" for a deserializer which expands objects.
  Deserializing even coderefs (methods, functions) or external
  data would be considered the most dangerous.
  
  Security relevant overview of serializers regarding deserializing
  objects by default:
  
                        Objects   Coderefs  External Data
  
      Data::Dumper      YES       YES       YES
      Storable          YES       NO (def)  NO
      Sereal            YES       NO        NO
      YAML              YES       NO        NO
      B::C              YES       YES       YES
      B::Bytecode       YES       YES       YES
      BSON              YES       YES       NO
      JSON::SL          YES       NO        YES
      JSON              NO (def)  NO        NO
      Data::MessagePack NO        NO        NO
      XML               NO        NO        YES
  
      Pickle            YES       YES       YES
      PHP Deserialize   YES       NO        NO
  
  When you are using JSON in a protocol, talking to untrusted potentially
  hostile creatures requires relatively few measures.
  
  First of all, your JSON decoder should be secure, that is, should not have
  any buffer overflows. Obviously, this module should ensure that.
  
  Second, you need to avoid resource-starving attacks. That means you should
  limit the size of JSON texts you accept, or make sure then when your
  resources run out, that's just fine (e.g. by using a separate process that
  can crash safely). The size of a JSON text in octets or characters is
  usually a good indication of the size of the resources required to decode
  it into a Perl structure. While JSON::XS can check the size of the JSON
  text, it might be too late when you already have it in memory, so you
  might want to check the size before you accept the string.
  
  Third, Cpanel::JSON::XS recurses using the C stack when decoding objects and
  arrays. The C stack is a limited resource: for instance, on my amd64
  machine with 8MB of stack size I can decode around 180k nested arrays but
  only 14k nested JSON objects (due to perl itself recursing deeply on croak
  to free the temporary). If that is exceeded, the program crashes. To be
  conservative, the default nesting limit is set to 512. If your process
  has a smaller stack, you should adjust this setting accordingly with the
  C<max_depth> method.
  
  Also keep in mind that Cpanel::JSON::XS might leak contents of your Perl data
  structures in its error messages, so when you serialize sensitive
  information you might want to make sure that exceptions thrown by JSON::XS
  will not end up in front of untrusted eyes.
  
  If you are using Cpanel::JSON::XS to return packets to consumption
  by JavaScript scripts in a browser you should have a look at
  L<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to
  see whether you are vulnerable to some common attack vectors (which really
  are browser design bugs, but it is still you who will have to deal with
  it, as major browser developers care only for features, not about getting
  security right). You might also want to also look at L<Mojo::JSON>
  special escape rules to prevent from XSS attacks.
  
  =head1 "OLD" VS. "NEW" JSON (RFC 4627 VS. RFC 7159)
  
  TL;DR: Due to security concerns, Cpanel::JSON::XS will not allow
  scalar data in JSON texts by default - you need to create your own
  Cpanel::JSON::XS object and enable C<allow_nonref>:
  
  
     my $json = JSON::XS->new->allow_nonref;
  
     $text = $json->encode ($data);
     $data = $json->decode ($text);
  
  The long version: JSON being an important and supposedly stable format,
  the IETF standardized it as RFC 4627 in 2006. Unfortunately the inventor
  of JSON Douglas Crockford unilaterally changed the definition of JSON in
  javascript. Rather than create a fork, the IETF decided to standardize the
  new syntax (apparently, so I as told, without finding it very amusing).
  
  The biggest difference between the original JSON and the new JSON is that
  the new JSON supports scalars (anything other than arrays and objects) at
  the top-level of a JSON text. While this is strictly backwards compatible
  to older versions, it breaks a number of protocols that relied on sending
  JSON back-to-back, and is a minor security concern.
  
  For example, imagine you have two banks communicating, and on one side,
  the JSON coder gets upgraded. Two messages, such as C<10> and C<1000>
  might then be confused to mean C<101000>, something that couldn't happen
  in the original JSON, because neither of these messages would be valid
  JSON.
  
  If one side accepts these messages, then an upgrade in the coder on either
  side could result in this becoming exploitable.
  
  This module has always allowed these messages as an optional extension, by
  default disabled. The security concerns are the reason why the default is
  still disabled, but future versions might/will likely upgrade to the newer
  RFC as default format, so you are advised to check your implementation
  and/or override the default with C<< ->allow_nonref (0) >> to ensure that
  future versions are safe.
  
  =head1 THREADS
  
  Cpanel::JSON::XS has proper ithreads support, unlike JSON::XS. If you
  encounter any bugs with thread support please report them.
  
  =head1 BUGS
  
  While the goal of the Cpanel::JSON::XS module is to be correct, that
  unfortunately does not mean it's bug-free, only that the author thinks
  its design is bug-free. If you keep reporting bugs and tests they will
  be fixed swiftly, though.
  
  Since the JSON::XS author refuses to use a public bugtracker and
  prefers private emails, we've setup a tracker at RT, so you might want
  to report any issues twice. Once in private to MLEHMANN to be fixed in
  JSON::XS and one to our the public tracker. Issues fixed by JSON::XS
  with a new release will also be backported to Cpanel::JSON::XS and
  5.6.2, as long as cPanel relies on 5.6.2 and Cpanel::JSON::XS as our
  serializer of choice.
  
  L<https://rt.cpan.org/Public/Dist/Display.html?Queue=Cpanel-JSON-XS>
  
  =head1 LICENSE
  
  This module is available under the same licences as perl, the Artistic
  license and the GPL.
  
  =cut
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
  }
  
  BEGIN {
    package
      JSON::PP::Boolean;
  
    require overload;
  
    local $^W; # silence redefine warnings. no warnings 'redefine' does not help
    &overload::import( 'overload', # workaround 5.6 reserved keyword warning
      "0+"     => sub { ${$_[0]} },
      "++"     => sub { $_[0] = ${$_[0]} + 1 },
      "--"     => sub { $_[0] = ${$_[0]} - 1 },
      '""'     => sub { ${$_[0]} == 1 ? '1' : '0' }, # GH 29
      'eq'     => sub {
        my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
        if ($op eq 'true' or $op eq 'false') {
          return "$obj" eq '1' ? 'true' eq $op : 'false' eq $op;
        }
        else {
          return $obj ? 1 == $op : 0 == $op;
        }
      },
      'ne'     => sub {
        my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
        return !($obj eq $op);
      },
      fallback => 1);
  }
  
  our ($true, $false);
  BEGIN {
    if ($INC{'JSON/XS.pm'}
        and $INC{'Types/Serialiser.pm'}
        and $JSON::XS::VERSION ge "3.00") {
      $true  = $Types::Serialiser::true; # readonly if loaded by JSON::XS
      $false = $Types::Serialiser::false;
    } else {
      $true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
      $false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
    }
  }
  
  BEGIN {
    my $const_true  = $true;
    my $const_false = $false;
    *true  = sub () { $const_true  };
    *false = sub () { $const_false };
  }
  
  sub is_bool($) {
    shift if @_ == 2; # as method call
    (ref($_[0]) and UNIVERSAL::isa( $_[0], JSON::PP::Boolean::))
    or (exists $INC{'Types/Serialiser.pm'} and Types::Serialiser::is_bool($_[0]))
  }
  
  XSLoader::load 'Cpanel::JSON::XS', $XS_VERSION;
  
  1;
  
  =head1 SEE ALSO
  
  The F<cpanel_json_xs> command line utility for quick experiments.
  
  L<JSON>, L<JSON::XS>, L<JSON::MaybeXS>, L<Mojo::JSON>, L<Mojo::JSON::MaybeXS>,
  L<JSON::SL>, L<JSON::DWIW>, L<JSON::YAJL>,  L<JSON::Any>, L<Test::JSON>,
  L<Locale::Wolowitz>,
  L<https://metacpan.org/search?q=JSON>
  
  L<https://tools.ietf.org/html/rfc7159>
  
  L<https://tools.ietf.org/html/rfc4627>
  
  
  =head1 AUTHOR
  
  Reini Urban <rurban@cpan.org>
  
  Marc Lehmann <schmorp@schmorp.de>, http://home.schmorp.de/
  
  =head1 MAINTAINER
  
  Reini Urban <rurban@cpan.org>
  
  =cut
  
X86_64-LINUX_CPANEL_JSON_XS

$fatpacked{"x86_64-linux/Cpanel/JSON/XS/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CPANEL_JSON_XS_BOOLEAN';
  =head1 NAME
  
  Cpanel::JSON::XS::Boolean - true and false values
  
  =head1 SYNOPSIS
  
    # do not "use" yourself
  
  See L<Cpanel::JSON::XS/"true, false">
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable
  and similar modules and interop with L<JSON::XS> booleans.  See
  L<Cpanel::JSON::XS> for more info about this class.
  
  =cut
  
  use Cpanel::JSON::XS ();
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
X86_64-LINUX_CPANEL_JSON_XS_BOOLEAN

$fatpacked{"x86_64-linux/Cpanel/JSON/XS/Type.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CPANEL_JSON_XS_TYPE';
  package Cpanel::JSON::XS::Type;
  
  =pod
  
  =head1 NAME
  
  Cpanel::JSON::XS::Type - Type support for JSON encode
  
  =head1 SYNOPSIS
  
   use Cpanel::JSON::XS;
   use Cpanel::JSON::XS::Type;
  
   encode_json([10, "10", 10.25], [JSON_TYPE_INT, JSON_TYPE_INT, JSON_TYPE_STRING]);
   # '[10,10,"10.25"]'
  
   encode_json([10, "10", 10.25], json_type_arrayof(JSON_TYPE_INT));
   # '[10,10,10]'
  
   encode_json(1, JSON_TYPE_BOOL);
   # 'true'
  
   my $perl_struct = { key1 => 1, key2 => "2", key3 => 1 };
   my $type_spec = { key1 => JSON_TYPE_STRING, key2 => JSON_TYPE_INT, key3 => JSON_TYPE_BOOL };
   my $json_string = encode_json($perl_struct, $type_spec);
   # '{"key1":"1","key2":2,"key3":true}'
  
   my $perl_struct = { key1 => "value1", key2 => "value2", key3 => 0, key4 => 1, key5 => "string", key6 => "string2" };
   my $type_spec = json_type_hashof(JSON_TYPE_STRING);
   my $json_string = encode_json($perl_struct, $type_spec);
   # '{"key1":"value1","key2":"value2","key3":"0","key4":"1","key5":"string","key6":"string2"}'
  
   my $perl_struct = { key1 => { key2 => [ 10, "10", 10.6 ] }, key3 => "10.5" };
   my $type_spec = { key1 => json_type_anyof(JSON_TYPE_FLOAT, json_type_hashof(json_type_arrayof(JSON_TYPE_INT))), key3 => JSON_TYPE_FLOAT };
   my $json_string = encode_json($perl_struct, $type_spec);
   # '{"key1":{"key2":[10,10,10]},"key3":10.5}'
  
  =head1 DESCRIPTION
  
  This module provides stable JSON type support for the
  L<Cpanel::JSON::XS|Cpanel::JSON::XS> encoder which doesn't depend on
  any internal perl scalar flags or characteristics.
  
  In most cases perl structures passed to
  L<encode_json|Cpanel::JSON::XS/encode_json> come from other functions
  or from other modules and caller of Cpanel::JSON::XS module does not
  have control of internals or they are subject of change. So it is not
  easy to support enforcing types as described in the
  L<simple scalars|Cpanel::JSON::XS/simple scalars> section.
  
  The function L<encode_json|Cpanel::JSON::XS/encode_json> takes a perl
  structure as its input and optionally also a json type specification in
  the second parameter.
  
  If the specification is not provided (or is undef) internal perl
  scalar flags are used for the resulting JSON type. The internal flags
  can be changed by perl itself, but also by external modules. Which
  means that types in resulting JSON string aren't stable. Specially it
  does not work reliable for dual vars and scalars which were used in
  both numeric and string operations. See L<simple
  scalars|Cpanel::JSON::XS/simple scalars>.
  
  =head2 JSON type specification for scalars:
  
  =over 4
  
  =item JSON_TYPE_BOOL
  
  It enforces JSON boolean in resulting JSON, i.e. either C<true> or
  C<false>. For determining whether the scalar passed to the encoder
  is true, standard perl boolean logic is used.
  
  =item JSON_TYPE_INT
  
  It enforces JSON number without fraction part in the resulting JSON.
  Equivalent of perl function L<int|perlfunc/int> is used for conversion.
  
  =item JSON_TYPE_FLOAT
  
  It enforces JSON number with fraction part in the resulting JSON.
  Equivalent of perl operation C<+0> is used for conversion.
  
  =item JSON_TYPE_STRING
  
  It enforces JSON string type in the resulting JSON.
  
  =back
  
  For each type, there also exists a type with the suffix C<_OR_NULL>
  which encodes perl's C<undef> into JSON C<null>. Without type with
  suffix C<_OR_NULL> perl's C<undef> is converted to specific type
  according to above rules.
  
  =head2 JSON type specification for arrays:
  
  =over 4
  
  =item [...]
  
  The array must contain the same number of elements as in the perl
  array passed for encoding. Each element of the array describes the
  JSON type which is enforced for the corresponding element of the
  perl array.
  
  =item json_type_arrayof
  
  This function takes a JSON type specification as its argument which
  is enforced for every element of the passed perl array.
  
  =back
  
  =head2 JSON type specification for hashes:
  
  =over 4
  
  =item {...}
  
  Each hash value for corresponding key describes the JSON type
  specification for values of passed perl hash structure. Keys in hash
  which are not present in passed perl hash structure are simple
  ignored and not used.
  
  =item json_type_hashof
  
  This function takes a JSON type specification as its argument which
  is enforced for every value of passed perl hash structure.
  
  =back
  
  =head2 JSON type specification for alternatives:
  
  =over 4
  
  =item json_type_anyof
  
  This function takes a list of JSON type alternative specifications
  (maximally one scalar, one array, and one hash) as its input and the
  JSON encoder chooses one that matches.
  
  =item json_type_null_or_anyof
  
  Like L<C<json_type_anyof>|/json_type_anyof>, but scalar can be only
  perl's C<undef>.
  
  =back
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright (c) 2017, GoodData Corporation. All rights reserved.
  
  This module is available under the same licences as perl, the Artistic
  license and the GPL.
  
  =cut
  
  use strict;
  use warnings;
  
  # This exports needed XS constants to perl
  use Cpanel::JSON::XS ();
  
  use Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT = our @EXPORT_OK = qw(
    json_type_arrayof
    json_type_hashof
    json_type_anyof
    json_type_null_or_anyof
    JSON_TYPE_BOOL
    JSON_TYPE_INT
    JSON_TYPE_FLOAT
    JSON_TYPE_STRING
    JSON_TYPE_BOOL_OR_NULL
    JSON_TYPE_INT_OR_NULL
    JSON_TYPE_FLOAT_OR_NULL
    JSON_TYPE_STRING_OR_NULL
    JSON_TYPE_ARRAYOF_CLASS
    JSON_TYPE_HASHOF_CLASS
    JSON_TYPE_ANYOF_CLASS
  );
  
  sub json_type_anyof {
    my ($scalar, $array, $hash);
    foreach (@_) {
      my $type = ref($_);
      if ($type eq '') {
        die 'Only one scalar type can be specified in anyof' if defined $scalar;
        $scalar = $_;
      } elsif ($type eq 'ARRAY' or $type eq JSON_TYPE_ARRAYOF_CLASS) {
        die 'Only one array type can be specified in anyof' if defined $array;
        $array = $_;
      } elsif ($type eq 'HASH' or $type eq JSON_TYPE_HASHOF_CLASS) {
        die 'Only one hash type can be specified in anyof' if defined $hash;
        $hash = $_;
      } else {
        die 'Only scalar, array or hash can be specified in anyof';
      }
    }
    return bless [$scalar, $array, $hash], JSON_TYPE_ANYOF_CLASS;
  }
  
  sub json_type_null_or_anyof {
    foreach (@_) {
      die 'Scalar cannot be specified in null_or_anyof' if ref($_) eq '';
    }
    return json_type_anyof(JSON_TYPE_CAN_BE_NULL, @_);
  }
  
  sub json_type_arrayof {
    die 'Exactly one type must be specified in arrayof' if scalar @_ != 1;
    return bless \(my $type = $_[0]), JSON_TYPE_ARRAYOF_CLASS;
  }
  
  sub json_type_hashof {
    die 'Exactly one type must be specified in hashof' if scalar @_ != 1;
    return bless \(my $type = $_[0]), JSON_TYPE_HASHOF_CLASS;
  }
  
  1;
X86_64-LINUX_CPANEL_JSON_XS_TYPE

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use 5.010000;
use Pithub;
use LWP::UserAgent;
use HTTP::Request;
use JSON;
use Data::Dumper; sub p { warn Dumper(@_); }
use autodie ':system';
use File::Basename ();
use Cwd ();
use Getopt::Long;
use Term::ReadKey;
use Sys::Hostname;
use Pod::Usage;
use Term::ANSIColor;
use Encode ();
use Encode::Locale;

our $VERSION = '0.09';

if (-t) {
    binmode STDOUT, ":encoding(console_out)";
    binmode STDERR, ":encoding(console_out)";
}

sub prompt {
    my ($prompt, @args) = @_;
    push @args, 1 if @args % 2;
    my %args = @args;
    local $| = 1;
    my $phrase = '';
    print $prompt;
    ReadMode 'cbreak';
    while (1) {
        my $c = ReadKey ~0/2-1;
        if ($c =~ /[\r\n]/) {
            print "\n";
            last;
        }
        elsif ($c eq "\b" || ord $c == 127) {
            next unless length $phrase;
            chop $phrase;
            next if defined $args{-echo} && length $args{-echo} eq 0;
            print "\b \b";
        }
        elsif (ord $c) {
            $phrase .= $c;
            print defined $args{-echo} ?  $args{-echo} : $c;
        }
    }
    ReadMode 'restore';
    $args{-yes} ? ($phrase =~ /^y/i) : $phrase;
}

my $agent = LWP::UserAgent->new(timeout => 10);
$agent->env_proxy(); # for mattn
my $token = `git config --get ph.token`;
my $me = `git config --get ph.user`;
chomp $me;
unless ($token && $me) {
    setup();
}
my $pithub = Pithub->new(
    token => $token,
    ua    => $agent,
);
main();
exit;

# ------------------------------------------------------------------------- 
sub main {
    my $cmd = shift @ARGV || 'help';
    my $cmd_code = __PACKAGE__->can("CMD_$cmd")
        or die "Unknown command $cmd\n";
    $cmd_code->();
}

# ------------------------------------------------------------------------- 

sub CMD_help {
    pod2usage(-verbose => 2);
}

sub CMD_version {
    print "$VERSION\n";
    exit 0;
}

sub CMD_issues {
    my ($user, $repo) = _get_user_repo_with_current_repo('issues');
    my $res = $pithub->issues->list(user => $user, repo => $repo);
    while ( my $row = $res->next ) {
        printf("#%s %s - %s\n", colored(['green'], $row->{number}), $row->{title}, colored(['Cyan'], $row->{user}->{login}));
        printf("%s\n\n", colored(['white'], $row->{html_url}));
    }
}

sub CMD_info {
    my ($user, $repo) = _get_user_repo('info');
    my $res = $pithub->repos->get(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    dump_content($res->content);
}

sub CMD_clone {
    my $fork;
    if ($ARGV[0] eq '--fork') {
        $fork = 1;
        shift @ARGV;
    }
    my ($user, $repo) = _get_user_repo('clone');
    if ($fork) {
        my $res = $pithub->repos->forks->create(user => $user, repo => $repo);
        $res->success or die dump_content($res->content);
        $user = $me;
    }
    my $res = $pithub->repos->get(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    my $url = $res->content->{ssh_url} or die "Cannot get ssh_url";
    system("git", "clone", $url);
}

sub CMD_fork {
    my ($user, $repo) = _get_user_repo_with_current_repo('fork');
    print("Forking $user/$repo\n");
    my $res = $pithub->repos->forks->create(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    my $ssh_url = $res->content->{ssh_url} // die dump_content($res->content);
    system("git", "remote", "add", $me, $ssh_url);
    system("git remote -v"); # show current settings.
}

sub CMD_pull {
    my ($num) = pop @ARGV;
    my $remote;
    if (@ARGV) {
        $remote = shift @ARGV;
    }
    else {
        my $branch = `git symbolic-ref -q HEAD`;
        chomp $branch;
        $branch ||= 'master';
        $branch =~ s{refs/heads/}{};
        warn $branch;
        $remote = `git config branch.$branch.remote`;
        chomp $remote;
    }
    warn join(" ", "git", "fetch", $remote, "refs/pull/$num/head:pull-$num");
    system("git", "fetch", $remote, "refs/pull/$num/head:pull-$num");
}

sub CMD_pullreq {
    my ($title, $branch, $desc) = splice(@ARGV, 2);
    $title or die "Usage: $0 pullreq tokuhirom ph 'pull req title'\n";
    $branch ||= `git symbolic-ref -q HEAD` || 'master';
    $desc   ||= '';

    my ($user, $repo) = _get_user_repo('clone');
    my $res = $pithub->pull_requests->create(
        user => $user,
        repo => $repo,
        data => {
            title => $title,
            body  => $desc,
            head  => "$me:$branch",
            base  => 'master',
        },
    );
    $res->success or die dump_content($res->content);
}

sub CMD_add {
    my ($user, $repo) = _get_user_repo('clone');
    my $res = $pithub->repos->get(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    my $url = $res->content->{ssh_url} or die "Cannot get ssh_url";
    system("git remote add $user $url");
    system("git fetch $user");
}

sub CMD_all {
    my ($user) = shift @ARGV;
    $user or die "Usage: $0 all tokuhirom\n";
    my $res = $pithub->repos->list(user => $user);
    $res->success or die dump_content($res->content);
    $res->auto_pagination(1);
    while (my $row = $res->next) {
        say("-------- $row->{name} --------");
        next if $row->{fork}; # skip forked repos
        next if -e $row->{name};
        system("git", "clone", $row->{ssh_url});
    }
}

sub CMD_import {
    my $remote = 'origin';
    my $homepage = '';
    my $description = '';
    my $private = 0;
    GetOptions(
        'remote=s'      => \$remote,
        'homepage=s'    => \$homepage,
        'description=s' => \$description,
        'private'       => \$private,
    );
    if (`git config --local --get remote.$remote.fetch`) {
        Carp::croak "Remote [$remote] already exists. Try specifying another one using --remote.";
    }

    my $pwd = Cwd::getcwd();
    my $name = File::Basename::basename($pwd);
    exit unless prompt("Can I import $pwd to $name in github? [y/N] ", -yes);
    my $res = $pithub->repos->create(
        data => {
            name        => $name,
            homepage    => $homepage,
            description => $description,
            public      => $private ? 0 : 1,
        }
    );
    $res->success or die dump_content($res->content);
    dump_content($res->content);
    my $ssh_url = $res->content->{ssh_url} // die "Missing ssh_url";

    print "Adding GitHub repo $name as remote [$remote].\n";
    system(qw(git remote add), $remote, $ssh_url);

    if (!`git config --get branch.master.remote`) {
        print "Setting up remote [$remote] for master branch.\n";
        system(qw(git config branch.master.remote), $remote);
        system(qw(git config branch.master.merge refs/heads/master));
        my $rebase = `git config --get branch.autosetuprebase`;
        chomp $rebase;
        if ($rebase && ($rebase eq 'remote' || $rebase eq 'always')) {
            system(qw(git config branch.master.rebase true));
        }
    }

    print "Pushing to remote [$remote]\n";
    system(qw(git push), $remote, qw(master));
    print "Done.\n";
}

# ------------------------------------------------------------------------- 

sub _get_user_repo_simple() {
    my ($repo, $user);
    if (@ARGV==2) {
        ($user, $repo) = @ARGV;
    } elsif (@ARGV==1) {
        if ($ARGV[0] =~ m{/}) {
            ($user, $repo) = split m{/}, $ARGV[0];
        }
        else {
            ($user, $repo) = ($me, $ARGV[0]);
        }
    }
    return ($user, $repo);
}

sub _get_user_repo {
    my ($cmd) = @_;
    my ($user, $repo) = _get_user_repo_simple();
    $user // die "Usage: $0 $cmd miyagawa/Plack\n";
    return ($user, $repo);
}

sub _get_user_repo_with_current_repo {
    my ($cmd) = @_;
    my ($user, $repo) = _get_user_repo_simple();
    unless ($user && $repo) {
        my $remote = `git remote -v`;
        if ($remote =~ m{git://github\.com\/([^/ ]+)\/([^/ ]+)\.git}) {
            ($user, $repo) = ($1, $2);
        } elsif ($remote =~ m{git\@github\.com:([^/]+)/([^/]+)\.git}) {
            ($user, $repo) = ($1, $2);
        } else {
            die "Usage: $0 $cmd plack/Plack\n";
        }
    }
    return ($user, $repo);
}

our $DUMP_DEPTH = 0;
sub dump_content {
    local $DUMP_DEPTH = 0;
    my $c = shift;
    _dump_content($c);
}
sub _dump_content {
    my $c = shift;
    if (ref $c eq 'HASH') {
        for my $key (sort keys %$c) {
            print(' ' x ($DUMP_DEPTH*2));
            print($key . ': ');
            if (ref $c->{$key} eq 'HASH') {
                print("\n");
                local $DUMP_DEPTH = $DUMP_DEPTH + 1;
                _dump_content($c->{$key});
            } else {
                print("$c->{$key}");
                print("\n");
            }
        }
    }
}

# ------------------------------------------------------------------------- 

sub save_auth_result {
    my $res = shift;

    $res->is_success or die $res->as_string;
    my $dat = decode_json($res->content);
    $token = $dat->{token} || die "Cannot get token from API:\n\n" . $res->as_string;
    $token =~ /^[A-Za-z0-9_-]+$/ or die "API token contains bad char: $token";
    {
        no autodie;
        system("git config --global --unset-all ph.user");
        system("git config --global --unset-all ph.token");
    }
    system("git config --global --add ph.user $me") == 0 or die;
    system("git config --global --add ph.token $token") == 0 or die;
}

sub request_basic {
    my ($user, $password, $otp) = @_;
    my $res = $agent->request(
        do {
            my $req = HTTP::Request->new(
                POST => 'https://api.github.com/authorizations'
                # GET => 'https://github.com/login/oauth/authorize?client_id=45ee252fecc56cd85629&scopes=delete_repo,public_repo,repo,gist,user'
            );
            if (defined $otp) {
                $req->header('X-GitHub-OTP' => $otp);
            }
            $req->content(
                encode_json({
                    note   => 'App::ph on ' . Sys::Hostname::hostname,
                    scopes => [qw(delete_repo public_repo repo gist user)],
                })
            );
            $req->authorization_basic($me, $password);
            $req;
        }
    );
    return $res;
}

sub setup {
    say("setup ph. please input your id/pw to this prompt. password will not save to any location.");
    $me = prompt('user: ');
    my $pass = prompt('pass: ', -echo => '*');
    # request with basic auth.
    my $res = request_basic($me, $pass);
    if ($res->is_success) {
        save_auth_result($res);
        return;
    } else {
        if ($res->header('X-GitHub-OTP') =~ 'required') {
            my $otp = prompt('otp for 2-factor authentication: ');
            my $res = request_basic($me, $pass, $otp);
            save_auth_result($res);
            return;
        } else {
            die $res->as_string;
        }
    }
}

__END__

=pod

=head1 NAME

ph - Github CLI client

=head1 SYNOPSIS

    $ ph info mattn gal-vim
    $ ph clone mattn gal-vim
    $ ph import

=head1 DESCRIPTION

ph is yet another Github CLI client.

=head1 SUB COMMANDS

=head2 ph import

    % ph import

This command import current directory to the github.

=head2 ph fork

    % ph fork tokuhirom Minilla

This command forks the repository to your github account.

=head2 ph info

   % ph info mattn gal-vim

This command displays information of the repository.

=head2 ph help

    % ph help

Shows this help page.

=head2 ph all

    % ph all $USERNAME

Clone all repository in your account

=head2 ph version

Show the version number.

=head2 ph issues

    % ph issues

Show list of issues for current project.

