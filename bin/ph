#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Array/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR';
  package Array::Iterator;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  ### constructor
  
  sub new {
  	my ($_class, @array) = @_;
  	(@array)
          || die "Insufficient Arguments : you must provide something to iterate over";
  	my $class = ref($_class) || $_class;
  	my $_array;
  	if (scalar @array == 1) {
  		if (ref $array[0] eq "ARRAY") {
  		    $_array = $array[0];
  		}
  		elsif (ref $array[0] eq "HASH") {
  		    die "Incorrect type : HASH reference must contain the key __array__"
  		        unless exists $array[0]->{__array__};
  		    die "Incorrect type : __array__ value must be an ARRAY reference"
  		        unless ref $array[0]->{__array__} eq 'ARRAY';
  		    $_array = $array[0]->{__array__};
  		}
  		else {
  		    die "Incorrect Type : the argument must be an array or hash reference";
  		}
  	}
  	else {
  		$_array = \@array;
  	}
  	my $iterator = {
          _current_index => 0,
          _length => 0,
          _iteratee => [],
          _iterated => 0,
          };
  	bless($iterator, $class);
  	$iterator->_init(scalar(@{$_array}), $_array);
  	return $iterator;
  }
  
  ### methods
  
  # private methods
  
  sub _init {
  	my ($self, $length, $iteratee) = @_;
  	(defined($length) && defined($iteratee))
          || die "Insufficient Arguments : you must provide an length and an iteratee";
  	$self->{_current_index} = 0;
  	$self->{_length} = $length;
  	$self->{_iteratee} = $iteratee;
  }
  
  # protected method
  
  # this can be used in a subclass to access the value
  
  # we need to alter this so its an lvalue
  sub _current_index : lvalue {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
      $_[0]->{_current_index}
  }
  
  # this we should never need to alter
  # so we dont make it a lvalue
  sub _iteratee {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
      $_[0]->{_iteratee}
  }
  
  # we move this from a private method
  # to a protected one, and check our access
  # as well
  sub _getItem {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
  	my ($self, $iteratee, $index) = @_;
  	return $iteratee->[$index];
  }
  
  sub _get_item { my $self = shift; $self->_getItem(@_) }
  
  # we need to alter this so its an lvalue
  sub _iterated : lvalue {
      (UNIVERSAL::isa((caller)[0], __PACKAGE__))
          || die "Illegal Operation : This method can only be called by a subclass";
      $_[0]->{_iterated}
  }
  
  # public methods
  
  # this defines the interface
  # an iterator object will have
  
  sub iterated {
      my ($self) = @_;
      return $self->{_iterated};
  }
  
  sub has_next {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "has_next(0) doesn't make sense, did you mean current()?" }
      elsif($n < 0)      { die "has_next() with negative argument doesn't make sense, perhaps you should use a BiDirectional iterator" }
  
      my $idx = $self->{_current_index} + ($n - 1);
  
  	return ($idx < $self->{_length}) ? 1 : 0;
  }
  
  sub hasNext { my $self = shift; $self->has_next(@_) }
  
  sub next {
  	my ($self) = @_;
      ($self->{_current_index} < $self->{_length})
          || die "Out Of Bounds : no more elements";
          $self->{_iterated} = 1;
  	return $self->_getItem($self->{_iteratee}, $self->{_current_index}++);
  }
  
  sub get_next {
  	my ($self) = @_;
          $self->{_iterated} = 1;
      return undef unless ($self->{_current_index} < $self->{_length});
  	return $self->_getItem($self->{_iteratee}, $self->{_current_index}++);
  }
  
  sub getNext { my $self = shift; $self->get_next(@_) }
  
  sub peek {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "peek(0) doesn't make sense, did you mean get_next()?" }
      elsif($n < 0)      { die "peek() with negative argument doesn't make sense, perhaps you should use a BiDirectional iterator" }
  
      my $idx = $self->{_current_index} + ($n - 1);
  
      return undef unless ($idx < $self->{_length});
  	return $self->_getItem($self->{_iteratee}, $idx);
  }
  
  sub current {
  	my ($self) = @_;
  	return $self->_getItem($self->{_iteratee}, $self->currentIndex());
  }
  
  sub current_index {
  	my ($self) = @_;
  	return ($self->{_current_index} != 0) ? $self->{_current_index} - 1 : 0;
  }
  
  sub currentIndex { my $self = shift; $self->current_index(@_) }
  
  sub get_length {
      my ($self) = @_;
      return $self->{_length};
  }
  
  sub getLength { my $self = shift; $self->get_length(@_) }
  
  1;
  #ABSTRACT: A simple class for iterating over Perl arrays
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator - A simple class for iterating over Perl arrays
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator;
  
    # create an iterator with an array
    my $i = Array::Iterator->new(1 .. 100);
  
    # create an iterator with an array reference
    my $i = Array::Iterator->new(\@array);
  
    # create an iterator with a hash reference
    my $i = Array::Iterator->new({ __array__ => \@array });
  
    # a base iterator example
    while ($i->has_next()) {
        if ($i->peek() < 50) {
            # ... do something because
            # the next element is over 50
        }
        my $current = $i->next();
        # ... do something with current
    }
  
    # shortcut style
    my @accumulation;
    push @accumulation => { item => $iterator->next() } while $iterator->has_next();
  
    # C++ ish style iterator
    for (my $i = Array::Iterator->new(@array); $i->has_next(); $i->next()) {
      my $current = $i->current();
      # .. do something with current
    }
  
    # common perl iterator idiom
    my $current;
    while ($current = $i->get_next()) {
      # ... do something with $current
    }
  
  =head1 DESCRIPTION
  
  This class provides a very simple iterator interface. It is is uni-directional
  and can only be used once. It provides no means of reverseing or reseting the
  iterator. It is not recommended to alter the array during iteration, however
  no attempt is made to enforce this (although I will if I can find an efficient
  means of doing so). This class only intends to provide a clear and simple
  means of generic iteration, nothing more (yet).
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  =head2 Public Methods
  
  =over 4
  
  =item B<new (@array | $array_ref | $hash_ref)>
  
  The constructor can be passed either a plain perl array, an array reference,
  or a hash reference (with the array specified as a single key off the hash,
  __array__). Single element arrays are not supported by either of the first
  two calling conventions, since it is not possible to distinguish between an
  array of a single element which happens to be an array reference, and an
  array reference of a single element, thus previous versions of the constructor
  would raise an exception. If you expect to pass arrays to the constructor which
  may have only a single element, then the array can be passed as the element
  of a HASH reference, with the key, __array__:
  
    my $i = Array::Iterator->new({ __array__ => \@array });
  
  =item B<has_next([$n])>
  
  This methods returns a boolean. True (1) if there are still more elements in
  the iterator, false (0) if there are not.
  
  Takes an optional positive integer (E<gt> 0) that specifies the position you
  want to check. This allows you to check if there an element at arbitrary position.
  Think of it as an ordinal number you want to check:
  
    $i->has_next(2);  # 2nd next element
    $i->has_next(10); # 10th next element
  
  Note that C<has_next(1)> is the same as C<has_next()>.
  
  Throws an exception if C<$n> E<lt>= 0.
  
  =item B<next>
  
  This method returns the next item in the iterator, be sure to only call this
  once per iteration as it will advance the index pointer to the next item. If
  this method is called after all elements have been exhausted, an exception
  will be thrown.
  
  =item B<get_next>
  
  This method returns the next item in the iterator, be sure to only call this
  once per iteration as it will advance the index pointer to the next item. If
  this method is called after all elements have been exhausted, it will return
  undef.
  
  This method was added to allow for a faily common perl iterator idiom of:
  
    my $current;
    while ($current = $i->get_next()) {
        ...
    }
  
  In this the loop terminates once C<$current> is assigned to a false value.
  The only problem with this idiom for me is that it does not allow for
  undefined or false values in the iterator. Of course, if this fits your
  data, then there is no problem. Otherwise I would recommend the C<has_next>/C<next>
  idiom instead.
  
  =item B<peek([$n])>
  
  This method can be used to peek ahead at the next item in the iterator. It
  is non-destructuve, meaning it does not advance the internal pointer. If
  this method is called and attempts to reach beyond the bounds of the iterator,
  it will return undef.
  
  Takes an optional positive integer (E<gt> 0) that specifies how far ahead you want to peek:
  
    $i->peek(2);  # gives you 2nd next element
    $i->peek(10); # gives you 10th next element
  
  Note that C<peek(1)> is the same as C<peek()>.
  
  Throws an exception if C<$n> E<lt>= 0.
  
  B<NOTE:> Prior to version 0.03 this method would throw an exception if called
  out of bounds. I decided this was not a good practice, as it made it difficult
  to be able to peek ahead effectively. This not the case when calling with an argument
  that is E<lt>= 0 though, as it's clearly a sign of incorrect usage.
  
  =item B<current>
  
  This method can be used to get the current item in the iterator. It is non-destructive,
  meaning that it does not advance the internal pointer. This value will match the
  last value dispensed by C<next> or C<get_next>.
  
  =item B<current_index>
  
  This method can be used to get the current index in the iterator. It is non-destructive,
  meaning that it does not advance the internal pointer. This value will match the index
  of the last value dispensed by C<next> or C<get_next>.
  
  =item B<get_length>
  
  This is a basic accessor for getting the length of the array being iterated over.
  
  =back
  
  =head2 Protected Methods
  
  These methods are I<protected>, in the Java/C++ sense of the word. They can only be
  called internally by subclasses of Array::Iterator, an exception is thrown if that
  condition is violated. They are documented here only for people interested in
  subclassing Array::Iterator.
  
  =over 4
  
  =item B<_current_index>
  
  An lvalue-ed subroutine which allows access to the iterator's internal pointer.
  
  =item B<_iteratee>
  
  This returns the item being iteratated over, in our case an array.
  
  =item B<_get_item ($iteratee, $index)>
  
  This method is used by all other routines to access items with. Given the iteratee
  and an index, it will return the item being stored in the C<$iteratee> at the index
  of C<$index>.
  
  =back
  
  =head1 TO DO
  
  =over 4
  
  =item Improve BiDirectional Test suite
  
  I want to test the back and forth a little more, make sure they work well with
  one another.
  
  =item Other Iterators
  
  Array::Iterator::BiDirectional::Circular, Array::Iterator::Skipable and
  Array::Iterator::BiDirectional::Skipable are just a few ideas I have had. I am going
  to hold off for now until I am sure they are actually useful.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of. The code is pretty thoroughly tested (see L<CODE COVERAGE> below)
  and is based on an (non-publicly released) module which I had used in production systems
  for about 2 years without incident. Of course, if you find a bug, let me know, and I will
  be sure to fix it.
  
  =head1 CODE COVERAGE
  
  I use B<Devel::Cover> to test the code coverage of my tests, below is the B<Devel::Cover>
  report on this module's test suite.
  
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
   File                              stmt   bran   cond    sub    pod   time  total
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
   Array/Iterator.pm                100.0  100.0   66.7  100.0  100.0   67.6   98.2
   Array/Iterator/BiDirectional.pm  100.0  100.0    n/a  100.0  100.0   20.2  100.0
   Array/Iterator/Circular.pm       100.0  100.0    n/a  100.0  100.0    7.1  100.0
   Array/Iterator/Reusable.pm       100.0    n/a    n/a  100.0  100.0    5.0  100.0
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
   Total                            100.0  100.0   66.7  100.0  100.0  100.0   99.0
   ------------------------------- ------ ------ ------ ------ ------ ------ ------
  
  =head1 SEE ALSO
  
  This module now includes several subclasses of Array::Iterator which add certain behaviors
  to Array::Iterator, they are:
  
  =over 4
  
  =item B<Array::Iterator::BiDirectional>
  
  Adds the ability to move backwards and forwards through the array.
  
  =item B<Array::Iterator::Circular>
  
  When this iterator reaches the end of its list, it will loop back to the start again.
  
  =item B<Array::Iterator::Reusable>
  
  This iterator can be reset to its beginning and used again.
  
  =back
  
  The Design Patterns book by the Gang of Four, specifically the Iterator pattern.
  
  Some of the interface for this class is based upon the Java Iterator interface.
  
  =head1 OTHER ITERATOR MODULES
  
  There are a number of modules on CPAN with the word Iterator in them. Most of them are
  actually iterators included inside other modules, and only really useful within that
  parent modules context. There are however some other modules out there that are just
  for pure iteration. I have provided a list below of the ones I have found, if perhaps
  you don't happen to like the way I do it.
  
  =over 4
  
  =item B<Tie::Array::Iterable>
  
  This module ties the array, something we do not do. But it also makes an attempt to
  account for, and allow the array to be changed during iteration. It accomplishes this
  control because the underlying array is tied. As we all know, tie-ing things can be a
  performance issue, but if you need what this module provides, then it will likely be
  an acceptable compromise. Array::Iterator makes no attempt to deal with this mid-iteration
  manipulation problem. In fact it is recommened to not alter your array with Array::Iterator,
  and if possible we will enforce this in later versions.
  
  =item B<Data::Iter>
  
  This module allows for simple iteratation over both hashes and arrays. It does it by
  importing several functions which can be used to loop over either type (hash or array)
  in the same way. It is an interesting module, it differs from Array::Iterator in
  paradigm (Array::Iterator is more OO) as well as in intent.
  
  =item B<Class::Iterator>
  
  This is essentially a wrapper around a closure based iterator. This method can be very
  flexible, but at times is difficult to manage due to the inherent complextity of using
  closures. I actually was a closure-as-iterator fan for a while, but eventually moved
  away from it in favor of the more plain vanilla means of iteration, like that found
  Array::Iterator.
  
  =item B<Class::Iter>
  
  This is part of the Class::Visitor module, and is a Visitor and Iterator extensions to
  Class::Template. Array::Iterator is a standalone module not associated with others.
  
  =item B<Data::Iterator::EasyObj>
  
  Data::Iterator::EasyObj makes your array of arrays into iterator objects. It also has
  the ability to further nest additional data structures including Data::Iterator::EasyObj
  objects. Array::Iterator is one dimensional only, and does not attempt to do many of
  the more advanced features of this module.
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item Thanks to Hugo Cornelis for pointing out a bug in C<peek()>
  
  =item Thanks to Phillip Moore for providing the patch to allow single element iteration
  through the hash-ref constructor parameter.
  
  =back
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004, 2005 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR

$fatpacked{"Array/Iterator/BiDirectional.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR_BIDIRECTIONAL';
  
  package Array::Iterator::BiDirectional;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  use Array::Iterator;
  our @ISA = qw(Array::Iterator);
  
  sub has_previous {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "has_previous(0) doesn't make sense, did you mean current()?" }
      elsif($n < 0)      { die "has_previous() with negative argument doesn't make sense, did you mean has_next()?" }
  
      my $idx = $self->_current_index - $n;
  
  	return ($idx > 0) ? 1 : 0;
  }
  
  sub hasPrevious { my $self = shift; $self->has_previous(@_) }
  
  sub previous {
  	my ($self) = @_;
      (($self->_current_index - 1) > 0)
          || die "Out Of Bounds : no more elements";
          $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee, --$self->_current_index);
  }
  
  sub get_previous {
  	my ($self) = @_;
      return undef unless (($self->_current_index - 1) > 0);
          $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee, --$self->_current_index);
  }
  
  sub getPrevious { my $self = shift; $self->get_previous(@_) }
  
  sub look_back {
  	my ($self, $n) = @_;
  
      if(not defined $n) { $n = 1 }
      elsif(not $n)      { die "look_back(0) doesn't make sense, did you mean get_previous()?" }
      elsif($n < 0)      { die "look_back() with negative argument doesn't make sense, did you mean get_next()?" }
  
      my $idx = $self->_current_index - ($n + 1);
  
      return undef unless ($idx > 0);
      $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee, $idx);
  }
  
  sub lookBack { my $self = shift; $self->look_back(@_) }
  
  1;
  #ABSTRACT: A subclass of Array::Iterator to allow forwards and backwards iteration
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator::BiDirectional - A subclass of Array::Iterator to allow forwards and backwards iteration
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator::BiDirectional;
  
    # create an instance of the iterator
    my $i = Array::Iterator::BiDirectional->new(1 .. 100);
  
    while ($some_condition_exists) {
        # get the latest item from
        # the iterator
        my $current = $i->get_next();
        # ...
        if ($something_happens) {
            # back up the iterator
            $current = $i->get_previous();
        }
    }
  
  =head1 DESCRIPTION
  
  Occasionally it is useful for an iterator to go in both directions, forward and backward. One example would be token processing. When looping though tokens it is sometimes necessary to advance forward looking for a match to a rule. If the match fails, a bi-directional iterator can be moved back so that the next rule can be tried.
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  This is a subclass of Array::Iterator, only those methods that have been added are documented here, refer to the Array::Iterator documentation for more information.
  
  =over 4
  
  =item B<has_previous([$n])>
  
  This method works much like C<hasNext> does, it will return true (C<1>) unless the beginning of the array has been reached, and false (C<0>) otherwise.
  
  Optional argument has the same meaning except that it specifies C<$n>th previous element.
  
  =item B<previous>
  
  This method is much like C<next>. It will return the previous item in the iterator, and throw an exception if it attempts to reach past the beginning of the array.
  
  =item B<get_previous>
  
  This method is much like C<get_next>. It will return the previous item in the iterator, and return undef if it attempts to reach past the beginning of the array.
  
  =item B<look_back([$n])>
  
  This is the counterpart to C<peek>, it will return the previous items in the iterator, but will not affect the internal counter.
  
  Optional argument has the same meaning except that it specifies C<$n>th previous element.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of, if you find a bug, let me know, and I will be sure to fix it.
  
  =head1 CODE COVERAGE
  
  See the B<CODE COVERAGE> section of the B<Array::Iterator> documentation for information about the code coverage of this module's test suite.
  
  =head1 SEE ALSO
  
  This is a subclass of B<Array::Iterator>, please refer to it for more documenation.
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR_BIDIRECTIONAL

$fatpacked{"Array/Iterator/Circular.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR_CIRCULAR';
  
  package Array::Iterator::Circular;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  use Array::Iterator;
  our @ISA = qw(Array::Iterator);
  
  sub _init {
      my ($self, @args) = @_;
      $self->{loop_counter} = 0;
      $self->SUPER::_init(@args);
  }
  
  # always return true, since
  # we just keep looping
  sub has_next { 1 }
  
  sub next {
  	my ($self) = @_;
      unless ($self->_current_index < $self->getLength()) {
          $self->_current_index = 0;
          $self->{loop_counter}++;
      }
          $self->_iterated = 1;
  	return $self->_getItem($self->_iteratee(), $self->_current_index++);
  }
  
  # since neither of them will
  # ever stop dispensing items
  # they can just be aliases of
  # one another.
  *get_next = \&next;
  
  sub is_start {
      my ($self) = @_;
      return ($self->_current_index() == 0);
  }
  
  sub isStart { my $self = shift; $self->is_start(@_) }
  
  sub is_end {
      my ($self) = @_;
      return ($self->_current_index() == $self->getLength());
  }
  
  sub isEnd { my $self = shift; $self->is_end(@_) }
  
  sub get_loop_count {
      my ($self) = @_;
      return $self->{loop_counter};
  }
  
  sub getLoopCount { my $self = shift; $self->get_loop_count(@_) }
  
  1;
  #ABSTRACT: A subclass of Array::Iterator to allow circular iteration
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator::Circular - A subclass of Array::Iterator to allow circular iteration
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator::Circular;
  
    # create an instance with a
    # small array
    my $color_iterator = Array::Iterator::Circular->new(qw(red green blue orange));
  
    # this is a large list of
    # arbitrary items
    my @long_list_of_items = ( ... );
  
    # as we loop through the items ...
    foreach my $item (@long_list_of_items) {
        # we assign color from our color
        # iterator, which will keep dispensing
        # as it loops through its set
        $item->set_color($color_iterator->next());
    }
  
    # tell us how many times the set
    # was looped through
    print $color_iterator->get_loop_count();
  
  =head1 DESCRIPTION
  
  This iterator will loop continuosly as long as C<next> or C<get_next> is called. The C<has_next> method will always return true (C<1>), since the list will always loop back. This is useful when you need a list to repeat itself, but don't want to (or care to) know that it is doing so.
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  This is a subclass of Array::Iterator, only those methods that have been added or altered are documented here, refer to the Array::Iterator documentation for more information.
  
  =over 4
  
  =item B<has_next>
  
  Since we endlessly loop, this will always return true (C<1>).
  
  =item B<next>
  
  This will return the next item in the array, and when it reaches the end of the array, it will loop back to the beginning again.
  
  =item B<get_next>
  
  This method is now defined in terms of C<next>, since neither will even stop dispensing items, there is no need to differentiate.
  
  =item B<is_start>
  
  If at anytime during your looping, you want to know if you have arrived back at the start of you list, you can ask this method.
  
  =item B<is_end>
  
  If at anytime during your looping, you want to know if you have gotten to the end of you list, you can ask this method.
  
  =item B<get_loop_count>
  
  This method will tell you how many times the iterator has looped back to its start.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of, if you find a bug, let me know, and I will be sure to fix it.
  
  =head1 CODE COVERAGE
  
  See the B<CODE COVERAGE> section of the B<Array::Iterator> documentation for information about the code coverage of this module's test suite.
  
  =head1 SEE ALSO
  
  This is a subclass of B<Array::Iterator>, please refer to it for more documenation.
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR_CIRCULAR

$fatpacked{"Array/Iterator/Reusable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARRAY_ITERATOR_REUSABLE';
  
  package Array::Iterator::Reusable;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11'; # VERSION
  
  use Array::Iterator;
  our @ISA = qw(Array::Iterator);
  
  sub reset {
      my ($self) = @_;
      $self->_iterated = 0;
      $self->_current_index = 0;
  }
  
  1;
  #ABSTRACT: A subclass of Array::Iterator to allow reuse of iterators
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Array::Iterator::Reusable - A subclass of Array::Iterator to allow reuse of iterators
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    use Array::Iterator::Reusable;
  
    # create an iterator with an array
    my $i = Array::Iterator::Reusable->new(1 .. 100);
  
    # do something with the iterator
    my @accumulation;
    push @accumulation => { item => $iterator->next() } while $iterator->has_next();
  
    # now reset the iterator so we can do it again
    $iterator->reset();
  
  =head1 DESCRIPTION
  
  Sometimes you don't want to have to throw out your iterator each time you have exhausted it. This class adds the C<reset> method to allow reuse of an iterator. This is a very simple addition to the Array::Iterator class of a single method.
  
  =for Pod::Coverage .+
  
  =head1 METHODS
  
  This is a subclass of Array::Iterator, only those methods that have been added are documented here, refer to the Array::Iterator documentation for more information.
  
  =over 4
  
  =item B<reset>
  
  This resets the interal counter of the iterator back to the start of the array.
  
  =back
  
  =head1 BUGS
  
  None that I am aware of, if you find a bug, let me know, and I will be sure to fix it.
  
  =head1 CODE COVERAGE
  
  See the B<CODE COVERAGE> section of the B<Array::Iterator> documentation for information about the code coverage of this module's test suite.
  
  =head1 SEE ALSO
  
  This is a subclass of B<Array::Iterator>, please refer to it for more documenation.
  
  =head1 ORIGINAL AUTHOR
  
  stevan little, E<lt>stevan@iinteractive.comE<gt>
  
  =head1 ORIGINAL COPYRIGHT AND LICENSE
  
  Copyright 2004 by Infinity Interactive, Inc.
  
  L<http://www.iinteractive.com>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
ARRAY_ITERATOR_REUSABLE

$fatpacked{"Cache/LRU.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CACHE_LRU';
  package Cache::LRU;
  
  use strict;
  use warnings;
  
  use 5.008_001;
  
  use Scalar::Util qw();
  
  our $VERSION = '0.04';
  
  sub GC_FACTOR () { 10 }
  
  sub new {
      my ($klass, %args) = @_;
      return bless {
          size    => 1024,
          %args,
          _entries => {}, # $key => $weak_valueref
          _fifo    => [], # fifo queue of [ $key, $valueref ]
      }, $klass;
  }
  
  sub set {
      my ($self, $key, $value) = @_;
  
      my $entries = $self->{_entries};
  
      if (my $old_value_ref = $entries->{$key}) {
          $$old_value_ref = undef;
      }
  
      # register
      my $value_ref = \$value;
      Scalar::Util::weaken($entries->{$key} = $value_ref);
      $self->_update_fifo($key, $value_ref);
  
      # expire the oldest entry if full
      while (scalar(keys %$entries) > $self->{size}) {
          my $exp_key = shift(@{$self->{_fifo}})->[0];
          delete $entries->{$exp_key}
              unless $entries->{$exp_key};
      }
  
      $value;
  }
  
  sub remove {
      my ($self, $key) = @_;
      my $value_ref = delete $self->{_entries}->{$key};
      return undef unless $value_ref;
      my $value = $$value_ref;
      $$value_ref = undef;
      $value;
  }
  
  sub get {
      my ($self, $key) = @_;
  
      my $value_ref = $self->{_entries}->{$key};
      return undef unless $value_ref;
  
      $self->_update_fifo($key, $value_ref);
      $$value_ref;
  }
  
  sub clear {
      my $self = shift;
  
      $self->{_entries} = {};
      $self->{_fifo} = [];    
  }
  
  sub _update_fifo {
      # precondition: $self->{_entries} should contain given key
      my ($self, $key, $value_ref) = @_;
      my $fifo = $self->{_fifo};
  
      push @$fifo, [ $key, $value_ref ];
      if (@$fifo >= $self->{size} * GC_FACTOR) {
          my $entries = $self->{_entries};
          my @new_fifo;
          my %need = map { $_ => 1 } keys %$entries;
          while (%need) {
              my $fifo_entry = pop @$fifo;
              unshift @new_fifo, $fifo_entry
                  if delete $need{$fifo_entry->[0]};
          }
          $self->{_fifo} = \@new_fifo;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Cache::LRU - a simple, fast implementation of LRU cache in pure perl
  
  =head1 SYNOPSIS
  
      use Cache::LRU;
  
      my $cache = Cache::LRU->new(
          size => $max_num_of_entries,
      );
  
      $cache->set($key => $value);
  
      $value = $cache->get($key);
  
      $removed_value = $cache->remove($key);
  
  =head1 DESCRIPTION
  
  Cache::LRU is a simple, fast implementation of an in-memory LRU cache in pure perl.
  
  =head1 FUNCTIONS
  
  =head2 Cache::LRU->new(size => $max_num_of_entries)
  
  Creates a new cache object.  Takes a hash as the only argument.  The only parameter currently recognized is the C<size> parameter that specifies the maximum number of entries to be stored within the cache object.
  
  =head2 $cache->get($key)
  
  Returns the cached object if exists, or undef otherwise.
  
  =head2 $cache->set($key => $value)
  
  Stores the given key-value pair.
  
  =head2 $cache->remove($key)
  
  Removes data associated to the given key and returns the old value, if any.
  
  =head2 $cache->clear($key)
  
  Removes all entries from the cache.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  =head1 SEE ALSO
  
  L<Cache>
  
  L<Cache::Ref>
  
  L<Tie::Cache::LRU>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  See <http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
CACHE_LRU

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.13';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Encode/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENCODE_LOCALE';
  package Encode::Locale;
  
  use strict;
  our $VERSION = "1.05";
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetACP) {
  		    require Win32;
                      eval { Win32::GetACP() };
  		    *GetACP = sub { &Win32::GetACP } unless $@;
  		}
  		unless (defined &GetACP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetACP()');
  		}
  		if (defined &GetACP) {
  		    my $cp = GetACP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
              # only test one since set together
              unless (defined &GetInputCP) {
                  eval {
                      require Win32;
                      eval { Win32::GetConsoleCP() };
                      # manually "import" it since Win32->import refuses
                      *GetInputCP = sub { &Win32::GetConsoleCP } unless $@;
                      *GetOutputCP = sub { &Win32::GetConsoleOutputCP } unless $@;
                  };
                  unless (defined &GetInputCP) {
                      eval {
                          # try Win32::Console module for codepage to use
                          require Win32::Console;
                          eval { Win32::Console::InputCP() };
                          *GetInputCP = sub { &Win32::Console::InputCP }
                              unless $@;
                          *GetOutputCP = sub { &Win32::Console::OutputCP }
                              unless $@;
                      };
                  }
                  unless (defined &GetInputCP) {
                      # final fallback
                      *GetInputCP = *GetOutputCP = sub {
                          # another fallback that could work is:
                          # reg query HKLM\System\CurrentControlSet\Control\Nls\CodePage /v ACP
                          ((qx(chcp) || '') =~ /^Active code page: (\d+)/)
                              ? $1 : ();
                      };
                  }
  	    }
              my $cp = GetInputCP();
              $ENCODING_CONSOLE_IN = "cp$cp" if $cp;
              $cp = GetOutputCP();
              $ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode::Locale - Determine the locale encoding
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output to the terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suitable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>, L<Term::Encoding>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
ENCODE_LOCALE

$fatpacked{"HTTP/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use warnings;
  
  use URI;
  
  our $VERSION = "6.11";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              no warnings 'uninitialized';
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.02";
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  will be the full 4-digit year, and $month numbers start with 1 (for January).
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned (C<undef> in
  scalar context).
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use warnings;
  
  use Carp ();
  
  our $VERSION = "6.11";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  our $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      if (exists $self->{'::std_case'}) {
  	$c->{'::std_case'} = $self->{'::std_case'};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      Carp::croak("Illegal field name '$field'")
          if rindex($field, ':') > 1 || !length($field);
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless($standard_case{$field} || $self->{'::std_case'}{$field}) {
  	    # generate a %std_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $self->{'::std_case'}{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } grep !/^::/, keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $self->{'::std_case'}{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return grep !/^::/, keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $vals);
  	}
      }
  }
  
  sub flatten {
  	my($self)=@_;
  
  	(
  		map {
  			my $k = $_;
  			map {
  				( $k => $_ )
  			} $self->header($_);
  		} $self->header_field_names
  	);
  }
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		$val = '' if not defined $val;
  		my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    $vals = '' if not defined $vals;
  	    my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promises that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->flatten()
  
  Returns the list of pairs of keys and values.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use warnings;
  
  our $VERSION = "6.11";
  
  use HTTP::Headers;
  
  package
      HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use warnings;
  
  our $VERSION = "6.11";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package
      HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use warnings;
  
  our $VERSION = "6.11";
  
  use base 'Exporter';
  
  our @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessarily be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use warnings;
  
  our $VERSION = "6.11";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  unless ($HTTP::URI_CLASS) {
      if ($ENV{PERL_HTTP_URI_CLASS}
      &&  $ENV{PERL_HTTP_URI_CLASS} =~ /^([\w:]+)$/) {
          $HTTP::URI_CLASS = $1;
      } else {
          $HTTP::URI_CLASS = "URI";
      }
  }
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16LE" if /^\xFF\xFE/;
  	return "UTF-16BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32BE" if /^\x00\x00\x00</;
  	    return "UTF-32LE" if /^<\x00\x00\x00/;
  	    return "UTF-16BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	require IO::HTML;
  	# Use relaxed search to match previous versions of HTTP::Message:
  	my $encoding = IO::HTML::find_charset_in($$cref, { encoding    => 1,
  	                                                   need_pragma => 0 });
  	return $encoding->mime_name if $encoding;
      }
      elsif ($self->content_type eq "application/json") {
  	for ($$cref) {
  	    # RFC 4627, ch 3
  	    return "UTF-32BE" if /^\x00\x00\x00./s;
  	    return "UTF-32LE" if /^.\x00\x00\x00/s;
  	    return "UTF-16BE" if /^\x00.\x00./s;
  	    return "UTF-16LE" if /^.\x00.\x00/s;
  	    return "UTF-8";
  	}
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity" || $ce eq "none";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2" or $ce eq "bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it as is
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = $opt{no_content};
  	$no_content = "(no content)" unless defined $no_content;
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = $no_content;
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  # allow subclasses to override what will handle individual parts
  sub _part_class {
      return __PACKAGE__;
  }
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = $self->_part_class->new(
  	    $self->remove_content_headers,
  	    $self->content(""),
  	);
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls to the headers object.
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { local $Carp::Internal{+__PACKAGE__} = 1; shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map $self->_part_class->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ $self->_part_class->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If a @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item no_content => $str
  
  Replaces the "(no content)" marker.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST';
  package HTTP::Request;
  
  use strict;
  use warnings;
  
  use base 'HTTP::Message';
  
  our $VERSION = "6.11";
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parsable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use warnings;
  
  our $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  use Exporter 5.57 'import';
  
  our @EXPORT =qw(GET HEAD PUT POST);
  our @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  our $VERSION = "6.11";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  for my $type (qw(PUT POST)) {
      no strict 'refs';
      *{ __PACKAGE__ . "::" . $type } = sub {
          return request_type_with_data($type, @_);
      };
  }
  
  sub request_type_with_data
  {
      my $type = shift;
      my $url  = shift;
      my $req = HTTP::Request->new($type => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  
  	    # HTML/4.01 says that line breaks are represented as "CR LF" pairs (i.e., `%0D%0A')
  	    $content =~ s/(?<!%0D)%0A/%0D%0A/g if defined($content);
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      while (my ($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
              no warnings 'uninitialized';
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate an HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create an HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create an HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_RESPONSE';
  package HTTP::Response;
  
  use strict;
  use warnings;
  
  use base 'HTTP::Message';
  
  our $VERSION = "6.11";
  
  use HTTP::Status ();
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  sub is_client_error { HTTP::Status::is_client_error (shift->{'_rc'}); }
  sub is_server_error { HTTP::Status::is_server_error (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meanings of these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of an HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  =item $r->is_client_error
  
  =item $r->is_server_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  use warnings;
  
  require 5.002;   # because we use prototypes
  
  use base 'Exporter';
  our @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  our @EXPORT_OK = qw(is_client_error is_server_error);
  
  our $VERSION = "6.11";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      208 => 'Already Reported',		      # RFC 5842
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      308 => 'Permanent Redirect',              # RFC 7238
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      418 => 'I\'m a teapot',		      # RFC 2324
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      428 => 'Precondition Required',
      429 => 'Too Many Requests',
      431 => 'Request Header Fields Too Large',
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
      511 => 'Network Authentication Required',
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ s/I'm/I am/;
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  our %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of an HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
     HTTP_ALREADY_REPORTED		(208)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
     HTTP_PERMANENT_REDIRECT              (308)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_I_AM_A_TEAPOT			(418)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_PRECONDITION_REQUIRED		(428)
     HTTP_TOO_MANY_REQUESTS		(429)
     HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
     HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  returns TRUE for both client and server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is a I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is a I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explicit imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"IPC/System/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_SYSTEM_SIMPLE';
  package IPC::System::Simple;
  
  # ABSTRACT: Run commands simply, with detailed diagnostics
  
  use 5.006;
  use strict;
  use warnings;
  use re 'taint';
  use Carp;
  use List::Util qw(first);
  use Scalar::Util qw(tainted);
  use Config;
  use constant WINDOWS => ($^O eq 'MSWin32');
  use constant VMS     => ($^O eq 'VMS');
  
  BEGIN {
  
      # It would be lovely to use the 'if' module here, but it didn't
      # enter core until 5.6.2, and we want to keep 5.6.0 compatibility.
  
  
      if (WINDOWS) {
  
          ## no critic (ProhibitStringyEval)
  
          eval q{
              use Win32::Process qw(INFINITE NORMAL_PRIORITY_CLASS);
              use File::Spec;
              use Win32;
  
              # This uses the same rules as the core win32.c/get_shell() call.
  
              use constant WINDOWS_SHELL => eval { Win32::IsWinNT() }
                                              ? [ qw(cmd.exe /x/d/c) ]
                                              : [ qw(command.com /c) ];
  
              # These are used when invoking _win32_capture
              use constant NO_SHELL  => 0;
              use constant USE_SHELL => 1;
  
          };
  
          ## use critic
  
          # Die nosily if any of the above broke.
          die $@ if $@;
      }
  }
  
  # Note that we don't use WIFSTOPPED because perl never uses
  # the WUNTRACED flag, and hence will never return early from
  # system() if the child processes is suspended with a SIGSTOP.
  
  use POSIX qw(WIFEXITED WEXITSTATUS WIFSIGNALED WTERMSIG);
  
  use constant FAIL_START     => q{"%s" failed to start: "%s"};
  use constant FAIL_PLUMBING  => q{Error in IPC::System::Simple plumbing: "%s" - "%s"};
  use constant FAIL_CMD_BLANK => q{Entirely blank command passed: "%s"};
  use constant FAIL_INTERNAL  => q{Internal error in IPC::System::Simple: "%s"};
  use constant FAIL_TAINT     => q{%s called with tainted argument "%s"};
  use constant FAIL_TAINT_ENV => q{%s called with tainted environment $ENV{%s}};
  use constant FAIL_SIGNAL    => q{"%s" died to signal "%s" (%d)%s};
  use constant FAIL_BADEXIT   => q{"%s" unexpectedly returned exit value %d};
  
  use constant FAIL_UNDEF     => q{%s called with undefined command};
  
  use constant FAIL_POSIX     => q{IPC::System::Simple does not understand the POSIX error '%s'.  Please check http://search.cpan.org/perldoc?IPC::System::Simple to see if there is an updated version.  If not please report this as a bug to http://rt.cpan.org/Public/Bug/Report.html?Queue=IPC-System-Simple};
  
  # On Perl's older than 5.8.x we can't assume that there'll be a
  # $^{TAINT} for us to check, so we assume that our args may always
  # be tainted.
  use constant ASSUME_TAINTED => ($] < 5.008);
  
  use constant EXIT_ANY_CONST => -1;			# Used internally
  use constant EXIT_ANY       => [ EXIT_ANY_CONST ];	# Exported
  
  use constant UNDEFINED_POSIX_RE => qr{not (?:defined|a valid) POSIX macro|not implemented on this architecture};
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT_OK = qw( 
      capture  capturex
      run      runx
      system   systemx
      $EXITVAL EXIT_ANY
  );
  
  our $VERSION = '1.25'; # VERSION : From dzil
  our $EXITVAL = -1;
  
  my @Signal_from_number = split(' ', $Config{sig_name});
  
  # Environment variables we don't want to see tainted.
  my @Check_tainted_env = qw(PATH IFS CDPATH ENV BASH_ENV);
  if (WINDOWS) {
  	push(@Check_tainted_env, 'PERL5SHELL');
  }
  if (VMS) {
  	push(@Check_tainted_env, 'DCL$PATH');
  }
  
  # Not all systems implement the WIFEXITED calls, but POSIX
  # will always export them (even if they're just stubs that
  # die with an error).  Test for the presence of a working
  # WIFEXITED and friends, or define our own.
  
  eval { WIFEXITED(0); };
  
  if ($@ =~ UNDEFINED_POSIX_RE) {
          no warnings 'redefine';  ## no critic
  	*WIFEXITED   = sub { not $_[0] & 0xff };
  	*WEXITSTATUS = sub { $_[0] >> 8  };
  	*WIFSIGNALED = sub { $_[0] & 127 };
  	*WTERMSIG    = sub { $_[0] & 127 };
  } elsif ($@) {
  	croak sprintf FAIL_POSIX, $@;
  }
  
  # None of the POSIX modules I've found define WCOREDUMP, although
  # many systems define it.  Check the POSIX module in the hope that
  # it may actually be there.
  
  
  # TODO: Ideally, $NATIVE_WCOREDUMP should be a constant.
  
  my $NATIVE_WCOREDUMP;
  
  eval { POSIX::WCOREDUMP(1); };
  
  if ($@ =~ UNDEFINED_POSIX_RE) {
  	*WCOREDUMP = sub { $_[0] & 128 };
          $NATIVE_WCOREDUMP = 0;
  } elsif ($@) {
  	croak sprintf FAIL_POSIX, $@;
  } else {
  	# POSIX actually has it defined!  Huzzah!
  	*WCOREDUMP = \&POSIX::WCOREDUMP;
          $NATIVE_WCOREDUMP = 1;
  }
  
  sub _native_wcoredump {
      return $NATIVE_WCOREDUMP;
  }
  
  # system simply calls run
  
  *system  = \&run;
  *systemx = \&runx;
  
  # run is our way of running a process with system() semantics
  
  sub run {
  
  	_check_taint(@_);
  
  	my ($valid_returns, $command, @args) = _process_args(@_);
  
          # If we have arguments, we really want to call systemx,
          # so we do so.
  
  	if (@args) {
                  return systemx($valid_returns, $command, @args);
  	}
  
          # Without arguments, we're calling system, and checking
          # the results.
  
  	# We're throwing our own exception on command not found, so
  	# we don't need a warning from Perl.
  
          {
              # silence 'Statement unlikely to be reached' warning
              no warnings 'exec';             ## no critic
              CORE::system($command,@args);
          }
  
  	return _process_child_error($?,$command,$valid_returns);
  }
  
  # runx is just like system/run, but *never* invokes the shell.
  
  sub runx {
      _check_taint(@_);
  
      my ($valid_returns, $command, @args) = _process_args(@_);
  
      if (WINDOWS) {
          our $EXITVAL = -1;
  
          my $pid = _spawn_or_die($command, "$command @args");
  
          $pid->Wait(INFINITE);	# Wait for process exit.
          $pid->GetExitCode($EXITVAL);
          return _check_exit($command,$EXITVAL,$valid_returns);
      }
  
      # If system() fails, we throw our own exception.  We don't
      # need to have perl complain about it too.
  
      no warnings; ## no critic
  
      CORE::system { $command } $command, @args;
  
      return _process_child_error($?, $command, $valid_returns);
  }
  
  # capture is our way of running a process with backticks/qx semantics
  
  sub capture {
  	_check_taint(@_);
  
  	my ($valid_returns, $command, @args) = _process_args(@_);
  
          if (@args) {
              return capturex($valid_returns, $command, @args);
          }
  
          if (WINDOWS) {
              # USE_SHELL really means "You may use the shell if you need it."
              return _win32_capture(USE_SHELL, $valid_returns, $command, @args);
          }
  
  	our $EXITVAL = -1;
  
  	my $wantarray = wantarray();
  
  	# We'll produce our own warnings on failure to execute.
  	no warnings 'exec';	## no critic
  
          if ($wantarray) {
                  my @results = qx($command);
                  _process_child_error($?,$command,$valid_returns);
                  return @results;
          } 
  
          my $results = qx($command);
          _process_child_error($?,$command,$valid_returns);
          return $results;
  }
  
  # _win32_capture implements the capture and capurex commands on Win32.
  # We need to wrap the whole internals of this sub into
  # an if (WINDOWS) block to avoid it being compiled on non-Win32 systems.
  
  sub _win32_capture {
      if (not WINDOWS) {
          croak sprintf(FAIL_INTERNAL, "_win32_capture called when not under Win32");
      } else {
  
          my ($use_shell, $valid_returns, $command, @args) = @_;
  
          my $wantarray = wantarray();
  
          # Perl doesn't support multi-arg open under
          # Windows.  Perl also doesn't provide very good
          # feedback when normal backtails fail, either;
          # it returns exit status from the shell
          # (which is indistinguishable from the command
          # running and producing the same exit status).
  
          # As such, we essentially have to write our own
          # backticks.
  
          # We start by dup'ing STDOUT.
  
          open(my $saved_stdout, '>&', \*STDOUT)  ## no critic
                  or croak sprintf(FAIL_PLUMBING, "Can't dup STDOUT", $!);
  
          # We now open up a pipe that will allow us to	
          # communicate with the new process.
  
          pipe(my ($read_fh, $write_fh))
                  or croak sprintf(FAIL_PLUMBING, "Can't create pipe", $!);
  
          # Allow CRLF sequences to become "\n", since
          # this is what Perl backticks do.
  
          binmode($read_fh, ':crlf');
  
          # Now we re-open our STDOUT to $write_fh...
  
          open(STDOUT, '>&', $write_fh)  ## no critic
                  or croak sprintf(FAIL_PLUMBING, "Can't redirect STDOUT", $!);
  
          # If we have args, or we're told not to use the shell, then
          # we treat $command as our shell.  Otherwise we grub around
          # in our command to look for a command to run.
          #
          # Note that we don't actually *use* the shell (although in
          # a future version we might).  Being told not to use the shell
          # (capturex) means we treat our command as really being a command,
          # and not a command line.
  
          my $exe =   @args                      ? $command :
                      (! $use_shell)             ? $command :
                      $command =~ m{^"([^"]+)"}x ? $1       :
                      $command =~ m{(\S+)     }x ? $1       :
                      croak sprintf(FAIL_CMD_BLANK, $command);
  
          # And now we spawn our new process with inherited
          # filehandles.
  
          my $err;
          my $pid = eval { 
                  _spawn_or_die($exe, "$command @args"); 
          }
          or do {
                  $err = $@;
          };
  
          # Regardless of whether our command ran, we must restore STDOUT.
          # RT #48319
          open(STDOUT, '>&', $saved_stdout)  ## no critic
                  or croak sprintf(FAIL_PLUMBING,"Can't restore STDOUT", $!);
  
          # And now, if there was an actual error , propagate it.
          die $err if defined $err;   # If there's an error from _spawn_or_die
  
          # Clean-up the filehandles we no longer need...
  
          close($write_fh)
                  or croak sprintf(FAIL_PLUMBING,q{Can't close write end of pipe}, $!);
          close($saved_stdout)
                  or croak sprintf(FAIL_PLUMBING,q{Can't close saved STDOUT}, $!);
  
          # Read the data from our child...
  
          my (@results, $result);
  
          if ($wantarray) {
                  @results = <$read_fh>;
          } else {
                  $result = join("",<$read_fh>);
          }
  
          # Tidy up our windows process and we're done!
  
          $pid->Wait(INFINITE);	# Wait for process exit.
          $pid->GetExitCode($EXITVAL);
  
          _check_exit($command,$EXITVAL,$valid_returns);
  
          return $wantarray ? @results : $result;
  
      }
  }
  
  # capturex() is just like backticks/qx, but never invokes the shell.
  
  sub capturex {
  	_check_taint(@_);
  
  	my ($valid_returns, $command, @args) = _process_args(@_);
  
  	our $EXITVAL = -1;
  
  	my $wantarray = wantarray();
  
  	if (WINDOWS) {
              return _win32_capture(NO_SHELL, $valid_returns, $command, @args);
          }
  
  	# We can't use a multi-arg piped open here, since 5.6.x
  	# doesn't like them.  Instead we emulate what 5.8.x does,
  	# which is to create a pipe(), set the close-on-exec flag
  	# on the child, and the fork/exec.  If the exec fails, the
  	# child writes to the pipe.  If the exec succeeds, then
  	# the pipe closes without data.
  
  	pipe(my ($read_fh, $write_fh))
  		or croak sprintf(FAIL_PLUMBING, "Can't create pipe", $!);
  
  	# This next line also does an implicit fork.
  	my $pid = open(my $pipe, '-|');	 ## no critic
  
  	if (not defined $pid) {
  		croak sprintf(FAIL_START, $command, $!);
  	} elsif (not $pid) {
  		# Child process, execs command.
  
  		close($read_fh);
  
  		# TODO: 'no warnings exec' doesn't get rid
  		# of the 'unlikely to be reached' warnings.
  		# This is a bug in perl / perldiag / perllexwarn / warnings.
  
  		no warnings;   ## no critic
  
  		CORE::exec { $command } $command, @args;
  
  		# Oh no, exec fails!  Send the reason why to
  		# the parent.
  
  		print {$write_fh} int($!);
  		exit(-1);
  	}
  
  	{
  		# In parent process.
  
  		close($write_fh);
  
  		# Parent process, check for child error.
  		my $error = <$read_fh>;
  
  		# Tidy up our pipes.
  		close($read_fh);
  
  		# Check for error.
  		if ($error) {
  			# Setting $! to our child error number gives
  			# us nice looking strings when printed.
  			local $! = $error;
  			croak sprintf(FAIL_START, $command, $!);
  		}
  	}
  
  	# Parent process, we don't care about our pid, but we
  	# do go and read our pipe.
  
  	if ($wantarray) {
  		my @results = <$pipe>;
  		close($pipe);
  		_process_child_error($?,$command,$valid_returns);
  		return @results;
  	}
  
  	# NB: We don't check the return status on close(), since
  	# on failure it sets $?, which we then inspect for more
  	# useful information.
  
  	my $results = join("",<$pipe>);
  	close($pipe);
  	_process_child_error($?,$command,$valid_returns);
  	
  	return $results;
  
  }
  
  # Tries really hard to spawn a process under Windows.  Returns
  # the pid on success, or undef on error.
  
  sub _spawn_or_die {
  
  	# We need to wrap practically the entire sub in an
  	# if block to ensure it doesn't get compiled under non-Win32
  	# systems.  Compiling on these systems would not only be a
  	# waste of time, but also results in complaints about
  	# the NORMAL_PRIORITY_CLASS constant.
  
  	if (not WINDOWS) {
  		croak sprintf(FAIL_INTERNAL, "_spawn_or_die called when not under Win32");
  	} else {
  		my ($orig_exe, $cmdline) = @_;
  		my $pid;
  
  		my $exe = $orig_exe;
  
  		# If our command doesn't have an extension, add one.
  		$exe .= $Config{_exe} if ($exe !~ m{\.});
  
  		Win32::Process::Create(
  			$pid, $exe, $cmdline, 1, NORMAL_PRIORITY_CLASS, "."
  		) and return $pid;
  
  		my @path = split(/;/,$ENV{PATH});
  
  		foreach my $dir (@path) {
  			my $fullpath = File::Spec->catfile($dir,$exe);
  
  			# We're using -x here on the assumption that stat()
  			# is faster than spawn, so trying to spawn a process
  			# for each path element will be unacceptably
  			# inefficient.
  
  			if (-x $fullpath) {
  				Win32::Process::Create(
  					$pid, $fullpath, $cmdline, 1,
  					NORMAL_PRIORITY_CLASS, "."
  				) and return $pid;
  			}
  		}
  
  		croak sprintf(FAIL_START, $orig_exe, $^E);
  	}
  }
  
  # Complain on tainted arguments or environment.
  # ASSUME_TAINTED is true for 5.6.x, since it's missing ${^TAINT}
  
  sub _check_taint {
  	return if not (ASSUME_TAINTED or ${^TAINT});
  	my $caller = (caller(1))[3];
  	foreach my $var (@_) {
  		if (tainted $var) {
  			croak sprintf(FAIL_TAINT, $caller, $var);
  		}
  	}
  	foreach my $var (@Check_tainted_env) {
  		if (tainted $ENV{$var} ) {
  			croak sprintf(FAIL_TAINT_ENV, $caller, $var);
  		}
  	}
  
  	return;
  
  }
  
  # This subroutine performs the difficult task of interpreting
  # $?.  It's not intended to be called directly, as it will
  # croak on errors, and its implementation and interface may
  # change in the future.
  
  sub _process_child_error {
  	my ($child_error, $command, $valid_returns) = @_;
  	
  	$EXITVAL = -1;
  
  	my $coredump = WCOREDUMP($child_error);
  
          # There's a bug in perl 5.10.0 where if the system
          # does not provide a native WCOREDUMP, then $? will
          # never contain coredump information.  This code
          # checks to see if we have the bug, and works around
          # it if needed.
  
          if ($] >= 5.010 and not $NATIVE_WCOREDUMP) {
              $coredump ||= WCOREDUMP( ${^CHILD_ERROR_NATIVE} );
          }
  
  	if ($child_error == -1) {
  		croak sprintf(FAIL_START, $command, $!);
  
  	} elsif ( WIFEXITED( $child_error ) ) {
  		$EXITVAL = WEXITSTATUS( $child_error );
  
  		return _check_exit($command,$EXITVAL,$valid_returns);
  
  	} elsif ( WIFSIGNALED( $child_error ) ) {
  		my $signal_no   = WTERMSIG( $child_error );
  		my $signal_name = $Signal_from_number[$signal_no] || "UNKNOWN";
  
  		croak sprintf FAIL_SIGNAL, $command, $signal_name, $signal_no, ($coredump ? " and dumped core" : "");
  
  
  	} 
  
  	croak sprintf(FAIL_INTERNAL, qq{'$command' ran without exit value or signal});
  
  }
  
  # A simple subroutine for checking exit values.  Results in better
  # assurance of consistent error messages, and better forward support
  # for new features in I::S::S.
  
  sub _check_exit {
  	my ($command, $exitval, $valid_returns) = @_;
  
  	# If we have a single-value list consisting of the EXIT_ANY
  	# value, then we're happy with whatever exit value we're given.
  	if (@$valid_returns == 1 and $valid_returns->[0] == EXIT_ANY_CONST) {
  		return $exitval;
  	}
  
  	if (not defined first { $_ == $exitval } @$valid_returns) {
  		croak sprintf FAIL_BADEXIT, $command, $exitval;
  	}	
  	return $exitval;
  }
  
  
  # This subroutine simply determines a list of valid returns, the command
  # name, and any arguments that we need to pass to it.
  
  sub _process_args {
  	my $valid_returns = [ 0 ];
  	my $caller = (caller(1))[3];
  
  	if (not @_) {
  		croak "$caller called with no arguments";
  	}
  
  	if (ref $_[0] eq "ARRAY") {
  		$valid_returns = shift(@_);
  	}
  
  	if (not @_) {
  		croak "$caller called with no command";
  	}
  
  	my $command = shift(@_);
  
          if (not defined $command) {
                  croak sprintf( FAIL_UNDEF, $caller );
          }
  
  	return ($valid_returns,$command,@_);
  
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IPC::System::Simple - Run commands simply, with detailed diagnostics
  
  =head1 SYNOPSIS
  
    use IPC::System::Simple qw(system systemx capture capturex);
  
    system("some_command");        # Command succeeds or dies!
  
    system("some_command",@args);  # Succeeds or dies, avoids shell if @args
  
    systemx("some_command",@args); # Succeeds or dies, NEVER uses the shell
  
  
    # Capture the output of a command (just like backticks). Dies on error.
    my $output = capture("some_command");
  
    # Just like backticks in list context.  Dies on error.
    my @output = capture("some_command");
  
    # As above, but avoids the shell if @args is non-empty
    my $output = capture("some_command", @args);
  
    # As above, but NEVER invokes the shell.
    my $output = capturex("some_command", @args);
    my @output = capturex("some_command", @args);
  
  =head1 DESCRIPTION
  
  Calling Perl's in-built C<system()> function is easy, 
  determining if it was successful is I<hard>.  Let's face it,
  C<$?> isn't the nicest variable in the world to play with, and
  even if you I<do> check it, producing a well-formatted error
  string takes a lot of work.
  
  C<IPC::System::Simple> takes the hard work out of calling 
  external commands.  In fact, if you want to be really lazy,
  you can just write:
  
      use IPC::System::Simple qw(system);
  
  and all of your C<system> commands will either succeed (run to
  completion and return a zero exit value), or die with rich diagnostic
  messages.
  
  The C<IPC::System::Simple> module also provides a simple replacement
  to Perl's backticks operator.  Simply write:
  
      use IPC::System::Simple qw(capture);
  
  and then use the L</capture()> command just like you'd use backticks.
  If there's an error, it will die with a detailed description of what
  went wrong.  Better still, you can even use C<capturex()> to run the
  equivalent of backticks, but without the shell:
  
      use IPC::System::Simple qw(capturex);
  
      my $result = capturex($command, @args);
  
  If you want more power than the basic interface, including the
  ability to specify which exit values are acceptable, trap errors,
  or process diagnostics, then read on!
  
  =head1 ADVANCED SYNOPSIS
  
    use IPC::System::Simple qw(
      capture capturex system systemx run runx $EXITVAL EXIT_ANY
    );
  
    # Run a command, throwing exception on failure
  
    run("some_command");
  
    runx("some_command",@args);  # Run a command, avoiding the shell
  
    # Do the same thing, but with the drop-in system replacement.
  
    system("some_command");
  
    systemx("some_command", @args);
  
    # Run a command which must return 0..5, avoid the shell, and get the
    # exit value (we could also look at $EXITVAL)
  
    my $exit_value = runx([0..5], "some_command", @args);
  
    # The same, but any exit value will do.
  
    my $exit_value = runx(EXIT_ANY, "some_command", @args);
  
    # Capture output into $result and throw exception on failure
  
    my $result = capture("some_command");	
  
    # Check exit value from captured command
  
    print "some_command exited with status $EXITVAL\n";
  
    # Captures into @lines, splitting on $/
    my @lines = capture("some_command"); 
  
    # Run a command which must return 0..5, capture the output into
    # @lines, and avoid the shell.
  
    my @lines  = capturex([0..5], "some_command", @args);
  
  =head1 ADVANCED USAGE
  
  =head2 run() and system()
  
  C<IPC::System::Simple> provides a subroutine called
  C<run>, that executes a command using the same semantics is
  Perl's built-in C<system>:
  
      use IPC::System::Simple qw(run);
  
      run("cat *.txt");           # Execute command via the shell
      run("cat","/etc/motd");     # Execute command without shell
  
  The primary difference between Perl's in-built system and
  the C<run> command is that C<run> will throw an exception on
  failure, and allows a list of acceptable exit values to be set.
  See L</Exit values> for further information.
  
  In fact, you can even have C<IPC::System::Simple> replace the
  default C<system> function for your package so it has the
  same behaviour:
  
      use IPC::System::Simple qw(system);
  
      system("cat *.txt");  # system now suceeds or dies!
  
  C<system> and C<run> are aliases to each other.
  
  See also L</runx(), systemx() and capturex()> for variants of
  C<system()> and C<run()> that never invoke the shell, even with
  a single argument.
  
  =head2 capture()
  
  A second subroutine, named C<capture> executes a command with
  the same semantics as Perl's built-in backticks (and C<qx()>):
  
      use IPC::System::Simple qw(capture);
  
      # Capture text while invoking the shell.
      my $file  = capture("cat /etc/motd");
      my @lines = capture("cat /etc/passwd");
  
  However unlike regular backticks, which always use the shell, C<capture>
  will bypass the shell when called with multiple arguments:
  
      # Capture text while avoiding the shell.
      my $file  = capture("cat", "/etc/motd");
      my @lines = capture("cat", "/etc/passwd");
  
  See also L</runx(), systemx() and capturex()> for a variant of
  C<capture()> that never invokes the shell, even with a single
  argument.
  
  =head2 runx(), systemx() and capturex()
  
  The C<runx()>, C<systemx()> and C<capturex()> commands are identical
  to the multi-argument forms of C<run()>, C<system()> and C<capture()>
  respectively, but I<never> invoke the shell, even when called with a
  single argument.  These forms are particularly useful when a command's
  argument list I<might> be empty, for example:
  
      systemx($cmd, @args);
  
  The use of C<systemx()> here guarantees that the shell will I<never>
  be invoked, even if C<@args> is empty.
  
  =head2 Exception handling
  
  In the case where the command returns an unexpected status, both C<run> and
  C<capture> will throw an exception, which if not caught will terminate your
  program with an error.
  
  Capturing the exception is easy:
  
      eval {
          run("cat *.txt");
      };
  
      if ($@) {
          print "Something went wrong - $@\n";
      }
  
  See the diagnostics section below for more details.
  
  =head3 Exception cases
  
  C<IPC::System::Simple> considers the following to be unexpected,
  and worthy of exception:
  
  =over 4
  
  =item *
  
  Failing to start entirely (eg, command not found, permission denied).
  
  =item *
  
  Returning an exit value other than zero (but see below).
  
  =item *
  
  Being killed by a signal.
  
  =item *
  
  Being passed tainted data (in taint mode).
  
  =back
  
  =head2 Exit values
  
  Traditionally, system commands return a zero status for success and a
  non-zero status for failure.  C<IPC::System::Simple> will default to throwing
  an exception if a non-zero exit value is returned.
  
  You may specify a range of values which are considered acceptable exit
  values by passing an I<array reference> as the first argument.  The
  special constant C<EXIT_ANY> can be used to allow I<any> exit value
  to be returned.
  
  	use IPC::System::Simple qw(run system capture EXIT_ANY);
  
  	run( [0..5], "cat *.txt");             # Exit values 0-5 are OK
  
  	system( [0..5], "cat *.txt");          # This works the same way
  
  	my @lines = capture( EXIT_ANY, "cat *.txt"); # Any exit is fine.
  
  The C<run> and replacement C<system> subroutines returns the exit
  value of the process:
  
  	my $exit_value = run( [0..5], "cat *.txt");
  
  	# OR:
  
  	my $exit_value = system( [0..5] "cat *.txt");
  
  	print "Program exited with value $exit_value\n";
  
  =head3 $EXITVAL
  
  The exit value of any command executed by C<IPC::System::Simple>
  can always be retrieved from the C<$IPC::System::Simple::EXITVAL>
  variable:
  
  This is particularly useful when inspecting results from C<capture>,
  which returns the captured text from the command.
  
  	use IPC::System::Simple qw(capture $EXITVAL EXIT_ANY);
  
  	my @enemies_defeated = capture(EXIT_ANY, "defeat_evil", "/dev/mordor");
  
  	print "Program exited with value $EXITVAL\n";
  
  C<$EXITVAL> will be set to C<-1> if the command did not exit normally (eg,
  being terminated by a signal) or did not start.  In this situation an
  exception will also be thrown.
  
  =head2 WINDOWS-SPECIFIC NOTES
  
  As of C<IPC::System::Simple> v0.06, the C<run> subroutine I<when
  called with multiple arguments> will make available the full 32-bit
  exit value on Win32 systems.  This is different from the
  previous versions of C<IPC::System::Simple> and from Perl's
  in-build C<system()> function, which can only handle 8-bit return values.
  
  The C<capture> subroutine always returns the 32-bit exit value under
  Windows.  The C<capture> subroutine also never uses the shell,
  even when passed a single argument.
  
  Versions of C<IPC::System::Simple> before v0.09 would not search
  the C<PATH> environment variable when the multi-argument form of
  C<run()> was called.  Versions from v0.09 onwards correctly search
  the path provided the command is provided including the extension
  (eg, C<notepad.exe> rather than just C<notepad>, or C<gvim.bat> rather
  than just C<gvim>).  If no extension is provided, C<.exe> is
  assumed.
  
  Signals are not supported on Windows systems.  Sending a signal
  to a Windows process will usually cause it to exit with the signal
  number used.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item "%s" failed to start: "%s"
  
  The command specified did not even start.  It may not exist, or
  you may not have permission to use it.  The reason it could not
  start (as determined from C<$!>) will be provided.
  
  =item "%s" unexpectedly returned exit value %d
  
  The command ran successfully, but returned an exit value we did
  not expect.  The value returned is reported.
  
  =item "%s" died to signal "%s" (%d) %s
  
  The command was killed by a signal.  The name of the signal
  will be reported, or C<UNKNOWN> if it cannot be determined.  The
  signal number is always reported.  If we detected that the
  process dumped core, then the string C<and dumped core> is
  appended.
  
  =item IPC::System::Simple::%s called with no arguments
  
  You attempted to call C<run> or C<capture> but did not provide any
  arguments at all.  At the very lease you need to supply a command
  to run.
  
  =item IPC::System::Simple::%s called with no command
  
  You called C<run> or C<capture> with a list of acceptable exit values,
  but no actual command.
  
  =item IPC::System::Simple::%s called with tainted argument "%s"
  
  You called C<run> or C<capture> with tainted (untrusted) arguments, which is
  almost certainly a bad idea.  To untaint your arguments you'll need to pass
  your data through a regular expression and use the resulting match variables.
  See L<perlsec/Laundering and Detecting Tainted Data> for more information.
  
  =item IPC::System::Simple::%s called with tainted environment $ENV{%s}
  
  You called C<run> or C<capture> but part of your environment was tainted
  (untrusted).  You should either delete the named environment
  variable before calling C<run>, or set it to an untainted value
  (usually one set inside your program).  See
  L<perlsec/Cleaning Up Your Path> for more information.
  
  =item Error in IPC::System::Simple plumbing: "%s" - "%s"
  
  Implementing the C<capture> command involves dark and terrible magicks
  involving pipes, and one of them has sprung a leak.  This could be due to a
  lack of file descriptors, although there are other possibilities.
  
  If you are able to reproduce this error, you are encouraged
  to submit a bug report according to the L</Reporting bugs> section below.
  
  =item Internal error in IPC::System::Simple: "%s"
  
  You've found a bug in C<IPC::System::Simple>.  Please check to
  see if an updated version of C<IPC::System::Simple> is available.
  If not, please file a bug report according to the L</Reporting bugs> section
  below.
  
  =item IPC::System::Simple::%s called with undefined command
  
  You've passed the undefined value as a command to be executed.
  While this is a very Zen-like action, it's not supported by
  Perl's current implementation.
  
  =back
  
  =head1 DEPENDENCIES
  
  This module depends upon L<Win32::Process> when used on Win32
  system.  C<Win32::Process> is bundled as a core module in ActivePerl 5.6
  and above.
  
  There are no non-core dependencies on non-Win32 systems.
  
  =head1 COMPARISON TO OTHER APIs
  
  Perl provides a range of in-built functions for handling external
  commands, and CPAN provides even more.  The C<IPC::System::Simple>
  differentiates itself from other options by providing:
  
  =over 4
  
  =item Extremely detailed diagnostics
  
  The diagnostics produced by C<IPC::System::Simple> are designed
  to provide as much information as possible.  Rather than requiring
  the developer to inspect C<$?>, C<IPC::System::Simple> does the
  hard work for you.
  
  If an odd exit status is provided, you're informed of what it is.  If
  a signal kills your process, you are informed of both its name and
  number.  If tainted data or environment prevents your command from
  running, you are informed of exactly which datais 
  
  =item Exceptions on failure
  
  C<IPC::System::Simple> takes an aggressive approach to error handling.
  Rather than allow commands to fail silently, exceptions are thrown
  when unexpected results are seen.  This allows for easy development
  using a try/catch style, and avoids the possibility of accidently
  continuing after a failed command.
  
  =item Easy access to exit status
  
  The C<run>, C<system> and C<capture> commands all set C<$EXITVAL>,
  making it easy to determine the exit status of a command.
  Additionally, the C<system> and C<run> interfaces return the exit
  status.
  
  =item Consistent interfaces
  
  When called with multiple arguments, the C<run>, C<system> and
  C<capture> interfaces I<never> invoke the shell.  This differs
  from the in-built Perl C<system> command which may invoke the
  shell under Windows when called with multiple arguments.  It
  differs from the in-built Perl backticks operator which always
  invokes the shell.
  
  =back
  
  =head1 BUGS
  
  When C<system> is exported, the exotic form C<system { $cmd } @args>
  is not supported.  Attemping to use the exotic form is a syntax
  error.  This affects the calling package I<only>.  Use C<CORE::system>
  if you need it, or consider using the L<autodie> module to replace
  C<system> with lexical scope.
  
  Core dumps are only checked for when a process dies due to a
  signal.  It is not believed there are any systems where processes
  can dump core without dying to a signal.
  
  C<WIFSTOPPED> status is not checked, as perl never spawns processes
  with the C<WUNTRACED> option.
  
  Signals are not supported under Win32 systems, since they don't
  work at all like Unix signals.  Win32 singals cause commands to
  exit with a given exit value, which this modules I<does> capture.
  
  Only 8-bit values are returned when C<run()> or C<system()> 
  is called with a single value under Win32.  Multi-argument calls
  to C<run()> and C<system()>, as well as the C<runx()> and
  C<systemx()> always return the 32-bit Windows return values.
  
  =head2 Reporting bugs
  
  Before reporting a bug, please check to ensure you are using the
  most recent version of C<IPC::System::Simple>.  Your problem may
  have already been fixed in a new release.
  
  You can find the C<IPC::System::Simple> bug-tracker at
  L<http://rt.cpan.org/Public/Dist/Display.html?Name=IPC-System-Simple> .
  Please check to see if your bug has already been reported; if
  in doubt, report yours anyway.
  
  Submitting a patch and/or failing test case will greatly expedite
  the fixing of bugs.
  
  =head1 FEEDBACK
  
  If you find this module useful, please consider rating it on the
  CPAN Ratings service at
  L<http://cpanratings.perl.org/rate/?distribution=IPC-System-Simple> .
  
  The module author loves to hear how C<IPC::System::Simple> has made
  your life better (or worse).  Feedback can be sent to
  E<lt>pjf@perltraining.com.auE<gt>.
  
  =head1 SEE ALSO
  
  L<autodie> uses C<IPC::System::Simple> to provide succeed-or-die
  replacements to C<system> (and other built-ins) with lexical scope.
  
  L<POSIX>, L<IPC::Run::Simple>, L<perlipc>, L<perlport>, L<IPC::Run>,
  L<IPC::Run3>, L<Win32::Process>
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2006-2008 by Paul Fenwick
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.6.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =for Pod::Coverage WCOREDUMP
  
  =cut
IPC_SYSTEM_SIMPLE

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use base qw(Exporter);
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.90';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my $Module_XS  = 'JSON::XS';
  my $Module_PP  = 'JSON::PP';
  my $Module_bp  = 'JSON::backportPP'; # included in JSON distribution
  my $PP_Version = '2.27203';
  my $XS_Version = '2.34';
  
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw/allow_tags/; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_INSTALL_ONLY      = 2; # Don't call _set_methods()
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  my $_USSING_bpPP       = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1' or $backend =~ /JSON::XS\s*,\s*JSON::PP/) {
          _load_xs($_INSTALL_DONT_DIE) or _load_pp();
      }
      elsif ($backend eq '0' or $backend eq 'JSON::PP') {
          _load_pp();
      }
      elsif ($backend eq '2' or $backend eq 'JSON::XS') {
          _load_xs();
      }
      elsif ($backend eq 'JSON::backportPP') {
          $_USSING_bpPP = 1;
          _load_pp();
      }
      else {
          Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend eq $Module_XS);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              eval q|
                  require B;
                  *UNIVERSAL::TO_JSON = sub {
                      my $b_obj = B::svref_2object( $_[0] );
                      return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                              : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                              : undef
                              ;
                  }
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $XS_Version; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend eq $Module_XS;
  }
  
  
  sub is_pp {
      return not $_[0]->is_xs;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub _load_xs {
      my $opt = shift;
  
      $JSON::DEBUG and Carp::carp "Load $Module_XS.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($Module_PP);
  
      eval qq|
          use $Module_XS $XS_Version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_XS...($@)";
              return 0;
          }
          Carp::croak $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_XS );
          my $data = join("", <DATA>); # this code is from Jcode 2.xx.
          close(DATA);
          eval $data;
          JSON::Backend::XS->init;
      }
  
      return 1;
  };
  
  
  sub _load_pp {
      my $opt = shift;
      my $backend = $_USSING_bpPP ? $Module_bp : $Module_PP;
  
      $JSON::DEBUG and Carp::carp "Load $backend.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($backend);
  
      if ( $_USSING_bpPP ) {
          eval qq| require $backend |;
      }
      else {
          eval qq| use $backend $PP_Version () |;
      }
  
      if ($@) {
          if ( $backend eq $Module_PP ) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_PP ($@), so try to load $Module_bp";
              $_USSING_bpPP++;
              $backend = $Module_bp;
              JSON::Boolean::_overrride_overload($backend);
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $Module_bp |;
          }
          Carp::croak $@ if $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_PP ); # even if backportPP, set $Backend with 'JSON::PP'
          JSON::Backend::PP->init;
      }
  };
  
  
  sub _set_module {
      return if defined $JSON::true;
  
      my $module = shift;
  
      local $^W;
      no strict qw(refs);
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::ISA, $module;
      if ( JSON->is_xs and JSON->backend->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      for my $method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  
  
  #
  # JSON Boolean
  #
  
  package JSON::Boolean;
  
  my %Installed;
  
  sub _overrride_overload {
      return; # this function is currently disable.
      return if ($Installed{ $_[0] }++);
  
      my $boolean = $_[0] . '::Boolean';
  
      eval sprintf(q|
          package %s;
          use overload (
              '""' => sub { ${$_[0]} == 1 ? 'true' : 'false' },
              'eq' => sub {
                  my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
                  if ($op eq 'true' or $op eq 'false') {
                      return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
                  }
                  else {
                      return $obj ? 1 == $op : 0 == $op;
                  }
              },
          );
      |, $boolean);
  
      if ($@) { Carp::croak $@; }
  
      if ( exists $INC{'JSON/XS.pm'} and $boolean eq 'JSON::XS::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::XS::true  = sub () { $true };
          *JSON::XS::false = sub () { $false };
      }
      elsif ( exists $INC{'JSON/PP.pm'} and $boolean eq 'JSON::PP::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::PP::true  = sub { $true };
          *JSON::PP::false = sub { $false };
      }
  
      return 1;
  }
  
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::PP::is_xs"}  = sub { 0 };
      *{"JSON::PP::is_pp"}  = sub { 1 };
      return 1;
  }
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  use constant INDENT_LENGTH_FLAG => 15 << 12;
  
  use constant UNSUPPORTED_ENCODE_FLAG => {
      ESCAPE_SLASH      => 0x00000010,
      ALLOW_BIGNUM      => 0x00000020,
      AS_NONBLESSED     => 0x00000040,
      EXPANDED          => 0x10000000, # for developer's
  };
  
  use constant UNSUPPORTED_DECODE_FLAG => {
      LOOSE             => 0x00000001,
      ALLOW_BIGNUM      => 0x00000002,
      ALLOW_BAREKEY     => 0x00000004,
      ALLOW_SINGLEQUOTE => 0x00000008,
      EXPANDED          => 0x20000000, # for developer's
  };
  
  
  sub init {
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"JSON::XS::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::XS::encode_json"};
      *{"JSON::XS::is_xs"}  = sub { 1 };
      *{"JSON::XS::is_pp"}  = sub { 0 };
      return 1;
  }
  
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      local $^W;
      no strict qw(refs);
  
      my $JSON_XS_encode_orignal     = \&JSON::XS::encode;
      my $JSON_XS_decode_orignal     = \&JSON::XS::decode;
      my $JSON_XS_incr_parse_orignal = \&JSON::XS::incr_parse;
  
      *JSON::XS::decode     = \&JSON::Backend::XS::Supportable::_decode;
      *JSON::XS::encode     = \&JSON::Backend::XS::Supportable::_encode;
      *JSON::XS::incr_parse = \&JSON::Backend::XS::Supportable::_incr_parse;
  
      *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;
      *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;
      *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;
  
      push @JSON::Backend::XS::Supportable::ISA, 'JSON';
  
      my $pkg = 'JSON::Backend::XS::Supportable';
  
      *{JSON::new} = sub {
          my $proto = JSON::XS->new; $$proto = 0;
          bless  $proto, $pkg;
      };
  
  
      for my $method (@methods) {
          my $flag = uc($method);
          my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);
             $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);
  
          next unless($type);
  
          $pkg->_make_unsupported_method($method => $type);
      }
  
  #    push @{"JSON::XS::Boolean::ISA"}, qw(JSON::PP::Boolean);
  #    push @{"JSON::PP::Boolean::ISA"}, qw(JSON::Boolean);
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  
      return 1;
  }
  
  
  
  
  #
  # Helper classes for XS
  #
  
  package JSON::Backend::XS::Supportable;
  
  $Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;
  
  sub _make_unsupported_method {
      my ($pkg, $method, $type) = @_;
  
      local $^W;
      no strict qw(refs);
  
      *{"$pkg\::$method"} = sub {
          local $^W;
          if (defined $_[1] ? $_[1] : 1) {
              ${$_[0]} |= $type;
          }
          else {
              ${$_[0]} &= ~$type;
          }
          $_[0];
      };
  
      *{"$pkg\::get_$method"} = sub {
          ${$_[0]} & $type ? 1 : '';
      };
  
  }
  
  
  sub _set_for_pp {
      JSON::_load_pp( $_INSTALL_ONLY );
  
      my $type  = shift;
      my $pp    = JSON::PP->new;
      my $prop = $_[0]->property;
  
      for my $name (keys %$prop) {
          $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );
      }
  
      my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG
                                          : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;
      my $flags       = ${$_[0]} || 0;
  
      for my $name (keys %$unsupported) {
          next if ($name eq 'EXPANDED'); # for developer's
          my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;
          my $method = lc $name;
          $pp->$method($enable);
      }
  
      $pp->indent_length( $_[0]->get_indent_length );
  
      return $pp;
  }
  
  sub _encode { # using with PP encode
      if (${$_[0]}) {
          _set_for_pp('encode' => @_)->encode($_[1]);
      }
      else {
          $_[0]->_original_encode( $_[1] );
      }
  }
  
  
  sub _decode { # if unsupported-flag is set, use PP
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->decode($_[1]);
      }
      else {
          $_[0]->_original_decode( $_[1] );
      }
  }
  
  
  sub decode_prefix { # if unsupported-flag is set, use PP
      _set_for_pp('decode' => @_)->decode_prefix($_[1]);
  }
  
  
  sub _incr_parse {
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->incr_parse($_[1]);
      }
      else {
          $_[0]->_original_incr_parse( $_[1] );
      }
  }
  
  
  sub get_indent_length {
      ${$_[0]} << 4 >> 16;
  }
  
  
  sub indent_length {
      my $length = $_[1];
  
      if (!defined $length or $length > 15 or $length < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          local $^W;
          $length <<= 12;
          ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;
          ${$_[0]} |= $length;
          *JSON::XS::encode = \&JSON::Backend::XS::Supportable::_encode;
      }
  
      $_[0];
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # If you want to use PP only support features, call with '-support_by_pp'
   # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.
   
   use JSON -support_by_pp;
   
   # option-acceptable interfaces (expect/generate UNICODE by default)
   
   $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );
   $perl_scalar = from_json( $json_text, { utf8  => 1 } );
   
   # Between (en|de)code_json and (to|from)_json, if you want to write
   # a code which communicates to an outer world (encoded in UTF-8),
   # recommend to use (en|de)code_json.
   
  =head1 VERSION
  
      2.90
  
  This version is compatible with JSON::XS B<2.34> and later.
  (Not yet compatble to JSON::XS B<3.0x>.)
  
  
  =head1 NOTE
  
  JSON::PP was earlier included in the C<JSON> distribution, but
  has since Perl 5.14 been a core module. For this reason,
  L<JSON::PP> was removed from the JSON distribution and can now
  be found also in the Perl5 repository at
  
  =over
  
  =item * L<http://perl5.git.perl.org/perl.git>
  
  =back
  
  (The newest JSON::PP version still exists in CPAN.)
  
  Instead, the C<JSON> distribution will include JSON::backportPP
  for backwards computability. JSON.pm should thus work as it did
  before.
  
  =head1 DESCRIPTION
  
   *************************** CAUTION **************************************
   *                                                                        *
   * INCOMPATIBLE CHANGE (JSON::XS version 2.90)                            *
   *                                                                        *
   * JSON.pm had patched JSON::XS::Boolean and JSON::PP::Boolean internally *
   * on loading time for making these modules inherit JSON::Boolean.        *
   * But since JSON::XS v3.0 it use Types::Serialiser as boolean class.     *
   * Then now JSON.pm breaks boolean classe overload features and           *
   * -support_by_pp if JSON::XS v3.0 or later is installed.                 *
   *                                                                        *
   * JSON::true and JSON::false returned JSON::Boolean objects.             *
   * For workaround, they return JSON::PP::Boolean objects in this version. *
   *                                                                        *
   *     isa_ok(JSON::true, 'JSON::PP::Boolean');                           *
   *                                                                        *
   * And it discards a feature:                                             *
   *                                                                        *
   *     ok(JSON::true eq 'true');                                          *
   *                                                                        *
   * In other word, JSON::PP::Boolean overload numeric only.                *
   *                                                                        *
   *     ok( JSON::true == 1 );                                             *
   *                                                                        *
   **************************************************************************
  
   ************************** CAUTION ********************************
   * This is 'JSON module version 2' and there are many differences  *
   * to version 1.xx                                                 *
   * Please check your applications using old version.              *
   *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *
   *******************************************************************
  
  JSON (JavaScript Object Notation) is a simple data format.
  See to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).
  
  This module converts Perl data structures to JSON and vice versa using either
  L<JSON::XS> or L<JSON::PP>.
  
  JSON::XS is the fastest and most proper JSON module on CPAN which must be
  compiled and installed in your environment.
  JSON::PP is a pure-Perl module which is bundled in this distribution and
  has a strong compatibility to JSON::XS.
  
  This module try to use JSON::XS by default and fail to it, use JSON::PP instead.
  So its features completely depend on JSON::XS or JSON::PP.
  
  See to L<BACKEND MODULE DECISION>.
  
  To distinguish the module name 'JSON' and the format type JSON,
  the former is quoted by CE<lt>E<gt> (its results vary with your using media),
  and the latter is left just as it is.
  
  Module name : C<JSON>
  
  Format type : JSON
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module (i.e. backend modules) knows how to handle Unicode, documents
  how and when it does so, and even documents what "correct" means.
  
  Even though there are limitations, this feature is available since Perl version 5.6.
  
  JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions
  C<JSON> should call JSON::PP as the backend which can be used since Perl 5.005.
  
  With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,
  JSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.
  
  See also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>
  and L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  L</MAPPING> section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  See to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.
  
  =item * fast
  
  This module returns a JSON::XS object itself if available.
  Compared to other JSON modules and other serialisers such as Storable,
  JSON::XS usually compares favorably in terms of speed, too.
  
  If not available, C<JSON> returns a JSON::PP object instead of JSON::XS and
  it is very slow as pure-Perl.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an
  object oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format possible
  (nice for simple line-based protocols), a pure-ASCII format (for when your transport
  is not 8-bit clean, still supports the whole Unicode range), or a pretty-printed
  format (for when you want to read that stuff). Or you can combine those features
  in whatever way you like.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  C<to_json> and C<from_json> are additional functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar)
  
  Converts the given Perl data structure to a json string.
  
  This function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Takes a hash reference as the second.
  
     $json_text = to_json($perl_scalar, $flag_hashref)
  
  So,
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
  
  equivalent to:
  
     $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<encode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text)
  
  The opposite of C<to_json>: expects a json string and tries
  to parse it, returning the resulting reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->decode($json_text)
  
  Takes a hash reference as the second.
  
      $perl_scalar = from_json($json_text, $flag_hashref)
  
  So,
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
  
  equivalent to:
  
      $perl_scalar = JSON->new->utf8(1)->decode($json_text)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<decode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    # or
    $perl_scalar = from_json( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # or 
    $unicode_json_text = to_json( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  =head2 new
  
      $json = JSON->new
  
  Returns a new C<JSON> object inherited from either JSON::XS or JSON::PP
  that can be used to de/encode JSON strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
  This feature depends on the used Perl version and environment.
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  The indent space length is three and JSON::XS cannot change the indent
  space length.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, identifying them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The indent space length is three.
  With JSON::PP, you can also access C<indent_length> to change indent space length.
  
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =over
  
  =item convert_blessed_universally mode
  
  If use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>
  subroutine is defined as the below code:
  
     *UNIVERSAL::TO_JSON = sub {
         my $b_obj = B::svref_2object( $_[0] );
         return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                 : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                 : undef
                 ;
     }
  
  This will cause that C<encode> method converts simple blessed objects into
  JSON objects as non-blessed object.
  
     JSON -convert_blessed_universally;
     $json->allow_blessed->convert_blessed->encode( $blessed_object )
  
  This feature is experimental and may be removed in the future.
  
  =back
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  With JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  With JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing. (JSON::XS)
  
  With JSON::PP as the backend, when a large value (100 or more) was set and
  it de/encodes a deep nested object/text, it may raise a warning
  'Deep recursion on subroutine' at the perl runtime phase.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 property
  
      $boolean = $json->property($property_name)
  
  Returns a boolean value about above some properties.
  
  The available properties are C<ascii>, C<latin1>, C<utf8>,
  C<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,
  C<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,
  C<shrink>, C<max_depth> and C<max_size>.
  
     $boolean = $json->property('utf8');
      => 0
     $json->utf8;
     $boolean = $json->property('utf8');
      => 1
  
  Sets the property with a given boolean value.
  
      $json = $json->property($property_name => $boolean);
  
  With no argument, it returns all the above properties as a hash reference.
  
      $flag_hashref = $json->property();
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  The backend module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP SUPPORT METHODS
  
  The below methods are JSON::PP own methods, so when C<JSON> works
  with JSON::PP (i.e. the created object is a JSON::PP object), available.
  See to L<JSON::PP/JSON::PP OWN METHODS> in detail.
  
  If you use C<JSON> with additional C<-support_by_pp>, some methods
  are available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.
  
     BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
     # functional interfaces too.
     print to_json(["/"], {escape_slash => 1});
     print from_json('["foo"]', {utf8 => 1});
  
  If you do not want to all functions but C<-support_by_pp>,
  use C<-no_export>.
  
     use JSON -support_by_pp, -no_export;
     # functional interfaces are not exported.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  any JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<MAPPING> about the conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But by default
  JSON backend modules encode strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  With JSON::XS, The indent space length is 3 and cannot be changed.
  With JSON::PP, it sets the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  with 'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  If the backend is JSON::PP and C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  In future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  With C<convert_blessed_universally> mode,  C<encode> converts blessed
  hash references or blessed array references (contains other blessed references)
  into JSON members and arrays.
  
     use JSON -convert_blessed_universally;
     JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  If the backend is JSON::PP and C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 JSON and ECMAscript
  
  See to L<JSON::XS/JSON and ECMAscript>.
  
  =head1 JSON and YAML
  
  JSON is not a subset of YAML.
  See to L<JSON::XS/JSON and YAML>.
  
  
  =head1 BACKEND MODULE DECISION
  
  When you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will
  C<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.
  
  The C<JSON> constructor method returns an object inherited from the backend module,
  and JSON::XS object is a blessed scalar reference while JSON::PP is a blessed hash
  reference.
  
  So, your program should not depend on the backend module, especially
  returned objects should not be modified.
  
   my $json = JSON->new; # XS or PP?
   $json->{stash} = 'this is xs object'; # this code may raise an error!
  
  To check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.
  
    JSON->backend; # 'JSON::XS' or 'JSON::PP'
    
    JSON->backend->is_pp: # 0 or 1
    
    JSON->backend->is_xs: # 1 or 0
    
    $json->is_xs; # 1 or 0
    
    $json->is_pp; # 0 or 1
  
  
  If you set an environment variable C<PERL_JSON_BACKEND>, the calling action will be changed.
  
  =over
  
  =item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'
  
  Always use JSON::PP
  
  =item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'
  
  (The default) Use compiled JSON::XS if it is properly compiled & installed,
  otherwise use JSON::PP.
  
  =item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'
  
  Always use compiled JSON::XS, die if it isn't properly compiled & installed.
  
  =item PERL_JSON_BACKEND = 'JSON::backportPP'
  
  Always use JSON::backportPP.
  JSON::backportPP is JSON::PP back port module.
  C<JSON> includes JSON::backportPP instead of JSON::PP.
  
  =back
  
  These ideas come from L<DBI::PurePerl> mechanism.
  
  example:
  
   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }
   use JSON; # always uses JSON::PP
  
  In future, it may be able to specify another module.
  
  =head1 USE PP FEATURES EVEN THOUGH XS BACKEND
  
  Many methods are available with either JSON::XS or JSON::PP and
  when the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unsupported)
  method is called, it will C<warn> and be noop.
  
  But If you C<use> C<JSON> passing the optional string C<-support_by_pp>,
  it makes a part of those unsupported methods available.
  This feature is achieved by using JSON::PP in C<de/encode>.
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
     use JSON -support_by_pp;
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
  At this time, the returned object is a C<JSON::Backend::XS::Supportable>
  object (re-blessed XS object), and  by checking JSON::XS unsupported flags
  in de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,
  C<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.
  
  When any unsupported methods are not enable, C<XS de/encode> will be
  used as is. The switch is achieved by changing the symbolic tables.
  
  C<-support_by_pp> is effective only when the backend module is JSON::XS
  and it makes the de/encoding speed down a bit.
  
  See to L<JSON::PP SUPPORT METHODS>.
  
  =head1 INCOMPATIBLE CHANGES TO OLD VERSION
  
  There are big incompatibility between new version (2.00) and old (1.xx).
  If you use old C<JSON> 1.xx in your code, please check it.
  
  See to L<Transition ways from 1.xx to 2.xx.>
  
  =over
  
  =item jsonToObj and objToJson are obsoleted.
  
  Non Perl-style name C<jsonToObj> and C<objToJson> are obsoleted
  (but not yet deleted from the source).
  If you use these functions in your code, please replace them
  with C<from_json> and C<to_json>.
  
  
  =item Global variables are no longer available.
  
  C<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...
  - are not available any longer.
  Instead, various features can be used through object methods.
  
  
  =item Package JSON::Converter and JSON::Parser are deleted.
  
  Now C<JSON> bundles with JSON::PP which can handle JSON more properly than them.
  
  =item Package JSON::NotString is deleted.
  
  There was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>
  and numbers. It was deleted and replaced by C<JSON::Boolean>.
  
  C<JSON::Boolean> represents C<true> and C<false>.
  
  C<JSON::Boolean> does not represent C<null>.
  
  C<JSON::null> returns C<undef>.
  
  C<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation
  to L<JSON::Boolean>.
  
  =item function JSON::Number is obsoleted.
  
  C<JSON::Number> is now needless because JSON::XS and JSON::PP have
  round-trip integrity.
  
  =item JSONRPC modules are deleted.
  
  Perl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>
  and C<Apache::JSONRPC > are deleted in this distribution.
  Instead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.
  
  =back
  
  =head2 Transition ways from 1.xx to 2.xx.
  
  You should set C<suport_by_pp> mode firstly, because
  it is always successful for the below codes even with JSON::XS.
  
      use JSON -support_by_pp;
  
  =over
  
  =item Exported jsonToObj (simple)
  
    from_json($json_text);
  
  =item Exported objToJson (simple)
  
    to_json($perl_scalar);
  
  =item Exported jsonToObj (advanced)
  
    $flags = {allow_barekey => 1, allow_singlequote => 1};
    from_json($json_text, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    $JSON::QuotApos = 1;
    jsonToObj($json_text);
  
  =item Exported objToJson (advanced)
  
    $flags = {allow_blessed => 1, allow_barekey => 1};
    to_json($perl_scalar, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    objToJson($perl_scalar);
  
  =item jsonToObj as object method
  
    $json->decode($json_text);
  
  =item objToJson as object method
  
    $json->encode($perl_scalar);
  
  =item new method with parameters
  
  The C<new> method in 2.x takes any parameters no longer.
  You can set parameters instead;
  
     $json = JSON->new->pretty;
  
  =item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
  
  If C<indent> is enable, that means C<$JSON::Pretty> flag set. And
  C<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.
  In conclusion:
  
     $json->indent->space_before->space_after;
  
  Equivalent to:
  
    $json->pretty;
  
  To change indent length, use C<indent_length>.
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->pretty->indent_length(2)->encode($perl_scalar);
  
  =item $JSON::BareKey
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_barekey->decode($json_text)
  
  =item $JSON::ConvBlessed
  
  use C<-convert_blessed_universally>. See to L<convert_blessed>.
  
  =item $JSON::QuotApos
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_singlequote->decode($json_text)
  
  =item $JSON::SingleQuote
  
  Disable. C<JSON> does not make such a invalid JSON string any longer.
  
  =item $JSON::KeySort
  
    $json->canonical->encode($perl_scalar)
  
  This is the ascii sort.
  
  If you want to use with your own sort routine, check the C<sort_by> method.
  
  (Only with JSON::PP, even if C<-support_by_pp> is used currently.)
  
    $json->sort_by($sort_routine_ref)->encode($perl_scalar)
   
    $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)
  
  Can't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.
  
  =item $JSON::SkipInvalid
  
    $json->allow_unknown
  
  =item $JSON::AUTOCONVERT
  
  Needless. C<JSON> backend modules have the round-trip integrity.
  
  =item $JSON::UTF8
  
  Needless because C<JSON> (JSON::XS/JSON::PP) sets
  the UTF8 flag on properly.
  
      # With UTF8-flagged strings
  
      $json->allow_nonref;
      $str = chr(1000); # UTF8-flagged
  
      $json_text  = $json->utf8(0)->encode($str);
      utf8::is_utf8($json_text);
      # true
      $json_text  = $json->utf8(1)->encode($str);
      utf8::is_utf8($json_text);
      # false
  
      $str = '"' . chr(1000) . '"'; # UTF8-flagged
  
      $perl_scalar  = $json->utf8(0)->decode($str);
      utf8::is_utf8($perl_scalar);
      # true
      $perl_scalar  = $json->utf8(1)->decode($str);
      # died because of 'Wide character in subroutine'
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =item $JSON::UnMapping
  
  Disable. See to L<MAPPING>.
  
  =item $JSON::SelfConvert
  
  This option was deleted.
  Instead of it, if a given blessed object has the C<TO_JSON> method,
  C<TO_JSON> will be executed with C<convert_blessed>.
  
    $json->convert_blessed->encode($blessed_hashref_or_arrayref)
    # if need, call allow_blessed
  
  Note that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item example programs
  
  =back
  
  =head1 THREADS
  
  No test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.
  
  
  =head1 BUGS
  
  Please report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.
  
  
  =head1 SEE ALSO
  
  Most of the document is copied and modified from JSON::XS doc.
  
  L<JSON::XS>, L<JSON::PP>
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/MaybeXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_MAYBEXS';
  package JSON::MaybeXS;
  
  use strict;
  use warnings FATAL => 'all';
  use base qw(Exporter);
  
  our $VERSION = '1.003005';
  $VERSION = eval $VERSION;
  
  sub _choose_json_module {
      return 'Cpanel::JSON::XS' if $INC{'Cpanel/JSON/XS.pm'};
      return 'JSON::XS'         if $INC{'JSON/XS.pm'};
  
      my @err;
  
      return 'Cpanel::JSON::XS' if eval { require Cpanel::JSON::XS; 1; };
      push @err, "Error loading Cpanel::JSON::XS: $@";
  
      return 'JSON::XS' if eval { require JSON::XS; 1; };
      push @err, "Error loading JSON::XS: $@";
  
      return 'JSON::PP' if eval { require JSON::PP; 1 };
      push @err, "Error loading JSON::PP: $@";
  
      die join( "\n", "Couldn't load a JSON module:", @err );
  
  }
  
  BEGIN {
      our $JSON_Class = _choose_json_module();
      $JSON_Class->import(qw(encode_json decode_json));
  }
  
  our @EXPORT = qw(encode_json decode_json JSON);
  my @EXPORT_ALL = qw(is_bool);
  our @EXPORT_OK = qw(is_bool to_json from_json);
  our %EXPORT_TAGS = ( all => [ @EXPORT, @EXPORT_ALL ],
                       legacy => [ @EXPORT, @EXPORT_OK ],
                     );
  
  sub JSON () { our $JSON_Class }
  
  sub new {
    shift;
    my %args = @_ == 1 ? %{$_[0]} : @_;
    my $new = (our $JSON_Class)->new;
    $new->$_($args{$_}) for keys %args;
    return $new;
  }
  
  use Scalar::Util ();
  
  sub is_bool {
    die 'is_bool is not a method' if $_[1];
  
    Scalar::Util::blessed($_[0])
      and ($_[0]->isa('JSON::XS::Boolean')
        or $_[0]->isa('Cpanel::JSON::XS::Boolean')
        or $_[0]->isa('JSON::PP::Boolean'));
  }
  
  # (mostly) CopyPasta from JSON.pm version 2.90
  use Carp ();
  
  sub from_json ($@) {
      if ( ref($_[0]) =~ /^JSON/ or $_[0] =~ /^JSON/ ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON()->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  sub to_json ($@) {
      if (
          ref($_[0]) =~ /^JSON/
          or (@_ > 2 and $_[0] =~ /^JSON/)
            ) {
                 Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON()->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  1;
  
  =head1 NAME
  
  JSON::MaybeXS - Use L<Cpanel::JSON::XS> with a fallback to L<JSON::XS> and L<JSON::PP>
  
  =head1 SYNOPSIS
  
    use JSON::MaybeXS;
  
    my $data_structure = decode_json($json_input);
  
    my $json_output = encode_json($data_structure);
  
    my $json = JSON->new;
  
    my $json_with_args = JSON::MaybeXS->new(utf8 => 1); # or { utf8 => 1 }
  
  =head1 DESCRIPTION
  
  This module first checks to see if either L<Cpanel::JSON::XS> or
  L<JSON::XS> is already loaded, in which case it uses that module. Otherwise
  it tries to load L<Cpanel::JSON::XS>, then L<JSON::XS>, then L<JSON::PP>
  in order, and either uses the first module it finds or throws an error.
  
  It then exports the C<encode_json> and C<decode_json> functions from the
  loaded module, along with a C<JSON> constant that returns the class name
  for calling C<new> on.
  
  If you're writing fresh code rather than replacing L<JSON.pm|JSON> usage, you might
  want to pass options as constructor args rather than calling mutators, so
  we provide our own C<new> method that supports that.
  
  =head1 EXPORTS
  
  C<encode_json>, C<decode_json> and C<JSON> are exported by default; C<is_bool>
  is exported on request.
  
  To import only some symbols, specify them on the C<use> line:
  
    use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only
  
    use JSON::MaybeXS qw(JSON); # JSON constant only
  
  To import all available sensible symbols (C<encode_json>, C<decode_json>, and
  C<is_bool>), use C<:all>:
  
    use JSON::MaybeXS ':all';
  
  To import all symbols including those needed by legacy apps that use L<JSON::PP>:
  
    use JSON::MaybeXS ':legacy';
  
  This imports the C<to_json> and C<from_json> symbols as well as everything in
  C<:all>.  NOTE: This is to support legacy code that makes extensive
  use of C<to_json> and C<from_json> which you are not yet in a position to
  refactor.  DO NOT use this import tag in new code, in order to avoid
  the crawling horrors of getting UTF8 support subtly wrong.  See the
  documentation for L<JSON> for further details.
  
  =head2 encode_json
  
  This is the C<encode_json> function provided by the selected implementation
  module, and takes a perl data structure which is serialised to JSON text.
  
    my $json_text = encode_json($data_structure);
  
  =head2 decode_json
  
  This is the C<decode_json> function provided by the selected implementation
  module, and takes a string of JSON text to deserialise to a perl data structure.
  
    my $data_structure = decode_json($json_text);
  
  =head2 to_json, from_json
  
  See L<JSON> for details.  These are included to support legacy code
  B<only>.
  
  =head2 JSON
  
  The C<JSON> constant returns the selected implementation module's name for
  use as a class name - so:
  
    my $json_obj = JSON->new; # returns a Cpanel::JSON::XS or JSON::PP object
  
  and that object can then be used normally:
  
    my $data_structure = $json_obj->decode($json_text); # etc.
  
  =head2 is_bool
  
    $is_boolean = is_bool($scalar)
  
  Returns true if the passed scalar represents either C<true> or
  C<false>, two constants that act like C<1> and C<0>, respectively
  and are used to represent JSON C<true> and C<false> values in Perl.
  
  Since this is a bare sub in the various backend classes, it cannot be called as
  a class method like the other interfaces; it must be called as a function, with
  no invocant.  It supports the representation used in all JSON backends.
  
  =head1 CONSTRUCTOR
  
  =head2 new
  
  With L<JSON::PP>, L<JSON::XS> and L<Cpanel::JSON::XS> you are required to call
  mutators to set options, such as:
  
    my $json = $class->new->utf8(1)->pretty(1);
  
  Since this is a trifle irritating and noticeably un-perlish, we also offer:
  
    my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);
  
  which works equivalently to the above (and in the usual tradition will accept
  a hashref instead of a hash, should you so desire).
  
  =head1 BOOLEANS
  
  To include JSON-aware booleans (C<true>, C<false>) in your data, just do:
  
      use JSON::MaybeXS;
      my $true = JSON->true;
      my $false = JSON->false;
  
  =head1 CAVEATS
  
  The C<new()> method in this module is technically a factory, not a
  constructor, because the objects it returns will I<NOT> be blessed into the
  C<JSON::MaybeXS> class.
  
  If you are using an object returned by this module as a Moo(se) attribute,
  this type constraint code:
  
      is 'json' => ( isa => 'JSON::MaybeXS' );
  
  will I<NOT> do what you expect. Instead, either rely on the C<JSON> class
  constant described above, as so:
  
      is 'json' => ( isa => JSON::MaybeXS::JSON() );
  
  Alternatively, you can use duck typing:
  
      use Moose::Util::TypeConstraints 'duck_type';
      is 'json' => ( isa => Object , duck_type([qw/ encode decode /]));
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item * Clinton Gormley <drtech@cpan.org>
  
  =item * Karen Etheridge <ether@cpan.org>
  
  =item * Kieren Diment <diment@gmail.com>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2013 the C<JSON::MaybeXS> L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
JSON_MAYBEXS

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  use vars qw($VERSION);
  $VERSION = '2.27204';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package # hide from PAUSE
            JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  unless ( $INC{'JSON/PP.pm'} ) {
      eval q|
          package
              JSON::PP::Boolean;
  
          use overload (
              "0+"     => sub { ${$_[0]} },
              "++"     => sub { $_[0] = ${$_[0]} + 1 },
              "--"     => sub { $_[0] = ${$_[0]} - 1 },
              fallback => 1,
          );
      |;
  }
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  use vars qw($VERSION);
  $VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj || '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27200
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and
  L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types
  supported by JSON and Perl, the deserialised data structure is
  identical on the Perl level. (e.g. the string "2.0" doesn't suddenly
  become "2" just because it looks like a number). There I<are> minor
  exceptions to this, read the MAPPING section below to learn about
  those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a
  security feature). But when some options are set, loose checking
  features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Returns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code reference
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutine' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> about the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Returns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte semantics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable
  and similar modules. See L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::backportPP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by
  Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP';
  package LWP;
  
  $VERSION = "6.15";
  sub Version { $VERSION; }
  
  require 5.008;
  require LWP::UserAgent;  # this should load everything you need
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to http, https, gopher, ftp, news,
  file, and mailto resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/Protocols/>:
  
  =over 3
  
  =item *
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name C<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send C<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  B<headers> contains additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name C<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  B<headers> contains additional information about the
  response and describe the content.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is C<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an C<HTTP::Request> object as
  argument and (eventually) returns a C<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  B<agent> specifies the name that your application uses when it
  presents itself on the network.
  
  =item *
  
  B<from> can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  B<proxy> and B<no_proxy> specify if and when to go through
  a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
  
  =item *
  
  B<credentials> provides a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  C<LWP::UserAgent>.  The library includes a
  sub-class, C<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The C<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the MDTM command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to the a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-download>, L<lwp-dump>
  and L<lwp-mirror> are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The C<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_ENV_PROXY
  
  If set to a TRUE value, then the C<LWP::UserAgent> will by default call
  C<env_proxy> during initialization.  This makes LWP honor the proxy variables
  described above.
  
  =item PERL_LWP_SSL_VERIFY_HOSTNAME
  
  The default C<verify_hostname> setting for C<LWP::UserAgent>.  If
  not set the default will be 1.  Set it as 0 to disable hostname
  verification (the default prior to libwww-perl 5.840.
  
  =item PERL_LWP_SSL_CA_FILE
  
  =item PERL_LWP_SSL_CA_PATH
  
  The file and/or directory
  where the trusted Certificate Authority certificates
  is located.  See L<LWP::UserAgent> for details.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is C<URI>.
  You might want to set it to C<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas König,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krüger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skyttä, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/libwww-perl/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  use strict;
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  
  use strict;
  use base 'LWP::Authen::Basic';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  
  	# RFC2617 sais that qop-value and nc-value should be unquoted.
  	if ( $_ eq 'qop' || $_ eq 'nc' ) {
  		push(@pairs, "$_=" . $resp{$_});
  	}
  	else {
  		push(@pairs, "$_=" . qq("$resp{$_}"));
  	}
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  use vars qw/$VERSION/;
  
  $VERSION = "6.15";
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate'); 
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) { 
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  	
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) { 
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  C<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the 
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is 
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there 
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an 
  entirely different interface, it is necessary to ensure that you have the correct 
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different 
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is 
  necessary to ensure that your Mime::Base64 module supports exporting of the 
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your 
  code.  The LWP system will invoke the NTLM authentication when it encounters the 
  authentication scheme while attempting to retrieve a URL from a server.  In order 
  for the NTLM authentication to work, you must have a few things set up in your 
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set 
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials 
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and 
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  use vars qw($VERSION $DEBUG);
  
  $VERSION = "6.15";
  
  
  sub new {
      my($class, %cnf) = @_;
  
      my $total_capacity = 1;
      if (exists $cnf{total_capacity}) {
          $total_capacity = delete $cnf{total_capacity};
      }
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for LWP::UserAgent.
  
  The following basic methods are provided:
  
  =over
  
  =item $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new C<LWP::ConnCache> object.  The only
  option currently accepted is 'total_capacity'.  If specified it
  initialize the total_capacity option.  It defaults to the value 1.
  
  =item $cache->total_capacity( [$num_connections] )
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =item $cache->capacity($type, [$num_connections] )
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The $type will typically be a short string like
  "http" or "ftp".
  
  =item $cache->drop( [$checker, [$reason]] )
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The $reason argument is passed on to the dropped() method.
  
  =item $cache->prune
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the ping() method on the connections.  If the ping()
  method exists and returns a FALSE value, then the connection is
  dropped.
  
  =item $cache->get_types
  
  This returns all the 'type' fields used for the currently cached
  connections.
  
  =item $cache->get_connections( [$type] )
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =back
  
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =over
  
  =item $cache->deposit($type, $key, $conn)
  
  This method adds a new connection to the cache.  As a result other
  already cached connections might be dropped.  Multiple connections with
  the same $type/$key might added.
  
  =item $conn = $cache->withdraw($type, $key)
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =back
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =over
  
  =item $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =item $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  $LWP::ConnCache::DEBUG variable is set and nothing more.
  
  =back
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the deposit(), enforce_limits()
  and dropping() methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUG';
  package LWP::Debug;  # legacy
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  %current_level = ();
  
  
  sub import
  {
      my $pack = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels = ();
      for (@_) {
  	if (/^[-+]/) {
  	    push(@levels, $_);
  	}
  	else {
  	    push(@symbols, $_);
  	}
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  
  sub level
  {
      for (@_) {
  	if ($_ eq '+') {              # all on
  	    # switch on all levels
  	    %current_level = map { $_ => 1 } @levels;
  	}
  	elsif ($_ eq '-') {           # all off
  	    %current_level = ();
  	}
  	elsif (/^([-+])(\w+)$/) {
  	    $current_level{$2} = $1 eq '+';
  	}
  	else {
  	    Carp::croak("Illegal level format $_");
  	}
      }
  }
  
  
  sub trace  { _log(@_) if $current_level{'trace'}; }
  sub debug  { _log(@_) if $current_level{'debug'}; }
  sub conns  { _log(@_) if $current_level{'conns'}; }
  
  
  sub _log
  {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;  # ensure trailing "\n"
  
      my($package,$filename,$line,$sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  LWP::Debug is used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happens to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provides some hints about recommended replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The Wireshark program
  (L<http://www.wireshark.org/>) is highly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
LWP_DEBUG

$fatpacked{"LWP/DebugFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MemberMixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   require LWP::MemberMixin;
   @ISA=qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the %$self.
  Ideally there should be better Perl language support for this.
  
  There is only one method provided:
  
  =over 4
  
  =item _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =back
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.15";
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response;
  
  my %ImplementedBy = (); # scheme => classname
  
  
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ s/[.+\-]/_/g;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
  	# try to autoload it
  	eval "require $ic";
  	if ($@) {
  	    if ($@ =~ /Can't locate/) { #' #emacs get confused by '
  		$ic = '';
  	    }
  	    else {
  		die "$@\n";
  	    }
  	}
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      eval {
  	local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      };
      my $err = $@;
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      if ($err) {
          chomp($err);
          $response->push_header('X-Died' => $err);
          $response->push_header("Client-Aborted", "die");
          return $response;
      }
  
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   require LWP::Protocol;
   @ISA=qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used a the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialized subclass
  appropriate for that access method. In other words, the
  LWP::Protocol::create() function calls the constructor for one of its
  subclasses.
  
  All derived LWP::Protocol classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  The following methods and functions are provided:
  
  =over 4
  
  =item $prot = LWP::Protocol->new()
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =item $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =item $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns '' if the
  specified scheme is not supported.
  
  =item $prot->request(...)
  
   $response = $protocol->request($request, $proxy, undef);
   $response = $protocol->request($request, $proxy, '/tmp/sss');
   $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =item $prot->collect($arg, $response, $collector)
  
  Called to collect the content of a request, and process it
  appropriately into a scalar, file, or by calling a callback.  If $arg
  is undefined, then the content is stored within the $response.  If
  $arg is a simple scalar, then $arg is interpreted as a file name and
  the content is written to this file.  If $arg is a reference to a
  routine, then content is passed to this routine.
  
  The $collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The $collector signals EOF by returning a reference to an
  empty string.
  
  The return value from collect() is the $response object reference.
  
  B<Note:> We will only use the callback or file argument if
  $response->is_success().  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =item $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as
  $content.  This will invoke collect() with a collector callback that
  returns a reference to $content the first time and an empty string the
  next.
  
  =back
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/GHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GHTTP';
  package LWP::Protocol::GHTTP;
  
  # You can tell LWP to use this module for 'http' requests by running
  # code like this before you make requests:
  #
  #    require LWP::Protocol::GHTTP;
  #    LWP::Protocol::implementor('http', 'LWP::Protocol::GHTTP');
  #
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA=qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  
  use HTTP::GHTTP qw(METHOD_GET METHOD_HEAD METHOD_POST);
  
  my %METHOD =
  (
   GET  => METHOD_GET,
   HEAD => METHOD_HEAD,
   POST => METHOD_POST,
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $method = $request->method;
      unless (exists $METHOD{$method}) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Bad method '$method'");
      }
  
      my $r = HTTP::GHTTP->new($request->uri);
  
      # XXX what headers for repeated headers here?
      $request->headers->scan(sub { $r->set_header(@_)});
  
      $r->set_type($METHOD{$method});
  
      # XXX should also deal with subroutine content.
      my $cref = $request->content_ref;
      $r->set_body($$cref) if length($$cref);
  
      # XXX is this right
      $r->set_proxy($proxy->as_string) if $proxy;
  
      $r->process_request;
  
      my $response = HTTP::Response->new($r->get_status);
  
      # XXX How can get the headers out of $r??  This way is too stupid.
      my @headers;
      eval {
  	# Wrapped in eval because this method is not always available
  	@headers = $r->get_headers;
      };
      @headers = qw(Date Connection Server Content-type
                    Accept-Ranges Server
                    Content-Length Last-Modified ETag) if $@;
      for (@headers) {
  	my $v = $r->get_header($_);
  	$response->header($_ => $v) if defined $v;
      }
  
      return $self->collect_once($arg, $response, $r->get_body);
  }
  
  1;
LWP_PROTOCOL_GHTTP

$fatpacked{"LWP/Protocol/cpan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( &HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( &HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( &HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(F, $path) or return new
  	    HTTP::Response(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode(F);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread(F, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close(F);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  
  use Carp ();
  
  use HTTP::Status ();
  use HTTP::Negotiate ();
  use HTTP::Response ();
  use LWP::MediaTypes ();
  use File::Listing ();
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  eval {
      package LWP::Protocol::MyFTP;
  
      require Net::FTP;
      Net::FTP->require_version(2.00);
  
      use vars qw(@ISA);
      @ISA=qw(Net::FTP);
  
      sub new {
  	my $class = shift;
  
  	my $self = $class->SUPER::new(@_) || return undef;
  
  	my $mess = $self->message;  # welcome message
  	$mess =~ s|\n.*||s; # only first line left
  	$mess =~ s|\s*ready\.?$||;
  	# Make the version number more HTTP like
  	$mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
  	${*$self}{myftp_server} = $mess;
  	#$response->header("Server", $mess);
  
  	$self;
      }
  
      sub http_server {
  	my $self = shift;
  	${*$self}{myftp_server};
      }
  
      sub home {
  	my $self = shift;
  	my $old = ${*$self}{myftp_home};
  	if (@_) {
  	    ${*$self}{myftp_home} = shift;
  	}
  	$old;
      }
  
      sub go_home {
  	my $self = shift;
  	$self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
  	my $self = shift;
  	++${*$self}{myftp_reqcount};
      }
  
      sub ping {
  	my $self = shift;
  	return $self->go_home;
      }
  
  };
  my $init_failed = $@;
  
  
  sub _connect {
      my($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	$key = "$host:$port:$user";
  	$key .= ":$account" if defined($account);
  	if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
  	    if ($ftp->ping) {
  		# save it again
  		$conn_cache->deposit("ftp", $key, $ftp);
  		return $ftp;
  	    }
  	}
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new($host,
  					Port => $port,
  					Timeout => $timeout,
  					LocalAddr => $self->{ua}{local_address},
  				       );
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
  	$@ =~ s/^Net::FTP: //;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  	# Unauthorized.  Let's fake a RC_UNAUTHORIZED response
  	my $mess = scalar($ftp->message);
  	$mess =~ s/\n$//;
  	my $res =  HTTP::Response->new(&HTTP::Status::RC_UNAUTHORIZED, $mess);
  	$res->header("Server", $ftp->http_server);
  	$res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
  	return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
  	my $scheme = $url->scheme;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  		       "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'ftp:' URLs");
      }
  
      if ($init_failed) {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   $init_failed);
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic authorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
  	my($u,$p) = $request->authorization_basic;
  	if (defined $u) {
  	    $user = $u;
  	    $password = $p;
  	}
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response"; # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header(Server => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path =  grep { length } $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
  	my @params;
  	($remote_file, @params) = @$remote_file;
  	for (@params) {
  	    $type = $_ if s/^type=//;
  	}
      }
  
      if ($type && $type eq 'a') {
  	$ftp->ascii;
      }
      else {
  	$ftp->binary;
      }
  
      for (@path) {
  	unless ($ftp->cwd($_)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  				       "Can't chdir to $_");
  	}
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
  	if (my $mod_time = $ftp->mdtm($remote_file)) {
  	    $response->last_modified($mod_time);
  	    if (my $ims = $request->if_modified_since) {
  		if ($mod_time <= $ims) {
  		    $response->code(&HTTP::Status::RC_NOT_MODIFIED);
  		    $response->message("Not modified");
  		    return $response;
  		}
  	    }
  	}
  
  	# We'll use this later to abort the transfer if necessary. 
  	# if $max_size is defined, we need to abort early. Otherwise, it's
        # a normal transfer
  	my $max_size = undef;
  
  	# Set resume location, if the client requested it
  	if ($request->header('Range') && $ftp->supported('REST'))
  	{
  		my $range_info = $request->header('Range');
  
  		# Change bytes=2772992-6781209 to just 2772992
  		my ($start_byte,$end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
  		if ( defined $start_byte && !defined $end_byte ) {
  
  		  # open range -- only the start is specified
  
  		  $ftp->restart( $start_byte );
  		  # don't define $max_size, we don't want to abort early
  		}
  		elsif ( defined $start_byte && defined $end_byte &&
  			$start_byte >= 0 && $end_byte >= $start_byte ) {
  
  		  $ftp->restart( $start_byte );
  		  $max_size = $end_byte - $start_byte;
  		}
  		else {
  
  		  return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  		     'Incorrect syntax for Range request');
  		}
  	}
  	elsif ($request->header('Range') && !$ftp->supported('REST'))
  	{
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  	         "Server does not support resume.");
  	}
  
  	my $data;  # the data handle
  	if (length($remote_file) and $data = $ftp->retr($remote_file)) {
  	    my($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
  	    $response->header('Content-Type',   $type) if $type;
  	    for (@enc) {
  		$response->push_header('Content-Encoding', $_);
  	    }
  	    my $mess = $ftp->message;
  	    if ($mess =~ /\((\d+)\s+bytes\)/) {
  		$response->header('Content-Length', "$1");
  	    }
  
  	    if ($method ne 'HEAD') {
  		# Read data from server
  		$response = $self->collect($arg, $response, sub {
  		    my $content = '';
  		    my $result = $data->read($content, $size);
  
                      # Stop early if we need to.
                      if (defined $max_size)
                      {
                        # We need an interface to Net::FTP::dataconn for getting
                        # the number of bytes already read
                        my $bytes_received = $data->bytes_read();
  
                        # We were already over the limit. (Should only happen
                        # once at the end.)
                        if ($bytes_received - length($content) > $max_size)
                        {
                          $content = '';
                        }
                        # We just went over the limit
                        elsif ($bytes_received  > $max_size)
                        {
                          # Trim content
                          $content = substr($content, 0,
                            $max_size - ($bytes_received - length($content)) );
                        }
                        # We're under the limit
                        else
                        {
                        }
                      }
  
  		    return \$content;
  		} );
  	    }
  	    # abort is needed for HEAD, it's == close if the transfer has
  	    # already completed.
  	    unless ($data->abort) {
  		# Something did not work too well.  Note that we treat
  		# responses to abort() with code 0 in case of HEAD as ok
  		# (at least wu-ftpd 2.6.1(1) does that).
  		if ($method ne 'HEAD' || $ftp->code != 0) {
  		    $response->code(&HTTP::Status::RC_INTERNAL_SERVER_ERROR);
  		    $response->message("FTP close response: " . $ftp->code .
  				       " " . $ftp->message);
  		}
  	    }
  	}
  	elsif (!length($remote_file) || ( $ftp->code >= 400 && $ftp->code < 600 )) {
  	    # not a plain file, try to list instead
  	    if (length($remote_file) && !$ftp->cwd($remote_file)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  					   "File '$remote_file' not found");
  	    }
  
  	    # It should now be safe to try to list the directory
  	    my @lsl = $ftp->dir;
  
  	    # Try to figure out if the user want us to convert the
  	    # directory listing to HTML.
  	    my @variants =
  	      (
  	       ['html',  0.60, 'text/html'            ],
  	       ['dir',   1.00, 'text/ftp-dir-listing' ]
  	      );
  	    #$HTTP::Negotiate::DEBUG=1;
  	    my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
  	    my $content = '';
  
  	    if (!defined($prefer)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_ACCEPTABLE,
  			       "Neither HTML nor directory listing wanted");
  	    }
  	    elsif ($prefer eq 'html') {
  		$response->header('Content-Type' => 'text/html');
  		$content = "<HEAD><TITLE>File Listing</TITLE>\n";
  		my $base = $request->uri->clone;
  		my $path = $base->path;
  		$base->path("$path/") unless $path =~ m|/$|;
  		$content .= qq(<BASE HREF="$base">\n</HEAD>\n);
  		$content .= "<BODY>\n<UL>\n";
  		for (File::Listing::parse_dir(\@lsl, 'GMT')) {
  		    my($name, $type, $size, $mtime, $mode) = @$_;
  		    $content .= qq(  <LI> <a href="$name">$name</a>);
  		    $content .= " $size bytes" if $type eq 'f';
  		    $content .= "\n";
  		}
  		$content .= "</UL></body>\n";
  	    }
  	    else {
  		$response->header('Content-Type', 'text/ftp-dir-listing');
  		$content = join("\n", @lsl, '');
  	    }
  
  	    $response->header('Content-Length', length($content));
  
  	    if ($method ne 'HEAD') {
  		$response = $self->collect_once($arg, $response, $content);
  	    }
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  			  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      elsif ($method eq 'PUT') {
  	# method must be PUT
  	unless (length($remote_file)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				       "Must have a file name to PUT to");
  	}
  	my $data;
  	if ($data = $ftp->stor($remote_file)) {
  	    my $content = $request->content;
  	    my $bytes = 0;
  	    if (defined $content) {
  		if (ref($content) eq 'SCALAR') {
  		    $bytes = $data->write($$content, length($$content));
  		}
  		elsif (ref($content) eq 'CODE') {
  		    my($buf, $n);
  		    while (length($buf = &$content)) {
  			$n = $data->write($buf, length($buf));
  			last unless $n;
  			$bytes += $n;
  		    }
  		}
  		elsif (!ref($content)) {
  		    if (defined $content && length($content)) {
  			$bytes = $data->write($content, length($content));
  		    }
  		}
  		else {
  		    die "Bad content";
  		}
  	    }
  	    $data->close;
  
  	    $response->code(&HTTP::Status::RC_CREATED);
  	    $response->header('Content-Type', 'text/plain');
  	    $response->content("$bytes bytes stored as $remote_file on $host\n")
  
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  					  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      else {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
      
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ s/\015//g;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use vars qw(@ISA @EXTRA_SOCK_OPTS);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
  
      # IPv6 literal IP address should be [bracketed] to remove
      # ambiguity between ip address and port number.
      if ( ($host =~ /:/) && ($host !~ /^\[/) ) {
        $host = "[$host]";
      }
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$self->{ua}{conn_cache},
  					SendTE    => 1,
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	my $status = "Can't connect to $host:$port";
  	if ($@ =~ /\bconnect: (.*)/ ||
  	    $@ =~ /\b(Bad hostname)\b/ ||
  	    $@ =~ /\b(certificate verify failed)\b/ ||
  	    $@ =~ /\b(Crypt-SSLeay can't verify hostnames)\b/
  	) {
  	    $status .= " ($1)";
  	}
  	die "$status\n\n$@";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy && $url->scheme ne 'https') {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port".
  	# For https only the initial CONNECT requests needs authorization.
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
  
      # Proxying SSL with a http proxy needs issues a CONNECT request to build a
      # tunnel and then upgrades the tunnel to SSL. But when doing keep-alive the
      # https request does not need to be the first request in the connection, so
      # we need to distinguish between
      # - not yet connected (create socket and ssl upgrade)
      # - connected but not inside ssl tunnel (ssl upgrade)
      # - inside ssl tunnel to the target - once we are in the tunnel to the
      #   target we cannot only reuse the tunnel for more https requests with the
      #   same target
  
      my $ssl_tunnel = $proxy && $url->scheme eq 'https'
  	&& $url->host.":".$url->port;
  
      my ($host,$port) = $proxy
  	? ($proxy->host,$proxy->port)
  	: ($url->host,$url->port);
      my $fullpath =
  	$method eq 'CONNECT' ? $url->host . ":" . $url->port :
  	$proxy && ! $ssl_tunnel ? $url->as_string :
  	do {
  	    my $path = $url->path_query;
  	    $path = "/$path" if $path !~m{^/};
  	    $path
  	};
  
      my $socket;
      my $conn_cache = $self->{ua}{conn_cache};
      my $cache_key;
      if ( $conn_cache ) {
  	$cache_key = "$host:$port";
  	# For https we reuse the socket immediatly only if it has an established
  	# tunnel to the target. Otherwise a CONNECT request followed by an SSL
  	# upgrade need to be done first. The request itself might reuse an
  	# existing non-ssl connection to the proxy
  	$cache_key .= "!".$ssl_tunnel if $ssl_tunnel;
  	if ( $socket = $conn_cache->withdraw($self->socket_type,$cache_key)) {
  	    if ($socket->can_read(0)) {
  		# if the socket is readable, then either the peer has closed the
  		# connection or there are some garbage bytes on it.  In either
  		# case we abandon it.
  		$socket->close;
  		$socket = undef;
  	    } # else use $socket
  	}
      }
  
      if ( ! $socket && $ssl_tunnel ) {
  	my $proto_https = LWP::Protocol::create('https',$self->{ua})
  	    or die "no support for scheme https found";
  
  	# only if ssl socket class is IO::Socket::SSL we can upgrade
  	# a plain socket to SSL. In case of Net::SSL we fall back to
  	# the old version
  	if ( my $upgrade_sub = $proto_https->can('_upgrade_sock')) {
  	    my $response = $self->request(
  		HTTP::Request->new('CONNECT',"http://$ssl_tunnel"),
  		$proxy,
  		undef,$size,$timeout
  	    );
  	    $response->is_success or die
  		"establishing SSL tunnel failed: ".$response->status_line;
  	    $socket = $upgrade_sub->($proto_https,
  		$response->{client_socket},$url)
  		or die "SSL upgrade failed: $@";
  	} else {
  	    $socket = $proto_https->_new_socket($url->host,$url->port,$timeout);
  	}
      }
  
      if ( ! $socket ) {
  	# connect to remote site w/o reusing established socket
  	$socket = $self->_new_socket($host, $port, $timeout );
      }
  
      my $http_version = "";
      if (my $proto = $request->protocol) {
  	if ($proto =~ /^(?:HTTP\/)?(1.\d+)$/) {
  	    $http_version = $1;
  	    $socket->http_version($http_version);
  	    $socket->send_te(0) if $http_version eq "1.0";
  	}
      }
  
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ s/\n/ /g;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EWOULDBLOCK} || $!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
        INITIAL_READ:
  	if ($write_wait) {
  	    # skip filling $wbuf when waiting for 100-continue
  	    # because if the response is a redirect or auth required
  	    # the request will be cloned and there is no way
  	    # to reset the input stream
  	    # return here via the label after the 100-continue is read
  	}
  	elsif (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($write_wait || $woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  			goto INITIAL_READ;
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EWOULDBLOCK} || $!{EAGAIN} || $!{ENOTTY};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if ($cache_key) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, $cache_key, $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::SocketMethods;
  
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::Socket;
  use vars qw(@ISA);
  @ISA = qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/loopback.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require LWP::Protocol;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  use vars qw(@ISA $SENDMAIL);
  
  @ISA = qw(LWP::Protocol);
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new($url->host,
  			      #Port    => 18574,
  			      Timeout => $timeout,
  			      #Debug   => 1,
  			     );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
  	return HTTP::Response->new(&HTTP::Status::RC_SERVICE_UNAVAILABLE,
  				   $nntp->message);
      }
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	$response->message("POST not implemented yet");
  	return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
  	if (!$nntp->group($groupart)) {
  	    $response->code(&HTTP::Status::RC_NOT_FOUND);
  	    $response->message($nntp->message);
  	}
  	$nntp->quit; $nntp = undef;
  	# HEAD: just check if the group exists
  	if ($method eq 'GET' && $response->is_success) {
  	    $response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	    $response->message("GET newsgroup not implemented yet");
  	}
  	return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_FOUND);
  	$response->message($nntp->message);
  	return $response;
      }
  
      # Parse headers
      my($key, $val);
      local $_;
      while ($_ = shift @$art) {
  	if (/^\s+$/) {
  	    last;  # end of headers
  	}
  	elsif (/^(\S+):\s*(.*)/) {
  	    $response->push_header($key, $val) if $key;
  	    ($key, $val) = ($1, $2);
  	}
  	elsif (/^\s+(.*)/) {
  	    next unless $key;
  	    $val .= $1;
  	}
  	else {
  	    unshift(@$art, $_);
  	    last;
  	}
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
  	unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art))
        if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  require HTTP::Status;
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
      
      return HTTP::Response->new(
        &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  require LWP::UserAgent;
  @ISA = qw(LWP::UserAgent);
  $VERSION = "6.15";
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'}); 
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, ""); 
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $parse_head = $self->parse_head(0);
  	my $robot_res = $self->request($robot_req);
  	$self->parse_head($parse_head);
  	my $fresh_until = $robot_res->fresh_until;
  	my $content = "";
  	if ($robot_res->is_success && $robot_res->content_is_text) {
  	    $content = $robot_res->decoded_content;
  	    $content = "" unless $content && $content =~ /^\s*Disallow\s*:/mi;
  	}
  	$self->{'rules'}->parse($robot_url, $content, $fresh_until);
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  &HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      &HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  <URL:http://www.robotstxt.org/>.
  
  When you use an I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of LWP::UserAgent and implements the
  same methods. In addition the following methods are provided:
  
  =over 4
  
  =item $ua = LWP::RobotUA->new( %options )
  
  =item $ua = LWP::RobotUA->new( $agent, $from )
  
  =item $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =item $ua->delay
  
  =item $ua->delay( $minutes )
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is 1 minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to 10 seconds:
  
      $ua->delay(10/60);
  
  =item $ua->use_sleep
  
  =item $ua->use_sleep( $boolean )
  
  Get/set a value indicating whether the UA should sleep() if requests
  arrive too fast, defined as $ua->delay minutes not passed since
  last request to the given server.  The default is TRUE.  If this value is
  FALSE then an internal SERVICE_UNAVAILABLE response will be generated.
  It will have a Retry-After header that indicates when it is OK to
  send another request to this server.
  
  =item $ua->rules
  
  =item $ua->rules( $rules )
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =item $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named num_visits() or
  something like that. :-(
  
  =item $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =item $ua->as_string
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =back
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  use vars qw($ua %loop_check $FULL_LWP @EXPORT @EXPORT_OK $VERSION);
  
  require Exporter;
  
  @EXPORT = qw(get head getprint getstore mirror);
  @EXPORT_OK = qw($ua);
  
  # I really hate this.  I was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  $VERSION = "6.15";
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Status ();
  use HTTP::Date ();
  $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the C<LWP::UserAgent> module.
  
  The following functions are provided (and exported) by this module:
  
  =over 3
  
  =item get($url)
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The $url argument can
  be either a string or a reference to a URI object.
  
  You will not be able to examine the response code or response headers
  (like 'Content-Type') when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =item head($url)
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =item getprint($url)
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =item getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =item mirror($url, $file)
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =back
  
  This module also exports the HTTP::Status constants and procedures.
  You can use them when you check the response code from getprint(),
  getstore() or mirror().  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  The HTTP::Status classification functions are:
  
  =over 3
  
  =item is_success($rc)
  
  True if response code indicated a successful request.
  
  =item is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =back
  
  The module will also export the LWP::UserAgent object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  "LWP::Simple/#.##"
  and will initialize its proxy defaults from the environment (by
  calling $ua->env_proxy).
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular CGI.pm
  module, you may be importing a C<head> function from each module,
  producing a warning like "Prototype mismatch: sub main::head ($) vs
  none". Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.15";
  
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Carp ();
  
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference") 
          if ref($_[1]) eq 'HASH'; 
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $ssl_opts = delete $cnf{ssl_opts} || {};
      unless (exists $ssl_opts->{verify_hostname}) {
  	# The processing of HTTPS_CA_* below is for compatibility with Crypt::SSLeay
  	if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
  	    $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
  	}
  	elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
  	    # Crypt-SSLeay compatibility (verify peer certificate; but not the hostname)
  	    $ssl_opts->{verify_hostname} = 0;
  	    $ssl_opts->{SSL_verify_mode} = 1;
  	}
  	else {
  	    $ssl_opts->{verify_hostname} = 1;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_file}) {
  	if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
  	    $ssl_opts->{SSL_ca_file} = $ca_file;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_path}) {
  	if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
  	    $ssl_opts->{SSL_ca_path} = $ca_path;
  	}
      }
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = exists $cnf{env_proxy} ? delete $cnf{env_proxy} : $ENV{PERL_LWP_ENV_PROXY};
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
      
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
      
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
  		      def_headers  => $def_headers,
  		      timeout      => $timeout,
  		      local_address => $local_address,
  		      ssl_opts     => $ssl_opts,
  		      use_eval     => $use_eval,
                        show_progress=> $show_progress,
  		      max_size     => $max_size,
  		      max_redirect => $max_redirect,
                        proxy        => {},
  		      no_proxy     => [],
                        protocols_allowed     => $protocols_allowed,
                        protocols_forbidden   => $protocols_forbidden,
                        requests_redirectable => $requests_redirectable,
  		     }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
  	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              $protocol = eval { LWP::Protocol::create($scheme, $self) };
              if ($@) {
                  $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (LWP::Protocol::https not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if the LWP::Protocol::https module
  is installed.
  EOT
                  }
              }
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              eval {
                  $response = $protocol->request($request, $proxy, $arg, $size, $self->{timeout}) ||
  		    die "No response returned by $protocol";
              };
              if ($@) {
                  if (UNIVERSAL::isa($@, "HTTP::Response")) {
                      $response = $@;
                      $response->request($request);
                  }
                  else {
                      my $full = $@;
                      (my $status = $@) =~ s/\n.*//s;
                      $status =~ s/ at .* line \d+.*//s;  # remove file/line number
                      my $code = ($status =~ s/^(\d\d\d)\s+//) ? $1 : &HTTP::Status::RC_INTERNAL_SERVER_ERROR;
                      $response = _new_response($request, $code, $status, $full);
                  }
              }
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      eval {
  	$request = $self->prepare_request($request);
      };
      if ($@) {
  	$@ =~ s/ at .* line \d+.*//s;  # remove file/line number
  	return _new_response($request, &HTTP::Status::RC_BAD_REQUEST, $@);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request
  {
      my($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                            "Redirect loop detected (max_redirect = $self->{max_redirect})");
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if ($code == &HTTP::Status::RC_MOVED_PERMANENTLY or
  	$code == &HTTP::Status::RC_FOUND or
  	$code == &HTTP::Status::RC_SEE_OTHER or
  	$code == &HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
  	my $referral = $request->clone;
  
  	# These headers should never be forwarded
  	$referral->remove_header('Host', 'Cookie');
  	
  	if ($referral->header('Referer') &&
  	    $request->uri->scheme eq 'https' &&
  	    $referral->uri->scheme eq 'http')
  	{
  	    # RFC 2616, section 15.1.3.
  	    # https -> http redirect, suppressing Referer
  	    $referral->remove_header('Referer');
  	}
  
  	if ($code == &HTTP::Status::RC_SEE_OTHER ||
  	    $code == &HTTP::Status::RC_FOUND) 
          {
  	    my $method = uc($referral->method);
  	    unless ($method eq "GET" || $method eq "HEAD") {
  		$referral->method("GET");
  		$referral->content("");
  		$referral->remove_content_headers;
  	    }
  	}
  
  	# And then we update the URL based on the Location:-header.
  	my $referral_uri = $response->header('Location');
  	{
  	    # Some servers erroneously return a relative URL for redirects,
  	    # so make it absolute if it not already is.
  	    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
  	    my $base = $response->base;
  	    $referral_uri = "" unless defined $referral_uri;
  	    $referral_uri = $HTTP::URI_CLASS->new($referral_uri, $base)
  		            ->abs($base);
  	}
  	$referral->uri($referral_uri);
  
  	return $response unless $self->redirect_ok($referral, $response);
  	return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == &HTTP::Status::RC_UNAUTHORIZED ||
  	     $code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED
  	    )
      {
  	my $proxy = ($code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
  	my $ch_header = $proxy || $request->method eq 'CONNECT'
  	    ?  "Proxy-Authenticate" : "WWW-Authenticate";
  	my @challenge = $response->header($ch_header);
  	unless (@challenge) {
  	    $response->header("Client-Warning" => 
  			      "Missing Authenticate header");
  	    return $response;
  	}
  
  	require HTTP::Headers::Util;
  	CHALLENGE: for my $challenge (@challenge) {
  	    $challenge =~ tr/,/;/;  # "," is used to separate auth-params!!
  	    ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
  	    my $scheme = shift(@$challenge);
  	    shift(@$challenge); # no value
  	    $challenge = { @$challenge };  # make rest into a hash
  
  	    unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
  		$response->header("Client-Warning" => 
  				  "Bad authentication scheme '$scheme'");
  		return $response;
  	    }
  	    $scheme = $1;  # untainted now
  	    my $class = "LWP::Authen::\u$scheme";
  	    $class =~ s/-/_/g;
  
  	    no strict 'refs';
  	    unless (%{"$class\::"}) {
  		# try to load it
  		eval "require $class";
  		if ($@) {
  		    if ($@ =~ /^Can\'t locate/) {
  			$response->header("Client-Warning" =>
  					  "Unsupported authentication scheme '$scheme'");
  		    }
  		    else {
  			$response->header("Client-Warning" => $@);
  		    }
  		    next CHALLENGE;
  		}
  	    }
  	    unless ($class->can("authenticate")) {
  		$response->header("Client-Warning" =>
  				  "Unsupported authentication scheme '$scheme'");
  		next CHALLENGE;
  	    }
  	    return $class->authenticate($self, $proxy, $challenge, $response,
  					$request, $arg, $size);
  	}
  	return $response;
      }
      return $response;
  }
  
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::POST( @parameters ), @suff );
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub put {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::PUT( @parameters ), @suff );
  }
  
  
  sub delete {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::DELETE( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  	    
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  
  sub is_online {
      my $self = shift;
      return 1 if $self->get("http://www.msftncsi.com/ncsi.txt")->content eq "Microsoft NCSI";
      return 1 if $self->get("http://www.apple.com")->content =~ m,<title>Apple</title>,;
      return 0;
  }
  
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
      
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
      
      # Otherwise it's apparently okay...
      return 1;
  }
  
  
  sub credentials
  {
      my $self = shift;
      my $netloc = lc(shift);
      my $realm = shift || "";
      my $old = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  
  sub ssl_opts {
      my $self = shift;
      if (@_ == 1) {
  	my $k = shift;
  	return $self->{ssl_opts}{$k};
      }
      if (@_) {
  	my $old;
  	while (@_) {
  	    my($k, $v) = splice(@_, 0, 2);
  	    $old = $self->{ssl_opts}{$k} unless @_;
  	    if (defined $v) {
  		$self->{ssl_opts}{$k} = $v;
  	    }
  	    else {
  		delete $self->{ssl_opts}{$k};
  	    }
  	}
  	%{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
  	return $old;
      }
  
      return keys %{$self->{ssl_opts}};
  }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent       { "libwww-perl/$LWP::VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($o, $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($o, $self, $h);
      }
  }
  
  
  # deprecated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which 
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length. 
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some DOSish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file  
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy
  {
      my $self = shift;
      my $key  = shift;
      return map $self->proxy($_, @_), @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      require Encode;
      require Encode::Locale;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, Encode::decode(locale => $v));
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message, $content) = @_;
      $message ||= HTTP::Status::status_message($code);
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content($content || "$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   require LWP::UserAgent;
   
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
   
   my $response = $ua->get('http://search.cpan.org/');
   
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The C<LWP::UserAgent> is a class implementing a web user agent.
  C<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an C<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of C<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a C<HTTP::Response> object.  There are
  convenience methods for sending the most common request types: get(),
  head(), post(), put() and delete().  When using these methods then the
  creation of the request object is hidden as shown in the synopsis above.
  
  The basic approach of the library is to use HTTP style communication
  for all protocol schemes.  This means that you will construct
  C<HTTP::Request> objects and receive C<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP style communications, gopher menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =over 4
  
  =item $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new C<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     ssl_opts		   { verify_hostname => 1 }
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
  
  The following additional options are also accepted: If the C<env_proxy> option
  is passed in with a TRUE value, then proxy settings are read from environment
  variables (see env_proxy() method below).  If C<env_proxy> isn't provided the
  C<PERL_LWP_ENV_PROXY> environment variable controls if env_proxy() is called
  during initialization.  If the C<keep_alive> option is passed in, then a
  C<LWP::ConnCache> is set up (see conn_cache() method below).  The C<keep_alive>
  value is passed on as the C<total_capacity> for the connection cache.
  
  =item $ua->clone
  
  Returns a copy of the LWP::UserAgent object.
  
  =back
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  C<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =over
  
  =item $ua->agent
  
  =item $ua->agent( $product_id )
  
  Get/set the product token that is used to identify the user agent on
  the network.  The agent value is sent as the "User-Agent" header in
  the requests.  The default is the string returned by the _agent()
  method (see below).
  
  If the $product_id ends with space then the _agent() string is
  appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the "/" character.
  Examples are:
  
    $ua->agent('Checkbot/0.4 ' . $ua->_agent);
    $ua->agent('Checkbot/0.4 ');    # same as above
    $ua->agent('Mozilla/5.0');
    $ua->agent("");                 # don't identify
  
  =item $ua->_agent
  
  Returns the default agent identifier.  This is a string of the form
  "libwww-perl/#.###", where "#.###" is substituted with the version number
  of this library.
  
  =item $ua->from
  
  =item $ua->from( $email_address )
  
  Get/set the e-mail address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in RFC 822.  The C<from> value is send as the "From" header in
  the requests.  Example:
  
    $ua->from('gaas@cpan.org');
  
  The default is to not send a "From" header.  See the default_headers()
  method for the more general interface that allow any header to be defaulted.
  
  =item $ua->cookie_jar
  
  =item $ua->cookie_jar( $cookie_jar_obj )
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the extract_cookies($response) and
  add_cookie_header($request) methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a C<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie_jar, i.e. never automatically add
  "Cookie" headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in as the
  $cookie_jar_object, then it is replaced with an instance of
  C<HTTP::Cookies> that is initialized based on the hash.  This form also
  automatically loads the C<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =item $ua->default_headers
  
  =item $ua->default_headers( $headers_obj )
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty C<HTTP::Headers>
  object.
  
  =item $ua->default_header( $field )
  
  =item $ua->default_header( $field => $value )
  
  This is just a short-cut for $ua->default_headers->header( $field =>
  $value ). Example:
  
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
    $ua->default_header('Accept-Language' => "no, en");
  
  =item $ua->conn_cache
  
  =item $ua->conn_cache( $cache_obj )
  
  Get/set the C<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =item $ua->credentials( $netloc, $realm )
  
  =item $ua->credentials( $netloc, $realm, $uname, $pass )
  
  Get/set the user name and password to be used for a realm.
  
  The $netloc is a string of the form "<host>:<port>".  The username and
  password will only be passed to this server.  Example:
  
    $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  =item $ua->local_address
  
  =item $ua->local_address( $address )
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =item $ua->max_size
  
  =item $ua->max_size( $bytes )
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  "Client-Aborted" header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The "Content-Length"
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =item $ua->max_redirect
  
  =item $ua->max_redirect( $n )
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is 7. This means that if you call request()
  method and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =item $ua->parse_head
  
  =item $ua->parse_head( $boolean )
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  TRUE.  Do not turn this off, unless you know what you are doing.
  
  =item $ua->protocols_allowed
  
  =item $ua->protocols_allowed( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_allowed( [ 'http', 'https'] );>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like "ftp://...") will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_allowed(undef)>
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  C<protocols_forbidden> list.
  
  Note that having a C<protocols_allowed> list causes any
  C<protocols_forbidden> list to be ignored.
  
  =item $ua->protocols_forbidden
  
  =item $ua->protocols_forbidden( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_forbidden( [ 'file', 'mailto'] );>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_forbidden(undef)>
  
  =item $ua->requests_redirectable
  
  =item $ua->requests_redirectable( \@requests )
  
  This reads or sets the object's list of request names that
  C<$ua-E<gt>redirect_ok(...)> will allow redirection for.  By
  default, this is C<['GET', 'HEAD']>, as per RFC 2616.  To
  change to include 'POST', consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =item $ua->show_progress
  
  =item $ua->show_progress( $boolean )
  
  Get/set a value indicating whether a progress bar should be displayed
  on the terminal as requests are processed. The default is FALSE.
  
  =item $ua->timeout
  
  =item $ua->timeout( $secs )
  
  Get/set the timeout value in seconds. The default timeout() value is
  180 seconds, i.e. 3 minutes.
  
  The requests is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the request() method to actually
  return might be longer.
  
  =item $ua->ssl_opts
  
  =item $ua->ssl_opts( $key )
  
  =item $ua->ssl_opts( $key => $value )
  
  Get/set the options for SSL connections.  Without argument return the list
  of options keys currently set.  With a single argument return the current
  value for the given option.  With 2 arguments set the option value and return
  the old.  Setting an option to the value C<undef> removes this option.
  
  The options that LWP relates to are:
  
  =over
  
  =item C<verify_hostname> => $bool
  
  When TRUE LWP will for secure protocol schemes ensure it connects to servers
  that have a valid certificate matching the expected hostname.  If FALSE no
  checks are made and you can't be sure that you communicate with the expected peer.
  The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
  
  This option is initialized from the L<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
  variable.  If this environment variable isn't set; then C<verify_hostname>
  defaults to 1.
  
  =item C<SSL_ca_file> => $path
  
  The path to a file containing Certificate Authority certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order.
  
  =item C<SSL_ca_path> => $path
  
  The path to a directory containing files containing Certificate Authority
  certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
  
  =back
  
  Other options can be set and are processed directly by the SSL Socket implementation
  in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
  
  The libwww-perl core no longer bundles protocol plugins for SSL.  You will need
  to install L<LWP::Protocol::https> separately to enable support for processing
  https-URLs.
  
  =back
  
  =head2 Proxy attributes
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =over
  
  =item $ua->proxy(\@schemes, $proxy_url)
  
  =item $ua->proxy($scheme, $proxy_url)
  
  Set/retrieve proxy URL for a scheme:
  
   $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
   $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
  The first form specifies that the URL is to be used for proxying of
  access methods listed in the list in the first method argument,
  i.e. 'http' and 'ftp'.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  =item $ua->no_proxy( $domain, ... )
  
  Do not proxy requests to the given domains.  Calling no_proxy without
  any domains clears the list of domains. Eg:
  
   $ua->no_proxy('localhost', 'example.com');
  
  =item $ua->env_proxy
  
  Load proxy settings from *_proxy environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by env_proxy().  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =back
  
  =head2 Handlers
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =over
  
  =item $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify %matchspec see L<HTTP::Config/"Matching">.
  
  The possible values $phase and the corresponding callback signatures are:
  
  =over
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exception is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler gets a chance of handling requests before they're sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handler is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler needs to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler returns an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =item $ua->remove_handler( undef, %matchspec )
  
  =item $ua->remove_handler( $phase, %matchspec )
  
  Remove handlers that match the given %matchspec.  If $phase is not
  provided remove handlers from all phases.
  
  Be careful as calling this function with %matchspec that is not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the set_my_handler() method instead.
  
  The removed handlers are returned.
  
  =item $ua->set_my_handler( $phase, $cb, %matchspec )
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the %matchspec that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =item $ua->get_my_handler( $phase, %matchspec )
  
  =item $ua->get_my_handler( $phase, %matchspec, $init )
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed as a TRUE value, create and add the
  handler if it's not found.  If $init is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  $init is a hash reference, merge the hashes.
  
  =item $ua->handlers( $phase, $request )
  
  =item $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =back
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =over
  
  =item $ua->get( $url )
  
  =item $ua->get( $url , $field_name => $value, ... )
  
  This method will dispatch a C<GET> request on the given $url.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =item $ua->head( $url )
  
  =item $ua->head( $url , $field_name => $value, ... )
  
  This method will dispatch a C<HEAD> request on the given $url.
  Otherwise it works like the get() method described above.
  
  =item $ua->post( $url, \%form )
  
  =item $ua->post( $url, \@form )
  
  =item $ua->post( $url, \%form, $field_name => $value, ... )
  
  =item $ua->post( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->post( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->post( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<POST> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the POST() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->put( $url, \%form )
  
  =item $ua->put( $url, \@form )
  
  =item $ua->put( $url, \%form, $field_name => $value, ... )
  
  =item $ua->put( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->put( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->put( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<PUT> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the PUT() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->delete( $url )
  
  =item $ua->delete( $url, $field_name => $value, ... )
  
  This method will dispatch a C<DELETE> request on the given $url.  Additional
  headers and content options are the same as for the get() method.
  
  This method will use the DELETE() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->mirror( $url, $filename )
  
  This method will get the document identified by $url and store it in
  file called $filename.  If the file already exists, then the request
  will contain an "If-Modified-Since" header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is the response object.
  
  =item $ua->request( $request )
  
  =item $ua->request( $request, $content_file )
  
  =item $ua->request( $request, $content_cb )
  
  =item $ua->request( $request, $content_cb, $read_size_hint )
  
  This method will dispatch the given $request object.  Normally this
  will be an instance of the C<HTTP::Request> class, but any object with
  a similar interface will do.  The return value is a response object.
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  interface provided by these classes.
  
  The request() method will process redirects and authentication
  responses transparently.  This means that it may actually send several
  simple requests via the simple_request() method described below.
  
  The request methods described above; get(), head(), post() and
  mirror(), will all dispatch the request they build via this method.
  They are convenience methods that simply hides the creation of the
  request object for you.
  
  The $content_file, $content_cb and $read_size_hint all correspond to
  options described with the get() method above.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =item $ua->simple_request( $request )
  
  =item $ua->simple_request( $request, $content_file )
  
  =item $ua->simple_request( $request, $content_cb )
  
  =item $ua->simple_request( $request, $content_cb, $read_size_hint )
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for request() described above.
  
  The difference from request() is that simple_request() will not try to
  handle redirects or authentication responses.  The request() method
  will in fact invoke this method for each simple request it sends.
  
  =item $ua->is_online
  
  Tries to determine if you have access to the Internet.  Returns
  TRUE if the built-in heuristics determine that the user agent is
  able to access the Internet (over HTTP).  See also L<LWP::Online>.
  
  =item $ua->is_protocol_supported( $scheme )
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like 'http' or
  'ftp') or it might be an URI object reference.)
  
  Whether a scheme is supported, is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return TRUE only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =back
  
  =head2 Callback methods
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of C<LWP::UserAgent>
  might want to override their behaviour.
  
  =over
  
  =item $ua->prepare_request( $request )
  
  This method is invoked by simple_request().  Its task is to modify the
  given $request object by setting up various headers based on the
  attributes of the user agent. The return value should normally be the
  $request object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; "User-Agent",
  "From", "Range" and "Cookie".
  
  =item $ua->redirect_ok( $prospective_request, $response )
  
  This method is called by request() before it tries to follow a
  redirection to the request in $response.  This should return a TRUE
  value if this redirection is permissible.  The $prospective_request
  will be the request to be sent if this method returns TRUE.
  
  The base implementation will return FALSE unless the method
  is in the object's C<requests_redirectable> list,
  FALSE if the proposed redirection is to a "file://..."
  URL, and TRUE otherwise.
  
  =item $ua->get_basic_credentials( $realm, $uri, $isproxy )
  
  This is called by request() to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the $realm provided by the server, the $uri requested and a boolean
  flag to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the credentials() method.
  
  =item $ua->progress( $status, $request_or_response )
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with $status
  "begin" at the start of processing the request and with $state "end"
  before the request method returns.  In between these $status will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When $status is "begin" the second argument is the request object,
  otherwise it is the response object.
  
  =back
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on C<LWP::UserAgent>.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_USERAGENT

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use Moo::_strictures;
  use Moo::_Utils;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quoted_from_sub quotify);
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  
  my $module_name_only = qr/\A$Module::Runtime::module_name_rx\z/;
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with "
      . ( $type || 'an accessor' );
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ $module_name_only;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
    if (($spec->{coerce}||0) eq 1) {
      my $isa = $spec->{isa};
      if (blessed $isa and $isa->can('coercion')) {
        $spec->{coerce} = $isa->coercion;
      } elsif (blessed $isa and $isa->can('coerce')) {
        $spec->{coerce} = sub { $isa->coerce(@_) };
      } else {
        die "Invalid coercion for $into->$name - no appropriate type constraint";
      }
    }
  
    foreach my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name",
          'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      foreach my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $methods{$pred} =
          quote_sub "${into}::${pred}" =>
            '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
          ;
      }
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
      $methods{$cl} =
        quote_sub "${into}::${cl}" =>
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Moo::Role')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" =>
          $self->_generate_asserter($name, $spec),
          delete $self->{captures};
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_default {
    my ($self, $name, $spec) = @_;
    $spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\quotify $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\quotify $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa} ?
         "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
    );
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : quotify $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_simple_get(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .=
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return quotify($name) if !defined($init_arg) or $init_arg eq $name;
    return quotify($name).' (constructor argument: '.quotify($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce),
      1,
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _wrap_attr_exception {
    my ($self, $name, $step, $arg, $code, $want_return) = @_;
    my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
    .'    init_arg => '.quotify($arg).",\n"
    .'    name     => '.quotify($name).",\n"
    .'    step     => '.quotify($step).",\n"
    ."  };\n"
    .($want_return ? '  my $_return;'."\n" : '')
    .'  my $_error;'."\n"
    ."  {\n"
    .'    my $_old_error = $@;'."\n"
    ."    if (!eval {\n"
    .'      $@ = $_old_error;'."\n"
    .($want_return ? '      $_return ='."\n" : '')
    .'      '.$code.";\n"
    ."      1;\n"
    ."    }) {\n"
    .'      $_error = $@;'."\n"
    .'      if (!ref $_error) {'."\n"
    .'        $_error = '.$prefix.'.$_error;'."\n"
    ."      }\n"
    ."    }\n"
    .'    $@ = $_old_error;'."\n"
    ."  }\n"
    .'  die $_error if $_error;'."\n"
    .($want_return ? '  $_return;'."\n" : '')
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.$self->_sanitize_name($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify($code, $values,
          Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.$self->_sanitize_name($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name {
    my ($self, $name) = @_;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value =
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n"
              ."${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      # &Internals::SvREADONLY($foo, 0);
      # Scalar::Util::weaken($foo);
      # &Internals::SvREADONLY($foo, 1);
      #
      # but requires Internal functions and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using quotify
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{mro::get_linear_isa($into)};
    '    unless (('.$args.')[0]->{__no_BUILD__}) {'."\n"
    .join('', map qq{      ${me}->${_}(${args});\n}, @builds)
    ."   }\n";
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use Moo::_strictures;
  use Sub::Quote qw(quote_sub unquote_sub quotify);
  use Sub::Defer;
  use Moo::_Utils qw(_getstash _getglob);
  use Moo;
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    $self->assert_constructor;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      if ($new_spec->{required}
        && !(
          $self->accessor_generator->has_default($name, $new_spec)
          || !exists $new_spec->{init_arg}
          || defined $new_spec->{init_arg}
        )
      ) {
        die "You cannot have a required attribute (${name})"
          . " without a default, builder, or an init_arg";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    $self->assert_constructor;
    my $package = $self->{package};
    my (undef, @isa) = @{mro::get_linear_isa($package)};
    my $isa = join ',', @isa;
    $self->{deferred_constructor} = defer_sub "${package}::new" => sub {
      my (undef, @new_isa) = @{mro::get_linear_isa($package)};
      if (join(',', @new_isa) ne $isa) {
        my ($expected_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa;
        my ($found_new) = grep { *{_getglob($_.'::new')}{CODE} } @new_isa;
        if (($found_new||'') ne ($expected_new||'')) {
          $found_new ||= 'none';
          $expected_new ||= 'none';
          die "Expected parent constructor of $package expected to be"
          . " $expected_new, but found $found_new: changing the inheritance"
          . " chain (\@ISA) at runtime is unsupported";
        }
      }
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub current_constructor {
    my ($self, $package) = @_;
    return *{_getglob("${package}::new")}{CODE};
  }
  
  sub assert_constructor {
    my ($self) = @_;
    my $package = $self->{package} or return 1;
    my $current = $self->current_constructor($package)
      or return 1;
    my $deferred = $self->{deferred_constructor}
      or die "Unknown constructor for $package already exists";
    return 1
      if $deferred == $current;
    my $current_deferred = (Sub::Defer::defer_info($current)||[])->[3];
    if ($current_deferred && $current_deferred == $deferred) {
      die "Constructor for $package has been inlined and cannot be updated";
    }
    die "Constructor for $package has been replaced with an unknown sub";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      $body .= $self->buildall_generator->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.quotify($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = quotify($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or exists $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, '
      .join(', ', map quotify($_), @required_init).') {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  # bootstrap our own constructor
  sub new {
    my $class = shift;
    delete _getstash(__PACKAGE__)->{new};
    bless $class->BUILDARGS(@_), $class;
  }
  Moo->_constructor_maker_for(__PACKAGE__)
  ->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'bare' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'bare' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{mro::get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use Moo::_strictures;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
          $fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use Moo::_strictures;
  use Moo::_Utils;
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
  
    strict->import;
    warnings->import;
  
    if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      $old->assert_constructor;
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              require Sub::Defer;
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
  
      my %construct_opts = (
        package => $target,
        accessor_generator => $class->_accessor_maker_for($target),
        subconstructor_handler => (
          '      if ($Moo::MAKERS{$class}) {'."\n"
          .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
          .'          return $class->'.$target.'::SUPER::new(@_);'."\n"
          .'        }'."\n"
          .'        '.$class.'->_constructor_maker_for($class);'."\n"
          .'        return $class->new(@_)'.";\n"
          .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
          .'        return $meta->new_object('."\n"
          .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
          .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
          .'        );'."\n"
          .'      }'."\n"
        ),
      );
  
      my $con;
      my @isa = @{mro::get_linear_isa($target)};
      shift @isa;
      if (my ($parent_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa) {
        if ($parent_new eq 'Moo::Object') {
          # no special constructor needed
        }
        elsif (my $makers = $MAKERS{$parent_new}) {
          $con = $makers->{constructor};
          $construct_opts{construction_string} = $con->construction_string
            if $con;
        }
        elsif ($parent_new->can('BUILDALL')) {
          $construct_opts{construction_builder} = sub {
            my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
            'do {'
            .'  my $args = $class->'.$inv.'BUILDARGS(@_);'
            .'  $args->{__no_BUILD__} = 1;'
            .'  $class->'.$target.'::SUPER::new($args);'
            .'}'
          };
        }
        else {
          $construct_opts{construction_builder} = sub {
            '$class->'.$target.'::SUPER::new('
              .($target->can('FOREIGNBUILDARGS') ?
                '$class->FOREIGNBUILDARGS(@_)' : '@_')
              .')'
          };
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(%construct_opts)
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use strictures 2;
   use namespace::clean;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  C<Moo> is an extremely light-weight Object Orientation system. It allows one to
  concisely define objects and roles with a convenient syntax that avoids the
  details of Perl's object system.  C<Moo> contains a subset of L<Moose> and is
  optimised for rapid startup.
  
  C<Moo> avoids depending on any XS modules to allow for simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite --
  two thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead to provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  But if you don't want to use L<Moose>, you may not want "less metaprotocol"
  like L<Mouse> offers, but you probalby want "no metaprotocol", which is what
  Moo provides. C<Moo> is ideal for some situations where deployment or startup
  time precludes using L<Moose> and L<Mouse>:
  
  =over 2
  
  =item a command line or CGI script where fast startup is essential
  
  =item code designed to be deployed as a single file via L<App::FatPacker>
  
  =item a CPAN module that may be used by others in the above situations
  
  =back
  
  C<Moo> maintains transparent compatibility with L<Moose> so if you install and
  load L<Moose> you can use Moo clases and roles in L<Moose> code without
  modification.
  
  Moo -- Minimal Object Orientation -- aims to make it smooth to upgrade to
  L<Moose> when you need more than the minimal features offered by Moo.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without modification.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  L<Moo> classes and roles, so that in Moose classes C<< isa => 'MyMooClass' >>
  and C<< isa => 'MyMooRole' >> work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  Extending a L<Mouse> class or consuming a L<Mouse::Role> will also work. But
  note that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  global and turns the mechanism off entirely so don't put this in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  better performance.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   }
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares a base class. Multiple superclasses can be passed for multiple
  inheritance but please consider using L<roles|Moo::Role> instead.  The class
  will be loaded but no errors will be triggered if the class can't be found and
  there are already subs in the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles cannot be composed because they
  have conflicting method definitions.  The roles will be loaded using the same
  mechansim as C<extends> uses.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * C<is>
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> stands for "read-only" and generates an accessor that dies if you attempt
  to write to it - i.e.  a getter only - by defaulting C<reader> to the name of
  the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> stands for "read-write protected" and generates a reader like C<ro>, but
  also sets C<writer> to C<_set_${attribute_name}> for attributes that are
  designed to be written from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> stands for "read-write" and generates a normal getter/setter by
  defaulting the C<accessor> to the name of the attribute specified.
  
  =item * C<isa>
  
  Takes a coderef which is used to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   use Scalar::Util qw(looks_like_number);
   ...
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value for C<isa> is discarded. Only if the sub dies does
  type validation fail.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<Moose> compatible or L<MooseX::Types> style named types, look at
  L<Type::Tiny>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * C<coerce>
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always execute your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  If the C<isa> option is a blessed object providing a C<coerce> or
  C<coercion> method, then the C<coerce> option may be set to just C<1>.
  
  =item * C<handles>
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a L<role|Moo::Role> that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. The coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument to
  populate an attribute if no value for that attribute was supplied to the
  constructor. Alternatively, if the attribute is lazy, C<default> executes when
  the attribute is first retrieved if no value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  B<NOTE:> If the attribute is C<lazy>, it will be regenerated from C<default> or
  C<builder> the next time it is accessed. If it is not lazy, it will be C<undef>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on object instantiation.
  
  =item * C<reader>
  
  The name of the method that returns the value of the attribute.  If you like
  Java style methods, you might set this to C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened. Use this when circular references, which cause memory leaks, are
  possible.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... }; >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
   package Record;
  
   use Digest::MD5 qw(md5_hex);
  
   use Moo;
   use namespace::clean;
  
   has name => (is => 'ro', required => 1);
   has id => (is => 'lazy');
   sub _build_id {
     my ($self) = @_;
     return md5_hex($self->name);
   }
  
   1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> Older versions of L<namespace::autoclean> would
  inflate Moo classes to full L<Moose> classes, losing the benefits of Moo.  If
  you want to use L<namespace::autoclean> with a Moo class, make sure you are
  using version 0.16 or newer.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, L<Type::Tiny> can provide types, type libraries, and
  will work seamlessly with both L<Moo> and L<Moose>.  L<Type::Tiny> can be
  considered the successor to L<MooseX::Types> and provides a similar API, so
  that you can write
  
    use Types::Standard;
    has days_to_live => (is => 'ro', isa => Int);
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you need
  L<Moose> - Moo is small because it explicitly does not provide a metaprotocol.
  However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and
  L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  C<BUILDARGS> is not triggered if your class does not have any attributes.
  Without attributes, C<BUILDARGS> return value would be ignored, so we just
  skip calling the method instead.
  
  Handling of warnings: when you C<use Moo> we enable strict and warnings, in a
  similar way to Moose. The authors recommend the use of C<strictures>, which
  enables FATAL warnings, and several extra pragmas when used in development:
  L<indirect>, L<multidimensional>, and L<bareword::filehandles>.
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
      use strictures 2;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  bubaflub - Bob Kuo (cpan:BUBAFLUB) <bubaflub@cpan.org>
  
  ether = Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2015 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  use Moo::_strictures;
  no warnings 'once';
  use Moo::_Utils;
  use Sub::Quote qw(quotify);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    die "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
    @Moo::HandleMoose::FakeMeta::ISA = 'Moose::Meta::Method::Meta';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $am_class, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, 0, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, 1, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, 0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    foreach my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods
      = %{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Moo::Role cache is cleared so we don't confuse Moo itself.
    if (my $info = $Moo::Role::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              unless ( Scalar::Util::blessed($type)
                  && $type->isa("Moose::Meta::TypeConstraint") ) {
                die "error inflating attribute '$name' for package '$_[0]': "
                  ."\$TYPE_MAP{$isa} did not return a valid type constraint'";
              }
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = quotify($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    foreach my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    }
    elsif ($am_class) {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      my $meta_meth;
      if (
        $meta_meth = $meta->find_method_by_name('meta')
        and $meta_meth->body == \&Moo::Object::meta
      ) {
        bless($meta_meth, 'Moo::HandleMoose::FakeMeta');
      }
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Moo::Role::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  use Moo::_strictures;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    my $self = shift;
    die "Can't call $meth without object instance"
      if !ref $self;
    die "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)
  }
  sub can {
    my $self = shift;
    return $self->SUPER::can(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)
  }
  sub isa {
    my $self = shift;
    return $self->SUPER::isa(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use Moo::_strictures;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  use Config;
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/) {
      my $id = do { no warnings 'portable'; hex "$1" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  if ($Config{useithreads}) {
    my @types = %TYPE_MAP;
    tie %TYPE_MAP, __PACKAGE__;
    %TYPE_MAP = @types;
  }
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use Moo::_strictures;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    my $proto = $class->BUILDARGS(@_);
    $NO_BUILD{$class} and
      return bless({}, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({}, $class)
      : bless({}, $class)->BUILDALL($proto);
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    return !!0
      unless ($INC{'Moose/Role.pm'} || $INC{'Role/Tiny.pm'});
    require Moo::Role;
    my $does = Moo::Role->can("does_role");
    { no warnings 'redefine'; *does = $does }
    goto &$does;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use Moo::_strictures;
  use Moo::_Utils;
  use Role::Tiny ();
  our @ISA = qw(Role::Tiny);
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  BEGIN {
      *INFO = \%Role::Tiny::INFO;
      *APPLIED_TO = \%Role::Tiny::APPLIED_TO;
      *ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
  }
  
  our %INFO;
  our %APPLIED_TO;
  our %APPLY_DEFAULTS;
  our @ON_ROLE_CREATE;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
  
    _set_loaded(caller);
    strict->import;
    warnings->import;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
  
    $_->($target)
      for @ON_ROLE_CREATE;
  }
  
  push @ON_ROLE_CREATE, sub {
    my $target = shift;
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  };
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    _load_module($role);
    $self->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $self->is_role($role);
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub is_role {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    $self->SUPER::is_role($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    my $meta;
    if (!$self->SUPER::is_role($role)
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $me->is_role($role);
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    _load_module($role);
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $me->is_role($role);
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        _load_module($role);
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->apply_roles_to_package($new_name, @roles);
      _set_loaded($new_name, (caller)[1]);
      return $new_name;
    }
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Moo::Role" unless $me->is_role($role);
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    _set_loaded(ref $new, (caller)[1]);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = "{no warnings 'void';\n";
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code . ";\n";
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        $assign .= "}";
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _install_does {
      my ($me, $to) = @_;
  
      # If Role::Tiny actually installed the DOES, give it a name
      my $new = $me->SUPER::_install_does($to) or return;
      return _name_coderef("${to}::DOES", $new);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return 1
      if Role::Tiny::does_role($proto, $role);
    my $meta;
    if ($INC{'Moose.pm'}
        and $meta = Class::MOP::class_of($proto)
        and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
        and $meta->can('does_role')
    ) {
      return $meta->does_role($role);
    }
    return 0;
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    my $info = $INFO{$to};
    my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
    my %existing
      = $info ? @{$info->{attributes} || []}
      : $con  ? %{$con->all_attribute_specs || {}}
      : ();
  
    my @attr_info =
      map { @{$attr_info}[$_, $_+1] }
      grep { ! $existing{$attr_info->[$_]} }
      map { 2 * $_ } 0..@$attr_info/2-1;
  
    if ($info) {
      push @{$info->{attributes}||=[]}, @attr_info;
    }
    elsif ($con) {
      # shallow copy of the specs since the constructor will assign an index
      $con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
   use strictures 2;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
   use strictures 2;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
   package My::Role::ID;
  
   use Digest::MD5 qw(md5_hex);
   use Moo::Role;
   use Digest::SHA qw(sha1_hex);
  
   requires 'name';
  
   sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
   sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
   1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subutil => (
      $INC{"Sub/Util.pm"}
      || ( !$INC{"Sub/Name.pm"} && eval { require Sub::Util } )
    ) && defined &Sub::Util::set_subname;
  use constant can_haz_subname => (
      $INC{"Sub/Name.pm"}
      || ( !$INC{"Sub/Util.pm"} && eval { require Sub::Name } )
    ) && defined &Sub::Name::subname;
  
  use Moo::_strictures;
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use Exporter qw(import);
  use Moo::_mro;
  use Config;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction _set_loaded
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    my $module = $_[0];
    my $file = module_notional_filename($module);
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    die $error;
  }
  
  sub _maybe_load_module {
    my $module = $_[0];
    return $MAYBE_LOADED{$module}
      if exists $MAYBE_LOADED{$module};
    if(! eval { use_package_optimistically($module) }) {
      warn "$module exists but failed to load with error: $@";
    }
    elsif ( $INC{module_notional_filename($module)} ) {
      return $MAYBE_LOADED{$module} = 1;
    }
    return $MAYBE_LOADED{$module} = 0;
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subutil ? Sub::Util::set_subname(@_) :
      can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  use Moo::_strictures;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;
  use strict;
  use warnings;
  
  sub import {
    if ($ENV{MOO_FATAL_WARNINGS}) {
      require strictures;
      strictures->VERSION(2);
      @_ = ('strictures');
      goto &strictures::import;
    }
    else {
      strict->import;
      warnings->import;
    }
  }
  
  1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use Moo::_strictures;
  no warnings 'once';
  use Devel::GlobalDestruction qw(in_global_destruction);
  
  sub unimport {
    die "Can't disable Moo::sification after inflation has been done"
      if $Moo::HandleMoose::SETUP_DONE;
    our $disabled = 1;
  }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disabled or in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  sub import {
    return
      if our $setup_done;
    if ($INC{"Moose.pm"}) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    } else {
      $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
    }
    $setup_done = 1;
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Pithub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB';
  package Pithub;
  $Pithub::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 API
  
  use Moo;
  use Pithub::Events;
  use Pithub::Gists;
  use Pithub::GitData;
  use Pithub::Issues;
  use Pithub::Orgs;
  use Pithub::PullRequests;
  use Pithub::Repos;
  use Pithub::Search;
  use Pithub::SearchV3;
  use Pithub::Users;
  use Carp 'croak';
  extends 'Pithub::Base';
  
  
  sub _validate_search_api {
      my %search_apis = map { $_ => 1 } qw(legacy v3);
      croak "unknown search api '$_[0]'"
          unless exists $search_apis{$_[0]};
  }
  
  
  has search_api => (
      is  => 'ro',
      isa => \&_validate_search_api,
      default => 'legacy',
  );
  
  sub _search_class {
      my ($self, $search_api) = @_;
  
      _validate_search_api($search_api);
  
      return $search_api eq 'legacy'
          ? 'Pithub::Search'
          : 'Pithub::SearchV3';
  }
  
  
  sub events {
      return shift->_create_instance('Pithub::Events', @_);
  }
  
  
  sub gists {
      return shift->_create_instance('Pithub::Gists', @_);
  }
  
  
  sub git_data {
      return shift->_create_instance('Pithub::GitData', @_);
  }
  
  
  sub issues {
      return shift->_create_instance('Pithub::Issues', @_);
  }
  
  
  sub orgs {
      return shift->_create_instance('Pithub::Orgs', @_);
  }
  
  
  sub pull_requests {
      return shift->_create_instance('Pithub::PullRequests', @_);
  }
  
  
  sub repos {
      return shift->_create_instance('Pithub::Repos', @_);
  }
  
  
  sub search {
      my ($self, %args) = @_;
      my $class = $self->_search_class(
          exists $args{search_api}
              ? delete $args{search_api}
              : $self->search_api,
      );
      return shift->_create_instance($class, @_);
  }
  
  
  sub users {
      return shift->_create_instance('Pithub::Users', @_);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub - Github v3 API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 SYNOPSIS
  
      use Pithub;
      use Data::Dumper;
  
      my $p = Pithub->new;
      my $result = $p->repos->get( user => 'plu', repo => 'Pithub' );
  
      # $result->content is either an arrayref or an hashref
      # depending on the API call that has been made
      printf "%s\n", $result->content->{html_url};     # prints https://github.com/plu/Pithub
      printf "%s\n", $result->content->{clone_url};    # prints https://github.com/plu/Pithub.git
  
      # if the result is an arrayref, you can use the result iterator
      my $result = $p->repos->list( user => 'plu' );
      while ( my $row = $result->next ) {
          printf "%s\n", $row->{name};
      }
  
      # Connect to your local GitHub Enterprise instance
      my $p = Pithub->new(
          api_uri => 'https://github.yourdomain.com/api/v3/'
      );
  
  =head1 DESCRIPTION
  
  L<Pithub> provides a set of modules to access the
  L<Github v3 API|http://developer.github.com/v3/> in an object
  oriented way. There is also L<Net::GitHub> which does the same for
  all the versions (v1, v2, v3) of the Github API.
  L<Pithub> supports all API calls so far, but only for v3.
  
  =head1 ATTRIBUTES
  
  =head2 search_api
  
      my $p = Pithub->new({ search_api => 'v3' });
      my $search = $p->search; # $search->isa('Pithub::SearchV3');
  
  This attribute allows the default for the API to use for searches to be
  specified. The two accepted values are C<v3> and C<legacy>. For compatibility
  reasons the default is C<legacy>.
  
  =head1 METHODS
  
  =head2 events
  
  Provides access to L<Pithub::Events>.
  
  =head2 gists
  
  Provides access to L<Pithub::Gists>.
  
  =head2 git_data
  
  Provides access to L<Pithub::GitData>.
  
  =head2 issues
  
  Provides access to L<Pithub::Issues>.
  
  =head2 orgs
  
  Provides access to L<Pithub::Orgs>.
  
  =head2 pull_requests
  
  Provides access to L<Pithub::PullRequests>.
  
  =head2 repos
  
  Provides access to L<Pithub::Repos>.
  
  =head2 search
  
    my $legacy_search  = $p->search(search_api => 'legacy');
    my $v3_search      = $p->search(search_api => 'v3');
    my $default_search = $p->search;
  
  Provides access to L<Pithub::Search> and L<Pithub::SearchV3>. When no
  C<search_api> option is given, the value provided by the C<search_api>
  attribute is used.
  
  =head2 users
  
  Provides access to L<Pithub::Users>.
  
  =head1 DOCUMENTATION
  
  Quite a lot of the L<Pithub> documentation has been taken directly
  from the great API documentation at
  L<Github|http://developer.github.com/v3/>. Please also read the
  documentation there, since it might be more complete and more
  up-to-date.
  
  =head1 WARNING
  
  L<Pithub> as well as the
  L<Github v3 API|http://developer.github.com/v3/> are still under
  development. So there might be things broken on both sides. Besides
  that it's possible that the API will change. This applies to
  L<Pithub> itself as well as the
  L<Github v3 API|http://developer.github.com/v3/>.
  
  =head1 CONTRIBUTE
  
  This module is hosted on L<Github|https://github.com/plu/Pithub>, so
  feel free to fork it and send pull requests.
  There are two different kinds of test suites, one is just checking
  the HTTP requests that are created by the method calls, without
  actually sending them. The second one is sending real requests to
  the Github API. If you want to contribute to this project, I highly
  recommend to run the live tests on a test account, because it will
  generate a lof of activity.
  
  =head1 MODULES
  
  There are different ways of using the Pithub library. You can either
  use the main module L<Pithub> to get access to all other
  modules, like L<Pithub::Repos> for example. Or you can use
  L<Pithub::Repos> directly and create an instance of it. All
  modules accept the same L<attributes|Pithub::Base/ATTRIBUTES>,
  either in the constructor or later by calling the setters.
  
  Besides that there are other modules involved. Every method call
  which maps directly to a Github API call returns a
  L<Pithub::Result> object. This contains everything interesting
  about the response returned from the API call.
  
  L<Pithub::Base> might be interesting for two reasons:
  
  =over
  
  =item *
  
  The list of L<attributes|Pithub::Base/ATTRIBUTES> which all modules
  accept.
  
  =item *
  
  The L<request|Pithub::Base/request> method: In case Github adds a
  new API call which is not supported yet by L<Pithub> the
  L<request|Pithub::Base/request> method can be used directly to
  perform this new API call, there's some documentation on how to
  use it.
  
  =over
  
  =item *
  
  L<Pithub::Events>
  
  See also: L<http://developer.github.com/v3/events/>
  
      my $gists = Pithub->new->events;
      my $gists = Pithub::Events->new;
  
  =item *
  
  L<Pithub::Gists>
  
  See also: L<http://developer.github.com/v3/gists/>
  
      my $gists = Pithub->new->gists;
      my $gists = Pithub::Gists->new;
  
  =over
  
  =item *
  
  L<Pithub::Gists::Comments>
  
  See also: L<http://developer.github.com/v3/gists/comments/>
  
      my $comments = Pithub->new->gists->comments;
      my $comments = Pithub::Gists->new->comments;
      my $comments = Pithub::Gists::Comments->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::GitData>
  
  See also: L<http://developer.github.com/v3/git/>
  
      my $git_data = Pithub->new->git_data;
      my $git_data = Pithub::GitData->new;
  
  =over
  
  =item *
  
  L<Pithub::GitData::Blobs>
  
  See also: L<http://developer.github.com/v3/git/blobs/>
  
      my $blobs = Pithub->new->git_data->blobs;
      my $blobs = Pithub::GitData->new->blobs;
      my $blobs = Pithub::GitData::Blobs->new;
  
  =item *
  
  L<Pithub::GitData::Commits>
  
  See also: L<http://developer.github.com/v3/git/commits/>
  
      my $commits = Pithub->new->git_data->commits;
      my $commits = Pithub::GitData->new->commits;
      my $commits = Pithub::GitData::Commits->new;
  
  =item *
  
  L<Pithub::GitData::References>
  
  See also: L<http://developer.github.com/v3/git/refs/>
  
      my $references = Pithub->new->git_data->references;
      my $references = Pithub::GitData->new->references;
      my $references = Pithub::GitData::References->new;
  
  =item *
  
  L<Pithub::GitData::Tags>
  
  See also: L<http://developer.github.com/v3/git/tags/>
  
      my $tags = Pithub->new->git_data->tags;
      my $tags = Pithub::GitData->new->tags;
      my $tags = Pithub::GitData::Tags->new;
  
  =item *
  
  L<Pithub::GitData::Trees>
  
  See also: L<http://developer.github.com/v3/git/trees/>
  
      my $trees = Pithub->new->git_data->trees;
      my $trees = Pithub::GitData->new->trees;
      my $trees = Pithub::GitData::Trees->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Issues>
  
  See also: L<http://developer.github.com/v3/issues/>
  
      my $issues = Pithub->new->issues;
      my $issues = Pithub::Issues->new;
  
  =over
  
  =item *
  
  L<Pithub::Issues::Assignees>
  
  See also: L<http://developer.github.com/v3/issues/assignees/>
  
      my $assignees = Pithub->new->issues->assignees;
      my $assignees = Pithub::Issues->new->assignees;
      my $assignees = Pithub::Issues::Assignees->new;
  
  =item *
  
  L<Pithub::Issues::Comments>
  
  See also: L<http://developer.github.com/v3/issues/comments/>
  
      my $comments = Pithub->new->issues->comments;
      my $comments = Pithub::Issues->new->comments;
      my $comments = Pithub::Issues::Comments->new;
  
  =item *
  
  L<Pithub::Issues::Events>
  
  See also: L<http://developer.github.com/v3/issues/events/>
  
      my $events = Pithub->new->issues->events;
      my $events = Pithub::Issues->new->events;
      my $events = Pithub::Issues::Events->new;
  
  =item *
  
  L<Pithub::Issues::Labels>
  
  See also: L<http://developer.github.com/v3/issues/labels/>
  
      my $labels = Pithub->new->issues->labels;
      my $labels = Pithub::Issues->new->labels;
      my $labels = Pithub::Issues::Labels->new;
  
  =item *
  
  L<Pithub::Issues::Milestones>
  
  See also: L<http://developer.github.com/v3/issues/milestones/>
  
      my $milestones = Pithub->new->issues->milestones;
      my $milestones = Pithub::Issues->new->milestones;
      my $milestones = Pithub::Issues::Milestones->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Orgs>
  
  See also: L<http://developer.github.com/v3/orgs/>
  
      my $orgs = Pithub->new->orgs;
      my $orgs = Pithub::Orgs->new;
  
  =over
  
  =item *
  
  L<Pithub::Orgs::Members>
  
  See also: L<http://developer.github.com/v3/orgs/members/>
  
      my $members = Pithub->new->orgs->members;
      my $members = Pithub::Orgs->new->members;
      my $members = Pithub::Orgs::Members->new;
  
  =item *
  
  L<Pithub::Orgs::Teams>
  
  See also: L<http://developer.github.com/v3/orgs/teams/>
  
      my $teams = Pithub->new->orgs->teams;
      my $teams = Pithub::Orgs->new->teams;
      my $teams = Pithub::Orgs::Teams->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::PullRequests>
  
  See also: L<http://developer.github.com/v3/pulls/>
  
      my $pull_requests = Pithub->new->pull_requests;
      my $pull_requests = Pithub::PullRequests->new;
  
  =over
  
  =item *
  
  L<Pithub::PullRequests::Comments>
  
  See also: L<http://developer.github.com/v3/pulls/comments/>
  
      my $comments = Pithub->new->pull_requests->comments;
      my $comments = Pithub::PullRequests->new->comments;
      my $comments = Pithub::PullRequests::Comments->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Repos>
  
  See also: L<http://developer.github.com/v3/repos/>
  
      my $repos = Pithub->new->repos;
      my $repos = Pithub::Repos->new;
  
  =over
  
  =item *
  
  L<Pithub::Repos::Collaborators>
  
  See also: L<http://developer.github.com/v3/repos/collaborators/>
  
      my $collaborators = Pithub->new->repos->collaborators;
      my $collaborators = Pithub::Repos->new->collaborators;
      my $collaborators = Pithub::Repos::Collaborators->new;
  
  =item *
  
  L<Pithub::Repos::Commits>
  
  See also: L<http://developer.github.com/v3/repos/commits/>
  
      my $commits = Pithub->new->repos->commits;
      my $commits = Pithub::Repos->new->commits;
      my $commits = Pithub::Repos::Commits->new;
  
  =item *
  
  L<Pithub::Repos::Contents>
  
  See also: L<http://developer.github.com/v3/repos/contents/>
  
      my $contents = Pithub->new->repos->contents;
      my $contents = Pithub::Repos->new->contents;
      my $contents = Pithub::Repos::Contents->new;
  
  =item *
  
  L<Pithub::Repos::Downloads>
  
  Github says: The Downloads API (described below) was deprecated on
  December 11, 2012. It will be removed at a future date. We recommend
  using L<Pithub::Repos::Releases> instead.
  
  See also: L<http://developer.github.com/v3/repos/downloads/>
  
      my $downloads = Pithub->new->repos->downloads;
      my $downloads = Pithub::Repos->new->downloads;
      my $downloads = Pithub::Repos::Downloads->new;
  
  =item *
  
  L<Pithub::Repos::Forks>
  
  See also: L<http://developer.github.com/v3/repos/forks/>
  
      my $forks = Pithub->new->repos->forks;
      my $forks = Pithub::Repos->new->forks;
      my $forks = Pithub::Repos::Forks->new;
  
  =item *
  
  L<Pithub::Repos::Keys>
  
  See also: L<http://developer.github.com/v3/repos/keys/>
  
      my $keys = Pithub->new->repos->keys;
      my $keys = Pithub::Repos->new->keys;
      my $keys = Pithub::Repos::Keys->new;
  
  =item *
  
  L<Pithub::Repos::Releases>
  
  See also: L<http://developer.github.com/v3/repos/releases/>
  
      my $releases = Pithub->new->repos->releases;
      my $releases = Pithub::Repos->new->releases;
      my $releases = Pithub::Repos::Releases->new;
  
  =over
  
  =item *
  
  L<Pithub::Repos::Releases::Assets>
  
  See also: L<http://developer.github.com/v3/repos/releases/>
  
      my $assets = Pithub->new->repos->releases->assets;
      my $assets = Pithub::Repos->new->releases->assets;
      my $assets = Pithub::Repos::Releases->new->assets;
      my $assets = Pithub::Repos::Releases::Assets->new;
  
  =back
  
  =item *
  
  L<Pithub::Repos::Stats>
  
  See also: L<http://developer.github.com/v3/repos/statistics/>
  
      my $watching = Pithub->new->repos->stats;
      my $watching = Pithub::Repos->new->stats;
      my $watching = Pithub::Repos::Stats->new;
  
  =item *
  
  L<Pithub::Repos::Statuses>
  
  See also: L<http://developer.github.com/v3/repos/statuses/>
  
      my $watching = Pithub->new->repos->statuses;
      my $watching = Pithub::Repos->new->statuses;
      my $watching = Pithub::Repos::Statuses->new;
  
  =item *
  
  L<Pithub::Repos::Watching>
  
  See also: L<http://developer.github.com/v3/repos/watching/>
  
      my $watching = Pithub->new->repos->watching;
      my $watching = Pithub::Repos->new->watching;
      my $watching = Pithub::Repos::Watching->new;
  
  =back
  
  =back
  
  =over
  
  =item *
  
  L<Pithub::Users>
  
  See also: L<http://developer.github.com/v3/users/>
  
      my $users = Pithub->new->users;
      my $users = Pithub::Users->new;
  
  =over
  
  =item *
  
  L<Pithub::Users::Emails>
  
  See also: L<http://developer.github.com/v3/users/emails/>
  
      my $emails = Pithub->new->users->emails;
      my $emails = Pithub::Users->new->emails;
      my $emails = Pithub::Users::Emails->new;
  
  =item *
  
  L<Pithub::Users::Followers>
  
  See also: L<http://developer.github.com/v3/users/followers/>
  
      my $followers = Pithub->new->users->followers;
      my $followers = Pithub::Users->new->followers;
      my $followers = Pithub::Users::Followers->new;
  
  =item *
  
  L<Pithub::Users::Keys>
  
  See also: L<http://developer.github.com/v3/users/keys/>
  
      my $keys = Pithub->new->users->keys;
      my $keys = Pithub::Users->new->keys;
      my $keys = Pithub::Users::Keys->new;
  
  =back
  
  =back
  
  =back
  
  =head1 CONTRIBUTORS
  
  =over
  
  =item *
  
  Andreas Marienborg
  
  =item *
  
  Alessandro Ghedini
  
  =item *
  
  Michael G Schwern
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB

$fatpacked{"Pithub/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_BASE';
  package Pithub::Base;
  $Pithub::Base::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 base class for all Pithub modules
  
  use Moo;
  use Carp qw(croak);
  use HTTP::Headers;
  use HTTP::Request;
  use JSON::MaybeXS;
  use LWP::UserAgent;
  use Pithub::Result;
  use URI;
  
  with 'Pithub::Result::SharedCache';
  
  
  has 'auto_pagination' => (
      default => sub { 0 },
      is      => 'rw',
  );
  
  
  has 'api_uri' => (
      default => sub { URI->new('https://api.github.com') },
      is      => 'rw',
      trigger => sub {
          my ( $self, $uri ) = @_;
          $self->{api_uri} = URI->new("$uri");
      },
  );
  
  
  has 'jsonp_callback' => (
      clearer   => 'clear_jsonp_callback',
      is        => 'rw',
      predicate => 'has_jsonp_callback',
      required  => 0,
  );
  
  
  has 'per_page' => (
      clearer   => 'clear_per_page',
      is        => 'rw',
      predicate => 'has_per_page',
      default   => 100,
      required  => 0,
  );
  
  
  has 'prepare_request' => (
      clearer   => 'clear_prepare_request',
      is        => 'rw',
      predicate => 'has_prepare_request',
      required  => 0,
  );
  
  
  has 'repo' => (
      clearer   => 'clear_repo',
      is        => 'rw',
      predicate => 'has_repo',
      required  => 0,
  );
  
  
  has 'token' => (
      clearer   => 'clear_token',
      is        => 'rw',
      predicate => '_has_token',
      required  => 0,
  );
  
  
  has 'ua' => (
      builder => '_build_ua',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'user' => (
      clearer   => 'clear_user',
      is        => 'rw',
      predicate => 'has_user',
      required  => 0,
  );
  
  has '_json' => (
      builder => '_build__json',
      is      => 'ro',
      lazy    => 1,
  );
  
  my @TOKEN_REQUIRED = (
      'DELETE /user/emails',
      'GET /user',
      'GET /user/emails',
      'GET /user/followers',
      'GET /user/following',
      'GET /user/keys',
      'GET /user/repos',
      'PATCH /user',
      'POST /user/emails',
      'POST /user/keys',
      'POST /user/repos',
  );
  
  my @TOKEN_REQUIRED_REGEXP = (
      qr{^DELETE },
      qr{^GET /gists/starred$},
      qr{^GET /gists/[^/]+/star$},
      qr{^GET /issues$},
      qr{^GET /orgs/[^/]+/members/.*$},
      qr{^GET /orgs/[^/]+/teams$},
      qr{^GET /repos/[^/]+/[^/]+/collaborators$},
      qr{^GET /repos/[^/]+/[^/]+/collaborators/.*$},
      qr{^GET /repos/[^/]+/[^/]+/hooks$},
      qr{^GET /repos/[^/]+/[^/]+/hooks/.*$},
      qr{^GET /repos/[^/]+/[^/]+/keys$},
      qr{^GET /repos/[^/]+/[^/]+/keys/.*$},
      qr{^GET /teams/.*$},
      qr{^GET /teams/[^/]+/members$},
      qr{^GET /teams/[^/]+/members/.*$},
      qr{^GET /teams/[^/]+/repos$},
      qr{^GET /teams/[^/]+/repos/.*$},
      qr{^GET /user/following/.*$},
      qr{^GET /user/keys/.*$},
      qr{^GET /user/orgs$},
      qr{^GET /user/starred/[^/]+/.*$},
      qr{^GET /user/watched$},
      qr{^GET /user/watched/[^/]+/.*$},
      qr{^GET /users/[^/]+/events/orgs/.*$},
      qr{^PATCH /gists/.*$},
      qr{^PATCH /gists/[^/]+/comments/.*$},
      qr{^PATCH /orgs/.*$},
      qr{^PATCH /repos/[^/]+/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/comments/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/git/refs/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/hooks/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/issues/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/issues/comments/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/keys/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/labels/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/milestones/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/pulls/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/releases/.*$},
      qr{^PATCH /repos/[^/]+/[^/]+/pulls/comments/.*$},
      qr{^PATCH /teams/.*$},
      qr{^PATCH /user/keys/.*$},
      qr{^PATCH /user/repos/.*$},
      qr{^POST /repos/[^/]+/[^/]+/releases/[^/]+/assets.*$},
      qr{^POST /gists/[^/]+/comments$},
      qr{^POST /orgs/[^/]+/repos$},
      qr{^POST /orgs/[^/]+/teams$},
      qr{^POST /repos/[^/]+/[^/]+/commits/[^/]+/comments$},
      qr{^POST /repos/[^/]+/[^/]+/downloads$},
      qr{^POST /repos/[^/]+/[^/]+/forks},
      qr{^POST /repos/[^/]+/[^/]+/git/blobs$},
      qr{^POST /repos/[^/]+/[^/]+/git/commits$},
      qr{^POST /repos/[^/]+/[^/]+/git/refs},
      qr{^POST /repos/[^/]+/[^/]+/git/tags$},
      qr{^POST /repos/[^/]+/[^/]+/git/trees$},
      qr{^POST /repos/[^/]+/[^/]+/hooks$},
      qr{^POST /repos/[^/]+/[^/]+/hooks/[^/]+/test$},
      qr{^POST /repos/[^/]+/[^/]+/issues$},
      qr{^POST /repos/[^/]+/[^/]+/issues/[^/]+/comments},
      qr{^POST /repos/[^/]+/[^/]+/issues/[^/]+/labels$},
      qr{^POST /repos/[^/]+/[^/]+/keys$},
      qr{^POST /repos/[^/]+/[^/]+/labels$},
      qr{^POST /repos/[^/]+/[^/]+/milestones$},
      qr{^POST /repos/[^/]+/[^/]+/pulls$},
      qr{^POST /repos/[^/]+/[^/]+/releases$},
      qr{^POST /repos/[^/]+/[^/]+/pulls/[^/]+/comments$},
      qr{^PUT /gists/[^/]+/star$},
      qr{^PUT /orgs/[^/]+/public_members/.*$},
      qr{^PUT /repos/[^/]+/[^/]+/collaborators/.*$},
      qr{^PUT /repos/[^/]+/[^/]+/issues/[^/]+/labels$},
      qr{^PUT /repos/[^/]+/[^/]+/pulls/[^/]+/merge$},
      qr{^PUT /teams/[^/]+/members/.*$},
      qr{^PUT /teams/[^/]+/memberships/.*$},
      qr{^PUT /teams/[^/]+/repos/.*$},
      qr{^PUT /user/following/.*$},
      qr{^PUT /user/starred/[^/]+/.*$},
      qr{^PUT /user/watched/[^/]+/.*$},
  );
  
  
  sub request {
      my ( $self, %args ) = @_;
  
      my $method  = delete $args{method} || croak 'Missing mandatory key in parameters: method';
      my $path    = delete $args{path}   || croak 'Missing mandatory key in parameters: path';
      my $data    = delete $args{data};
      my $options = delete $args{options};
      my $params  = delete $args{params};
  
      croak "Invalid method: $method" unless grep $_ eq $method, qw(DELETE GET PATCH POST PUT);
  
      my $uri = $self->_uri_for($path);
  
      if (my $host = delete $args{host}) {
          $uri->host($host);
      }
  
      if (my $query = delete $args{query}) {
          $uri->query_form(%$query);
      }
  
      my $request = $self->_request_for( $method, $uri, $data );
  
      if (my $headers = delete $args{headers}) {
          foreach my $header (keys %$headers) {
              $request->header($header, $headers->{$header});
          }
      }
  
      if ( $self->_token_required( $method, $path ) && !$self->has_token($request) ) {
          croak sprintf "Access token required for: %s %s (%s)", $method, $path, $uri;
      }
  
      if ($options) {
          croak 'The key options must be a hashref' unless ref $options eq 'HASH';
          croak 'The key prepare_request in the options hashref must be a coderef' if $options->{prepare_request} && ref $options->{prepare_request} ne 'CODE';
  
          if ( $options->{prepare_request} ) {
              $options->{prepare_request}->($request);
          }
      }
  
      if ($params) {
          croak 'The key params must be a hashref' unless ref $params eq 'HASH';
          my %query = ( $request->uri->query_form, %$params );
          $request->uri->query_form(%query);
      }
  
      my $response = $self->_make_request($request);
  
      return Pithub::Result->new(
          auto_pagination => $self->auto_pagination,
          response        => $response,
          _request        => sub { $self->request(@_) },
      );
  }
  
  
  sub _make_request {
      my($self, $request) = @_;
  
      if( my $cached_response = $self->shared_cache->get($request->uri) ) {
          # Add the If-None-Match header from the cache's ETag
          # and make the request
          $request->header( "If-None-Match" => $cached_response->header("ETag") );
          my $response = $self->ua->request($request);
  
          # Got 304 Not Modified, cache is still valid
          return $cached_response if ($response->code || 0) == 304;
  
          # The response changed, cache it and return it.
          $self->shared_cache->set( $request->uri, $response );
          return $response;
      }
      else {
          my $response = $self->ua->request($request);
          $self->shared_cache->set( $request->uri, $response );
          return $response;
      }
  }
  
  
  
  sub has_token {
      my ($self, $request) = @_;
  
      # If we have one specified in the object, return true
      return 1 if $self->_has_token;
      # If no request object here, we don't have a token
      return 0  unless $request;
  
      return 1 if $request->header('Authorization');
      return 0;
  }
  
  sub _build__json {
      my ($self) = @_;
      return JSON->new->utf8;
  }
  
  sub _build_ua {
      my ($self) = @_;
      return LWP::UserAgent->new;
  }
  
  sub _get_user_repo_args {
      my ( $self, $args ) = @_;
      $args->{user} = $self->user unless defined $args->{user};
      $args->{repo} = $self->repo unless defined $args->{repo};
      return $args;
  }
  
  sub _create_instance {
      my ( $self, $class, @args ) = @_;
  
      my %args = (
          api_uri         => $self->api_uri,
          auto_pagination => $self->auto_pagination,
          ua              => $self->ua,
          @args
      );
  
      for my $attr (qw(repo token user per_page jsonp_callback prepare_request)) {
          # Allow overrides to set attributes to undef
          next if exists $args{$attr};
  
          my $has_attr = "has_$attr";
          $args{$attr} = $self->$attr if $self->$has_attr;
      }
  
      return $class->new(%args);
  }
  
  sub _request_for {
      my ( $self, $method, $uri, $data ) = @_;
  
      my $headers = HTTP::Headers->new;
  
      if ( $self->has_token ) {
          $headers->header( 'Authorization' => sprintf( 'token %s', $self->token ) );
      }
  
      my $request = HTTP::Request->new( $method, $uri, $headers );
  
      if ($data) {
          $data = $self->_json->encode($data) if ref $data;
          $request->content($data);
      }
  
      $request->header( 'Content-Length' => length $request->content );
  
      if ( $self->has_prepare_request ) {
          $self->prepare_request->($request);
      }
  
      return $request;
  }
  
  my %TOKEN_REQUIRED = map { ($_ => 1) } @TOKEN_REQUIRED;
  sub _token_required {
      my ( $self, $method, $path ) = @_;
  
      my $key = "${method} ${path}";
  
      return 1 if $TOKEN_REQUIRED{$key};
  
      foreach my $regexp (@TOKEN_REQUIRED_REGEXP) {
          return 1 if $key =~ /$regexp/;
      }
  
      return 0;
  }
  
  sub _uri_for {
      my ( $self, $path ) = @_;
  
      my $uri = $self->api_uri->clone;
      my $base_path = $uri->path;
      $path =~ s/^$base_path//;
      my @parts;
      push @parts, split qr{/+}, $uri->path;
      push @parts, split qr{/+}, $path;
      $uri->path( join '/',  grep { $_ } @parts );
  
      if ( $self->has_per_page ) {
          my %query = ( $uri->query_form, per_page => $self->per_page );
          $uri->query_form(%query);
      }
  
      if ( $self->has_jsonp_callback ) {
          my %query = ( $uri->query_form, callback => $self->jsonp_callback );
          $uri->query_form(%query);
      }
  
      return $uri;
  }
  
  sub _validate_user_repo_args {
      my ( $self, $args ) = @_;
      $args = $self->_get_user_repo_args($args);
      croak 'Missing key in parameters: user' unless $args->{user};
      croak 'Missing key in parameters: repo' unless $args->{repo};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Base - Github v3 base class for all Pithub modules
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 DESCRIPTION
  
  All L<Pithub> L<modules|Pithub/MODULES> inherit from
  L<Pithub::Base>, even L<Pithub> itself. So all
  L<attributes|/ATTRIBUTES> listed here can either be set in the
  constructor or via the setter on the objects.
  
  If any attribute is set on a L<Pithub> object it gets
  automatically set on objects that get created by a method call on
  the L<Pithub> object. This is very convenient for attributes like
  the L</token> or the L</user> and L</repo> attributes.
  
  The L</user> and L</repo> attributes are special: They get even
  set on method calls that require B<both> of them. This is to reduce
  verbosity, especially if you want to do a lot of things on the
  same repo. This also works for other objects: If you create an
  object of L<Pithub::Repos> where you set the L</user> and L</repo>
  attribute in the constructor, this will also be set once you
  get to the L<Pithub::Repos::Keys> object via the C<< keys >> method.
  
  Attributes passed along from the parent can be changed in the method
  call.
  
      my $p = Pithub->new( per_page => 50 );
      my $r1 = $p->repos;                         # $r->per_page == 50
      my $r2 = $p->repos( per_page => 100 );      # $r->per_page == 100
  
  Examples:
  
      # just to demonstrate the "magic"
      print Pithub->new( user => 'plu' )->repos->user;          # plu
      print Pithub::Repos->new( user => 'plu' )->keys->user;    # plu
  
      # and now some real use cases
      my $p = Pithub->new( user => 'plu', repo => 'Pithub' );
      my $r = $p->repos;
  
      print $r->user;    # plu
      print $r->repo;    # pithub
  
      # usually you would do
      print $r->get( user => 'plu', repo => 'Pithub' )->content->{html_url};
  
      # but since user + repo has been set already
      print $r->get->content->{html_url};
  
      # of course parameters to the method take precedence
      print $r->get( user => 'miyagawa', repo => 'Plack' )->content->{html_url};
  
      # it even works on other objects
      my $repo = Pithub::Repos->new( user => 'plu', repo => 'Pithub' );
      print $repo->watching->list->first->{login};
  
  =head1 ATTRIBUTES
  
  =head2 auto_pagination
  
  Off by default.
  
  See also: L<Pithub::Result/auto_pagination>.
  
  =head2 api_uri
  
  Defaults to L<https://api.github.com>.  For GitHub Enterprise, you'll likely
  need an URL like L<https://github.yourdomain.com/api/v3/>.
  
  Examples:
  
      my $users = Pithub::Users->new( api_uri => 'https://api-foo.github.com' );
  
      # ... is the same as ...
  
      my $users = Pithub::Users->new;
      $users->api_uri('https://api-foo.github.com');
  
  =head2 jsonp_callback
  
  If you want to use the response directly in JavaScript for example,
  Github supports setting a JSONP callback parameter.
  
  See also: L<http://developer.github.com/v3/#json-p-callbacks>.
  
  Examples:
  
      my $p = Pithub->new( jsonp_callback => 'loadGithubData' );
      my $result = $p->users->get( user => 'plu' );
      print $result->raw_content;
  
  The result will look like this:
  
      loadGithubData({
          "meta": {
              "status": 200,
              "X-RateLimit-Limit": "5000",
              "X-RateLimit-Remaining": "4661"
          },
          "data": {
              "type": "User",
              "location": "Dubai",
              "url": "https://api.github.com/users/plu",
              "login": "plu",
              "name": "Johannes Plunien",
              ...
          }
      })
  
  B<Be careful:> The L<content|Pithub::Result/content> method will
  try to decode the JSON into a Perl data structure. This is not
  possible if the C<< jsonp_callback >> is set:
  
      # calling this ...
      print $result->content;
  
      # ... will throw an exception like this ...
      Runtime error: malformed JSON string, neither array, object, number, string or atom,
      at character offset 0 (before "loadGithubData( ...
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_jsonp_callback>: reset the jsonp_callback attribute
  
  =item *
  
  B<has_jsonp_callback>: check if the jsonp_callback attribute is set
  
  =back
  
  =head2 per_page
  
  Controls how many items are fetched per API call, aka "page".  See
  also: L<http://developer.github.com/v3/#pagination> and
  L</auto_pagination>.
  
  To minimize the number of API calls to get a complete listing, this
  defaults to the maximum allowed by Github, which is currently 100.
  This may change in the future if Github changes their maximum.
  
  Examples:
  
      my $users = Pithub::Users->new( per_page => 30 );
  
      # ... is the same as ...
  
      my $users = Pithub::Users->new;
      $users->per_page(30);
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_per_page>: reset the per_page attribute
  
  =item *
  
  B<has_per_page>: check if the per_page attribute is set
  
  =back
  
  =head2 prepare_request
  
  This is a CodeRef and can be used to modify the L<HTTP::Request>
  object on a global basis, before it's being sent to the Github
  API. It's useful for setting MIME types for example. See also:
  L<http://developer.github.com/v3/mimes/>. This is the right way
  to go if you want to modify the HTTP request of B<all> API
  calls. If you just want to change a few, consider sending the
  C<< prepare_request >> parameter on any method call.
  
  Let's use this example from the Github docs:
  
  B<Html>
  
  C<< application/vnd.github-issue.html+json >>
  
  Return html rendered from the body's markdown. Response will
  include body_html.
  
  Examples:
  
      my $p = Pithub::Issues->new(
          prepare_request => sub {
              my ($request) = @_;
              $request->header( Accept => 'application/vnd.github-issue.html+json' );
          }
      );
  
      my $result = $p->get(
          user     => 'miyagawa',
          repo     => 'Plack',
          issue_id => 209,
      );
  
      print $result->content->{body_html};
  
  Please compare to the solution where you set the custom HTTP header
  on the method call, instead globally on the object:
  
      my $p = Pithub::Issues->new;
  
      my $result = $p->get(
          user     => 'miyagawa',
          repo     => 'Plack',
          issue_id => 209,
          options  => {
              prepare_request => sub {
                  my ($request) = @_;
                  $request->header( Accept => 'application/vnd.github-issue.html+json' );
              },
          }
      );
  
      print $result->content->{body_html};
  
  =head2 repo
  
  This can be set as a default repo to use for API calls that require
  the repo parameter to be set. There are many of them and it can get
  kind of verbose to include the repo and the user for all of the
  calls, especially if you want to do many operations on the same
  user/repo.
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new( repo => 'Pithub' );
      my $result = $c->list( user => 'plu' );
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_repo>: reset the repo attribute
  
  =item *
  
  B<has_repo>: check if the repo attribute is set
  
  =back
  
  =head2 token
  
  If the OAuth token is set, L<Pithub> will sent it via an HTTP header
  on each API request. Currently the basic authentication method is
  not supported.
  
  See also: L<http://developer.github.com/v3/oauth/>
  
  =head2 ua
  
  By default a L<LWP::UserAgent> object, but it can be anything that
  implements the same interface.
  
  =head2 user
  
  This can be set as a default user to use for API calls that require
  the user parameter to be set.
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new( user => 'plu' );
      my $result = $c->list( repo => 'Pithub' );
  
  There are two helper methods:
  
  =over
  
  =item *
  
  B<clear_user>: reset the user attribute
  
  =item *
  
  B<has_user>: check if the user attribute is set
  
  =back
  
  It might make sense to use this together with the repo attribute:
  
      my $c = Pithub::Repos::Commits->new( user => 'plu', repo => 'Pithub' );
      my $result = $c->list;
      my $result = $c->list_comments;
      my $result = $c->get('6b6127383666e8ecb41ec20a669e4f0552772363');
  
  =head1 METHODS
  
  =head2 request
  
  This method is the central point: All L<Pithub> are using this method
  for making requests to the Github. If Github adds a new API call that
  is not yet supported, this method can be used directly. It accepts
  an hash with following keys:
  
  =over
  
  =item *
  
  B<method>: mandatory string, one of the following:
  
  =over
  
  =item *
  
  DELETE
  
  =item *
  
  GET
  
  =item *
  
  PATCH
  
  =item *
  
  POST
  
  =item *
  
  PUT
  
  =back
  
  =item *
  
  B<path>: mandatory string of the relative path used for making the
  API call.
  
  =item *
  
  B<data>: optional data reference, usually a reference to an array
  or hash. It must be possible to serialize this using L<JSON>.
  This will be the HTTP request body.
  
  =item *
  
  B<options>: optional hash reference to set additional options on
  the request. So far C<< prepare_request >> is supported. See
  more about that in the examples below. So this can be used on
  B<every> method which maps directly to an API call.
  
  =item *
  
  B<params>: optional hash reference to set additional C<< GET >>
  parameters. This could be achieved using the C<< prepare_request >>
  in the C<< options >> hashref as well, but this is shorter. It's
  being used in L<list method of Pithub::Issues|Pithub::Issues/list>
  for example.
  
  =back
  
  Usually you should not end up using this method at all. It's only
  available if L<Pithub> is missing anything from the Github v3 API.
  Though here are some examples how to use it:
  
  =over
  
  =item *
  
  Same as L<Pithub::Issues/list>:
  
      my $p      = Pithub->new;
      my $result = $p->request(
          method => 'GET',
          path   => '/repos/plu/Pithub/issues',
          params => {
              state     => 'closed',
              direction => 'asc',
          }
      );
  
  =item *
  
  Same as L<Pithub::Users/get>:
  
      my $p = Pithub->new;
      my $result = $p->request(
          method => 'GET',
          path   => '/users/plu',
      );
  
  =item *
  
  Same as L<Pithub::Gists/create>:
  
      my $p      = Pithub->new;
      my $method = 'POST';
      my $path   = '/gists';
      my $data   = {
          description => 'the description for this gist',
          public      => 1,
          files       => { 'file1.txt' => { content => 'String file content' } }
      };
      my $result = $p->request(
          method => $method,
          path   => $path,
          data   => $data,
      );
  
  =item *
  
  Same as L<Pithub::GitData::Trees/get>:
  
      my $p       = Pithub->new;
      my $method  = 'GET';
      my $path    = '/repos/miyagawa/Plack/issues/209';
      my $data    = undef;
      my $options = {
          prepare_request => sub {
              my ($request) = @_;
              $request->header( Accept => 'application/vnd.github-issue.html+json' );
          },
      };
      my $result = $p->request(
          method  => $method,
          path    => $path,
          data    => $data,
          options => $options,
      );
  
  =back
  
  This method always returns a L<Pithub::Result> object.
  
  =head2 has_token (?$request)
  
  This method checks if a token has been specified, or if not, and a request
  object is passed, then it looks for an Authorization header in the request.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_BASE

$fatpacked{"Pithub/Events.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_EVENTS';
  package Pithub::Events;
  $Pithub::Events::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Events API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub issue {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub network {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/networks/%s/%s/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub org {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/events', delete $args{org} ),
          %args,
      );
  }
  
  
  sub org_for_user {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/users/%s/events/orgs/%s', delete $args{user}, delete $args{org} ),
          %args,
      );
  }
  
  
  sub public {
      my ( $self, %args ) = @_;
      return $self->request(
          method => 'GET',
          path   => '/events',
          %args,
      );
  }
  
  
  sub repos {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub user_performed {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      my $path = sprintf( '/users/%s/events', delete $args{user} );
      if ( $args{public} ) {
          $path .= '/public';
      }
      return $self->request(
          method => 'GET',
          path   => $path,
          %args,
      );
  }
  
  
  sub user_received {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      my $path = sprintf( '/users/%s/received_events', delete $args{user} );
      if ( $args{public} ) {
          $path .= '/public';
      }
      return $self->request(
          method => 'GET',
          path   => $path,
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Events - Github v3 Events API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 issue
  
  =over
  
  =item *
  
  List issue events for a repository
  
      GET /repos/:user/:repo/issues/events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->issue(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 network
  
  =over
  
  =item *
  
  List public events for a network of repositories
  
      GET /networks/:user/:repo/events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->network(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 org
  
  =over
  
  =item *
  
  List public events for an organization
  
      GET /orgs/:org/events
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->org( org => 'CPAN-API' );
  
  =back
  
  =head2 org_for_user
  
  =over
  
  =item *
  
  List events for an organization
  
      GET /users/:user/events/orgs/:org
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->org(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 public
  
  =over
  
  =item *
  
  List public events
  
      GET /events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->public;
  
  =back
  
  =head2 repos
  
  =over
  
  =item *
  
  List repository events
  
      GET /repos/:user/:repo/events
  
  Examples:
  
      my $e      = Pithub::Events->new;
      my $result = $e->repos(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 user_performed
  
  =over
  
  =item *
  
  List events performed by a user
  
      GET /users/:user/events
  
  If you are authenticated as the given user, you will see your
  private events. Otherwise, you'll only see public events.
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->user_performed( user => 'plu' );
  
      # List public events performed by a user
      my $e      = Pithub::Events->new;
      my $result = $e->user_performed(
          user   => 'plu',
          public => 1,
      );
  
  =back
  
  =head2 user_received
  
  =over
  
  =item *
  
  List events that a user has received
  
      GET /users/:user/received_events
  
  These are events that you've received by watching repos and
  following users. If you are authenticated as the given user,
  you will see private events. Otherwise, you'll only see
  public events.
  
  Examples:
  
      my $e = Pithub::Events->new;
      my $result = $e->user_received( user => 'plu' );
  
      # List public events that a user has received
      my $e      = Pithub::Events->new;
      my $result = $e->user_received(
          user   => 'plu',
          public => 1,
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_EVENTS

$fatpacked{"Pithub/Gists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GISTS';
  package Pithub::Gists;
  $Pithub::Gists::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Gists API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Gists::Comments
  extends 'Pithub::Base';
  
  
  sub comments {
      return shift->_create_instance('Pithub::Gists::Comments', @_);
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => '/gists',
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/gists/%s', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub fork {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'POST',
          path   => sprintf( '/gists/%s/forks', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub is_starred {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s/star', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/gists', $user ),
              %args,
          );
      }
      elsif ( delete $args{starred} ) {
          return $self->request(
              method => 'GET',
              path   => '/gists/starred',
              %args,
          );
      }
      elsif ( delete $args{public} ) {
          return $self->request(
              method => 'GET',
              path   => '/gists/public',
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/gists',
          %args,
      );
  }
  
  
  sub star {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/gists/%s/star', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub unstar {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/gists/%s/star', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/gists/%s', delete $args{gist_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Gists - Github v3 Gists API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 comments
  
  Provides access to L<Pithub::Gists::Comments>.
  
  =head2 create
  
  =over
  
  =item *
  
  Create a gist
  
      POST /gists
  
  Parameters:
  
  =over
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<description>: optional string
  
  =item *
  
  B<public>: mandatory boolean
  
  =item *
  
  B<files>: mandatory hashref, please see examples section below
  
  =back
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->create(
          data => {
              description => 'the description for this gist',
              public      => 1,
              files       => { 'file1.txt' => { content => 'String file content' } }
          }
      );
      if ( $result->success ) {
          printf "The new gist is available at %s\n", $result->content->{html_url};
      }
  
  Response: B<Status: 201 Created>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z",
          "forks": [
          {
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "url": "https://api.github.com/gists/5",
              "created_at": "2011-04-14T16:00:49Z"
          }
          ],
          "history": [
          {
              "url": "https://api.github.com/gists/1/57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "version": "57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "change_status": {
                  "deletions": 0,
                  "additions": 180,
                  "total": 180
              },
              "committed_at": "2010-04-14T02:15:15Z"
          }
          ]
      }
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a gist
  
      DELETE /gists/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->delete( gist_id => 784612 );
      if ( $result->success ) {
          print "The gist 784612 has been deleted\n";
      }
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 fork
  
  =over
  
  =item *
  
  Fork a gist
  
      POST /gists/:id/forks
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->fork( gist_id => 784612 );
      if ( $result->success ) {
          printf "The gist 784612 has been forked: %s\n", $result->content->{html_url};
      }
  
  Response: B<Status: 201 Created>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z"
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single gist
  
      GET /gists/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->get( gist_id => 784612 );
      if ( $result->success ) {
          print $result->content->{html_url};
      }
  
  Response: B<Status: 200 OK>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z",
          "forks": [
          {
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "url": "https://api.github.com/gists/5",
              "created_at": "2011-04-14T16:00:49Z"
          }
          ],
          "history": [
          {
              "url": "https://api.github.com/gists/1/57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "version": "57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "change_status": {
                  "deletions": 0,
                  "additions": 180,
                  "total": 180
              },
              "committed_at": "2010-04-14T02:15:15Z"
          }
          ]
      }
  
  =back
  
  =head2 is_starred
  
  =over
  
  =item *
  
  Check if a gist is starred
  
      GET /gists/:id/star
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->is_starred( gist_id => 784612 );
  
  Response: B<Status: 204 No Content> / C<< Status: 404 Not Found >>
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List a user's gists:
  
      GET /users/:user/gists
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: string
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list( user => 'miyagawa' );
      if ( $result->success ) {
          while ( my $row = $result->next ) {
              printf "%s => %s\n", $row->{html_url}, $row->{description} || 'no description';
          }
      }
  
  =item *
  
  List the authenticated user's gists or if called anonymously,
  this will returns all public gists:
  
      GET /gists
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list;
  
  =item *
  
  List all public gists:
  
      GET /gists/public
  
  Parameters:
  
  =over
  
  =item *
  
  B<public>: boolean
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list( public => 1 );
  
  =item *
  
  List the authenticated user's starred gists:
  
      GET /gists/starred
  
  Parameters:
  
  =over
  
  =item *
  
  B<starred>: boolean
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->list( starred => 1 );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "url": "https://api.github.com/gists/1",
              "id": "1",
              "description": "description of gist",
              "public": true,
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "files": {
                  "ring.erl": {
                      "size": 932,
                      "filename": "ring.erl",
                      "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                      "content": "contents of gist"
                  }
              },
              "comments": 0,
              "git_pull_url": "git://gist.github.com/1.git",
              "git_push_url": "git@gist.github.com:1.git",
              "created_at": "2010-04-14T02:15:15Z"
          }
      ]
  
  =back
  
  =head2 star
  
  =over
  
  =item *
  
  Star a gist
  
      PUT /gists/:id/star
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->star( gist_id => 784612 );
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 unstar
  
  =over
  
  =item *
  
  Unstar a gist
  
      DELETE /gists/:id/star
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $g = Pithub::Gists->new;
      my $result = $g->unstar( gist_id => 784612 );
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a gist
  
      PATCH /gists/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory integer
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<description>: optional string
  
  =item *
  
  B<public>: mandatory boolean
  
  =item *
  
  B<files>: mandatory hashref, please see examples section below
  
  NOTE: All files from the previous version of the gist are carried
  over by default if not included in the hash. Deletes can be
  performed by including the filename with a null hash.
  
  =back
  
  =back
  
  Examples:
  
      my $g      = Pithub::Gists->new;
      my $result = $g->update(
          gist_id => 784612,
          data    => {
              description => 'the description for this gist',
              files       => {
                  'file1.txt'    => { content => 'updated file contents' },
                  'old_name.txt' => {
                      filename => 'new_name.txt',
                      content  => 'modified contents'
                  },
                  'new_file.txt'         => { content => 'a new file' },
                  'delete_this_file.txt' => undef
              }
          }
      );
  
  Response: B<Status: 200 OK>
  
      {
          "url": "https://api.github.com/gists/1",
          "id": "1",
          "description": "description of gist",
          "public": true,
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "files": {
              "ring.erl": {
                  "size": 932,
                  "filename": "ring.erl",
                  "raw_url": "https://gist.github.com/raw/365370/8c4d2d43d178df44f4c03a7f2ac0ff512853564e/ring.erl",
                  "content": "contents of gist"
              }
          },
          "comments": 0,
          "git_pull_url": "git://gist.github.com/1.git",
          "git_push_url": "git@gist.github.com:1.git",
          "created_at": "2010-04-14T02:15:15Z",
          "forks": [
          {
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "url": "https://api.github.com/gists/5",
              "created_at": "2011-04-14T16:00:49Z"
          }
          ],
          "history": [
          {
              "url": "https://api.github.com/gists/1/57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "version": "57a7f021a713b1c5a6a199b54cc514735d2d462f",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "change_status": {
                  "deletions": 0,
                  "additions": 180,
                  "total": 180
              },
              "committed_at": "2010-04-14T02:15:15Z"
          }
          ]
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GISTS

$fatpacked{"Pithub/Gists/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GISTS_COMMENTS';
  package Pithub::Gists::Comments;
  $Pithub::Gists::Comments::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Gist Comments API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => sprintf( '/gists/%s/comments', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/gists/%s/comments/%s', delete $args{gist_id}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s/comments/%s', delete $args{gist_id}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/gists/%s/comments', delete $args{gist_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: gist_id' unless $args{gist_id};
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/gists/%s/comments/%s', delete $args{gist_id}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Gists::Comments - Github v3 Gist Comments API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a comment
  
      POST /gists/:gist_id/comments
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<body>: mandatory string
  
  =back
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->create(
          gist_id => 'c0ff33',
          data    => { body => 'Just commenting for the sake of commenting' },
      );
  
  Response: B<Status: 201 Created>
  
      {
          "id": 1,
          "url": "https://api.github.com/gists/c0ff33/comments/1",
          "body": "Just commenting for the sake of commenting",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "created_at": "2011-04-18T23:23:56Z"
      }
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a comment
  
      DELETE /gists/:gist_id/comments/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<comment_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->delete(
          gist_id    => 'c0ff33',
          comment_id => 1
      );
  
  Response: B<Status: 204 No Content>
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single comment
  
      GET /gists/:gist_id/comments/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<comment_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->get(
          gist_id    => 'c0ff33',
          comment_id => 1
      );
  
  Response: B<Status: 200 OK>
  
      {
          "id": 1,
          "url": "https://api.github.com/gists/c0ff33/comments/1",
          "body": "Just commenting for the sake of commenting",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "created_at": "2011-04-18T23:23:56Z"
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List comments on a gist
  
      GET /gists/:gist_id/comments
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->list( gist_id => 1 );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "id": 1,
              "url": "https://api.github.com/gists/c0ff33/comments/1",
              "body": "Just commenting for the sake of commenting",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "created_at": "2011-04-18T23:23:56Z"
          }
      ]
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a comment
  
      PATCH /gists/:gist_id/comments/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<gist_id>: mandatory string
  
  =item *
  
  B<comment_id>: mandatory integer
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<body>: mandatory string
  
  =back
  
  =back
  
  Examples:
  
      my $c = Pithub::Gists::Comments->new;
      my $result = $c->update(
          gist_id    => 'c0ff33',
          comment_id => 1,
          data       => { body => 'some comment' }
      );
  
  Response: B<Status: 200 OK>
  
      {
          "id": 1,
          "url": "https://api.github.com/gists/c0ff33/comments/1",
          "body": "Just commenting for the sake of commenting",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "created_at": "2011-04-18T23:23:56Z"
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GISTS_COMMENTS

$fatpacked{"Pithub/GitData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA';
  package Pithub::GitData;
  $Pithub::GitData::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Git Data API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::GitData::Blobs;
  use Pithub::GitData::Commits;
  use Pithub::GitData::References;
  use Pithub::GitData::Tags;
  use Pithub::GitData::Trees;
  extends 'Pithub::Base';
  
  
  sub blobs {
      return shift->_create_instance('Pithub::GitData::Blobs', @_);
  }
  
  
  sub commits {
      return shift->_create_instance('Pithub::GitData::Commits', @_);
  }
  
  
  sub references {
      return shift->_create_instance('Pithub::GitData::References', @_);
  }
  
  
  sub tags {
      return shift->_create_instance('Pithub::GitData::Tags', @_);
  }
  
  
  sub trees {
      return shift->_create_instance('Pithub::GitData::Trees', @_);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData - Github v3 Git Data API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 blobs
  
  Provides access to L<Pithub::GitData::Blobs>.
  
  =head2 commits
  
  Provides access to L<Pithub::GitData::Commits>.
  
  =head2 references
  
  Provides access to L<Pithub::GitData::References>.
  
  =head2 tags
  
  Provides access to L<Pithub::GitData::Tags>.
  
  =head2 trees
  
  Provides access to L<Pithub::GitData::Trees>.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA

$fatpacked{"Pithub/GitData/Blobs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_BLOBS';
  package Pithub::GitData::Blobs;
  $Pithub::GitData::Blobs::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Git Data Blobs API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/blobs', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/blobs/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Blobs - Github v3 Git Data Blobs API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 DESCRIPTION
  
  Since blobs can be any arbitrary binary data, the input and responses
  for the blob api takes an encoding parameter that can be either
  C<< utf-8 >> or C<< base64 >>. If your data cannot be losslessly sent
  as a UTF-8 string, you can base64 encode it.
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Blob
  
      POST /repos/:user/:repo/git/blobs
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<content>: mandatory string
  
  =item *
  
  B<encoding>: mandatory string, C<< utf-8 >> or C<< base64 >>
  
  =back
  
  =back
  
  Examples:
  
      my $b = Pithub::GitData::Blobs->new;
      my $result = $b->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              content  => 'Content of the blob',
              encoding => 'utf-8',
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "sha": "3a0f86fb8db8eea7ccbb9a95f325ddbedfb25e15"
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Blob
  
      GET /repos/:user/:repo/git/blobs/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =back
  
  Examples:
  
      my $b = Pithub::GitData::Blobs->new;
      my $result = $b->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'b7cdea6830e128bc16c2b75efd99842d971666e2',
      );
  
  Response: B<Status: 200 OK>
  
      {
          "content": "Content of the blob",
          "encoding": "utf-8"
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_BLOBS

$fatpacked{"Pithub/GitData/Commits.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_COMMITS';
  package Pithub::GitData::Commits;
  $Pithub::GitData::Commits::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Git Data Commits API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/commits', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/commits/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Commits - Github v3 Git Data Commits API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Commit
  
      POST /repos/:user/:repo/git/commits
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<message>: mandatory string, the commit message
  
  =item *
  
  B<tree>: mandatory string, the SHA of the tree object this commit
  points to
  
  =item *
  
  B<parents>: mandatory arrayref of the SHAs of the commits that were
  the parents of this commit. If omitted or empty, the commit will be
  written as a root commit. For a single parent, an array of one SHA
  should be provided, for a merge commit, an array of more than one
  should be provided points to.
  
  =back
  
  Optional Parameters in the C<< data >> hashref:
  
  The committer section is optional and will be filled with the author
  data if omitted. If the author section is omitted, it will be filled
  in with the authenticated users information and the current date.
  
  =over
  
  =item *
  
  B<author>: hashref, having following keys:
  
  =over
  
  =item *
  
  B<name>: string of the name of the author of the commit
  
  =item *
  
  B<email>: string of the email of the author of the commit
  
  =item *
  
  B<date>: timestamp of when this commit was authored
  
  =back
  
  =item *
  
  B<committer>: hashref, having following keys:
  
  =over
  
  =item *
  
  B<name>: string of the name of the committer of the commit
  
  =item *
  
  B<email>: string of the email of the committer of the commit
  
  =item *
  
  B<date>: timestamp of when this commit was committed
  
  =back
  
  =back
  
  =back
  
  Examples:
  
      my $c = Pithub::GitData::Commits->new;
      my $result = $c->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              author => {
                  date  => '2008-07-09T16:13:30+12:00',
                  email => 'schacon@gmail.com',
                  name  => 'Scott Chacon',
              },
              message => 'my commit message',
              parents => ['7d1b31e74ee336d15cbd21741bc88a537ed063a0'],
              tree    => '827efc6d56897b048c772eb4087f854f46256132',
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "sha": "7638417db6d59f3c431d3e1f261cc637155684cd",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd",
          "author": {
              "date": "2008-07-09T16:13:30+12:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "committer": {
              "date": "2008-07-09T16:13:30+12:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "message": "my commit message",
          "tree": {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/trees/827efc6d56897b048c772eb4087f854f46256132",
              "sha": "827efc6d56897b048c772eb4087f854f46256132"
          },
          "parents": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/7d1b31e74ee336d15cbd21741bc88a537ed063a0",
              "sha": "7d1b31e74ee336d15cbd21741bc88a537ed063a0"
          }
          ]
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Commit
  
      GET /repos/:user/:repo/git/commits/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =back
  
  Examples:
  
      my $c = Pithub::GitData::Commits->new;
      my $result = $c->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'b7cdea6830e128bc16c2b75efd99842d971666e2',
      );
  
  Response: B<Status: 200 OK>
  
      {
          "sha": "7638417db6d59f3c431d3e1f261cc637155684cd",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd",
          "author": {
              "date": "2010-04-10T14:10:01-07:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "committer": {
              "date": "2010-04-10T14:10:01-07:00",
              "name": "Scott Chacon",
              "email": "schacon@gmail.com"
          },
          "message": "added readme, because im a good github citizen\n",
          "tree": {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/trees/691272480426f78a0138979dd3ce63b77f706feb",
              "sha": "691272480426f78a0138979dd3ce63b77f706feb"
          },
          "parents": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/1acc419d4d6a9ce985db7be48c6349a0475975b5",
              "sha": "1acc419d4d6a9ce985db7be48c6349a0475975b5"
          }
          ]
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_COMMITS

$fatpacked{"Pithub/GitData/References.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_REFERENCES';
  package Pithub::GitData::References;
  $Pithub::GitData::References::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Git Data References API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/refs', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: ref' unless $args{ref};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/refs/%s', delete $args{user}, delete $args{repo}, delete $args{ref} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $ref = $args{ref} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/git/refs/%s', delete $args{user}, delete $args{repo}, delete $args{ref} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/refs', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: ref' unless $args{ref};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/git/refs/%s', delete $args{user}, delete $args{repo}, delete $args{ref} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::References - Github v3 Git Data References API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Reference
  
      POST /repos/:user/:repo/git/refs
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<ref>: mandatory string of the name of the fully qualified
  reference (ie: refs/heads/master). If it doesn't start with
  'refs' and have at least two slashes, it will be rejected.
  
  =item *
  
  B<sha>: mandatory string of the SHA1 value to set this
  reference to.
  
  =back
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              ref => 'refs/heads/master',
              sha => '827efc6d56897b048c772eb4087f854f46256132' .
          }
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Reference
  
      GET /repos/:user/:repo/git/refs/:ref
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<ref>: mandatory string
  
  The key B<ref> must be formatted as C<< heads/branch >>, not just
  C<< branch >>. For example, the call to get the data for a branch
  named C<< sc/featureA >> would be: C<< heads/sc/featureA >>
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->get(
          user => 'plu',
          repo => 'Pithub',
          ref  => 'heads/master'
      );
  
  Response: B<Status: 200 OK>
  
      {
          "ref": "refs/heads/sc/featureA",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/refs/heads/sc/featureA",
          "object": {
              "type": "commit",
              "sha": "aa218f56b14c9653891f9e74264a383fa43fefbd",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/aa218f56b14c9653891f9e74264a383fa43fefbd"
          }
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  Get all References
  
      GET /repos/:user/:repo/git/refs
  
  This will return an array of all the references on the system,
  including things like notes and stashes if they exist on the server.
  Anything in the namespace, not just heads and tags, though that
  would be the most common.
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =item *
  
  You can also request a sub-namespace. For example, to get all the
  tag references, you can call:
  
      GET /repos/:user/:repo/git/refs/tags
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<ref>: mandatory string
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->list(
          user => 'plu',
          repo => 'Pithub',
          ref  => 'tags',
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "object": {
                  "type": "commit",
                  "sha": "1c5230f42d6d3e376162591f223fc4130d671937",
                  "url": "https://api.github.com/repos/plu/Pithub/git/commits/1c5230f42d6d3e376162591f223fc4130d671937"
              },
              "ref": "refs/tags/v0.01000",
              "url": "https://api.github.com/repos/plu/Pithub/git/refs/tags/v0.01000"
          },
          {
              "object": {
                  "type": "tag",
                  "sha": "ef328a0679a992bd2c0ac537cf19d379f1c8d177",
                  "url": "https://api.github.com/repos/plu/Pithub/git/tags/ef328a0679a992bd2c0ac537cf19d379f1c8d177"
              },
              "ref": "refs/tags/v0.01001",
              "url": "https://api.github.com/repos/plu/Pithub/git/refs/tags/v0.01001"
          }
      ]
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a Reference
  
      PATCH /repos/:user/:repo/git/refs/:ref
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<ref>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<sha>: mandatory string of the SHA1 value to set this
  reference to.
  
  =item *
  
  B<force>: optional boolean indicating whether to force the update or
  to make sure the update is a fast-forward update. The default is
  C<< false >> so leaving this out or setting it to C<< false >> will
  make sure you're not overwriting work.
  
  =back
  
  =back
  
  Examples:
  
      my $r = Pithub::GitData::References->new;
      my $result = $r->update(
          user => 'plu',
          repo => 'Pithub',
          ref  => 'tags/v1.0',
          data => {
              force => 1,
              sha   => 'aa218f56b14c9653891f9e74264a383fa43fefbd',
          }
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "ref": "refs/heads/sc/featureA",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/refs/heads/sc/featureA",
              "object": {
                  "type": "commit",
                  "sha": "aa218f56b14c9653891f9e74264a383fa43fefbd",
                  "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/aa218f56b14c9653891f9e74264a383fa43fefbd"
              }
          }
      ]
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_REFERENCES

$fatpacked{"Pithub/GitData/Tags.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_TAGS';
  package Pithub::GitData::Tags;
  $Pithub::GitData::Tags::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Git Data Tags API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/tags', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/git/tags/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Tags - Github v3 Git Data Tags API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 DESCRIPTION
  
  This tags api only deals with tag objects - so only annotated tags,
  not lightweight tags.
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a Tag
  
  Note that creating a tag object does not create the reference that
  makes a tag in Git. If you want to create an annotated tag in Git,
  you have to do this call to create the tag object, and then create
  the C<< refs/tags/[tag] >> reference. If you want to create a
  lightweight tag, you simply have to create the reference - this
  call would be unnecessary.
  
      POST /repos/:user/:repo/git/tags
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<tag>: mandatory string of the tag
  
  =item *
  
  B<message>: mandatory string of the tag message
  
  =item *
  
  B<object>: mandatory stringof the SHA of the git object this is tagging
  
  =item *
  
  B<type>: mandatory string of the type of the object we're tagging.
  Normally this is a C<< commit >> but it can also be a C<< tree >>
  or a C<< blob >>.
  
  =item *
  
  B<tagger>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<name>: string of the name of the author of the tag
  
  =item *
  
  B<email>: string of the email of the author of the tag
  
  =item *
  
  B<date>: timestamp of when this commit was tagged
  
  =back
  
  =back
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Tags->new;
      my $result = $t->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              tagger => {
                  date  => '2011-06-17T14:53:35-07:00',
                  email => 'schacon@gmail.com',
                  name  => 'Scott Chacon',
              },
              message => 'initial version',
              object  => 'c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c',
              tag     => 'v0.0.1',
              type    => 'commit',
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "tag": "v0.0.1",
          "sha": "940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "message": "initial version\n",
          "tagger": {
              "name": "Scott Chacon",
              "email": "schacon@gmail.com",
              "date": "2011-06-17T14:53:35-07:00"
          },
          "object": {
              "type": "commit",
              "sha": "c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c"
          }
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Tag
  
      GET /repos/:user/:repo/git/tags/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Tags->new;
      my $result = $t->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
      );
  
  Response: B<Status: 200 OK>
  
      {
          "tag": "v0.0.1",
          "sha": "940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "url": "https://api.github.com/repos/octocat/Hello-World/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac",
          "message": "initial version\n",
          "tagger": {
              "name": "Scott Chacon",
              "email": "schacon@gmail.com",
              "date": "2011-06-17T14:53:35-07:00"
          },
          "object": {
              "type": "commit",
              "sha": "c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c",
              "url": "https://api.github.com/repos/octocat/Hello-World/git/commits/c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c"
          }
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_TAGS

$fatpacked{"Pithub/GitData/Trees.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_GITDATA_TREES';
  package Pithub::GitData::Trees;
  $Pithub::GitData::Trees::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Git Data Trees API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/git/trees', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      my $path = sprintf( '/repos/%s/%s/git/trees/%s', $args{user}, $args{repo}, $args{sha} );
      my %params = ();
      if ( $args{recursive} ) {
          $params{recursive} = 1;
      }
      return $self->request(
          method => 'GET',
          path   => $path,
          params => \%params,
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::GitData::Trees - Github v3 Git Data Trees API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  The tree creation API will take nested entries as well. If both a
  tree and a nested path modifying that tree are specified, it will
  overwrite the contents of that tree with the new path contents and
  write a new tree out.
  
  =over
  
  =item *
  
  Create a Tree
  
      POST /repos/:user/:repo/git/trees
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<base_tree>: optional String of the SHA1 of the tree you want to
  update with new data.
  
  =item *
  
  B<tree>: mandatory arrayref of hashrefs, having following keys:
  
  =over
  
  =item *
  
  B<path>: mandatory string of the file referenced in the tree.
  
  =item *
  
  B<mode>: mandatory string of the file mode - one of C<< 100644 >>
  for file (blob), C<< 100755 >> for executable (blob), C<< 040000 >>
  for subdirectory (tree), C<< 160000 >> for submodule (commit) or
  C<< 120000 >> for a blob that specifies the path of a symlink.
  
  =item *
  
  B<type>: mandatory string of C<< blob >>, C<< tree >>, C<< commit >>.
  
  =item *
  
  B<sha>: mandatory string of SHA1 checksum ID of the object in the tree.
  
  =item *
  
  B<content>: String of content you want this file to have - GitHub will
  write this blob out and use that SHA for this entry. Use either this
  or C<< tree.sha >>.
  
  =back
  
  =back
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Trees->new;
      my $result = $t->create(
          user => 'octocat',
          repo => 'Hello-World',
          data => {
              tree => [
                  {
                      path => 'file.rb',
                      mode => '100644',
                      type => 'blob',
                      sha  => '7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b',
                  }
              ]
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "sha": "cd8274d15fa3ae2ab983129fb037999f264ba9a7",
          "url": "https://api.github.com/repo/octocat/Hello-World/trees/cd8274d15fa3ae2ab983129fb037999f264ba9a7",
          "tree": [
          {
              "path": "file.rb",
              "mode": "100644",
              "type": "blob",
              "size": 132,
              "sha": "7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b"
          }
          ]
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a Tree
  
      GET /repos/:user/:repo/git/trees/:sha
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =item *
  
  B<recursive>: optional boolean
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Trees->new;
      my $result = $t->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6'
      );
  
  Response: B<Status: 200 OK>
  
      {
          "sha": "9fb037999f264ba9a7fc6274d15fa3ae2ab98312",
          "url": "https://api.github.com/repo/octocat/Hello-World/trees/9fb037999f264ba9a7fc6274d15fa3ae2ab98312",
          "tree": [
          {
              "path": "file.rb",
              "mode": "100644",
              "type": "blob",
              "size": 30,
              "sha": "44b4fc6d56897b048c772eb4087f854f46256132",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/44b4fc6d56897b048c772eb4087f854f46256132"
          },
          {
              "path": "subdir",
              "mode": "040000",
              "type": "tree",
              "sha": "f484d249c660418515fb01c2b9662073663c242e",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/f484d249c660418515fb01c2b9662073663c242e"
          },
          {
              "path": "exec_file",
              "mode": "100755",
              "type": "blob",
              "size": 75,
              "sha": "45b983be36b73c0788dc9cbcb76cbb80fc7bb057",
              "url": "https://api.github.com/octocat/Hello-World/git/blobs/45b983be36b73c0788dc9cbcb76cbb80fc7bb057"
          }
          ]
      }
  
  =item *
  
  Get a Tree Recursively
  
      GET /repos/:user/:repo/git/trees/:sha?recursive=1
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<sha>: mandatory string
  
  =item *
  
  B<recursive>: optional boolean
  
  =back
  
  Examples:
  
      my $t = Pithub::GitData::Trees->new;
      my $result = $t->get(
          user      => 'plu',
          repo      => 'Pithub',
          sha       => 'df21b2660fb6',
          recursive => 1,
      );
  
  Response: B<Status: 200 OK>
  
      {
          "sha": "fc6274d15fa3ae2ab983129fb037999f264ba9a7",
          "url": "https://api.github.com/repo/octocat/Hello-World/trees/fc6274d15fa3ae2ab983129fb037999f264ba9a7",
          "tree": [
          {
              "path": "subdir/file.txt",
              "mode": "100644",
              "type": "blob",
              "size": 132,
              "sha": "7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b",
              "url": "https://api.github.com/octocat/Hello-World/git/7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b"
          }
          ]
      }
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_GITDATA_TREES

$fatpacked{"Pithub/Issues.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES';
  package Pithub::Issues;
  $Pithub::Issues::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Issues API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Issues::Assignees;
  use Pithub::Issues::Comments;
  use Pithub::Issues::Events;
  use Pithub::Issues::Labels;
  use Pithub::Issues::Milestones;
  extends 'Pithub::Base';
  
  
  sub assignees {
      return shift->_create_instance('Pithub::Issues::Assignees', @_);
  }
  
  
  sub comments {
      return shift->_create_instance('Pithub::Issues::Comments', @_);
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/issues', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub events {
      return shift->_create_instance('Pithub::Issues::Events', @_);
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/%s', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub labels {
      return shift->_create_instance('Pithub::Issues::Labels', @_);
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_get_user_repo_args( \%args );
      if ( $args{user} && $args{repo} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/issues', delete $args{user}, delete $args{repo} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf('/issues'),
          %args,
      );
  }
  
  
  sub milestones {
      return shift->_create_instance('Pithub::Issues::Milestones', @_);
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/issues/%s', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues - Github v3 Issues API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 assignees
  
  Provides access to L<Pithub::Issues::Assignees>.
  
  =head2 comments
  
  Provides access to L<Pithub::Issues::Comments>.
  
  =head2 create
  
  =over
  
  =item *
  
  Create an issue
  
      POST /repos/:user/:repo/issues
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<title>: mandatory string
  
  =item *
  
  B<body>: optional string
  
  =item *
  
  B<assignee>: optional string - Login for the user that this issue
  should be assigned to.
  
  =item *
  
  B<milestone>: optional number - Milestone to associate this issue
  with.
  
  =item *
  
  B<labels>: optional arrayref of strings - Labels to associate with this
  issue.
  
  =back
  
  =back
  
  Examples:
  
      my $i = Pithub::Issues->new;
      my $result = $i->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              assignee  => 'octocat',
              body      => "I'm having a problem with this.",
              labels    => [ 'Label1', 'Label2' ],
              milestone => 1,
              title     => 'Found a bug'
          }
      );
  
  Response: B<Status: 201 Created>
  
      {
          "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
          "html_url": "https://github.com/octocat/Hello-World/issues/1",
          "number": 1347,
          "state": "open",
          "title": "Found a bug",
          "body": "I'm having a problem with this.",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "labels": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
              "name": "bug",
              "color": "f29513"
          }
          ],
          "assignee": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "milestone": {
              "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
              "number": 1,
              "state": "open",
              "title": "v1.0",
              "description": "",
              "creator": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "open_issues": 4,
              "closed_issues": 8,
              "created_at": "2011-04-10T20:09:31Z",
              "due_on": null
          },
          "comments": 0,
          "pull_request": {
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
              "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
          },
          "closed_at": null,
          "created_at": "2011-04-22T13:33:48Z",
          "updated_at": "2011-04-22T13:33:48Z"
      }
  
  =back
  
  =head2 events
  
  Provides access to L<Pithub::Issues::Events>.
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single issue
  
      GET /repos/:user/:repo/issues/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<issue_id>: mandatory integer
  
  =back
  
  Examples:
  
      my $i = Pithub::Issues->new;
      my $result = $i->get(
          user => 'plu',
          repo => 'Pithub',
          issue_id => 1,
      );
  
  Response: B<Status: 200 OK>
  
      {
          "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
          "html_url": "https://github.com/octocat/Hello-World/issues/1",
          "number": 1347,
          "state": "open",
          "title": "Found a bug",
          "body": "I'm having a problem with this.",
          "user": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "labels": [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
              "name": "bug",
              "color": "f29513"
          }
          ],
          "assignee": {
              "login": "octocat",
              "id": 1,
              "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
              "url": "https://api.github.com/users/octocat"
          },
          "milestone": {
              "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
              "number": 1,
              "state": "open",
              "title": "v1.0",
              "description": "",
              "creator": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "open_issues": 4,
              "closed_issues": 8,
              "created_at": "2011-04-10T20:09:31Z",
              "due_on": null
          },
          "comments": 0,
          "pull_request": {
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
              "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
          },
          "closed_at": null,
          "created_at": "2011-04-22T13:33:48Z",
          "updated_at": "2011-04-22T13:33:48Z"
      }
  
  =back
  
  =head2 labels
  
  Provides access to L<Pithub::Issues::Labels>.
  
  =head2 list
  
  =over
  
  =item *
  
  List the issues of the authenticated user
  
      GET /issues
  
  This API call can be influenced via the C<< params >>
  hashref with following parameters:
  
  =over
  
  =item *
  
  B<filter>: one of the following:
  
  =over
  
  =item *
  
  B<assigned>: Issues assigned to you (default)
  
  =item *
  
  B<created>: Issues created by you
  
  =item *
  
  B<mentioned>: Issues mentioning you
  
  =item *
  
  B<subscribed>: Issues you're subscribed to updates for
  
  =back
  
  =item *
  
  B<state>: one of the following:
  
  =over
  
  =item *
  
  B<open> (default)
  
  =item *
  
  B<closed>
  
  =back
  
  =item *
  
  B<labels>: String list of comma separated Label names.
  Example: C<< bug,ui,@high >>
  
  =item *
  
  B<sort>: one of the following:
  
  =over
  
  =item *
  
  B<created> (default)
  
  =item *
  
  B<updated>
  
  =item *
  
  B<comments>
  
  =back
  
  =item *
  
  B<direction>: one of the following:
  
  =over
  
  =item *
  
  B<asc>
  
  =item *
  
  B<desc> (default)
  
  =back
  
  =item *
  
  B<since>: optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
  
  =back
  
  Examples:
  
      my $i      = Pithub::Issues->new;
      my $result = $i->list(
          params => {
              filter    => 'assigned',
              state     => 'open',
              labels    => 'bug',
              sort      => 'updated',
              direction => 'asc',
          }
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "number": 1347,
              "state": "open",
              "title": "Found a bug",
              "body": "I'm having a problem with this.",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "labels": [
              {
                  "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
                  "name": "bug",
                  "color": "f29513"
              }
              ],
              "assignee": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "milestone": {
                  "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
                  "number": 1,
                  "state": "open",
                  "title": "v1.0",
                  "description": "",
                  "creator": {
                      "login": "octocat",
                      "id": 1,
                      "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                      "url": "https://api.github.com/users/octocat"
                  },
                  "open_issues": 4,
                  "closed_issues": 8,
                  "created_at": "2011-04-10T20:09:31Z",
                  "due_on": null
              },
              "comments": 0,
              "pull_request": {
                  "html_url": "https://github.com/octocat/Hello-World/issues/1",
                  "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
                  "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
              },
              "closed_at": null,
              "created_at": "2011-04-22T13:33:48Z",
              "updated_at": "2011-04-22T13:33:48Z"
          }
      ]
  
  =item *
  
  List issues for a repository
  
      GET /repos/:user/:repo/issues
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =back
  
  This API call can be influenced via the C<< params >>
  hashref with following parameters:
  
  =over
  
  =item *
  
  B<milestone>: one of the following:
  
  =over
  
  =item *
  
  C<< Integer >> Milestone number
  
  =item *
  
  C<< none >> for Issues with no Milestone
  
  =item *
  
  C<< * >> for Issues with any Milestone
  
  =back
  
  =item *
  
  B<state>: one of the following:
  
  =over
  
  =item *
  
  B<open> (default)
  
  =item *
  
  B<closed>
  
  =back
  
  =item *
  
  B<assignee>: one of the following:
  
  =over
  
  =item *
  
  C<< String >> User login
  
  =item *
  
  C<< none >> for Issues with no assigned User
  
  =item *
  
  C<< * >> for Issues with any assigned User
  
  =back
  
  =item *
  
  B<mentioned>: String User login
  
  =item *
  
  B<labels>: String list of comma separated Label names.
  Example: C<< bug,ui,@high >>
  
  =item *
  
  B<sort>: one of the following:
  
  =over
  
  =item *
  
  B<created> (default)
  
  =item *
  
  B<updated>
  
  =item *
  
  B<comments>
  
  =back
  
  =item *
  
  B<direction>: one of the following:
  
  =over
  
  =item *
  
  B<asc>
  
  =item *
  
  B<desc> (default)
  
  =back
  
  =item *
  
  B<since>: optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
  
  =back
  
  Examples:
  
      my $i      = Pithub::Issues->new;
      my $result = $i->list(
          user    => 'plu',
          repo    => 'Pithub',
          params => {
              milestone => 42,
              state     => 'open',
              labels    => 'bug',
              sort      => 'updated',
              direction => 'asc',
          }
      );
  
  Response: B<Status: 200 OK>
  
      [
          {
              "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
              "html_url": "https://github.com/octocat/Hello-World/issues/1",
              "number": 1347,
              "state": "open",
              "title": "Found a bug",
              "body": "I'm having a problem with this.",
              "user": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "labels": [
              {
                  "url": "https://api.github.com/repos/octocat/Hello-World/labels/bug",
                  "name": "bug",
                  "color": "f29513"
              }
              ],
              "assignee": {
                  "login": "octocat",
                  "id": 1,
                  "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                  "url": "https://api.github.com/users/octocat"
              },
              "milestone": {
                  "url": "https://api.github.com/repos/octocat/Hello-World/milestones/1",
                  "number": 1,
                  "state": "open",
                  "title": "v1.0",
                  "description": "",
                  "creator": {
                      "login": "octocat",
                      "id": 1,
                      "gravatar_url": "https://github.com/images/error/octocat_happy.gif",
                      "url": "https://api.github.com/users/octocat"
                  },
                  "open_issues": 4,
                  "closed_issues": 8,
                  "created_at": "2011-04-10T20:09:31Z",
                  "due_on": null
              },
              "comments": 0,
              "pull_request": {
                  "html_url": "https://github.com/octocat/Hello-World/issues/1",
                  "diff_url": "https://github.com/octocat/Hello-World/issues/1.diff",
                  "patch_url": "https://github.com/octocat/Hello-World/issues/1.patch"
              },
              "closed_at": null,
              "created_at": "2011-04-22T13:33:48Z",
              "updated_at": "2011-04-22T13:33:48Z"
          }
      ]
  
  =back
  
  =head2 milestones
  
  Provides access to L<Pithub::Issues::Milestones>.
  
  =head2 update
  
  =over
  
  =item *
  
  Edit an issue
  
      PATCH /repos/:user/:repo/issues/:id
  
  Parameters:
  
  =over
  
  =item *
  
  B<user>: mandatory string
  
  =item *
  
  B<repo>: mandatory string
  
  =item *
  
  B<data>: mandatory hashref, having following keys:
  
  =over
  
  =item *
  
  B<title>: mandatory string
  
  =item *
  
  B<body>: optional string
  
  =item *
  
  B<assignee>: optional string - Login for the user that this issue
  should be assigned to.
  
  =item *
  
  B<milestone>: optional number - Milestone to associate this issue
  with.
  
  =item *
  
  B<labels>: optional arrayref of strings - Labels to associate with
  this issue. Pass one or more Labels to replace the set of Labels
  on this Issue. Send an empty arrayref (C<< [] >>) to clear all
  Labels from the Issue.
  
  =back
  
  =back
  
  Examples:
  
      my $i = Pithub::Issues->new;
      my $result = $i->update(
          user     => 'plu',
          repo     => 'Pithub',
          issue_id => 1,
          data     => {
              assignee  => 'octocat',
              body      => "I'm having a problem with this.",
              labels    => [ 'Label1', 'Label2' ],
              milestone => 1,
              state     => 'open',
              title     => 'Found a bug'
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES

$fatpacked{"Pithub/Issues/Assignees.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_ASSIGNEES';
  package Pithub::Issues::Assignees;
  $Pithub::Issues::Assignees::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Issue Assignees API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub check {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: assignee' unless $args{assignee};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/assignees/%s', delete $args{user}, delete $args{repo}, delete $args{assignee} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/assignees', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Assignees - Github v3 Issue Assignees API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 check
  
  =over
  
  =item *
  
  You may also check to see if a particular user is an assignee for a repository.
  
      GET /repos/:user/:repo/assignees/:assignee
  
  If the given assignee login belongs to an assignee for the repository, a 204
  header with no content is returned.
  
  Examples:
  
      my $c      = Pithub::Issues::Assignees->new;
      my $result = $c->check(
          repo     => 'Pithub',
          user     => 'plu',
          assignee => 'plu',
      );
      if ( $result->success ) {
          print "plu is an assignee for the repo plu/Pithub.git";
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  This call lists all the available assignees (owner + collaborators)
  to which issues may be assigned.
  
      GET /repos/:user/:repo/assignees
  
  Examples:
  
      my $c      = Pithub::Issues::Assignees->new;
      my $result = $c->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_ASSIGNEES

$fatpacked{"Pithub/Issues/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_COMMENTS';
  package Pithub::Issues::Comments;
  $Pithub::Issues::Comments::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Issue Comments API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/issues/%s/comments', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/issues/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/%s/comments', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/issues/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Comments - Github v3 Issue Comments API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a comment
  
      POST /repos/:user/:repo/issues/:id/comments
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->create(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          data     => { body => 'some comment' }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a comment
  
      DELETE /repos/:user/:repo/issues/comments/:id
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->delete(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single comment
  
      GET /repos/:user/:repo/issues/comments/:id
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->get(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List comments on an issue
  
      GET /repos/:user/:repo/issues/:id/comments
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->list(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a comment
  
      PATCH /repos/:user/:repo/issues/comments/:id
  
  Examples:
  
      my $c = Pithub::Issues::Comments->new;
      my $result = $c->update(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
          data       => { body => 'some comment' },
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_COMMENTS

$fatpacked{"Pithub/Issues/Events.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_EVENTS';
  package Pithub::Issues::Events;
  $Pithub::Issues::Events::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Issue Events API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: event_id' unless $args{event_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/events/%s', delete $args{user}, delete $args{repo}, delete $args{event_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $issue_id = delete $args{issue_id} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/issues/%s/events', delete $args{user}, delete $args{repo}, $issue_id ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/issues/events', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Events - Github v3 Issue Events API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single event
  
      GET /repos/:user/:repo/issues/events/:id
  
  Examples:
  
      my $e = Pithub::Issues::Events->new;
      my $result = $e->get(
          repo     => 'Pithub',
          user     => 'plu',
          event_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List events for an issue
  
      GET /repos/:user/:repo/issues/:issue_id/events
  
  Examples:
  
      my $e = Pithub::Issues::Events->new;
      my $result = $e->list(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =item *
  
  List events for a repository
  
      GET /repos/:user/:repo/issues/events
  
  Examples:
  
      my $e = Pithub::Issues::Events->new;
      my $result = $e->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_EVENTS

$fatpacked{"Pithub/Issues/Labels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_LABELS';
  package Pithub::Issues::Labels;
  $Pithub::Issues::Labels::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Issue Labels API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub add {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/labels', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: label' unless $args{label};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{label} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: label' unless $args{label};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{label} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $milestone_id = delete $args{milestone_id} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/milestones/%s/labels', delete $args{user}, delete $args{repo}, $milestone_id ),
              %args,
          );
      }
      elsif ( my $issue_id = delete $args{issue_id} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, $issue_id ),
              %args
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/labels', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub remove {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      if ( my $label = delete $args{label} ) {
          return $self->request(
              method => 'DELETE',
              path   => sprintf( '/repos/%s/%s/issues/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{issue_id}, $label ),
              %args,
          );
      }
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub replace {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: issue_id' unless $args{issue_id};
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/repos/%s/%s/issues/%s/labels', delete $args{user}, delete $args{repo}, delete $args{issue_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: label' unless $args{label};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/labels/%s', delete $args{user}, delete $args{repo}, delete $args{label} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Labels - Github v3 Issue Labels API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 add
  
  =over
  
  =item *
  
  Add labels to an issue
  
      POST /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->add(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          data     => ['Label1', 'Label2'],
      );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a label
  
      POST /repos/:user/:repo/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->create(
          repo => 'Pithub',
          user => 'plu',
          data => {
              color => 'FFFFFF',
              name  => 'some label',
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a label
  
      DELETE /repos/:user/:repo/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->delete(
          repo     => 'Pithub',
          user     => 'plu',
          label => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single label
  
      GET /repos/:user/:repo/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->get(
          repo => 'Pithub',
          user => 'plu',
          label => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all labels for this repository
  
      GET /repos/:user/:repo/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->list(
          repo => 'Pithub',
          user => 'plu'
      );
  
  =item *
  
  List labels on an issue
  
      GET /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->list(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =item *
  
  Get labels for every issue in a milestone
  
      GET /repos/:user/:repo/milestones/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->get(
          repo         => 'Pithub',
          user         => 'plu',
          milestone_id => 1
      );
  
  =back
  
  =head2 remove
  
  =over
  
  =item *
  
  Remove a label from an issue
  
      DELETE /repos/:user/:repo/issues/:id/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->delete(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          label => 1,
      );
  
  =item *
  
  Remove all labels from an issue
  
      DELETE /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->delete(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
      );
  
  =back
  
  =head2 replace
  
  =over
  
  =item *
  
  Replace all labels for an issue
  
      PUT /repos/:user/:repo/issues/:id/labels
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->replace(
          repo     => 'Pithub',
          user     => 'plu',
          issue_id => 1,
          data     => [qw(label3 label4)],
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a label
  
      PATCH /repos/:user/:repo/labels/:id
  
  Examples:
  
      my $l = Pithub::Issues::Labels->new;
      my $result = $l->update(
          repo     => 'Pithub',
          user     => 'plu',
          label => 1,
          data     => {
              color => 'FFFFFF',
              name  => 'API',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_LABELS

$fatpacked{"Pithub/Issues/Milestones.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ISSUES_MILESTONES';
  package Pithub::Issues::Milestones;
  $Pithub::Issues::Milestones::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Issue Milestones API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/milestones', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: milestone_id' unless $args{milestone_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/milestones/%s', delete $args{user}, delete $args{repo}, delete $args{milestone_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: milestone_id' unless $args{milestone_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/milestones/%s', delete $args{user}, delete $args{repo}, delete $args{milestone_id} ),
          %args
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/milestones', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: milestone_id' unless $args{milestone_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/milestones/%s', delete $args{user}, delete $args{repo}, delete $args{milestone_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Issues::Milestones - Github v3 Issue Milestones API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a milestone
  
      POST /repos/:user/:repo/milestones
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->create(
          repo => 'Pithub',
          user => 'plu',
          data => {
              description => 'String',
              due_on      => 'Time',
              state       => 'open or closed',
              title       => 'String'
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a milestone
  
      DELETE /repos/:user/:repo/milestones/:id
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->delete(
          repo => 'Pithub',
          user => 'plu',
          milestone_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single milestone
  
      GET /repos/:user/:repo/milestones/:id
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->get(
          repo => 'Pithub',
          user => 'plu',
          milestone_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List milestones for an issue
  
      GET /repos/:user/:repo/milestones
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a milestone
  
      PATCH /repos/:user/:repo/milestones/:id
  
  Examples:
  
      my $m = Pithub::Issues::Milestones->new;
      my $result = $m->update(
          repo => 'Pithub',
          user => 'plu',
          data => {
              description => 'String',
              due_on      => 'Time',
              state       => 'open or closed',
              title       => 'String'
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ISSUES_MILESTONES

$fatpacked{"Pithub/Orgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ORGS';
  package Pithub::Orgs;
  $Pithub::Orgs::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Orgs API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Orgs::Members;
  use Pithub::Orgs::Teams;
  extends 'Pithub::Base';
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s', delete $args{org} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/orgs', $user ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/orgs',
          %args,
      );
  }
  
  
  sub members {
      return shift->_create_instance('Pithub::Orgs::Members', @_);
  }
  
  
  sub teams {
      return shift->_create_instance('Pithub::Orgs::Teams', @_);
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/orgs/%s', delete $args{org} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Orgs - Github v3 Orgs API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 get
  
  =over
  
  =item *
  
  Get an organization
  
      GET /orgs/:org
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->get( org => 'CPAN-API' );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all public organizations for a user.
  
      GET /users/:user/orgs
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->list( user => 'plu' );
  
  =item *
  
  List public and private organizations for the authenticated user.
  
      GET /user/orgs
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->list;
  
  =back
  
  =head2 members
  
  Provides access to L<Pithub::Orgs::Members>.
  
  =head2 teams
  
  Provides access to L<Pithub::Orgs::Teams>.
  
  =head2 update
  
  =over
  
  =item *
  
  Edit an organization
  
      PATCH /orgs/:org
  
  Examples:
  
      my $o = Pithub::Orgs->new;
      my $result = $o->update(
          org  => 'CPAN-API',
          data => {
              billing_email => 'support@github.com',
              blog          => 'https://github.com/blog',
              company       => 'GitHub',
              email         => 'support@github.com',
              location      => 'San Francisco',
              name          => 'github',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ORGS

$fatpacked{"Pithub/Orgs/Members.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ORGS_MEMBERS';
  package Pithub::Orgs::Members;
  $Pithub::Orgs::Members::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Org Members API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub conceal {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/orgs/%s/public_members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/orgs/%s/members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub is_member {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub is_public {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/public_members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/members', delete $args{org} ),
          %args,
      );
  }
  
  
  sub list_public {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/public_members', delete $args{org} ),
          %args,
      );
  }
  
  
  sub publicize {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org'  unless $args{org};
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/orgs/%s/public_members/%s', delete $args{org}, delete $args{user} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Orgs::Members - Github v3 Org Members API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 conceal
  
  =over
  
  =item *
  
  Conceal a user's membership
  
      DELETE /orgs/:org/public_members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->conceal(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Removing a user from this list will remove them from all teams and
  they will no longer have any access to the organization's
  repositories.
  
      DELETE /orgs/:org/members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->delete(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 is_member
  
  =over
  
  =item *
  
  Check if a user is a member of an organization
  
      GET /orgs/:org/members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->is_member(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 is_public
  
  =over
  
  =item *
  
  Get if a user is a public member
  
      GET /orgs/:org/public_members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->is_public(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all users who are members of an organization. A member is a user
  that belongs to at least 1 team in the organization. If the
  authenticated user is also a member of this organization then both
  concealed and public members will be returned. Otherwise only public
  members are returned.
  
      GET /orgs/:org/members
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->list( org => 'CPAN-API' );
  
  =back
  
  =head2 list_public
  
  =over
  
  =item *
  
  Members of an organization can choose to have their membership
  publicized or not.
  
      GET /orgs/:org/public_members
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->list_public( org => 'CPAN-API' );
  
  =back
  
  =head2 publicize
  
  =over
  
  =item *
  
  Publicize a user's membership
  
      PUT /orgs/:org/public_members/:user
  
  Examples:
  
      my $m = Pithub::Orgs::Members->new;
      my $result = $m->publicize(
          org  => 'CPAN-API',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ORGS_MEMBERS

$fatpacked{"Pithub/Orgs/Teams.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_ORGS_TEAMS';
  package Pithub::Orgs::Teams;
  $Pithub::Orgs::Teams::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Org Teams API
  
  use Moo;
  use Carp qw(croak carp);
  extends 'Pithub::Base';
  
  
  sub add_member {
      my ( $self, %args ) = @_;
      carp '"Add team member" API is deprecated. Use add_membership method.';
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/teams/%s/members/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub add_membership {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      croak 'Missing key in parameters: data'    unless $args{data};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/teams/%s/memberships/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub add_repo {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: repo'    unless $args{repo};
      croak 'Missing key in parameters: org'     unless $args{org};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/teams/%s/repos/%s/%s',
              delete $args{team_id},
              delete $args{org},
              delete $args{repo} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => sprintf( '/orgs/%s/teams', delete $args{org} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub has_repo {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: repo'    unless $args{repo};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/repos/%s', delete $args{team_id}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub is_member {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/members/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: org' unless $args{org};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/orgs/%s/teams', delete $args{org} ),
          %args,
      );
  }
  
  
  sub list_members {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/members', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub list_repos {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/teams/%s/repos', delete $args{team_id} ),
          %args,
      );
  }
  
  
  sub remove_member {
      my ( $self, %args ) = @_;
      carp '"Remove team member" API is deprecated. Use remove_membership method.';
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s/members/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub remove_membership {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: user'    unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s/memberships/%s', delete $args{team_id}, delete $args{user} ),
          %args,
      );
  }
  
  
  sub remove_repo {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: repo'    unless $args{repo};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/teams/%s/repos/%s', delete $args{team_id}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: team_id' unless $args{team_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/teams/%s', delete $args{team_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Orgs::Teams - Github v3 Org Teams API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 add_member
  
  =over
  
  The "Add team member" API (described below) is deprecated and is
  scheduled for removal in the next major version of the API. We
  recommend using the Add team membership API instead. It allows
  you to invite new organization members to your teams.
  
  In order to add a user to a team, the authenticated user must have
  'admin' permissions to the team or be an owner of the org that the
  team is associated with.
  
      PUT /teams/:id/members/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->add_member(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 add_membership
  
  =over
  
  If the user is already a member of the team’s organization, this
  endpoint will add the user to the team. In order to add a membership
  between an organization member and a team, the authenticated user
  must be an organization owner or a maintainer of the team.
  
      PUT /teams/:id/memberships/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->add_membership(
          team_id => 1,
          user    => 'plu',
          data    => {
              role => 'member',
          }
      );
  
  =back
  
  =head2 add_repo
  
  =over
  
  In order to add a repo to a team, the authenticated user must be
  an owner of the org that the team is associated with.
  
      PUT /teams/:id/repos/:repo
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->add_repo(
          team_id => 1,
          repo    => 'some_repo',
          org => 'our_organization',
      );
  
  =back
  
  =head2 create
  
  =over
  
  In order to create a team, the authenticated user must be an
  owner of the given organization.
  
      POST /orgs/:org/teams
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->create(
          org  => 'CPAN-API',
          data => {
              name       => 'new team',
              permission => 'push',
              repo_names => ['github/dotfiles']
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  In order to delete a team, the authenticated user must be an owner
  of the org that the team is associated with.
  
      DELETE /teams/:id
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->delete( team_id => 1 );
  
  =back
  
  =head2 get
  
  =over
  
  Get team
  
      GET /teams/:id
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->get( team_id => 1 );
  
  =back
  
  =head2 has_repo
  
  =over
  
  Get team repo
  
      GET /teams/:id/repos/:repo
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->has_repo(
          team_id => 1,
          repo    => 'some_repo',
      );
  
  =back
  
  =head2 is_member
  
  =over
  
  In order to get if a user is a member of a team, the authenticated
  user must be a member of the team.
  
      GET /teams/:id/members/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->is_member(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 list
  
  =over
  
  List teams
  
      GET /orgs/:org/teams
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->list( org => 'CPAN-API' );
  
  =back
  
  =head2 list_members
  
  =over
  
  In order to list members in a team, the authenticated user must be
  a member of the team.
  
      GET /teams/:id/members
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->list_members( team_id => 1 );
  
  =back
  
  =head2 list_repos
  
  =over
  
  List team repos
  
      GET /teams/:id/repos
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->list_repos( team_id => 1 );
  
  =back
  
  =head2 remove_member
  
  =over
  
  The "Remove team member" API (described below) is deprecated and
  is scheduled for removal in the next major version of the API. We
  recommend using the Remove team membership API instead. It allows
  you to remove both active and pending memberships.
  
  In order to remove a user from a team, the authenticated user must
  have 'admin' permissions to the team or be an owner of the org that
  the team is associated with. NOTE: This does not delete the user,
  it just remove them from the team.
  
      DELETE /teams/:id/members/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->remove_member(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 remove_membership
  
  =over
  
  In order to remove a membership between a user and a team,
  the authenticated user must have 'admin' permissions to
  the team or be an owner of the organization that the team
  is associated with. NOTE: This does not delete the user,
  it just removes their membership from the team.
  
      DELETE /teams/:id/memberships/:user
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->remove_membership(
          team_id => 1,
          user    => 'plu',
      );
  
  =back
  
  =head2 remove_repo
  
  =over
  
  In order to remove a repo from a team, the authenticated user must be
  an owner of the org that the team is associated with.
  
      DELETE /teams/:id/repos/:repo
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->remove_repo(
          team_id => 1,
          repo    => 'some_repo',
      );
  
  =back
  
  =head2 update
  
  =over
  
  In order to edit a team, the authenticated user must be an owner
  of the org that the team is associated with.
  
      PATCH /teams/:id
  
  Examples:
  
      my $t = Pithub::Orgs::Teams->new;
      my $result = $t->update(
          team_id => 1,
          data    => {
              name       => 'new team name',
              permission => 'push',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_ORGS_TEAMS

$fatpacked{"Pithub/PullRequests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_PULLREQUESTS';
  package Pithub::PullRequests;
  $Pithub::PullRequests::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Pull Requests API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::PullRequests::Comments;
  extends 'Pithub::Base';
  
  
  sub comments {
      return shift->_create_instance('Pithub::PullRequests::Comments', @_);
  }
  
  
  sub commits {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/commits', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/pulls', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub files {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/files', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub is_merged {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/merge', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub merge {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/repos/%s/%s/pulls/%s/merge', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/pulls/%s', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::PullRequests - Github v3 Pull Requests API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 comments
  
  Provides access to L<Pithub::PullRequests::Comments>.
  
  =head2 commits
  
  =over
  
  =item *
  
  List commits on a pull request
  
      GET /repos/:user/:repo/pulls/:id/commits
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->commits(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1
      );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a pull request
  
      POST /repos/:user/:repo/pulls
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->create(
          user   => 'plu',
          repo => 'Pithub',
          data   => {
              base  => 'master',
              body  => 'Please pull this in!',
              head  => 'octocat:new-feature',
              title => 'Amazing new feature',
          }
      );
  
  =back
  
  =head2 files
  
  =over
  
  =item *
  
  List pull requests files
  
      GET /repos/:user/:repo/pulls/:id/files
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->files(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single pull request
  
      GET /repos/:user/:repo/pulls/:id
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->get(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 is_merged
  
  =over
  
  =item *
  
  Get if a pull request has been merged
  
      GET /repos/:user/:repo/pulls/:id/merge
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->is_merged(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List pull requests
  
      GET /repos/:user/:repo/pulls
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->list(
          user => 'plu',
          repo => 'Pithub'
      );
  
  =back
  
  =head2 merge
  
  =over
  
  =item *
  
  Merge a pull request
  
      PUT /repos/:user/:repo/pulls/:id/merge
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->merge(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update a pull request
  
      PATCH /repos/:user/:repo/pulls/:id
  
  Examples:
  
      my $p = Pithub::PullRequests->new;
      my $result = $p->update(
          user            => 'plu',
          repo            => 'Pithub',
          pull_request_id => 1,
          data            => {
              base  => 'master',
              body  => 'Please pull this in!',
              head  => 'octocat:new-feature',
              title => 'Amazing new feature',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_PULLREQUESTS

$fatpacked{"Pithub/PullRequests/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_PULLREQUESTS_COMMENTS';
  package Pithub::PullRequests::Comments;
  $Pithub::PullRequests::Comments::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Pull Request Comments API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/pulls/%s/comments', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/pulls/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: pull_request_id' unless $args{pull_request_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/pulls/%s/comments', delete $args{user}, delete $args{repo}, delete $args{pull_request_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/pulls/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::PullRequests::Comments - Github v3 Pull Request Comments API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a comment
  
      POST /repos/:user/:repo/pulls/:id/comments
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->create(
          repo            => 'Pithub',
          user            => 'plu',
          pull_request_id => 1,
          data            => {
              body      => 'Nice change',
              commit_id => '6dcb09b5b57875f334f61aebed695e2e4193db5e',
              path      => 'file1.txt',
              position  => 4,
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a comment
  
      DELETE /repos/:user/:repo/pulls/comments/:id
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->delete(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single comment
  
      GET /repos/:user/:repo/pulls/comments/:id
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->get(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List comments on a pull request
  
      GET /repos/:user/:repo/pulls/:id/comments
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->list(
          repo            => 'Pithub',
          user            => 'plu',
          pull_request_id => 1,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a comment
  
      PATCH /repos/:user/:repo/pulls/comments/:id
  
  Examples:
  
      my $c = Pithub::PullRequests::Comments->new;
      my $result = $c->update(
          repo       => 'Pithub',
          user       => 'plu',
          comment_id => 1,
          data       => { body => 'some updated comment' },
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_PULLREQUESTS_COMMENTS

$fatpacked{"Pithub/Repos.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS';
  package Pithub::Repos;
  $Pithub::Repos::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repos API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Repos::Collaborators;
  use Pithub::Repos::Commits;
  use Pithub::Repos::Contents;
  use Pithub::Repos::Downloads;
  use Pithub::Repos::Forks;
  use Pithub::Repos::Hooks;
  use Pithub::Repos::Keys;
  use Pithub::Repos::Releases;
  use Pithub::Repos::Starring;
  use Pithub::Repos::Stats;
  use Pithub::Repos::Statuses;
  use Pithub::Repos::Watching;
  extends 'Pithub::Base';
  
  
  sub branch {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: branch (string)' unless defined $args{branch};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf(
              '/repos/%s/%s/branches/%s', delete $args{user},
                                          delete $args{repo},
                                          delete $args{branch},
          ),
          %args,
      );
  }
  
  
  sub branches {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/branches', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub collaborators {
      return shift->_create_instance('Pithub::Repos::Collaborators', @_);
  }
  
  
  sub commits {
      return shift->_create_instance('Pithub::Repos::Commits', @_);
  }
  
  
  sub contents {
      return shift->_create_instance('Pithub::Repos::Contents', @_);
  }
  
  
  sub contributors {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/contributors', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      if ( my $org = delete $args{org} ) {
          return $self->request(
              method => 'POST',
              path   => sprintf( '/orgs/%s/repos', $org ),
              %args,
          );
      }
      else {
          return $self->request(
              method => 'POST',
              path   => '/user/repos',
              %args,
          );
      }
  }
  
  
  sub delete {
      my( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub downloads {
      return shift->_create_instance('Pithub::Repos::Downloads', @_);
  }
  
  
  sub forks {
      return shift->_create_instance('Pithub::Repos::Forks', @_);
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub hooks {
      return shift->_create_instance('Pithub::Repos::Hooks', @_);
  }
  
  
  sub keys {
      return shift->_create_instance('Pithub::Repos::Keys', @_);
  }
  
  
  sub languages {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/languages', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/repos', $user ),
              %args,
          );
      }
      elsif ( my $org = delete $args{org} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/orgs/%s/repos', $org ),
              %args
          );
      }
      else {
          return $self->request(
              method => 'GET',
              path   => '/user/repos',
              %args,
          );
      }
  }
  
  
  sub releases {
      return shift->_create_instance('Pithub::Repos::Releases', @_);
  }
  
  
  sub starring {
      return shift->_create_instance('Pithub::Repos::Starring', @_);
  }
  
  
  sub stats {
      return shift->_create_instance('Pithub::Repos::Stats', @_);
  }
  
  
  sub statuses {
      return shift->_create_instance('Pithub::Repos::Statuses', @_);
  }
  
  
  sub tags {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/tags', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub teams {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/teams', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub watching {
      return shift->_create_instance('Pithub::Repos::Watching', @_);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos - Github v3 Repos API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 branch
  
  Get information about a single branch.
  
      GET /repos/:owner/:repo/branches/:branch
  
  Example:
  
      my $result = Pithub->new->branch(
          user => 'plu',
          repo => 'Pithub',
          branch => "master"
      );
  
  See also L<branches> to get a list of all branches.
  
  =head2 branches
  
  =over
  
  =item *
  
  List Branches
  
      GET /repos/:user/:repo/branches
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->branches( user => 'plu', repo => 'Pithub' );
  
  See also L<branch> to get information about a single branch.
  
  =back
  
  =head2 collaborators
  
  Provides access to L<Pithub::Repos::Collaborators>.
  
  =head2 commits
  
  Provides access to L<Pithub::Repos::Commits>.
  
  =head2 contents
  
  Provides access to L<Pithub::Repos::Contents>.
  
  =head2 contributors
  
  =over
  
  =item *
  
  List contributors
  
      GET /repos/:user/:repo/contributors
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->contributors( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a new repository for the authenticated user.
  
      POST /user/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->create( data => { name => 'some-repo' } );
  
  =item *
  
  Create a new repository in this organization. The authenticated user
  must be a member of this organization.
  
      POST /orgs/:org/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->create(
          org  => 'CPAN-API',
          data => { name => 'some-repo' }
      );
  
  =back
  
  =head2 delete
  
  Delete a repository.
  
      DELETE /repos/:owner/:repo
  
  =head2 downloads
  
  Provides access to L<Pithub::Repos::Downloads>.
  
  =head2 forks
  
  Provides access to L<Pithub::Repos::Forks>.
  
  =head2 get
  
  =over
  
  =item *
  
  Get a repo
  
      GET /repos/:user/:repo
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->get( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 hooks
  
  Provides access to L<Pithub::Repos::Hooks>.
  
  =head2 keys
  
  Provides access to L<Pithub::Repos::Keys>.
  
  =head2 languages
  
  =over
  
  =item *
  
  List languages
  
      GET /repos/:user/:repo/languages
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->languages( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List repositories for the authenticated user.
  
      GET /user/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->list;
  
  =item *
  
  List public repositories for the specified user.
  
      GET /users/:user/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->list( user => 'plu' );
  
  =item *
  
  List repositories for the specified org.
  
      GET /orgs/:org/repos
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->list( org => 'CPAN-API' );
  
  =back
  
  =head2 releases
  
  Provides access to L<Pithub::Repos::Releases>.
  
  =head2 starring
  
  Provides access to L<Pithub::Repos::Starring>.
  
  =head2 stats
  
  Provide access to L<Pithub::Repos::Stats>.
  
  =head2 statuses
  
  Provide access to L<Pithub::Repos::Statuses>.
  
  =head2 tags
  
  =over
  
  =item *
  
  List Tags
  
      GET /repos/:user/:repo/tags
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->tags( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 teams
  
  =over
  
  =item *
  
  List Teams
  
      GET /repos/:user/:repo/teams
  
  Examples:
  
      my $repos  = Pithub::Repos->new;
      my $result = $repos->teams( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit
  
      PATCH /repos/:user/:repo
  
  Examples:
  
      # update a repo for the authenticated user
      my $repos  = Pithub::Repos->new;
      my $result = $repos->update(
          repo => 'Pithub',
          data => { description => 'Github API v3' },
      );
  
  =back
  
  =head2 watching
  
  Provides access to L<Pithub::Repos::Watching>.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS

$fatpacked{"Pithub/Repos/Collaborators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_COLLABORATORS';
  package Pithub::Repos::Collaborators;
  $Pithub::Repos::Collaborators::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Collaborators API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub add {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: collaborator' unless $args{collaborator};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/repos/%s/%s/collaborators/%s', delete $args{user}, delete $args{repo}, delete $args{collaborator} ),
          %args,
      );
  }
  
  
  sub is_collaborator {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: collaborator' unless $args{collaborator};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/collaborators/%s', delete $args{user}, delete $args{repo}, delete $args{collaborator} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/collaborators', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub remove {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: collaborator' unless $args{collaborator};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/collaborators/%s', delete $args{user}, delete $args{repo}, delete $args{collaborator} ),
          %args
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Collaborators - Github v3 Repo Collaborators API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 add
  
  =over
  
  =item *
  
  Add collaborator
  
      PUT /repos/:user/:repo/collaborators/:user
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->add(
          user         => 'plu',
          repo         => 'Pithub',
          collaborator => 'rbo',
      );
  
  =back
  
  =head2 is_collaborator
  
  =over
  
  =item *
  
  Get
  
      GET /repos/:user/:repo/collaborators/:user
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->is_collaborator(
          user         => 'plu',
          repo         => 'Pithub',
          collaborator => 'rbo',
      );
  
      if ( $result->is_success ) {
          print "rbo is added as collaborator to Pithub\n";
      }
      elsif ( $result->code == 404 ) {
          print "rbo is not added as collaborator to Pithub\n";
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List
  
      GET /repos/:user/:repo/collaborators
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 remove
  
  =over
  
  =item *
  
  Remove collaborator
  
      DELETE /repos/:user/:repo/collaborators/:user
  
  Examples:
  
      my $c = Pithub::Repos::Collaborators->new;
      my $result = $c->remove(
          user         => 'plu',
          repo         => 'Pithub',
          collaborator => 'rbo',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_COLLABORATORS

$fatpacked{"Pithub/Repos/Commits.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_COMMITS';
  package Pithub::Repos::Commits;
  $Pithub::Repos::Commits::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Commits API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub compare {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: base' unless $args{base};
      croak 'Missing key in parameters: head' unless $args{head};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/compare/%s...%s', delete $args{user}, delete $args{repo}, delete $args{base}, delete $args{head} ),
          %args,
      );
  }
  
  
  sub create_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/commits/%s/comments', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  
  sub delete_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: sha' unless $args{sha};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/commits/%s', delete $args{user}, delete $args{repo}, delete $args{sha} ),
          %args,
      );
  }
  
  
  sub get_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/commits', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list_comments {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $sha = delete $args{sha} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/commits/%s/comments', delete $args{user}, delete $args{repo}, $sha ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/comments', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update_comment {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: comment_id' unless $args{comment_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/comments/%s', delete $args{user}, delete $args{repo}, delete $args{comment_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Commits - Github v3 Repo Commits API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 compare
  
  =over
  
  =item *
  
  Compare two commits
  
      GET /repos/:user/:repo/compare/:base...:head
  
  Examples:
  
      my $c      = Pithub::Repos::Commits->new;
      my $result = $c->compare(
          user => 'plu',
          repo => 'Pithub',
          base => 'v0.01008,
          head => ' master ',
      );
  
  =back
  
  =head2 create_comment
  
  =over
  
  =item *
  
  Create a commit comment
  
      POST /repos/:user/:repo/commits/:sha/comments
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->create_comment(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
          data => { body => 'some comment' },
      );
  
  =back
  
  =head2 delete_comment
  
  =over
  
  =item *
  
  Delete a commit comment
  
      DELETE /repos/:user/:repo/comments/:id
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->delete_comment(
          user       => 'plu',
          repo       => 'Pithub',
          comment_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single commit
  
      GET /repos/:user/:repo/commits/:sha
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->get(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
      );
  
  =back
  
  =head2 get_comment
  
  =over
  
  =item *
  
  Get a single commit comment
  
      GET /repos/:user/:repo/comments/:id
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->get_comment(
          user       => 'plu',
          repo       => 'Pithub',
          comment_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List commits on a repository
  
      GET /repos/:user/:repo/commits
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 list_comments
  
  =over
  
  =item *
  
  List commit comments for a repository
  
  Commit Comments leverage these custom mime types. You can read more
  about the use of mimes types in the API here. See also:
  L<http://developer.github.com/v3/mimes/>.
  
      GET /repos/:user/:repo/comments
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->list_comments(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =item *
  
  List comments for a single commit
  
      GET /repos/:user/:repo/commits/:sha/comments
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->list_comments(
          user => 'plu',
          repo => 'Pithub',
          sha  => 'df21b2660fb6',
      );
  
  =back
  
  =head2 update_comment
  
  =over
  
  =item *
  
  Update a commit comment
  
      PATCH /repos/:user/:repo/comments/:id
  
  Examples:
  
      my $c = Pithub::Repos::Commits->new;
      my $result = $c->update_comment(
          user       => 'plu',
          repo       => 'Pithub',
          comment_id => 1,
          data       => { body => 'updated comment' },
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_COMMITS

$fatpacked{"Pithub/Repos/Contents.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_CONTENTS';
  package Pithub::Repos::Contents;
  $Pithub::Repos::Contents::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Contents API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub archive {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: archive_format' unless $args{archive_format};
      croak 'Invalid archive_format. Valid formats: tarball, zipball' unless grep $args{archive_format} eq $_, qw(tarball zipball);
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/%s/%s', delete $args{user}, delete $args{repo}, delete $args{archive_format}, delete $args{ref} || '' ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $path = delete $args{path} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/repos/%s/%s/contents/%s', delete $args{user}, delete $args{repo}, $path ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/contents', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub readme {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/readme', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Contents - Github v3 Repo Contents API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 archive
  
  =over
  
  =item *
  
  This method will return a C<< 302 >> to a URL to download a tarball
  or zipball archive for a repository.
  
  Note: For private repositories, these links are temporary and expire
  quickly.
  
      GET /repos/:user/:repo/:archive_format/:ref
  
  The C<< ref >> parameter is optional and will default to
  C<< master >>.
  
  Examples:
  
      use Path::Tiny;
  
      my $c = Pithub::Repos::Contents->new(
          repo => 'Pithub',
          user => 'plu'
      );
  
      my $result = $c->archive( archive_format => 'tarball' );
      if ( $result->success ) {
          path('Pithub-master.tgz')->spew($result->raw_content);
      }
  
      $result = $c->archive( archive_format => 'tarball', ref => 'other_branch' );
      if ( $result->success ) {
          path('Pithub-other_branch.tgz')->spew($result->raw_content);
      }
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  This method returns the contents of any file or directory in a
  repository.
  
      GET /repos/:user/:repo/contents/:path
  
  Optional Parameters:
  
  =over
  
  =item *
  
  B<ref>: Optional string - The String name of the
  Commit/Branch/Tag. Defaults to C<< master >>.
  
  =back
  
  Examples:
  
      my $c = Pithub::Repos::Contents->new(
          repo => 'Pithub',
          user => 'plu'
      );
  
      # List all files/directories in the repo root
      my $result = $c->get;
      if ( $result->success ) {
          say $_->{name} for @{ $result->content };
      }
  
      # Get the Pithub.pm file
      $result = $c->get( path => 'lib/Pithub.pm' );
      print Dumper $result->content if $result->success;
  
  =back
  
  =head2 readme
  
  =over
  
  =item *
  
  This method returns the preferred README for a repository.
  
      GET /repos/:user/:repo/readme
  
  Optional Parameters:
  
  =over
  
  =item *
  
  B<ref>: Optional string - The String name of the
  Commit/Branch/Tag. Defaults to C<< master >>.
  
  =back
  
  Examples:
  
      my $c = Pithub::Repos::Contents->new(
          repo => 'dotfiles',
          user => 'plu'
      );
  
      my $result = $c->readme;
      if ( $result->success ) {
          print Dumper $result->content;
      }
  
      # Get the readme of branch 'other_branch'
      $result = $c->readme( params => { ref => 'other_branch' } );
      print Dumper $result->content if $result->success;
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_CONTENTS

$fatpacked{"Pithub/Repos/Downloads.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_DOWNLOADS';
  package Pithub::Repos::Downloads;
  $Pithub::Repos::Downloads::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Downloads API
  
  use Moo;
  use Carp qw(croak);
  use HTTP::Request::Common qw(POST);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/downloads', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: download_id' unless $args{download_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/downloads/%s', delete $args{user}, delete $args{repo}, delete $args{download_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: download_id' unless $args{download_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/downloads/%s', delete $args{user}, delete $args{repo}, delete $args{download_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/downloads', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub upload {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: result (Pithub::Result object)' unless ref $args{result} eq 'Pithub::Result';
      croak 'Missing key in parameters: file' unless $args{file};
      my $result = $args{result}->content;
      foreach my $key (qw(path acl name accesskeyid policy signature mime_type)) {
          croak "Missing key in Pithub::Result content: ${key}" unless grep $_ eq $key, keys %$result;
      }
      my %data = (
          Content_Type => 'form-data',
          Content      => [
              'key'                   => $result->{path},
              'acl'                   => $result->{acl},
              'success_action_status' => 201,
              'Filename'              => $result->{name},
              'AWSAccessKeyId'        => $result->{accesskeyid},
              'Policy'                => $result->{policy},
              'Signature'             => $result->{signature},
              'Content-Type'          => $result->{mime_type},
              'file'                  => [ $args{file} ],
          ],
      );
      my $request = POST $result->{s3_url}, %data;
      return $self->ua->request($request);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Downloads - Github v3 Repo Downloads API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Creating a new download is a two step process. You must first
  create a new download resource using this call here. After
  that you take the return L<Pithub::Result> object and call
  L</upload> to upload the file to Amazon S3.
  
      POST /repos/:user/:repo/downloads
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              name         => 'new_file.jpg',
              size         => 114034,
              description  => 'Latest release',
              content_type => 'text/plain',
          },
      );
  
      $d->upload(
          result => $result,
          file   => '/path/to/file',
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a download
  
      DELETE /repos/:user/:repo/downloads/:id
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->delete(
          user        => 'plu',
          repo        => 'Pithub',
          download_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single download
  
      GET /repos/:user/:repo/downloads/:id
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->get(
          user        => 'plu',
          repo        => 'Pithub',
          download_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List downloads for a repository
  
      GET /repos/:user/:repo/downloads
  
  Examples:
  
      my $d = Pithub::Repos::Downloads->new;
      my $result = $d->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 upload
  
  =over
  
  =item *
  
  Upload a file to Amazon S3. See also: L</create>. This will use
  the C<< ua >> attribute's C<< request >> method to do a POST
  request to Amazon S3. It requires the L<Pithub::Result> object
  of a L</create> call to get the necessary data for S3 API call.
  This method returns an L<HTTP::Response> object directly, not
  a L<Pithub::Result> object (like all other methods do)! If the
  upload was successful the status will be C<< 201 >>.
  
  =back
  
  =head1 NOTE
  
  Github says: The Downloads API (described below) was deprecated on
  December 11, 2012. It will be removed at a future date. We recommend
  using L<Pithub::Repos::Releases> instead.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_DOWNLOADS

$fatpacked{"Pithub/Repos/Forks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_FORKS';
  package Pithub::Repos::Forks;
  $Pithub::Repos::Forks::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Forks API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      if ( my $org = delete $args{org} ) {
          return $self->request(
              method => 'POST',
              path   => sprintf( '/repos/%s/%s/forks', delete $args{user}, delete $args{repo} ),
              data => { organization => $org },
              %args,
          );
      }
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/forks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/forks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Forks - Github v3 Repo Forks API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a fork for the authenicated user.
  
      POST /repos/:user/:repo/forks
  
  Examples:
  
      my $f = Pithub::Repos::Forks->new;
      my $result = $f->create(
          user => 'plu',
          repo => 'Pithub',
      );
  
      # or fork to an org
      my $result = $f->create(
          user => 'plu',
          repo => 'Pithub',
          org  => 'CPAN-API',
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List forks
  
      GET /repos/:user/:repo/forks
  
  Examples:
  
      my $f = Pithub::Repos::Forks->new;
      my $result = $f->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_FORKS

$fatpacked{"Pithub/Repos/Hooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_HOOKS';
  package Pithub::Repos::Hooks;
  $Pithub::Repos::Hooks::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Hooks API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/hooks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/hooks/%d', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/hooks/%d', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/hooks', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub test {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/hooks/%d/test', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: hook_id' unless $args{hook_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/hooks/%d', delete $args{user}, delete $args{repo}, delete $args{hook_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Hooks - Github v3 Repo Hooks API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a hook
  
      POST /repos/:user/:repo/hooks
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              name   => 'irc',
              active => 1,
              config => {
                  server => 'irc.perl.org',
                  port   => 6667,
                  room   => 'pithub',
              },
          },
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a hook
  
      DELETE /repos/:user/:repo/hooks/:id
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->delete(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get single hook
  
      GET /repos/:user/:repo/hooks/:id
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->get(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List Hooks
  
      GET /repos/:user/:repo/hooks
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->tags( user => 'plu', repo => 'Pithub' );
  
  =back
  
  =head2 test
  
  =over
  
  =item *
  
  Get single hook
  
      POST /repos/:user/:repo/hooks/:id/test
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->test(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Update/edit a hook
  
      PATCH /repos/:user/:repo/hooks/:id
  
  Examples:
  
      my $hooks  = Pithub::Repos::Hooks->new;
      my $result = $hooks->update(
          user    => 'plu',
          repo    => 'Pithub',
          hook_id => 5,
          data    => {
              name   => 'irc',
              active => 1,
              config => {
                  server => 'irc.freenode.net',
                  port   => 6667,
                  room   => 'pithub',
              },
          },
      );
  
  =back
  
  =head1 EVENTS
  
  Active hooks can be configured to trigger for one or more events.
  The default event is push. The available events are:
  
  =over
  
  =item *
  
  commit_comment - Any time a Commit is commented on.
  
  =item *
  
  download - Any time a Download is added to the Repository.
  
  =item *
  
  fork - Any time a Repository is forked.
  
  =item *
  
  fork_apply - Any time a patch is applied to the Repository from
  the Fork Queue.
  
  =item *
  
  gollum - Any time a Wiki page is updated.
  
  =item *
  
  issues - Any time an Issue is opened or closed.
  
  =item *
  
  issue_comment - Any time an Issue is commented on.
  
  =item *
  
  member - Any time a User is added as a collaborator to a
  non-Organization Repository.
  
  =item *
  
  public - Any time a Repository changes from private to public.
  
  =item *
  
  pull_request - Any time a Pull Request is opend, closed, or
  synchronized (updated due to a new push in the branch that
  the pull request is tracking).
  
  =item *
  
  push - Any git push to a Repository.
  
  =item *
  
  watch - Any time a User watches the Repository.
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_HOOKS

$fatpacked{"Pithub/Repos/Keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_KEYS';
  package Pithub::Repos::Keys;
  $Pithub::Repos::Keys::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Keys API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/keys', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/keys/%s', delete $args{user}, delete $args{repo}, delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/keys/%s', delete $args{user}, delete $args{repo}, delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/keys', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Keys - Github v3 Repo Keys API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create
  
      POST /repos/:user/:repo/keys
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              title => 'some key',
              key   => 'ssh-rsa AAA...',
          },
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete
  
      DELETE /repos/:user/:repo/keys/:id
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->delete(
          user   => 'plu',
          repo   => 'Pithub',
          key_id => 1,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get
  
      GET /repos/:user/:repo/keys/:id
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->get(
          user   => 'plu',
          repo   => 'Pithub',
          key_id => 1,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List
  
      GET /repos/:user/:repo/keys
  
  Examples:
  
      my $k = Pithub::Repos::Keys->new;
      my $result = $k->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_KEYS

$fatpacked{"Pithub/Repos/Releases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_RELEASES';
  package Pithub::Repos::Releases;
  $Pithub::Repos::Releases::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Releases API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Repos::Releases::Assets;
  extends 'Pithub::Base';
  
  
  sub assets {
      return shift->_create_instance('Pithub::Repos::Releases::Assets', @_);
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases/%d', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'POST',
          path   => sprintf( '/repos/%s/%s/releases', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PATCH',
          path   => sprintf( '/repos/%s/%s/releases/%d', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/releases/%d', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Releases - Github v3 Repo Releases API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 assets
  
  Provides access to L<Pithub::Repos::Releases::Assets>.
  
  =head2 list
  
  =over
  
  =item *
  
  List releases for a repository.
  
      GET /repos/:owner/:repo/releases
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->get(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single release.
  
      GET /repos/:owner/:repo/releases/:id
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->get(
          repo       => 'Pithub',
          user       => 'plu',
          release_id => 1,
      );
  
  =back
  
  =head2 create
  
  =over
  
  =item *
  
  Create a release.
  
      POST /repos/:user/:repo/releases
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->create(
          user => 'plu',
          repo => 'Pithub',
          data => {
              tag_name         => 'v1.0.0',
              target_commitish => 'master',
              name             => 'v1.0.0',
              body             => 'Description of the release',
              draft            => 0,
              prerelease       => 0,
          }
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a release.
  
      PATCH /repos/:user/:repo/releases/:id
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->update(
          user       => 'plu',
          repo       => 'Pithub',
          release_id => 1,
          data       => {
              tag_name         => 'v1.0.0',
              target_commitish => 'master',
              name             => 'v1.0.0',
              body             => 'Description of the release',
              draft            => 0,
              prerelease       => 0,
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a release.
  
      DELETE /repos/:user/:repo/releases:id
  
  Examples:
  
      my $r = Pithub::Repos::Releases->new;
      my $result = $r->delete(
          user       => 'plu',
          repo       => 'Pithub',
          release_id => 1,
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_RELEASES

$fatpacked{"Pithub/Repos/Releases/Assets.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_RELEASES_ASSETS';
  package Pithub::Repos::Releases::Assets;
  $Pithub::Repos::Releases::Assets::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Releases Assets API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: name' unless $args{name};
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      croak 'Missing key in parameters: data' unless $args{data};
      croak 'Missing key in parameters: content_type' unless $args{content_type};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method  => 'POST',
          path    => sprintf( '/repos/%s/%s/releases/%s/assets', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          host    => 'uploads.github.com',
          query   => { name => delete $args{name} },
          headers => {
              'Content-Type' => delete $args{content_type},
          },
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: asset_id' unless $args{asset_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/repos/%s/%s/releases/assets/%s', delete $args{user}, delete $args{repo}, delete $args{asset_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: asset_id' unless $args{asset_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases/assets/%s', delete $args{user}, delete $args{repo}, delete $args{asset_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: release_id' unless $args{release_id};
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/releases/%s/assets', delete $args{user}, delete $args{repo}, delete $args{release_id} ),
          %args,
      );
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: asset_id' unless $args{asset_id};
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method  => 'PATCH',
          path    => sprintf( '/repos/%s/%s/releases/assets/%s', delete $args{user}, delete $args{repo}, delete $args{asset_id} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Releases::Assets - Github v3 Repo Releases Assets API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Upload a release asset.
  
      POST https://uploads.github.com/repos/:owner/:repo/releases/:id/assets?name=foo.zip
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->create(
          repo         => 'graylog2-server',
          user         => 'Graylog2',
          release_id   => 81148,
          name         => 'Some Asset',
          data         => 'the asset data',
          content_type => 'text/plain',
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a release asset.
  
      DELETE /repos/:owner/:repo/releases/assets/:id
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->delete(
          repo     => 'graylog2-server',
          user     => 'Graylog2',
          asset_id => 81148,
      );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single release asset.
  
      GET /repos/:owner/:repo/releases/assets/:id
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->get(
          repo     => 'graylog2-server',
          user     => 'Graylog2',
          asset_id => 81148,
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List assets for a release.
  
      GET /repos/:owner/:repo/releases/:id/assets
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->list(
          repo       => 'graylog2-server',
          user       => 'Graylog2',
          release_id => 198110,
      );
  
  =back
  
  =head2 update
  
  =over
  
  =item *
  
  Edit a release asset.
  
      PATCH /repos/:owner/:repo/releases/assets/:id
  
  Examples:
  
      my $a = Pithub::Repos::Releases::Assets->new;
      my $result = $a->update(
          repo     => 'graylog2-server',
          user     => 'Graylog2',
          asset_id => 81148,
          data     => {
              name  => 'Some Name',
              label => 'Some Label',
          }
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_RELEASES_ASSETS

$fatpacked{"Pithub/Repos/Starring.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_STARRING';
  package Pithub::Repos::Starring;
  $Pithub::Repos::Starring::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Starring API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub has_starred {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/starred/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/stargazers', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list_repos {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/starred', $user ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/starred',
          %args,
      );
  }
  
  
  sub star {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/user/starred/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub unstar {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/starred/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Starring - Github v3 Repo Starring API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 has_starred
  
  =over
  
  =item *
  
  Check if you are starring a repository.
  
  Requires for the user to be authenticated.
  
      GET /user/starred/:user/:repo
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->has_starred(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List all stargazers of a repository
  
      GET /repos/:user/:repo/stargazers
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->list(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 list_repos
  
  =over
  
  =item *
  
  List repositories being starred by a user.
  
      GET /users/:user/starred
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->list_repos(
          user => 'plu',
      );
  
  =item *
  
  List repos being starred by the authenticated user
  
      GET /user/starred
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->list_repos;
  
  =back
  
  =head2 star
  
  =over
  
  =item *
  
  Star a repository.
  
  Requires for the user to be authenticated.
  
      PUT /user/starred/:user/:repo
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->star(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 unstar
  
  =over
  
  =item *
  
  Unstar a repository.
  
  Requires for the user to be authenticated.
  
      DELETE /user/starred/:user/:repo
  
  Examples:
  
      my $s = Pithub::Repos::Starring->new;
      my $result = $s->unstar(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_STARRING

$fatpacked{"Pithub/Repos/Stats.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_STATS';
  package Pithub::Repos::Stats;
  $Pithub::Repos::Stats::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 repos / stats API
  
  use Moo;
  
  extends 'Pithub::Base';
  
  
  sub contributors {
      my ( $self, %args ) = @_;
      # The default is to not wait for 200
      my $sleep = delete $args{wait_for_200} || 0;
      $self->_validate_user_repo_args( \%args );
      my $req = {
          method => 'GET',
          path => sprintf(
              '/repos/%s/%s/stats/contributors',
              delete $args{user}, delete $args{repo}
          ),
          %args
      };
      my $res = $self->request(
          %$req
      );
  
      if ($sleep) {
          while ($res->response->code == 202) {
              sleep $sleep;
              $res = $self->request(%$req);
          }
      }
      return $res;
  }
  
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Stats - Github v3 repos / stats API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 contributors
  
  Extra arguments
  
  =over
  
  =item * wait_for_200
  
  If this is set, and we receive the 202 status from github, we will sleep for
  this many seconds before trying the request again. We will keep trying until we
  get anything else than 202 status
  
  =back
  
  List contributors with stats
  
      GET /repos/:user/:repo/stats/contributors
  
  Examples:
  
      my $repos  = Pithub::Repos::Stats->new;
      my $result = $repos->contributors( user => 'plu', repo => 'Pithub' );
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_STATS

$fatpacked{"Pithub/Repos/Statuses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_STATUSES';
  package Pithub::Repos::Statuses;
  $Pithub::Repos::Statuses::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT:  Github v3 repos / statuses API
  
  use Moo;
  use Carp qw(croak);
  
  extends 'Pithub::Base';
  
  
  sub list {
      my ($self, %args) = @_;
  
      $self->_validate_user_repo_args( \%args );
      my $req = {
          method => 'GET',
          path => sprintf(
              '/repos/%s/%s/statuses/%s',
              delete $args{user}, delete $args{repo}, delete $args{ref}
          ),
          %args
      };
      return $self->request(%$req);
  }
  
  
  sub create {
      my ($self, %args) = @_;
      $self->_validate_user_repo_args( \%args );
      croak 'Missing state paramenter. Must be one of pending, success, error or failure'
          unless $args{data}->{state};
  
      unless ($args{data}->{state} =~ m/^(?:pending|success|error|failure)$/) {
          croak 'state param must be one of pending, success, error, failure. Was ' .
          $args{data}->{state};
      }
  
      my $req = {
          method => 'POST',
          path => sprintf(
              '/repos/%s/%s/statuses/%s',
              delete $args{user}, delete $args{repo}, delete $args{sha},
          ),
          %args
      };
  
      return $self->request(%$req);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Statuses - Github v3 repos / statuses API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 list
  
  Extra arguments
  
  =over
  
  =item * ref
  
  The SHA, branch, or tag-name to get statuses for
  
  =back
  
  List statuses for a ref
  
      GET /repos/:user/:repo/statuses/:ref
  
  Examples:
  
      my $statuses = Pithub::Repos::Statuses->new;
      my $result   = $statuses->list( ref => 'master' );
  
  =head2 create
  
  Extra arguments
  
  =over
  
  =item state (required)
  
  The state of the status. Can be one of 'pending', 'success', 'error' or 'failure'.
  
  =item target_url
  
  This URL will be used to link from the status to some related page, for instance
  the build result for this specific SHA.
  
  =item description
  
  A short description of the status
  
  =back
  
  Add a status to a SHA.
  
      POST /repos/:user/:repo/statuses/:sha
  
  Examples:
  
      my $statuses = Pithub::Repos::Statuses->new;
      my $result   = $statuses->create( user => 'plu', repo => 'Pithub',
          sha => '0123456', 
          data => {
              state => 'error',
              description => 'Build failed',
              target_url => 'https://travis-ci.org/some/url/0123456',
          },
      );
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_STATUSES

$fatpacked{"Pithub/Repos/Watching.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_REPOS_WATCHING';
  package Pithub::Repos::Watching;
  $Pithub::Repos::Watching::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Repo Watching API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub is_watching {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/watched/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub list_repos {
      my ( $self, %args ) = @_;
      if ( my $user = delete $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/watched', $user ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/watched',
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'GET',
          path   => sprintf( '/repos/%s/%s/watchers', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub start_watching {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/user/watched/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  
  sub stop_watching {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/watched/%s/%s', delete $args{user}, delete $args{repo} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Repos::Watching - Github v3 Repo Watching API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 is_watching
  
  =over
  
  =item *
  
  Check if you are watching a repo
  
      GET /user/watched/:user/:repo
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->is_watching(
          repo => 'Pithub',
          user => 'plu',
      );
  
  =back
  
  =head2 list_repos
  
  =over
  
  =item *
  
  List repos being watched by a user
  
      GET /users/:user/watched
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->list_repos( user => 'plu' );
  
  =item *
  
  List repos being watched by the authenticated user
  
      GET /user/watched
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->list_repos;
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List watchers
  
      GET /repos/:user/:repo/watchers
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->list(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 start_watching
  
  =over
  
  =item *
  
  Watch a repo
  
      PUT /user/watched/:user/:repo
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->start_watching(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head2 stop_watching
  
  =over
  
  =item *
  
  Stop watching a repo
  
      DELETE /user/watched/:user/:repo
  
  Examples:
  
      my $w = Pithub::Repos::Watching->new;
      my $result = $w->stop_watching(
          user => 'plu',
          repo => 'Pithub',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_REPOS_WATCHING

$fatpacked{"Pithub/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_RESULT';
  package Pithub::Result;
  $Pithub::Result::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 result object
  
  use Moo;
  use Array::Iterator;
  use JSON::MaybeXS;
  use URI;
  use Carp;
  
  sub _isa_isa_maker {
      my $class = shift;
      return sub {
          confess "must be an instance of $class but isn't a reference" if !ref $_[0];
          confess "must be an instance of $class, but is a ".ref $_[0]
            unless eval { $_[0]->isa($class) };
      };
  }
  
  
  has 'auto_pagination' => (
      default => sub { 0 },
      is      => 'rw',
  );
  
  
  has 'content' => (
      builder => '_build_content',
      clearer => 'clear_content',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'first_page_uri' => (
      builder => '_build_first_page_uri',
      clearer => 'clear_first_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'last_page_uri' => (
      builder => '_build_last_page_uri',
      clearer => 'clear_last_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'next_page_uri' => (
      builder => '_build_next_page_uri',
      clearer => 'clear_next_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'prev_page_uri' => (
      builder => '_build_prev_page_uri',
      clearer => 'clear_prev_page_uri',
      is      => 'ro',
      lazy    => 1,
  );
  
  
  has 'response' => (
      handles => {
          code        => 'code',
          raw_content => 'content',
          request     => 'request',
          success     => 'is_success',
      },
      is       => 'ro',
      isa      => _isa_isa_maker('HTTP::Response'),
      required => 1,
  );
  
  
  # required for next_page etc
  has '_request' => (
      is       => 'ro',
      isa      => sub {
          croak 'must be a coderef, but is ' . ref $_[0] unless ref $_[0] eq 'CODE'
      },
      required => 1,
  );
  
  # required for next
  has '_iterator' => (
      builder => '_build__iterator',
      clearer => '_clear_iterator',
      is      => 'ro',
      isa     => _isa_isa_maker('Array::Iterator'),
      lazy    => 1,
  );
  
  has '_json' => (
      builder => '_build__json',
      is      => 'ro',
      isa     => sub {
          confess "$_[0] is not a suitable JSON object"
            unless eval { $_[0]->can("decode") };
      },
      lazy    => 1,
  );
  
  
  sub count {
      my ($self) = @_;
      return 0 unless $self->success;
      my $content = $self->content;
      if ( ref $content eq 'HASH' && scalar keys %$content == 0 ) {
          return 0;
      }
      return $self->_iterator->getLength;
  }
  
  
  sub first {
      my ($self) = @_;
      my $content = $self->content;
      if ( ref $content eq 'ARRAY' ) {
          return $content->[0];
      }
      return $content;
  }
  
  
  sub first_page {
      my ($self) = @_;
      return unless $self->first_page_uri;
      return $self->_paginate( $self->first_page_uri );
  }
  
  
  sub get_page {
      my ( $self, $page ) = @_;
  
      # First we need to get an URI we can work with and replace
      # the page GET parameter properly with the given value. If
      # we cannot get the first or last page URI, then there is
      # only one page.
      my $uri_str = $self->first_page_uri || $self->last_page_uri;
      return unless $uri_str;
  
      my $uri   = URI->new($uri_str);
      my %query = $uri->query_form;
  
      $query{page} = $page;
  
      my $options = {
          prepare_request => sub {
              my ($request) = @_;
              %query = ( $request->uri->query_form, %query );
              $request->uri->query_form(%query);
          },
      };
  
      return $self->_request->(
          method  => 'GET',
          path    => $uri->path,
          options => $options,
      );
  }
  
  
  sub last_page {
      my ($self) = @_;
      return unless $self->last_page_uri;
      return $self->_paginate( $self->last_page_uri );
  }
  
  
  sub next {
      my ($self) = @_;
      my $row = $self->_iterator->getNext;
      return $row if $row;
      if ( $self->auto_pagination ) {
          my $result = $self->next_page;
          return unless $result;
          $self->_reset;
          $self->{response} = $result->response;
          return $self->_iterator->getNext;
      }
      return;
  }
  
  
  sub next_page {
      my ($self) = @_;
      return unless $self->next_page_uri;
      return $self->_paginate( $self->next_page_uri );
  }
  
  
  sub prev_page {
      my ($self) = @_;
      return unless $self->prev_page_uri;
      return $self->_paginate( $self->prev_page_uri );
  }
  
  
  sub etag {
      my ($self) = @_;
      return $self->response->header('ETag');
  }
  
  
  sub ratelimit {
      my ($self) = @_;
      return $self->response->header('X-RateLimit-Limit');
  }
  
  
  sub ratelimit_remaining {
      my ($self) = @_;
      return $self->response->header('X-RateLimit-Remaining');
  }
  
  sub _build_content {
      my ($self) = @_;
      if ( $self->raw_content ) {
          return $self->_json->decode( $self->raw_content );
      }
      return {};
  }
  
  sub _build_first_page_uri {
      return shift->_get_link_header('first');
  }
  
  sub _build__iterator {
      my ($self) = @_;
      my $content = $self->content;
      $content = [$content] unless ref $content eq 'ARRAY';
      return Array::Iterator->new($content);
  }
  
  sub _build_last_page_uri {
      return shift->_get_link_header('last');
  }
  
  sub _build_next_page_uri {
      return shift->_get_link_header('next');
  }
  
  sub _build_prev_page_uri {
      return shift->_get_link_header('prev');
  }
  
  sub _build__json {
      my ($self) = @_;
      return JSON->new->utf8;
  }
  
  sub _get_link_header {
      my ( $self, $type ) = @_;
      return $self->{_get_link_header}{$type} if $self->{_get_link_header}{$type};
      my $link = $self->response->header('Link');
      return unless $link;
      return unless $link =~ /(next|first|last|prev)/;
      foreach my $item ( split /,/, $link ) {
          my @result = $item =~ /<([^>]+)>; rel="([^"]+)"/g;
          next if !$result[1] || !$result[0];
          $self->{_get_link_header}{ $result[1] } = $result[0];
      }
      return $self->{_get_link_header}{$type};
  }
  
  sub _paginate {
      my ( $self, $uri_str ) = @_;
      my $uri     = URI->new($uri_str);
      my $options = {
          prepare_request => sub {
              my ($request) = @_;
              my %query = ( $request->uri->query_form, $uri->query_form );
              $request->uri->query_form(%query);
          },
      };
      return $self->_request->(
          method  => 'GET',
          path    => $uri->path,
          options => $options,
      );
  }
  
  sub _reset {
      my ($self) = @_;
      $self->clear_content;
      $self->clear_first_page_uri;
      $self->clear_last_page_uri;
      $self->clear_next_page_uri;
      $self->clear_prev_page_uri;
      $self->_clear_iterator;
      delete $self->{_get_link_header};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Result - Github v3 result object
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 DESCRIPTION
  
  Every method call which maps directly to a Github API call returns a
  L<Pithub::Result> object. Once you got the result object, you can
  set L<attributes|/ATTRIBUTES> on them or call L<methods|/METHODS>.
  
  =head1 ATTRIBUTES
  
  =head2 auto_pagination
  
  If you set this to true and use the L</next> method to iterate
  over the result rows, it will call automatically L</next_page>
  for you until you got all the results. Be careful using this
  feature, if there are 100 pages, this will make 100 API calls.
  By default it's off. Instead of setting it per L<Pithub::Result>
  you can also set it directly on any of the L<Pithub> API objects.
  
  Examples:
  
      my $r = Pithub::Repos->new;
      my $result = $r->list( user => 'rjbs' );
  
      # This would just show the first 30 by default
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
      # Let's do the same thing using auto_pagination to fetch all
      $result = $r->list( user => 'rjbs' );
      $result->auto_pagination(1);
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
      # Turn auto_pagination on for all L<Pithub::Result> objects
      my $p = Pithub::Repos->new( auto_pagination => 1 );
      my $result = $p->list( user => 'rjbs' );
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
  =head2 content
  
  The decoded JSON response. May be an arrayref or hashref, depending
  on the API call. For some calls there is no content at all.
  
  =head2 first_page_uri
  
  The extracted value from the C<< Link >> header for the first page.
  This can return undef.
  
  =head2 last_page_uri
  
  The extracted value from the C<< Link >> header for the last page.
  This can return undef.
  
  =head2 next_page_uri
  
  The extracted value from the C<< Link >> header for the next page.
  This can return undef.
  
  =head2 prev_page_uri
  
  The extracted value from the C<< Link >> header for the previous
  page. This can return undef.
  
  =head2 response
  
  The L<HTTP::Response> object.
  
  =head1 METHODS
  
  =head2 raw_content
  
  Returns the content of the API response as a string, it will probably
  be JSON.
  
  =head2 request
  
  Returns the L<HTTP::Request> object used to make the API call.
  
  =head2 code
  
  Returns the HTTP code from the API call.
  
  =head2 success
  
  Returns whether the API call was successful.
  
  =head2 count
  
  Returns the count of the elements in L</content>. If the result is
  not an arrayref but a hashref, it will still return C<< 1 >>. Some
  calls return an empty hashref, for those calls it returns C<< 0 >>.
  
  =head2 first
  
  Return the first element from L</content> if L</content> is an
  arrayref. If it's a hashref, it returns just that.
  
  =head2 first_page
  
  Get the L<Pithub::Result> of the first page. Returns undef if there
  is no first page (if you're on the first page already or if there
  is no pages at all).
  
  =head2 get_page
  
  Get the L<Pithub::Result> for a specific page. The parameter is not
  validated, if you hit a page that does not exist, the Github API will
  tell you so. If there is only one page, this method will return
  undef, no matter which page you ask for, even for page 1.
  
  =head2 last_page
  
  Get the L<Pithub::Result> of the last page. Returns undef if there
  is no last page (if you're on the last page already or if there
  is only one page or no pages at all).
  
  =head2 next
  
  Most of the results returned by the Github API calls are arrayrefs
  of hashrefs. The data structures can be retrieved directly by
  calling L</content>. Besides that it's possible to iterate over
  the results using this method.
  
  Examples:
  
      my $r = Pithub::Repos->new;
      my $result = $r->list( user => 'rjbs' );
  
      while ( my $row = $result->next ) {
          printf "%s: %s\n", $row->{name}, $row->{description};
      }
  
  =head2 next_page
  
  Get the L<Pithub::Result> of the next page. Returns undef if there
  is no next page (there's only one page at all).
  
  Examples:
  
  =over
  
  =item *
  
  List all followers in order, from the first one on the first
  page to the last one on the last page. See also
  L</auto_pagination>.
  
      my $followers = Pithub->new->users->followers;
      my $result = $followers->list( user => 'rjbs' );
      do {
          if ( $result->success ) {
              while ( my $row = $result->next ) {
                  printf "%s\n", $row->{login};
              }
          }
      } while $result = $result->next_page;
  
  The nature of the implementation requires you here to do a
  C<< do { ... } while ... >> loop. If you're going to fetch
  all results of all pages, I suggest to use the
  L</auto_pagination> feature, it's much more convenient.
  
  =back
  
  =head2 prev_page
  
  Get the L<Pithub::Result> of the previous page. Returns undef if there
  is no previous page (you're on the first page).
  
  Examples:
  
  =over
  
  =item *
  
  List all followers in reverse order, from the last one on the last
  page to the first one on the first page. See also
  L</auto_pagination>.
  
      my $followers = Pithub->new->users->followers;
      my $result = $followers->list( user => 'rjbs' )->last_page;    # this makes two requests!
      do {
          if ( $result->success ) {
              while ( my $row = $result->next ) {
                  printf "%s\n", $row->{login};
              }
          }
      } while $result = $result->prev_page;
  
  =back
  
  =head2 etag
  
  Returns the value of the C<< ETag >> http header.
  
  =head2 ratelimit
  
  Returns the value of the C<< X-Ratelimit-Limit >> http header.
  
  =head2 ratelimit_remaining
  
  Returns the value of the C<< X-Ratelimit-Remaining >> http header.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_RESULT

$fatpacked{"Pithub/Result/SharedCache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_RESULT_SHAREDCACHE';
  package Pithub::Result::SharedCache;
  $Pithub::Result::SharedCache::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: A role to share the LRU cache with all Pithub objects
  
  use Moo::Role;
  use Cache::LRU;
  
  my $Shared_Cache = Cache::LRU->new(
      size        => 200
  );
  
  
  sub shared_cache {
      return $Shared_Cache;
  }
  
  
  sub set_shared_cache {
      my($self, $cache) = @_;
  
      $Shared_Cache = $cache;
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Result::SharedCache - A role to share the LRU cache with all Pithub objects
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 DESCRIPTION
  
  A role to share the least recently used cache with all Pithub objects.
  
  =head1 METHODS
  
  =head2 shared_cache
  
  Returns the Cache::LRU object shared by all Pithub objects.
  
  =head2 set_shared_cache
  
  Sets the Cache::LRU object shared by all Pithub objects.
  
  This should only be necessary for testing or to change the
  size of the cache.
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_RESULT_SHAREDCACHE

$fatpacked{"Pithub/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_SEARCH';
  package Pithub::Search;
  $Pithub::Search::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github legacy Search API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub email {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: email' unless $args{email};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/user/email/%s', delete $args{email} ),
          %args,
      );
  }
  
  
  sub issues {
      my ( $self, %args ) = @_;
      $self->_validate_user_repo_args( \%args );
      croak 'Missing key in parameters: state' unless $args{state};
      croak 'Missing key in parameters: keyword' unless $args{keyword};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/issues/search/%s/%s/%s/%s', delete $args{user}, delete $args{repo}, delete $args{state}, delete $args{keyword} ),
          %args,
      );
  }
  
  
  sub repos {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: keyword' unless $args{keyword};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/repos/search/%s', delete $args{keyword} ),
          %args,
      );
  }
  
  
  sub users {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: keyword' unless $args{keyword};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/legacy/user/search/%s', delete $args{keyword} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Search - Github legacy Search API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 email
  
  =over
  
  =item *
  
  This API call is added for compatibility reasons only. There's
  no guarantee that full email searches will always be available.
  
      GET /legacy/user/email/:email
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->email(
          email => 'plu@pqpq.de',
      );
  
  =back
  
  =head2 issues
  
  =over
  
  =item *
  
  Find issues by state and keyword.
  
      GET /legacy/issues/search/:owner/:repository/:state/:keyword
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->issues(
          user    => 'plu',
          repo    => 'Pithub',
          state   => 'open',
          keyword => 'some keyword',
      );
  
  =back
  
  =head2 repos
  
  =over
  
  =item *
  
  Find repositories by keyword. Note, this legacy method does not
  follow the v3 pagination pattern. This method returns up to 100
  results per page and pages can be fetched using the start_page
  parameter.
  
      GET /legacy/repos/search/:keyword
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->repos(
          keyword => 'github',
          params  => {
              language   => 'Perl',
              start_page => 0,
          }
      );
  
  =back
  
  =head2 users
  
  =over
  
  =item *
  
  Find users by keyword.
  
      GET /legacy/user/search/:keyword
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->users(
          keyword => 'plu',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_SEARCH

$fatpacked{"Pithub/SearchV3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_SEARCHV3';
  package Pithub::SearchV3;
  $Pithub::SearchV3::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Search API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub issues {
      my $self = shift;
      return $self->_search('issues', @_);
  }
  
  
  sub repos {
      my $self = shift;
      return $self->_search('repositories', @_);
  }
  
  
  sub users {
      my $self = shift;
      return $self->_search('users', @_);
  }
  
  
  sub code {
      my $self = shift;
      return $self->_search('code', @_);
  }
  
  sub _search {
      my ( $self, $thing_to_search, %args ) = @_;
      croak 'Missing key in parameters: q' unless exists $args{q};
      return $self->request(
          method => 'GET',
          path   => '/search/' . $thing_to_search,
          query => {
              q => delete $args{q},
              (exists $args{sort}  ? (sort  => delete $args{sort})  : ()),
              (exists $args{order} ? (order => delete $args{order}) : ()),
          },
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::SearchV3 - Github v3 Search API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 issues
  
  =over
  
  =item *
  
  Find issues by state and keyword.
  
      GET /search/issues
  
  Examples:
  
      my $search = Pithub::Search->new;
      my $result = $search->issues(
          q => 'some keyword',
      );
  
  =back
  
  =head2 repos
  
  =over
  
  =item *
  
  Find repositories by keyword.
  
      GET /search/repositories
  
  Examples:
  
      my $search = Pithub::SearchV3->new;
      my $result = $search->repos(
          q => 'github language:Perl',
      );
  
  =back
  
  =head2 users
  
  =over
  
  =item *
  
  Find users by keyword.
  
      GET /search/users
  
  Examples:
  
      my $search = Pithub::SearchV3->new;
      my $result = $search->users(
          q => 'plu',
      );
  
  =back
  
  =head2 code
  
  =over
  
  =item *
  
  Search code by keyword.
  
      GET /search/code
  
  Examples:
  
      my $search = Pithub::SearchV3->new;
      my $result = $search->code(
          q => 'addClass repo:jquery/jquery',
      );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_SEARCHV3

$fatpacked{"Pithub/Users.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS';
  package Pithub::Users;
  $Pithub::Users::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 Users API
  
  use Moo;
  use Carp qw(croak);
  use Pithub::Users::Emails;
  use Pithub::Users::Followers;
  use Pithub::Users::Keys;
  extends 'Pithub::Base';
  
  
  sub emails {
      return shift->_create_instance('Pithub::Users::Emails', @_);
  }
  
  
  sub followers {
      return shift->_create_instance('Pithub::Users::Followers', @_);
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      if ( $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s', delete $args{user} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user',
          %args,
      );
  }
  
  
  sub keys {
      return shift->_create_instance('Pithub::Users::Keys', @_);
  }
  
  
  sub update {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'PATCH',
          path   => '/user',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users - Github v3 Users API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 emails
  
  Provides access to L<Pithub::Users::Emails>.
  
  =head2 followers
  
  Provides access to L<Pithub::Users::Followers>.
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single user
  
      GET /users/:user
  
  Examples:
  
      my $u = Pithub::Users->new;
      my $result = $u->get( user => 'plu');
  
  =item *
  
  Get the authenticated user
  
      GET /user
  
  Examples:
  
      my $u = Pithub::Users->new( token => 'b3c62c6' );
      my $result = $u->get;
  
  =back
  
  =head2 keys
  
  Provides access to L<Pithub::Users::Keys>.
  
  =head2 update
  
  =over
  
  =item *
  
  Update the authenticated user
  
      PATCH /user
  
  Examples:
  
      my $u = Pithub::Users->new( token => 'b3c62c6' );
      my $result = $u->update( data => { email => 'plu@cpan.org' } );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS

$fatpacked{"Pithub/Users/Emails.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS_EMAILS';
  package Pithub::Users::Emails;
  $Pithub::Users::Emails::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 User Emails API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub add {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      return $self->request(
          method => 'POST',
          path   => '/user/emails',
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (arrayref)' unless ref $args{data} eq 'ARRAY';
      return $self->request(
          method => 'DELETE',
          path   => '/user/emails',
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      return $self->request(
          method => 'GET',
          path   => '/user/emails',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users::Emails - Github v3 User Emails API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 add
  
  =over
  
  =item *
  
  Add email address(es)
  
      POST /user/emails
  
  Examples:
  
      my $e = Pithub::Users::Emails->new( token => 'b3c62c6' );
      my $result = $e->add( data => [ 'plu@cpan.org', 'plu@pqpq.de' ] );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete email address(es)
  
      DELETE /user/emails
  
  Examples:
  
      my $e = Pithub::Users::Emails->new( token => 'b3c62c6' );
      my $result = $e->delete( data => [ 'plu@cpan.org', 'plu@pqpq.de' ] );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List email addresses for a user
  
      GET /user/emails
  
  Examples:
  
      my $e = Pithub::Users::Emails->new( token => 'b3c62c6' );
      my $result = $e->list;
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS_EMAILS

$fatpacked{"Pithub/Users/Followers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS_FOLLOWERS';
  package Pithub::Users::Followers;
  $Pithub::Users::Followers::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 User Followers API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub follow {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'PUT',
          path   => sprintf( '/user/following/%s', delete $args{user} ),
          %args,
      );
  }
  
  
  sub is_following {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/following/%s', delete $args{user} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      if ( $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/followers', delete $args{user} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/followers',
          %args,
      );
  }
  
  
  sub list_following {
      my ( $self, %args ) = @_;
      if ( $args{user} ) {
          return $self->request(
              method => 'GET',
              path   => sprintf( '/users/%s/following', delete $args{user} ),
              %args,
          );
      }
      return $self->request(
          method => 'GET',
          path   => '/user/following',
          %args,
      );
  }
  
  
  sub unfollow {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: user' unless $args{user};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/following/%s', delete $args{user} ),
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users::Followers - Github v3 User Followers API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 follow
  
  =over
  
  =item *
  
  Follow a user
  
      PUT /user/following/:user
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->follow( user => 'plu' );
  
  =back
  
  =head2 is_following
  
  =over
  
  =item *
  
  Check if the authenticated user is following another given user
  
      GET /user/following/:user
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->is_following( user => 'rafl' );
  
      if ( $result->is_success ) {
          print "plu is following rafl\n";
      }
      elsif ( $result->code == 404 ) {
          print "plu is not following rafl\n";
      }
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List a user's followers:
  
      GET /users/:user/followers
  
  Examples:
  
      my $f = Pithub::Users::Followers->new;
      my $result = $f->list( user => 'plu' );
  
  =item *
  
  List the authenticated user's followers:
  
      GET /user/followers
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->list;
  
  =back
  
  =head2 list_following
  
  =over
  
  =item *
  
  List who a user is following:
  
      GET /users/:user/following
  
  Examples:
  
      my $f = Pithub::Users::Followers->new;
      my $result = $f->list_following( user => 'plu' );
  
  =item *
  
  List who the authenicated user is following:
  
      GET /user/following
  
  Examples:
  
      my $f = Pithub::Users::Followers->new( token => 'b3c62c6' );
      my $result = $f->list_following;
  
  =back
  
  =head2 unfollow
  
  =over
  
  =item *
  
  Unfollow a user
  
      DELETE /user/following/:user
  
  Examples:
  
      my $f = Pithub::Users::Followers->new;
      my $result = $f->unfollow( user => 'plu' );
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS_FOLLOWERS

$fatpacked{"Pithub/Users/Keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PITHUB_USERS_KEYS';
  package Pithub::Users::Keys;
  $Pithub::Users::Keys::VERSION = '0.01030';
  our $AUTHORITY = 'cpan:PLU';
  
  # ABSTRACT: Github v3 User Keys API
  
  use Moo;
  use Carp qw(croak);
  extends 'Pithub::Base';
  
  
  sub create {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: data (hashref)' unless ref $args{data} eq 'HASH';
      return $self->request(
          method => 'POST',
          path   => '/user/keys',
          %args,
      );
  }
  
  
  sub delete {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      return $self->request(
          method => 'DELETE',
          path   => sprintf( '/user/keys/%s', delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub get {
      my ( $self, %args ) = @_;
      croak 'Missing key in parameters: key_id' unless $args{key_id};
      return $self->request(
          method => 'GET',
          path   => sprintf( '/user/keys/%s', delete $args{key_id} ),
          %args,
      );
  }
  
  
  sub list {
      my ( $self, %args ) = @_;
      return $self->request(
          method => 'GET',
          path   => '/user/keys',
          %args,
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Pithub::Users::Keys - Github v3 User Keys API
  
  =head1 VERSION
  
  version 0.01030
  
  =head1 METHODS
  
  =head2 create
  
  =over
  
  =item *
  
  Create a public key
  
      POST /user/keys
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->create(
          data => {
              title => 'plu@localhost',
              key   => 'ssh-rsa AAA...',
          }
      );
  
  =back
  
  =head2 delete
  
  =over
  
  =item *
  
  Delete a public key
  
      DELETE /user/keys/:id
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->delete( key_id => 123 );
  
  =back
  
  =head2 get
  
  =over
  
  =item *
  
  Get a single public key
  
      GET /user/keys/:id
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->get( key_id => 123 );
  
  =back
  
  =head2 list
  
  =over
  
  =item *
  
  List public keys for a user
  
      GET /user/keys
  
  Examples:
  
      my $k = Pithub::Users::Keys->new( token => 'b3c62c6' );
      my $result = $k->list;
  
  =back
  
  =head1 AUTHOR
  
  Johannes Plunien <plu@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Johannes Plunien.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PITHUB_USERS_KEYS

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000001';
  $VERSION = eval $VERSION;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    $proto .= '.pm';
    return 1 if $INC{$proto};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $proto ], 'Role::Tiny::__GUARD__');
    require $proto;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = (map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    $_->($target) for @ON_ROLE_CREATE;
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    die "This is apply_role_to_package" if ref($to);
    die "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    die "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    die "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      $seen{$_}++ for @roles;
      if (my @dupes = grep $seen{$_} > 1, @roles) {
        die "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      die "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      die $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      die $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        die "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    die "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    if (my $info = $INFO{$to}) {
      push @{$info->{modifiers}}, @{$modifiers||[]};
    } else {
      foreach my $modifier (@{$modifiers||[]}) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval { Class::Method::Modifiers->VERSION(1.05); 1 }
        ? 0
        : $@
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && $INFO{$role}{is_role});
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... }
  
   1;
  
  else where
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly.  Object is reblessed into the
  resulting class.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to all copies of the object.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000001';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use Moo::_strictures;
  use Exporter qw(import);
  use Moo::_Utils qw(_getglob _install_coderef);
  use Scalar::Util qw(weaken);
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  our @EXPORT_OK = qw(undefer_package);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    $DEFERRED{$made} = $DEFERRED{$deferred};
    weaken $DEFERRED{$made}
      unless $target;
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub undefer_package {
    my $package = shift;
    my @subs = grep { $DEFERRED{$_}[0] =~ /^${package}::[^:]+$/ } keys %DEFERRED;
    undefer_sub($_) for @subs;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred||''} or return undef;
    [ @$info ];
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($deferred_info->[3]);
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ && $_->[3] ? ($_->[3] => $_) : () } values %DEFERRED;
    foreach my $info (values %DEFERRED) {
      weaken($info)
        unless $info->[0] && ${$info->[2]};
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  Exported by default.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  Exported by default.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all defered subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.  Note this may bake the behavior of some subs that were intended to
  calculate their behavior later, so it shouldn't be used midway through a
  module load or class definition.
  
  Exported by default.
  
  =head2 undefer_package
  
    undefer_package($package);
  
  This undefers all defered subs in a package.
  
  Not exported by default.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001011';
  
  use Carp ();
  use List::Util ();
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (List::Util::first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = List::Util::first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              Carp::croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              Carp::croak $too_complicated if List::Util::first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 Carp::croak $too_complicated if List::Util::first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              Carp::croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        Carp::croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  sub _clean_eval { eval $_[0] }
  
  use Moo::_strictures;
  
  use Sub::Defer qw(defer_sub);
  use Scalar::Util qw(weaken);
  use Exporter qw(import);
  use B ();
  BEGIN {
    *_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
  our @EXPORT_OK = qw(quotify capture_unroll inlinify);
  
  our %QUOTED;
  
  sub quotify {
    ! defined $_[0]     ? 'undef()'
    : _HAVE_PERLSTRING  ? B::perlstring($_[0])
    : qq["\Q$_[0]\E"];
  }
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms) {
      my ($pre, $indent, $code_args) = ($1, $2, $3);
      $do .= $pre;
      if ($code_args ne $args) {
        $do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my ($package, $hints, $bitmask, $hintshash) = (caller(0))[0,8,9,10];
    my $context
      ="# BEGIN quote_sub PRELUDE\n"
      ."package $package;\n"
      ."BEGIN {\n"
      ."  \$^H = ".quotify($hints).";\n"
      ."  \${^WARNING_BITS} = ".quotify($bitmask).";\n"
      ."  \%^H = (\n"
      . join('', map
       "    ".quotify($_)." => ".quotify($hintshash->{$_}).",",
        keys %$hintshash)
      ."  );\n"
      ."}\n"
      ."# END quote_sub PRELUDE\n";
    $code = "$context$code";
    my $quoted_info;
    my $unquoted;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      $unquoted if 0;
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, \$unquoted, $deferred ];
    weaken($quoted_info->[3]);
    weaken($quoted_info->[4]);
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub||''} or return undef;
    my ($name, $code, $captured, $unquoted, $deferred) = @{$quoted_info};
    $unquoted &&= $$unquoted;
    if (($deferred && $deferred eq $sub)
        || ($unquoted && $unquoted eq $sub)) {
      return [ $name, $code, $captured, $unquoted, $deferred ];
    }
    return undef;
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    my $quoted = $QUOTED{$sub} or return undef;
    my $unquoted = $quoted->[3];
    unless ($unquoted && $$unquoted) {
      my ($name, $code, $captures) = @$quoted;
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_UNQUOTED'} = \$unquoted;
      $captures{'$_QUOTED'} = \$quoted;
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$\$_UNQUOTED = sub {\n"
      );
      $make_sub .= "  \$_QUOTED if 0;\n";
      $make_sub .= "  \$_UNQUOTED if 0;\n";
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$\$_UNQUOTED = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{$name} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
        weaken($QUOTED{$$unquoted} = $quoted);
      }
    }
    $$unquoted;
  }
  
  sub qsub ($) {
    goto &quote_sub;
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? (
      $_->[3] && ${$_->[3]} ? (${ $_->[3] } => $_) : (),
      $_->[4] ? ($_->[4] => $_) : (),
    ) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 quotify
  
   my $quoted_value = quotify $value;
  
  Quotes a single (non-reference) scalar value for use in a code string.  Numbers
  aren't treated specially and will be quoted as strings, but undef will quoted as
  C<undef()>.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head2 qsub
  
   my $hash = {
    coderef => qsub q{ print "hello"; },
    other   => 5,
   };
  
  Arguments: $code
  
  Works exactly like L</quote_sub>, but includes a prototype to only accept a
  single parameter.  This makes it easier to include in hash structures or lists.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few
  caveats apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_QUOTE

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # Try to load it
          eval "require $ic";
          die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = "1.69";
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = "1.69";
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = "1.69";
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = "1.69";
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = $] < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = "1.69";
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = "1.69";
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.69';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = "1.69";
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = "1.69";
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = "1.69";
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = "1.69";
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = "1.69";
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use Moo::_strictures;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  oo - syntactic sugar for Moo oneliners
  
  =head1 SYNOPSIS
  
    perl -Moo=Foo -e 'has bar => ( is => q[ro], default => q[baz] ); print Foo->new->bar'
  
    # loads an existing class and re-"opens" the package definition
    perl -Moo=+My::Class -e 'print __PACKAGE__->new->bar'
  
  =head1 DESCRIPTION
  
  oo.pm is a simple source filter that adds C<package $name; use Moo;> to the
  beginning of your script, intended for use on the command line via the -M
  option.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
OO

$fatpacked{"x86_64-linux/Cpanel/JSON/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CPANEL_JSON_XS';
  package Cpanel::JSON::XS;
  our $VERSION = '3.0210';
  
  =pod
  
  =head1 NAME
  
  Cpanel::JSON::XS - cPanel fork of JSON::XS, fast and correct serializing
  
  =head1 SYNOPSIS
  
   use Cpanel::JSON::XS;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = Cpanel::JSON::XS->new->ascii->pretty->allow_nonref;
   $pretty_printed_unencoded = $coder->encode ($perl_scalar);
   $perl_scalar = $coder->decode ($unicode_json_text);
  
   # Note that 5.6 misses most smart utf8 and encoding functionalities
   # of newer releases.
  
   # Note that L<JSON::MaybeXS> will automatically use Cpanel::JSON::XS
   # if available, at virtually no speed overhead either, so you should
   # be able to just:
   
   use JSON::MaybeXS;
  
   # and do the same things, except that you have a pure-perl fallback now.
  
  =head1 DESCRIPTION
  
  This module converts Perl data structures to JSON and vice versa. Its
  primary goal is to be I<correct> and its secondary goal is to be
  I<fast>. To reach the latter goal it was written in C.
  
  As this is the n-th-something JSON module on CPAN, what was the reason
  to write yet another JSON module? While it seems there are many JSON
  modules, none of them correctly handle all corner cases, and in most cases
  their maintainers are unresponsive, gone missing, or not listening to bug
  reports for other reasons.
  
  See below for the cPanel fork.
  
  See MAPPING, below, on how Cpanel::JSON::XS maps perl values to JSON
  values and vice versa.
  
  =head2 FEATURES
  
  =over 4
  
  =item * correct Unicode handling
  
  This module knows how to handle Unicode with Perl version higher than 5.8.5,
  documents how and when it does so, and even documents what "correct" means.
  
  =item * round-trip integrity
  
  When you serialize a perl data structure using only data types supported
  by JSON and Perl, the deserialized data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  =item * fast
  
  Compared to other JSON modules and other serializers such as Storable,
  this module usually compares favourably in terms of speed, too.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an object
  oriented interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format
  possible (nice for simple line-based protocols), a pure-ASCII format
  (for when your transport is not 8-bit clean, still supports the whole
  Unicode range), or a pretty-printed format (for when you want to read that
  stuff). Or you can combine those features in whatever way you like.
  
  =back
  
  =head2 cPanel fork
  
  Since the original author MLEHMANN has no public
  bugtracker, this cPanel fork sits now on github.
  
  src repo: L<https://github.com/rurban/Cpanel-JSON-XS>
  original: L<http://cvs.schmorp.de/JSON-XS/>
  
  RT:       L<https://github.com/rurban/Cpanel-JSON-XS/issues>
  or        L<https://rt.cpan.org/Public/Dist/Display.html?Queue=Cpanel-JSON-XS>
  
  B<Changes to JSON::XS>
  
  - stricter decode_json() as documented. non-refs are disallowed.
    added a 2nd optional argument. decode() honors now allow_nonref.
  
  - fixed encode of numbers for dual-vars. Different string representations
    are preserved, but numbers with temporary strings which represent the same number
    are here treated as numbers, not strings. Cpanel::JSON::XS is a bit slower, but
    preserves numeric types better.
  
  - different handling of inf/nan. Default now to null, optionally with
    -DSTRINGIFY_INFNAN to "inf"/"nan". [#28, #32]
  
  - added C<binary> extension, non-JSON and non JSON parsable, allows
    C<\xNN> and C<\NNN> sequences.
  
  - 5.6.2 support; sacrificing some utf8 features (assuming bytes all-over),
    no multi-byte unicode characters.
  
  - interop for true/false overloading. JSON::XS, JSON::PP and Mojo::JSON 
    representations for booleans are accepted and JSON::XS accepts
    Cpanel::JSON::XS booleans [#13, #37]
    Fixed overloading of booleans. Cpanel::JSON::XS::true stringifies now
    to true, not 1.
  
  - native boolean mapping of yes and no to true and false, as in YAML::XS.
    In perl C<!0> is yes, C<!1> is no.
    The JSON value true maps to 1, false maps to 0. [#39]
  
  - support arbitrary stringification with encode, with convert_blessed
    and allow_blessed.
  
  - ithread support. Cpanel::JSON::XS is thread-safe, JSON::XS not
  
  - is_bool can be called as method, JSON::XS::is_bool not.
  
  - Performance Optimizations for threaded Perls
  
  - additional fixes for:
  
    - [cpan #88061] AIX atof without USE_LONG_DOUBLE
  
    - #10 unshare_hek crash
  
    - #7, #29 avoid re-blessing where possible. It fails in JSON::XS for
     READONLY values, i.e. restricted hashes.
  
    - #41 overloading of booleans, use the object not the reference.
  
  - public maintenance and bugtracker
  
  - use ppport.h, sanify XS.xs comment styles, harness C coding style
  
  - common::sense is optional. When available it is not used in the published
    production module, just during development and testing.
  
  - extended testsuite
  
  - support many more options and methods from JSON::PP
  
  
  =cut
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(encode_json decode_json to_json from_json);
  
  sub to_json($@) {
     if ($] >= 5.008) {
       require Carp;
       Carp::croak ("Cpanel::JSON::XS::to_json has been renamed to encode_json, either downgrade to pre-2.0 versions of Cpanel::JSON::XS or rename the call");
     } else {
       _to_json(@_);
     }
  }
  
  sub from_json($@) {
     if ($] >= 5.008) {
       require Carp;
       Carp::croak ("Cpanel::JSON::XS::from_json has been renamed to decode_json, either downgrade to pre-2.0 versions of Cpanel::JSON::XS or rename the call");
     } else {
       _from_json(@_);
     }
  }
  
  use Exporter;
  use XSLoader;
  
  =head1 FUNCTIONAL INTERFACE
  
  The following convenience methods are provided by this module. They are
  exported by default:
  
  =over 4
  
  =item $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
     $json_text = Cpanel::JSON::XS->new->utf8->encode ($perl_scalar)
  
  Except being faster.
  
  =item $perl_scalar = decode_json $json_text [, $allow_nonref ]
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string of an json reference
  and tries to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
     $perl_scalar = Cpanel::JSON::XS->new->utf8->decode ($json_text)
  
  except being faster.
  
  Note that older decode_json versions in Cpanel::JSON::XS older than
  3.0116 and JSON::XS did not set allow_nonref but allowed them due to a
  bug in the decoder.
  
  If the new optional $allow_nonref argument is set and not false, the allow_nonref
  option will be set and the function will act is described as in the relaxed RFC 7159
  allowing all values such as objects, arrays, strings, numbers, "null", "true", and "false".
  
  =item $is_boolean = Cpanel::JSON::XS::is_bool $scalar
  
  Returns true if the passed scalar represents either C<JSON::XS::true> or
  C<JSON::XS::false>, two constants that act like C<1> and C<0>, respectively
  and are used to represent JSON C<true> and C<false> values in Perl.
  
  See MAPPING, below, for more information on how JSON values are mapped to
  Perl.
  
  =back
  
  =head1 DEPRECATED FUNCTIONS
  
  =over
  
  =item from_json
  
  from_json has been renamed to decode_json
  
  =item to_json
  
  to_json has been renamed to encode_json
  
  =back
  
  
  =head1 A FEW NOTES ON UNICODE AND PERL
  
  Since this often leads to confusion, here are a few very clear words on
  how Unicode works in Perl, modulo bugs.
  
  =over 4
  
  =item 1. Perl strings can store characters with ordinal values > 255.
  
  This enables you to store Unicode characters as single characters in a
  Perl string - very natural.
  
  =item 2. Perl does I<not> associate an encoding with your strings.
  
  ... until you force it to, e.g. when matching it against a regex, or
  printing the scalar to a file, in which case Perl either interprets your
  string as locale-encoded text, octets/binary, or as Unicode, depending
  on various settings. In no case is an encoding stored together with your
  data, it is I<use> that decides encoding, not any magical meta data.
  
  =item 3. The internal utf-8 flag has no meaning with regards to the
  encoding of your string.
  
  =item 4. A "Unicode String" is simply a string where each character can be
  validly interpreted as a Unicode code point.
  
  If you have UTF-8 encoded data, it is no longer a Unicode string, but a
  Unicode string encoded in UTF-8, giving you a binary string.
  
  =item 5. A string containing "high" (> 255) character values is I<not> a UTF-8 string.
  
  =back
  
  I hope this helps :)
  
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =over 4
  
  =item $json = new Cpanel::JSON::XS
  
  Creates a new JSON object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = Cpanel::JSON::XS->new->utf8->space_after->encode ({a => [1,2]})
     => {"a": [1, 2]}
  
  =item $json = $json->ascii ([$enable])
  
  =item $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single C<\uXXXX> (BMP characters) or a double C<\uHHHH\uLLLLL> escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    Cpanel::JSON::XS->new->ascii (1)->encode ([chr 0x10401])
    => ["\ud801\udc01"]
  
  =item $json = $json->latin1 ([$enable])
  
  =item $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or ISO-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    Cpanel::JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  
  =item $json = $json->binary ([$enable])
  
  =item $enabled = $json = $json->get_binary
  
  If the C<$enable> argument is true (or missing), then the C<encode>
  method will not try to detect an UTF-8 encoding in any JSON string, it
  will strictly interpret it as byte sequence.  The result might contain
  new C<\xNN> sequences, which is B<unparsable JSON>.  The C<decode> method
  forbids C<\uNNNN> sequences and accepts C<\xNN> and octal C<\NNN>
  sequences.
  
  There is also a special logic for perl 5.6 and utf8. 5.6 encodes any
  string to utf-8 automatically when seeing a codepoint >= C<0x80> and
  < C<0x100>. With the binary flag enabled decode the perl utf8 encoded
  string to the original byte encoding and encode this with C<\xNN>
  escapes. This will result to the same encodings as with newer
  perls. But note that binary multi-byte codepoints with 5.6 will
  result in C<illegal unicode character in binary string> errors,
  unlike with newer perls.
  
  If C<$enable> is false, then the C<encode> method will smartly try to
  detect Unicode characters unless required by the JSON syntax or other
  flags and hex and octal sequences are forbidden.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to avoid the smart unicode detection and
  possible double encoding. The disadvantage is that the resulting JSON
  text is encoded in new C<\xNN> and in latin1 characters and must
  correctly be treated as such when storing and transferring, a rare
  encoding for JSON. It will produce non-readable JSON strings in the
  browser.  It is therefore most useful when you want to store data
  structures known to contain binary data efficiently in files or
  databases, not when talking to other JSON encoders/decoders.  The
  binary decoding method can also be used when an encoder produced a
  non-JSON conformant hex or octal encoding C<\xNN> or C<\NNN>.
  
    Cpanel::JSON::XS->new->binary->encode (["\x{89}\x{abc}"])
    5.6:   Error: malformed or illegal unicode character in binary string
    >=5.8: ['\x89\xe0\xaa\xbc']
  
    Cpanel::JSON::XS->new->binary->encode (["\x{89}\x{bc}"])
    => ["\x89\xbc"]
  
    Cpanel::JSON::XS->new->binary->decode (["\x89\ua001"])
    Error: malformed or illegal unicode character in binary string
  
    Cpanel::JSON::XS->new->decode (["\x89"])
    Error: illegal hex character in non-binary string
  
  
  =item $json = $json->utf8 ([$enable])
  
  =item $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", Cpanel::JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = Cpanel::JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  =item $json = $json->pretty ([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Example, pretty-print some simple structure:
  
     my $json = Cpanel::JSON::XS->new->pretty(1)->encode ({a => [1,2]})
     =>
     {
        "a" : [
           1,
           2
        ]
     }
  
  
  =item $json = $json->indent ([$enable])
  
  =item $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  
  =item $json = $json->space_before ([$enable])
  
  =item $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =item $json = $json->space_after ([$enable])
  
  =item $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =item $json = $json->relaxed ([$enable])
  
  =item $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =item * literal ASCII TAB characters in strings
  
  Literal ASCII TAB characters are now allowed in strings (and treated as
  C<\t>) in relaxed mode. Despite JSON mandates, that TAB character is
  substituted for "\t" sequence.
  
    [
       "Hello\tWorld",
       "Hello<TAB>World", # literal <TAB> would not normally be allowed
    ]
  
  =item * allow_singlequote
  
  Single quotes are accepted instead of double quotes. See the
  L</allow_singlequote> option.
  
      { "foo":'bar' }
      { 'foo':"bar" }
      { 'foo':'bar' }
  
  =item * allow_barekey
  
  Accept unquoted object keys instead of with mandatory double quotes. See the
  L</allow_barekey> option.
  
      { foo:"bar" }
  
  =back
  
  
  =item $json = $json->canonical ([$enable])
  
  =item $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  
  =item $json = $json->sort_by (undef, 0, 1 or a block)
  
  This currently only (un)sets the C<canonical> option, and ignores
  custom sort blocks.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  
  =item $json = $json->escape_slash ([$enable])
  
  =item $enabled = $json->get_escape_slash
  
  According to the JSON Grammar, the I<forward slash> character (U+002F)
  C<"/"> need to be escaped.  But by default strings are encoded without
  escaping slashes in all perl JSON encoders.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes,
  C<"\/">.
  
  This setting has no effect when decoding JSON texts.
  
  
  =item $json = $json->allow_singlequote ([$enable])
  
  =item $enabled = $json->get_allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  This is also enabled with C<relaxed>.
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =item $json = $json->allow_barekey ([$enable])
  
  =item $enabled = $json->get_allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  Same as with the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  
  =item $json = $json->allow_bignum ([$enable])
  
  =item $enabled = $json->get_allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See L</MAPPING> about the normal conversion of JSON number.
  
  
  =item $json = $json->allow_bigint ([$enable])
  
  This option is obsolete and replaced by allow_bignum.
  
  
  =item $json = $json->allow_nonref ([$enable])
  
  =item $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     Cpanel::JSON::XS->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =item $json = $json->allow_unknown ([$enable])
  
  =item $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =item $json = $json->allow_stringify ([$enable])
  
  =item $enabled = $json->get_allow_stringify
  
  If C<$enable> is true (or missing), then C<encode> will stringify the
  non-object perl value or reference. Note that blessed objects are not
  included here and are handled separately by C<allow_blessed> and
  C<convert_blessed>.  String references are stringified to the string
  value, other references as in perl.
  
  This option does not affect C<decode> in any way.
  
  This option is special to this module, it is not supported by other
  encoders.  So it is not recommended to use it.
  
  =item $json = $json->allow_blessed ([$enable])
  
  =item $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->convert_blessed ([$enable])
  
  =item $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, a stringification overload method is tried next.
  If both are not found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->allow_tags ([$enable])
  
  =item $enabled = $json->get_allow_tags
  
  See L<OBJECT SERIALIZATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialize the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialize
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =item $json = $json->filter_json_object ([$coderef->($hashref)])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialized data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialized hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialized hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = Cpanel::JSON::XS->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]')
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialize Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialized Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     Cpanel::JSON::XS
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialization to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =item $json = $json->shrink ([$enable])
  
  =item $enabled = $json->get_shrink
  
  Perl usually over-allocates memory a bit when allocating space for
  strings. This flag optionally resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk-to-fit, while all strings generated by C<decode> will also be
  shrunk-to-fit.
  
  If C<$enable> is false, then the normal perl allocation algorithms are used.
  If you work with your data, then this is likely to be faster.
  
  In the future, this setting might control other things, such as converting
  strings that look like integers or floats into integers or floats
  internally (there is no difference on the Perl level), saving space.
  
  =item $json = $json->max_depth ([$maximum_nesting_depth])
  
  =item $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing.
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json = $json->max_size ([$maximum_string_size])
  
  =item $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json->stringify_infnan ([$infnan_mode = 1])
  
  =item $infnan_mode = $json->get_stringify_infnan
  
  Get or set how Cpanel::JSON::XS encodes C<inf> or C<nan> for numeric
  values. 
  
  C<null>:     infnan_mode = 0. Similar to most JSON modules in other languages.
  
  stringified: infnan_mode = 1. As in Mojo::JSON.
  
  inf/nan:     infnan_mode = 2. As in JSON::XS, and older releases. Produces invalid JSON.
  
  =item $json_text = $json->encode ($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values. Neither C<true>
  nor C<false> values will be generated.
  
  =item $perl_scalar = $json->decode ($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1>, C<false> becomes C<0> and C<null> becomes C<undef>.
  
  =item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     Cpanel::JSON::XS->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =item $json->to_json ($perl_hash_or_arrayref)
  
  Deprecated method for perl 5.8 and newer. Use L<encode_json> instead.
  
  =item $json->from_json ($utf8_encoded_json_text)
  
  Deprecated method for perl 5.8 and newer. Use L<decode_json> instead.
  
  =back
  
  
  =head1 INCREMENTAL PARSING
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  Cpanel::JSON::XS will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =over 4
  
  =item [void, scalar or list context] = $json->incr_parse ([$string])
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
     my @objs = Cpanel::JSON::XS->new->incr_parse ("[5][7][1,2]");
  
  =item $lvalue_string = $json->incr_text (>5.8 only)
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object, and
  2. only with Perl >= 5.8 
  
  Under all other circumstances you must not call this function (I mean
  it.  although in simple tests it might actually work, it I<will> fail
  under real world conditions). As a special exception, you can also
  call this method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =item $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =item $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =back
  
  =head2 LIMITATIONS
  
  All options that affect decoding are supported, except
  C<allow_nonref>. The reason for this is that it cannot be made to
  work sensibly: JSON objects and arrays are self-delimited, i.e. you can concatenate
  them back to back and still decode them perfectly. This does not hold true
  for JSON numbers, however.
  
  For example, is the string C<1> a single JSON number, or is it simply the
  start of C<12>? Or is C<12> a single JSON number, or the concatenation
  of C<1> and C<2>? In neither case you can tell, and this is why Cpanel::JSON::XS
  takes the conservative route and disallows this case.
  
  =head2 EXAMPLES
  
  Some examples will make all this clearer. First, a simple example that
  works similarly to C<decode_prefix>: We want to decode the JSON object at
  the start of a string and identify the portion after the JSON object:
  
     my $text = "[1,2,3] hello";
  
     my $json = new Cpanel::JSON::XS;
  
     my $obj = $json->incr_parse ($text)
        or die "expected JSON object or array at beginning of string";
  
     my $tail = $json->incr_text;
     # $tail now contains " hello"
  
  Easy, isn't it?
  
  Now for a more complicated example: Imagine a hypothetical protocol where
  you read some requests from a TCP stream, and each request is a JSON
  array, without any separation between them (in fact, it is often useful to
  use newlines as "separators", as these get interpreted as whitespace at
  the start of the JSON text, which makes it possible to test said protocol
  with C<telnet>...).
  
  Here is how you'd do it (it is trivial to write this in an event-based
  manner):
  
     my $json = new Cpanel::JSON::XS;
  
     # read some data from the socket
     while (sysread $socket, my $buf, 4096) {
  
        # split and decode as many requests as possible
        for my $request ($json->incr_parse ($buf)) {
           # act on the $request
        }
     }
  
  Another complicated example: Assume you have a string with JSON objects
  or arrays, all separated by (optional) comma characters (e.g. C<[1],[2],
  [3]>). To parse them, we have to skip the commas between the JSON texts,
  and here is where the lvalue-ness of C<incr_text> comes in useful:
  
     my $text = "[1],[2], [3]";
     my $json = new Cpanel::JSON::XS;
  
     # void context, so no parsing done
     $json->incr_parse ($text);
  
     # now extract as many objects as possible. note the
     # use of scalar context so incr_text can be called.
     while (my $obj = $json->incr_parse) {
        # do something with $obj
  
        # now skip the optional comma
        $json->incr_text =~ s/^ \s* , //x;
     }
  
  Now lets go for a very complex example: Assume that you have a gigantic
  JSON array-of-objects, many gigabytes in size, and you want to parse it,
  but you cannot load it into memory fully (this has actually happened in
  the real world :).
  
  Well, you lost, you have to implement your own JSON parser. But Cpanel::JSON::XS
  can still help you: You implement a (very simple) array parser and let
  JSON decode the array elements, which are all full JSON objects on their
  own (this wouldn't work if the array elements could be JSON numbers, for
  example):
  
     my $json = new Cpanel::JSON::XS;
  
     # open the monster
     open my $fh, "<bigfile.json"
        or die "bigfile: $!";
  
     # first parse the initial "["
     for (;;) {
        sysread $fh, my $buf, 65536
           or die "read error: $!";
        $json->incr_parse ($buf); # void context, so no parsing
  
        # Exit the loop once we found and removed(!) the initial "[".
        # In essence, we are (ab-)using the $json object as a simple scalar
        # we append data to.
        last if $json->incr_text =~ s/^ \s* \[ //x;
     }
  
     # now we have the skipped the initial "[", so continue
     # parsing all the elements.
     for (;;) {
        # in this loop we read data until we got a single JSON object
        for (;;) {
           if (my $obj = $json->incr_parse) {
              # do something with $obj
              last;
           }
  
           # add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
        # in this loop we read data until we either found and parsed the
        # separating "," between elements, or the final "]"
        for (;;) {
           # first skip whitespace
           $json->incr_text =~ s/^\s*//;
  
           # if we find "]", we are done
           if ($json->incr_text =~ s/^\]//) {
              print "finished.\n";
              exit;
           }
  
           # if we find ",", we can continue with the next element
           if ($json->incr_text =~ s/^,//) {
              last;
           }
  
           # if we find anything else, we have a parse error!
           if (length $json->incr_text) {
              die "parse error near ", $json->incr_text;
           }
  
           # else add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
  This is a complex example, but most of the complexity comes from the fact
  that we are trying to be correct (bear with me if I am wrong, I never ran
  the above example :).
  
  
  
  =head1 MAPPING
  
  This section describes how Cpanel::JSON::XS maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, Cpanel::JSON::XS will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values
  cannot represent most decimal fractions exactly, and when converting
  from and to floating point, C<Cpanel::JSON::XS> only guarantees precision
  up to but not including the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<Cpanel::JSON::XS::true> and
  C<Cpanel::JSON::XS::false>, respectively. They are C<JSON::PP::Boolean>
  objects and are overloaded to act almost exactly like the numbers C<1>
  and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<Cpanel::JSON::XS::is_bool> function.
  
  The other round, from perl to JSON, C<!0> which is represented as
  C<yes> becomes C<true>, and C<!1> which is represented as
  C<no> becomes C<false>.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALIZATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. Cpanel::JSON::XS can
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialize to the same JSON text (given same
  settings and version of Cpanel::JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. 
  
  With the option C<allow_stringify>, you can ignore the exception and return
  the stringification of the perl value.
  
  With the option C<allow_unknown>, you can ignore the exception and
  return C<null> instead.
  
     encode_json [\"x"]        # => cannot encode reference to scalar 'SCALAR(0x..)'
                               # unless the scalar is 0 or 1
     encode_json [\0, \1]      # yields [false,true]
  
     allow_stringify->encode_json [\"x"] # yields "x" unlike JSON::PP
     allow_unknown->encode_json [\"x"]   # yields null as in JSON::PP
  
  =item Cpanel::JSON::XS::true, Cpanel::JSON::XS::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> or C<!0> and C<!1>
  directly if you want.
  
     encode_json [Cpanel::JSON::XS::true, Cpanel::JSON::XS::true]      # yields [false,true]
     encode_json [!1, !0]      # yields [false,true]
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but
  C<Cpanel::JSON::XS> allows various optional ways of handling
  objects. See L<OBJECT SERIALIZATION>, below, for details.
  
  See the C<allow_blessed> and C<convert_blessed> methods on various
  options on how to deal with this: basically, you can choose between
  throwing an exception, encoding the reference as if it weren't
  blessed, use the objects overloaded stringification method or provide
  your own serializer method.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: Cpanel::JSON::XS will encode undefined
  scalars or inf/nan as JSON C<null> values, scalars that have last been
  used in a string context before encoding as JSON strings, and anything
  else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, but the two representations are for the same number
     print $value;
     encode_json [$value]                 # yields [5]
  
     # used as different string (non-matching dual-var)
     my $str = '0 but true';
     my $num = 1 + $str;
     encode_json [$num, $str]           # yields [1,"0 but true"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
     # inf or nan becomes null, unless you answered
     # "Do you want to handle inf/nan as strings" with yes
     encode_json [9**9**9]                # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and thus
  null is returned instead. Optionally you can configure it to stringify
  inf and nan values.
  
  =back
  
  =head2 OBJECT SERIALIZATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialize the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALIZATION
  
  What happens when C<Cpanel::JSON::XS> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<Cpanel::JSON::XS> uses the L<Types::Serialiser> object
  serialization protocol to create a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialize, and the second argument being the
  constant string C<JSON> to distinguish it from other serializers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serializer) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialized. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a stringification overload.
  
  In this case, the overloaded C<""> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<""> method will convert all L<URI>
  objects to JSON strings when serialized. The fact that these values
  originally were L<URI> objects is lost.
  
      package URI;
      use overload '""' => sub { shift->as_string };
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialized as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<Cpanel::JSON::XS> throws an exception.
  
  =back
  
  =head3 DESERIALIZATION
  
  For deserialization there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialized, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: I a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, C<Cpanel::JSON::XS> will look up the C<THAW> method
  of the package/classname used during serialization (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<enable_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serializer, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  See the L</SECURITY CONSIDERATIONS> section below. Allowing external
  json objects being deserialized to perl objects is usually a very bad
  idea.
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1>, C<binary> and
  C<ascii>. There seems to be some confusion on what these do, so here
  is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1>, C<binary> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape
  characters with ordinal values > 255 (> 127 with C<ascii>) and encode
  the remaining characters as specified by the C<utf8> flag.
  With C<binary> enabled, ordinal values > 255 are illegal.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1>, C<binary> nor C<ascii> are incompatible with the
  C<utf8> flag - they only govern when the JSON output engine escapes a
  character or not.
  
  The main use for C<latin1> or C<binary> is to relatively efficiently
  store binary data as JSON, at the expense of breaking compatibility
  with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  
  =head2 JSON and ECMAscript
  
  JSON syntax is based on how literals are represented in javascript (the
  not-standardized predecessor of ECMAscript) which is presumably why it is
  called "JavaScript Object Notation".
  
  However, JSON is not a subset (and also not a superset of course) of
  ECMAscript (the standard) or javascript (whatever browsers actually
  implement).
  
  If you want to use javascript's C<eval> function to "parse" JSON, you
  might run into parse errors for valid JSON texts, or the resulting data
  structure might not be queryable:
  
  One of the problems is that U+2028 and U+2029 are valid characters inside
  JSON strings, but are not allowed in ECMAscript string literals, so the
  following Perl fragment will not output something that can be guaranteed
  to be parsable by javascript's C<eval>:
  
     use Cpanel::JSON::XS;
  
     print encode_json [chr 0x2028];
  
  The right fix for this is to use a proper JSON parser in your javascript
  programs, and not rely on C<eval> (see for example Douglas Crockford's
  F<json2.js> parser).
  
  If this is not an option, you can, as a stop-gap measure, simply encode to
  ASCII-only JSON:
  
     use Cpanel::JSON::XS;
  
     print Cpanel::JSON::XS->new->ascii->encode ([chr 0x2028]);
  
  Note that this will enlarge the resulting JSON text quite a bit if you
  have many non-ASCII characters. You might be tempted to run some regexes
  to only escape U+2028 and U+2029, e.g.:
  
     # DO NOT USE THIS!
     my $json = Cpanel::JSON::XS->new->utf8->encode ([chr 0x2028]);
     $json =~ s/\xe2\x80\xa8/\\u2028/g; # escape U+2028
     $json =~ s/\xe2\x80\xa9/\\u2029/g; # escape U+2029
     print $json;
  
  Note that I<this is a bad idea>: the above only works for U+2028 and
  U+2029 and thus only for fully ECMAscript-compliant parsers. Many existing
  javascript implementations, however, have issues with other characters as
  well - using C<eval> naively simply I<will> cause problems.
  
  Another problem is that some javascript implementations reserve
  some property names for their own purposes (which probably makes
  them non-ECMAscript-compliant). For example, Iceweasel reserves the
  C<__proto__> property name for its own purposes.
  
  If that is a problem, you could parse try to filter the resulting JSON
  output for these property strings, e.g.:
  
     $json =~ s/"__proto__"\s*:/"__proto__renamed":/g;
  
  This works because C<__proto__> is not valid outside of strings, so every
  occurrence of C<"__proto__"\s*:> must be a string used as property name.
  
  If you know of other incompatibilities, please let me know.
  
  
  =head2 JSON and YAML
  
  You often hear that JSON is a subset of YAML.  I<in general, there is
  no way to configure JSON::XS to output a data structure as valid YAML>
  that works in all cases.  If you really must use Cpanel::JSON::XS to
  generate YAML, you should use this algorithm (subject to change in
  future versions):
  
     my $to_yaml = Cpanel::JSON::XS->new->utf8->space_after (1);
     my $yaml = $to_yaml->encode ($ref) . "\n";
  
  This will I<usually> generate JSON texts that also parse as valid
  YAML.
  
  
  =head2 SPEED
  
  It seems that JSON::XS is surprisingly fast, as shown in the following
  tables. They have been generated with the help of the C<eg/bench> program
  in the JSON::XS distribution, to make it easy to compare on your own
  system.
  
  JSON::XS is with L<Data::MessagePack> and L<Sereal> one of the fastest
  serializers, because JSON and JSON::XS do not support backrefs (no
  graph structures), only trees. Storable supports backrefs,
  i.e. graphs. Data::MessagePack encodes its data binary (as Storable)
  and supports only very simple subset of JSON.
  
  First comes a comparison between various modules using
  a very short single-line JSON string (also available at
  L<http://dist.schmorp.de/misc/json/short.json>).
  
     {"method": "handleMessage", "params": ["user1",
     "we were just talking"], "id": null, "array":[1,11,234,-5,1e5,1e7,
     1,  0]}
  
  It shows the number of encodes/decodes per second (JSON::XS uses
  the functional interface, while Cpanel::JSON::XS/2 uses the OO interface
  with pretty-printing and hash key sorting enabled, Cpanel::JSON::XS/3 enables
  shrink. JSON::DWIW/DS uses the deserialize function, while JSON::DWIW::FJ
  uses the from_json method). Higher is better:
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |  86302.551 | 102300.098 |
     JSON::DWIW/FJ |  86302.551 |  75983.768 |
     JSON::PP      |  15827.562 |   6638.658 |
     JSON::Syck    |  63358.066 |  47662.545 |
     JSON::XS      | 511500.488 | 511500.488 |
     JSON::XS/2    | 291271.111 | 388361.481 |
     JSON::XS/3    | 361577.931 | 361577.931 |
     Storable      |  66788.280 | 265462.278 |
     --------------+------------+------------+
  
  That is, JSON::XS is almost six times faster than JSON::DWIW on encoding,
  about five times faster on decoding, and over thirty to seventy times
  faster than JSON's pure perl implementation. It also compares favourably
  to Storable for small amounts of data.
  
  Using a longer test string (roughly 18KB, generated from Yahoo! Locals
  search API (L<http://dist.schmorp.de/misc/json/long.json>).
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |   1647.927 |   2673.916 |
     JSON::DWIW/FJ |   1630.249 |   2596.128 |
     JSON::PP      |    400.640 |     62.311 |
     JSON::Syck    |   1481.040 |   1524.869 |
     JSON::XS      |  20661.596 |   9541.183 |
     JSON::XS/2    |  10683.403 |   9416.938 |
     JSON::XS/3    |  20661.596 |   9400.054 |
     Storable      |  19765.806 |  10000.725 |
     --------------+------------+------------+
  
  Again, JSON::XS leads by far (except for Storable which non-surprisingly
  decodes a bit faster).
  
  On large strings containing lots of high Unicode characters, some modules
  (such as JSON::PC) seem to decode faster than JSON::XS, but the result
  will be broken due to missing (or wrong) Unicode handling. Others refuse
  to decode or encode properly, so it was impossible to prepare a fair
  comparison table for that case.
  
  For updated graphs see L<https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs>
  
  
  =head1 INTEROP with JSON and JSON::XS and other JSON modules
  
  JSON-XS-3.01 broke interoperability with JSON-2.90 with booleans. See L<JSON>.
  
  Cpanel::JSON::XS needs to know the JSON and JSON::XS versions to be able work
  with those objects, especially when encoding a booleans like C<{"is_true":true}>.
  So you need to load these modules before.
  
  true/false overloading and boolean representations are supported.
  
  JSON::XS and JSON::PP representations are accepted and older JSON::XS accepts
  Cpanel::JSON::XS booleans. All JSON modules JSON, JSON, PP, JSON::XS, Cpanel::JSON::XS
  produce JSON::PP::Boolean objects, just Mojo and JSON::YAJL not.
  Mojo produces Mojo::JSON::_Bool and JSON::YAJL::Parser just an unblessed IV.
  
  Cpanel::JSON::XS accepts JSON::PP::Boolean and Mojo::JSON::_Bool objects as booleans.
  
  I cannot think of any reason to still use JSON::XS anymore.
  
  =head1 SECURITY CONSIDERATIONS
  
  JSON::XS is not only fast, JSON is generally the most secure
  serializing format, because it is the only one besides
  Data::MessagePack, which does not deserialize objects per default. For
  all languages, not just perl.  The binary variant BSON (MongoDB) does
  more but is unsafe.
  
  It is trivial for any attacker to create such serialized objects in
  JSON and trick perl into expanding them, thereby triggering certain
  methods. Watch L<https://www.youtube.com/watch?v=Gzx6KlqiIZE> for an
  exploit demo for "CVE-2015-1592 SixApart MovableType Storable Perl
  Code Execution" for a deserializer which expands
  objects. Deserializing even coderefs (methods, functions) or external
  data would be considered the most dangerous.
  
  Security relevant overview of serializers regarding deserializing
  objects by default:
  
                        Objects   Coderefs  External Data
  
      Data::Dumper      YES       YES       YES
      Storable          YES       NO (def)  NO
      Sereal            YES       NO        NO
      YAML              YES       NO        NO
      B::C              YES       YES       YES
      B::Bytecode       YES       YES       YES
      BSON              YES       YES       NO
      JSON::SL          YES       NO        YES
      JSON              NO (def)  NO        NO
      Data::MessagePack NO        NO        NO
      XML               NO        NO        YES
  
      Pickle            YES       YES       YES
      PHP Deserialize   YES       NO        NO
  
  When you are using JSON in a protocol, talking to untrusted potentially
  hostile creatures requires relatively few measures.
  
  First of all, your JSON decoder should be secure, that is, should not have
  any buffer overflows. Obviously, this module should ensure that.
  
  Second, you need to avoid resource-starving attacks. That means you should
  limit the size of JSON texts you accept, or make sure then when your
  resources run out, that's just fine (e.g. by using a separate process that
  can crash safely). The size of a JSON text in octets or characters is
  usually a good indication of the size of the resources required to decode
  it into a Perl structure. While JSON::XS can check the size of the JSON
  text, it might be too late when you already have it in memory, so you
  might want to check the size before you accept the string.
  
  Third, Cpanel::JSON::XS recurses using the C stack when decoding objects and
  arrays. The C stack is a limited resource: for instance, on my amd64
  machine with 8MB of stack size I can decode around 180k nested arrays but
  only 14k nested JSON objects (due to perl itself recursing deeply on croak
  to free the temporary). If that is exceeded, the program crashes. To be
  conservative, the default nesting limit is set to 512. If your process
  has a smaller stack, you should adjust this setting accordingly with the
  C<max_depth> method.
  
  Also keep in mind that Cpanel::JSON::XS might leak contents of your Perl data
  structures in its error messages, so when you serialize sensitive
  information you might want to make sure that exceptions thrown by JSON::XS
  will not end up in front of untrusted eyes.
  
  If you are using Cpanel::JSON::XS to return packets to consumption
  by JavaScript scripts in a browser you should have a look at
  L<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to
  see whether you are vulnerable to some common attack vectors (which really
  are browser design bugs, but it is still you who will have to deal with
  it, as major browser developers care only for features, not about getting
  security right). You might also want to also look at L<Mojo::JSON>
  special escape rules to prevent from XSS attacks.
  
  =head1 THREADS
  
  Cpanel::JSON::XS has proper ithreads support, unlike JSON::XS. If you
  encounter any bugs with thread support please report them.
  
  =head1 BUGS
  
  While the goal of the Cpanel::JSON::XS module is to be correct, that
  unfortunately does not mean it's bug-free, only that the author thinks
  its design is bug-free. If you keep reporting bugs and tests they will
  be fixed swiftly, though.
  
  Since the JSON::XS author refuses to use a public bugtracker and
  prefers private emails, we've setup a tracker at RT, so you might want
  to report any issues twice. Once in private to MLEHMANN to be fixed in
  JSON::XS and one to our the public tracker. Issues fixed by JSON::XS
  with a new release will also be backported to Cpanel::JSON::XS and
  5.6.2, as long as cPanel relies on 5.6.2 and Cpanel::JSON::XS as our
  serializer of choice.
  
  L<https://rt.cpan.org/Public/Dist/Display.html?Queue=Cpanel-JSON-XS>
  
  =head1 LICENSE
  
  This module is available under the same licences as perl, the Artistic
  license and the GPL.
  
  =cut
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
  }
  
  our ($true, $false);
  BEGIN {
    if ($INC{'JSON/XS.pm'}
        and $INC{'Types/Serialiser.pm'}
        and $JSON::XS::VERSION ge "3.00") {
      $true  = $Types::Serialiser::true; # readonly if loaded by JSON::XS
      $false = $Types::Serialiser::false;
    } else {
      $true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
      $false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
    }
  }
  
  sub true()  { $true  }
  sub false() { $false }
  sub is_bool($) {
    shift if @_ == 2; # as method call
    (ref($_[0]) and UNIVERSAL::isa( $_[0], JSON::PP::Boolean::))
    or (exists $INC{'Types/Serializer.pm'} and Types::Serialiser::is_bool($_[0]))
  }
  
  XSLoader::load 'Cpanel::JSON::XS', $VERSION;
  
  package
    JSON::PP::Boolean;
  
  use overload
     "0+"     => sub { ${$_[0]} },
     "++"     => sub { $_[0] = ${$_[0]} + 1 },
     "--"     => sub { $_[0] = ${$_[0]} - 1 },
     '""'     => sub { ${$_[0]} == 1 ? 'true' : '0' }, # GH 29
     'eq'     => sub {
       my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
       if ($op eq 'true' or $op eq 'false') {
         return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
       }
       else {
         return $obj ? 1 == $op : 0 == $op;
       }
     },
    fallback => 1;
  
  1;
  
  =head1 SEE ALSO
  
  The F<cpanel_json_xs> command line utility for quick experiments.
  
  L<JSON>, L<JSON::XS>, L<JSON::MaybeXS>, L<Mojo::JSON>, L<Mojo::JSON::MaybeXS>,
  L<JSON::SL>, L<JSON::DWIW>, L<JSON::YAJL>,  L<JSON::Any>, L<Test::JSON>,
  L<Locale::Wolowitz>,
  L<https://metacpan.org/search?q=JSON>
  
  L<https://tools.ietf.org/html/rfc7159>
  
  L<https://tools.ietf.org/html/rfc4627>
  
  
  =head1 AUTHOR
  
  Marc Lehmann <schmorp@schmorp.de>, http://home.schmorp.de/
  
  Reini Urban <rurban@cpanel.net>, http://cpanel.net/
  
  =head1 MAINTAINER
  
  Reini Urban <rurban@cpanel.net>
  
  =cut
  
X86_64-LINUX_CPANEL_JSON_XS

$fatpacked{"x86_64-linux/Cpanel/JSON/XS/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CPANEL_JSON_XS_BOOLEAN';
  =head1 NAME
  
  Cpanel::JSON::XS::Boolean - dummy module providing JSON::XS::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules
  and interop with L<JSON::XS> booleans.
  See L<Cpanel::JSON::XS> for more info about this class.
  
  =cut
  
  use Cpanel::JSON::XS ();
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
X86_64-LINUX_CPANEL_JSON_XS_BOOLEAN

$fatpacked{"x86_64-linux/Term/ReadKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_TERM_READKEY';
  package Term::ReadKey;
  
  =head1 NAME
  
  Term::ReadKey - A perl module for simple terminal control
  
  =head1 SYNOPSIS
  
      use Term::ReadKey;
      ReadMode 4; # Turn off controls keys
      while (not defined ($key = ReadKey(-1))) {
          # No key yet
      }
      print "Get key $key\n";
      ReadMode 0; # Reset tty mode before exiting
  
  =head1 DESCRIPTION
  
  Term::ReadKey is a compiled perl module dedicated to providing simple
  control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
  non-blocking reads, if the architecture allows, and some generalized handy
  functions for working with terminals. One of the main goals is to have the
  functions as portable as possible, so you can just plug in "use
  Term::ReadKey" on any architecture and have a good likelihood of it working.
  
  Version 2.30.01:
  Added handling of arrows, page up/down, home/end, insert/delete keys 
  under Win32. These keys emit xterm-compatible sequences.
  Works with Term::ReadLine::Perl.
  
  =over 4
  
  =item ReadMode MODE [, Filehandle]
  
  Takes an integer argument or a string synonym (case insensitive), which
  can currently be one of the following values:
  
      INT   SYNONYM    DESCRIPTION
  
      0    'restore'   Restore original settings.
  
      1    'normal'    Change to what is commonly the default mode,
                       echo on, buffered, signals enabled, Xon/Xoff
                       possibly enabled, and 8-bit mode possibly disabled.
  
      2    'noecho'    Same as 1, just with echo off. Nice for
                       reading passwords.
  
      3    'cbreak'    Echo off, unbuffered, signals enabled, Xon/Xoff
                       possibly enabled, and 8-bit mode possibly enabled.
  
      4    'raw'       Echo off, unbuffered, signals disabled, Xon/Xoff
                       disabled, and 8-bit mode possibly disabled.
  
      5    'ultra-raw' Echo off, unbuffered, signals disabled, Xon/Xoff 
                       disabled, 8-bit mode enabled if parity permits,
                       and CR to CR/LF translation turned off. 
  
  
  These functions are automatically applied to the STDIN handle if no
  other handle is supplied. Modes 0 and 5 have some special properties
  worth mentioning: not only will mode 0 restore original settings, but it
  cause the next ReadMode call to save a new set of default settings. Mode
  5 is similar to mode 4, except no CR/LF translation is performed, and if
  possible, parity will be disabled (only if not being used by the terminal,
  however. It is no different from mode 4 under Windows.)
  
  If you just need to read a key at a time, then modes 3 or 4 are probably
  sufficient. Mode 4 is a tad more flexible, but needs a bit more work to
  control. If you use ReadMode 3, then you should install a SIGINT or END
  handler to reset the terminal (via ReadMode 0) if the user aborts the
  program via C<^C>. (For any mode, an END handler consisting of "ReadMode 0"
  is actually a good idea.)
  
  If you are executing another program that may be changing the terminal mode,
  you will either want to say
  
      ReadMode 1;             # same as ReadMode 'normal'
      system('someprogram');
      ReadMode 1;
  
  which resets the settings after the program has run, or:
  
      $somemode=1;
      ReadMode 0;             # same as ReadMode 'restore'
      system('someprogram');
      ReadMode 1;
  
  which records any changes the program may have made, before resetting the
  mode.
  
  =item ReadKey MODE [, Filehandle]
  
  Takes an integer argument, which can currently be one of the following 
  values:
  
      0    Perform a normal read using getc
      -1   Perform a non-blocked read
      >0	 Perform a timed read
  
  If the filehandle is not supplied, it will default to STDIN. If there is
  nothing waiting in the buffer during a non-blocked read, then undef will be
  returned.  In most situations, you will probably want to use C<ReadKey -1>.
  
  I<NOTE> that if the OS does not provide any known mechanism for non-blocking
  reads, then a C<ReadKey -1> can die with a fatal error. This will hopefully
  not be common.
  
  If MODE is greater then zero, then ReadKey will use it as a timeout value in
  seconds (fractional seconds are allowed), and won't return C<undef> until
  that time expires.
  
  I<NOTE>, again, that some OS's may not support this timeout behaviour.
  
  If MODE is less then zero, then this is treated as a timeout
  of zero, and thus will return immediately if no character is waiting. A MODE
  of zero, however, will act like a normal getc.
  
  I<NOTE>, there are currently some limitations with this call under Windows.
  It may be possible that non-blocking reads will fail when reading repeating
  keys from more then one console.
  
  
  =item ReadLine MODE [, Filehandle]
  
  Takes an integer argument, which can currently be one of the following 
  values:
  
      0    Perform a normal read using scalar(<FileHandle>)
      -1   Perform a non-blocked read
      >0	 Perform a timed read
  
  If there is nothing waiting in the buffer during a non-blocked read, then
  undef will be returned.
  
  I<NOTE>, that if the OS does not provide any known mechanism for
  non-blocking reads, then a C<ReadLine 1> can die with a fatal
  error. This will hopefully not be common.
  
  I<NOTE> that a non-blocking test is only performed for the first character
  in the line, not the entire line.  This call will probably B<not> do what
  you assume, especially with C<ReadMode> MODE values higher then 1. For
  example, pressing Space and then Backspace would appear to leave you
  where you started, but any timeouts would now be suspended.
  
  B<This call is currently not available under Windows>.
  
  =item GetTerminalSize [Filehandle]
  
  Returns either an empty array if this operation is unsupported, or a four
  element array containing: the width of the terminal in characters, the
  height of the terminal in character, the width in pixels, and the height in
  pixels. (The pixel size will only be valid in some environments.)
  
  I<NOTE>, under Windows, this function must be called with an B<output>
  filehandle, such as C<STDOUT>, or a handle opened to C<CONOUT$>.
  
  =item SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]
  
  Return -1 on failure, 0 otherwise.
  
  I<NOTE> that this terminal size is only for B<informative> value, and
  changing the size via this mechanism will B<not> change the size of
  the screen. For example, XTerm uses a call like this when
  it resizes the screen. If any of the new measurements vary from the old, the
  OS will probably send a SIGWINCH signal to anything reading that tty or pty.
  
  B<This call does not work under Windows>.
  
  =item GetSpeeds [, Filehandle]
  
  Returns either an empty array if the operation is unsupported, or a two
  value array containing the terminal in and out speeds, in B<decimal>. E.g,
  an in speed of 9600 baud and an out speed of 4800 baud would be returned as
  (9600,4800). Note that currently the in and out speeds will always be
  identical in some OS's.
  
  B<No speeds are reported under Windows>.
  
  =item GetControlChars [, Filehandle]
  
  Returns an array containing key/value pairs suitable for a hash. The pairs
  consist of a key, the name of the control character/signal, and the value
  of that character, as a single character.
  
  B<This call does nothing under Windows>.
  
  Each key will be an entry from the following list:
  
  	DISCARD
  	DSUSPEND
  	EOF
  	EOL
  	EOL2
  	ERASE
  	ERASEWORD
  	INTERRUPT
  	KILL
  	MIN
  	QUIT
  	QUOTENEXT
  	REPRINT
  	START
  	STATUS
  	STOP
  	SUSPEND
  	SWITCH
  	TIME
  
  Thus, the following will always return the current interrupt character,
  regardless of platform.
  
  	%keys = GetControlChars;
  	$int = $keys{INTERRUPT};
  
  =item SetControlChars [, Filehandle]
  
  Takes an array containing key/value pairs, as a hash will produce. The pairs
  should consist of a key that is the name of a legal control
  character/signal, and the value should be either a single character, or a
  number in the range 0-255. SetControlChars will die with a runtime error if
  an invalid character name is passed or there is an error changing the
  settings. The list of valid names is easily available via
  
  	%cchars = GetControlChars();
  	@cnames = keys %cchars;
  
  B<This call does nothing under Windows>.
  
  =back
  
  =head1 AUTHOR
  
  Kenneth Albanowski <kjahds@kjahds.com>
  
  Currently maintained by Jonathan Stowe <jns@gellyfish.co.uk>
  
  =head1 SUPPORT
  
  The code is maintained at 
  
       https://github.com/jonathanstowe/TermReadKey
  
  Please feel free to fork and suggest patches.
  
  
  =head1 LICENSE
  
  Prior to the 2.31 release the license statement was:
  
   Copyright (C) 1994-1999 Kenneth Albanowski.
                  2001-2005 Jonathan Stowe and others
  
                   Unlimited distribution and/or modification is allowed as long as this
                    copyright notice remains intact.
  
  And was only stated in the README file.
  
  Because I believe the original author's intent was to be more open than the
  other commonly used licenses I would like to leave that in place. However if
  you or your lawyers require something with some more words you can optionally
  choose to license this under the standard Perl license:
  
        This module is free software; you can redistribute it and/or modify it
        under the terms of the Artistic License. For details, see the full
        text of the license in the file "Artistic" that should have been provided
        with the version of perl you are using.
  
        This program is distributed in the hope that it will be useful, but
        without any warranty; without even the implied warranty of merchantability
        or fitness for a particular purpose.
  
  
  =cut
  
  use vars qw($VERSION);
  
  $VERSION = '2.33';
  
  require Exporter;
  require AutoLoader;
  require DynaLoader;
  use Carp;
  
  @ISA = qw(Exporter AutoLoader DynaLoader);
  
  # Items to export into callers namespace by default
  # (move infrequently used names to @EXPORT_OK below)
  
  @EXPORT = qw(
    ReadKey
    ReadMode
    ReadLine
    GetTerminalSize
    SetTerminalSize
    GetSpeed
    GetControlChars
    SetControlChars
  );
  
  @EXPORT_OK = qw();
  
  bootstrap Term::ReadKey;
  
  # Preloaded methods go here.  Autoload methods go after __END__, and are
  # processed by the autosplit program.
  
  # Should we use LINES and COLUMNS to try and get the terminal size?
  # Change this to zero if you have systems where these are commonly
  # set to erroneous values. (But if either are near zero, they won't be
  # used anyhow.)
  
  $UseEnv = 1;
  
  $CurrentMode = 0;
  
  %modes = (                            # lowercase is canonical
      original    => 0,
      restore     => 0,
      normal      => 1,
      noecho      => 2,
      cbreak      => 3,
      raw         => 4,
      'ultra-raw' => 5
  );
  
  sub ReadMode
  {
      my ($mode) = $modes{ lc $_[0] };  # lowercase is canonical
      my ($fh) = normalizehandle( ( @_ > 1 ? $_[1] : \*STDIN ) );
      if ( defined($mode) ) { $CurrentMode = $mode }
      elsif ( $_[0] =~ /^\d/ ) { $CurrentMode = $_[0] }
      else { croak("Unknown terminal mode `$_[0]'"); }
      SetReadMode($CurrentMode, $fh);
  }
  
  sub normalizehandle
  {
      my ($file) = @_;
  
      #	print "Handle = $file\n";
      if ( ref($file) ) { return $file; }    # Reference is fine
  
      #	if($file =~ /^\*/) { return $file; } # Type glob is good
      if ( ref( \$file ) eq 'GLOB' ) { return $file; }    # Glob is good
  
      #	print "Caller = ",(caller(1))[0],"\n";
      return \*{ ( ( caller(1) )[0] ) . "::$file" };
  }
  
  sub GetTerminalSize
  {
      my ($file) = normalizehandle( ( @_ > 1 ? $_[1] : \*STDOUT ) );
      my (@results) = ();
      my (@fail);
  
      if ( &termsizeoptions() & 1 )                       # VIO
      {
          @results = GetTermSizeVIO($file);
          push( @fail, "VIOGetMode call" );
      }
      elsif ( &termsizeoptions() & 2 )                    # GWINSZ
      {
          @results = GetTermSizeGWINSZ($file);
          push( @fail, "TIOCGWINSZ ioctl" );
      }
      elsif ( &termsizeoptions() & 4 )                    # GSIZE
      {
          @results = GetTermSizeGSIZE($file);
          push( @fail, "TIOCGSIZE ioctl" );
      }
      elsif ( &termsizeoptions() & 8 )                    # WIN32
      {
          @results = GetTermSizeWin32($file);
          push( @fail, "Win32 GetConsoleScreenBufferInfo call" );
      }
      else
      {
          @results = ();
      }
  
      if ( @results < 4 and $UseEnv )
      {
          my ($C) = defined( $ENV{COLUMNS} ) ? $ENV{COLUMNS} : 0;
          my ($L) = defined( $ENV{LINES} )   ? $ENV{LINES}   : 0;
          if ( ( $C >= 2 ) and ( $L >= 2 ) )
          {
              @results = ( $C + 0, $L + 0, 0, 0 );
          }
          push( @fail, "COLUMNS and LINES environment variables" );
      }
  
      if ( @results < 4 && $^O ne 'MSWin32')
      {
          my ($prog) = "resize";
  
          # Workaround for Solaris path silliness
          if ( -f "/usr/openwin/bin/resize" ) {
              $prog = "/usr/openwin/bin/resize";
          }
  
          my ($resize) = scalar(`$prog 2>/dev/null`);
          if (
              defined $resize
              and (  $resize =~ /COLUMNS\s*=\s*(\d+)/
                  or $resize =~ /setenv\s+COLUMNS\s+'?(\d+)/ )
            )
          {
              $results[0] = $1;
              if (   $resize =~ /LINES\s*=\s*(\d+)/
                  or $resize =~ /setenv\s+LINES\s+'?(\d+)/ )
              {
                  $results[1] = $1;
                  @results[ 2, 3 ] = ( 0, 0 );
              }
              else
              {
                  @results = ();
              }
          }
          else
          {
              @results = ();
          }
          push( @fail, "resize program" );
      }
  
      if ( @results < 4 && $^O ne 'MSWin32' )
      {
          my ($prog) = "stty size";
  
          my ($stty) = scalar(`$prog 2>/dev/null`);
          if (
              defined $stty
              and (  $stty =~ /(\d+) (\d+)/ )
            )
          {
              $results[0] = $2;
  			$results[1] = $1;
  			@results[ 2, 3 ] = ( 0, 0 );
          }
          else
          {
              @results = ();
          }
          push( @fail, "stty program" );
      }
  
      if ( @results != 4 )
      {
          warn "Unable to get Terminal Size."
            . join( "", map( " The $_ didn't work.", @fail ) );
  	return undef;
      }
  
      @results;
  }
  
  if ( &blockoptions() & 1 )    # Use nodelay
  {
      if ( &blockoptions() & 2 )    #poll
      {
          eval <<'DONE';
  		sub ReadKey {
  		  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
                    if (defined $_[0] && $_[0] > 0) {
                      if ($_[0]) {
                        return undef if &pollfile($File,$_[0]) == 0;
                      }
  		  }
                    if (defined $_[0] && $_[0] < 0) {
                       &setnodelay($File,1);
                    }
                    my ($value) = getc $File;
                    if (defined $_[0] && $_[0] < 0) {
                       &setnodelay($File,0);
                    }
                    $value;
  		}
  		sub ReadLine {
  		  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  
                    if (defined $_[0] && $_[0] > 0) {
                       if ($_[0]) {
                         return undef if &pollfile($File,$_[0]) == 0;
                       }
  		  }
                    if (defined $_[0] && $_[0] < 0) {
                       &setnodelay($File,1)
                    };
                    my ($value) = scalar(<$File>);
                    if ( defined $_[0] && $_[0]<0 ) {
                      &setnodelay($File,0)
                    };
                    $value;
  		}
  DONE
      }
      elsif ( &blockoptions() & 4 )    #select
      {
          eval <<'DONE';
  		sub ReadKey {
  		  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
                    if(defined $_[0] && $_[0]>0) {
  				if($_[0]) {return undef if &selectfile($File,$_[0])==0}
  		    }
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,1);}
  			my($value) = getc $File;
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,0);}
  			$value;
  		}
  		sub ReadLine {
  		  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		    if(defined $_[0] && $_[0]>0) {
  				if($_[0]) {return undef if &selectfile($File,$_[0])==0}
  		    }
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,1)};
  			my($value)=scalar(<$File>);
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,0)};
  			$value;
  		}
  DONE
      }
      else
      {    #nothing
          eval <<'DONE';
  		sub ReadKey {
  		  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		    if(defined $_[0] && $_[0]>0) {
  		    	# Nothing better seems to exist, so I just use time-of-day
  		    	# to timeout the read. This isn't very exact, though.
  		    	$starttime=time;
  		    	$endtime=$starttime+$_[0];
  				&setnodelay($File,1);
  				my($value)=undef;
  		    	while(time<$endtime) { # This won't catch wraparound!
  		    		$value = getc $File;
  		    		last if defined($value);
  		    	}
  				&setnodelay($File,0);
  				return $value;
  		    }
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,1);}
  			my($value) = getc $File;
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,0);}
  			$value;
  		}
  		sub ReadLine {
  		  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		    if(defined $_[0] && $_[0]>0) {
  		    	# Nothing better seems to exist, so I just use time-of-day
  		    	# to timeout the read. This isn't very exact, though.
  		    	$starttime=time;
  		    	$endtime=$starttime+$_[0];
  				&setnodelay($File,1);
  				my($value)=undef;
  		    	while(time<$endtime) { # This won't catch wraparound!
  		    		$value = scalar(<$File>);
  		    		last if defined($value);
  		    	}
  				&setnodelay($File,0);
  				return $value;
  		    }
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,1)};
  			my($value)=scalar(<$File>);
  			if(defined $_[0] && $_[0]<0) {&setnodelay($File,0)};
  			$value;
  		}
  DONE
      }
  }
  elsif ( &blockoptions() & 2 )    # Use poll
  {
      eval <<'DONE';
  	sub ReadKey {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		if(defined $_[0] && $_[0] != 0) {
                       return undef if &pollfile($File,$_[0]) == 0
                  }
  		getc $File;
  	}
  	sub ReadLine {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		if(defined $_[0] && $_[0]!=0) {
                       return undef if &pollfile($File,$_[0]) == 0;
                  }
  		scalar(<$File>);
  	}
  DONE
  }
  elsif ( &blockoptions() & 4 )    # Use select
  {
      eval <<'DONE';
  	sub ReadKey {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		if(defined $_[0] && $_[0] !=0 ) {
                       return undef if &selectfile($File,$_[0])==0
                  }
  		getc $File;
  	}
  	sub ReadLine {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		if(defined $_[0] && $_[0] != 0) {
                       return undef if &selectfile($File,$_[0]) == 0;
                  }
  		scalar(<$File>);
  	}
  DONE
  }
  elsif ( &blockoptions() & 8 )    # Use Win32
  {
      eval <<'DONE';
  	sub ReadKey {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
          if ($_[0] || $CurrentMode >= 3) {
  			Win32PeekChar($File, $_[0]);
          } else {
          	getc $File;
          }
  		#if ($_[0]!=0) {return undef if !Win32PeekChar($File, $_[0])};
  		#getc $File;
  	}
  	sub ReadLine {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		#if ($_[0]!=0) {return undef if !Win32PeekChar($File, $_[0])};
  		#scalar(<$File>);
  		if($_[0]) 
  			{croak("Non-blocking ReadLine is not supported on this architecture")}
  		scalar(<$File>);
  	}
  DONE
  }
  else
  {
      eval <<'DONE';
  	sub ReadKey {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		if($_[0]) 
  			{croak("Non-blocking ReadKey is not supported on this architecture")}
  		getc $File;
  	}
  	sub ReadLine {
  	  my($File) = normalizehandle((@_>1?$_[1]:\*STDIN));
  		if($_[0]) 
  			{croak("Non-blocking ReadLine is not supported on this architecture")}
  		scalar(<$File>);
  	}
  DONE
  }
  
  package Term::ReadKey;    # return to package ReadKey so AutoSplit is happy
  1;
  
  __END__;
X86_64-LINUX_TERM_READKEY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use 5.010000;
use Pithub;
use LWP::UserAgent;
use HTTP::Request;
use JSON;
use Data::Dumper; sub p { warn Dumper(@_); }
use autodie ':system';
use File::Basename ();
use Cwd ();
use Getopt::Long;
use Term::ReadKey;
use Sys::Hostname;
use Pod::Usage;
use Term::ANSIColor;
use Encode ();
use Encode::Locale;

our $VERSION = '0.09';

if (-t) {
    binmode STDOUT, ":encoding(console_out)";
    binmode STDERR, ":encoding(console_out)";
}

sub prompt {
    my ($prompt, @args) = @_;
    push @args, 1 if @args % 2;
    my %args = @args;
    local $| = 1;
    my $phrase = '';
    print $prompt;
    ReadMode 'cbreak';
    while (1) {
        my $c = ReadKey ~0/2-1;
        if ($c =~ /[\r\n]/) {
            print "\n";
            last;
        }
        elsif ($c eq "\b" || ord $c == 127) {
            next unless length $phrase;
            chop $phrase;
            next if defined $args{-echo} && length $args{-echo} eq 0;
            print "\b \b";
        }
        elsif (ord $c) {
            $phrase .= $c;
            print defined $args{-echo} ?  $args{-echo} : $c;
        }
    }
    ReadMode 'restore';
    $args{-yes} ? ($phrase =~ /^y/i) : $phrase;
}

my $agent = LWP::UserAgent->new(timeout => 10);
$agent->env_proxy(); # for mattn
my $token = `git config --get ph.token`;
my $me = `git config --get ph.user`;
chomp $me;
unless ($token && $me) {
    setup();
}
my $pithub = Pithub->new(
    token => $token,
    ua    => $agent,
);
main();
exit;

# ------------------------------------------------------------------------- 
sub main {
    my $cmd = shift @ARGV || 'help';
    my $cmd_code = __PACKAGE__->can("CMD_$cmd")
        or die "Unknown command $cmd\n";
    $cmd_code->();
}

# ------------------------------------------------------------------------- 

sub CMD_help {
    pod2usage(-verbose => 2);
}

sub CMD_version {
    print "$VERSION\n";
    exit 0;
}

sub CMD_issues {
    my ($user, $repo) = _get_user_repo_with_current_repo('issues');
    my $res = $pithub->issues->list(user => $user, repo => $repo);
    while ( my $row = $res->next ) {
        printf("#%s %s - %s\n", colored(['green'], $row->{number}), $row->{title}, colored(['Cyan'], $row->{user}->{login}));
        printf("%s\n\n", colored(['white'], $row->{html_url}));
    }
}

sub CMD_info {
    my ($user, $repo) = _get_user_repo('info');
    my $res = $pithub->repos->get(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    dump_content($res->content);
}

sub CMD_clone {
    my $fork;
    if ($ARGV[0] eq '--fork') {
        $fork = 1;
        shift @ARGV;
    }
    my ($user, $repo) = _get_user_repo('clone');
    if ($fork) {
        my $res = $pithub->repos->forks->create(user => $user, repo => $repo);
        $res->success or die dump_content($res->content);
        $user = $me;
    }
    my $res = $pithub->repos->get(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    my $url = $res->content->{ssh_url} or die "Cannot get ssh_url";
    system("git", "clone", $url);
}

sub CMD_fork {
    my ($user, $repo) = _get_user_repo_with_current_repo('fork');
    print("Forking $user/$repo\n");
    my $res = $pithub->repos->forks->create(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    my $ssh_url = $res->content->{ssh_url} // die dump_content($res->content);
    system("git", "remote", "add", $me, $ssh_url);
    system("git remote -v"); # show current settings.
}

sub CMD_pull {
    my ($num) = pop @ARGV;
    my $remote;
    if (@ARGV) {
        $remote = shift @ARGV;
    }
    else {
        my $branch = `git symbolic-ref -q HEAD`;
        chomp $branch;
        $branch ||= 'master';
        $branch =~ s{refs/heads/}{};
        warn $branch;
        $remote = `git config branch.$branch.remote`;
        chomp $remote;
    }
    warn join(" ", "git", "fetch", $remote, "refs/pull/$num/head:pull-$num");
    system("git", "fetch", $remote, "refs/pull/$num/head:pull-$num");
}

sub CMD_pullreq {
    my ($title, $branch, $desc) = splice(@ARGV, 2);
    $title or die "Usage: $0 pullreq tokuhirom ph 'pull req title'\n";
    $branch ||= `git symbolic-ref -q HEAD` || 'master';
    $desc   ||= '';

    my ($user, $repo) = _get_user_repo('clone');
    my $res = $pithub->pull_requests->create(
        user => $user,
        repo => $repo,
        data => {
            title => $title,
            body  => $desc,
            head  => "$me:$branch",
            base  => 'master',
        },
    );
    $res->success or die dump_content($res->content);
}

sub CMD_add {
    my ($user, $repo) = _get_user_repo('clone');
    my $res = $pithub->repos->get(user => $user, repo => $repo);
    $res->success or die dump_content($res->content);
    my $url = $res->content->{ssh_url} or die "Cannot get ssh_url";
    system("git remote add $user $url");
    system("git fetch $user");
}

sub CMD_all {
    my ($user) = shift @ARGV;
    $user or die "Usage: $0 all tokuhirom\n";
    my $res = $pithub->repos->list(user => $user);
    $res->success or die dump_content($res->content);
    $res->auto_pagination(1);
    while (my $row = $res->next) {
        say("-------- $row->{name} --------");
        next if $row->{fork}; # skip forked repos
        next if -e $row->{name};
        system("git", "clone", $row->{ssh_url});
    }
}

sub CMD_import {
    my $remote = 'origin';
    my $homepage = '';
    my $description = '';
    my $private = 0;
    GetOptions(
        'remote=s'      => \$remote,
        'homepage=s'    => \$homepage,
        'description=s' => \$description,
        'private'       => \$private,
    );
    if (`git config --local --get remote.$remote.fetch`) {
        Carp::croak "Remote [$remote] already exists. Try specifying another one using --remote.";
    }

    my $pwd = Cwd::getcwd();
    my $name = File::Basename::basename($pwd);
    exit unless prompt("Can I import $pwd to $name in github? [y/N] ", -yes);
    my $res = $pithub->repos->create(
        data => {
            name        => $name,
            homepage    => $homepage,
            description => $description,
            public      => $private ? 0 : 1,
        }
    );
    $res->success or die dump_content($res->content);
    dump_content($res->content);
    my $ssh_url = $res->content->{ssh_url} // die "Missing ssh_url";

    print "Adding GitHub repo $name as remote [$remote].\n";
    system(qw(git remote add), $remote, $ssh_url);

    if (!`git config --get branch.master.remote`) {
        print "Setting up remote [$remote] for master branch.\n";
        system(qw(git config branch.master.remote), $remote);
        system(qw(git config branch.master.merge refs/heads/master));
        my $rebase = `git config --get branch.autosetuprebase`;
        chomp $rebase;
        if ($rebase && ($rebase eq 'remote' || $rebase eq 'always')) {
            system(qw(git config branch.master.rebase true));
        }
    }

    print "Pushing to remote [$remote]\n";
    system(qw(git push), $remote, qw(master));
    print "Done.\n";
}

# ------------------------------------------------------------------------- 

sub _get_user_repo_simple() {
    my ($repo, $user);
    if (@ARGV==2) {
        ($user, $repo) = @ARGV;
    } elsif (@ARGV==1) {
        if ($ARGV[0] =~ m{/}) {
            ($user, $repo) = split m{/}, $ARGV[0];
        }
        else {
            ($user, $repo) = ($me, $ARGV[0]);
        }
    }
    return ($user, $repo);
}

sub _get_user_repo {
    my ($cmd) = @_;
    my ($user, $repo) = _get_user_repo_simple();
    $user // die "Usage: $0 $cmd miyagawa/Plack\n";
    return ($user, $repo);
}

sub _get_user_repo_with_current_repo {
    my ($cmd) = @_;
    my ($user, $repo) = _get_user_repo_simple();
    unless ($user && $repo) {
        my $remote = `git remote -v`;
        if ($remote =~ m{git://github\.com\/([^/ ]+)\/([^/ ]+)\.git}) {
            ($user, $repo) = ($1, $2);
        } elsif ($remote =~ m{git\@github\.com:([^/]+)/([^/]+)\.git}) {
            ($user, $repo) = ($1, $2);
        } else {
            die "Usage: $0 $cmd plack/Plack\n";
        }
    }
    return ($user, $repo);
}

our $DUMP_DEPTH = 0;
sub dump_content {
    local $DUMP_DEPTH = 0;
    my $c = shift;
    _dump_content($c);
}
sub _dump_content {
    my $c = shift;
    if (ref $c eq 'HASH') {
        for my $key (sort keys %$c) {
            print(' ' x ($DUMP_DEPTH*2));
            print($key . ': ');
            if (ref $c->{$key} eq 'HASH') {
                print("\n");
                local $DUMP_DEPTH = $DUMP_DEPTH + 1;
                _dump_content($c->{$key});
            } else {
                print("$c->{$key}");
                print("\n");
            }
        }
    }
}

# ------------------------------------------------------------------------- 

sub save_auth_result {
    my $res = shift;

    $res->is_success or die $res->as_string;
    my $dat = decode_json($res->content);
    $token = $dat->{token} || die "Cannot get token from API:\n\n" . $res->as_string;
    $token =~ /^[A-Za-z0-9_-]+$/ or die "API token contains bad char: $token";
    {
        no autodie;
        system("git config --global --unset-all ph.user");
        system("git config --global --unset-all ph.token");
    }
    system("git config --global --add ph.user $me") == 0 or die;
    system("git config --global --add ph.token $token") == 0 or die;
}

sub request_basic {
    my ($user, $password, $otp) = @_;
    my $res = $agent->request(
        do {
            my $req = HTTP::Request->new(
                POST => 'https://api.github.com/authorizations'
                # GET => 'https://github.com/login/oauth/authorize?client_id=45ee252fecc56cd85629&scopes=delete_repo,public_repo,repo,gist,user'
            );
            if (defined $otp) {
                $req->header('X-GitHub-OTP' => $otp);
            }
            $req->content(
                encode_json({
                    note   => 'App::ph on ' . Sys::Hostname::hostname,
                    scopes => [qw(delete_repo public_repo repo gist user)],
                })
            );
            $req->authorization_basic($me, $password);
            $req;
        }
    );
    return $res;
}

sub setup {
    say("setup ph. please input your id/pw to this prompt. password will not save to any location.");
    $me = prompt('user: ');
    my $pass = prompt('pass: ', -echo => '*');
    # request with basic auth.
    my $res = request_basic($me, $pass);
    if ($res->is_success) {
        save_auth_result($res);
        return;
    } else {
        if ($res->header('X-GitHub-OTP') =~ 'required') {
            my $otp = prompt('otp for 2-factor authentication: ');
            my $res = request_basic($me, $pass, $otp);
            save_auth_result($res);
            return;
        } else {
            die $res->as_string;
        }
    }
}

__END__

=pod

=head1 NAME

ph - Github CLI client

=head1 SYNOPSIS

    $ ph info mattn gal-vim
    $ ph clone mattn gal-vim
    $ ph import

=head1 DESCRIPTION

ph is yet another Github CLI client.

=head1 SUB COMMANDS

=head2 ph import

    % ph import

This command import current directory to the github.

=head2 ph fork

    % ph fork tokuhirom Minilla

This command forks the repository to your github account.

=head2 ph info

   % ph info mattn gal-vim

This command displays information of the repository.

=head2 ph help

    % ph help

Shows this help page.

=head2 ph all

    % ph all $USERNAME

Clone all repository in your account

=head2 ph version

Show the version number.

=head2 ph issues

    % ph issues

Show list of issues for current project.

