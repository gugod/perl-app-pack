#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Cmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD';
  use strict;
  use warnings;
  use 5.006;
  
  package App::Cmd;
  $App::Cmd::VERSION = '0.330';
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  # ABSTRACT: write command line apps with less suffering
  
  use File::Basename ();
  use Module::Pluggable::Object ();
  use Class::Load ();
  
  use Sub::Exporter -setup => {
    collectors => {
      -ignore  => \'_setup_ignore',
      -command => \'_setup_command',
      -run     => sub {
        warn "using -run to run your command is deprecated\n";
        $_[1]->{class}->run; 1
      },
    },
  };
  
  sub _setup_command {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -command setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    {
      my $base = $self->_default_command_base;
      Class::Load::load_class($base);
      no strict 'refs';
      push @{"$into\::ISA"}, $base;
    }
  
    $self->_register_command($into);
  
    for my $plugin ($self->_plugin_plugins) {
      $plugin->import_from_plugin({ into => $into });
    }
  
    1;
  }
  
  sub _setup_ignore {
    my ($self, $val, $data ) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -ignore setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    $self->_register_ignore($into);
  
    1;
  }
  
  sub _plugin_plugins { return }
  
  #pod =head1 SYNOPSIS
  #pod
  #pod in F<yourcmd>:
  #pod
  #pod   use YourApp;
  #pod   YourApp->run;
  #pod
  #pod in F<YourApp.pm>:
  #pod
  #pod   package YourApp;
  #pod   use App::Cmd::Setup -app;
  #pod   1;
  #pod
  #pod in F<YourApp/Command/blort.pm>:
  #pod
  #pod   package YourApp::Command::blort;
  #pod   use YourApp -command;
  #pod   use strict; use warnings;
  #pod
  #pod   sub abstract { "blortex algorithm" }
  #pod
  #pod   sub description { "Long description on blortex algorithm" }
  #pod
  #pod   sub opt_spec {
  #pod     return (
  #pod       [ "blortex|X",  "use the blortex algorithm" ],
  #pod       [ "recheck|r",  "recheck all results"       ],
  #pod     );
  #pod   }
  #pod
  #pod   sub validate_args {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     # no args allowed but options!
  #pod     $self->usage_error("No args allowed") if @$args;
  #pod   }
  #pod
  #pod   sub execute {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     my $result = $opt->{blortex} ? blortex() : blort();
  #pod
  #pod     recheck($result) if $opt->{recheck};
  #pod
  #pod     print $result;
  #pod   }
  #pod
  #pod and, finally, at the command line:
  #pod
  #pod   knight!rjbs$ yourcmd blort --recheck
  #pod
  #pod   All blorts successful.
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod App::Cmd is intended to make it easy to write complex command-line applications
  #pod without having to think about most of the annoying things usually involved.
  #pod
  #pod For information on how to start using App::Cmd, see L<App::Cmd::Tutorial>.
  #pod
  #pod =method new
  #pod
  #pod   my $cmd = App::Cmd->new(\%arg);
  #pod
  #pod This method returns a new App::Cmd object.  During initialization, command
  #pod plugins will be loaded.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   no_commands_plugin - if true, the command list plugin is not added
  #pod
  #pod   no_help_plugin     - if true, the help plugin is not added
  #pod
  #pod   no_version_plugin  - if true, the version plugin is not added
  #pod
  #pod   show_version_cmd -   if true, the version command will be shown in the
  #pod                        command list
  #pod
  #pod   plugin_search_path - The path to search for commands in. Defaults to
  #pod                        results of plugin_search_path method
  #pod
  #pod If C<no_commands_plugin> is not given, L<App::Cmd::Command::commands> will be
  #pod required, and it will be registered to handle all of its command names not
  #pod handled by other plugins.
  #pod
  #pod If C<no_help_plugin> is not given, L<App::Cmd::Command::help> will be required,
  #pod and it will be registered to handle all of its command names not handled by
  #pod other plugins. B<Note:> "help" is the default command, so if you do not load
  #pod the default help plugin, you should provide your own or override the
  #pod C<default_command> method.
  #pod
  #pod If C<no_version_plugin> is not given, L<App::Cmd::Command::version> will be
  #pod required to show the application's version with command C<--version>. By
  #pod default, the version command is not included in the command list. Pass
  #pod C<show_version_cmd> to include the version command in the list.
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
  
    my $arg0 = $0;
    my $base = File::Basename::basename $arg0;
  
    my $self = {
      command      => $class->_command($arg),
      arg0         => $base,
      full_arg0    => $arg0,
      show_version => $arg->{show_version_cmd} || 0,
    };
  
    bless $self => $class;
  }
  
  # effectively, returns the command-to-plugin mapping guts of a Cmd
  # if called on a class or on a Cmd with no mapping, construct a new hashref
  # suitable for use as the object's mapping
  sub _command {
    my ($self, $arg) = @_;
    return $self->{command} if ref $self and $self->{command};
  
    # TODO _default_command_base can be wrong if people are not using
    # ::Setup and have no ::Command :(
    #
    #  my $want_isa = $self->_default_command_base;
    # -- kentnl, 2010-12
    my $want_isa = 'App::Cmd::Command';
  
    my %plugin;
    for my $plugin ($self->_plugins) {
  
      Class::Load::load_class($plugin);
  
      # relies on either the plugin itself registering as ignored
      # during compile ( use MyApp::Cmd -ignore )
      # or being explicitly registered elsewhere ( blacklisted )
      # via $app_cmd->_register_ignore( $class )
      #  -- kentnl, 2011-09
      next if $self->should_ignore( $plugin );
  
      die "$plugin is not a " . $want_isa
        unless $plugin->isa($want_isa);
  
      next unless $plugin->can("command_names");
  
      foreach my $command (map { lc } $plugin->command_names) {
        die "two plugins for command $command: $plugin and $plugin{$command}\n"
          if exists $plugin{$command};
  
        $plugin{$command} = $plugin;
      }
    }
  
    $self->_load_default_plugin($_, $arg, \%plugin) for qw(commands help version);
  
    if ($self->allow_any_unambiguous_abbrev) {
      # add abbreviations to list of authorized commands
      require Text::Abbrev;
      my %abbrev = Text::Abbrev::abbrev( keys %plugin );
      @plugin{ keys %abbrev } = @plugin{ values %abbrev };
    }
  
    return \%plugin;
  }
  
  # ->_plugins won't be called more than once on any given App::Cmd, but since
  # finding plugins can be a bit expensive, we'll do a lousy cache here.
  # -- rjbs, 2007-10-09
  my %plugins_for;
  sub _plugins {
    my ($self) = @_;
    my $class = ref $self || $self;
  
    return @{ $plugins_for{$class} } if $plugins_for{$class};
  
    my $finder = Module::Pluggable::Object->new(
      search_path => $self->plugin_search_path,
      $self->_module_pluggable_options,
    );
  
    my @plugins = $finder->plugins;
    $plugins_for{$class} = \@plugins;
  
    return @plugins;
  }
  
  sub _register_command {
    my ($self, $cmd_class) = @_;
    $self->_plugins;
  
    my $class = ref $self || $self;
    push @{ $plugins_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $plugins_for{ $class } };
  }
  
  my %ignored_for;
  
  sub should_ignore {
    my ( $self , $cmd_class ) = @_;
    my $class = ref $self || $self;
    for ( @{ $ignored_for{ $class } } ) {
      return 1 if $_ eq $cmd_class;
    }
    return;
  }
  
  sub _register_ignore {
    my ($self, $cmd_class) = @_;
    my $class = ref $self || $self;
    push @{ $ignored_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $ignored_for{ $class } };
  }
  
  sub _module_pluggable_options {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return;
  }
  
  # load one of the stock plugins, unless requested to squash; unlike normal
  # plugin loading, command-to-plugin mapping conflicts are silently ignored
  sub _load_default_plugin {
    my ($self, $plugin_name, $arg, $plugin_href) = @_;
    unless ($arg->{"no_$plugin_name\_plugin"}) {
      my $plugin = "App::Cmd::Command::$plugin_name";
      Class::Load::load_class($plugin);
      for my $command (map { lc } $plugin->command_names) {
        $plugin_href->{$command} ||= $plugin;
      }
    }
  }
  
  #pod =method run
  #pod
  #pod   $cmd->run;
  #pod
  #pod This method runs the application.  If called the class, it will instantiate a
  #pod new App::Cmd object to run.
  #pod
  #pod It determines the requested command (generally by consuming the first
  #pod command-line argument), finds the plugin to handle that command, parses the
  #pod remaining arguments according to that plugin's rules, and runs the plugin.
  #pod
  #pod It passes the contents of the global argument array (C<@ARGV>) to
  #pod L</C<prepare_command>>, but C<@ARGV> is not altered by running an App::Cmd.
  #pod
  #pod =cut
  
  sub run {
    my ($self) = @_;
  
    # We should probably use Class::Default.
    $self = $self->new unless ref $self;
  
    # prepare the command we're going to run...
    my @argv = $self->prepare_args();
    my ($cmd, $opt, @args) = $self->prepare_command(@argv);
  
    # ...and then run it
    $self->execute_command($cmd, $opt, @args);
  }
  
  #pod =method prepare_args
  #pod
  #pod Normally App::Cmd uses C<@ARGV> for its commandline arguments. You can override
  #pod this method to change that behavior for testing or otherwise.
  #pod
  #pod =cut
  
  sub prepare_args {
    my ($self) = @_;
    return scalar(@ARGV)
      ? (@ARGV)
      : (@{$self->default_args});
  }
  
  #pod =method default_args
  #pod
  #pod If C<L</prepare_args>> is not changed and there are no arguments in C<@ARGV>,
  #pod this method is called and should return an arrayref to be used as the arguments
  #pod to the program.  By default, it returns an empty arrayref.
  #pod
  #pod =cut
  
  use constant default_args => [];
  
  #pod =method abstract 
  #pod
  #pod    sub abstract { "command description" }
  #pod
  #pod Defines the command abstract: a short description that will be printed in the
  #pod main command options list.
  #pod
  #pod =method description
  #pod
  #pod    sub description { "Long description" }
  #pod
  #pod Defines a longer command description that will be shown when the user asks for
  #pod help on a specific command.
  #pod
  #pod =method arg0
  #pod
  #pod =method full_arg0
  #pod
  #pod   my $program_name = $app->arg0;
  #pod
  #pod   my $full_program_name = $app->full_arg0;
  #pod
  #pod These methods return the name of the program invoked to run this application.
  #pod This is determined by inspecting C<$0> when the App::Cmd object is
  #pod instantiated, so it's probably correct, but doing weird things with App::Cmd
  #pod could lead to weird values from these methods.
  #pod
  #pod If the program was run like this:
  #pod
  #pod   knight!rjbs$ ~/bin/rpg dice 3d6
  #pod
  #pod Then the methods return:
  #pod
  #pod   arg0      - rpg
  #pod   full_arg0 - /Users/rjbs/bin/rpg
  #pod
  #pod These values are captured when the App::Cmd object is created, so it is safe to
  #pod assign to C<$0> later.
  #pod
  #pod =cut
  
  sub arg0      { $_[0]->{arg0} }
  sub full_arg0 { $_[0]->{full_arg0} }
  
  #pod =method prepare_command
  #pod
  #pod   my ($cmd, $opt, @args) = $app->prepare_command(@ARGV);
  #pod
  #pod This method will load the plugin for the requested command, use its options to
  #pod parse the command line arguments, and eventually return everything necessary to
  #pod actually execute the command.
  #pod
  #pod =cut
  
  sub prepare_command {
    my ($self, @args) = @_;
  
    # figure out first-level dispatch
    my ($command, $opt, @sub_args) = $self->get_command(@args);
  
    # set up the global options (which we just determined)
    $self->set_global_options($opt);
  
    # find its plugin or else call default plugin (default default is help)
    if ($command) {
      $self->_prepare_command($command, $opt, @sub_args);
    } else {
      $self->_prepare_default_command($opt, @sub_args);
    }
  }
  
  sub _prepare_command {
    my ($self, $command, $opt, @args) = @_;
    if (my $plugin = $self->plugin_for($command)) {
      return $plugin->prepare($self, @args);
    } else {
      return $self->_bad_command($command, $opt, @args);
    }
  }
  
  sub _prepare_default_command {
    my ($self, $opt, @sub_args) = @_;
    $self->_prepare_command($self->default_command, $opt, @sub_args);
  }
  
  sub _bad_command {
    my ($self, $command, $opt, @args) = @_;
    print "Unrecognized command: $command.\n\nUsage:\n" if defined($command);
  
    # This should be class data so that, in Bizarro World, two App::Cmds will not
    # conflict.
    our $_bad++;
    $self->prepare_command(qw(commands --stderr));
  }
  
  END { exit 1 if our $_bad };
  
  #pod =method default_command
  #pod
  #pod This method returns the name of the command to run if none is given on the
  #pod command line.  The default default is "help"
  #pod
  #pod =cut
  
  sub default_command { "help" }
  
  #pod =method execute_command
  #pod
  #pod   $app->execute_command($cmd, \%opt, @args);
  #pod
  #pod This method will invoke C<validate_args> and then C<run> on C<$cmd>.
  #pod
  #pod =cut
  
  sub execute_command {
    my ($self, $cmd, $opt, @args) = @_;
  
    local our $active_cmd = $cmd;
  
    $cmd->validate_args($opt, \@args);
    $cmd->execute($opt, \@args);
  }
  
  #pod =method plugin_search_path
  #pod
  #pod This method returns the plugin_search_path as set.  The default implementation,
  #pod if called on "YourApp::Cmd" will return "YourApp::Cmd::Command"
  #pod
  #pod This is a method because it's fun to override it with, for example:
  #pod
  #pod   use constant plugin_search_path => __PACKAGE__;
  #pod
  #pod =cut
  
  sub _default_command_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Command";
  }
  
  sub _default_plugin_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Plugin";
  }
  
  sub plugin_search_path {
    my ($self) = @_;
  
    my $dcb = $self->_default_command_base;
    my $ccb = $dcb eq 'App::Cmd::Command'
            ? $self->App::Cmd::_default_command_base
            : $self->_default_command_base;
  
    my @default = ($ccb, $self->_default_plugin_base);
  
    if (ref $self) {
      return $self->{plugin_search_path} ||= \@default;
    } else {
      return \@default;
    }
  }
  
  #pod =method allow_any_unambiguous_abbrev
  #pod
  #pod If this method returns true (which, by default, it does I<not>), then any
  #pod unambiguous abbreviation for a registered command name will be allowed as a
  #pod means to use that command.  For example, given the following commands:
  #pod
  #pod   reticulate
  #pod   reload
  #pod   rasterize
  #pod
  #pod Then the user could use C<ret> for C<reticulate> or C<ra> for C<rasterize> and
  #pod so on.
  #pod
  #pod =cut
  
  sub allow_any_unambiguous_abbrev { return 0 }
  
  #pod =method global_options
  #pod
  #pod   if ($cmd->app->global_options->{verbose}) { ... }
  #pod
  #pod This method returns the running application's global options as a hashref.  If
  #pod there are no options specified, an empty hashref is returned.
  #pod
  #pod =cut
  
  sub global_options {
  	my $self = shift;
  	return $self->{global_options} ||= {} if ref $self;
    return {};
  }
  
  #pod =method set_global_options
  #pod
  #pod   $app->set_global_options(\%opt);
  #pod
  #pod This method sets the global options.
  #pod
  #pod =cut
  
  sub set_global_options {
    my ($self, $opt) = @_;
    return $self->{global_options} = $opt;
  }
  
  #pod =method command_names
  #pod
  #pod   my @names = $cmd->command_names;
  #pod
  #pod This returns the commands names which the App::Cmd object will handle.
  #pod
  #pod =cut
  
  sub command_names {
    my ($self) = @_;
    keys %{ $self->_command };
  }
  
  #pod =method command_groups
  #pod
  #pod   my @groups = $cmd->commands_groups;
  #pod
  #pod This method can be implemented to return a grouped list of command names with
  #pod optional headers. Each group is given as arrayref and each header as string.
  #pod If an empty list is returned, the commands plugin will show two groups without
  #pod headers: the first group is for the "help" and "commands" commands, and all
  #pod other commands are in the second group.
  #pod
  #pod =cut
  
  sub command_groups { }
  
  #pod =method command_plugins
  #pod
  #pod   my @plugins = $cmd->command_plugins;
  #pod
  #pod This method returns the package names of the plugins that implement the
  #pod App::Cmd object's commands.
  #pod
  #pod =cut
  
  sub command_plugins {
    my ($self) = @_;
    my %seen = map {; $_ => 1 } values %{ $self->_command };
    keys %seen;
  }
  
  #pod =method plugin_for
  #pod
  #pod   my $plugin = $cmd->plugin_for($command);
  #pod
  #pod This method returns the plugin (module) for the given command.  If no plugin
  #pod implements the command, it returns false.
  #pod
  #pod =cut
  
  sub plugin_for {
    my ($self, $command) = @_;
    return unless $command;
    return unless exists $self->_command->{ $command };
  
    return $self->_command->{ $command };
  }
  
  #pod =method get_command
  #pod
  #pod   my ($command_name, $opt, @args) = $app->get_command(@args);
  #pod
  #pod Process arguments and into a command name and (optional) global options.
  #pod
  #pod =cut
  
  sub get_command {
    my ($self, @args) = @_;
  
    my ($opt, $args, %fields)
      = $self->_process_args(\@args, $self->_global_option_processing_params);
  
    # map --help to help command
    if ($opt->{help}) {
        unshift @$args, 'help';
        delete $opt->{help};
    }
  
    my ($command, $rest) = $self->_cmd_from_args($args);
  
    $self->{usage} = $fields{usage};
  
    return ($command, $opt, @$rest);
  }
  
  sub _cmd_from_args {
    my ($self, $args) = @_;
  
    my $command = shift @$args;
    return ($command, $args);
  }
  
  sub _global_option_processing_params {
    my ($self, @args) = @_;
  
    return (
      $self->usage_desc(@args),
      $self->global_opt_spec(@args),
      { getopt_conf => [qw/pass_through/] },
    );
  }
  
  #pod =method usage
  #pod
  #pod   print $self->app->usage->text;
  #pod
  #pod Returns the usage object for the global options.
  #pod
  #pod =cut
  
  sub usage { $_[0]{usage} };
  
  #pod =method usage_desc
  #pod
  #pod The top level usage line. Looks something like
  #pod
  #pod   "yourapp <command> [options]"
  #pod
  #pod =cut
  
  sub usage_desc {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return "%c <command> %o";
  }
  
  #pod =method global_opt_spec
  #pod
  #pod Returns a list with help command unless C<no_help_plugin> has been specified or
  #pod an empty list. Can be overridden for pre-dispatch option processing.  This is
  #pod useful for flags like --verbose.
  #pod
  #pod =cut
  
  sub global_opt_spec {
    my ($self) = @_;
  
    my $cmd = $self->{command};
    my %seen;
    my @help = grep { ! $seen{$_}++ }
               reverse sort map { s/^--?//; $_ }
               grep { $cmd->{$_} eq 'App::Cmd::Command::help' } keys %$cmd;
  
    return (@help ? [ join('|', @help) => "show help" ] : ());
  }
  
  #pod =method usage_error
  #pod
  #pod   $self->usage_error("Something's wrong!");
  #pod
  #pod Used to die with nice usage output, during C<validate_args>.
  #pod
  #pod =cut
  
  sub usage_error {
    my ($self, $error) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    my $text = $self->usage->text;
    $text =~ s/\A(\s+)/!/;
    return $text;
  }
  
  #pod =head1 TODO
  #pod
  #pod =for :list
  #pod * publish and bring in Log::Speak (simple quiet/verbose output)
  #pod * publish and use our internal enhanced describe_options
  #pod * publish and use our improved simple input routines
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd - write command line apps with less suffering
  
  =head1 VERSION
  
  version 0.330
  
  =head1 SYNOPSIS
  
  in F<yourcmd>:
  
    use YourApp;
    YourApp->run;
  
  in F<YourApp.pm>:
  
    package YourApp;
    use App::Cmd::Setup -app;
    1;
  
  in F<YourApp/Command/blort.pm>:
  
    package YourApp::Command::blort;
    use YourApp -command;
    use strict; use warnings;
  
    sub abstract { "blortex algorithm" }
  
    sub description { "Long description on blortex algorithm" }
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ yourcmd blort --recheck
  
    All blorts successful.
  
  =head1 DESCRIPTION
  
  App::Cmd is intended to make it easy to write complex command-line applications
  without having to think about most of the annoying things usually involved.
  
  For information on how to start using App::Cmd, see L<App::Cmd::Tutorial>.
  
  =head1 METHODS
  
  =head2 new
  
    my $cmd = App::Cmd->new(\%arg);
  
  This method returns a new App::Cmd object.  During initialization, command
  plugins will be loaded.
  
  Valid arguments are:
  
    no_commands_plugin - if true, the command list plugin is not added
  
    no_help_plugin     - if true, the help plugin is not added
  
    no_version_plugin  - if true, the version plugin is not added
  
    show_version_cmd -   if true, the version command will be shown in the
                         command list
  
    plugin_search_path - The path to search for commands in. Defaults to
                         results of plugin_search_path method
  
  If C<no_commands_plugin> is not given, L<App::Cmd::Command::commands> will be
  required, and it will be registered to handle all of its command names not
  handled by other plugins.
  
  If C<no_help_plugin> is not given, L<App::Cmd::Command::help> will be required,
  and it will be registered to handle all of its command names not handled by
  other plugins. B<Note:> "help" is the default command, so if you do not load
  the default help plugin, you should provide your own or override the
  C<default_command> method.
  
  If C<no_version_plugin> is not given, L<App::Cmd::Command::version> will be
  required to show the application's version with command C<--version>. By
  default, the version command is not included in the command list. Pass
  C<show_version_cmd> to include the version command in the list.
  
  =head2 run
  
    $cmd->run;
  
  This method runs the application.  If called the class, it will instantiate a
  new App::Cmd object to run.
  
  It determines the requested command (generally by consuming the first
  command-line argument), finds the plugin to handle that command, parses the
  remaining arguments according to that plugin's rules, and runs the plugin.
  
  It passes the contents of the global argument array (C<@ARGV>) to
  L</C<prepare_command>>, but C<@ARGV> is not altered by running an App::Cmd.
  
  =head2 prepare_args
  
  Normally App::Cmd uses C<@ARGV> for its commandline arguments. You can override
  this method to change that behavior for testing or otherwise.
  
  =head2 default_args
  
  If C<L</prepare_args>> is not changed and there are no arguments in C<@ARGV>,
  this method is called and should return an arrayref to be used as the arguments
  to the program.  By default, it returns an empty arrayref.
  
  =head2 abstract 
  
     sub abstract { "command description" }
  
  Defines the command abstract: a short description that will be printed in the
  main command options list.
  
  =head2 description
  
     sub description { "Long description" }
  
  Defines a longer command description that will be shown when the user asks for
  help on a specific command.
  
  =head2 arg0
  
  =head2 full_arg0
  
    my $program_name = $app->arg0;
  
    my $full_program_name = $app->full_arg0;
  
  These methods return the name of the program invoked to run this application.
  This is determined by inspecting C<$0> when the App::Cmd object is
  instantiated, so it's probably correct, but doing weird things with App::Cmd
  could lead to weird values from these methods.
  
  If the program was run like this:
  
    knight!rjbs$ ~/bin/rpg dice 3d6
  
  Then the methods return:
  
    arg0      - rpg
    full_arg0 - /Users/rjbs/bin/rpg
  
  These values are captured when the App::Cmd object is created, so it is safe to
  assign to C<$0> later.
  
  =head2 prepare_command
  
    my ($cmd, $opt, @args) = $app->prepare_command(@ARGV);
  
  This method will load the plugin for the requested command, use its options to
  parse the command line arguments, and eventually return everything necessary to
  actually execute the command.
  
  =head2 default_command
  
  This method returns the name of the command to run if none is given on the
  command line.  The default default is "help"
  
  =head2 execute_command
  
    $app->execute_command($cmd, \%opt, @args);
  
  This method will invoke C<validate_args> and then C<run> on C<$cmd>.
  
  =head2 plugin_search_path
  
  This method returns the plugin_search_path as set.  The default implementation,
  if called on "YourApp::Cmd" will return "YourApp::Cmd::Command"
  
  This is a method because it's fun to override it with, for example:
  
    use constant plugin_search_path => __PACKAGE__;
  
  =head2 allow_any_unambiguous_abbrev
  
  If this method returns true (which, by default, it does I<not>), then any
  unambiguous abbreviation for a registered command name will be allowed as a
  means to use that command.  For example, given the following commands:
  
    reticulate
    reload
    rasterize
  
  Then the user could use C<ret> for C<reticulate> or C<ra> for C<rasterize> and
  so on.
  
  =head2 global_options
  
    if ($cmd->app->global_options->{verbose}) { ... }
  
  This method returns the running application's global options as a hashref.  If
  there are no options specified, an empty hashref is returned.
  
  =head2 set_global_options
  
    $app->set_global_options(\%opt);
  
  This method sets the global options.
  
  =head2 command_names
  
    my @names = $cmd->command_names;
  
  This returns the commands names which the App::Cmd object will handle.
  
  =head2 command_groups
  
    my @groups = $cmd->commands_groups;
  
  This method can be implemented to return a grouped list of command names with
  optional headers. Each group is given as arrayref and each header as string.
  If an empty list is returned, the commands plugin will show two groups without
  headers: the first group is for the "help" and "commands" commands, and all
  other commands are in the second group.
  
  =head2 command_plugins
  
    my @plugins = $cmd->command_plugins;
  
  This method returns the package names of the plugins that implement the
  App::Cmd object's commands.
  
  =head2 plugin_for
  
    my $plugin = $cmd->plugin_for($command);
  
  This method returns the plugin (module) for the given command.  If no plugin
  implements the command, it returns false.
  
  =head2 get_command
  
    my ($command_name, $opt, @args) = $app->get_command(@args);
  
  Process arguments and into a command name and (optional) global options.
  
  =head2 usage
  
    print $self->app->usage->text;
  
  Returns the usage object for the global options.
  
  =head2 usage_desc
  
  The top level usage line. Looks something like
  
    "yourapp <command> [options]"
  
  =head2 global_opt_spec
  
  Returns a list with help command unless C<no_help_plugin> has been specified or
  an empty list. Can be overridden for pre-dispatch option processing.  This is
  useful for flags like --verbose.
  
  =head2 usage_error
  
    $self->usage_error("Something's wrong!");
  
  Used to die with nice usage output, during C<validate_args>.
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  publish and bring in Log::Speak (simple quiet/verbose output)
  
  =item *
  
  publish and use our internal enhanced describe_options
  
  =item *
  
  publish and use our improved simple input routines
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Adam Prime ambs Andreas Hernitscheck A. Sinan Unur Chris 'BinGOs' Williams David Golden Steinbrunner Denis Ibaev Diab Jerius Glenn Fowler Ingy dot Net Jakob Voss Jérôme Quelin John SJ Anderson Karen Etheridge Kent Fredric Matthew Astley mokko Olivier Mengué Ricardo SIGNES Ryan C. Thompson Salvatore Bonaccorso Sergey Romanov Stephen Caldwell Yuval Kogman
  
  =over 4
  
  =item *
  
  Adam Prime <aprime@oanda.com>
  
  =item *
  
  ambs <ambs@cpan.org>
  
  =item *
  
  Andreas Hernitscheck <andreash@lxhe.(none)>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Denis Ibaev <dionys@gmail.com>
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Ingy dot Net <ingy@ingy.net>
  
  =item *
  
  Jakob Voss <jakob@nichtich.de>
  
  =item *
  
  Jakob Voss <voss@gbv.de>
  
  =item *
  
  Jérôme Quelin <jquelin@gmail.com>
  
  =item *
  
  John SJ Anderson <genehack@genehack.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Matthew Astley <mca@sanger.ac.uk>
  
  =item *
  
  mokko <mauricemengel@gmail.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =item *
  
  Ryan C. Thompson <rct@thompsonclan.org>
  
  =item *
  
  Salvatore Bonaccorso <carnil@debian.org>
  
  =item *
  
  Sergey Romanov <sromanov-dev@yandex.ru>
  
  =item *
  
  Stephen Caldwell <steve@campusexplorer.com>
  
  =item *
  
  Yuval Kogman <nuffin@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD

$fatpacked{"App/Cmd/ArgProcessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_ARGPROCESSOR';
  use strict;
  use warnings;
  
  package App::Cmd::ArgProcessor;
  $App::Cmd::ArgProcessor::VERSION = '0.330';
  # ABSTRACT: App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  sub _process_args {
    my ($class, $args, @params) = @_;
    local @ARGV = @$args;
  
    require Getopt::Long::Descriptive;
    Getopt::Long::Descriptive->VERSION(0.084);
  
    my ($opt, $usage) = Getopt::Long::Descriptive::describe_options(@params);
  
    return (
      $opt,
      [ @ARGV ], # whatever remained
      usage => $usage,
    );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::ArgProcessor - App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  =head1 VERSION
  
  version 0.330
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_ARGPROCESSOR

$fatpacked{"App/Cmd/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND';
  use strict;
  use warnings;
  
  package App::Cmd::Command;
  $App::Cmd::Command::VERSION = '0.330';
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  
  # ABSTRACT: a base class for App::Cmd commands
  
  use Carp ();
  
  #pod =method prepare
  #pod
  #pod   my ($cmd, $opt, $args) = $class->prepare($app, @args);
  #pod
  #pod This method is the primary way in which App::Cmd::Command objects are built.
  #pod Given the remaining command line arguments meant for the command, it returns
  #pod the Command object, parsed options (as a hashref), and remaining arguments (as
  #pod an arrayref).
  #pod
  #pod In the usage above, C<$app> is the App::Cmd object that is invoking the
  #pod command.
  #pod
  #pod =cut
  
  sub prepare {
    my ($class, $app, @args) = @_;
  
    my ($opt, $args, %fields)
      = $class->_process_args(\@args, $class->_option_processing_params($app));
  
    return (
      $class->new({ app => $app, %fields }),
      $opt,
      @$args,
    );
  }
  
  sub _option_processing_params {
    my ($class, @args) = @_;
  
    return (
      $class->usage_desc(@args),
      $class->opt_spec(@args),
    );
  }
  
  #pod =method new
  #pod
  #pod This returns a new instance of the command plugin.  Probably only C<prepare>
  #pod should use this.
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
    bless $arg => $class;
  }
  
  #pod =method execute
  #pod
  #pod   $command_plugin->execute(\%opt, \@args);
  #pod
  #pod This method does whatever it is the command should do!  It is passed a hash
  #pod reference of the parsed command-line options and an array reference of left
  #pod over arguments.
  #pod
  #pod If no C<execute> method is defined, it will try to call C<run> -- but it will
  #pod warn about this behavior during testing, to remind you to fix the method name!
  #pod
  #pod =cut
  
  sub execute {
    my $class = shift;
  
    if (my $run = $class->can('run')) {
      warn "App::Cmd::Command subclasses should implement ->execute not ->run"
        if $ENV{HARNESS_ACTIVE};
  
      return $class->$run(@_);
    }
  
    Carp::croak ref($class) . " does not implement mandatory method 'execute'\n";
  }
  
  #pod =method app
  #pod
  #pod This method returns the App::Cmd object into which this command is plugged.
  #pod
  #pod =cut
  
  sub app { $_[0]->{app}; }
  
  #pod =method usage
  #pod
  #pod This method returns the usage object for this command.  (See
  #pod L<Getopt::Long::Descriptive>).
  #pod
  #pod =cut
  
  sub usage { $_[0]->{usage}; }
  
  #pod =method command_names
  #pod
  #pod This method returns a list of command names handled by this plugin. The
  #pod first item returned is the 'canonical' name of the command.
  #pod
  #pod If this method is not overridden by an App::Cmd::Command subclass, it will
  #pod return the last part of the plugin's package name, converted to lowercase.
  #pod For example, YourApp::Cmd::Command::Init will, by default, handle the command
  #pod "init".
  #pod
  #pod Subclasses should generally get the superclass value of C<command_names>
  #pod and then append aliases.
  #pod
  #pod =cut
  
  sub command_names {
    # from UNIVERSAL::moniker
    (ref( $_[0] ) || $_[0]) =~ /([^:]+)$/;
    return lc $1;
  }
  
  #pod =method usage_desc
  #pod
  #pod This method should be overridden to provide a usage string.  (This is the first
  #pod argument passed to C<describe_options> from Getopt::Long::Descriptive.)
  #pod
  #pod If not overridden, it returns "%c COMMAND %o";  COMMAND is the first item in
  #pod the result of the C<command_names> method.
  #pod
  #pod =cut
  
  sub usage_desc {
    my ($self) = @_;
  
    my ($command) = $self->command_names;
    return "%c $command %o"
  }
  
  #pod =method opt_spec
  #pod
  #pod This method should be overridden to provide option specifications.  (This is
  #pod list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  #pod after the first.)
  #pod
  #pod If not overridden, it returns an empty list.
  #pod
  #pod =cut
  
  sub opt_spec {
    return;
  }
  
  #pod =method validate_args
  #pod
  #pod   $command_plugin->validate_args(\%opt, \@args);
  #pod
  #pod This method is passed a hashref of command line options (as processed by
  #pod Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  #pod an exception (preferably by calling C<usage_error>, below) if they are invalid,
  #pod or it may do nothing to allow processing to continue.
  #pod
  #pod =cut
  
  sub validate_args { }
  
  #pod =method usage_error
  #pod
  #pod   $self->usage_error("This command must not be run by root!");
  #pod
  #pod This method should be called to die with human-friendly usage output, during
  #pod C<validate_args>.
  #pod
  #pod =cut
  
  sub usage_error {
    my ( $self, $error ) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    local $@;
    join "\n", eval { $self->app->_usage_text }, eval { $self->usage->text };
  }
  
  #pod =method abstract
  #pod
  #pod This method returns a short description of the command's purpose.  If this
  #pod method is not overridden, it will return the abstract from the module's Pod.
  #pod If it can't find the abstract, it will look for a comment starting with
  #pod "ABSTRACT:" like the ones used by L<Pod::Weaver::Section::Name>.
  #pod
  #pod =cut
  
  # stolen from ExtUtils::MakeMaker
  sub abstract {
    my ($class) = @_;
    $class = ref $class if ref $class;
  
    my $result;
    my $weaver_abstract;
  
    # classname to filename
    (my $pm_file = $class) =~ s!::!/!g;
    $pm_file .= '.pm';
    $pm_file = $INC{$pm_file} or return "(unknown)";
  
    # if the pm file exists, open it and parse it
    open my $fh, "<", $pm_file or return "(unknown)";
  
    local $/ = "\n";
    my $inpod;
  
    while (local $_ = <$fh>) {
      # =cut toggles, it doesn't end :-/
      $inpod = /^=cut/ ? !$inpod : $inpod || /^=(?!cut)/;
  
      if (/#+\s*ABSTRACT: (.*)/){
        # takes ABSTRACT: ... if no POD defined yet
        $weaver_abstract = $1;
      }
  
      next unless $inpod;
      chomp;
  
      next unless /^(?:$class\s-\s)(.*)/;
  
      $result = $1;
      last;
    }
  
    return $result || $weaver_abstract || "(unknown)";
  }
  
  #pod =method description
  #pod
  #pod This method can be overridden to provide full option description. It
  #pod is used by the built-in L<help|App::Cmd::Command::help> command.
  #pod
  #pod If not overridden, it uses L<Pod::Usage> to extract the description
  #pod from the module's Pod DESCRIPTION section or the empty string.
  #pod
  #pod =cut
  
  sub description {
      my ($class) = @_;
      $class = ref $class if ref $class;
  
      # classname to filename
      (my $pm_file = $class) =~ s!::!/!g;
      $pm_file .= '.pm';
      $pm_file = $INC{$pm_file} or return '';
  
      open my $input, "<", $pm_file or return '';
  
      my $descr = "";
      open my $output, ">", \$descr;
  
      require Pod::Usage;
      Pod::Usage::pod2usage( -input => $input,
                 -output => $output,
                 -exit => "NOEXIT", 
                 -verbose => 99,
                 -sections => "DESCRIPTION",
                 indent => 0
      );
      $descr =~ s/Description:\n//m;
      chomp $descr;
  
      return $descr;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command - a base class for App::Cmd commands
  
  =head1 VERSION
  
  version 0.330
  
  =head1 METHODS
  
  =head2 prepare
  
    my ($cmd, $opt, $args) = $class->prepare($app, @args);
  
  This method is the primary way in which App::Cmd::Command objects are built.
  Given the remaining command line arguments meant for the command, it returns
  the Command object, parsed options (as a hashref), and remaining arguments (as
  an arrayref).
  
  In the usage above, C<$app> is the App::Cmd object that is invoking the
  command.
  
  =head2 new
  
  This returns a new instance of the command plugin.  Probably only C<prepare>
  should use this.
  
  =head2 execute
  
    $command_plugin->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  If no C<execute> method is defined, it will try to call C<run> -- but it will
  warn about this behavior during testing, to remind you to fix the method name!
  
  =head2 app
  
  This method returns the App::Cmd object into which this command is plugged.
  
  =head2 usage
  
  This method returns the usage object for this command.  (See
  L<Getopt::Long::Descriptive>).
  
  =head2 command_names
  
  This method returns a list of command names handled by this plugin. The
  first item returned is the 'canonical' name of the command.
  
  If this method is not overridden by an App::Cmd::Command subclass, it will
  return the last part of the plugin's package name, converted to lowercase.
  For example, YourApp::Cmd::Command::Init will, by default, handle the command
  "init".
  
  Subclasses should generally get the superclass value of C<command_names>
  and then append aliases.
  
  =head2 usage_desc
  
  This method should be overridden to provide a usage string.  (This is the first
  argument passed to C<describe_options> from Getopt::Long::Descriptive.)
  
  If not overridden, it returns "%c COMMAND %o";  COMMAND is the first item in
  the result of the C<command_names> method.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $command_plugin->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>, below) if they are invalid,
  or it may do nothing to allow processing to continue.
  
  =head2 usage_error
  
    $self->usage_error("This command must not be run by root!");
  
  This method should be called to die with human-friendly usage output, during
  C<validate_args>.
  
  =head2 abstract
  
  This method returns a short description of the command's purpose.  If this
  method is not overridden, it will return the abstract from the module's Pod.
  If it can't find the abstract, it will look for a comment starting with
  "ABSTRACT:" like the ones used by L<Pod::Weaver::Section::Name>.
  
  =head2 description
  
  This method can be overridden to provide full option description. It
  is used by the built-in L<help|App::Cmd::Command::help> command.
  
  If not overridden, it uses L<Pod::Usage> to extract the description
  from the module's Pod DESCRIPTION section or the empty string.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND

$fatpacked{"App/Cmd/Command/commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_COMMANDS';
  use strict;
  use warnings;
  
  package App::Cmd::Command::commands;
  $App::Cmd::Command::commands::VERSION = '0.330';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' };
  
  # ABSTRACT: list the application's commands
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will list all of the application commands available and their
  #pod abstracts.
  #pod
  #pod =method execute
  #pod
  #pod This is the command's primary method and raison d'etre.  It prints the
  #pod application's usage text (if any) followed by a sorted listing of the
  #pod application's commands and their abstracts.
  #pod
  #pod The commands are printed in sorted groups (created by C<sort_commands>); each
  #pod group is set off by blank lines.
  #pod
  #pod =cut
  
  sub execute {
    my ($self, $opt, $args) = @_;
  
    my $target = $opt->stderr ? *STDERR : *STDOUT;
   
    my @cmd_groups = $self->app->command_groups;
    my @primary_commands = map { @$_ if ref $_ } @cmd_groups;
  
    if (!@cmd_groups) {
      @primary_commands =
        grep { $_ ne 'version' or $self->app->{show_version} }
        map { ($_->command_names)[0] }
        $self->app->command_plugins;
  
      @cmd_groups = $self->sort_commands(@primary_commands);
    }
  
    my $fmt_width = 0;
    for (@primary_commands) { $fmt_width = length if length > $fmt_width }
    $fmt_width += 2; # pretty
  
    foreach my $cmd_set (@cmd_groups) {
      if (!ref $cmd_set) {
        print { $target } "$cmd_set:\n";
        next;
      }
      for my $command (@$cmd_set) {
        my $abstract = $self->app->plugin_for($command)->abstract;
        printf { $target } "%${fmt_width}s: %s\n", $command, $abstract;
      }
      print { $target } "\n";
    }
  }
  
  #pod =method C<sort_commands>
  #pod
  #pod   my @sorted = $cmd->sort_commands(@unsorted);
  #pod
  #pod This method orders the list of commands into groups which it returns as a list of
  #pod arrayrefs, and optional group header strings.
  #pod
  #pod By default, the first group is for the "help" and "commands" commands, and all
  #pod other commands are in the second group.
  #pod
  #pod This method can be overridden by implementing the C<commands_groups> method in
  #pod your application base clase.
  #pod
  #pod =cut
  
  sub sort_commands {
    my ($self, @commands) = @_;
  
    my $float = qr/^(?:help|commands)$/;
  
    my @head = sort grep { $_ =~ $float } @commands;
    my @tail = sort grep { $_ !~ $float } @commands;
  
    return (\@head, \@tail);
  }
  
  sub opt_spec {
    return (
      [ 'stderr' => 'hidden' ],
    );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::commands - list the application's commands
  
  =head1 VERSION
  
  version 0.330
  
  =head1 DESCRIPTION
  
  This command will list all of the application commands available and their
  abstracts.
  
  =head1 METHODS
  
  =head2 execute
  
  This is the command's primary method and raison d'etre.  It prints the
  application's usage text (if any) followed by a sorted listing of the
  application's commands and their abstracts.
  
  The commands are printed in sorted groups (created by C<sort_commands>); each
  group is set off by blank lines.
  
  =head2 C<sort_commands>
  
    my @sorted = $cmd->sort_commands(@unsorted);
  
  This method orders the list of commands into groups which it returns as a list of
  arrayrefs, and optional group header strings.
  
  By default, the first group is for the "help" and "commands" commands, and all
  other commands are in the second group.
  
  This method can be overridden by implementing the C<commands_groups> method in
  your application base clase.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_COMMANDS

$fatpacked{"App/Cmd/Command/help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_HELP';
  use strict;
  use warnings;
  
  package App::Cmd::Command::help;
  $App::Cmd::Command::help::VERSION = '0.330';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display a command's help screen
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will either list all of the application commands and their
  #pod abstracts, or display the usage screen for a subcommand with its
  #pod description.
  #pod
  #pod =head1 USAGE
  #pod
  #pod The help text is generated from three sources:
  #pod
  #pod =for :list
  #pod * The C<usage_desc> method
  #pod * The C<description> method
  #pod * The C<opt_spec> data structure
  #pod
  #pod The C<usage_desc> method provides the opening usage line, following the
  #pod specification described in L<Getopt::Long::Descriptive>.  In some cases,
  #pod the default C<usage_desc> in L<App::Cmd::Command> may be sufficient and
  #pod you will only need to override it to provide additional command line
  #pod usage information.
  #pod
  #pod The C<opt_spec> data structure is used with L<Getopt::Long::Descriptive>
  #pod to generate the description of the options.
  #pod
  #pod Subcommand classes should override the C<discription> method to provide
  #pod additional information that is prepended before the option descriptions.
  #pod
  #pod For example, consider the following subcommand module:
  #pod
  #pod   package YourApp::Command::initialize;
  #pod
  #pod   # This is the default from App::Cmd::Command
  #pod   sub usage_desc {
  #pod     my ($self) = @_;
  #pod     my $desc = $self->SUPER::usage_desc; # "%c COMMAND %o"
  #pod     return "$desc [DIRECTORY]";
  #pod   }
  #pod
  #pod   sub description {
  #pod     return "The initialize command prepares the application...";
  #pod   }
  #pod
  #pod   sub opt_spec {
  #pod     return (
  #pod       [ "skip-refs|R",  "skip reference checks during init", ],
  #pod       [ "values|v=s@",  "starting values", { default => [ 0, 1, 3 ] } ],
  #pod     );
  #pod   }
  #pod
  #pod   ...
  #pod
  #pod That module would generate help output like this:
  #pod
  #pod   $ yourapp help initialize
  #pod   yourapp initialize [-Rv] [long options...] [DIRECTORY]
  #pod
  #pod   The initialize command prepares the application...
  #pod
  #pod         --help            This usage screen
  #pod         -R --skip-refs    skip reference checks during init
  #pod         -v --values       starting values
  #pod
  #pod =cut
  
  sub usage_desc { '%c help [subcommand]' }
  
  sub command_names { qw/help --help -h -?/ }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    if (!@$args) {
      print $self->app->usage->text . "\n";
  
      print "Available commands:\n\n";
  
      $self->app->execute_command( $self->app->_prepare_command("commands") );
    } else {
      my ($cmd, $opt, $args) = $self->app->prepare_command(@$args);
  
      local $@;
      my $desc = $cmd->description;
      $desc = "\n$desc" if length $desc;
  
      my $ut = join "\n",
        eval { $cmd->usage->leader_text },
        $desc,
        eval { $cmd->usage->option_text };
  
      print "$ut\n";
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::help - display a command's help screen
  
  =head1 VERSION
  
  version 0.330
  
  =head1 DESCRIPTION
  
  This command will either list all of the application commands and their
  abstracts, or display the usage screen for a subcommand with its
  description.
  
  =head1 USAGE
  
  The help text is generated from three sources:
  
  =over 4
  
  =item *
  
  The C<usage_desc> method
  
  =item *
  
  The C<description> method
  
  =item *
  
  The C<opt_spec> data structure
  
  =back
  
  The C<usage_desc> method provides the opening usage line, following the
  specification described in L<Getopt::Long::Descriptive>.  In some cases,
  the default C<usage_desc> in L<App::Cmd::Command> may be sufficient and
  you will only need to override it to provide additional command line
  usage information.
  
  The C<opt_spec> data structure is used with L<Getopt::Long::Descriptive>
  to generate the description of the options.
  
  Subcommand classes should override the C<discription> method to provide
  additional information that is prepended before the option descriptions.
  
  For example, consider the following subcommand module:
  
    package YourApp::Command::initialize;
  
    # This is the default from App::Cmd::Command
    sub usage_desc {
      my ($self) = @_;
      my $desc = $self->SUPER::usage_desc; # "%c COMMAND %o"
      return "$desc [DIRECTORY]";
    }
  
    sub description {
      return "The initialize command prepares the application...";
    }
  
    sub opt_spec {
      return (
        [ "skip-refs|R",  "skip reference checks during init", ],
        [ "values|v=s@",  "starting values", { default => [ 0, 1, 3 ] } ],
      );
    }
  
    ...
  
  That module would generate help output like this:
  
    $ yourapp help initialize
    yourapp initialize [-Rv] [long options...] [DIRECTORY]
  
    The initialize command prepares the application...
  
          --help            This usage screen
          -R --skip-refs    skip reference checks during init
          -v --values       starting values
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_HELP

$fatpacked{"App/Cmd/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_VERSION';
  use strict;
  use warnings;
  
  package App::Cmd::Command::version;
  $App::Cmd::Command::version::VERSION = '0.330';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display an app's version
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will display the program name, its base class
  #pod with version number, and the full program name.
  #pod
  #pod =cut
  
  sub command_names { qw/version --version/ }
  
  sub version_for_display {
    $_[0]->version_package->VERSION
  }
  
  sub version_package {
    ref($_[0]->app)
  }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    printf "%s (%s) version %s (%s)\n",
      $self->app->arg0, $self->version_package,
      $self->version_for_display, $self->app->full_arg0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::version - display an app's version
  
  =head1 VERSION
  
  version 0.330
  
  =head1 DESCRIPTION
  
  This command will display the program name, its base class
  with version number, and the full program name.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_VERSION

$fatpacked{"App/Cmd/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_PLUGIN';
  use strict;
  use warnings;
  package App::Cmd::Plugin;
  $App::Cmd::Plugin::VERSION = '0.330';
  # ABSTRACT: a plugin for App::Cmd commands
  
  sub _faux_curried_method {
    my ($class, $name, $arg) = @_;
  
    return sub {
      my $cmd = $App::Cmd::active_cmd;
      $class->$name($cmd, @_);
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Plugin - a plugin for App::Cmd commands
  
  =head1 VERSION
  
  version 0.330
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_PLUGIN

$fatpacked{"App/Cmd/Setup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SETUP';
  use strict;
  use warnings;
  package App::Cmd::Setup;
  $App::Cmd::Setup::VERSION = '0.330';
  # ABSTRACT: helper for setting up App::Cmd classes
  
  #pod =head1 OVERVIEW
  #pod
  #pod App::Cmd::Setup is a helper library, used to set up base classes that will be
  #pod used as part of an App::Cmd program.  For the most part you should refer to
  #pod L<the tutorial|App::Cmd::Tutorial> for how you should use this library.
  #pod
  #pod This class is useful in three scenarios:
  #pod
  #pod =begin :list
  #pod
  #pod = when writing your App::Cmd subclass
  #pod
  #pod Instead of writing:
  #pod
  #pod   package MyApp;
  #pod   use base 'App::Cmd';
  #pod
  #pod ...you can write:
  #pod
  #pod   package MyApp;
  #pod   use App::Cmd::Setup -app;
  #pod
  #pod The benefits of doing this are mostly minor, and relate to sanity-checking your
  #pod class.  The significant benefit is that this form allows you to specify
  #pod plugins, as in:
  #pod
  #pod   package MyApp;
  #pod   use App::Cmd::Setup -app => { plugins => [ 'Prompt' ] };
  #pod
  #pod Plugins are described in L<App::Cmd::Tutorial> and L<App::Cmd::Plugin>.
  #pod
  #pod = when writing abstract base classes for commands
  #pod
  #pod That is: when you write a subclass of L<App::Cmd::Command> that is intended for
  #pod other commands to use as their base class, you should use App::Cmd::Setup.  For
  #pod example, if you want all the commands in MyApp to inherit from MyApp::Command,
  #pod you may want to write that package like this:
  #pod
  #pod   package MyApp::Command;
  #pod   use App::Cmd::Setup -command;
  #pod
  #pod Do not confuse this with the way you will write specific commands:
  #pod
  #pod   package MyApp::Command::mycmd;
  #pod   use MyApp -command;
  #pod
  #pod Again, this form mostly performs some validation and setup behind the scenes
  #pod for you.  You can use C<L<base>> if you prefer.
  #pod
  #pod = when writing App::Cmd plugins
  #pod
  #pod L<App::Cmd::Plugin> is a mechanism that allows an App::Cmd class to inject code
  #pod into all its command classes, providing them with utility routines.
  #pod
  #pod To write a plugin, you must use App::Cmd::Setup.  As seen above, you must also
  #pod use App::Cmd::Setup to set up your App::Cmd subclass if you wish to consume
  #pod plugins.
  #pod
  #pod For more information on writing plugins, see L<App::Cmd::Manual> and
  #pod L<App::Cmd::Plugin>.
  #pod
  #pod =end :list
  #pod
  #pod =cut
  
  use App::Cmd ();
  use App::Cmd::Command ();
  use App::Cmd::Plugin ();
  use Carp ();
  use Data::OptList ();
  use String::RewritePrefix ();
  
  # 0.06 is needed for load_optional_class
  use Class::Load 0.06 qw();
  
  use Sub::Exporter -setup => {
    -as     => '_import',
    exports => [ qw(foo) ],
    collectors => [
      -app     => \'_make_app_class',
      -command => \'_make_command_class',
      -plugin  => \'_make_plugin_class',
    ],
  };
  
  sub import {
    goto &_import;
  }
  
  sub _app_base_class { 'App::Cmd' }
  
  sub _make_app_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    $val ||= {};
    Carp::confess "invalid argument to -app setup"
      if grep { $_ ne 'plugins' } keys %$val;
  
    Carp::confess "app setup requested on App::Cmd subclass $into"
      if $into->isa('App::Cmd');
  
    $self->_make_x_isa_y($into, $self->_app_base_class);
  
    if ( ! Class::Load::load_optional_class( $into->_default_command_base ) ) {
      my $base = $self->_command_base_class;
      Sub::Install::install_sub({
        code => sub { $base },
        into => $into,
        as   => '_default_command_base',
      });
    }
  
    # TODO Check this is right. -- kentnl, 2010-12
    #
    #  my $want_plugin_base = $self->_plugin_base_class;
    my $want_plugin_base = 'App::Cmd::Plugin';
  
    my @plugins;
    for my $plugin (@{ $val->{plugins} || [] }) {
      $plugin = String::RewritePrefix->rewrite(
        {
          ''  => 'App::Cmd::Plugin::',
          '=' => ''
        },
        $plugin,
      );
      Class::Load::load_class( $plugin );
      unless( $plugin->isa( $want_plugin_base ) ){
          die "$plugin is not a " . $want_plugin_base;
      }
      push @plugins, $plugin;
    }
  
    Sub::Install::install_sub({
      code => sub { @plugins },
      into => $into,
      as   => '_plugin_plugins',
    });
  
    return 1;
  }
  
  sub _command_base_class { 'App::Cmd::Command' }
  
  sub _make_command_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "command setup requested on App::Cmd::Command subclass $into"
      if $into->isa('App::Cmd::Command');
  
    $self->_make_x_isa_y($into, $self->_command_base_class);
  
    return 1;
  }
  
  sub _make_x_isa_y {
    my ($self, $x, $y) = @_;
  
    no strict 'refs';
    push @{"$x\::ISA"}, $y;
  }
  
  sub _plugin_base_class { 'App::Cmd::Plugin' }
  sub _make_plugin_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "plugin setup requested on App::Cmd::Plugin subclass $into"
      if $into->isa('App::Cmd::Plugin');
  
    Carp::confess "plugin setup requires plugin configuration" unless $val;
  
    $self->_make_x_isa_y($into, $self->_plugin_base_class);
  
    # In this special case, exporting everything by default is the sensible thing
    # to do. -- rjbs, 2008-03-31
    $val->{groups} = [ default => [ -all ] ] unless $val->{groups};
  
    my @exports;
    for my $pair (@{ Data::OptList::mkopt($val->{exports}) }) {
      push @exports, $pair->[0], ($pair->[1] || \'_faux_curried_method');
    }
  
    $val->{exports} = \@exports;
  
    Sub::Exporter::setup_exporter({
      %$val,
      into => $into,
      as   => 'import_from_plugin',
    });
  
    return 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Setup - helper for setting up App::Cmd classes
  
  =head1 VERSION
  
  version 0.330
  
  =head1 OVERVIEW
  
  App::Cmd::Setup is a helper library, used to set up base classes that will be
  used as part of an App::Cmd program.  For the most part you should refer to
  L<the tutorial|App::Cmd::Tutorial> for how you should use this library.
  
  This class is useful in three scenarios:
  
  =over 4
  
  =item when writing your App::Cmd subclass
  
  Instead of writing:
  
    package MyApp;
    use base 'App::Cmd';
  
  ...you can write:
  
    package MyApp;
    use App::Cmd::Setup -app;
  
  The benefits of doing this are mostly minor, and relate to sanity-checking your
  class.  The significant benefit is that this form allows you to specify
  plugins, as in:
  
    package MyApp;
    use App::Cmd::Setup -app => { plugins => [ 'Prompt' ] };
  
  Plugins are described in L<App::Cmd::Tutorial> and L<App::Cmd::Plugin>.
  
  =item when writing abstract base classes for commands
  
  That is: when you write a subclass of L<App::Cmd::Command> that is intended for
  other commands to use as their base class, you should use App::Cmd::Setup.  For
  example, if you want all the commands in MyApp to inherit from MyApp::Command,
  you may want to write that package like this:
  
    package MyApp::Command;
    use App::Cmd::Setup -command;
  
  Do not confuse this with the way you will write specific commands:
  
    package MyApp::Command::mycmd;
    use MyApp -command;
  
  Again, this form mostly performs some validation and setup behind the scenes
  for you.  You can use C<L<base>> if you prefer.
  
  =item when writing App::Cmd plugins
  
  L<App::Cmd::Plugin> is a mechanism that allows an App::Cmd class to inject code
  into all its command classes, providing them with utility routines.
  
  To write a plugin, you must use App::Cmd::Setup.  As seen above, you must also
  use App::Cmd::Setup to set up your App::Cmd subclass if you wish to consume
  plugins.
  
  For more information on writing plugins, see L<App::Cmd::Manual> and
  L<App::Cmd::Plugin>.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SETUP

$fatpacked{"App/Cmd/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SIMPLE';
  use strict;
  use warnings;
  
  package App::Cmd::Simple;
  $App::Cmd::Simple::VERSION = '0.330';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' }
  
  # ABSTRACT: a helper for building one-command App::Cmd applications
  
  use App::Cmd;
  use Sub::Install;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod in F<simplecmd>:
  #pod
  #pod   use YourApp::Cmd;
  #pod   Your::Cmd->run;
  #pod
  #pod in F<YourApp/Cmd.pm>:
  #pod
  #pod   package YourApp::Cmd;
  #pod   use base qw(App::Cmd::Simple);
  #pod
  #pod   sub opt_spec {
  #pod     return (
  #pod       [ "blortex|X",  "use the blortex algorithm" ],
  #pod       [ "recheck|r",  "recheck all results"       ],
  #pod     );
  #pod   }
  #pod
  #pod   sub validate_args {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     # no args allowed but options!
  #pod     $self->usage_error("No args allowed") if @$args;
  #pod   }
  #pod
  #pod   sub execute {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     my $result = $opt->{blortex} ? blortex() : blort();
  #pod
  #pod     recheck($result) if $opt->{recheck};
  #pod
  #pod     print $result;
  #pod   }
  #pod
  #pod and, finally, at the command line:
  #pod
  #pod   knight!rjbs$ simplecmd --recheck
  #pod
  #pod   All blorts successful.
  #pod
  #pod =head1 SUBCLASSING
  #pod
  #pod When writing a subclass of App::Cmd:Simple, there are only a few methods that
  #pod you might want to implement.  They behave just like the same-named methods in
  #pod App::Cmd.
  #pod
  #pod =head2 opt_spec
  #pod
  #pod This method should be overridden to provide option specifications.  (This is
  #pod list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  #pod after the first.)
  #pod
  #pod If not overridden, it returns an empty list.
  #pod
  #pod =head2 validate_args
  #pod
  #pod   $cmd->validate_args(\%opt, \@args);
  #pod
  #pod This method is passed a hashref of command line options (as processed by
  #pod Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  #pod an exception (preferably by calling C<usage_error>) if they are invalid, or it
  #pod may do nothing to allow processing to continue.
  #pod
  #pod =head2 execute
  #pod
  #pod   Your::App::Cmd::Simple->execute(\%opt, \@args);
  #pod
  #pod This method does whatever it is the command should do!  It is passed a hash
  #pod reference of the parsed command-line options and an array reference of left
  #pod over arguments.
  #pod
  #pod =cut
  
  # The idea here is that the user will someday replace "Simple" in his ISA with
  # "Command" and then write a standard App::Cmd package.  To make that possible,
  # we produce a behind-the-scenes App::Cmd object when the user says 'use
  # MyApp::Simple' and redirect MyApp::Simple->run to that.
  my $i;
  BEGIN { $i = 0 }
  
  sub import {
    my ($class) = @_;
    return if $class eq __PACKAGE__;
  
    # This signals that something has already set the target up.
    return $class if $class->_cmd_pkg;
  
    my $core_execute = App::Cmd::Command->can('execute');
    my $our_execute  = $class->can('execute');
    Carp::confess(
      "App::Cmd::Simple subclasses must implement ->execute, not ->run"
    ) unless $our_execute and $our_execute != $core_execute;
  
    # I doubt the $i will ever be needed, but let's start paranoid.
    my $generated_name = join('::', $class, '_App_Cmd', $i++);
  
    {
      no strict 'refs';
      *{$generated_name . '::ISA'} = [ 'App::Cmd' ];
    }
  
    Sub::Install::install_sub({
      into => $class,
      as   => '_cmd_pkg',
      code => sub { $generated_name },
    });
  
    Sub::Install::install_sub({
        into => $class,
        as => 'command_names',
        code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_plugins',
      code => sub { $class },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => 'default_command',
      code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_cmd_from_args',
      code => sub {
        my ($self, $args) = @_;
        if (defined(my $command = $args->[0])) {
          my $plugin = $self->plugin_for($command);
          # If help was requested, show the help for the command, not the
          # main help. Because the main help would talk about subcommands,
          # and a "Simple" app has no subcommands.
          if ($plugin and $plugin eq $self->plugin_for("help")) {
            return ($command, [ $self->default_command ]);
          }
          # Any other value for "command" isn't really a command at all --
          # it's the first argument. So call the default command instead.
        }
        return ($self->default_command, $args);
      },
    });
  
    Sub::Install::install_sub({
      into => $class,
      as   => 'run',
      code => sub {
        $generated_name->new({
          no_help_plugin     => 0,
          no_commands_plugin => 1,
        })->run(@_);
      }
    });
  
    return $class;
  }
  
  sub usage_desc {
    return "%c %o"
  }
  
  sub _cmd_pkg { }
  
  #pod =head1 WARNINGS
  #pod
  #pod B<This should be considered experimental!>  Although it is probably not going
  #pod to change much, don't build your business model around it yet, okay?
  #pod
  #pod App::Cmd::Simple is not rich in black magic, but it does do some somewhat
  #pod gnarly things to make an App::Cmd::Simple look as much like an
  #pod App::Cmd::Command as possible.  This means that you can't deviate too much from
  #pod the sort of thing shown in the synopsis as you might like.  If you're doing
  #pod something other than writing a fairly simple command, and you want to screw
  #pod around with the App::Cmd-iness of your program, Simple might not be the best
  #pod choice.
  #pod
  #pod B<One specific warning...>  if you are writing a program with the
  #pod App::Cmd::Simple class embedded in it, you B<must> call import on the class.
  #pod That's how things work.  You can just do this:
  #pod
  #pod   YourApp::Cmd->import->run;
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Simple - a helper for building one-command App::Cmd applications
  
  =head1 VERSION
  
  version 0.330
  
  =head1 SYNOPSIS
  
  in F<simplecmd>:
  
    use YourApp::Cmd;
    Your::Cmd->run;
  
  in F<YourApp/Cmd.pm>:
  
    package YourApp::Cmd;
    use base qw(App::Cmd::Simple);
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ simplecmd --recheck
  
    All blorts successful.
  
  =head1 SUBCLASSING
  
  When writing a subclass of App::Cmd:Simple, there are only a few methods that
  you might want to implement.  They behave just like the same-named methods in
  App::Cmd.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $cmd->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>) if they are invalid, or it
  may do nothing to allow processing to continue.
  
  =head2 execute
  
    Your::App::Cmd::Simple->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  =head1 WARNINGS
  
  B<This should be considered experimental!>  Although it is probably not going
  to change much, don't build your business model around it yet, okay?
  
  App::Cmd::Simple is not rich in black magic, but it does do some somewhat
  gnarly things to make an App::Cmd::Simple look as much like an
  App::Cmd::Command as possible.  This means that you can't deviate too much from
  the sort of thing shown in the synopsis as you might like.  If you're doing
  something other than writing a fairly simple command, and you want to screw
  around with the App::Cmd-iness of your program, Simple might not be the best
  choice.
  
  B<One specific warning...>  if you are writing a program with the
  App::Cmd::Simple class embedded in it, you B<must> call import on the class.
  That's how things work.  You can just do this:
  
    YourApp::Cmd->import->run;
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SIMPLE

$fatpacked{"App/Cmd/Subdispatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SUBDISPATCH';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch;
  $App::Cmd::Subdispatch::VERSION = '0.330';
  use App::Cmd;
  use App::Cmd::Command;
  BEGIN { our @ISA = qw(App::Cmd::Command App::Cmd) } 
  
  # ABSTRACT: an App::Cmd::Command that is also an App::Cmd
  
  #pod =method new
  #pod
  #pod A hackish new that allows us to have an Command instance before they normally
  #pod exist.
  #pod
  #pod =cut
  
  sub new {
  	my ($inv, $fields, @args) = @_;
  	if (ref $inv) {
  		@{ $inv }{ keys %$fields } = values %$fields;
  		return $inv;
  	} else {
  		$inv->SUPER::new($fields, @args);
  	}
  }
  
  #pod =method prepare
  #pod
  #pod   my $subcmd = $subdispatch->prepare($app, @args);
  #pod
  #pod An overridden version of L<App::Cmd::Command/prepare> that performs a new
  #pod dispatch cycle.
  #pod
  #pod =cut
  
  sub prepare {
  	my ($class, $app, @args) = @_;
  
  	my $self = $class->new({ app => $app });
  
  	my ($subcommand, $opt, @sub_args) = $self->get_command(@args);
  
    $self->set_global_options($opt);
  
  	if (defined $subcommand) {
      return $self->_prepare_command($subcommand, $opt, @sub_args);
    } else {
      if (@args) {
        return $self->_bad_command(undef, $opt, @sub_args);
      } else {
        return $self->_prepare_default_command($opt, @sub_args);
      }
    }
  }
  
  sub _plugin_prepare {
    my ($self, $plugin, @args) = @_;
    return $plugin->prepare($self->choose_parent_app($self->app, $plugin), @args);
  }
  
  #pod =method app
  #pod
  #pod   $subdispatch->app;
  #pod
  #pod This method returns the application that this subdispatch is a command of.
  #pod
  #pod =cut
  
  sub app { $_[0]{app} }
  
  #pod =method choose_parent_app
  #pod
  #pod   $subcmd->prepare(
  #pod     $subdispatch->choose_parent_app($app, $opt, $plugin),
  #pod     @$args
  #pod   );
  #pod
  #pod A method that chooses whether the parent app or the subdispatch is going to be
  #pod C<< $cmd->app >>.
  #pod
  #pod =cut
  
  sub choose_parent_app {
  	my ( $self, $app, $plugin ) = @_;
  
  	if (
      $plugin->isa("App::Cmd::Command::commands")
      or $plugin->isa("App::Cmd::Command::help")
      or scalar keys %{ $self->global_options }
    ) {
  		return $self;
  	} else {
  		return $app;
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Subdispatch - an App::Cmd::Command that is also an App::Cmd
  
  =head1 VERSION
  
  version 0.330
  
  =head1 METHODS
  
  =head2 new
  
  A hackish new that allows us to have an Command instance before they normally
  exist.
  
  =head2 prepare
  
    my $subcmd = $subdispatch->prepare($app, @args);
  
  An overridden version of L<App::Cmd::Command/prepare> that performs a new
  dispatch cycle.
  
  =head2 app
  
    $subdispatch->app;
  
  This method returns the application that this subdispatch is a command of.
  
  =head2 choose_parent_app
  
    $subcmd->prepare(
      $subdispatch->choose_parent_app($app, $opt, $plugin),
      @$args
    );
  
  A method that chooses whether the parent app or the subdispatch is going to be
  C<< $cmd->app >>.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SUBDISPATCH

$fatpacked{"App/Cmd/Subdispatch/DashedStyle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SUBDISPATCH_DASHEDSTYLE';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch::DashedStyle;
  $App::Cmd::Subdispatch::DashedStyle::VERSION = '0.330';
  use App::Cmd::Subdispatch;
  BEGIN { our @ISA = 'App::Cmd::Subdispatch' };
  
  # ABSTRACT: "app cmd --subcmd" style subdispatching
  
  #pod =method get_command
  #pod
  #pod   my ($subcommand, $opt, $args) = $subdispatch->get_command(@args)
  #pod
  #pod A version of get_command that chooses commands as options in the following
  #pod style:
  #pod
  #pod   mytool mycommand --mysubcommand
  #pod
  #pod =cut
  
  sub get_command {
  	my ($self, @args) = @_;
  
  	my (undef, $opt, @sub_args)
      = $self->App::Cmd::Command::prepare($self->app, @args);
  
  	if (my $cmd = delete $opt->{subcommand}) {
  		delete $opt->{$cmd}; # useless boolean
  		return ($cmd, $opt, @sub_args);
  	} else {
      return (undef, $opt, @sub_args);
    }
  }
  
  #pod =method opt_spec
  #pod
  #pod A version of C<opt_spec> that calculates the getopt specification from the
  #pod subcommands.
  #pod
  #pod =cut
  
  sub opt_spec {
  	my ($self, $app) = @_;
  
  	my $subcommands = $self->_command;
  	my %plugins = map {
  		$_ => [ $_->command_names ],
  	} values %$subcommands;
  
  	foreach my $opt_spec (values %plugins) {
  		$opt_spec = join("|", grep { /^\w/ } @$opt_spec);
  	}
  
  	my @subcommands = map { [ $plugins{$_} =>  $_->abstract ] } keys %plugins;
  
  	return (
  		[ subcommand => hidden => { one_of => \@subcommands } ],
  		$self->global_opt_spec($app),
  		{ getopt_conf => [ 'pass_through' ] },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Subdispatch::DashedStyle - "app cmd --subcmd" style subdispatching
  
  =head1 VERSION
  
  version 0.330
  
  =head1 METHODS
  
  =head2 get_command
  
    my ($subcommand, $opt, $args) = $subdispatch->get_command(@args)
  
  A version of get_command that chooses commands as options in the following
  style:
  
    mytool mycommand --mysubcommand
  
  =head2 opt_spec
  
  A version of C<opt_spec> that calculates the getopt specification from the
  subcommands.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SUBDISPATCH_DASHEDSTYLE

$fatpacked{"App/Cmd/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_TESTER';
  use strict;
  use warnings;
  package App::Cmd::Tester;
  $App::Cmd::Tester::VERSION = '0.330';
  # ABSTRACT: for capturing the result of running an app
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Test::More tests => 4;
  #pod   use App::Cmd::Tester;
  #pod
  #pod   use YourApp;
  #pod
  #pod   my $result = test_app(YourApp => [ qw(command --opt value) ]);
  #pod
  #pod   like($result->stdout, qr/expected output/, 'printed what we expected');
  #pod
  #pod   is($result->stderr, '', 'nothing sent to sderr');
  #pod
  #pod   is($result->error, undef, 'threw no exceptions');
  #pod
  #pod   my $result = test_app(YourApp => [ qw(command --opt value --quiet) ]);
  #pod
  #pod   is($result->output, '', 'absolutely no output with --quiet');
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod One of the reasons that user-executed programs are so often poorly tested is
  #pod that they are hard to test.  App::Cmd::Tester is one of the tools App-Cmd
  #pod provides to help make it easy to test App::Cmd-based programs.
  #pod
  #pod It provides one routine: test_app.
  #pod
  #pod =method test_app
  #pod
  #pod B<Note>: while C<test_app> is a method, it is by default exported as a
  #pod subroutine into the namespace that uses App::Cmd::Tester.  In other words: you
  #pod probably don't need to think about this as a method unless you want to subclass
  #pod App::Cmd::Tester.
  #pod
  #pod   my $result = test_app($app_class => \@argv_contents);
  #pod
  #pod This will locally set C<@ARGV> to simulate command line arguments, and will
  #pod then call the C<run> method on the given application class (or application).
  #pod Output to the standard output and standard error filehandles  will be captured.
  #pod
  #pod C<$result> is an App::Cmd::Tester::Result object, which has methods to access
  #pod the following data:
  #pod
  #pod   stdout - the output sent to stdout
  #pod   stderr - the output sent to stderr
  #pod   output - the combined output of stdout and stderr
  #pod   error  - the exception thrown by running the application, or undef
  #pod   run_rv - the return value of the run method (generally irrelevant)
  #pod   exit_code - the numeric exit code that would've been issued (0 is 'okay')
  #pod
  #pod =cut
  
  use Sub::Exporter::Util qw(curry_method);
  use Sub::Exporter -setup => {
    exports => { test_app => curry_method },
    groups  => { default  => [ qw(test_app) ] },
  };
  
  our $TEST_IN_PROGRESS;
  BEGIN {
    *CORE::GLOBAL::exit = sub {
      my ($rc) = @_;
      return CORE::exit($rc) unless $TEST_IN_PROGRESS;
      App::Cmd::Tester::Exited->throw($rc);
    };
  }
  
  #pod =for Pod::Coverage result_class
  #pod
  #pod =cut
  
  sub result_class { 'App::Cmd::Tester::Result' }
  
  sub test_app {
    my ($class, $app, $argv) = @_;
  
    local $App::Cmd::_bad = 0;
  
    $app = $app->new unless ref($app) or $app->isa('App::Cmd::Simple');
  
    my $result = $class->_run_with_capture($app, $argv);
  
    my $error = $result->{error};
  
    my $exit_code = defined $error ? ((0+$!)||-1) : 0;
  
    if ($error and eval { $error->isa('App::Cmd::Tester::Exited') }) {
      $exit_code = $$error;
    }
  
    $exit_code =1 if $App::Cmd::_bad && ! $exit_code;
  
    $class->result_class->new({
      app    => $app,
      exit_code => $exit_code,
      %$result,
    });
  }
  
  sub _run_with_capture {
    my ($class, $app, $argv) = @_;
  
    require IO::TieCombine;
    my $hub = IO::TieCombine->new;
  
    my $stdout = tie local *STDOUT, $hub, 'stdout';
    my $stderr = tie local *STDERR, $hub, 'stderr';
  
    my $run_rv;
  
    my $ok = eval {
      local $TEST_IN_PROGRESS = 1;
      local @ARGV = @$argv;
      $run_rv = $app->run;
      1;
    };
  
    my $error = $ok ? undef : $@;
  
    return {
      stdout => $hub->slot_contents('stdout'),
      stderr => $hub->slot_contents('stderr'),
      output => $hub->combined_contents,
      error  => $error,
      run_rv => $run_rv,
    };
  }
  
  {
    package App::Cmd::Tester::Result;
  $App::Cmd::Tester::Result::VERSION = '0.330';
  sub new {
      my ($class, $arg) = @_;
      bless $arg => $class;
    }
  
    for my $attr (qw(app stdout stderr output error run_rv exit_code)) {
      Sub::Install::install_sub({
        code => sub { $_[0]->{$attr} },
        as   => $attr,
      });
    }
  }
  
  {
    package App::Cmd::Tester::Exited;
  $App::Cmd::Tester::Exited::VERSION = '0.330';
  sub throw {
      my ($class, $code) = @_;
      $code = 0 unless defined $code;
      my $self = (bless \$code => $class);
      die $self;
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Tester - for capturing the result of running an app
  
  =head1 VERSION
  
  version 0.330
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    is($result->error, undef, 'threw no exceptions');
  
    my $result = test_app(YourApp => [ qw(command --opt value --quiet) ]);
  
    is($result->output, '', 'absolutely no output with --quiet');
  
  =head1 DESCRIPTION
  
  One of the reasons that user-executed programs are so often poorly tested is
  that they are hard to test.  App::Cmd::Tester is one of the tools App-Cmd
  provides to help make it easy to test App::Cmd-based programs.
  
  It provides one routine: test_app.
  
  =head1 METHODS
  
  =head2 test_app
  
  B<Note>: while C<test_app> is a method, it is by default exported as a
  subroutine into the namespace that uses App::Cmd::Tester.  In other words: you
  probably don't need to think about this as a method unless you want to subclass
  App::Cmd::Tester.
  
    my $result = test_app($app_class => \@argv_contents);
  
  This will locally set C<@ARGV> to simulate command line arguments, and will
  then call the C<run> method on the given application class (or application).
  Output to the standard output and standard error filehandles  will be captured.
  
  C<$result> is an App::Cmd::Tester::Result object, which has methods to access
  the following data:
  
    stdout - the output sent to stdout
    stderr - the output sent to stderr
    output - the combined output of stdout and stderr
    error  - the exception thrown by running the application, or undef
    run_rv - the return value of the run method (generally irrelevant)
    exit_code - the numeric exit code that would've been issued (0 is 'okay')
  
  =for Pod::Coverage result_class
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_TESTER

$fatpacked{"App/Cmd/Tester/CaptureExternal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_TESTER_CAPTUREEXTERNAL';
  use strict;
  use warnings;
  package App::Cmd::Tester::CaptureExternal;
  $App::Cmd::Tester::CaptureExternal::VERSION = '0.330';
  use parent 'App::Cmd::Tester';
  use Capture::Tiny 0.13 qw/capture/;
  
  # ABSTRACT: Extends App::Cmd::Tester to capture from external subprograms
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Test::More tests => 4;
  #pod   use App::Cmd::Tester::CaptureExternal;
  #pod
  #pod   use YourApp;
  #pod
  #pod   my $result = test_app(YourApp => [ qw(command --opt value) ]);
  #pod
  #pod   like($result->stdout, qr/expected output/, 'printed what we expected');
  #pod
  #pod   is($result->stderr, '', 'nothing sent to sderr');
  #pod
  #pod   ok($result->output, "STDOUT concatenated with STDERR");
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod L<App::Cmd::Tester> provides a useful scaffold for testing applications, but it
  #pod is unable to capture output generated from any external subprograms that are
  #pod invoked from the application.
  #pod
  #pod This subclass uses an alternate mechanism for capturing output
  #pod (L<Capture::Tiny>) that does capture from external programs, with one
  #pod major limitation.
  #pod
  #pod It is not possible to capture externally from both STDOUT and STDERR while
  #pod also having appropriately interleaved combined output.  Therefore, the
  #pod C<output> from this subclass simply concatenates the two.
  #pod
  #pod You can still use C<output> for testing if there is any output at all or for
  #pod testing if something appeared in either output stream, but you can't rely on
  #pod the ordering being correct between lines to STDOUT and lines to STDERR.
  #pod
  #pod =cut
  
  sub _run_with_capture {
    my ($class, $app, $argv) = @_;
  
    my $run_rv;
  
    my ($stdout, $stderr, $ok) = capture {
      eval {
        local $App::Cmd::Tester::TEST_IN_PROGRESS = 1;
        local @ARGV = @$argv;
        $run_rv = $app->run;
        1;
      };
    };
  
    my $error = $ok ? undef : $@;
  
    return {
      stdout => $stdout,
      stderr => $stderr,
      output => $stdout . $stderr,
      error  => $error,
      run_rv => $run_rv,
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Tester::CaptureExternal - Extends App::Cmd::Tester to capture from external subprograms
  
  =head1 VERSION
  
  version 0.330
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester::CaptureExternal;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    ok($result->output, "STDOUT concatenated with STDERR");
  
  =head1 DESCRIPTION
  
  L<App::Cmd::Tester> provides a useful scaffold for testing applications, but it
  is unable to capture output generated from any external subprograms that are
  invoked from the application.
  
  This subclass uses an alternate mechanism for capturing output
  (L<Capture::Tiny>) that does capture from external programs, with one
  major limitation.
  
  It is not possible to capture externally from both STDOUT and STDERR while
  also having appropriately interleaved combined output.  Therefore, the
  C<output> from this subclass simply concatenates the two.
  
  You can still use C<output> for testing if there is any output at all or for
  testing if something appeared in either output stream, but you can't rely on
  the ordering being correct between lines to STDOUT and lines to STDERR.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_TESTER_CAPTUREEXTERNAL

$fatpacked{"Class/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD';
  use strict;
  use warnings;
  package Class::Load; # git description: v0.22-9-g29ebb54
  # ABSTRACT: A working (require "Class::Name") and more
  # KEYWORDS: class module load require use runtime
  
  our $VERSION = '0.23';
  
  use base 'Exporter';
  use Data::OptList ();
  use Module::Implementation 0.04;
  use Module::Runtime 0.012 ();
  use Try::Tiny;
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => ['is_class_loaded'],
      );
  
      $loader->();
  }
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  sub load_class {
      my $class   = shift;
      my $options = shift;
  
      my ($res, $e) = try_load_class($class, $options);
      return $class if $res;
  
      _croak($e);
  }
  
  sub load_first_existing_class {
      my $classes = Data::OptList::mkopt(\@_)
          or return;
  
      foreach my $class (@{$classes}) {
          Module::Runtime::check_module_name($class->[0]);
      }
  
      for my $class (@{$classes}) {
          my ($name, $options) = @{$class};
  
          # We need to be careful not to pass an undef $options to this sub,
          # since the XS version will blow up if that happens.
          return $name if is_class_loaded($name, ($options ? $options : ()));
  
          my ($res, $e) = try_load_class($name, $options);
  
          return $name if $res;
  
          my $file = Module::Runtime::module_notional_filename($name);
  
          next if $e =~ /^Can't locate \Q$file\E in \@INC/;
          next
              if $options
                  && defined $options->{-version}
                  && $e =~ _version_fail_re($name, $options->{-version});
  
          _croak("Couldn't load class ($name) because: $e");
      }
  
      my @list = map {
          $_->[0]
              . ( $_->[1] && defined $_->[1]{-version}
              ? " (version >= $_->[1]{-version})"
              : q{} )
      } @{$classes};
  
      my $err
          .= q{Can't locate }
          . _or_list(@list)
          . " in \@INC (\@INC contains: @INC).";
      _croak($err);
  }
  
  sub _version_fail_re {
      my $name = shift;
      my $vers = shift;
  
      return qr/\Q$name\E version \Q$vers\E required--this is only version/;
  }
  
  sub _nonexistent_fail_re {
      my $name = shift;
  
      my $file = Module::Runtime::module_notional_filename($name);
      return qr/Can't locate \Q$file\E in \@INC/;
  }
  
  sub _or_list {
      return $_[0] if @_ == 1;
  
      return join ' or ', @_ if @_ ==2;
  
      my $last = pop;
  
      my $list = join ', ', @_;
      $list .= ', or ' . $last;
  
      return $list;
  }
  
  sub load_optional_class {
      my $class   = shift;
      my $options = shift;
  
      Module::Runtime::check_module_name($class);
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      return 0
          if $options
              && defined $options->{-version}
              && $e =~ _version_fail_re($class, $options->{-version});
  
      return 0
          if $e =~ _nonexistent_fail_re($class);
  
      _croak($e);
  }
  
  sub try_load_class {
      my $class   = shift;
      my $options = shift;
  
      Module::Runtime::check_module_name($class);
  
      local $@;
      undef $ERROR;
  
      if (is_class_loaded($class)) {
          # We need to check this here rather than in is_class_loaded() because
          # we want to return the error message for a failed version check, but
          # is_class_loaded just returns true/false.
          return 1 unless $options && defined $options->{-version};
          return try {
              $class->VERSION($options->{-version});
              1;
          }
          catch {
              _error($_);
          };
      }
  
      my $file = Module::Runtime::module_notional_filename($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and that's a win-win.
      delete $INC{$file};
      return try {
          local $SIG{__DIE__} = 'DEFAULT';
          if ($options && defined $options->{-version}) {
              Module::Runtime::use_module($class, $options->{-version});
          }
          else {
              Module::Runtime::require_module($class);
          }
          1;
      }
      catch {
          _error($_);
      };
  }
  
  sub _error {
      my $e = shift;
  
      $e =~ s/ at .+?Runtime\.pm line [0-9]+\.$//;
      chomp $e;
  
      $ERROR = $e;
      return 0 unless wantarray;
      return 0, $ERROR;
  }
  
  sub _croak {
      require Carp;
      local $Carp::CarpLevel = $Carp::CarpLevel + 2;
      Carp::croak(shift);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load - A working (require "Class::Name") and more
  
  =head1 VERSION
  
  version 0.23
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name, \%options
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  The C<%options> hash currently accepts one key, C<-version>. If you specify a
  version, then this subroutine will call C<< Class::Name->VERSION(
  $options{-version} ) >> internally, which will throw an error if the class's
  version is not equal to or greater than the version you requested.
  
  This method will return the name of the class on success.
  
  =head2 try_load_class Class::Name, \%options -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 is_class_loaded Class::Name, \%options -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 load_first_existing_class Class::Name, \%options, ...
  
  This attempts to load the first loadable class in the list of classes
  given. Each class name can be followed by an options hash reference.
  
  If any one of the classes loads and passes the optional version check, that
  class name will be returned. If I<none> of the classes can be loaded (or none
  pass their version check), then an error will be thrown.
  
  If, when attempting to load a class, it fails to load because of a syntax
  error, then an error will be thrown immediately.
  
  =head2 load_optional_class Class::Name, \%options -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1. If you specify a
  version in C<%options>, then the version check must succeed or it will return
  0.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  (e.g.: a syntax error), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, i.e.:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 CAVEATS
  
  Because of some of the heuristics that this module uses to infer whether a
  module has been loaded, some false positives may occur in C<is_class_loaded>
  checks (which are also performed internally in other interfaces) -- if a class
  has started to be loaded but then dies, it may appear that it has already been
  loaded, which can cause other things to make the wrong decision.
  L<Module::Runtime> doesn't have this issue, but it also doesn't do some things
  that this module does -- for example gracefully handle packages that have been
  defined inline in the same file as another package.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://blog.fox.geek.nz/2010/11/searching-design-spec-for-ultimate.html>
  
  This blog post is a good overview of the current state of the existing modules
  for loading other modules in various ways.
  
  =item L<http://blog.fox.geek.nz/2010/11/handling-optional-requirements-with.html>
  
  This blog post describes how to handle optional modules with L<Class::Load>.
  
  =item L<http://d.hatena.ne.jp/tokuhirom/20110202/1296598578>
  
  This Japanese blog post describes why L<DBIx::Skinny> now uses L<Class::Load>
  over its competitors.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =item L<Module::Runtime>
  
  A leaner approach to loading modules
  
  =back
  
  =head1 AUTHOR
  
  Shawn M Moore <sartak at bestpractical.com>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dave Rolsky Shawn Moore Karen Etheridge M Jesse Luehrs Kent Fredric Caleb Cushing
  
  =over 4
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Shawn Moore <sartak@bestpractical.com>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Shawn M Moore <sartak@bestpractical.com>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Caleb Cushing <xenoterracide@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by Shawn M Moore.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD_PP';
  use strict;
  use warnings;
  package Class::Load::PP;
  
  our $VERSION = '0.23';
  
  use Module::Runtime ();
  use Package::Stash 0.14;
  use Scalar::Util ();
  use Try::Tiny;
  
  sub is_class_loaded {
      my $class   = shift;
      my $options = shift;
  
      my $loaded = _is_class_loaded($class);
  
      return $loaded if ! $loaded;
      return $loaded unless $options && $options->{-version};
  
      return try {
          $class->VERSION($options->{-version});
          1;
      }
      catch {
          0;
      };
  }
  
  sub _is_class_loaded {
      my $class = shift;
  
      return 0 unless Module::Runtime::is_module_name($class);
  
      my $stash = Package::Stash->new($class);
  
      if ($stash->has_symbol('$VERSION')) {
          my $version = ${ $stash->get_symbol('$VERSION') };
          if (defined $version) {
              return 1 if ! ref $version;
              # Sometimes $VERSION ends up as a reference to undef (weird)
              return 1 if ref $version && Scalar::Util::reftype $version eq 'SCALAR' && defined ${$version};
              # a version object
              return 1 if Scalar::Util::blessed $version;
          }
      }
  
      if ($stash->has_symbol('@ISA')) {
          return 1 if @{ $stash->get_symbol('@ISA') };
      }
  
      # check for any method
      return 1 if $stash->list_all_symbols('CODE');
  
      # fail
      return 0;
  }
  
  1;
CLASS_LOAD_PP

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  {
    $Data::OptList::VERSION = '0.109';
  }
  # ABSTRACT: parse and validate simple name/value option pairs
  
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub __is_a {
    my ($got, $expected) = @_;
  
    return List::Util::first { __is_a($got, $_) } @$expected if ref $expected;
  
    return defined (
      exists($test_for{$expected})
      ? $test_for{$expected}->($got)
      : Params::Util::_INSTANCE($got, $expected) ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my $name_test;
  
    if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
      my $arg = $_[0];
      ($moniker, $require_unique, $must_be, $name_test)
        = @$arg{ qw(moniker require_unique must_be name_test) };
    } else {
      ($moniker, $require_unique, $must_be) = @_;
    }
  
    $moniker = 'unnamed' unless defined $moniker;
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
      my $value;
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      if    ($i == $#$opt_list)               { $value = undef;            }
      elsif (not defined $opt_list->[$i+1])   { $value = undef; $i++       }
      elsif ($name_test->($opt_list->[$i+1])) { $value = undef;            }
      else                                    { $value = $opt_list->[++$i] }
  
      if ($must_be and defined $value) {
        unless (__is_a($value, $must_be)) {
          my $ref = ref $value;
          Carp::croak "$ref-ref values are not valid in $moniker opt list";
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.109
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;
  
  use strict;
  use Exporter 5.57 'import';
  use vars qw($VERSION @EXPORT_OK);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '0.4';
  @EXPORT_OK = qw(list_packages);
  
  =pod
  
  =head1 NAME
  
  Devel::InnerPackage - find all the inner packages of a package
  
  =head1 SYNOPSIS
  
      use Foo::Bar;
      use Devel::InnerPackage qw(list_packages);
  
      my @inner_packages = list_packages('Foo::Bar');
  
  
  =head1 DESCRIPTION
  
  
  Given a file like this
  
  
      package Foo::Bar;
  
      sub foo {}
  
  
      package Foo::Bar::Quux;
  
      sub quux {}
  
      package Foo::Bar::Quirka;
  
      sub quirka {}
  
      1;
  
  then
  
      list_packages('Foo::Bar');
  
  will return
  
      Foo::Bar::Quux
      Foo::Bar::Quirka
  
  =head1 METHODS
  
  =head2 list_packages <package name>
  
  Return a list of all inner packages of that package.
  
  =cut
  
  sub list_packages {
              my $pack = shift; $pack .= "::" unless $pack =~ m!::$!;
  
              no strict 'refs';
              my @packs;
              my @stuff = grep !/^(main|)::$/, keys %{$pack};
              for my $cand (grep /::$/, @stuff)
              {
                  $cand =~ s!::$!!;
                  my @children = list_packages($pack.$cand);
      
                  push @packs, "$pack$cand" unless $cand =~ /^::/ ||
                      !__PACKAGE__->_loaded($pack.$cand); # or @children;
                  push @packs, @children;
              }
              return grep {$_ !~ /::(::ISA::CACHE|SUPER)/} @packs;
  }
  
  ### XXX this is an inlining of the Class-Inspector->loaded()
  ### method, but inlined to remove the dependency.
  sub _loaded {
         my ($class, $name) = @_;
  
          no strict 'refs';
  
         # Handle by far the two most common cases
         # This is very fast and handles 99% of cases.
         return 1 if defined ${"${name}::VERSION"};
         return 1 if @{"${name}::ISA"};
  
         # Are there any symbol table entries other than other namespaces
         foreach ( keys %{"${name}::"} ) {
                 next if substr($_, -2, 2) eq '::';
                 return 1 if defined &{"${name}::$_"};
         }
  
         # No functions, and it doesn't have a version, and isn't anything.
         # As an absolute last resort, check for an entry in %INC
         my $filename = join( '/', split /(?:'|::)/, $name ) . '.pm';
         return 1 if defined $INC{$filename};
  
         '';
  }
  
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2005 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =cut 
  
  
  
  
  
  1;
DEVEL_INNERPACKAGE

$fatpacked{"Dist/Zilla.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA';
  package Dist::Zilla 6.007;
  # ABSTRACT: distribution builder; installer not included!
  
  use Moose 0.92; # role composition fixes
  with 'Dist::Zilla::Role::ConfigDumper';
  
  # This comment has fün̈n̈ÿ characters.
  
  use MooseX::Types::Moose qw(ArrayRef Bool HashRef Object Str);
  use MooseX::Types::Perl qw(DistName LaxVersionStr);
  use Moose::Util::TypeConstraints;
  
  use Dist::Zilla::Types qw(Path License ReleaseStatus);
  
  use Log::Dispatchouli 1.100712; # proxy_loggers, quiet_fatal
  use Dist::Zilla::Path;
  use List::Util 1.33 qw(first none);
  use Software::License 0.101370; # meta2_name
  use String::RewritePrefix;
  use Try::Tiny;
  
  use Dist::Zilla::Prereqs;
  use Dist::Zilla::File::OnDisk;
  use Dist::Zilla::Role::Plugin;
  use Dist::Zilla::Util;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Dist::Zilla builds distributions of code to be uploaded to the CPAN.  In this
  #pod respect, it is like L<ExtUtils::MakeMaker>, L<Module::Build>, or
  #pod L<Module::Install>.  Unlike those tools, however, it is not also a system for
  #pod installing code that has been downloaded from the CPAN.  Since it's only run by
  #pod authors, and is meant to be run on a repository checkout rather than on
  #pod published, released code, it can do much more than those tools, and is free to
  #pod make much more ludicrous demands in terms of prerequisites.
  #pod
  #pod If you have access to the web, you can learn more and find an interactive
  #pod tutorial at B<L<dzil.org|http://dzil.org/>>.  If not, try
  #pod L<Dist::Zilla::Tutorial>.
  #pod
  #pod =cut
  
  has chrome => (
    is  => 'rw',
    isa => role_type('Dist::Zilla::Role::Chrome'),
    required => 1,
  );
  
  #pod =attr name
  #pod
  #pod The name attribute (which is required) gives the name of the distribution to be
  #pod built.  This is usually the name of the distribution's main module, with the
  #pod double colons (C<::>) replaced with dashes.  For example: C<Dist-Zilla>.
  #pod
  #pod =cut
  
  has name => (
    is   => 'ro',
    isa  => DistName,
    lazy => 1,
    builder => '_build_name',
  );
  
  #pod =attr version
  #pod
  #pod This is the version of the distribution to be created.
  #pod
  #pod =cut
  
  has _version_override => (
    isa => LaxVersionStr,
    is  => 'ro' ,
    init_arg => 'version',
  );
  
  # XXX: *clearly* this needs to be really much smarter -- rjbs, 2008-06-01
  has version => (
    is   => 'rw',
    isa  => LaxVersionStr,
    lazy => 1,
    init_arg  => undef,
    builder   => '_build_version',
  );
  
  sub _build_name {
    my ($self) = @_;
  
    my $name;
    for my $plugin (@{ $self->plugins_with(-NameProvider) }) {
      next unless defined(my $this_name = $plugin->provide_name);
  
      $self->log_fatal('attempted to set name twice') if defined $name;
  
      $name = $this_name;
    }
  
    $self->log_fatal('no name was ever set') unless defined $name;
  
    $name;
  }
  
  sub _build_version {
    my ($self) = @_;
  
    my $version = $self->_version_override;
  
    for my $plugin (@{ $self->plugins_with(-VersionProvider) }) {
      next unless defined(my $this_version = $plugin->provide_version);
  
      $self->log_fatal('attempted to set version twice') if defined $version;
  
      $version = $this_version;
    }
  
    $self->log_fatal('no version was ever set') unless defined $version;
  
    $version;
  }
  
  #pod =attr release_status
  #pod
  #pod This attribute sets the release status to one of the
  #pod L<CPAN::META::Spec|https://metacpan.org/pod/CPAN::Meta::Spec#release_status>
  #pod values: 'stable', 'testing' or 'unstable'.
  #pod
  #pod If the C<$ENV{RELEASE_STATUS}> environment variable exists, its value will
  #pod be used as the release status.
  #pod
  #pod For backwards compatibility, if C<$ENV{RELEASE_STATUS}> does not exist and
  #pod the C<$ENV{TRIAL}> variable is true, the release status will be 'testing'.
  #pod
  #pod Otherwise, the release status will be set from a
  #pod L<ReleaseStatusProvider|Dist::Zilla::Role::ReleaseStatusProvider>, if one
  #pod has been configured.
  #pod
  #pod For backwards compatibility, setting C<is_trial> true in F<dist.ini> is
  #pod equivalent to using a C<ReleaseStatusProvider>.  If C<is_trial> is false,
  #pod it has no effect.
  #pod
  #pod Only B<one> C<ReleaseStatusProvider> may be used.
  #pod
  #pod If no providers are used, the release status defaults to 'stable' unless there
  #pod is an "_" character in the version, in which case, it defaults to 'testing'.
  #pod
  #pod =cut
  
  # release status must be lazy, after files are gathered
  has release_status => (
    is => 'ro',
    isa => ReleaseStatus,
    lazy => 1,
    builder => '_build_release_status',
  );
  
  sub _build_release_status {
    my ($self) = @_;
  
    # environment variables override completely
    return $self->_release_status_from_env if $self->_release_status_from_env;
  
    # other ways of setting status must not conflict
    my $status;
  
    # dist.ini is equivalent to a release provider if is_trial is true.
    # If false, though, we want other providers to run or fall back to
    # the version
    $status = 'testing' if $self->_override_is_trial;
  
    for my $plugin (@{ $self->plugins_with(-ReleaseStatusProvider) }) {
      next unless defined(my $this_status = $plugin->provide_release_status);
  
      $self->log_fatal('attempted to set release status twice')
        if defined $status;
  
      $status = $this_status;
    }
  
    return $status || ( $self->version =~ /_/ ? 'testing' : 'stable' );
  }
  
  # captures environment variables early during Zilla object construction
  has _release_status_from_env => (
    is => 'ro',
    isa => Str,
    builder => '_build_release_status_from_env',
  );
  
  sub _build_release_status_from_env {
    my ($self) = @_;
    return $ENV{RELEASE_STATUS} if $ENV{RELEASE_STATUS};
    return $ENV{TRIAL} ? 'testing' : '';
  }
  
  #pod =attr abstract
  #pod
  #pod This is a one-line summary of the distribution.  If none is given, one will be
  #pod looked for in the L</main_module> of the dist.
  #pod
  #pod =cut
  
  has abstract => (
    is   => 'rw',
    isa  => 'Str',
    lazy => 1,
    default  => sub {
      my ($self) = @_;
  
      unless ($self->main_module) {
        die "no abstract given and no main_module found; make sure your main module is in ./lib\n";
      }
  
      my $file = $self->main_module;
      $self->log_debug("extracting distribution abstract from " . $file->name);
      my $abstract = Dist::Zilla::Util->abstract_from_file($file);
  
      if (!defined($abstract)) {
          my $filename = $file->name;
          die "Unable to extract an abstract from $filename. Please add the following comment to the file with your abstract:
      # ABSTRACT: turns baubles into trinkets
  ";
      }
  
      return $abstract;
    }
  );
  
  #pod =attr main_module
  #pod
  #pod This is the module where Dist::Zilla might look for various defaults, like
  #pod the distribution abstract.  By default, it's derived from the distribution
  #pod name.  If your distribution is Foo-Bar, and F<lib/Foo/Bar.pm> exists,
  #pod that's the main_module.  Otherwise, it's the shortest-named module in the
  #pod distribution.  This may change!
  #pod
  #pod You can override the default by specifying the file path explicitly,
  #pod ie:
  #pod
  #pod   main_module = lib/Foo/Bar.pm
  #pod
  #pod =cut
  
  has _main_module_override => (
    isa => 'Str',
    is  => 'ro' ,
    init_arg  => 'main_module',
    predicate => '_has_main_module_override',
  );
  
  has main_module => (
    is   => 'ro',
    isa  => 'Dist::Zilla::Role::File',
    lazy => 1,
    init_arg => undef,
    default  => sub {
      my ($self) = @_;
  
      my $file;
      my $guess;
  
      if ( $self->_has_main_module_override ) {
         $file = first { $_->name eq $self->_main_module_override }
                 @{ $self->files };
      } else {
        # We're having to guess
  
        $guess = $self->name =~ s{-}{/}gr;
        $guess = "lib/$guess.pm";
  
        $file = (first { $_->name eq $guess } @{ $self->files })
            ||  (sort { length $a->name <=> length $b->name }
                 grep { $_->name =~ m{\.pm\z} and $_->name =~ m{\Alib/} }
                 @{ $self->files })[0];
        $self->log("guessing dist's main_module is " . ($file ? $file->name : $guess));
      }
  
      if (not $file) {
        my @errorlines;
  
        push @errorlines, "Unable to find main_module in the distribution";
        if ($self->_has_main_module_override) {
          push @errorlines, "'main_module' was specified in dist.ini but the file '" . $self->_main_module_override . "' is not to be found in our dist. ( Did you add it? )";
        } else {
          push @errorlines,"We tried to guess '$guess' but no file like that existed";
        }
        if (not @{ $self->files }) {
          push @errorlines, "Upon further inspection we didn't find any files in your dist, did you add any?";
        } elsif ( none { $_->name =~ m{^lib/.+\.pm\z} } @{ $self->files } ){
          push @errorlines, "We didn't find any .pm files in your dist, this is probably a problem.";
        }
        push @errorlines,"Cannot continue without a main_module";
        $self->log_fatal( join qq{\n}, @errorlines );
      }
      $self->log_debug("dist's main_module is " . $file->name);
  
      return $file;
    },
  );
  
  #pod =attr license
  #pod
  #pod This is the L<Software::License|Software::License> object for this dist's
  #pod license and copyright.
  #pod
  #pod It will be created automatically, if possible, with the
  #pod C<copyright_holder> and C<copyright_year> attributes.  If necessary, it will
  #pod try to guess the license from the POD of the dist's main module.
  #pod
  #pod A better option is to set the C<license> name in the dist's config to something
  #pod understandable, like C<Perl_5>.
  #pod
  #pod =cut
  
  has license => (
    is   => 'ro',
    isa  => License,
    lazy => 1,
    init_arg  => 'license_obj',
    predicate => '_has_license',
    builder   => '_build_license',
    handles   => {
      copyright_holder => 'holder',
      copyright_year   => 'year',
    },
  );
  
  sub _build_license {
    my ($self) = @_;
  
    my $license_class    = $self->_license_class;
    my $copyright_holder = $self->_copyright_holder;
    my $copyright_year   = $self->_copyright_year;
  
    my $provided_license;
  
    for my $plugin (@{ $self->plugins_with(-LicenseProvider) }) {
      my $this_license = $plugin->provide_license({
        copyright_holder => $copyright_holder,
        copyright_year   => $copyright_year,
      });
  
      next unless defined $this_license;
  
      $self->log_fatal('attempted to set license twice')
        if defined $provided_license;
  
      $provided_license = $this_license;
    }
  
    return $provided_license if defined $provided_license;
  
    if ($license_class) {
      $license_class = String::RewritePrefix->rewrite(
        {
          '=' => '',
          ''  => 'Software::License::'
        },
        $license_class,
      );
    } else {
      require Software::LicenseUtils;
      my @guess = Software::LicenseUtils->guess_license_from_pod(
        $self->main_module->content
      );
  
      if (@guess != 1) {
        $self->log_fatal(
          "no license data in config, no %Rights stash,",
          "couldn't make a good guess at license from Pod; giving up. ",
          "Perhaps you need to set up a global config file (dzil setup)?"
        );
      }
  
      my $filename = $self->main_module->name;
      $license_class = $guess[0];
      $self->log("based on POD in $filename, guessing license is $guess[0]");
    }
  
    unless (Class::Load::try_load_class($license_class)) {
      $self->log_fatal(
        "could not load class $license_class for license " . $self->_license_class
      );
    }
  
    my $license = $license_class->new({
      holder => $self->_copyright_holder,
      year   => $self->_copyright_year,
    });
  
    $self->_clear_license_class;
    $self->_clear_copyright_holder;
    $self->_clear_copyright_year;
  
    return $license;
  }
  
  has _license_class => (
    is        => 'ro',
    isa       => 'Maybe[Str]',
    lazy      => 1,
    init_arg  => 'license',
    clearer   => '_clear_license_class',
    default   => sub {
      my $stash = $_[0]->stash_named('%Rights');
      $stash && return $stash->license_class;
      return;
    }
  );
  
  has _copyright_holder => (
    is        => 'ro',
    isa       => 'Maybe[Str]',
    lazy      => 1,
    init_arg  => 'copyright_holder',
    clearer   => '_clear_copyright_holder',
    default   => sub {
      return unless my $stash = $_[0]->stash_named('%Rights');
      $stash && return $stash->copyright_holder;
      return;
    }
  );
  
  has _copyright_year => (
    is        => 'ro',
    isa       => 'Str',
    lazy      => 1,
    init_arg  => 'copyright_year',
    clearer   => '_clear_copyright_year',
    default   => sub {
      # Oh man.  This is a terrible idea!  I mean, what if by the code gets run
      # around like Dec 31, 23:59:59.9 and by the time the default gets called
      # it's the next year but the default was already set up?  Oh man.  That
      # could ruin lives!  I guess we could make this a sub to defer the guess,
      # but think of the performance hit!  I guess we'll have to suffer through
      # this until we can optimize the code to not take .1s to run, right? --
      # rjbs, 2008-06-13
      my $stash = $_[0]->stash_named('%Rights');
      my $year  = $stash && $stash->copyright_year;
      return( $year // (localtime)[5] + 1900 );
    }
  );
  
  #pod =attr authors
  #pod
  #pod This is an arrayref of author strings, like this:
  #pod
  #pod   [
  #pod     'Ricardo Signes <rjbs@cpan.org>',
  #pod     'X. Ample, Jr <example@example.biz>',
  #pod   ]
  #pod
  #pod This is likely to change at some point in the near future.
  #pod
  #pod =cut
  
  has authors => (
    is   => 'ro',
    isa  => ArrayRef[Str],
    lazy => 1,
    default  => sub {
      my ($self) = @_;
  
      if (my $stash  = $self->stash_named('%User')) {
        return $stash->authors;
      }
  
      my $author = try { $self->copyright_holder };
      return [ $author ] if length $author;
  
      $self->log_fatal(
        "No %User stash and no copyright holder;",
        "can't determine dist author; configure author or a %User section",
      );
    },
  );
  
  #pod =attr files
  #pod
  #pod This is an arrayref of objects implementing L<Dist::Zilla::Role::File> that
  #pod will, if left in this arrayref, be built into the dist.
  #pod
  #pod Non-core code should avoid altering this arrayref, but sometimes there is not
  #pod other way to change the list of files.  In the future, the representation used
  #pod for storing files B<will be changed>.
  #pod
  #pod =cut
  
  has files => (
    is   => 'ro',
    isa  => ArrayRef[ role_type('Dist::Zilla::Role::File') ],
    lazy => 1,
    init_arg => undef,
    default  => sub { [] },
  );
  
  sub prune_file {
    my ($self, $file) = @_;
    my @files = @{ $self->files };
  
    for my $i (0 .. $#files) {
      next unless $file == $files[ $i ];
      splice @{ $self->files }, $i, 1;
      return;
    }
  
    return;
  }
  
  #pod =attr root
  #pod
  #pod This is the root directory of the dist, as a L<Path::Tiny>.  It will
  #pod nearly always be the current working directory in which C<dzil> was run.
  #pod
  #pod =cut
  
  has root => (
    is   => 'ro',
    isa  => Path,
    coerce   => 1,
    required => 1,
  );
  
  #pod =attr is_trial
  #pod
  #pod This attribute tells us whether or not the dist will be a trial release,
  #pod i.e. whether it has C<release_status> 'testing' or 'unstable'.
  #pod
  #pod Do not set this directly, it will be derived from C<release_status>.
  #pod
  #pod =cut
  
  has is_trial => (
    is => 'ro',
    isa => Bool,
    init_arg => undef,
    lazy => 1,
    builder => '_build_is_trial',
  );
  
  has _override_is_trial => (
    is => 'ro',
    isa => Bool,
    init_arg => 'is_trial',
    default => 0,
  );
  
  sub _build_is_trial {
      my ($self) = @_;
      return $self->release_status =~ /\A(?:testing|unstable)\z/ ? 1 : 0;
  }
  
  #pod =attr plugins
  #pod
  #pod This is an arrayref of plugins that have been plugged into this Dist::Zilla
  #pod object.
  #pod
  #pod Non-core code B<must not> alter this arrayref.  Public access to this attribute
  #pod B<may go away> in the future.
  #pod
  #pod =cut
  
  has plugins => (
    is   => 'ro',
    isa  => 'ArrayRef[Dist::Zilla::Role::Plugin]',
    init_arg => undef,
    default  => sub { [ ] },
  );
  
  #pod =attr distmeta
  #pod
  #pod This is a hashref containing the metadata about this distribution that will be
  #pod stored in META.yml or META.json.  You should not alter the metadata in this
  #pod hash; use a MetaProvider plugin instead.
  #pod
  #pod =cut
  
  has distmeta => (
    is   => 'ro',
    isa  => 'HashRef',
    init_arg  => undef,
    lazy      => 1,
    builder   => '_build_distmeta',
  );
  
  sub _build_distmeta {
    my ($self) = @_;
  
    require CPAN::Meta::Merge;
    my $meta_merge = CPAN::Meta::Merge->new(default_version => 2);
    my $meta = {};
  
    for (@{ $self->plugins_with(-MetaProvider) }) {
      $meta = $meta_merge->merge($meta, $_->metadata);
    }
  
    $meta = $meta_merge->merge($meta, {
      'meta-spec' => {
        version => 2,
        url     => 'https://metacpan.org/pod/CPAN::Meta::Spec',
      },
      name     => $self->name,
      version  => $self->version,
      abstract => $self->abstract,
      author   => $self->authors,
      license  => [ $self->license->meta2_name ],
  
      release_status => $self->release_status,
  
      dynamic_config => 0, # problematic, I bet -- rjbs, 2010-06-04
      generated_by   => $self->_metadata_generator_id
                      . ' version '
                      . ($self->VERSION // '(undef)'),
    });
  
    return $meta;
  }
  
  sub _metadata_generator_id { 'Dist::Zilla' }
  
  #pod =attr prereqs
  #pod
  #pod This is a L<Dist::Zilla::Prereqs> object, which is a thin layer atop
  #pod L<CPAN::Meta::Prereqs>, and describes the distribution's prerequisites.
  #pod
  #pod =method register_prereqs
  #pod
  #pod Allows registration of prerequisites; delegates to
  #pod L<Dist::Zilla::Prereqs/register_prereqs> via our L</prereqs> attribute.
  #pod
  #pod =cut
  
  has prereqs => (
    is   => 'ro',
    isa  => 'Dist::Zilla::Prereqs',
    init_arg => undef,
    lazy     => 1,
    default  => sub { Dist::Zilla::Prereqs->new },
    handles  => [ qw(register_prereqs) ],
  );
  
  #pod =method plugin_named
  #pod
  #pod   my $plugin = $zilla->plugin_named( $plugin_name );
  #pod
  #pod =cut
  
  sub plugin_named {
    my ($self, $name) = @_;
    my $plugin = first { $_->plugin_name eq $name } @{ $self->plugins };
  
    return $plugin if $plugin;
    return;
  }
  
  #pod =method plugins_with
  #pod
  #pod   my $roles = $zilla->plugins_with( -SomeRole );
  #pod
  #pod This method returns an arrayref containing all the Dist::Zilla object's plugins
  #pod that perform the named role.  If the given role name begins with a dash, the
  #pod dash is replaced with "Dist::Zilla::Role::"
  #pod
  #pod =cut
  
  sub plugins_with {
    my ($self, $role) = @_;
  
    $role =~ s/^-/Dist::Zilla::Role::/;
    my $plugins = [ grep { $_->does($role) } @{ $self->plugins } ];
  
    return $plugins;
  }
  
  #pod =method find_files
  #pod
  #pod   my $files = $zilla->find_files( $finder_name );
  #pod
  #pod This method will look for a
  #pod L<FileFinder|Dist::Zilla::Role::FileFinder>-performing plugin with the given
  #pod name and return the result of calling C<find_files> on it.  If no plugin can be
  #pod found, an exception will be raised.
  #pod
  #pod =cut
  
  sub find_files {
    my ($self, $finder_name) = @_;
  
    $self->log_fatal("no plugin named $finder_name found")
      unless my $plugin = $self->plugin_named($finder_name);
  
    $self->log_fatal("plugin $finder_name is not a FileFinder")
      unless $plugin->does('Dist::Zilla::Role::FileFinder');
  
    $plugin->find_files;
  }
  
  sub _check_dupe_files {
    my ($self) = @_;
  
    my %files_named;
    my @dupes;
    for my $file (@{ $self->files }) {
      my $filename = $file->name;
      if (my $seen = $files_named{ $filename }) {
        push @{ $seen }, $file;
        push @dupes, $filename if @{ $seen } == 2;
      } else {
        $files_named{ $filename } = [ $file ];
      }
    }
  
    return unless @dupes;
  
    for my $name (@dupes) {
      $self->log("attempt to add $name multiple times; added by: "
         . join('; ', map { $_->added_by } @{ $files_named{ $name } })
      );
    }
  
    Carp::croak("aborting; duplicate files would be produced");
  }
  
  sub _write_out_file {
    my ($self, $file, $build_root) = @_;
  
    # Okay, this is a bit much, until we have ->debug. -- rjbs, 2008-06-13
    # $self->log("writing out " . $file->name);
  
    my $file_path = path($file->name);
  
    my $to_dir = path($build_root)->child( $file_path->parent );
    my $to = $to_dir->child( $file_path->basename );
    $to_dir->mkpath unless -e $to_dir;
    die "not a directory: $to_dir" unless -d $to_dir;
  
    Carp::croak("attempted to write $to multiple times") if -e $to;
  
    path("$to")->spew_raw( $file->encoded_content );
    chmod $file->mode, "$to" or die "couldn't chmod $to: $!";
  }
  
  #pod =attr logger
  #pod
  #pod This attribute stores a L<Log::Dispatchouli::Proxy> object, used to log
  #pod messages.  By default, a proxy to the dist's L<Chrome|Dist::Zilla::Chrome> is
  #pod taken.
  #pod
  #pod The following methods are delegated from the Dist::Zilla object to the logger:
  #pod
  #pod =for :list
  #pod * log
  #pod * log_debug
  #pod * log_fatal
  #pod
  #pod =cut
  
  has logger => (
    is   => 'ro',
    isa  => 'Log::Dispatchouli::Proxy', # could be duck typed, I guess
    lazy => 1,
    handles => [ qw(log log_debug log_fatal) ],
    default => sub {
      $_[0]->chrome->logger->proxy({ proxy_prefix => '[DZ] ' })
    },
  );
  
  around dump_config => sub {
    my ($orig, $self) = @_;
    my $config = $self->$orig;
    $config->{is_trial} = $self->is_trial;
    return $config;
  };
  
  has _local_stashes => (
    is   => 'ro',
    isa  => HashRef[ Object ],
    lazy => 1,
    default => sub { {} },
  );
  
  has _global_stashes => (
    is   => 'ro',
    isa  => HashRef[ Object ],
    lazy => 1,
    default => sub { {} },
  );
  
  #pod =method stash_named
  #pod
  #pod   my $stash = $zilla->stash_named( $name );
  #pod
  #pod This method will return the stash with the given name, or undef if none exists.
  #pod It looks for a local stash (for this dist) first, then falls back to a global
  #pod stash (from the user's global configuration).
  #pod
  #pod =cut
  
  sub stash_named {
    my ($self, $name) = @_;
  
    return $self->_local_stashes->{ $name } if $self->_local_stashes->{$name};
    return $self->_global_stashes->{ $name };
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 STABILITY PROMISE
  #pod
  #pod None.
  #pod
  #pod I will try not to break things within any major release.  Minor releases are
  #pod not extensively tested before release.  In major releases, anything goes,
  #pod although I will try to publish a complete list of known breaking changes in any
  #pod major release.
  #pod
  #pod If Dist::Zilla was a tool, it would have yellow and black stripes and there
  #pod would be no L<UL
  #pod certification|https://en.wikipedia.org/wiki/UL_(safety_organization)> on it.
  #pod It is nasty, brutish, and large.
  #pod
  #pod =head1 SUPPORT
  #pod
  #pod There are usually people on C<irc.perl.org> in C<#distzilla>, even if they're
  #pod idling.
  #pod
  #pod The L<Dist::Zilla website|http://dzil.org/> has several valuable resources for
  #pod learning to use Dist::Zilla.
  #pod
  #pod There is a mailing list to discuss Dist::Zilla.  You can L<join the
  #pod list|http://www.listbox.com/subscribe/?list_id=139292> or L<browse the
  #pod archives|http://listbox.com/member/archive/139292>.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =over 4
  #pod
  #pod =item *
  #pod
  #pod In the Dist::Zilla distribution:
  #pod
  #pod =over 4
  #pod
  #pod =item *
  #pod
  #pod Plugin bundles:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<@Filter|Dist::Zilla::PluginBundle::Filter>.
  #pod
  #pod =item *
  #pod
  #pod Major plugins:
  #pod L<GatherDir|Dist::Zilla::Plugin::GatherDir>,
  #pod L<Prereqs|Dist::Zilla::Plugin::Prereqs>,
  #pod L<AutoPrereqs|Dist::Zilla::Plugin::AutoPrereqs>,
  #pod L<MetaYAML|Dist::Zilla::Plugin::MetaYAML>,
  #pod L<MetaJSON|Dist::Zilla::Plugin::MetaJSON>,
  #pod ...
  #pod
  #pod =back
  #pod
  #pod =item *
  #pod
  #pod On the CPAN:
  #pod
  #pod =over 4
  #pod
  #pod =item *
  #pod
  #pod Search for plugins: L<https://metacpan.org/search?q=Dist::Zilla::Plugin::>
  #pod
  #pod =item *
  #pod
  #pod Search for plugin bundles: L<https://metacpan.org/search?q=Dist::Zilla::PluginBundle::>
  #pod
  #pod =back
  #pod
  #pod =back
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla - distribution builder; installer not included!
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Dist::Zilla builds distributions of code to be uploaded to the CPAN.  In this
  respect, it is like L<ExtUtils::MakeMaker>, L<Module::Build>, or
  L<Module::Install>.  Unlike those tools, however, it is not also a system for
  installing code that has been downloaded from the CPAN.  Since it's only run by
  authors, and is meant to be run on a repository checkout rather than on
  published, released code, it can do much more than those tools, and is free to
  make much more ludicrous demands in terms of prerequisites.
  
  If you have access to the web, you can learn more and find an interactive
  tutorial at B<L<dzil.org|http://dzil.org/>>.  If not, try
  L<Dist::Zilla::Tutorial>.
  
  =head1 ATTRIBUTES
  
  =head2 name
  
  The name attribute (which is required) gives the name of the distribution to be
  built.  This is usually the name of the distribution's main module, with the
  double colons (C<::>) replaced with dashes.  For example: C<Dist-Zilla>.
  
  =head2 version
  
  This is the version of the distribution to be created.
  
  =head2 release_status
  
  This attribute sets the release status to one of the
  L<CPAN::META::Spec|https://metacpan.org/pod/CPAN::Meta::Spec#release_status>
  values: 'stable', 'testing' or 'unstable'.
  
  If the C<$ENV{RELEASE_STATUS}> environment variable exists, its value will
  be used as the release status.
  
  For backwards compatibility, if C<$ENV{RELEASE_STATUS}> does not exist and
  the C<$ENV{TRIAL}> variable is true, the release status will be 'testing'.
  
  Otherwise, the release status will be set from a
  L<ReleaseStatusProvider|Dist::Zilla::Role::ReleaseStatusProvider>, if one
  has been configured.
  
  For backwards compatibility, setting C<is_trial> true in F<dist.ini> is
  equivalent to using a C<ReleaseStatusProvider>.  If C<is_trial> is false,
  it has no effect.
  
  Only B<one> C<ReleaseStatusProvider> may be used.
  
  If no providers are used, the release status defaults to 'stable' unless there
  is an "_" character in the version, in which case, it defaults to 'testing'.
  
  =head2 abstract
  
  This is a one-line summary of the distribution.  If none is given, one will be
  looked for in the L</main_module> of the dist.
  
  =head2 main_module
  
  This is the module where Dist::Zilla might look for various defaults, like
  the distribution abstract.  By default, it's derived from the distribution
  name.  If your distribution is Foo-Bar, and F<lib/Foo/Bar.pm> exists,
  that's the main_module.  Otherwise, it's the shortest-named module in the
  distribution.  This may change!
  
  You can override the default by specifying the file path explicitly,
  ie:
  
    main_module = lib/Foo/Bar.pm
  
  =head2 license
  
  This is the L<Software::License|Software::License> object for this dist's
  license and copyright.
  
  It will be created automatically, if possible, with the
  C<copyright_holder> and C<copyright_year> attributes.  If necessary, it will
  try to guess the license from the POD of the dist's main module.
  
  A better option is to set the C<license> name in the dist's config to something
  understandable, like C<Perl_5>.
  
  =head2 authors
  
  This is an arrayref of author strings, like this:
  
    [
      'Ricardo Signes <rjbs@cpan.org>',
      'X. Ample, Jr <example@example.biz>',
    ]
  
  This is likely to change at some point in the near future.
  
  =head2 files
  
  This is an arrayref of objects implementing L<Dist::Zilla::Role::File> that
  will, if left in this arrayref, be built into the dist.
  
  Non-core code should avoid altering this arrayref, but sometimes there is not
  other way to change the list of files.  In the future, the representation used
  for storing files B<will be changed>.
  
  =head2 root
  
  This is the root directory of the dist, as a L<Path::Tiny>.  It will
  nearly always be the current working directory in which C<dzil> was run.
  
  =head2 is_trial
  
  This attribute tells us whether or not the dist will be a trial release,
  i.e. whether it has C<release_status> 'testing' or 'unstable'.
  
  Do not set this directly, it will be derived from C<release_status>.
  
  =head2 plugins
  
  This is an arrayref of plugins that have been plugged into this Dist::Zilla
  object.
  
  Non-core code B<must not> alter this arrayref.  Public access to this attribute
  B<may go away> in the future.
  
  =head2 distmeta
  
  This is a hashref containing the metadata about this distribution that will be
  stored in META.yml or META.json.  You should not alter the metadata in this
  hash; use a MetaProvider plugin instead.
  
  =head2 prereqs
  
  This is a L<Dist::Zilla::Prereqs> object, which is a thin layer atop
  L<CPAN::Meta::Prereqs>, and describes the distribution's prerequisites.
  
  =head2 logger
  
  This attribute stores a L<Log::Dispatchouli::Proxy> object, used to log
  messages.  By default, a proxy to the dist's L<Chrome|Dist::Zilla::Chrome> is
  taken.
  
  The following methods are delegated from the Dist::Zilla object to the logger:
  
  =over 4
  
  =item *
  
  log
  
  =item *
  
  log_debug
  
  =item *
  
  log_fatal
  
  =back
  
  =head1 METHODS
  
  =head2 register_prereqs
  
  Allows registration of prerequisites; delegates to
  L<Dist::Zilla::Prereqs/register_prereqs> via our L</prereqs> attribute.
  
  =head2 plugin_named
  
    my $plugin = $zilla->plugin_named( $plugin_name );
  
  =head2 plugins_with
  
    my $roles = $zilla->plugins_with( -SomeRole );
  
  This method returns an arrayref containing all the Dist::Zilla object's plugins
  that perform the named role.  If the given role name begins with a dash, the
  dash is replaced with "Dist::Zilla::Role::"
  
  =head2 find_files
  
    my $files = $zilla->find_files( $finder_name );
  
  This method will look for a
  L<FileFinder|Dist::Zilla::Role::FileFinder>-performing plugin with the given
  name and return the result of calling C<find_files> on it.  If no plugin can be
  found, an exception will be raised.
  
  =head2 stash_named
  
    my $stash = $zilla->stash_named( $name );
  
  This method will return the stash with the given name, or undef if none exists.
  It looks for a local stash (for this dist) first, then falls back to a global
  stash (from the user's global configuration).
  
  =head1 STABILITY PROMISE
  
  None.
  
  I will try not to break things within any major release.  Minor releases are
  not extensively tested before release.  In major releases, anything goes,
  although I will try to publish a complete list of known breaking changes in any
  major release.
  
  If Dist::Zilla was a tool, it would have yellow and black stripes and there
  would be no L<UL
  certification|https://en.wikipedia.org/wiki/UL_(safety_organization)> on it.
  It is nasty, brutish, and large.
  
  =head1 SUPPORT
  
  There are usually people on C<irc.perl.org> in C<#distzilla>, even if they're
  idling.
  
  The L<Dist::Zilla website|http://dzil.org/> has several valuable resources for
  learning to use Dist::Zilla.
  
  There is a mailing list to discuss Dist::Zilla.  You can L<join the
  list|http://www.listbox.com/subscribe/?list_id=139292> or L<browse the
  archives|http://listbox.com/member/archive/139292>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  In the Dist::Zilla distribution:
  
  =over 4
  
  =item *
  
  Plugin bundles:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<@Filter|Dist::Zilla::PluginBundle::Filter>.
  
  =item *
  
  Major plugins:
  L<GatherDir|Dist::Zilla::Plugin::GatherDir>,
  L<Prereqs|Dist::Zilla::Plugin::Prereqs>,
  L<AutoPrereqs|Dist::Zilla::Plugin::AutoPrereqs>,
  L<MetaYAML|Dist::Zilla::Plugin::MetaYAML>,
  L<MetaJSON|Dist::Zilla::Plugin::MetaJSON>,
  ...
  
  =back
  
  =item *
  
  On the CPAN:
  
  =over 4
  
  =item *
  
  Search for plugins: L<https://metacpan.org/search?q=Dist::Zilla::Plugin::>
  
  =item *
  
  Search for plugin bundles: L<https://metacpan.org/search?q=Dist::Zilla::PluginBundle::>
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Ævar Arnfjörð Bjarmason Alastair McGowan-Douglas Alexei Znamensky Alex Vandiver ambs Andrew Rodland Andy Jack Apocalypse ben hengst Bernardo Rechea Brian Fraser Caleb Cushing Chisel Christian Walde Christopher J. Madsen Chris Weyl Cory G Watson csjewell Curtis Brandt Dagfinn Ilmari Mannsåker Damien KRotkine Danijel Tasov Dave O'Neill Rolsky David E. Wheeler Golden H. Adler Steinbrunner Zurborg Davor Cubranic Dimitar Petrov Doug Bell Erik Carlsson Fayland Lam Florian Ragwitz Fred Moyer fREW Schmidt gardnerm Gianni Ceccarelli Graham Barr Knop Ollis Grzegorz Rożniecki Hans Dieter Pearcey Hunter McMillen Ivan Bessarabov Jakob Voss jantore Jérôme Quelin Jesse Luehrs Vincent John Napiorkowski Jonathan C. Otsuka Rockway Scott Duff Yu Karen Etheridge Kent Fredric Leon Timmermans Lucas Theisen Luc St-Louis Marcel Gruenauer Martin McGrath Mateu X mauke Michael Jemmeson Mike Doherty Mohammad S Anwar Moritz Onken Neil Bowers Nickolay Platonov Nick Tonkin nperez Olivier Mengué Paul Cochrane Pedro Melo Philippe Bruhat (BooK) Randy Stauner robertkrimen Rob Hoelz Robin Smidsrød Shawn M Moore Smylers Steffen Schwigon Steven Haryanto Tatsuhiko Miyagawa Upasana Shukla Vyacheslav Matjukhin Yanick Champoux Yuval Kogman
  
  =over 4
  
  =item *
  
  Ævar Arnfjörð Bjarmason <avarab@gmail.com>
  
  =item *
  
  Alastair McGowan-Douglas <alastair.mcgowan@opusvl.com>
  
  =item *
  
  Alexei Znamensky <russoz@cpan.org>
  
  =item *
  
  Alex Vandiver <alexmv@mit.edu>
  
  =item *
  
  ambs <ambs@cpan.org>
  
  =item *
  
  Andrew Rodland <andrew@hbslabs.com>
  
  =item *
  
  Andy Jack <andyjack@cpan.org>
  
  =item *
  
  Apocalypse <APOCAL@cpan.org>
  
  =item *
  
  ben hengst <ben.hengst@gmail.com>
  
  =item *
  
  Bernardo Rechea <brbpub@gmail.com>
  
  =item *
  
  Brian Fraser <fraserbn@gmail.com>
  
  =item *
  
  Caleb Cushing <xenoterracide@gmail.com>
  
  =item *
  
  Chisel <chisel@chizography.net>
  
  =item *
  
  Christian Walde <walde.christian@googlemail.com>
  
  =item *
  
  Christopher J. Madsen <cjm@cjmweb.net>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Cory G Watson <gphat@onemogin.com>
  
  =item *
  
  csjewell <perl@csjewell.fastmail.us>
  
  =item *
  
  Curtis Brandt <curtisjbrandt@gmail.com>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Damien KRotkine <dkrotkine@booking.com>
  
  =item *
  
  Danijel Tasov <dt@korn.shell.la>
  
  =item *
  
  Dave O'Neill <dmo@dmo.ca>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  David H. Adler <dha@pobox.com>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  David Zurborg <port@david-zurb.org>
  
  =item *
  
  Davor Cubranic <cubranic@stat.ubc.ca>
  
  =item *
  
  Dimitar Petrov <mitakaa@gmail.com>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Erik Carlsson <info@code301.com>
  
  =item *
  
  Fayland Lam <fayland@gmail.com>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Fred Moyer <fred@redhotpenguin.com>
  
  =item *
  
  fREW Schmidt <frioux@gmail.com>
  
  =item *
  
  gardnerm <gardnerm@gsicommerce.com>
  
  =item *
  
  Gianni Ceccarelli <gianni.ceccarelli@net-a-porter.com>
  
  =item *
  
  Graham Barr <gbarr@pobox.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Graham Ollis <perl@wdlabs.com>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Grzegorz Rożniecki <xaerxess@gmail.com>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Hunter McMillen <mcmillhj@gmail.com>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  Jakob Voss <jakob@nichtich.de>
  
  =item *
  
  jantore <jantore@32k.org>
  
  =item *
  
  Jérôme Quelin <jquelin@gmail.com>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Jesse Vincent <jesse@bestpractical.com>
  
  =item *
  
  John Napiorkowski <jjnapiork@cpan.org>
  
  =item *
  
  Jonathan C. Otsuka <djgoku@gmail.com>
  
  =item *
  
  Jonathan Rockway <jrockway@cpan.org>
  
  =item *
  
  Jonathan Scott Duff <duff@pobox.com>
  
  =item *
  
  Jonathan Yu <jawnsy@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Lucas Theisen <lucastheisen@pastdev.com>
  
  =item *
  
  Luc St-Louis <lucs@pobox.com>
  
  =item *
  
  Marcel Gruenauer <hanekomu@gmail.com>
  
  =item *
  
  Martin McGrath <mcgrath.martin@gmail.com>
  
  =item *
  
  Mateu X Hunter <hunter@missoula.org>
  
  =item *
  
  mauke <l.mai@web.de>
  
  =item *
  
  Michael Jemmeson <mjemmeson@cpan.org>
  
  =item *
  
  Mike Doherty <mike@mikedoherty.ca>
  
  =item *
  
  Mohammad S Anwar <mohammad.anwar@yahoo.com>
  
  =item *
  
  Moritz Onken <onken@netcubed.de>
  
  =item *
  
  Neil Bowers <neil@bowers.com>
  
  =item *
  
  Nickolay Platonov <nickolay@desktop.(none)>
  
  =item *
  
  Nick Tonkin <1nickt@users.noreply.github.com>
  
  =item *
  
  nperez <nperez@cpan.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Paul Cochrane <paul@liekut.de>
  
  =item *
  
  Pedro Melo <melo@simplicidade.org>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  Randy Stauner <rwstauner@cpan.org>
  
  =item *
  
  robertkrimen <robertkrimen@gmail.com>
  
  =item *
  
  Rob Hoelz <rob@hoelz.ro>
  
  =item *
  
  Robin Smidsrød <robin@smidsrod.no>
  
  =item *
  
  Shawn M Moore <sartak@gmail.com>
  
  =item *
  
  Smylers <Smylers@stripey.com>
  
  =item *
  
  Steffen Schwigon <ss5@renormalist.net>
  
  =item *
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Upasana Shukla <me@upasana.me>
  
  =item *
  
  Vyacheslav Matjukhin <mmcleric@yandex-team.ru>
  
  =item *
  
  Yanick Champoux <yanick@babyl.dyndns.org>
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA

$fatpacked{"Dist/Zilla/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP';
  use strict;
  use warnings;
  package Dist::Zilla::App 6.007;
  # ABSTRACT: Dist::Zilla's App::Cmd
  
  use App::Cmd::Setup 0.330 -app; # better compilation error detection
  
  use Carp ();
  use Try::Tiny;
  
  sub global_opt_spec {
    my ($self) = @_;
  
    return (
      [ "verbose|v",           "log additional output" ],
      [ "verbose-plugin|V=s@", "log additional output from some plugins only" ],
      [ "lib-inc|I=s@",        "additional \@INC dirs", {
          callbacks => { 'always fine' => sub { unshift @INC, @{$_[0]}; } }
      } ],
      $self->SUPER::global_opt_spec,
    );
  }
  
  sub _build_global_stashes {
    my ($self) = @_;
  
    return $self->{__global_stashes__} if $self->{__global_stashes__};
  
    # tests shouldn't depend on the user's configuration
    return {} if $ENV{DZIL_TESTING};
  
    my $stash_registry = $self->{__global_stashes__} = {};
  
    require Dist::Zilla::Util;
    my $config_dir  = Dist::Zilla::Util->_global_config_root;
  
    my $config_base = $config_dir->child('config');
  
    require Dist::Zilla::MVP::Reader::Finder;
    require Dist::Zilla::MVP::Assembler::GlobalConfig;
    require Dist::Zilla::MVP::Section;
    my $assembler = Dist::Zilla::MVP::Assembler::GlobalConfig->new({
      chrome => $self->chrome,
      stash_registry => $stash_registry,
      section_class  => 'Dist::Zilla::MVP::Section', # make this DZMA default
    });
  
    try {
      my $reader = Dist::Zilla::MVP::Reader::Finder->new({
        if_none => sub {
  #         warn <<'END_WARN';
  # WARNING: No global configuration file was found in ~/.dzil -- this limits the
  # ability of Dist::Zilla to perform some tasks.  You can run "dzil setup" to
  # create a simple first-pass configuration file, or you can touch the file
  # ~/.dzil/config.ini to suppress this message in the future.
  # END_WARN
          return $_[2]->{assembler}->sequence
        },
      });
  
      my $seq = $reader->read_config($config_base, { assembler => $assembler });
    } catch {
      my $e = $_;
      if (eval { $e->isa('Config::MVP::Error') and $e->ident eq 'package not installed' }) {
        my $package = $e->package;
  
        my $bundle = $package =~ /^@/ ? ' bundle' : '';
        die <<"END_DIE";
  Required plugin$bundle $package isn't installed.  Remedy with:
  
      cpanm $package
  
  END_DIE
      }
      else {
        die <<'END_DIE';
  
  Your global configuration file couldn't be loaded.  It's a file matching
  ~/.dzil/config.*
  
  You can try deleting the file or you might need to upgrade from pre-version 4
  format.  In most cases, this will just mean replacing [!release] with [%PAUSE]
  and deleting any [!new] stanza.  You can also delete the existing file and run
  "dzil setup"
  END_DIE
      }
    };
  
    return $stash_registry;
  }
  
  #pod =method zilla
  #pod
  #pod This returns the Dist::Zilla object in use by the command.  If none has yet
  #pod been constructed, one will be by calling C<< Dist::Zilla->from_config >>.
  #pod
  #pod =cut
  
  sub chrome {
    my ($self) = @_;
    require Dist::Zilla::Chrome::Term;
  
    return $self->{__chrome__} if $self->{__chrome__};
  
    $self->{__chrome__} = Dist::Zilla::Chrome::Term->new;
  
    my @v_plugins = $self->global_options->verbose_plugin
                  ? grep { length } @{ $self->global_options->verbose_plugin }
                  : ();
  
    my $verbose = $self->global_options->verbose;
  
    $self->{__chrome__}->logger->set_debug($verbose ? 1 : 0);
  
    return $self->{__chrome__};
  }
  
  sub zilla {
    my ($self) = @_;
  
    require Dist::Zilla::Dist::Builder;
  
    return $self->{'' . __PACKAGE__}{zilla} ||= do {
      my @v_plugins = $self->global_options->verbose_plugin
                    ? grep { length } @{ $self->global_options->verbose_plugin }
                    : ();
  
      my $verbose = $self->global_options->verbose;
  
      $self->chrome->logger->set_debug($verbose ? 1 : 0);
  
      my $core_debug = grep { m/\A[-_]\z/ } @v_plugins;
  
      my $zilla;
      try {
        $zilla = Dist::Zilla::Dist::Builder->from_config({
          chrome => $self->chrome,
          _global_stashes => $self->_build_global_stashes,
        });
      } catch {
        die $_ unless try { $_->isa('Config::MVP::Error') }
                   && $_->ident =~ /no viable config/;
        $self->chrome->logger->log_fatal("no configuration (e.g, dist.ini) found");
      };
  
      $zilla->logger->set_debug($verbose ? 1 : 0);
  
      VERBOSE_PLUGIN: for my $plugin_name (grep { ! m{\A[-_]\z} } @v_plugins) {
        my @plugins = grep { $_->plugin_name =~ /\b\Q$plugin_name\E\b/ }
                      @{ $zilla->plugins };
  
        $zilla->log_fatal("can't find plugins matching $plugin_name to set debug")
          unless @plugins;
  
        $_->logger->set_debug(1) for @plugins;
      }
  
      $zilla;
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App - Dist::Zilla's App::Cmd
  
  =head1 VERSION
  
  version 6.007
  
  =head1 METHODS
  
  =head2 zilla
  
  This returns the Dist::Zilla object in use by the command.  If none has yet
  been constructed, one will be by calling C<< Dist::Zilla->from_config >>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP

$fatpacked{"Dist/Zilla/App/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command 6.007;
  # ABSTRACT: base class for dzil commands
  
  use App::Cmd::Setup -command;
  
  #pod =method zilla
  #pod
  #pod This returns the Dist::Zilla object in use by the command.  If none has yet
  #pod been constructed, one will be by calling C<< Dist::Zilla->from_config >>.
  #pod
  #pod (This method just delegates to the Dist::Zilla::App object!)
  #pod
  #pod =cut
  
  sub zilla {
    return $_[0]->app->zilla;
  }
  
  #pod =method log
  #pod
  #pod This method calls the C<log> method of the application's chrome.
  #pod
  #pod =cut
  
  sub log {
    $_[0]->app->chrome->logger->log($_[1]);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command - base class for dzil commands
  
  =head1 VERSION
  
  version 6.007
  
  =head1 METHODS
  
  =head2 zilla
  
  This returns the Dist::Zilla object in use by the command.  If none has yet
  been constructed, one will be by calling C<< Dist::Zilla->from_config >>.
  
  (This method just delegates to the Dist::Zilla::App object!)
  
  =head2 log
  
  This method calls the C<log> method of the application's chrome.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND

$fatpacked{"Dist/Zilla/App/Command/add.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_ADD';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::add 6.007;
  # ABSTRACT: add a module to a dist
  
  use Dist::Zilla::App -command;
  use Dist::Zilla::Path;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod Adds a new module to a Dist::Zilla-based distribution
  #pod
  #pod   $ dzil add Some::New::Module
  #pod
  #pod There are two arguments, C<-p> and C<-P>. C<-P> specify the minting profile
  #pod provider and C<-p> - the profile name. These work just like C<dzil new>.
  #pod
  #pod =cut
  
  sub abstract { 'add modules to an existing dist' }
  
  sub usage_desc { '%c %o <ModuleName>' }
  
  sub opt_spec {
    [ 'profile|p=s',  'name of the profile to use',
      { default => 'default' }  ],
  
    [ 'provider|P=s', 'name of the profile provider to use',
      { default => 'Default' }  ],
  
    # [ 'module|m=s@', 'module(s) to create; may be given many times'         ],
  }
  
  sub validate_args {
    my ($self, $opt, $args) = @_;
  
    require MooseX::Types::Perl;
  
    $self->usage_error('dzil add takes one or more arguments') if @$args < 1;
  
    for my $name ( @$args ) {
      $self->usage_error("$name is not a valid module name")
        unless MooseX::Types::Perl::is_ModuleName($name);
    }
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    my $zilla = $self->zilla;
    my $dist = $zilla->name;
    
    require File::pushd;
  
    require Dist::Zilla::Dist::Minter;
    my $minter = Dist::Zilla::Dist::Minter->_new_from_profile(
      [ $opt->provider, $opt->profile ],
      {
        chrome  => $self->app->chrome,
        name    => $dist,
        _global_stashes => $self->app->_build_global_stashes,
      },
    );
  
    my $root = path($zilla->root)->absolute;
    my $wd = File::pushd::pushd($minter->root);
  
    my $factory = $minter->plugin_named(':DefaultModuleMaker');
  
    for my $name ( @$arg ) {
      $factory->make_module({ name => $name });
    }
  
    for my $file ( @{ $factory->zilla->files} ) {
      $zilla->_write_out_file($file, $root);
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::add - add a module to a dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  Adds a new module to a Dist::Zilla-based distribution
  
    $ dzil add Some::New::Module
  
  There are two arguments, C<-p> and C<-P>. C<-P> specify the minting profile
  provider and C<-p> - the profile name. These work just like C<dzil new>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_ADD

$fatpacked{"Dist/Zilla/App/Command/authordeps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_AUTHORDEPS';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::authordeps 6.007;
  # ABSTRACT: List your distribution's author dependencies
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   $ dzil authordeps
  #pod
  #pod This will scan the F<dist.ini> file and print a list of plugin modules that
  #pod probably need to be installed for the dist to be buildable.  This is a very
  #pod naive scan, but tends to be pretty accurate.  Modules can be added to its
  #pod results by using special comments in the form:
  #pod
  #pod   ; authordep Some::Package
  #pod
  #pod =cut
  
  sub abstract { "list your distribution's author dependencies" }
  
  sub opt_spec {
    return (
      [ 'root=s' => 'the root of the dist; defaults to .' ],
      [ 'missing' => 'list only the missing dependencies' ],
      [ 'versions' => 'include required version numbers in listing' ],
    );
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    require Dist::Zilla::Path;
    require Dist::Zilla::Util::AuthorDeps;
  
    my $deps = Dist::Zilla::Util::AuthorDeps::format_author_deps(
      Dist::Zilla::Util::AuthorDeps::extract_author_deps(
        Dist::Zilla::Path::path($opt->root // '.'),
        $opt->missing,
      ), $opt->versions
    );
  
    $self->log($deps) if $deps;
  
    return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::authordeps - List your distribution's author dependencies
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    $ dzil authordeps
  
  This will scan the F<dist.ini> file and print a list of plugin modules that
  probably need to be installed for the dist to be buildable.  This is a very
  naive scan, but tends to be pretty accurate.  Modules can be added to its
  results by using special comments in the form:
  
    ; authordep Some::Package
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_AUTHORDEPS

$fatpacked{"Dist/Zilla/App/Command/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_BUILD';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::build 6.007;
  # ABSTRACT: build your dist
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   dzil build [ --trial ] [ --tgz | --no-tgz ] [ --in /path/to/build/dir ]
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This command is a very thin layer over the Dist::Zilla C<build> method, which
  #pod does all the things required to build your distribution.  By default, it will
  #pod also archive your distribution and leave you with a complete, ready-to-release
  #pod distribution tarball.
  #pod
  #pod =cut
  
  sub abstract { 'build your dist' }
  
  #pod =head1 EXAMPLE
  #pod
  #pod   $ dzil build
  #pod   $ dzil build --no-tgz
  #pod   $ dzil build --in /path/to/build/dir
  #pod
  #pod =cut
  
  sub opt_spec {
    [ 'trial'  => 'build a trial release that PAUSE will not index'      ],
    [ 'tgz!'   => 'build a tarball (default behavior)', { default => 1 } ],
    [ 'in=s'   => 'the directory in which to build the distribution'     ]
  }
  
  #pod =head1 OPTIONS
  #pod
  #pod =head2 --trial
  #pod
  #pod This will build a trial distribution.  Among other things, it will generally
  #pod mean that the built tarball's basename ends in F<-TRIAL>.
  #pod
  #pod =head2 --tgz | --no-tgz
  #pod
  #pod Builds a .tar.gz in your project directory after building the distribution.
  #pod
  #pod --tgz behaviour is by default, use --no-tgz to disable building an archive.
  #pod
  #pod =head2 --in
  #pod
  #pod Specifies the directory into which the distribution should be built.  If
  #pod necessary, the directory will be created.  An archive will not be created.
  #pod
  #pod =cut
  
  sub execute {
    my ($self, $opt, $args) = @_;
  
    if ($opt->in) {
      require Path::Tiny;
      die qq{using "--in ." would destroy your working directory!\n}
        if Path::Tiny::path($opt->in)->absolute eq Path::Tiny::path('.')->absolute;
  
      $self->zilla->build_in($opt->in);
    } else {
      my $method = $opt->tgz ? 'build_archive' : 'build';
      my $zilla;
      {
        # isolate changes to RELEASE_STATUS to zilla construction
        local $ENV{RELEASE_STATUS} = $ENV{RELEASE_STATUS};
        $ENV{RELEASE_STATUS} = 'testing' if $opt->trial;
        $zilla  = $self->zilla;
      }
      $zilla->$method;
    }
  
    $self->zilla->log('built in ' . $self->zilla->built_in);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::build - build your dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    dzil build [ --trial ] [ --tgz | --no-tgz ] [ --in /path/to/build/dir ]
  
  =head1 DESCRIPTION
  
  This command is a very thin layer over the Dist::Zilla C<build> method, which
  does all the things required to build your distribution.  By default, it will
  also archive your distribution and leave you with a complete, ready-to-release
  distribution tarball.
  
  =head1 EXAMPLE
  
    $ dzil build
    $ dzil build --no-tgz
    $ dzil build --in /path/to/build/dir
  
  =head1 OPTIONS
  
  =head2 --trial
  
  This will build a trial distribution.  Among other things, it will generally
  mean that the built tarball's basename ends in F<-TRIAL>.
  
  =head2 --tgz | --no-tgz
  
  Builds a .tar.gz in your project directory after building the distribution.
  
  --tgz behaviour is by default, use --no-tgz to disable building an archive.
  
  =head2 --in
  
  Specifies the directory into which the distribution should be built.  If
  necessary, the directory will be created.  An archive will not be created.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_BUILD

$fatpacked{"Dist/Zilla/App/Command/clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_CLEAN';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::clean 6.007;
  # ABSTRACT: clean up after build, test, or install
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   dzil clean [ --dry-run|-n ]
  #pod
  #pod This command removes some files that are created during build, test, and
  #pod install.  It's a very thin layer over the C<L<clean|Dist::Zilla/clean>> method
  #pod on the Dist::Zilla object.  The documentation for that method gives more
  #pod information about the files that will be removed.
  #pod
  #pod =cut
  
  sub opt_spec {
    [ 'dry-run|n'   => 'don\'t actually remove anything, just show what would be done' ],
  }
  
  #pod =head1 OPTIONS
  #pod
  #pod =head2 -n, --dry-run
  #pod
  #pod Nothing is removed; instead, everything that would be removed will be listed.
  #pod
  #pod =cut
  
  sub abstract { 'clean up after build, test, or install' }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    $self->zilla->clean($opt->dry_run);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::clean - clean up after build, test, or install
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    dzil clean [ --dry-run|-n ]
  
  This command removes some files that are created during build, test, and
  install.  It's a very thin layer over the C<L<clean|Dist::Zilla/clean>> method
  on the Dist::Zilla object.  The documentation for that method gives more
  information about the files that will be removed.
  
  =head1 OPTIONS
  
  =head2 -n, --dry-run
  
  Nothing is removed; instead, everything that would be removed will be listed.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_CLEAN

$fatpacked{"Dist/Zilla/App/Command/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_INSTALL';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::install 6.007;
  # ABSTRACT: install your dist
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod Installs your distribution using a specified command.
  #pod
  #pod     dzil install [--install-command="cmd"]
  #pod
  #pod =cut
  sub abstract { 'install your dist' }
  
  #pod =head1 EXAMPLE
  #pod
  #pod     $ dzil install
  #pod     $ dzil install --install-command="cpan ."
  #pod
  #pod =cut
  
  sub opt_spec {
    [ 'install-command=s', 'command to run to install (e.g. "cpan .")' ],
    [ 'keep-build-dir|keep' => 'keep the build directory even after a success' ],
  }
  
  #pod =head1 OPTIONS
  #pod
  #pod =head2 --install-command
  #pod
  #pod This defines what command to run after building the dist in the dist dir.
  #pod
  #pod Any value that works with L<C<system>|perlfunc/system> is accepted.
  #pod
  #pod If not specified, calls (roughly):
  #pod
  #pod     cpanm .
  #pod
  #pod For more information, look at the L<install|Dist::Zilla::Dist::Builder/install> method in
  #pod Dist::Zilla.
  #pod
  #pod =cut
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    $self->zilla->install({
      $opt->install_command
        ? (install_command => [ $opt->install_command ])
        : (),
      $opt->keep_build_dir
        ? (keep_build_dir => 1)
        : (),
    });
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::install - install your dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  Installs your distribution using a specified command.
  
      dzil install [--install-command="cmd"]
  
  =head1 EXAMPLE
  
      $ dzil install
      $ dzil install --install-command="cpan ."
  
  =head1 OPTIONS
  
  =head2 --install-command
  
  This defines what command to run after building the dist in the dist dir.
  
  Any value that works with L<C<system>|perlfunc/system> is accepted.
  
  If not specified, calls (roughly):
  
      cpanm .
  
  For more information, look at the L<install|Dist::Zilla::Dist::Builder/install> method in
  Dist::Zilla.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_INSTALL

$fatpacked{"Dist/Zilla/App/Command/listdeps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_LISTDEPS';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::listdeps 6.007;
  # ABSTRACT: print your distribution's prerequisites
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   $ dzil listdeps | cpan
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This is a command plugin for L<Dist::Zilla>. It provides the C<listdeps>
  #pod command, which prints your distribution's prerequisites. You could pipe that
  #pod list to a CPAN client like L<cpan> to install all of the dependencies in one
  #pod quick go.
  #pod
  #pod =head1 OPTIONS
  #pod
  #pod =head2 --author (or --develop)
  #pod
  #pod Include author dependencies (those listed under C<develop_requires>).
  #pod
  #pod =head2 --missing
  #pod
  #pod List only dependencies which are unsatisfied.
  #pod
  #pod =head2 --versions
  #pod
  #pod Also display the required versions of listed modules.
  #pod
  #pod =head2 --cpanm-versions
  #pod
  #pod Also display the required versions of listed modules, but in a format suitable
  #pod for piping into F<cpanm>.
  #pod
  #pod =head2 --json
  #pod
  #pod Lists all prerequisites in JSON format, as they would appear in META.json
  #pod (broken out into phases and types)
  #pod
  #pod =head1 ACKNOWLEDGEMENTS
  #pod
  #pod This code was originally more or less a direct copy of Marcel Gruenauer (hanekomu)
  #pod Dist::Zilla::App::Command::prereqs, updated to work with the Dist::Zilla v2
  #pod API.
  #pod
  #pod =cut
  
  sub abstract { "print your distribution's prerequisites" }
  
  sub opt_spec {
    [ 'develop|author', 'include author/develop dependencies' ],
    [ 'missing', 'list only the missing dependencies' ],
    [ 'versions', 'include required version numbers in listing' ],
    [ 'cpanm-versions', 'format versions for consumption by cpanm' ],
    [ 'json', 'list dependencies by phase, in JSON format' ],
    [ 'omit-core=s', 'Omit dependencies that are shipped with the specified version of perl' ],
  }
  
  sub prereqs {
    my ($self, $zilla) = @_;
  
    $_->before_build for @{ $zilla->plugins_with(-BeforeBuild) };
    $_->gather_files for @{ $zilla->plugins_with(-FileGatherer) };
    $_->set_file_encodings for @{ $zilla->plugins_with(-EncodingProvider) };
    $_->prune_files  for @{ $zilla->plugins_with(-FilePruner) };
    $_->munge_files  for @{ $zilla->plugins_with(-FileMunger) };
    $_->register_prereqs for @{ $zilla->plugins_with(-PrereqSource) };
  
    my $prereqs = $zilla->prereqs;
  }
  
  my @phases = qw/configure build test runtime develop/;
  my @relationships = qw/requires recommends suggests/;
  
  sub filter_core {
    my ($prereqs, $core_version) = @_;
    $core_version = sprintf '%7.6f', $core_version if $core_version >= 5.010;
    $prereqs = $prereqs->clone if $prereqs->is_finalized;
    require Module::CoreList;
    for my $phase (@phases) {
      for my $relation (@relationships) {
        my $req = $prereqs->requirements_for($phase, $relation);
        for my $module ($req->required_modules) {
          next if not exists $Module::CoreList::version{$core_version}{$module};
          $req->clear_requirement($module) if $req->accepts_module($module, $Module::CoreList::version{$core_version}{$module});
        }
      }
    }
    return $prereqs;
  }
  
  sub extract_dependencies {
    my ($self, $zilla, $phases, $missing, $omit_core) = @_;
  
    my $prereqs = $self->prereqs($zilla);
    $prereqs = filter_core($prereqs, $omit_core) if $omit_core;
  
    require CPAN::Meta::Requirements;
    my $req = CPAN::Meta::Requirements->new;
  
    for my $phase (@$phases) {
      $req->add_requirements( $prereqs->requirements_for($phase, 'requires') );
      $req->add_requirements( $prereqs->requirements_for($phase, 'recommends') );
    }
  
    my @required = grep { $_ ne 'perl' } $req->required_modules;
    if ($missing) {
      require Module::Runtime;
      @required =
        grep {
          # Keep modules that can't be loaded or that don't have a $VERSION
          # matching our requirements
          ! eval {
            my $m = $_;
            # Will die if module is not installed
            Module::Runtime::require_module($m);
            # Returns true if $VERSION matches, so we will exclude the module
            $req->accepts_module($m => $m->VERSION)
          }
        } @required;
    }
  
    my $versions = $req->as_string_hash;
    return map { $_ => $versions->{$_} } @required;
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    $self->app->chrome->logger->mute;
  
    my @phases = qw(build test configure runtime);
    push @phases, 'develop' if $opt->develop;
  
    my $omit_core = $opt->omit_core;
    if($opt->json) {
      my $prereqs = $self->prereqs($self->zilla);
      $prereqs = filter_core($prereqs, $omit_core) if $omit_core;
      my $output = $prereqs->as_string_hash;
  
      require JSON::MaybeXS;
      print JSON::MaybeXS->new(ascii => 1, canonical => 1, pretty => 1)->encode($output), "\n";
      return 1;
    }
  
    my %modules = $self->extract_dependencies($self->zilla, \@phases, $opt->missing, $opt->omit_core);
  
    if ($opt->versions or $opt->cpanm_versions) {
      my @names = sort { lc $a cmp lc $b } keys %modules;
      if ($opt->cpanm_versions) {
        print qq{$_~"$modules{$_}"\n} for @names;
      } else {
        print "$_ = $modules{$_}\n" for @names;
      }
    } else {
        print "$_\n" for sort { lc $a cmp lc $b } keys(%modules);
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::listdeps - print your distribution's prerequisites
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    $ dzil listdeps | cpan
  
  =head1 DESCRIPTION
  
  This is a command plugin for L<Dist::Zilla>. It provides the C<listdeps>
  command, which prints your distribution's prerequisites. You could pipe that
  list to a CPAN client like L<cpan> to install all of the dependencies in one
  quick go.
  
  =head1 OPTIONS
  
  =head2 --author (or --develop)
  
  Include author dependencies (those listed under C<develop_requires>).
  
  =head2 --missing
  
  List only dependencies which are unsatisfied.
  
  =head2 --versions
  
  Also display the required versions of listed modules.
  
  =head2 --cpanm-versions
  
  Also display the required versions of listed modules, but in a format suitable
  for piping into F<cpanm>.
  
  =head2 --json
  
  Lists all prerequisites in JSON format, as they would appear in META.json
  (broken out into phases and types)
  
  =head1 ACKNOWLEDGEMENTS
  
  This code was originally more or less a direct copy of Marcel Gruenauer (hanekomu)
  Dist::Zilla::App::Command::prereqs, updated to work with the Dist::Zilla v2
  API.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_LISTDEPS

$fatpacked{"Dist/Zilla/App/Command/new.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_NEW';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::new 6.007;
  # ABSTRACT: mint a new dist
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod Creates a new Dist-Zilla based distribution under the current directory.
  #pod
  #pod   $ dzil new Main::Module::Name
  #pod
  #pod There are two arguments, C<-p> and C<-P>. C<-P> specify the minting profile
  #pod provider and C<-p> - the profile name.
  #pod
  #pod The default profile provider first looks in the
  #pod F<~/.dzil/profiles/$profile_name> and then among standard profiles, shipped
  #pod with Dist::Zilla. For example:
  #pod
  #pod   $ dzil new -p work Corporate::Library
  #pod
  #pod This command would instruct C<dzil> to look in F<~/.dzil/profiles/work> for a
  #pod F<profile.ini> (or other "profile" config file).  If no profile name is given,
  #pod C<dzil> will look for the C<default> profile.  If no F<default> directory
  #pod exists, it will use a very simple configuration shipped with Dist::Zilla.
  #pod
  #pod   $ dzil new -P Foo Corporate::Library
  #pod
  #pod This command would instruct C<dzil> to consult the Foo provider about the
  #pod directory of 'default' profile.
  #pod
  #pod Furthermore, it is possible to specify the default minting provider and profile
  #pod in the F<~/.dzil/config.ini> file, for example:
  #pod
  #pod   [%Mint]
  #pod   provider = FooCorp
  #pod   profile = work
  #pod
  #pod =cut
  
  sub abstract { 'mint a new dist' }
  
  sub usage_desc { '%c %o <ModuleName>' }
  
  sub opt_spec {
    [ 'profile|p=s',  'name of the profile to use',
      { default => 'default' }  ],
  
    [ 'provider|P=s', 'name of the profile provider to use',
      { default => 'Default' }  ],
  
    # [ 'module|m=s@', 'module(s) to create; may be given many times'         ],
  }
  
  sub validate_args {
    my ($self, $opt, $args) = @_;
  
    require MooseX::Types::Perl;
  
    $self->usage_error('dzil new takes exactly one argument') if @$args != 1;
  
    my $name = $args->[0];
  
    $name =~ s/::/-/g if MooseX::Types::Perl::is_ModuleName($name)
                 and not MooseX::Types::Perl::is_DistName($name);
  
    $self->usage_error("$name is not a valid distribution name")
      unless MooseX::Types::Perl::is_DistName($name);
  
    $args->[0] = $name;
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    my $dist = $arg->[0];
  
    require Dist::Zilla::Dist::Minter;
    my $stash = $self->app->_build_global_stashes;
    my $minter = Dist::Zilla::Dist::Minter->_new_from_profile(
      ( exists $stash->{'%Mint'} ?
        [ $stash->{'%Mint'}->provider, $stash->{'%Mint'}->profile ] :
        [ $opt->provider, $opt->profile ]
      ),
      {
        chrome  => $self->app->chrome,
        name    => $dist,
        _global_stashes => $stash,
      },
    );
  
    $minter->mint_dist({
      # modules => $opt->module,
    });
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::new - mint a new dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  Creates a new Dist-Zilla based distribution under the current directory.
  
    $ dzil new Main::Module::Name
  
  There are two arguments, C<-p> and C<-P>. C<-P> specify the minting profile
  provider and C<-p> - the profile name.
  
  The default profile provider first looks in the
  F<~/.dzil/profiles/$profile_name> and then among standard profiles, shipped
  with Dist::Zilla. For example:
  
    $ dzil new -p work Corporate::Library
  
  This command would instruct C<dzil> to look in F<~/.dzil/profiles/work> for a
  F<profile.ini> (or other "profile" config file).  If no profile name is given,
  C<dzil> will look for the C<default> profile.  If no F<default> directory
  exists, it will use a very simple configuration shipped with Dist::Zilla.
  
    $ dzil new -P Foo Corporate::Library
  
  This command would instruct C<dzil> to consult the Foo provider about the
  directory of 'default' profile.
  
  Furthermore, it is possible to specify the default minting provider and profile
  in the F<~/.dzil/config.ini> file, for example:
  
    [%Mint]
    provider = FooCorp
    profile = work
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_NEW

$fatpacked{"Dist/Zilla/App/Command/nop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_NOP';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::nop 6.007;
  # ABSTRACT: initialize dzil, then exit
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod This command does nothing.  It initializes Dist::Zilla, then exits.  This is
  #pod useful to see the logging output of plugin initialization.
  #pod
  #pod   dzil nop -v
  #pod
  #pod Seriously, this command is almost entirely for diagnostic purposes.  Don't
  #pod overthink it, okay?
  #pod
  #pod =cut
  
  sub abstract { 'do nothing: initialize dzil, then exit' }
  
  sub description {
    "This command does nothing but initialize Dist::Zilla and exit.\n" .
    "It is sometimes useful for diagnostic purposes."
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    $self->zilla;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::nop - initialize dzil, then exit
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  This command does nothing.  It initializes Dist::Zilla, then exits.  This is
  useful to see the logging output of plugin initialization.
  
    dzil nop -v
  
  Seriously, this command is almost entirely for diagnostic purposes.  Don't
  overthink it, okay?
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_NOP

$fatpacked{"Dist/Zilla/App/Command/release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_RELEASE';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::release 6.007;
  # ABSTRACT: release your dist to the CPAN
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   dzil release
  #pod
  #pod   dzil release --trial
  #pod
  #pod This command is a very, very thin wrapper around the
  #pod C<L<release|Dist::Zilla/release>> method on the Dist::Zilla object.  It will
  #pod build, archive, and release your distribution using your Releaser plugins.  The
  #pod only option, C<--trial>, will cause it to build a trial build.
  #pod
  #pod =cut
  
  sub abstract { 'release your dist' }
  
  sub opt_spec {
    [ 'trial' => 'build a trial release that PAUSE will not index' ],
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    my $zilla;
    {
      # isolate changes to RELEASE_STATUS to zilla construction
      local $ENV{RELEASE_STATUS} = $ENV{RELEASE_STATUS};
      $ENV{RELEASE_STATUS} = 'testing' if $opt->trial;
      $zilla = $self->zilla;
    }
  
    $self->zilla->release;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::release - release your dist to the CPAN
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    dzil release
  
    dzil release --trial
  
  This command is a very, very thin wrapper around the
  C<L<release|Dist::Zilla/release>> method on the Dist::Zilla object.  It will
  build, archive, and release your distribution using your Releaser plugins.  The
  only option, C<--trial>, will cause it to build a trial build.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_RELEASE

$fatpacked{"Dist/Zilla/App/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_RUN';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::run 6.007;
  # ABSTRACT: run stuff in a dir where your dist is built
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   $ dzil run ./bin/myscript
  #pod   $ dzil run prove -bv t/mytest.t
  #pod   $ dzil run bash
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will build your dist with Dist::Zilla, then build the
  #pod distribution and then run a command in the build directory.  It's something
  #pod like doing this:
  #pod
  #pod   dzil build
  #pod   rsync -avp My-Project-version/ .build/
  #pod   cd .build
  #pod   perl Makefile.PL            # or perl Build.PL
  #pod   make                        # or ./Build
  #pod   export PERL5LIB=$PWD/blib/lib:$PWD/blib/arch
  #pod   <your command as defined by rest of params>
  #pod
  #pod Except for the fact it's built directly in a subdir of .build (like
  #pod F<.build/69105y2>).
  #pod
  #pod A command returning with an non-zero error code will left the build directory
  #pod behind for analysis, and C<dzil> will exit with a non-zero status.  Otherwise,
  #pod the build directory will be removed and dzil will exit with status zero.
  #pod
  #pod If no run command is provided, a new default shell is invoked. This can be
  #pod useful for testing your distribution as if it were installed.
  #pod
  #pod =cut
  
  sub abstract { 'run stuff in a dir where your dist is built' }
  
  sub opt_spec {
    [ 'build!' => 'do the Build actions before running the command; done by default',
                  { default => 1 } ],
    [ 'trial'  => 'build a trial release that PAUSE will not index' ],
  }
  
  sub description {
    "This will build your dist and run the given 'command' in the build dir.\n" .
    "If no command was specified, your shell will be run there instead."
  }
  
  sub usage_desc {
    return '%c run %o [ command [ arg1 arg2 ... ] ]';
  }
  
  sub execute {
    my ($self, $opt, $args) = @_;
  
    unless (@$args) {
      my $envname = $^O eq 'MSWin32' ? 'COMSPEC' : 'SHELL';
      unless ($ENV{$envname}) {
        $self->usage_error("no command supplied to run and no \$$envname set");
      }
      $args = [ $ENV{$envname} ];
      $self->log("no command supplied to run so using \$$envname: $args->[0]");
    }
  
    $self->zilla->run_in_build($args, { build => $opt->build, trial => $opt->trial });
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::run - run stuff in a dir where your dist is built
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    $ dzil run ./bin/myscript
    $ dzil run prove -bv t/mytest.t
    $ dzil run bash
  
  =head1 DESCRIPTION
  
  This command will build your dist with Dist::Zilla, then build the
  distribution and then run a command in the build directory.  It's something
  like doing this:
  
    dzil build
    rsync -avp My-Project-version/ .build/
    cd .build
    perl Makefile.PL            # or perl Build.PL
    make                        # or ./Build
    export PERL5LIB=$PWD/blib/lib:$PWD/blib/arch
    <your command as defined by rest of params>
  
  Except for the fact it's built directly in a subdir of .build (like
  F<.build/69105y2>).
  
  A command returning with an non-zero error code will left the build directory
  behind for analysis, and C<dzil> will exit with a non-zero status.  Otherwise,
  the build directory will be removed and dzil will exit with status zero.
  
  If no run command is provided, a new default shell is invoked. This can be
  useful for testing your distribution as if it were installed.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_RUN

$fatpacked{"Dist/Zilla/App/Command/setup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_SETUP';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::setup 6.007;
  # ABSTRACT: set up a basic global config file
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   $ dzil setup
  #pod   Enter your name> Ricardo Signes
  #pod   ...
  #pod
  #pod Dist::Zilla looks for per-user configuration in F<~/.dzil/config.ini>.  This
  #pod command prompts the user for some basic information that can be used to produce
  #pod the most commonly needed F<config.ini> sections.
  #pod
  #pod B<WARNING>: PAUSE account details are stored within config.ini in plain text.
  #pod
  #pod =cut
  
  use autodie;
  
  sub abstract { 'set up a basic global config file' }
  
  sub description {
    "This command will run through a short interactive process to set up\n" .
    "a basic Dist::Zilla configuration in ~/.dzil/config.ini"
  }
  
  sub validate_args {
    my ($self, $opt, $args) = @_;
  
    $self->usage_error('too many arguments') if @$args != 0;
  }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    my $chrome = $self->app->chrome;
  
    require Dist::Zilla::Util;
    my $config_root = Dist::Zilla::Util->_global_config_root;
  
    if (
      -d $config_root
      and
      my @files = grep { -f and $_->basename =~ /\Aconfig\.[^.]+\z/ }
      $config_root->children
    ) {
      $chrome->logger->log_fatal([
        "per-user configuration files already exist in %s: %s",
        "$config_root",
        join(q{, }, @files),
      ]);
  
      return unless $chrome->prompt_yn("Continue anyway?", { default => 0 });
    }
  
    my $realname = $chrome->prompt_str(
      "What's your name? ",
      { check => sub { defined $_[0] and $_[0] =~ /\S/ } },
    );
  
    my $email = $chrome->prompt_str(
      "What's your email address? ",
      { check => sub { defined $_[0] and $_[0] =~ /\A\S+\@\S+\z/ } },
    );
  
    my $c_holder = $chrome->prompt_str(
      "Who, by default, holds the copyright on your code? ",
      {
        check   => sub { defined $_[0] and $_[0] =~ /\S/ },
        default => $realname,
      },
    );
  
    my $license = $chrome->prompt_str(
      "What license will you use by default (Perl_5, BSD, etc.)? ",
      {
        default => 'Perl_5',
        check   => sub {
          my $str = String::RewritePrefix->rewrite(
            { '' => 'Software::License::', '=' => '' },
            $_[0],
          );
  
          return Params::Util::_CLASS($str) && eval "require $str; 1";
        },
      },
    );
  
    my %pause;
  
    if (
      $chrome->prompt_yn(
      '
      * WARNING - Your account details will be stored in plain text *
  Do you want to enter your PAUSE account details? ',
        { default => 0 },
      )
    ) {
      my $default_pause;
      if ($email =~ /\A(.+?)\@cpan\.org\z/i) {
        $default_pause = uc $1;
      }
  
      $pause{username} = $chrome->prompt_str(
        "What is your PAUSE id? ",
        {
          check   => sub { defined $_[0] and $_[0] =~ /\A\w+\z/ },
          default => $default_pause,
        },
      );
  
      $pause{password} = $chrome->prompt_str(
        "What is your PAUSE password? ",
        {
          check   => sub { length $_[0] },
          noecho  => 1,
        },
      );
    }
  
    $config_root->mkpath unless -d $config_root;
    $config_root->child('profiles')->mkpath
      unless -d $config_root->child('profiles');
  
    my $umask = umask;
    umask( $umask | 077 ); # this file might contain PAUSE pw; make it go-r
    open my $fh, '>:encoding(UTF-8)', $config_root->child('config.ini');
  
    $fh->print("[%User]\n");
    $fh->print("name  = $realname\n");
    $fh->print("email = $email\n\n");
  
    $fh->print("[%Rights]\n");
    $fh->print("license_class    = $license\n");
    $fh->print("copyright_holder = $c_holder\n\n");
  
    if (keys %pause) {
      $fh->print("[%PAUSE]\n");
      $fh->print("username = $pause{username}\n");
      if (length $pause{password}) {
        $fh->print("password = $pause{password}\n");
      }
      $fh->print("\n");
    }
  
    close $fh;
  
    umask $umask;
  
    $self->log("config.ini file created!");
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::setup - set up a basic global config file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    $ dzil setup
    Enter your name> Ricardo Signes
    ...
  
  Dist::Zilla looks for per-user configuration in F<~/.dzil/config.ini>.  This
  command prompts the user for some basic information that can be used to produce
  the most commonly needed F<config.ini> sections.
  
  B<WARNING>: PAUSE account details are stored within config.ini in plain text.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_SETUP

$fatpacked{"Dist/Zilla/App/Command/smoke.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_SMOKE';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::smoke 6.007;
  # ABSTRACT: smoke your dist
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   dzil smoke [ --release ] [ --author ] [ --no-automated ]
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This command builds and tests the distribution in "smoke testing mode."
  #pod
  #pod This command is a thin wrapper around the L<test|Dist::Zilla::Dist::Builder/test> method in
  #pod Dist::Zilla.  It builds your dist and runs the tests with the AUTOMATED_TESTING
  #pod environment variable turned on, so it's like doing this:
  #pod
  #pod   export AUTOMATED_TESTING=1
  #pod   dzil build --no-tgz
  #pod   cd $BUILD_DIRECTORY
  #pod   perl Makefile.PL
  #pod   make
  #pod   make test
  #pod
  #pod A build that fails tests will be left behind for analysis, and F<dzil> will
  #pod exit a non-zero value.  If the tests are successful, the build directory will
  #pod be removed and F<dzil> will exit with status 0.
  #pod
  #pod =cut
  
  sub opt_spec {
    [ 'release'   => 'enables the RELEASE_TESTING env variable', { default => 0 } ],
    [ 'automated!' => 'enables the AUTOMATED_TESTING env variable (default behavior)', { default => 1 } ],
    [ 'author' => 'enables the AUTHOR_TESTING env variable', { default => 0 } ]
  }
  
  #pod =head1 OPTIONS
  #pod
  #pod =head2 --release
  #pod
  #pod This will run the test suite with RELEASE_TESTING=1
  #pod
  #pod =head2 --no-automated
  #pod
  #pod This will run the test suite without setting AUTOMATED_TESTING
  #pod
  #pod =head2 --author
  #pod
  #pod This will run the test suite with AUTHOR_TESTING=1
  #pod
  #pod =cut
  
  sub abstract { 'smoke your dist' }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    local $ENV{RELEASE_TESTING} = 1 if $opt->release;
    local $ENV{AUTHOR_TESTING} = 1 if $opt->author;
    local $ENV{AUTOMATED_TESTING} = 1 if $opt->automated;
  
    $self->zilla->test;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::smoke - smoke your dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    dzil smoke [ --release ] [ --author ] [ --no-automated ]
  
  =head1 DESCRIPTION
  
  This command builds and tests the distribution in "smoke testing mode."
  
  This command is a thin wrapper around the L<test|Dist::Zilla::Dist::Builder/test> method in
  Dist::Zilla.  It builds your dist and runs the tests with the AUTOMATED_TESTING
  environment variable turned on, so it's like doing this:
  
    export AUTOMATED_TESTING=1
    dzil build --no-tgz
    cd $BUILD_DIRECTORY
    perl Makefile.PL
    make
    make test
  
  A build that fails tests will be left behind for analysis, and F<dzil> will
  exit a non-zero value.  If the tests are successful, the build directory will
  be removed and F<dzil> will exit with status 0.
  
  =head1 OPTIONS
  
  =head2 --release
  
  This will run the test suite with RELEASE_TESTING=1
  
  =head2 --no-automated
  
  This will run the test suite without setting AUTOMATED_TESTING
  
  =head2 --author
  
  This will run the test suite with AUTHOR_TESTING=1
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_SMOKE

$fatpacked{"Dist/Zilla/App/Command/test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_TEST';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::test 6.007;
  # ABSTRACT: test your dist
  
  use Dist::Zilla::App -command;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   dzil test [ --release ] [ --no-author ] [ --automated ] [ --extended ] [ --all ]
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This command is a thin wrapper around the L<test|Dist::Zilla::Dist::Builder/test> method in
  #pod Dist::Zilla.  It builds your dist and runs the tests with the AUTHOR_TESTING
  #pod environment variable turned on, so it's like doing this:
  #pod
  #pod   export AUTHOR_TESTING=1
  #pod   dzil build --no-tgz
  #pod   cd $BUILD_DIRECTORY
  #pod   perl Makefile.PL
  #pod   make
  #pod   make test
  #pod
  #pod A build that fails tests will be left behind for analysis, and F<dzil> will
  #pod exit a non-zero value.  If the tests are successful, the build directory will
  #pod be removed and F<dzil> will exit with status 0.
  #pod
  #pod =cut
  
  sub opt_spec {
    [ 'release'   => 'enables the RELEASE_TESTING env variable', { default => 0 } ],
    [ 'automated' => 'enables the AUTOMATED_TESTING env variable', { default => 0 } ],
    [ 'extended' => 'enables the EXTENDED_TESTING env variable', { default => 0 } ],
    [ 'author!' => 'enables the AUTHOR_TESTING env variable (default behavior)', { default => 1 } ],
    [ 'all' => 'enables the RELEASE_TESTING, AUTOMATED_TESTING, EXTENDED_TESTING and AUTHOR_TESTING env variables', { default => 0 } ],
    [ 'keep-build-dir|keep' => 'keep the build directory even after a success' ],
    [ 'jobs|j=i' => 'number of parallel test jobs to run' ],
    [ 'test-verbose' => 'enables verbose testing (TEST_VERBOSE env variable on Makefile.PL, --verbose on Build.PL', { default => 0 } ],
  }
  
  #pod =head1 OPTIONS
  #pod
  #pod =head2 --release
  #pod
  #pod This will run the test suite with RELEASE_TESTING=1
  #pod
  #pod =head2 --automated
  #pod
  #pod This will run the test suite with AUTOMATED_TESTING=1
  #pod
  #pod =head2 --extended
  #pod
  #pod This will run the test suite with EXTENDED_TESTING=1
  #pod
  #pod =head2 --no-author
  #pod
  #pod This will run the test suite without setting AUTHOR_TESTING
  #pod
  #pod =head2 --all
  #pod
  #pod Equivalent to --release --automated --extended --author
  #pod
  #pod =cut
  
  sub abstract { 'test your dist' }
  
  sub execute {
    my ($self, $opt, $arg) = @_;
  
    local $ENV{RELEASE_TESTING} = 1 if $opt->release or $opt->all;
    local $ENV{AUTHOR_TESTING} = 1 if $opt->author or $opt->all;
    local $ENV{AUTOMATED_TESTING} = 1 if $opt->automated or $opt->all;
    local $ENV{EXTENDED_TESTING} = 1 if $opt->extended or $opt->all;
  
    $self->zilla->test({
      $opt->keep_build_dir
        ? (keep_build_dir => 1)
        : (),
      $opt->jobs
        ? (jobs => $opt->jobs)
        : (),
  	$opt->test_verbose
  	  ? (test_verbose => $opt->test_verbose)
  	  : (),
    });
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::test - test your dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    dzil test [ --release ] [ --no-author ] [ --automated ] [ --extended ] [ --all ]
  
  =head1 DESCRIPTION
  
  This command is a thin wrapper around the L<test|Dist::Zilla::Dist::Builder/test> method in
  Dist::Zilla.  It builds your dist and runs the tests with the AUTHOR_TESTING
  environment variable turned on, so it's like doing this:
  
    export AUTHOR_TESTING=1
    dzil build --no-tgz
    cd $BUILD_DIRECTORY
    perl Makefile.PL
    make
    make test
  
  A build that fails tests will be left behind for analysis, and F<dzil> will
  exit a non-zero value.  If the tests are successful, the build directory will
  be removed and F<dzil> will exit with status 0.
  
  =head1 OPTIONS
  
  =head2 --release
  
  This will run the test suite with RELEASE_TESTING=1
  
  =head2 --automated
  
  This will run the test suite with AUTOMATED_TESTING=1
  
  =head2 --extended
  
  This will run the test suite with EXTENDED_TESTING=1
  
  =head2 --no-author
  
  This will run the test suite without setting AUTHOR_TESTING
  
  =head2 --all
  
  Equivalent to --release --automated --extended --author
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_TEST

$fatpacked{"Dist/Zilla/App/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_COMMAND_VERSION';
  use strict;
  use warnings;
  package Dist::Zilla::App::Command::version 6.007;
  # ABSTRACT: display dzil's version
  
  use Dist::Zilla::App -command;
  use App::Cmd::Command::version;
  BEGIN {
    ## parent and base dont work here. ??? -- kentnl 2014-10-31
    our @ISA;
    unshift @ISA, 'App::Cmd::Command::version';
  }
  
  #pod =head1 SYNOPSIS
  #pod
  #pod Print dzil version
  #pod
  #pod   $ dzil --version or $dzil version
  #pod
  #pod =cut
  
  sub version_for_display {
    my $version_pkg = $_[0]->version_package;
    my $version = ( $version_pkg->VERSION ?
                    $version_pkg->VERSION :
                   'dev' );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Command::version - display dzil's version
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  Print dzil version
  
    $ dzil --version or $dzil version
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_COMMAND_VERSION

$fatpacked{"Dist/Zilla/App/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_APP_TESTER';
  use strict;
  use warnings;
  package Dist::Zilla::App::Tester 6.007;
  # ABSTRACT: testing library for Dist::Zilla::App
  
  use parent 'App::Cmd::Tester::CaptureExternal';
  use App::Cmd::Tester 0.306 (); # result_class, ->app
  
  use Dist::Zilla::App;
  use File::Copy::Recursive qw(dircopy);
  use File::pushd ();
  use File::Spec;
  use File::Temp;
  use Dist::Zilla::Path;
  
  use Sub::Exporter::Util ();
  use Sub::Exporter -setup => {
    exports => [ test_dzil => Sub::Exporter::Util::curry_method() ],
    groups  => [ default   => [ qw(test_dzil) ] ],
  };
  
  sub result_class { 'Dist::Zilla::App::Tester::Result' }
  
  sub test_dzil {
    my ($self, $source, $argv, $arg) = @_;
    $arg ||= {};
  
    local @INC = map {; ref($_) ? $_ : File::Spec->rel2abs($_) } @INC;
  
    my $tmpdir = $arg->{tempdir} || File::Temp::tempdir(CLEANUP => 1);
    my $root   = path($tmpdir)->child('source');
    $root->mkpath;
  
    dircopy($source, $root);
  
    my $wd = File::pushd::pushd($root);
  
    local $ENV{DZIL_TESTING} = 1;
    my $result = $self->test_app('Dist::Zilla::App' => $argv);
    $result->{tempdir} = $tmpdir;
  
    return $result;
  }
  
  {
    package Dist::Zilla::App::Tester::Result 6.007;
  
    BEGIN { our @ISA = qw(App::Cmd::Tester::Result); }
  
    sub tempdir {
      my ($self) = @_;
      return $self->{tempdir};
    }
  
    sub zilla {
      my ($self) = @_;
      return $self->app->zilla;
    }
  
    sub build_dir {
      my ($self) = @_;
      return $self->zilla->built_in;
    }
  
    sub clear_log_events {
      my ($self) = @_;
      $self->app->zilla->logger->logger->clear_events;
    }
  
    sub log_events {
      my ($self) = @_;
      $self->app->zilla->logger->logger->events;
    }
  
    sub log_messages {
      my ($self) = @_;
      [ map {; $_->{message} } @{ $self->app->zilla->logger->logger->events } ];
    }
  }
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This module exports only one function, C<test_dzil>.
  #pod
  #pod =head2 C<test_dzil>
  #pod
  #pod This function is used to test L<Dist::Zilla::App>.
  #pod It receives two mandatory options. The first is the path to a Dist::Zilla-based
  #pod distribution. The second, an array reference to a list of arguments. 
  #pod
  #pod The third optional argument is a hash reference, with further options. At the moment
  #pod the only supported option is c<tempdir>.
  #pod
  #pod It returns a L<Dist::Zilla::App::Tester::Result>, that inherits from 
  #pod L<App::Cmd::Tester::Result>. Typical methods called from this result are:
  #pod
  #pod =over 4 
  #pod
  #pod =item C<output>
  #pod
  #pod The output of running dzil;
  #pod
  #pod =item C<tempdir>
  #pod
  #pod The folder used for temporary files.
  #pod
  #pod =item C<build_dir>
  #pod
  #pod The folder where the distribution was built.
  #pod
  #pod =back
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::App::Tester - testing library for Dist::Zilla::App
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This module exports only one function, C<test_dzil>.
  
  =head2 C<test_dzil>
  
  This function is used to test L<Dist::Zilla::App>.
  It receives two mandatory options. The first is the path to a Dist::Zilla-based
  distribution. The second, an array reference to a list of arguments. 
  
  The third optional argument is a hash reference, with further options. At the moment
  the only supported option is c<tempdir>.
  
  It returns a L<Dist::Zilla::App::Tester::Result>, that inherits from 
  L<App::Cmd::Tester::Result>. Typical methods called from this result are:
  
  =over 4 
  
  =item C<output>
  
  The output of running dzil;
  
  =item C<tempdir>
  
  The folder used for temporary files.
  
  =item C<build_dir>
  
  The folder where the distribution was built.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_APP_TESTER

$fatpacked{"Dist/Zilla/Chrome/Term.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_CHROME_TERM';
  package Dist::Zilla::Chrome::Term 6.007;
  # ABSTRACT: chrome used for terminal-based interaction
  
  use Moose;
  
  #pod =head1 OVERVIEW
  #pod
  #pod This class provides a L<Dist::Zilla::Chrome> implementation for use in a
  #pod terminal environment.  It's the default chrome used by L<Dist::Zilla::App>.
  #pod
  #pod =cut
  
  use Dist::Zilla::Types qw(OneZero);
  use Encode ();
  use Log::Dispatchouli 1.102220;
  
  use namespace::autoclean;
  
  has logger => (
    is  => 'ro',
    isa => 'Log::Dispatchouli',
    init_arg => undef,
    writer   => '_set_logger',
    lazy => 1,
    builder => '_build_logger',
  );
  
  sub _build_logger {
    my $self = shift;
    my $enc = $self->term_enc;
  
    if ($enc && Encode::resolve_alias($enc)) {
      my $layer = sprintf(":encoding(%s)", $enc);
      binmode( STDOUT, $layer );
      binmode( STDERR, $layer );
    }
  
    return Log::Dispatchouli->new({
        ident     => 'Dist::Zilla',
        to_stdout => 1,
        log_pid   => 0,
        to_self   => ($ENV{DZIL_TESTING} ? 1 : 0),
        quiet_fatal => 'stdout',
    });
  }
  
  has term_ui => (
    is   => 'ro',
    isa  => 'Object',
    lazy => 1,
    default => sub {
      require Term::ReadLine;
      require Term::UI;
      Term::ReadLine->new('dzil')
    },
  );
  
  has term_enc => (
    is   => 'ro',
    lazy => 1,
    default => sub {
      require Term::Encoding;
      return Term::Encoding::get_encoding();
    },
  );
  
  sub prompt_str {
    my ($self, $prompt, $arg) = @_;
    $arg ||= {};
    my $default = $arg->{default};
    my $check   = $arg->{check};
  
    require Encode;
    my $term_enc = $self->term_enc;
  
    my $encode = $term_enc
               ? sub { Encode::encode($term_enc, shift, Encode::FB_CROAK())  }
               : sub { shift };
    my $decode = $term_enc
               ? sub { Encode::decode($term_enc, shift, Encode::FB_CROAK())  }
               : sub { shift };
  
    if ($arg->{noecho}) {
      require Term::ReadKey;
      Term::ReadKey::ReadMode('noecho');
    }
    my $input_bytes = $self->term_ui->get_reply(
      prompt => $encode->($prompt),
      allow  => $check || sub { length $_[0] },
      (defined $default
        ? (default => $encode->($default))
        : ()
      ),
    );
    if ($arg->{noecho}) {
      Term::ReadKey::ReadMode('normal');
      # The \n ending user input disappears under noecho; this ensures
      # the next output ends up on the next line.
      print "\n";
    }
  
    my $input = $decode->($input_bytes);
    chomp $input;
  
    return $input;
  }
  
  sub prompt_yn {
    my ($self, $prompt, $arg) = @_;
    $arg ||= {};
    my $default = $arg->{default};
  
    my $input = $self->term_ui->ask_yn(
      prompt  => $prompt,
      (defined $default ? (default => OneZero->coerce($default)) : ()),
    );
  
    return $input;
  }
  
  sub prompt_any_key {
    my ($self, $prompt) = @_;
    $prompt ||= 'press any key to continue';
  
    my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT));
  
    if ($isa_tty) {
      local $| = 1;
      print $prompt;
  
      require Term::ReadKey;
      Term::ReadKey::ReadMode('cbreak');
      Term::ReadKey::ReadKey(0);
      Term::ReadKey::ReadMode('normal');
      print "\n";
    }
  }
  
  with 'Dist::Zilla::Role::Chrome';
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Chrome::Term - chrome used for terminal-based interaction
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  This class provides a L<Dist::Zilla::Chrome> implementation for use in a
  terminal environment.  It's the default chrome used by L<Dist::Zilla::App>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_CHROME_TERM

$fatpacked{"Dist/Zilla/Chrome/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_CHROME_TEST';
  package Dist::Zilla::Chrome::Test 6.007;
  # ABSTRACT: the chrome used by Dist::Zilla::Tester
  
  use Moose;
  
  use MooseX::Types::Moose qw(ArrayRef HashRef Str);
  use Dist::Zilla::Types qw(OneZero);
  use Log::Dispatchouli 1.102220;
  
  has logger => (
    is => 'ro',
    default => sub {
      Log::Dispatchouli->new({
        ident   => 'Dist::Zilla::Tester',
        log_pid => 0,
        to_self => 1,
      });
    }
  );
  
  #pod =attr response_for
  #pod
  #pod The response_for attribute (which exists only in the Test chrome) is a
  #pod hashref that lets you specify the answer to questions asked by
  #pod C<prompt_str> or C<prompt_yn>.  The key is the prompt string.  If the
  #pod value is a string, it is returned every time that question is asked.
  #pod If the value is an arrayref, the first element is shifted off and
  #pod returned every time the question is asked.  If the arrayref is empty
  #pod (or the prompt is not listed in the hash), the default answer (if any)
  #pod is returned.
  #pod
  #pod Since you can't pass arguments to the Chrome constructor, response_for
  #pod is initialized to an empty hash, and you can add entries after
  #pod construction with the C<set_response_for> method:
  #pod
  #pod   $chrome->set_response_for($prompt => $response);
  #pod
  #pod =cut
  
  has response_for => (
    isa     => HashRef[ ArrayRef | Str ],
    traits  => [ 'Hash' ],
    default => sub { {} },
    handles => {
      response_for     => 'get',
      set_response_for => 'set',
    },
  );
  
  sub prompt_str {
    my ($self, $prompt, $arg) = @_;
    $arg ||= {};
  
    my $response = $self->response_for($prompt);
  
    $response = shift @$response if ref $response;
  
    $response = $arg->{default} unless defined $response;
  
    $self->logger->log_fatal("no response for test prompt '$prompt'")
      unless defined $response;
  
    return $response;
  }
  
  sub prompt_yn {
    my $self = shift;
  
    return OneZero->coerce( $self->prompt_str(@_) );
  }
  
  sub prompt_any_key { return }
  
  with 'Dist::Zilla::Role::Chrome';
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Chrome::Test - the chrome used by Dist::Zilla::Tester
  
  =head1 VERSION
  
  version 6.007
  
  =head1 ATTRIBUTES
  
  =head2 response_for
  
  The response_for attribute (which exists only in the Test chrome) is a
  hashref that lets you specify the answer to questions asked by
  C<prompt_str> or C<prompt_yn>.  The key is the prompt string.  If the
  value is a string, it is returned every time that question is asked.
  If the value is an arrayref, the first element is shifted off and
  returned every time the question is asked.  If the arrayref is empty
  (or the prompt is not listed in the hash), the default answer (if any)
  is returned.
  
  Since you can't pass arguments to the Chrome constructor, response_for
  is initialized to an empty hash, and you can add entries after
  construction with the C<set_response_for> method:
  
    $chrome->set_response_for($prompt => $response);
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_CHROME_TEST

$fatpacked{"Dist/Zilla/Dist/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_DIST_BUILDER';
  package Dist::Zilla::Dist::Builder 6.007;
  # ABSTRACT: dist zilla subclass for building dists
  
  use Moose 0.92; # role composition fixes
  extends 'Dist::Zilla';
  
  use MooseX::Types::Moose qw(HashRef);
  use Dist::Zilla::Types qw(Path);
  
  use File::pushd ();
  use Dist::Zilla::Path; # because more Path::* is better, eh?
  use Try::Tiny;
  use List::Util 1.45 'uniq';
  
  use namespace::autoclean;
  
  #pod =method from_config
  #pod
  #pod   my $zilla = Dist::Zilla->from_config(\%arg);
  #pod
  #pod This routine returns a new Zilla from the configuration in the current working
  #pod directory.
  #pod
  #pod This method should not be relied upon, yet.  Its semantics are B<certain> to
  #pod change.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   config_class - the class to use to read the config
  #pod                  default: Dist::Zilla::MVP::Reader::Finder
  #pod
  #pod =cut
  
  sub from_config {
    my ($class, $arg) = @_;
    $arg ||= {};
  
    my $root = path($arg->{dist_root} || '.');
  
    my $sequence = $class->_load_config({
      root   => $root,
      chrome => $arg->{chrome},
      config_class    => $arg->{config_class},
      _global_stashes => $arg->{_global_stashes},
    });
  
    my $self = $sequence->section_named('_')->zilla;
  
    $self->_setup_default_plugins;
  
    return $self;
  }
  
  sub _setup_default_plugins {
    my ($self) = @_;
    unless ($self->plugin_named(':InstallModules')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':InstallModules',
        zilla       => $self,
        style       => 'grep',
        code        => sub {
          my ($file, $self) = @_;
          local $_ = $file->name;
          return 1 if m{\Alib/} and m{\.(pm|pod)$};
          return;
        },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':IncModules')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':IncModules',
        zilla       => $self,
        style       => 'grep',
        code        => sub {
          my ($file, $self) = @_;
          local $_ = $file->name;
          return 1 if m{\Ainc/} and m{\.pm$};
          return;
        },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':TestFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':TestFiles',
        zilla       => $self,
        style       => 'grep',
        code        => sub { local $_ = $_->name; m{\At/} },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':ExtraTestFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':ExtraTestFiles',
        zilla       => $self,
        style       => 'grep',
        code        => sub { local $_ = $_->name; m{\Axt/} },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':ExecFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':ExecFiles',
        zilla       => $self,
        style       => 'list',
        code        => sub {
          my $plugins = $_[0]->zilla->plugins_with(-ExecFiles);
          my @files = uniq map {; @{ $_->find_files } } @$plugins;
  
          return \@files;
        },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':PerlExecFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':PerlExecFiles',
        zilla       => $self,
        style       => 'list',
        code        => sub {
          my $parent_plugin = $self->plugin_named(':ExecFiles');
          my @files = grep {
            $_->name =~ m{\.pl$}
                or $_->content =~ m{^\s*\#\!.*perl\b};
          } @{ $parent_plugin->find_files };
          return \@files;
        },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':ShareFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':ShareFiles',
        zilla       => $self,
        style       => 'list',
        code        => sub {
          my $self = shift;
          my $map = $self->zilla->_share_dir_map;
          my @files;
          if ( $map->{dist} ) {
            push @files, grep {; $_->name =~ m{\A\Q$map->{dist}\E/} }
                         @{ $self->zilla->files };
          }
          if ( my $mod_map = $map->{module} ) {
            for my $mod ( keys %$mod_map ) {
              push @files, grep { $_->name =~ m{\A\Q$mod_map->{$mod}\E/} }
                           @{ $self->zilla->files };
            }
          }
          return \@files;
        },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':MainModule')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':MainModule',
        zilla       => $self,
        style       => 'grep',
        code        => sub {
          my ($file, $self) = @_;
          local $_ = $file->name;
          return 1 if $_ eq $self->zilla->main_module->name;
          return;
        },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':AllFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':AllFiles',
        zilla       => $self,
        style       => 'grep',
        code        => sub { return 1 },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  
    unless ($self->plugin_named(':NoFiles')) {
      require Dist::Zilla::Plugin::FinderCode;
      my $plugin = Dist::Zilla::Plugin::FinderCode->new({
        plugin_name => ':NoFiles',
        zilla       => $self,
        style       => 'list',
        code        => sub { return },
      });
  
      push @{ $self->plugins }, $plugin;
    }
  }
  
  has _share_dir_map => (
    is   => 'ro',
    isa  => HashRef,
    init_arg  => undef,
    lazy      => 1,
    builder   => '_build_share_dir_map',
  );
  
  sub _build_share_dir_map {
    my ($self) = @_;
  
    my $share_dir_map = {};
  
    for my $plugin (@{ $self->plugins_with(-ShareDir) }) {
      next unless my $sub_map = $plugin->share_dir_map;
  
      if ( $sub_map->{dist} ) {
        $self->log_fatal("can't install more than one distribution ShareDir")
          if $share_dir_map->{dist};
        $share_dir_map->{dist} = $sub_map->{dist};
      }
  
      if ( my $mod_map = $sub_map->{module} ) {
        for my $mod ( keys %$mod_map ) {
          $self->log_fatal("can't install more than one ShareDir for $mod")
            if $share_dir_map->{module}{$mod};
          $share_dir_map->{module}{$mod} = $mod_map->{$mod};
        }
      }
    }
  
    return $share_dir_map;
  }
  
  
  sub _load_config {
    my ($class, $arg) = @_;
    $arg ||= {};
  
    my $config_class =
      $arg->{config_class} ||= 'Dist::Zilla::MVP::Reader::Finder';
  
    Class::Load::load_class($config_class);
  
    $arg->{chrome}->logger->log_debug(
      { prefix => '[DZ] ' },
      "reading configuration using $config_class"
    );
  
    my $root = $arg->{root};
  
    require Dist::Zilla::MVP::Assembler::Zilla;
    require Dist::Zilla::MVP::Section;
    my $assembler = Dist::Zilla::MVP::Assembler::Zilla->new({
      chrome        => $arg->{chrome},
      zilla_class   => $class,
      section_class => 'Dist::Zilla::MVP::Section', # make this DZMA default
    });
  
    for ($assembler->sequence->section_named('_')) {
      $_->add_value(chrome => $arg->{chrome});
      $_->add_value(root   => $arg->{root});
      $_->add_value(_global_stashes => $arg->{_global_stashes})
        if $arg->{_global_stashes};
    }
  
    my $seq;
    try {
      $seq = $config_class->read_config(
        $root->child('dist'),
        {
          assembler => $assembler
        },
      );
    } catch {
      die $_ unless try {
        $_->isa('Config::MVP::Error')
        and $_->ident eq 'package not installed'
      };
  
      my $package = $_->package;
      my $bundle  = $_->section_name =~ m{^@(?!.*/)} ? ' bundle' : '';
  
      die <<"END_DIE";
  Required plugin$bundle $package isn't installed.
  
  Run 'dzil authordeps' to see a list of all required plugins.
  You can pipe the list to your CPAN client to install or update them:
  
      dzil authordeps --missing | cpanm
  
  END_DIE
  
    };
  
    return $seq;
  }
  
  #pod =method build_in
  #pod
  #pod   $zilla->build_in($root);
  #pod
  #pod This method builds the distribution in the given directory.  If no directory
  #pod name is given, it defaults to DistName-Version.  If the distribution has
  #pod already been built, an exception will be thrown.
  #pod
  #pod =method build
  #pod
  #pod This method just calls C<build_in> with no arguments.  It gets you the default
  #pod behavior without the weird-looking formulation of C<build_in> with no object
  #pod for the preposition!
  #pod
  #pod =cut
  
  sub build { $_[0]->build_in }
  
  sub build_in {
    my ($self, $root) = @_;
  
    $self->log_fatal("tried to build with a minter")
      if $self->isa('Dist::Zilla::Dist::Minter');
  
    $self->log_fatal("attempted to build " . $self->name . " a second time")
      if $self->built_in;
  
    $_->before_build for @{ $self->plugins_with(-BeforeBuild) };
  
    $self->log("beginning to build " . $self->name);
  
    $_->gather_files       for @{ $self->plugins_with(-FileGatherer) };
    $_->set_file_encodings for @{ $self->plugins_with(-EncodingProvider) };
    $_->prune_files        for @{ $self->plugins_with(-FilePruner) };
  
    $self->version; # instantiate this lazy attribute now that files are gathered
  
    $_->munge_files        for @{ $self->plugins_with(-FileMunger) };
  
    $_->register_prereqs   for @{ $self->plugins_with(-PrereqSource) };
  
    $self->prereqs->finalize;
  
    # Barf if someone has already set up a prereqs entry? -- rjbs, 2010-04-13
    $self->distmeta->{prereqs} = $self->prereqs->as_string_hash;
  
    $_->setup_installer for @{ $self->plugins_with(-InstallTool) };
  
    $self->_check_dupe_files;
  
    my $build_root = $self->_prep_build_root($root);
  
    $self->log("writing " . $self->name . " in $build_root");
  
    for my $file (@{ $self->files }) {
      $self->_write_out_file($file, $build_root);
    }
  
    $_->after_build({ build_root => $build_root })
      for @{ $self->plugins_with(-AfterBuild) };
  
    $self->built_in($build_root);
  }
  
  #pod =attr built_in
  #pod
  #pod This is the L<Path::Tiny>, if any, in which the dist has been built.
  #pod
  #pod =cut
  
  has built_in => (
    is   => 'rw',
    isa  => Path,
    init_arg  => undef,
    coerce => 1,
  );
  
  #pod =method ensure_built_in
  #pod
  #pod   $zilla->ensure_built_in($root);
  #pod
  #pod This method behaves like C<L</build_in>>, but if the dist is already built in
  #pod C<$root> (or the default root, if no root is given), no exception is raised.
  #pod
  #pod =method ensure_built
  #pod
  #pod This method just calls C<ensure_built_in> with no arguments.  It gets you the
  #pod default behavior without the weird-looking formulation of C<ensure_built_in>
  #pod with no object for the preposition!
  #pod
  #pod =cut
  
  sub ensure_built {
    $_[0]->ensure_built_in;
  }
  
  sub ensure_built_in {
    my ($self, $root) = @_;
  
    # $root ||= $self->name . q{-} . $self->version;
    return $self->built_in if $self->built_in and
      (!$root or ($self->built_in eq $root));
  
    Carp::croak("dist is already built, but not in $root") if $self->built_in;
    $self->build_in($root);
  }
  
  #pod =method dist_basename
  #pod
  #pod   my $basename = $zilla->dist_basename;
  #pod
  #pod This method will return the dist's basename (e.g. C<Dist-Name-1.01>.
  #pod The basename is used as the top-level directory in the tarball.  It
  #pod does not include C<-TRIAL>, even if building a trial dist.
  #pod
  #pod =cut
  
  sub dist_basename {
    my ($self) = @_;
    return join(q{},
      $self->name,
      '-',
      $self->version,
    );
  }
  
  #pod =method archive_filename
  #pod
  #pod   my $tarball = $zilla->archive_filename;
  #pod
  #pod This method will return the filename (e.g. C<Dist-Name-1.01.tar.gz>)
  #pod of the tarball of this distribution.  It will include C<-TRIAL> if building a
  #pod trial distribution, unless the version contains an underscore.  The tarball
  #pod might not exist.
  #pod
  #pod =cut
  
  sub archive_filename {
    my ($self) = @_;
    return join(q{},
      $self->dist_basename,
      ( $self->is_trial && $self->version !~ /_/ ? '-TRIAL' : '' ),
      '.tar.gz'
    );
  }
  
  #pod =method build_archive
  #pod
  #pod   $zilla->build_archive;
  #pod
  #pod This method will ensure that the dist has been built, and will then build a
  #pod tarball of the build directory in the current directory.
  #pod
  #pod =cut
  
  sub build_archive {
    my ($self) = @_;
  
    my $built_in = $self->ensure_built;
  
    my $basename = $self->dist_basename;
    my $basedir = path($basename);
  
    $_->before_archive for @{ $self->plugins_with(-BeforeArchive) };
  
    my $method = Class::Load::load_optional_class('Archive::Tar::Wrapper',
                                                  { -version => 0.15 })
               ? '_build_archive_with_wrapper'
               : '_build_archive';
  
    my $archive = $self->$method($built_in, $basename, $basedir);
  
    my $file = path($self->archive_filename);
  
    $self->log("writing archive to $file");
    $archive->write("$file", 9);
  
    return $file;
  }
  
  sub _build_archive {
    my ($self, $built_in, $basename, $basedir) = @_;
  
    $self->log("building archive with Archive::Tar; install Archive::Tar::Wrapper 0.15 or newer for improved speed");
  
    require Archive::Tar;
    my $archive = Archive::Tar->new;
    my %seen_dir;
    for my $distfile (
      sort { length($a->name) <=> length($b->name) } @{ $self->files }
    ) {
      my $in = path($distfile->name)->parent;
  
      unless ($seen_dir{ $in }++) {
        $archive->add_data(
          $basedir->child($in),
          '',
          { type => Archive::Tar::Constant::DIR(), mode => 0755 },
        )
      }
  
      my $filename = $built_in->child( $distfile->name );
      $archive->add_data(
        $basedir->child( $distfile->name ),
        path($filename)->slurp_raw,
        { mode => (stat $filename)[2] & ~022 },
      );
    }
  
    return $archive;
  }
  
  sub _build_archive_with_wrapper {
    my ($self, $built_in, $basename, $basedir) = @_;
  
    $self->log("building archive with Archive::Tar::Wrapper");
  
    my $archive = Archive::Tar::Wrapper->new;
  
    for my $distfile (
      sort { length($a->name) <=> length($b->name) } @{ $self->files }
    ) {
      my $in = path($distfile->name)->parent;
  
      my $filename = $built_in->child( $distfile->name );
      $archive->add(
        $basedir->child( $distfile->name )->stringify,
        $filename->stringify,
        { perm => (stat $filename)[2] & ~022 },
      );
    }
  
    return $archive;
  }
  
  sub _prep_build_root {
    my ($self, $build_root) = @_;
  
    $build_root = path($build_root || $self->dist_basename);
  
    $build_root->mkpath unless -d $build_root;
  
    my $dist_root = $self->root;
  
    return $build_root if !-d $build_root;
  
    my $ok = eval { $build_root->remove_tree({ safe => 0 }); 1 };
    die "unable to delete '$build_root' in preparation of build: $@" unless $ok;
  
    # the following is done only on windows, and only if the deletion failed,
    # yet rmtree reported success, because currently rmdir is non-blocking as per:
    # https://rt.perl.org/Ticket/Display.html?id=123958
    if ( $^O eq 'MSWin32' and -d $build_root ) {
      $self->log("spinning for at least one second to allow other processes to release locks on $build_root");
      my $timeout = time + 2;
      while(time != $timeout and -d $build_root) { }
      die "unable to delete '$build_root' in preparation of build because some process has a lock on it"
        if -d $build_root;
    }
  
    return $build_root;
  }
  
  #pod =method release
  #pod
  #pod   $zilla->release;
  #pod
  #pod This method releases the distribution, probably by uploading it to the CPAN.
  #pod The actual effects of this method (as with most of the methods) is determined
  #pod by the loaded plugins.
  #pod
  #pod =cut
  
  sub release {
    my $self = shift;
  
    Carp::croak("you can't release without any Releaser plugins")
      unless my @releasers = @{ $self->plugins_with(-Releaser) };
  
    $ENV{DZIL_RELEASING} = 1;
  
    my $tgz = $self->build_archive;
  
    # call all plugins implementing BeforeRelease role
    $_->before_release($tgz) for @{ $self->plugins_with(-BeforeRelease) };
  
    # do the actual release
    $_->release($tgz) for @releasers;
  
    # call all plugins implementing AfterRelease role
    $_->after_release($tgz) for @{ $self->plugins_with(-AfterRelease) };
  }
  
  #pod =method clean
  #pod
  #pod This method removes temporary files and directories suspected to have been
  #pod produced by the Dist::Zilla build process.  Specifically, it deletes the
  #pod F<.build> directory and any entity that starts with the dist name and a hyphen,
  #pod like matching the glob C<Your-Dist-*>.
  #pod
  #pod =cut
  
  sub clean {
    my ($self, $dry_run) = @_;
  
    require File::Path;
    for my $x (grep { -e } '.build', glob($self->name . '-*')) {
      if ($dry_run) {
        $self->log("clean: would remove $x");
      } else {
        $self->log("clean: removing $x");
        File::Path::rmtree($x);
      }
    };
  }
  
  #pod =method ensure_built_in_tmpdir
  #pod
  #pod   $zilla->ensure_built_in_tmpdir;
  #pod
  #pod This method will consistently build the distribution in a temporary
  #pod subdirectory. It will return the path for the temporary build location.
  #pod
  #pod =cut
  
  sub ensure_built_in_tmpdir {
    my $self = shift;
  
    require File::Temp;
  
    my $build_root = path('.build');
    $build_root->mkpath unless -d $build_root;
  
    my $target = path( File::Temp::tempdir(DIR => $build_root) );
    $self->log("building distribution under $target for installation");
  
    my $os_has_symlinks = eval { symlink("",""); 1 };
    my $previous;
    my $latest;
  
    if( $os_has_symlinks ) {
      $previous = path( $build_root, 'previous' );
      $latest   = path( $build_root, 'latest'   );
      if( -l $previous ) {
        $previous->remove
          or $self->log("cannot remove old .build/previous link");
      }
      if( -l $latest ) {
        rename $latest, $previous
          or $self->log("cannot move .build/latest link to .build/previous");
      }
      symlink $target->basename, $latest
        or $self->log('cannot create link .build/latest');
    }
  
    $self->ensure_built_in($target);
  
    return ($target, $latest, $previous);
  }
  
  #pod =method install
  #pod
  #pod   $zilla->install( \%arg );
  #pod
  #pod This method installs the distribution locally.  The distribution will be built
  #pod in a temporary subdirectory, then the process will change directory to that
  #pod subdir and an installer will be run.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   keep_build_dir  - if true, don't rmtree the build dir, even if everything
  #pod                     seemed to work
  #pod   install_command - the command to run in the subdir to install the dist
  #pod                     default (roughly): $^X -MCPAN -einstall .
  #pod
  #pod                     this argument should be an arrayref
  #pod
  #pod =cut
  
  sub install {
    my ($self, $arg) = @_;
    $arg ||= {};
  
    my ($target, $latest) = $self->ensure_built_in_tmpdir;
  
    my $ok = eval {
      ## no critic Punctuation
      my $wd = File::pushd::pushd($target);
      my @cmd = $arg->{install_command}
              ? @{ $arg->{install_command} }
              : (cpanm => ".");
  
      $self->log_debug([ 'installing via %s', \@cmd ]);
      system(@cmd) && $self->log_fatal([ "error running %s", \@cmd ]);
      1;
    };
  
    unless ($ok) {
      my $error = $@ || '(exception clobered)';
      $self->log("install failed, left failed dist in place at $target");
      die $error;
    }
  
    if ($arg->{keep_build_dir}) {
      $self->log("all's well; left dist in place at $target");
    } else {
      $self->log("all's well; removing $target");
      $target->remove_tree({ safe => 0 });
      $latest->remove if $latest;
    }
  
    return;
  }
  
  #pod =method test
  #pod
  #pod   $zilla->test(\%arg);
  #pod
  #pod This method builds a new copy of the distribution and tests it using
  #pod C<L</run_tests_in>>.
  #pod
  #pod C<\%arg> may be omitted.  Otherwise, valid arguments are:
  #pod
  #pod   keep_build_dir  - if true, don't rmtree the build dir, even if everything
  #pod                     seemed to work
  #pod
  #pod =cut
  
  sub test {
    my ($self, $arg) = @_;
  
    Carp::croak("you can't test without any TestRunner plugins")
      unless my @testers = @{ $self->plugins_with(-TestRunner) };
  
    my ($target, $latest) = $self->ensure_built_in_tmpdir;
    my $error  = $self->run_tests_in($target, $arg);
  
    if ($arg and $arg->{keep_build_dir}) {
      $self->log("all's well; left dist in place at $target");
      return;
    }
  
    $self->log("all's well; removing $target");
    $target->remove_tree({ safe => 0 });
    $latest->remove if $latest;
  }
  
  #pod =method run_tests_in
  #pod
  #pod   my $error = $zilla->run_tests_in($directory, $arg);
  #pod
  #pod This method runs the tests in $directory (a Path::Tiny), which must contain an
  #pod already-built copy of the distribution.  It will throw an exception if there
  #pod are test failures.
  #pod
  #pod It does I<not> set any of the C<*_TESTING> environment variables, nor
  #pod does it clean up C<$directory> afterwards.
  #pod
  #pod =cut
  
  sub run_tests_in {
    my ($self, $target, $arg) = @_;
  
    Carp::croak("you can't test without any TestRunner plugins")
      unless my @testers = @{ $self->plugins_with(-TestRunner) };
  
    for my $tester (@testers) {
      my $wd = File::pushd::pushd($target);
      $tester->test( $target, $arg );
    }
  }
  
  #pod =method run_in_build
  #pod
  #pod   $zilla->run_in_build( \@cmd );
  #pod
  #pod This method makes a temporary directory, builds the distribution there,
  #pod executes all the dist's L<BuildRunner|Dist::Zilla::Role::BuildRunner>s
  #pod (unless directed not to, via C<< $arg->{build} = 0 >>), and
  #pod then runs the given command in the build directory.  If the command exits
  #pod non-zero, the directory will be left in place.
  #pod
  #pod =cut
  
  sub run_in_build {
    my ($self, $cmd, $arg) = @_;
  
    $self->log_fatal("you can't build without any BuildRunner plugins")
      unless ($arg and exists $arg->{build} and ! $arg->{build})
          or @{ $self->plugins_with(-BuildRunner) };
  
    require "Config.pm"; # skip autoprereq
  
    my ($target, $latest) = $self->ensure_built_in_tmpdir;
    my $abstarget = $target->absolute;
  
    # building the dist for real
    my $ok = eval {
      my $wd = File::pushd::pushd($target);
  
      if ($arg and exists $arg->{build} and ! $arg->{build}) {
        system(@$cmd) and die "error while running: @$cmd";
        return 1;
      }
  
      $self->_ensure_blib;
  
      local $ENV{PERL5LIB} = join $Config::Config{path_sep},
        (map { $abstarget->child('blib', $_) } qw(arch lib)),
        (defined $ENV{PERL5LIB} ? $ENV{PERL5LIB} : ());
  
      local $ENV{PATH} = join $Config::Config{path_sep},
        (map { $abstarget->child('blib', $_) } qw(bin script)),
        (defined $ENV{PATH} ? $ENV{PATH} : ());
  
      system(@$cmd) and die "error while running: @$cmd";
      1;
    };
  
    if ($ok) {
      $self->log("all's well; removing $target");
      $target->remove_tree({ safe => 0 });
      $latest->remove if $latest;
    } else {
      my $error = $@ || '(unknown error)';
      $self->log($error);
      $self->log_fatal("left failed dist in place at $target");
    }
  }
  
  # Ensures that a F<blib> directory exists in the build, by invoking all
  # C<-BuildRunner> plugins to generate it.  Useful for commands that operate on
  # F<blib>, such as C<test> or C<run>.
  
  sub _ensure_blib {
    my ($self) = @_;
  
    unless ( -d 'blib' ) {
      my @builders = @{ $self->plugins_with( -BuildRunner ) };
      $self->log_fatal("no BuildRunner plugins specified") unless @builders;
      $_->build for @builders;
      $self->log_fatal("no blib; failed to build properly?") unless -d 'blib';
    }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Dist::Builder - dist zilla subclass for building dists
  
  =head1 VERSION
  
  version 6.007
  
  =head1 ATTRIBUTES
  
  =head2 built_in
  
  This is the L<Path::Tiny>, if any, in which the dist has been built.
  
  =head1 METHODS
  
  =head2 from_config
  
    my $zilla = Dist::Zilla->from_config(\%arg);
  
  This routine returns a new Zilla from the configuration in the current working
  directory.
  
  This method should not be relied upon, yet.  Its semantics are B<certain> to
  change.
  
  Valid arguments are:
  
    config_class - the class to use to read the config
                   default: Dist::Zilla::MVP::Reader::Finder
  
  =head2 build_in
  
    $zilla->build_in($root);
  
  This method builds the distribution in the given directory.  If no directory
  name is given, it defaults to DistName-Version.  If the distribution has
  already been built, an exception will be thrown.
  
  =head2 build
  
  This method just calls C<build_in> with no arguments.  It gets you the default
  behavior without the weird-looking formulation of C<build_in> with no object
  for the preposition!
  
  =head2 ensure_built_in
  
    $zilla->ensure_built_in($root);
  
  This method behaves like C<L</build_in>>, but if the dist is already built in
  C<$root> (or the default root, if no root is given), no exception is raised.
  
  =head2 ensure_built
  
  This method just calls C<ensure_built_in> with no arguments.  It gets you the
  default behavior without the weird-looking formulation of C<ensure_built_in>
  with no object for the preposition!
  
  =head2 dist_basename
  
    my $basename = $zilla->dist_basename;
  
  This method will return the dist's basename (e.g. C<Dist-Name-1.01>.
  The basename is used as the top-level directory in the tarball.  It
  does not include C<-TRIAL>, even if building a trial dist.
  
  =head2 archive_filename
  
    my $tarball = $zilla->archive_filename;
  
  This method will return the filename (e.g. C<Dist-Name-1.01.tar.gz>)
  of the tarball of this distribution.  It will include C<-TRIAL> if building a
  trial distribution, unless the version contains an underscore.  The tarball
  might not exist.
  
  =head2 build_archive
  
    $zilla->build_archive;
  
  This method will ensure that the dist has been built, and will then build a
  tarball of the build directory in the current directory.
  
  =head2 release
  
    $zilla->release;
  
  This method releases the distribution, probably by uploading it to the CPAN.
  The actual effects of this method (as with most of the methods) is determined
  by the loaded plugins.
  
  =head2 clean
  
  This method removes temporary files and directories suspected to have been
  produced by the Dist::Zilla build process.  Specifically, it deletes the
  F<.build> directory and any entity that starts with the dist name and a hyphen,
  like matching the glob C<Your-Dist-*>.
  
  =head2 ensure_built_in_tmpdir
  
    $zilla->ensure_built_in_tmpdir;
  
  This method will consistently build the distribution in a temporary
  subdirectory. It will return the path for the temporary build location.
  
  =head2 install
  
    $zilla->install( \%arg );
  
  This method installs the distribution locally.  The distribution will be built
  in a temporary subdirectory, then the process will change directory to that
  subdir and an installer will be run.
  
  Valid arguments are:
  
    keep_build_dir  - if true, don't rmtree the build dir, even if everything
                      seemed to work
    install_command - the command to run in the subdir to install the dist
                      default (roughly): $^X -MCPAN -einstall .
  
                      this argument should be an arrayref
  
  =head2 test
  
    $zilla->test(\%arg);
  
  This method builds a new copy of the distribution and tests it using
  C<L</run_tests_in>>.
  
  C<\%arg> may be omitted.  Otherwise, valid arguments are:
  
    keep_build_dir  - if true, don't rmtree the build dir, even if everything
                      seemed to work
  
  =head2 run_tests_in
  
    my $error = $zilla->run_tests_in($directory, $arg);
  
  This method runs the tests in $directory (a Path::Tiny), which must contain an
  already-built copy of the distribution.  It will throw an exception if there
  are test failures.
  
  It does I<not> set any of the C<*_TESTING> environment variables, nor
  does it clean up C<$directory> afterwards.
  
  =head2 run_in_build
  
    $zilla->run_in_build( \@cmd );
  
  This method makes a temporary directory, builds the distribution there,
  executes all the dist's L<BuildRunner|Dist::Zilla::Role::BuildRunner>s
  (unless directed not to, via C<< $arg->{build} = 0 >>), and
  then runs the given command in the build directory.  If the command exits
  non-zero, the directory will be left in place.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_DIST_BUILDER

$fatpacked{"Dist/Zilla/Dist/Minter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_DIST_MINTER';
  package Dist::Zilla::Dist::Minter 6.007;
  # ABSTRACT: distribution builder; installer not included!
  
  use Moose 0.92; # role composition fixes
  extends 'Dist::Zilla';
  
  use File::pushd ();
  use Dist::Zilla::Path;
  
  use namespace::autoclean;
  
  sub _setup_default_plugins {
    my ($self) = @_;
  
    unless ($self->plugin_named(':DefaultModuleMaker')) {
      require Dist::Zilla::Plugin::TemplateModule;
      my $plugin = Dist::Zilla::Plugin::TemplateModule->new({
        plugin_name => ':DefaultModuleMaker',
        zilla       => $self,
      });
  
      push @{ $self->plugins }, $plugin;
    }
  }
  
  sub _new_from_profile {
    my ($class, $profile_data, $arg) = @_;
    $arg ||= {};
  
    my $config_class =
      $arg->{config_class} ||= 'Dist::Zilla::MVP::Reader::Finder';
    Class::Load::load_class($config_class);
  
    $arg->{chrome}->logger->log_debug(
      { prefix => '[DZ] ' },
      "reading configuration using $config_class"
    );
  
    require Dist::Zilla::MVP::Assembler::Zilla;
    require Dist::Zilla::MVP::Section;
    my $assembler = Dist::Zilla::MVP::Assembler::Zilla->new({
      chrome        => $arg->{chrome},
      zilla_class   => $class,
      section_class => 'Dist::Zilla::MVP::Section', # make this DZMA default
    });
  
    for ($assembler->sequence->section_named('_')) {
      $_->add_value(name   => $arg->{name});
      $_->add_value(chrome => $arg->{chrome});
      $_->add_value(_global_stashes => $arg->{_global_stashes})
        if $arg->{_global_stashes};
    }
  
    my $module = String::RewritePrefix->rewrite(
      { '' => 'Dist::Zilla::MintingProfile::', '=', => '' },
      $profile_data->[0],
    );
    Class::Load::load_class($module);
  
    my $profile_dir = $module->profile_dir($profile_data->[1]);
  
    warn "expected a string or Path::Tiny but got a Path::Class from $module\n"
      if ref $profile_dir && $profile_dir->isa('Path::Class');
  
    $profile_dir = path($profile_dir);
  
    $assembler->sequence->section_named('_')->add_value(root => $profile_dir);
  
    my $seq = $config_class->read_config(
      $profile_dir->child('profile'),
      {
        assembler => $assembler
      },
    );
  
    my $self = $seq->section_named('_')->zilla;
  
    $self->_setup_default_plugins;
  
    return $self;
  }
  
  sub _mint_target_dir {
    my ($self) = @_;
  
    my $name = $self->name;
    my $dir  = path($name);
    $self->log_fatal("./$name already exists") if -e $dir;
  
    return $dir = $dir->absolute;
  }
  
  sub mint_dist {
    my ($self, $arg) = @_;
  
    my $name = $self->name;
    my $dir  = $self->_mint_target_dir;
  
    # XXX: We should have a way to get more than one module name in, and to
    # supply plugin names for the minter to use. -- rjbs, 2010-05-03
    my @modules = (
      { name => $name =~ s/-/::/gr }
    );
  
    $self->log("making target dir $dir");
    $dir->mkpath;
  
    my $wd = File::pushd::pushd($self->root);
  
    $_->before_mint  for @{ $self->plugins_with(-BeforeMint) };
  
    for my $module (@modules) {
      my $minter = $self->plugin_named(
        $module->{minter_name} || ':DefaultModuleMaker'
      );
  
      $minter->make_module({ name => $module->{name} })
    }
  
    $_->gather_files       for @{ $self->plugins_with(-FileGatherer) };
    $_->set_file_encodings for @{ $self->plugins_with(-EncodingProvider) };
    $_->prune_files        for @{ $self->plugins_with(-FilePruner) };
    $_->munge_files        for @{ $self->plugins_with(-FileMunger) };
  
    $self->_check_dupe_files;
  
    $self->log("writing files to $dir");
  
    for my $file (@{ $self->files }) {
      $self->_write_out_file($file, $dir);
    }
  
    $_->after_mint({ mint_root => $dir })
      for @{ $self->plugins_with(-AfterMint) };
  
    $self->log("dist minted in ./$name");
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Dist::Minter - distribution builder; installer not included!
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_DIST_MINTER

$fatpacked{"Dist/Zilla/File/FromCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_FILE_FROMCODE';
  package Dist::Zilla::File::FromCode 6.007;
  # ABSTRACT: a file whose content is (re-)built on demand
  
  use Moose;
  use Moose::Util::TypeConstraints;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This represents a file whose contents will be generated on demand from a
  #pod callback or method name.
  #pod
  #pod It has one attribute, C<code>, which may be a method name (string) or a
  #pod coderef.  When the file's C<content> method is called, the code is used to
  #pod generate the content.  This content is I<not> cached.  It is recomputed every
  #pod time the content is requested.
  #pod
  #pod =cut
  
  with 'Dist::Zilla::Role::File';
  
  has code => (
    is  => 'rw',
    isa => 'CodeRef|Str',
    required => 1,
  );
  
  #pod =attr code_return_type
  #pod
  #pod 'text' or 'bytes'
  #pod
  #pod =cut
  
  has code_return_type => (
    is => 'ro',
    isa => enum([ qw(text bytes) ]),
    default => 'text',
  );
  
  #pod =attr encoding
  #pod
  #pod =cut
  
  sub encoding;
  
  has encoding => (
    is => 'ro',
    isa => 'Str',
    lazy => 1,
    builder => "_build_encoding",
  );
  
  sub _build_encoding {
    my ($self) = @_;
    return $self->code_return_type eq 'text' ? 'UTF-8' : 'bytes';
  }
  
  #pod =attr content
  #pod
  #pod =cut
  
  sub content {
    my ($self) = @_;
  
    confess("cannot set content of a FromCode file") if @_ > 1;
  
    my $code = $self->code;
    my $result = $self->$code;
  
    if ( $self->code_return_type eq 'text' ) {
      return $result;
    }
    else {
      $self->_decode($result);
    }
  }
  
  #pod =attr encoded_content
  #pod
  #pod =cut
  
  sub encoded_content {
    my ($self) = @_;
  
    confess( "cannot set encoded_content of a FromCode file" ) if @_ > 1;
  
    my $code = $self->code;
    my $result = $self->$code;
  
    if ( $self->code_return_type eq 'bytes' ) {
      return $result;
    }
    else {
      $self->_encode($result);
    }
  }
  
  sub _set_added_by {
    my ($self, $value) = @_;
    return $self->_push_added_by(sprintf("%s from coderef added by %s", $self->code_return_type, $value));
  };
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::File::FromCode - a file whose content is (re-)built on demand
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This represents a file whose contents will be generated on demand from a
  callback or method name.
  
  It has one attribute, C<code>, which may be a method name (string) or a
  coderef.  When the file's C<content> method is called, the code is used to
  generate the content.  This content is I<not> cached.  It is recomputed every
  time the content is requested.
  
  =head1 ATTRIBUTES
  
  =head2 code_return_type
  
  'text' or 'bytes'
  
  =head2 encoding
  
  =head2 content
  
  =head2 encoded_content
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_FILE_FROMCODE

$fatpacked{"Dist/Zilla/File/InMemory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_FILE_INMEMORY';
  package Dist::Zilla::File::InMemory 6.007;
  # ABSTRACT: a file that you build entirely in memory
  
  use Moose;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This represents a file created in memory -- it's not much more than a glorified
  #pod string.
  #pod
  #pod See L<Dist::Zilla::Role::MutableFile> for details.
  #pod
  #pod =cut
  
  with 'Dist::Zilla::Role::MutableFile', 'Dist::Zilla::Role::StubBuild';
  
  after 'BUILD' => sub {
    my ($self,$opts) = @_;
    my @sources = qw/encoded_content content/;
    my @given = grep { exists $opts->{$_} } @sources;
    unless ( @given == 1 ) {
      $self->log_fatal(__PACKAGE__ . " requires have one and only one of: @sources");
    }
    my $source = $given[0];
    my $setter = "_$source";
    $self->_content_source($source);
    $self->$setter( $opts->{$source} );
  };
  
  # these should never be called since we ensure one of _content or
  # _encoded_content content is set in BUILD and set the source accordingly
  
  sub _build_content { die "shouldn't reach here" }
  sub _build_encoded_content { die "shouldn't reach here" }
  sub _build_content_source { die "shouldn't reach here" }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::File::InMemory - a file that you build entirely in memory
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This represents a file created in memory -- it's not much more than a glorified
  string.
  
  See L<Dist::Zilla::Role::MutableFile> for details.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_FILE_INMEMORY

$fatpacked{"Dist/Zilla/File/OnDisk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_FILE_ONDISK';
  package Dist::Zilla::File::OnDisk 6.007;
  # ABSTRACT: a file that comes from your filesystem
  
  use Moose;
  
  use Dist::Zilla::Path;
  
  use namespace::autoclean;
  
  with 'Dist::Zilla::Role::MutableFile', 'Dist::Zilla::Role::StubBuild';
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This represents a file stored on disk.  Its C<content> attribute is read from
  #pod the originally given file name when first read, but is then kept in memory and
  #pod may be altered by plugins.
  #pod
  #pod =cut
  
  has _original_name => (
    is  => 'ro',
    writer => '_set_original_name',
    isa => 'Str',
    init_arg => undef,
  );
  
  after 'BUILD' => sub {
    my ($self) = @_;
    $self->_set_original_name( $self->name );
  };
  
  sub _build_encoded_content {
    my ($self) = @_;
    return path($self->_original_name)->slurp_raw;
  }
  
  sub _build_content_source { return "encoded_content" }
  
  # should never be called, as content will always be generated from
  # encoded content
  sub _build_content { die "shouldn't reach here" }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::File::OnDisk - a file that comes from your filesystem
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This represents a file stored on disk.  Its C<content> attribute is read from
  the originally given file name when first read, but is then kept in memory and
  may be altered by plugins.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_FILE_ONDISK

$fatpacked{"Dist/Zilla/MVP/Assembler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_ASSEMBLER';
  package Dist::Zilla::MVP::Assembler 6.007;
  # ABSTRACT: Dist::Zilla-specific subclass of Config::MVP::Assembler
  
  use Moose;
  extends 'Config::MVP::Assembler';
  with 'Config::MVP::Assembler::WithBundles' => { -version => '2.200010' };
  
  use namespace::autoclean;
  
  use Dist::Zilla::Util;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod B<Take this next bit seriously!>  If you don't understand how L<Config::MVP>
  #pod works, reading about how the Dist::Zilla-specific Assembler works is not going
  #pod to be useful.
  #pod
  #pod Dist::Zilla::MVP::Assembler extends L<Config::MVP::Assembler> and composes
  #pod L<Config::MVP::Assembler::WithBundles>.  For potential plugin bundles (things
  #pod composing L<Dist::Zilla::Role::PluginBundle>)
  #pod
  #pod The Assembler has chrome, so it can log and will (eventually) be able to get
  #pod input from the user.
  #pod
  #pod The Assembler's C<expand_package> method delegates to Dist::Zilla::Util's
  #pod L<expand_config_package_name|Dist::Zilla::Util/expand_config_package_name>
  #pod method.
  #pod
  #pod The Assembler will throw an exception if it is instructed to add a value for
  #pod C<plugin_name> or C<zilla>.
  #pod
  #pod =cut
  
  has chrome => (
    is   => 'rw',
    does => 'Dist::Zilla::Role::Chrome',
    required => 1,
  );
  
  has logger => (
    is   => 'ro',
    isa  => 'Log::Dispatchouli::Proxy', # could be duck typed, I guess
    lazy => 1,
    handles => [ qw(log log_debug log_fatal) ],
    default => sub {
      $_[0]->chrome->logger->proxy({ proxy_prefix => '[DZ] ' })
    },
  );
  
  sub expand_package {
    return scalar Dist::Zilla::Util->expand_config_package_name($_[1]);
  }
  
  sub package_bundle_method {
    my ($self, $pkg) = @_;
    return unless $pkg->isa('Moose::Object')
           and    $pkg->does('Dist::Zilla::Role::PluginBundle');
    return 'bundle_config';
  }
  
  before add_value => sub {
    my ($self, $name) = @_;
  
    return unless $name =~ /\A(?:plugin_name|zilla)\z/;
  
    my $section_name = $self->current_section->name;
    $self->log_fatal(
      "$section_name arguments attempted to provide reserved argument $name"
    );
  };
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::Assembler - Dist::Zilla-specific subclass of Config::MVP::Assembler
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  B<Take this next bit seriously!>  If you don't understand how L<Config::MVP>
  works, reading about how the Dist::Zilla-specific Assembler works is not going
  to be useful.
  
  Dist::Zilla::MVP::Assembler extends L<Config::MVP::Assembler> and composes
  L<Config::MVP::Assembler::WithBundles>.  For potential plugin bundles (things
  composing L<Dist::Zilla::Role::PluginBundle>)
  
  The Assembler has chrome, so it can log and will (eventually) be able to get
  input from the user.
  
  The Assembler's C<expand_package> method delegates to Dist::Zilla::Util's
  L<expand_config_package_name|Dist::Zilla::Util/expand_config_package_name>
  method.
  
  The Assembler will throw an exception if it is instructed to add a value for
  C<plugin_name> or C<zilla>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_ASSEMBLER

$fatpacked{"Dist/Zilla/MVP/Assembler/GlobalConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_ASSEMBLER_GLOBALCONFIG';
  package Dist::Zilla::MVP::Assembler::GlobalConfig 6.007;
  # ABSTRACT: Dist::Zilla::MVP::Assembler for global configuration
  
  use Moose;
  extends 'Dist::Zilla::MVP::Assembler';
  
  use namespace::autoclean;
  
  #pod =head1 OVERVIEW
  #pod
  #pod This is a subclass of L<Dist::Zilla::MVP::Assembler> used when assembling the
  #pod global configuration.  It has a C<stash_registry> attribute, a hashref, into
  #pod which stashes will be registered.
  #pod
  #pod They get registered via the C<register_stash> method, below, generally called
  #pod by the C<register_component> method on L<Dist::Zilla::Role::Stash>-performing
  #pod class.
  #pod
  #pod =cut
  
  has stash_registry => (
    is  => 'ro',
    isa => 'HashRef[Object]',
    default => sub { {} },
  );
  
  #pod =method register_stash
  #pod
  #pod   $assembler->register_stash($name => $stash_object);
  #pod
  #pod This adds a stash to the assembler's stash registry -- unless the name is
  #pod already taken, in which case an exception is raised.
  #pod
  #pod =cut
  
  sub register_stash {
    my ($self, $name, $object) = @_;
  
    # $self->log_fatal("tried to register $name stash entry twice")
    confess("tried to register $name stash entry twice")
      if $self->stash_registry->{ $name };
  
    $self->stash_registry->{ $name } = $object;
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::Assembler::GlobalConfig - Dist::Zilla::MVP::Assembler for global configuration
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  This is a subclass of L<Dist::Zilla::MVP::Assembler> used when assembling the
  global configuration.  It has a C<stash_registry> attribute, a hashref, into
  which stashes will be registered.
  
  They get registered via the C<register_stash> method, below, generally called
  by the C<register_component> method on L<Dist::Zilla::Role::Stash>-performing
  class.
  
  =head1 METHODS
  
  =head2 register_stash
  
    $assembler->register_stash($name => $stash_object);
  
  This adds a stash to the assembler's stash registry -- unless the name is
  already taken, in which case an exception is raised.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_ASSEMBLER_GLOBALCONFIG

$fatpacked{"Dist/Zilla/MVP/Assembler/Zilla.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_ASSEMBLER_ZILLA';
  package Dist::Zilla::MVP::Assembler::Zilla 6.007;
  # ABSTRACT: Dist::Zilla::MVP::Assembler for the Dist::Zilla object
  
  use Moose;
  extends 'Dist::Zilla::MVP::Assembler';
  
  use namespace::autoclean;
  
  #pod =head1 OVERVIEW
  #pod
  #pod This is a subclass of L<Dist::Zilla::MVP::Assembler> used when assembling the
  #pod Dist::Zilla object.
  #pod
  #pod It has a C<zilla_class> attribute, which is used to determine what class of
  #pod Dist::Zilla object to create.  (This isn't very useful now, but will be in the
  #pod future when minting and building use different subclasses of Dist::Zilla.)
  #pod
  #pod Upon construction, the assembler will create a L<Dist::Zilla::MVP::RootSection>
  #pod as the initial section.
  #pod
  #pod =cut
  
  use MooseX::Types::Perl qw(PackageName);
  use Dist::Zilla::MVP::RootSection;
  
  sub BUILD {
    my ($self) = @_;
  
    my $root = Dist::Zilla::MVP::RootSection->new;
    $self->sequence->add_section($root);
  }
  
  has zilla_class => (
    is       => 'ro',
    isa      => PackageName,
    required => 1
  );
  
  #pod =method zilla
  #pod
  #pod This method is a shortcut for retrieving the C<zilla> from the root section.
  #pod If called before that section has been finalized, it will result in an
  #pod exception.
  #pod
  #pod =cut
  
  sub zilla {
    my ($self) = @_;
    $self->sequence->section_named('_')->zilla;
  }
  
  #pod =method register_stash
  #pod
  #pod   $assembler->register_stash($name => $stash_object);
  #pod
  #pod This adds a stash to the assembler's zilla's stash registry -- unless the name
  #pod is already taken, in which case an exception is raised.
  #pod
  #pod =cut
  
  sub register_stash {
    my ($self, $name, $object) = @_;
    $self->log_fatal("tried to register $name stash entry twice")
      if $self->zilla->_local_stashes->{ $name };
  
    $self->zilla->_local_stashes->{ $name } = $object;
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::Assembler::Zilla - Dist::Zilla::MVP::Assembler for the Dist::Zilla object
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  This is a subclass of L<Dist::Zilla::MVP::Assembler> used when assembling the
  Dist::Zilla object.
  
  It has a C<zilla_class> attribute, which is used to determine what class of
  Dist::Zilla object to create.  (This isn't very useful now, but will be in the
  future when minting and building use different subclasses of Dist::Zilla.)
  
  Upon construction, the assembler will create a L<Dist::Zilla::MVP::RootSection>
  as the initial section.
  
  =head1 METHODS
  
  =head2 zilla
  
  This method is a shortcut for retrieving the C<zilla> from the root section.
  If called before that section has been finalized, it will result in an
  exception.
  
  =head2 register_stash
  
    $assembler->register_stash($name => $stash_object);
  
  This adds a stash to the assembler's zilla's stash registry -- unless the name
  is already taken, in which case an exception is raised.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_ASSEMBLER_ZILLA

$fatpacked{"Dist/Zilla/MVP/Reader/Finder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_READER_FINDER';
  package Dist::Zilla::MVP::Reader::Finder 6.007;
  # ABSTRACT: the reader for dist.ini files
  
  use Moose;
  use Config::MVP::Reader 2.101540; # if_none
  extends 'Config::MVP::Reader::Finder';
  
  use namespace::autoclean;
  
  use Dist::Zilla::MVP::Assembler;
  
  sub default_search_path {
    return qw(Dist::Zilla::MVP::Reader Config::MVP::Reader);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::Reader::Finder - the reader for dist.ini files
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_READER_FINDER

$fatpacked{"Dist/Zilla/MVP/Reader/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_READER_PERL';
  package Dist::Zilla::MVP::Reader::Perl 6.007;
  # ABSTRACT: the reader for dist.pl files
  
  use Moose;
  extends 'Config::MVP::Reader';
  with qw(Config::MVP::Reader::Findable::ByExtension);
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Dist::Zilla::Config reads in the F<dist.pl> file for a distribution.
  #pod
  #pod =cut
  
  sub default_extension { 'pl' }
  
  sub read_into_assembler {
    my ($self, $location, $asm) = @_;
  
    my @input = do $location;
    while (@input and ! ref $input[0]) {
      my ($key, $value) = (shift(@input), shift(@input));
      $asm->add_value($key => $value);
    }
  
    my $plugins = shift @input;
  
    confess "too much input" if @input;
  
    while (my ($ident, $arg) = splice @$plugins, 0, 2) {
      unless (ref $arg) {
        unshift @$plugins, $arg;
        $arg = [];
      }
  
      my ($moniker, $name) = ref $ident ? @$ident : (($ident) x 2);
      $asm->change_section($moniker, $name);
      my @to_iter = ref $arg eq 'HASH' ? %$arg : @$arg;
      while (my ($key, $value) = splice @to_iter, 0, 2) {
        $asm->add_value($key, $value);
      }
    }
  
    # should be done ... elsewhere? -- rjbs, 2009-08-24
    $self->assembler->end_section if $self->assembler->current_section;
  
    return $self->assembler->sequence;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::Reader::Perl - the reader for dist.pl files
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Dist::Zilla::Config reads in the F<dist.pl> file for a distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_READER_PERL

$fatpacked{"Dist/Zilla/MVP/RootSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_ROOTSECTION';
  package Dist::Zilla::MVP::RootSection 6.007;
  # ABSTRACT: a standard section in Dist::Zilla's configuration sequence
  
  use Moose;
  extends 'Config::MVP::Section';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This is a subclass of L<Config::MVP::Section>, used as the starting section by
  #pod L<Dist::Zilla::MVP::Assembler::Zilla>.  It has a number of useful defaults, as
  #pod well as a C<zilla> attribute which will, after section finalization, contain a
  #pod Dist::Zilla object with which subsequent plugin sections may register.
  #pod
  #pod Those useful defaults are:
  #pod
  #pod =for :list
  #pod * name defaults to _
  #pod * aliases defaults to { author => 'authors' }
  #pod * multivalue_args defaults to [ 'authors' ]
  #pod
  #pod =cut
  
  use MooseX::LazyRequire;
  use MooseX::SetOnce;
  use Moose::Util::TypeConstraints;
  
  has '+name'    => (default => '_');
  
  has '+aliases' => (default => sub { return { author => 'authors' } });
  
  has '+multivalue_args' => (default => sub { [ qw(authors) ] });
  
  has zilla => (
    is     => 'ro',
    isa    => class_type('Dist::Zilla'),
    traits => [ qw(SetOnce) ],
    writer => 'set_zilla',
    lazy_required => 1,
  );
  
  after finalize => sub {
    my ($self) = @_;
  
    my $assembler = $self->sequence->assembler;
  
    my %payload = %{ $self->payload };
  
    my %dzil;
    $dzil{$_} = delete $payload{":$_"} for grep { s/\A:// } keys %payload;
  
    my $zilla = $assembler->zilla_class->new( \%payload );
  
    if (defined $dzil{version}) {
      Dist::Zilla::Util->_assert_loaded_class_version_ok(
        'Dist::Zilla',
        $dzil{version},
      );
    }
  
    $self->set_zilla($zilla);
  };
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::RootSection - a standard section in Dist::Zilla's configuration sequence
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Config::MVP::Section>, used as the starting section by
  L<Dist::Zilla::MVP::Assembler::Zilla>.  It has a number of useful defaults, as
  well as a C<zilla> attribute which will, after section finalization, contain a
  Dist::Zilla object with which subsequent plugin sections may register.
  
  Those useful defaults are:
  
  =over 4
  
  =item *
  
  name defaults to _
  
  =item *
  
  aliases defaults to { author => 'authors' }
  
  =item *
  
  multivalue_args defaults to [ 'authors' ]
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_ROOTSECTION

$fatpacked{"Dist/Zilla/MVP/Section.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MVP_SECTION';
  package Dist::Zilla::MVP::Section 6.007;
  # ABSTRACT: a standard section in Dist::Zilla's configuration sequence
  
  use Moose;
  extends 'Config::MVP::Section';
  
  use namespace::autoclean;
  
  use Config::MVP::Section 2.200009; # not-installed error with section_name
  
  around add_value => sub {
    my ($orig, $self, $name, $value) = @_;
  
    if ($name =~ s/\A://) {
      if ($name eq 'version') {
        Dist::Zilla::Util->_assert_loaded_class_version_ok(
          $self->package,
          $value,
        );
      }
  
      return;
    }
  
    $self->$orig($name, $value);
  };
  
  after finalize => sub {
    my ($self) = @_;
  
    my ($name, $plugin_class, $arg) = (
      $self->name,
      $self->package,
      $self->payload,
    );
  
    my %payload = %{ $self->payload };
  
    $plugin_class->register_component($name, \%payload, $self);
  
    return;
  };
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MVP::Section - a standard section in Dist::Zilla's configuration sequence
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MVP_SECTION

$fatpacked{"Dist/Zilla/MintingProfile/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_MINTINGPROFILE_DEFAULT';
  package Dist::Zilla::MintingProfile::Default 6.007;
  # ABSTRACT: Default minting profile provider
  
  use Moose;
  with 'Dist::Zilla::Role::MintingProfile::ShareDir';
  
  use namespace::autoclean;
  
  use Dist::Zilla::Util;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Default minting profile provider.
  #pod
  #pod This provider looks first in the F<~/.dzil/profiles/$profile_name> directory,
  #pod if not found it looks among the default profiles shipped with Dist::Zilla.
  #pod
  #pod =cut
  
  around profile_dir => sub {
    my ($orig, $self, $profile_name) = @_;
  
    $profile_name ||= 'default';
  
    # shouldn't look in user's config when testing
    if (!$ENV{DZIL_TESTING}) {
      my $profile_dir = Dist::Zilla::Util->_global_config_root
                      ->child('profiles', $profile_name);
  
      return $profile_dir if -d $profile_dir;
    }
  
    return $self->$orig($profile_name);
  };
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::MintingProfile::Default - Default minting profile provider
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Default minting profile provider.
  
  This provider looks first in the F<~/.dzil/profiles/$profile_name> directory,
  if not found it looks among the default profiles shipped with Dist::Zilla.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_MINTINGPROFILE_DEFAULT

$fatpacked{"Dist/Zilla/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PATH';
  use strict;
  use warnings;
  use utf8;
  
  package Dist::Zilla::Path 6.007;
  # ABSTRACT: a helper to get Path::Tiny objects
  
  use parent 'Path::Tiny';
  
  use Path::Tiny 0.052 qw();  # issue 427
  use Scalar::Util qw( blessed );
  use Sub::Exporter -setup => {
    exports => [ qw( path ) ],
    groups  => { default => [ qw( path ) ] },
  };
  
  sub path {
    my ($thing, @rest) = @_;
  
    if (@rest == 0 && blessed $thing) {
      return $thing if $thing->isa(__PACKAGE__);
  
      return bless(Path::Tiny::path("$thing"), __PACKAGE__)
        if $thing->isa('Path::Class::Entity') || $thing->isa('Path::Tiny');
    }
  
    return bless(Path::Tiny::path($thing, @rest), __PACKAGE__);
  }
  
  my %warned;
  
  sub file {
    my ($self, @file) = @_;
  
    my ($package, $pmfile, $line) = caller;
    unless ($warned{ $pmfile, $line }++) {
      Carp::carp("->file called on a Dist::Zilla::Path object; this will cease to work in Dist::Zilla v7; downstream code should be updated to use Path::Tiny API, not Path::Class");
    }
  
    require Path::Class;
    Path::Class::dir($self)->file(@file);
  }
  
  sub subdir {
    my ($self, @subdir) = @_;
    Carp::carp("->subdir called on a Dist::Zilla::Path object; this will cease to work in Dist::Zilla v7; downstream code should be updated to use Path::Tiny API, not Path::Class");
    require Path::Class;
    Path::Class::dir($self)->subdir(@subdir);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Path - a helper to get Path::Tiny objects
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PATH

$fatpacked{"Dist/Zilla/Plugin/AutoPrereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_AUTOPREREQS';
  package Dist::Zilla::Plugin::AutoPrereqs 6.007;
  # ABSTRACT: automatically extract prereqs from your modules
  
  use Moose;
  with(
    'Dist::Zilla::Role::PrereqScanner',
    'Dist::Zilla::Role::PrereqSource',
    'Dist::Zilla::Role::PPI',
  );
  
  use Moose::Util::TypeConstraints 'enum';
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [AutoPrereqs]
  #pod   skip = ^Foo|Bar$
  #pod   skip = ^Other::Dist
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will extract loosely your distribution prerequisites from
  #pod your files using L<Perl::PrereqScanner>.
  #pod
  #pod If some prereqs are not found, you can still add them manually with the
  #pod L<Prereqs|Dist::Zilla::Plugin::Prereqs> plugin.
  #pod
  #pod This plugin will skip the modules shipped within your dist.
  #pod
  #pod B<Note>, if you have any non-Perl files in your C<t/> directory or other
  #pod directories being scanned, be sure to mark those files' encoding as C<bytes>
  #pod with the L<Encoding|Dist::Zilla::Plugin::Encoding> plugin so they won't be
  #pod scanned:
  #pod
  #pod     [Encoding]
  #pod     encoding = bytes
  #pod     match    = ^t/data/
  #pod
  #pod =attr finder
  #pod
  #pod This is the name of a L<FileFinder|Dist::Zilla::Role::FileFinder>
  #pod whose files will be scanned to determine runtime prerequisites.  It
  #pod may be specified multiple times.  The default value is
  #pod C<:InstallModules> and C<:ExecFiles>.
  #pod
  #pod =attr test_finder
  #pod
  #pod Just like C<finder>, but for test-phase prerequisites.  The default
  #pod value is C<:TestFiles>.
  #pod
  #pod =attr configure_finder
  #pod
  #pod Just like C<finder>, but for configure-phase prerequisites.  There is
  #pod no default value; AutoPrereqs will not determine configure-phase
  #pod prerequisites unless you set configure_finder.
  #pod
  #pod =attr develop_finder
  #pod
  #pod Just like C<finder>, but for develop-phase prerequisites.  The default value
  #pod is C<:ExtraTestFiles>.
  #pod
  #pod =attr skips
  #pod
  #pod This is an arrayref of regular expressions, derived from all the 'skip' lines
  #pod in the configuration.  Any module names matching any of these regexes will not
  #pod be registered as prerequisites.
  #pod
  #pod =attr relationship
  #pod
  #pod The relationship used for the registered prerequisites. The default value is
  #pod 'requires'; other options are 'recommends' and 'suggests'.
  #pod
  #pod =attr extra_scanners
  #pod
  #pod This is an arrayref of scanner names (as expected by L<Perl::PrereqScanner>).
  #pod It will be passed as the C<extra_scanners> parameter to L<Perl::PrereqScanner>.
  #pod
  #pod =attr scanners
  #pod
  #pod This is an arrayref of scanner names (as expected by L<Perl::PrereqScanner>).
  #pod If present, it will be passed as the C<scanners> parameter to
  #pod L<Perl::PrereqScanner>, which means that it will replace the default list
  #pod of scanners.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod L<Prereqs|Dist::Zilla::Plugin::Prereqs>, L<Perl::PrereqScanner>.
  #pod
  #pod =head1 CREDITS
  #pod
  #pod This plugin was originally contributed by Jerome Quelin.
  #pod
  #pod =cut
  
  sub mvp_multivalue_args { qw(extra_scanners scanners) }
  sub mvp_aliases { return { extra_scanner => 'extra_scanners',
                             scanner => 'scanners',
                             relationship => 'type' } }
  
  has extra_scanners => (
    is  => 'ro',
    isa => 'ArrayRef[Str]',
    default => sub { [] },
  );
  
  has scanners => (
    is  => 'ro',
    isa => 'ArrayRef[Str]',
    predicate => 'has_scanners',
  );
  
  
  has _scanner => (
    is => 'ro',
    lazy => 1,
    default => sub {
      my $self = shift;
  
      require Perl::PrereqScanner;
      Perl::PrereqScanner->VERSION('1.016'); # don't skip "lib"
  
      return Perl::PrereqScanner->new(
        ($self->has_scanners ? (scanners => $self->scanners) : ()),
        extra_scanners => $self->extra_scanners,
      )
    },
    init_arg => undef,
  );
  
  has type => (
    is => 'ro',
    isa => enum([qw(requires recommends suggests)]),
    default => 'requires',
  );
  
  sub scan_file_reqs {
    my ($self, $file) = @_;
    return $self->_scanner->scan_ppi_document($self->ppi_document_for_file($file))
  }
  
  sub register_prereqs {
    my $self  = shift;
  
    my $type = $self->type;
  
    my $reqs_by_phase = $self->scan_prereqs;
    while (my ($phase, $reqs) = each %$reqs_by_phase) {
      $self->zilla->register_prereqs({ phase => $phase, type => $type }, %$reqs);
    }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::AutoPrereqs - automatically extract prereqs from your modules
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [AutoPrereqs]
    skip = ^Foo|Bar$
    skip = ^Other::Dist
  
  =head1 DESCRIPTION
  
  This plugin will extract loosely your distribution prerequisites from
  your files using L<Perl::PrereqScanner>.
  
  If some prereqs are not found, you can still add them manually with the
  L<Prereqs|Dist::Zilla::Plugin::Prereqs> plugin.
  
  This plugin will skip the modules shipped within your dist.
  
  B<Note>, if you have any non-Perl files in your C<t/> directory or other
  directories being scanned, be sure to mark those files' encoding as C<bytes>
  with the L<Encoding|Dist::Zilla::Plugin::Encoding> plugin so they won't be
  scanned:
  
      [Encoding]
      encoding = bytes
      match    = ^t/data/
  
  =head1 ATTRIBUTES
  
  =head2 finder
  
  This is the name of a L<FileFinder|Dist::Zilla::Role::FileFinder>
  whose files will be scanned to determine runtime prerequisites.  It
  may be specified multiple times.  The default value is
  C<:InstallModules> and C<:ExecFiles>.
  
  =head2 test_finder
  
  Just like C<finder>, but for test-phase prerequisites.  The default
  value is C<:TestFiles>.
  
  =head2 configure_finder
  
  Just like C<finder>, but for configure-phase prerequisites.  There is
  no default value; AutoPrereqs will not determine configure-phase
  prerequisites unless you set configure_finder.
  
  =head2 develop_finder
  
  Just like C<finder>, but for develop-phase prerequisites.  The default value
  is C<:ExtraTestFiles>.
  
  =head2 skips
  
  This is an arrayref of regular expressions, derived from all the 'skip' lines
  in the configuration.  Any module names matching any of these regexes will not
  be registered as prerequisites.
  
  =head2 relationship
  
  The relationship used for the registered prerequisites. The default value is
  'requires'; other options are 'recommends' and 'suggests'.
  
  =head2 extra_scanners
  
  This is an arrayref of scanner names (as expected by L<Perl::PrereqScanner>).
  It will be passed as the C<extra_scanners> parameter to L<Perl::PrereqScanner>.
  
  =head2 scanners
  
  This is an arrayref of scanner names (as expected by L<Perl::PrereqScanner>).
  If present, it will be passed as the C<scanners> parameter to
  L<Perl::PrereqScanner>, which means that it will replace the default list
  of scanners.
  
  =head1 SEE ALSO
  
  L<Prereqs|Dist::Zilla::Plugin::Prereqs>, L<Perl::PrereqScanner>.
  
  =head1 CREDITS
  
  This plugin was originally contributed by Jerome Quelin.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_AUTOPREREQS

$fatpacked{"Dist/Zilla/Plugin/AutoVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_AUTOVERSION';
  package Dist::Zilla::Plugin::AutoVersion 6.007;
  # ABSTRACT: take care of numbering versions so you don't have to
  
  use Moose;
  with(
    'Dist::Zilla::Role::VersionProvider',
    'Dist::Zilla::Role::TextTemplate',
  );
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin automatically produces a version string, generally based on the
  #pod current time.  By default, it will be in the format: 1.yyDDDn
  #pod
  #pod =cut
  
  #pod =attr major
  #pod
  #pod The C<major> attribute is just an integer that is meant to store the major
  #pod version number.  If no value is specified in configuration, it will default to
  #pod 1.
  #pod
  #pod This attribute's value can be referred to in the autoversion format template.
  #pod
  #pod =cut
  
  has major => (
    is   => 'ro',
    isa  => 'Int',
    required => 1,
    default  => 1,
  );
  
  #pod =attr format
  #pod
  #pod The format is a L<Text::Template> string that will be rendered to form the
  #pod version.  It is meant to access to one variable, C<$major>, and one subroutine,
  #pod C<cldr>, which will format the current time (in GMT) using CLDR patterns (for
  #pod which consult the L<DateTime> documentation).
  #pod
  #pod The default value is:
  #pod
  #pod   {{ $major }}.{{ cldr('yyDDD') }}
  #pod   {{ sprintf('%01u', ($ENV{N} || 0)) }}
  #pod   {{$ENV{DEV} ? (sprintf '_%03u', $ENV{DEV}) : ''}}
  #pod
  #pod =cut
  
  has time_zone => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
    default  => 'GMT',
  );
  
  has format => (
    is       => 'ro',
    isa      => 'Str',
    required => 1,
    default  => q<{{ $major }}.{{ cldr('yyDDD') }}>
              . q<{{ sprintf('%01u', ($ENV{N} || 0)) }}>
              . q<{{$ENV{DEV} ? (sprintf '_%03u', $ENV{DEV}) : ''}}>
  );
  
  sub provide_version {
    my ($self) = @_;
  
    # TODO declare this as a 'develop' prereq as we want it in
    # `dzil listdeps --author`
    require DateTime;
    DateTime->VERSION('0.44'); # CLDR fixes
  
    my $now;
  
    my $version = $self->fill_in_string(
      $self->format,
      {
        major => \( $self->major ),
        cldr  => sub {
          $now ||= do {
            require DateTime;
            DateTime->VERSION('0.44'); # CLDR fixes
            DateTime->now(time_zone => $self->time_zone);
          };
          $now->format_cldr($_[0])
        },
      },
    );
  
    $self->log_debug([ 'providing version %s', $version ]);
  
    return $version;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<PkgVersion|Dist::Zilla::Plugin::PkgVersion>,
  #pod L<PodVersion|Dist::Zilla::Plugin::PodVersion>,
  #pod L<NextRelease|Dist::Zilla::Plugin::NextRelease>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<VersionProvider|Dist::Zilla::Role::VersionProvider>,
  #pod L<TextTemplate|Dist::Zilla::Role::TextTemplate>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::AutoVersion - take care of numbering versions so you don't have to
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin automatically produces a version string, generally based on the
  current time.  By default, it will be in the format: 1.yyDDDn
  
  =head1 ATTRIBUTES
  
  =head2 major
  
  The C<major> attribute is just an integer that is meant to store the major
  version number.  If no value is specified in configuration, it will default to
  1.
  
  This attribute's value can be referred to in the autoversion format template.
  
  =head2 format
  
  The format is a L<Text::Template> string that will be rendered to form the
  version.  It is meant to access to one variable, C<$major>, and one subroutine,
  C<cldr>, which will format the current time (in GMT) using CLDR patterns (for
  which consult the L<DateTime> documentation).
  
  The default value is:
  
    {{ $major }}.{{ cldr('yyDDD') }}
    {{ sprintf('%01u', ($ENV{N} || 0)) }}
    {{$ENV{DEV} ? (sprintf '_%03u', $ENV{DEV}) : ''}}
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<PkgVersion|Dist::Zilla::Plugin::PkgVersion>,
  L<PodVersion|Dist::Zilla::Plugin::PodVersion>,
  L<NextRelease|Dist::Zilla::Plugin::NextRelease>.
  
  Dist::Zilla roles:
  L<VersionProvider|Dist::Zilla::Role::VersionProvider>,
  L<TextTemplate|Dist::Zilla::Role::TextTemplate>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_AUTOVERSION

$fatpacked{"Dist/Zilla/Plugin/CPANFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_CPANFILE';
  package Dist::Zilla::Plugin::CPANFile 6.007;
  # ABSTRACT: produce a cpanfile prereqs file
  
  use Moose;
  with 'Dist::Zilla::Role::FileGatherer';
  
  use namespace::autoclean;
  
  use Dist::Zilla::File::FromCode;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will add a F<cpanfile> file to the distribution.
  #pod
  #pod =attr filename
  #pod
  #pod If given, parameter allows you to specify an alternate name for the generated
  #pod file.  It defaults, of course, to F<cpanfile>.
  #pod
  #pod =cut
  
  has filename => (
    is  => 'ro',
    isa => 'Str',
    default => 'cpanfile',
  );
  
  sub _hunkify_hunky_hunk_hunks {
    my ($self, $indent, $type, $req) = @_;
  
    my $str = '';
    for my $module (sort $req->required_modules) {
      my $vstr = $req->requirements_for_module($module);
      $str .= qq{$type "$module" => "$vstr";\n};
    }
    $str =~ s/^/'  ' x $indent/egm;
    return $str;
  }
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    my $zilla = $self->zilla;
  
    my $file  = Dist::Zilla::File::FromCode->new({
      name => $self->filename,
      code => sub {
        my $prereqs = $zilla->prereqs;
  
        my @types  = qw(requires recommends suggests conflicts);
        my @phases = qw(runtime build test configure develop);
  
        my $str = '';
        for my $phase (@phases) {
          for my $type (@types) {
            my $req = $prereqs->requirements_for($phase, $type);
            next unless $req->required_modules;
            $str .= qq[\non '$phase' => sub {\n] unless $phase eq 'runtime';
            $str .= $self->_hunkify_hunky_hunk_hunks(
              ($phase eq 'runtime' ? 0 : 1),
              $type,
              $req,
            );
            $str .= qq[};\n]                     unless $phase eq 'runtime';
          }
        }
  
        return $str;
      },
    });
  
    $self->add_file($file);
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::CPANFile - produce a cpanfile prereqs file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin will add a F<cpanfile> file to the distribution.
  
  =head1 ATTRIBUTES
  
  =head2 filename
  
  If given, parameter allows you to specify an alternate name for the generated
  file.  It defaults, of course, to F<cpanfile>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_CPANFILE

$fatpacked{"Dist/Zilla/Plugin/ConfirmRelease.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_CONFIRMRELEASE';
  package Dist::Zilla::Plugin::ConfirmRelease 6.007;
  # ABSTRACT: prompt for confirmation before releasing
  
  use Moose;
  with 'Dist::Zilla::Role::BeforeRelease';
  
  use namespace::autoclean;
  
  sub before_release {
    my ($self, $tgz) = @_;
  
    my $releasers = join q{, },
                    map {; $_->plugin_name }
                    @{ $self->zilla->plugins_with(-Releaser) };
  
    $self->log("*** Preparing to release $tgz with $releasers ***");
    my $prompt = "Do you want to continue the release process?";
  
    my $default = exists $ENV{DZIL_CONFIRMRELEASE_DEFAULT}
                ? $ENV{DZIL_CONFIRMRELEASE_DEFAULT}
                : 0;
  
    my $confirmed = $self->zilla->chrome->prompt_yn(
      $prompt,
      { default => $default }
    );
  
    $self->log_fatal("Aborting release") unless $confirmed;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin prompts the author whether or not to continue before releasing
  #pod the distribution to CPAN.  It gives authors a chance to abort before
  #pod they upload.
  #pod
  #pod The default is "no", but you can set the environment variable
  #pod C<DZIL_CONFIRMRELEASE_DEFAULT> to "yes" if you just want to hit enter to
  #pod release.
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ConfirmRelease - prompt for confirmation before releasing
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin prompts the author whether or not to continue before releasing
  the distribution to CPAN.  It gives authors a chance to abort before
  they upload.
  
  The default is "no", but you can set the environment variable
  C<DZIL_CONFIRMRELEASE_DEFAULT> to "yes" if you just want to hit enter to
  release.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_CONFIRMRELEASE

$fatpacked{"Dist/Zilla/Plugin/DistINI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_DISTINI';
  package Dist::Zilla::Plugin::DistINI 6.007;
  # ABSTRACT: a plugin to add a dist.ini to newly-minted dists
  
  use Moose;
  with qw(Dist::Zilla::Role::FileGatherer);
  
  use Dist::Zilla::File::FromCode;
  
  use MooseX::Types::Moose qw(ArrayRef Str);
  use Dist::Zilla::Path;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugins produces a F<dist.ini> file in a new dist, specifying the required
  #pod core attributes from the dist being minted.
  #pod
  #pod This plugin is dead simple and pretty stupid, but should get better as dist
  #pod minting facilities improve.  For example, it will not specify any plugins.
  #pod
  #pod In the meantime, you may be happier with a F<dist.ini> template.
  #pod
  #pod =attr append_file
  #pod
  #pod This parameter may be a filename in the profile's directory to append to the
  #pod generated F<dist.ini> with things like plugins.  In other words, if your make
  #pod this file, called F<plugins.ini>:
  #pod
  #pod   [@Basic]
  #pod   [NextRelease]
  #pod   [@Git]
  #pod
  #pod ...and your F<profile.ini> includes:
  #pod
  #pod   [DistINI]
  #pod   append_file = plugins.ini
  #pod
  #pod ...then the generated C<dist.ini> in a newly-minted dist will look something
  #pod like this:
  #pod
  #pod   name    = My-New-Dist
  #pod   author  = E. Xavier Ample <example@example.com>
  #pod   license = Perl_5
  #pod   copyright_holder = E. Xavier Ample
  #pod   copyright_year   = 2010
  #pod
  #pod   [@Basic]
  #pod   [NextRelease]
  #pod   [@Git]
  #pod
  #pod =cut
  
  sub mvp_multivalue_args { qw(append_file) }
  
  has append_file => (
    is  => 'ro',
    isa => ArrayRef[ Str ],
    default => sub { [] },
  );
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    my $zilla = $self->zilla;
  
    my $postlude = '';
  
    for (@{ $self->append_file }) {
      my $fn = $self->zilla->root->child($_);
  
      $postlude .= path($fn)->slurp_utf8;
    }
  
    my $code = sub {
      my @core_attrs = qw(name authors copyright_holder);
  
      my $license = ref $zilla->license;
      if ($license =~ /^Software::License::(.+)$/) {
        $license = $1;
      } else {
        $license = "=$license";
      }
  
      my $content = '';
      $content .= sprintf "name    = %s\n", $zilla->name;
      $content .= sprintf "author  = %s\n", $_ for @{ $zilla->authors };
      $content .= sprintf "license = %s\n", $license;
      $content .= sprintf "copyright_holder = %s\n", $zilla->copyright_holder;
      $content .= sprintf "copyright_year   = %s\n", (localtime)[5] + 1900;
      $content .= "\n";
  
      $content .= $postlude;
    };
  
    my $file = Dist::Zilla::File::FromCode->new({
      name => 'dist.ini',
      code => $code,
    });
  
    $self->add_file($file);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::DistINI - a plugin to add a dist.ini to newly-minted dists
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugins produces a F<dist.ini> file in a new dist, specifying the required
  core attributes from the dist being minted.
  
  This plugin is dead simple and pretty stupid, but should get better as dist
  minting facilities improve.  For example, it will not specify any plugins.
  
  In the meantime, you may be happier with a F<dist.ini> template.
  
  =head1 ATTRIBUTES
  
  =head2 append_file
  
  This parameter may be a filename in the profile's directory to append to the
  generated F<dist.ini> with things like plugins.  In other words, if your make
  this file, called F<plugins.ini>:
  
    [@Basic]
    [NextRelease]
    [@Git]
  
  ...and your F<profile.ini> includes:
  
    [DistINI]
    append_file = plugins.ini
  
  ...then the generated C<dist.ini> in a newly-minted dist will look something
  like this:
  
    name    = My-New-Dist
    author  = E. Xavier Ample <example@example.com>
    license = Perl_5
    copyright_holder = E. Xavier Ample
    copyright_year   = 2010
  
    [@Basic]
    [NextRelease]
    [@Git]
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_DISTINI

$fatpacked{"Dist/Zilla/Plugin/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_ENCODING';
  package Dist::Zilla::Plugin::Encoding 6.007;
  # ABSTRACT: set the encoding of arbitrary files
  
  use Moose;
  with 'Dist::Zilla::Role::EncodingProvider';
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod This plugin allows you to explicitly set the encoding on some files in your
  #pod distribution. You can either specify the exact set of files (with the
  #pod "filenames" parameter) or provide the regular expressions to check (using
  #pod "match").
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [Encoding]
  #pod   encoding = Latin-3
  #pod
  #pod   filename = t/esperanto.t  ; this file is Esperanto
  #pod   match     = ^t/urkish/    ; these are all Turkish
  #pod
  #pod =cut
  
  sub mvp_multivalue_args { qw(filenames matches ignore) }
  sub mvp_aliases { return { filename => 'filenames', match => 'matches' } }
  
  #pod =attr encoding
  #pod
  #pod This is the encoding to set on the selected files. The special value "bytes"
  #pod can be used to indicate raw files that should not be encoded.
  #pod
  #pod =cut
  
  has encoding => (
    is   => 'ro',
    isa  => 'Str',
    required => 1,
  );
  
  #pod =attr filenames
  #pod
  #pod This is an arrayref of filenames to have their encoding set.
  #pod
  #pod =cut
  
  has filenames => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  #pod =attr matches
  #pod
  #pod This is an arrayref of regular expressions.  Any file whose name matches one of
  #pod these regex will have its encoding set.
  #pod
  #pod =cut
  
  has matches => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  #pod =attr ignore
  #pod
  #pod This is an arrayref of regular expressions.  Any file whose name matches one of
  #pod these regex will B<not> have its encoding set. Useful to ignore a few files
  #pod that would otherwise be selected by C<matches>.
  #pod
  #pod =cut
  
  has ignore => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  sub set_file_encodings {
    my ($self) = @_;
  
    # never match (at least the filename characters)
    my $matches_regex = qr/\000/;
  
    $matches_regex = qr/$matches_regex|$_/ for @{$self->matches};
  
    # \A\Q$_\E should also handle the `eq` check
    $matches_regex = qr/$matches_regex|\A\Q$_\E/ for @{$self->filenames};
  
    my( $ignore_regex ) = map { $_ && qr/$_/ } join '|', @{ $self->ignore };
  
    for my $file (@{$self->zilla->files}) {
      next unless $file->name =~ $matches_regex;
  
      next if $ignore_regex and $file->name =~ $ignore_regex;
  
      $self->log_debug([
        'setting encoding of %s to %s',
        $file->name,
        $self->encoding,
      ]);
  
      $file->encoding($self->encoding);
    }
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::Encoding - set the encoding of arbitrary files
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  This plugin allows you to explicitly set the encoding on some files in your
  distribution. You can either specify the exact set of files (with the
  "filenames" parameter) or provide the regular expressions to check (using
  "match").
  
  In your F<dist.ini>:
  
    [Encoding]
    encoding = Latin-3
  
    filename = t/esperanto.t  ; this file is Esperanto
    match     = ^t/urkish/    ; these are all Turkish
  
  =head1 ATTRIBUTES
  
  =head2 encoding
  
  This is the encoding to set on the selected files. The special value "bytes"
  can be used to indicate raw files that should not be encoded.
  
  =head2 filenames
  
  This is an arrayref of filenames to have their encoding set.
  
  =head2 matches
  
  This is an arrayref of regular expressions.  Any file whose name matches one of
  these regex will have its encoding set.
  
  =head2 ignore
  
  This is an arrayref of regular expressions.  Any file whose name matches one of
  these regex will B<not> have its encoding set. Useful to ignore a few files
  that would otherwise be selected by C<matches>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_ENCODING

$fatpacked{"Dist/Zilla/Plugin/ExecDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_EXECDIR';
  package Dist::Zilla::Plugin::ExecDir 6.007;
  # ABSTRACT: install a directory's contents as executables
  
  use Moose;
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [ExecDir]
  #pod   dir = scripts
  #pod
  #pod If no C<dir> is provided, the default is F<bin>.
  #pod
  #pod =cut
  
  has dir => (
    is   => 'ro',
    isa  => 'Str',
    default => 'bin',
  );
  
  sub find_files {
    my ($self) = @_;
  
    my $dir = $self->dir;
    my $files = [
      grep { index($_->name, "$dir/") == 0 } @{ $self->zilla->files }
    ];
  }
  
  with 'Dist::Zilla::Role::ExecFiles';
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ExecDir - install a directory's contents as executables
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [ExecDir]
    dir = scripts
  
  If no C<dir> is provided, the default is F<bin>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_EXECDIR

$fatpacked{"Dist/Zilla/Plugin/ExtraTests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_EXTRATESTS';
  package Dist::Zilla::Plugin::ExtraTests 6.007;
  # ABSTRACT: rewrite ./xt tests to ./t tests with skips
  
  use Moose;
  with 'Dist::Zilla::Role::FileMunger';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin rewrites tests found in the following directories:
  #pod
  #pod   ./xt/author  - tests for author testing (env AUTHOR_TESTING is true)
  #pod   ./xt/release - tests for pre-release testers (env RELEASE_TESTING is true)
  #pod   ./xt/smoke   - tests for automated testers (env AUTOMATED_TESTING is true)
  #pod
  #pod The tests are renamed and moved to F<./t>, and they are rewritten to include
  #pod some simple Perl code to skip all included tests if the correct env vars are
  #pod not set.
  #pod
  #pod =cut
  
  sub munge_file {
    my ($self, $file) = @_;
  
    return unless $file->name =~ m{\Axt/(smoke|author|release)/.+\.t\z};
    my $method = "_rewrite_$1\_test";
  
    $self->log("rewriting $1 test " . $file->name);
  
    $self->$method($file);
  }
  
  sub _rewrite_smoke_test {
    my ($self, $file) = @_;
    $self->_rewrite($file, 'AUTOMATED_TESTING', '"smoke bot" testing');
  }
  
  sub _rewrite_author_test {
    my ($self, $file) = @_;
    $self->_rewrite($file, 'AUTHOR_TESTING', 'testing by the author');
  }
  
  sub _rewrite_release_test {
    my ($self, $file) = @_;
    $self->_rewrite($file, 'RELEASE_TESTING', 'release candidate testing');
  }
  
  sub _rewrite {
    my ($self, $file, $env, $msg) = @_;
  
    my $name = $file->name =~ s{^xt/([^/]+)/}{t/$1-}r;
  
    $file->name($name);
  
    my @lines = split /\n/, $file->content;
    my $after = $lines[0] =~ /\A#!/ ? 1 : 0;
    splice @lines, $after, 0, qq|
  BEGIN {
    unless (\$ENV{$env}) {
      print "1..0 # SKIP these tests are for $msg\\n";
      exit
    }
  }
  |;
  
    $file->content(join "\n", @lines, '');
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ExtraTests - rewrite ./xt tests to ./t tests with skips
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin rewrites tests found in the following directories:
  
    ./xt/author  - tests for author testing (env AUTHOR_TESTING is true)
    ./xt/release - tests for pre-release testers (env RELEASE_TESTING is true)
    ./xt/smoke   - tests for automated testers (env AUTOMATED_TESTING is true)
  
  The tests are renamed and moved to F<./t>, and they are rewritten to include
  some simple Perl code to skip all included tests if the correct env vars are
  not set.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_EXTRATESTS

$fatpacked{"Dist/Zilla/Plugin/FakeRelease.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_FAKERELEASE';
  package Dist::Zilla::Plugin::FakeRelease 6.007;
  # ABSTRACT: fake plugin to test release
  
  use Moose;
  with 'Dist::Zilla::Role::Releaser';
  
  use namespace::autoclean;
  
  has user => (
    is   => 'ro',
    isa  => 'Str',
    required => 1,
    default  => 'AUTHORID',
  );
  
  sub cpanid { shift->user }
  
  sub release {
    my $self = shift;
  
    for my $env (
      'DIST_ZILLA_FAKERELEASE_FAIL', # old
      'DZIL_FAKERELEASE_FAIL',       # new
    ) {
      $self->log_fatal("$env set, aborting") if $ENV{$env};
    }
  
    $self->log('Fake release happening (nothing was really done)');
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod     [FakeRelease]
  #pod     user = CPANAUTHORID ; # optional.
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin is a L<Releaser|Dist::Zilla::Role::Releaser> that does nothing. It
  #pod is directed to plugin authors, who may need a dumb release plugin to test their
  #pod shiny plugin implementing L<BeforeRelease|Dist::Zilla::Role::BeforeRelease>
  #pod and L<AfterRelease|Dist::Zilla::Role::AfterRelease>.
  #pod
  #pod When this plugin does the release, it will just log a message and finish.
  #pod
  #pod If you set the environment variable C<DZIL_FAKERELEASE_FAIL> to a true value,
  #pod the plugin will die instead of doing nothing. This can be useful for
  #pod authors wanting to test reliably that release failed.
  #pod
  #pod You can optionally provide the 'user' parameter, which defaults to 'AUTHORID',
  #pod which will allow things that depend on this metadata
  #pod ( Sometimes provided by L<UploadToCPAN|Dist::Zilla::Plugin::UploadToCPAN> ) to still work.
  #pod ( For example: L<Dist::Zilla::Plugin::Twitter> )
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<ConfirmRelease|Dist::Zilla::Plugin::ConfirmRelease>,
  #pod L<UploadToCPAN|Dist::Zilla::Plugin::UploadToCPAN>.
  #pod
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::FakeRelease - fake plugin to test release
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
      [FakeRelease]
      user = CPANAUTHORID ; # optional.
  
  =head1 DESCRIPTION
  
  This plugin is a L<Releaser|Dist::Zilla::Role::Releaser> that does nothing. It
  is directed to plugin authors, who may need a dumb release plugin to test their
  shiny plugin implementing L<BeforeRelease|Dist::Zilla::Role::BeforeRelease>
  and L<AfterRelease|Dist::Zilla::Role::AfterRelease>.
  
  When this plugin does the release, it will just log a message and finish.
  
  If you set the environment variable C<DZIL_FAKERELEASE_FAIL> to a true value,
  the plugin will die instead of doing nothing. This can be useful for
  authors wanting to test reliably that release failed.
  
  You can optionally provide the 'user' parameter, which defaults to 'AUTHORID',
  which will allow things that depend on this metadata
  ( Sometimes provided by L<UploadToCPAN|Dist::Zilla::Plugin::UploadToCPAN> ) to still work.
  ( For example: L<Dist::Zilla::Plugin::Twitter> )
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<ConfirmRelease|Dist::Zilla::Plugin::ConfirmRelease>,
  L<UploadToCPAN|Dist::Zilla::Plugin::UploadToCPAN>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_FAKERELEASE

$fatpacked{"Dist/Zilla/Plugin/FileFinder/ByName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_FILEFINDER_BYNAME';
  package Dist::Zilla::Plugin::FileFinder::ByName 6.007;
  # ABSTRACT: FileFinder matching on pathnames
  
  use Moose;
  with 'Dist::Zilla::Role::FileFinder';
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [FileFinder::ByName / MyFiles]
  #pod   dir   = bin     ; look in the bin/ directory
  #pod   dir   = lib     ; and the lib/ directory
  #pod   file  = *.pl    ; for .pl files
  #pod   match = \.pm$   ; and for .pm files
  #pod   skip  = ignore  ; that don't have "ignore" in the path
  #pod
  #pod =head1 CREDITS
  #pod
  #pod This plugin was originally contributed by Christopher J. Madsen.
  #pod
  #pod =cut
  
  use Moose::Util::TypeConstraints;
  use MooseX::Types::Moose qw(ArrayRef RegexpRef Str);
  
  use Text::Glob 0.08 qw(glob_to_regex_string);
  
  #pod =attr dir
  #pod
  #pod The file must be located in one of the specified directories (relative
  #pod to the root directory of the dist).
  #pod
  #pod =attr file
  #pod
  #pod The filename must match one of the specified patterns (which are
  #pod converted to regexs using L<Text::Glob> and combined with any C<match>
  #pod rules).
  #pod
  #pod =cut
  
  has dirs => (
    is       => 'ro',
    isa      => ArrayRef[Str],
    default  => sub { [] },
  );
  
  has files => (
    is      => 'ro',
    isa      => ArrayRef[Str],
    default => sub { [] },
  );
  
  {
    my $type = subtype as ArrayRef[RegexpRef];
    coerce $type, from ArrayRef[Str], via { [map { qr/$_/ } @$_] };
  
  #pod =attr match
  #pod
  #pod The pathname must match one of these regular expressions.
  #pod
  #pod =attr skip
  #pod
  #pod The pathname must I<not> match any of these regular expressions.
  #pod
  #pod =cut
  
    has matches => (
      is      => 'ro',
      isa     => $type,
      coerce  => 1,
      default => sub { [] },
    );
  
    has skips => (
      is      => 'ro',
      isa     => $type,
      coerce  => 1,
      default => sub { [] },
    );
  }
  
  sub mvp_aliases { +{ qw(
    dir      dirs
    file     files
    match    matches
    matching matches
    skip     skips
    except   skips
  ) } }
  
  sub mvp_multivalue_args { qw(dirs files matches skips) }
  
  sub _join_re {
    my $list = shift;
    return undef unless @$list;
    # Special case to avoid stringify+compile
    return $list->[0] if @$list == 1;
    # Wrap each element to ensure that alternations are isolated
    my $re = join('|', map { "(?:$_)" } @$list);
    qr/$re/
  }
  
  sub find_files {
    my $self = shift;
  
    my $skip  = _join_re($self->skips);
    my $dir   = _join_re([ map { qr!^\Q$_/! } @{ $self->dirs } ]);
    my $match = _join_re([
      (map { my $re = glob_to_regex_string($_); qr!(?:\A|/)$re\z! }
           @{ $self->files }),
      @{ $self->matches }
    ]);
  
    my $files = $self->zilla->files;
  
    $files = [ grep {
      my $name = $_->name;
      (not defined $dir   or $name =~ $dir)   and
      (not defined $match or $name =~ $match) and
      (not defined $skip  or $name !~ $skip)
    } @$files ];
  
    $self->log_debug("No files found") unless @$files;
    $self->log_debug("Found " . $_->name) for @$files;
  
    $files;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod FileFinder::ByName is a L<FileFinder|Dist::Zilla::Role::FileFinder> that
  #pod selects files by matching the criteria you specify against the pathname.
  #pod
  #pod There are three types of criteria you can use.  C<dir> limits the
  #pod search to a particular directory.  C<match> is a regular expression
  #pod that must match the pathname.  C<skip> is a regular expression that
  #pod must not match the pathname.
  #pod
  #pod Each key can be specified multiple times.  Multiple occurrences of the
  #pod same key are ORed together.  Different keys are ANDed together.  That
  #pod means that to be selected, a file must be located in one of the
  #pod C<dir>s, must match one of the C<match> regexs, and must not match any
  #pod of the C<skip> regexs.
  #pod
  #pod Note that C<file> and C<match> are considered to be the I<same> key.
  #pod They're just different ways to write a regex that the pathname must match.
  #pod
  #pod Omitting a particular key means that criterion will not apply to the
  #pod search.  Omitting all keys will select every file in your dist.
  #pod
  #pod Note: If you need to OR different types of criteria, then use more
  #pod than one instance of FileFinder::ByName.  A
  #pod L<FileFinderUser|Dist::Zilla::Role::FileFinderUser> should allow you
  #pod to specify more than one FileFinder to use.
  #pod
  #pod =for Pod::Coverage
  #pod mvp_aliases
  #pod mvp_multivalue_args
  #pod find_files
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::FileFinder::ByName - FileFinder matching on pathnames
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [FileFinder::ByName / MyFiles]
    dir   = bin     ; look in the bin/ directory
    dir   = lib     ; and the lib/ directory
    file  = *.pl    ; for .pl files
    match = \.pm$   ; and for .pm files
    skip  = ignore  ; that don't have "ignore" in the path
  
  =head1 DESCRIPTION
  
  FileFinder::ByName is a L<FileFinder|Dist::Zilla::Role::FileFinder> that
  selects files by matching the criteria you specify against the pathname.
  
  There are three types of criteria you can use.  C<dir> limits the
  search to a particular directory.  C<match> is a regular expression
  that must match the pathname.  C<skip> is a regular expression that
  must not match the pathname.
  
  Each key can be specified multiple times.  Multiple occurrences of the
  same key are ORed together.  Different keys are ANDed together.  That
  means that to be selected, a file must be located in one of the
  C<dir>s, must match one of the C<match> regexs, and must not match any
  of the C<skip> regexs.
  
  Note that C<file> and C<match> are considered to be the I<same> key.
  They're just different ways to write a regex that the pathname must match.
  
  Omitting a particular key means that criterion will not apply to the
  search.  Omitting all keys will select every file in your dist.
  
  Note: If you need to OR different types of criteria, then use more
  than one instance of FileFinder::ByName.  A
  L<FileFinderUser|Dist::Zilla::Role::FileFinderUser> should allow you
  to specify more than one FileFinder to use.
  
  =head1 ATTRIBUTES
  
  =head2 dir
  
  The file must be located in one of the specified directories (relative
  to the root directory of the dist).
  
  =head2 file
  
  The filename must match one of the specified patterns (which are
  converted to regexs using L<Text::Glob> and combined with any C<match>
  rules).
  
  =head2 match
  
  The pathname must match one of these regular expressions.
  
  =head2 skip
  
  The pathname must I<not> match any of these regular expressions.
  
  =head1 CREDITS
  
  This plugin was originally contributed by Christopher J. Madsen.
  
  =for Pod::Coverage mvp_aliases
  mvp_multivalue_args
  find_files
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_FILEFINDER_BYNAME

$fatpacked{"Dist/Zilla/Plugin/FileFinder/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_FILEFINDER_FILTER';
  package Dist::Zilla::Plugin::FileFinder::Filter 6.007;
  # ABSTRACT: filter matches from other FileFinders
  
  use Moose;
  with(
    'Dist::Zilla::Role::FileFinder',
    'Dist::Zilla::Role::FileFinderUser' => {
      default_finders => [],
    },
  );
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [FileFinder::Filter / MyFiles]
  #pod   finder = :InstallModules ; find files from :InstallModules
  #pod   finder = :ExecFiles      ; or :ExecFiles
  #pod   skip  = ignore           ; that don't have "ignore" in the path
  #pod
  #pod =head1 CREDITS
  #pod
  #pod This plugin was originally contributed by Christopher J. Madsen.
  #pod
  #pod =cut
  
  use Moose::Util::TypeConstraints;
  use MooseX::Types::Moose qw(ArrayRef RegexpRef Str);
  
  {
    my $type = subtype as ArrayRef[RegexpRef];
    coerce $type, from ArrayRef[Str], via { [map { qr/$_/ } @$_] };
  
  #pod =attr finder
  #pod
  #pod A FileFinder to supply the initial list of files.
  #pod May occur multiple times.
  #pod
  #pod =attr skip
  #pod
  #pod The pathname must I<not> match any of these regular expressions.
  #pod May occur multiple times.
  #pod
  #pod =cut
  
    has skips => (
      is      => 'ro',
      isa     => $type,
      coerce  => 1,
      default => sub { [] },
    );
  }
  
  sub mvp_aliases { +{ qw(
    skip     skips
  ) } }
  
  sub mvp_multivalue_args { qw(skips) }
  
  sub find_files {
    my $self = shift;
  
    my $files = $self->found_files;
  
    foreach my $re (@{ $self->skips }) {
      @$files = grep { $_->name !~ $re } @$files;
    }
  
    $self->log_debug("No files found") unless @$files;
    $self->log_debug("Found " . $_->name) for @$files;
  
    $files;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod FileFinder::Filter is a L<FileFinder|Dist::Zilla::Role::FileFinder> that
  #pod selects files by filtering the selections of other FileFinders.
  #pod
  #pod You specify one or more FileFinders to generate the initial list of
  #pod files.  Any file whose pathname matches any of the C<skip> regexs is
  #pod removed from that list.
  #pod
  #pod =for Pod::Coverage
  #pod mvp_aliases
  #pod mvp_multivalue_args
  #pod find_files
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::FileFinder::Filter - filter matches from other FileFinders
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [FileFinder::Filter / MyFiles]
    finder = :InstallModules ; find files from :InstallModules
    finder = :ExecFiles      ; or :ExecFiles
    skip  = ignore           ; that don't have "ignore" in the path
  
  =head1 DESCRIPTION
  
  FileFinder::Filter is a L<FileFinder|Dist::Zilla::Role::FileFinder> that
  selects files by filtering the selections of other FileFinders.
  
  You specify one or more FileFinders to generate the initial list of
  files.  Any file whose pathname matches any of the C<skip> regexs is
  removed from that list.
  
  =head1 ATTRIBUTES
  
  =head2 finder
  
  A FileFinder to supply the initial list of files.
  May occur multiple times.
  
  =head2 skip
  
  The pathname must I<not> match any of these regular expressions.
  May occur multiple times.
  
  =head1 CREDITS
  
  This plugin was originally contributed by Christopher J. Madsen.
  
  =for Pod::Coverage mvp_aliases
  mvp_multivalue_args
  find_files
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_FILEFINDER_FILTER

$fatpacked{"Dist/Zilla/Plugin/FinderCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_FINDERCODE';
  package Dist::Zilla::Plugin::FinderCode 6.007;
  # ABSTRACT: a callback-based FileFinder plugin
  
  use Moose;
  with 'Dist::Zilla::Role::FileFinder';
  
  use namespace::autoclean;
  
  use Moose::Util::TypeConstraints;
  
  has code => (
    is  => 'ro',
    isa => 'CodeRef',
    required => 1,
  );
  
  has style => (
    is  => 'ro',
    isa => enum([ qw(grep list) ]),
    required => 1,
  );
  
  sub find_files {
    my ($self) = @_;
  
    my $method = '_find_via_' . $self->style;
  
    $self->$method;
  }
  
  sub _find_via_grep {
    my ($self) = @_;
  
    my @files = grep { $self->code->($_, $self) } @{ $self->zilla->files };
    return \@files;
  }
  
  sub _find_via_list {
    my ($self) = @_;
  
    my $code = $self->code;
    $self->$code;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::FinderCode - a callback-based FileFinder plugin
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_FINDERCODE

$fatpacked{"Dist/Zilla/Plugin/GatherDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_GATHERDIR';
  package Dist::Zilla::Plugin::GatherDir 6.007;
  # ABSTRACT: gather all the files in a directory
  
  use Moose;
  use Dist::Zilla::Types qw(Path);
  with 'Dist::Zilla::Role::FileGatherer';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This is a very, very simple L<FileGatherer|Dist::Zilla::Role::FileGatherer>
  #pod plugin.  It looks in the directory named in the L</root> attribute and adds all
  #pod the files it finds there.  If the root begins with a tilde, the tilde is
  #pod replaced with the current user's home directory according to L<File::HomeDir>.
  #pod
  #pod Almost every dist will be built with one GatherDir plugin, since it's the
  #pod easiest way to get files from disk into your dist.  Most users just need:
  #pod
  #pod   [GatherDir]
  #pod   [PruneCruft]
  #pod
  #pod ...and this will pick up all the files from the current directory into the
  #pod dist.  (L<PruneCruft|Dist::Zilla::Plugin::PruneCruft> is needed, here, to drop
  #pod files that might present as build artifacts, but should not be shipped.)  You
  #pod can use it multiple times, as you can any other plugin, by providing a plugin
  #pod name.  For example, if you want to include external specification files into a
  #pod subdir of your dist, you might write:
  #pod
  #pod   [GatherDir]
  #pod   ; this plugin needs no config and gathers most of your files
  #pod
  #pod   [GatherDir / SpecFiles]
  #pod   ; this plugin gets all the files in the root dir and adds them under ./spec
  #pod   root   = ~/projects/my-project/spec
  #pod   prefix = spec
  #pod
  #pod =cut
  
  use File::Find::Rule;
  use File::Spec;
  use Path::Tiny;
  use List::Util 1.33 'all';
  
  #pod =attr root
  #pod
  #pod This is the directory in which to look for files.  If not given, it defaults to
  #pod the dist root -- generally, the place where your F<dist.ini> or other
  #pod configuration file is located.
  #pod
  #pod =cut
  
  has root => (
    is   => 'ro',
    isa  => Path,
    lazy => 1,
    coerce   => 1,
    required => 1,
    default  => sub { shift->zilla->root },
  );
  
  #pod =attr prefix
  #pod
  #pod This parameter can be set to place the gathered files under a particular
  #pod directory.  See the L<description|DESCRIPTION> above for an example.
  #pod
  #pod =cut
  
  has prefix => (
    is  => 'ro',
    isa => 'Str',
    default => '',
  );
  
  #pod =attr include_dotfiles
  #pod
  #pod By default, files will not be included if they begin with a dot.  This goes
  #pod both for files and for directories relative to the C<root>.
  #pod
  #pod In almost all cases, the default value (false) is correct.
  #pod
  #pod =cut
  
  has include_dotfiles => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  #pod =attr follow_symlinks
  #pod
  #pod By default, symlinks pointing to directories will not be followed; set
  #pod C<< follow_symlinks = 1 >> to traverse these links as if they were normal
  #pod directories.
  #pod
  #pod In all followed directories, files which are symlinks are B<always> gathered,
  #pod with the link turning into a normal file.
  #pod
  #pod =cut
  
  has follow_symlinks => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  sub mvp_multivalue_args { qw(exclude_filename exclude_match prune_directory) }
  
  #pod =attr exclude_filename
  #pod
  #pod To exclude certain files from being gathered, use the C<exclude_filename>
  #pod option.  The filename is matched exactly, relative to C<root>.
  #pod This may be used multiple times to specify multiple files to exclude.
  #pod
  #pod =cut
  
  has exclude_filename => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  #pod =attr exclude_match
  #pod
  #pod This is just like C<exclude_filename> but provides a regular expression
  #pod pattern.  Filenames matching the pattern (relative to C<root>)  are not
  #pod gathered.  This may be used
  #pod multiple times to specify multiple patterns to exclude.
  #pod
  #pod =cut
  
  has exclude_match => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  #pod =attr prune_directory
  #pod
  #pod While traversing, any directory matching the regular expression pattern will
  #pod not be traversed further. This may be used multiple times to specify multiple
  #pod directories to skip.
  #pod
  #pod =cut
  
  has prune_directory => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  around dump_config => sub {
    my $orig = shift;
    my $self = shift;
  
    my $config = $self->$orig;
  
    $config->{+__PACKAGE__} = {
      prefix => $self->prefix,
      # only report relative to dist root to avoid leaking private info
      root => path($self->root)->relative($self->zilla->root),
      (map { $_ => $self->$_ ? 1 : 0 } qw(include_dotfiles follow_symlinks)),
      (map { $_ => [ sort @{ $self->$_ } ] } qw(exclude_filename exclude_match prune_directory)),
    };
  
    return $config;
  };
  
  sub gather_files {
    my ($self) = @_;
  
    my $exclude_regex = qr/\000/;
    $exclude_regex = qr/(?:$exclude_regex)|$_/
      for @{ $self->exclude_match };
  
    my $repo_root = $self->zilla->root;
    my $root = "" . $self->root;
    $root =~ s{^~([\\/])}{require File::HomeDir; File::HomeDir::->my_home . $1}e;
    $root = path($root)->absolute($repo_root)->stringify if path($root)->is_relative;
  
    my $prune_regex = qr/\000/;
    $prune_regex = qr/$prune_regex|$_/
      for ( @{ $self->prune_directory },
        $self->include_dotfiles ? () : ( qr/^\.[^.]/ ) );
  
    # build up the rules
    my $rule = File::Find::Rule->new();
    $rule->extras({ follow => $self->follow_symlinks });
  
    $rule->exec(sub { $self->log_debug('considering ' . path($_[-1])->relative($repo_root)); 1 })
      if $self->zilla->logger->get_debug;
  
    $rule->or(
      $rule->new->directory->exec(sub { /$prune_regex/ })->prune->discard,
      $rule->new,
    );
  
    if ($self->follow_symlinks) {
      $rule->or(
        $rule->new->file,     # symlinks to files still count as files
        $rule->new->symlink,  # traverse into the linked dir, but screen it out later
      );
    } else {
      $rule->file;
    }
  
    $rule->not_exec(sub { /^\.[^.]/ }) unless $self->include_dotfiles;   # exec passes basename as $_
    $rule->exec(sub {
      my $relative = path($_[-1])->relative($root);
      $relative !~ $exclude_regex &&
        all { $relative ne $_ } @{ $self->exclude_filename }
    });
  
    FILE: for my $filename ($rule->in($root)) {
      next if -d $filename;
  
      # _file_from_filename is overloaded in GatherDir::Template
      my $fileobj = $self->_file_from_filename($filename);
  
      # GatherDir::Template may rename the file
      $filename = $fileobj->name;
      my $file = path($filename)->relative($root);
      $file = path($self->prefix, $file) if $self->prefix;
  
      $fileobj->name($file->stringify);
      $self->add_file($fileobj);
    }
  
    return;
  }
  
  sub _file_from_filename {
    my ($self, $filename) = @_;
  
    my @stat = stat $filename or $self->log_fatal("$filename does not exist!");
  
    return Dist::Zilla::File::OnDisk->new({
      name => $filename,
      mode => $stat[2] & 0755, # kill world-writeability
    });
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::GatherDir - gather all the files in a directory
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is a very, very simple L<FileGatherer|Dist::Zilla::Role::FileGatherer>
  plugin.  It looks in the directory named in the L</root> attribute and adds all
  the files it finds there.  If the root begins with a tilde, the tilde is
  replaced with the current user's home directory according to L<File::HomeDir>.
  
  Almost every dist will be built with one GatherDir plugin, since it's the
  easiest way to get files from disk into your dist.  Most users just need:
  
    [GatherDir]
    [PruneCruft]
  
  ...and this will pick up all the files from the current directory into the
  dist.  (L<PruneCruft|Dist::Zilla::Plugin::PruneCruft> is needed, here, to drop
  files that might present as build artifacts, but should not be shipped.)  You
  can use it multiple times, as you can any other plugin, by providing a plugin
  name.  For example, if you want to include external specification files into a
  subdir of your dist, you might write:
  
    [GatherDir]
    ; this plugin needs no config and gathers most of your files
  
    [GatherDir / SpecFiles]
    ; this plugin gets all the files in the root dir and adds them under ./spec
    root   = ~/projects/my-project/spec
    prefix = spec
  
  =head1 ATTRIBUTES
  
  =head2 root
  
  This is the directory in which to look for files.  If not given, it defaults to
  the dist root -- generally, the place where your F<dist.ini> or other
  configuration file is located.
  
  =head2 prefix
  
  This parameter can be set to place the gathered files under a particular
  directory.  See the L<description|DESCRIPTION> above for an example.
  
  =head2 include_dotfiles
  
  By default, files will not be included if they begin with a dot.  This goes
  both for files and for directories relative to the C<root>.
  
  In almost all cases, the default value (false) is correct.
  
  =head2 follow_symlinks
  
  By default, symlinks pointing to directories will not be followed; set
  C<< follow_symlinks = 1 >> to traverse these links as if they were normal
  directories.
  
  In all followed directories, files which are symlinks are B<always> gathered,
  with the link turning into a normal file.
  
  =head2 exclude_filename
  
  To exclude certain files from being gathered, use the C<exclude_filename>
  option.  The filename is matched exactly, relative to C<root>.
  This may be used multiple times to specify multiple files to exclude.
  
  =head2 exclude_match
  
  This is just like C<exclude_filename> but provides a regular expression
  pattern.  Filenames matching the pattern (relative to C<root>)  are not
  gathered.  This may be used
  multiple times to specify multiple patterns to exclude.
  
  =head2 prune_directory
  
  While traversing, any directory matching the regular expression pattern will
  not be traversed further. This may be used multiple times to specify multiple
  directories to skip.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_GATHERDIR

$fatpacked{"Dist/Zilla/Plugin/GatherDir/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_GATHERDIR_TEMPLATE';
  package Dist::Zilla::Plugin::GatherDir::Template 6.007;
  # ABSTRACT: gather all the files in a directory and use them as templates
  
  use Moose;
  extends 'Dist::Zilla::Plugin::GatherDir';
  with 'Dist::Zilla::Role::TextTemplate';
  
  use namespace::autoclean;
  
  use autodie;
  use Dist::Zilla::File::FromCode;
  use Dist::Zilla::Path;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This is a subclass of the L<GatherDir|Dist::Zilla::Plugin::GatherDir>
  #pod plugin.  It works just like its parent class, except that each
  #pod gathered file is processed through L<Text::Template>.
  #pod
  #pod The variables C<$plugin> and C<$dist> will be provided to the
  #pod template, set to the GatherDir::Template plugin and the Dist::Zilla
  #pod object, respectively.
  #pod
  #pod It is meant to be used when minting dists with C<dzil new>, but could be used
  #pod in building existing dists, too.
  #pod
  #pod =head1 ATTRIBUTES
  #pod
  #pod =head2 rename
  #pod
  #pod Use this to rename files while they are being gathered.  This is a list of
  #pod key/value pairs, specified thus:
  #pod
  #pod     [GatherDir::Template]
  #pod     rename.DISTNAME = $dist->name =~ s/...//r
  #pod     rename.DISTVER  = $dist->version
  #pod
  #pod This example will replace the tokens C<DISTNAME> and C<DISTVER> with the
  #pod expressions they are associated with. These expressions will be treated as
  #pod though they were miniature Text::Template sections, and hence will receive the
  #pod same variables that the file itself receives, i.e. C<$dist> and C<$plugin>.
  #pod
  #pod =cut
  
  has _rename => (
    is => 'ro',
    isa => 'HashRef',
    default => sub { +{} },
  );
  
  around BUILDARGS => sub {
    my $orig = shift;
    my ($class, @arg) = @_;
  
    my $args = $class->$orig(@arg);
    my %retargs = %$args;
  
    for my $rename (grep /^rename/, keys %retargs) {
      my $expr = delete $retargs{$rename};
      $rename =~ s/^rename\.//;
      $retargs{_rename}->{$rename} = $expr;
    }
  
    return \%retargs;
  };
  
  sub _file_from_filename {
    my ($self, $filename) = @_;
  
    my $template = path($filename)->slurp_utf8;
  
    my @stat = stat $filename or $self->log_fatal("$filename does not exist!");
  
    my $new_filename = $filename;
  
    for my $token (keys %{$self->_rename}) {
      my $expr = $self->_rename->{$token};
      my $temp_temp = "{{ $expr }}";
      my $replacement = $self->fill_in_string(
        $temp_temp,
        {
          dist   => \($self->zilla),
          plugin => \($self),
        },
      );
  
      $new_filename =~ s/\Q$token/$replacement/g;
    }
  
    return Dist::Zilla::File::FromCode->new({
      name => $new_filename,
      mode => ($stat[2] & 0755) | 0200, # kill world-writeability, make sure owner-writable.
      code => sub {
        my ($file_obj) = @_;
        $self->fill_in_string(
          $template,
          {
            dist   => \($self->zilla),
            plugin => \($self),
          },
        );
      },
    });
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::GatherDir::Template - gather all the files in a directory and use them as templates
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is a subclass of the L<GatherDir|Dist::Zilla::Plugin::GatherDir>
  plugin.  It works just like its parent class, except that each
  gathered file is processed through L<Text::Template>.
  
  The variables C<$plugin> and C<$dist> will be provided to the
  template, set to the GatherDir::Template plugin and the Dist::Zilla
  object, respectively.
  
  It is meant to be used when minting dists with C<dzil new>, but could be used
  in building existing dists, too.
  
  =head1 ATTRIBUTES
  
  =head2 rename
  
  Use this to rename files while they are being gathered.  This is a list of
  key/value pairs, specified thus:
  
      [GatherDir::Template]
      rename.DISTNAME = $dist->name =~ s/...//r
      rename.DISTVER  = $dist->version
  
  This example will replace the tokens C<DISTNAME> and C<DISTVER> with the
  expressions they are associated with. These expressions will be treated as
  though they were miniature Text::Template sections, and hence will receive the
  same variables that the file itself receives, i.e. C<$dist> and C<$plugin>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_GATHERDIR_TEMPLATE

$fatpacked{"Dist/Zilla/Plugin/GenerateFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_GENERATEFILE';
  package Dist::Zilla::Plugin::GenerateFile 6.007;
  # ABSTRACT: build a custom file from only the plugin configuration
  
  use Moose;
  with (
    'Dist::Zilla::Role::FileGatherer',
    'Dist::Zilla::Role::TextTemplate',
  );
  
  use namespace::autoclean;
  
  use Dist::Zilla::File::InMemory;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [GenerateFile]
  #pod   filename    = todo/{{ $dist->name }}-master-plan.txt
  #pod   name_is_template = 1
  #pod   content_is_template = 1
  #pod   content = # Outlines the plan for world domination by {{$dist->name}}
  #pod   content =
  #pod   content = Item 1: Think of an idea!
  #pod   content = Item 2: ?
  #pod   content = Item 3: Profit!
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin adds a file to the distribution.
  #pod
  #pod You can specify the content, as a sequence of lines, in your configuration.
  #pod The specified filename and content might be literals or might be L<Text::Template>
  #pod templates.
  #pod
  #pod =head2 Templating of the content
  #pod
  #pod If you provide C<content_is_template> (or C<is_template>) parameter of C<"1">, the
  #pod content will be run through L<Text::Template>.  The variables C<$plugin> and
  #pod C<$dist> will be provided, set to the [GenerateFile] plugin and the L<Dist::Zilla>
  #pod object respectively.
  #pod
  #pod If you provide a C<name_is_template> parameter of "1", the filename will be run
  #pod through L<Text::Template>.  The variables C<$plugin> and C<$dist> will be
  #pod provided, set to the [GenerateFile] plugin and the L<Dist::Zilla> object
  #pod respectively.
  #pod
  #pod =cut
  
  sub mvp_aliases { +{ is_template => 'content_is_template' } }
  
  sub mvp_multivalue_args { qw(content) }
  
  #pod =attr filename
  #pod
  #pod This attribute names the file you want to generate.  It is required.
  #pod
  #pod =cut
  
  has filename => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  #pod =attr content
  #pod
  #pod The C<content> attribute is an arrayref of lines that will be joined together
  #pod with newlines to form the file content.
  #pod
  #pod =cut
  
  has content => (
    is  => 'ro',
    isa => 'ArrayRef',
  );
  
  #pod =attr content_is_template, is_template
  #pod
  #pod This attribute is a bool indicating whether or not the content should be
  #pod treated as a Text::Template template.  By default, it is false.
  #pod
  #pod =cut
  
  has content_is_template => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  #pod =cut
  #pod
  #pod =attr name_is_template
  #pod
  #pod This attribute is a bool indicating whether or not the filename should be
  #pod treated as a Text::Template template.  By default, it is false.
  #pod
  #pod =cut
  
  has name_is_template => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    my $file = Dist::Zilla::File::InMemory->new({
      name    => $self->_filename,
      content => $self->_content,
    });
  
    $self->add_file($file);
    return;
  }
  
  sub _content {
    my $self = shift;
  
    my $content = join "\n", @{ $self->content };
    $content .= qq{\n};
  
    if ($self->content_is_template) {
      $content = $self->fill_in_string(
        $content,
        {
          dist   => \($self->zilla),
          plugin => \($self),
        },
      );
    }
  
    return $content;
  }
  
  sub _filename {
    my $self = shift;
  
    my $filename = $self->filename;
  
    if ($self->name_is_template) {
      $filename = $self->fill_in_string(
        $filename,
        {
          dist   => \($self->zilla),
          plugin => \($self),
        },
      );
    }
  
    return $filename;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::GenerateFile - build a custom file from only the plugin configuration
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [GenerateFile]
    filename    = todo/{{ $dist->name }}-master-plan.txt
    name_is_template = 1
    content_is_template = 1
    content = # Outlines the plan for world domination by {{$dist->name}}
    content =
    content = Item 1: Think of an idea!
    content = Item 2: ?
    content = Item 3: Profit!
  
  =head1 DESCRIPTION
  
  This plugin adds a file to the distribution.
  
  You can specify the content, as a sequence of lines, in your configuration.
  The specified filename and content might be literals or might be L<Text::Template>
  templates.
  
  =head2 Templating of the content
  
  If you provide C<content_is_template> (or C<is_template>) parameter of C<"1">, the
  content will be run through L<Text::Template>.  The variables C<$plugin> and
  C<$dist> will be provided, set to the [GenerateFile] plugin and the L<Dist::Zilla>
  object respectively.
  
  If you provide a C<name_is_template> parameter of "1", the filename will be run
  through L<Text::Template>.  The variables C<$plugin> and C<$dist> will be
  provided, set to the [GenerateFile] plugin and the L<Dist::Zilla> object
  respectively.
  
  =head1 ATTRIBUTES
  
  =head2 filename
  
  This attribute names the file you want to generate.  It is required.
  
  =head2 content
  
  The C<content> attribute is an arrayref of lines that will be joined together
  with newlines to form the file content.
  
  =head2 content_is_template, is_template
  
  This attribute is a bool indicating whether or not the content should be
  treated as a Text::Template template.  By default, it is false.
  
  =head2 name_is_template
  
  This attribute is a bool indicating whether or not the filename should be
  treated as a Text::Template template.  By default, it is false.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_GENERATEFILE

$fatpacked{"Dist/Zilla/Plugin/InlineFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_INLINEFILES';
  package Dist::Zilla::Plugin::InlineFiles 6.007;
  # ABSTRACT: files in a data section
  
  use Moose;
  with 'Dist::Zilla::Role::FileGatherer';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin exists only to be extended, and gathers all files contained in its
  #pod data section and those of its ancestors.  For more information, see
  #pod L<Data::Section|Data::Section>.
  #pod
  #pod =cut
  
  use Sub::Exporter::ForMethods;
  use Data::Section 0.200002 # encoding and bytes
    { installer => Sub::Exporter::ForMethods::method_installer },
    '-setup' => { encoding => 'bytes' };
  use Dist::Zilla::File::InMemory;
  
  sub gather_files {
    my ($self) = @_;
  
    my $data = $self->merged_section_data;
    return unless $data and %$data;
  
    for my $name (keys %$data) {
      $self->add_file(
        Dist::Zilla::File::InMemory->new({
          name    => $name,
          content => ${ $data->{$name} },
        }),
      );
    }
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins inheriting from L<InlineFiles>:
  #pod L<MetaTests|Dist::Zilla::Plugin::MetaTests>,
  #pod L<PodCoverageTests|Dist::Zilla::Plugin::PodCoverageTests>,
  #pod L<PodSyntaxTests|Dist::Zilla::Plugin::PodSyntaxTests>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::InlineFiles - files in a data section
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin exists only to be extended, and gathers all files contained in its
  data section and those of its ancestors.  For more information, see
  L<Data::Section|Data::Section>.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins inheriting from L<InlineFiles>:
  L<MetaTests|Dist::Zilla::Plugin::MetaTests>,
  L<PodCoverageTests|Dist::Zilla::Plugin::PodCoverageTests>,
  L<PodSyntaxTests|Dist::Zilla::Plugin::PodSyntaxTests>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_INLINEFILES

$fatpacked{"Dist/Zilla/Plugin/License.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_LICENSE';
  package Dist::Zilla::Plugin::License 6.007;
  # ABSTRACT: output a LICENSE file
  
  use Moose;
  with 'Dist::Zilla::Role::FileGatherer';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin adds a F<LICENSE> file containing the full text of the
  #pod distribution's license, as produced by the C<fulltext> method of the
  #pod dist's L<Software::License> object.
  #pod
  #pod =attr filename
  #pod
  #pod This attribute can be used to specify a name other than F<LICENSE> to be used.
  #pod
  #pod =cut
  
  use Dist::Zilla::File::InMemory;
  
  has filename => (
    is  => 'ro',
    isa => 'Str',
    default => 'LICENSE',
  );
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    my $file = Dist::Zilla::File::InMemory->new({
      name    => $self->filename,
      content => $self->zilla->license->fulltext,
    });
  
    $self->add_file($file);
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over 4
  #pod
  #pod =item *
  #pod
  #pod the C<license> attribute of the L<Dist::Zilla> object to select the license
  #pod to use.
  #pod
  #pod =item *
  #pod
  #pod Dist::Zilla roles:
  #pod L<FileGatherer|Dist::Zilla::Role::FileGatherer>.
  #pod
  #pod =item *
  #pod
  #pod Other modules:
  #pod L<Software::License>,
  #pod L<Software::License::Artistic_2_0>.
  #pod
  #pod =back
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::License - output a LICENSE file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin adds a F<LICENSE> file containing the full text of the
  distribution's license, as produced by the C<fulltext> method of the
  dist's L<Software::License> object.
  
  =head1 ATTRIBUTES
  
  =head2 filename
  
  This attribute can be used to specify a name other than F<LICENSE> to be used.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  the C<license> attribute of the L<Dist::Zilla> object to select the license
  to use.
  
  =item *
  
  Dist::Zilla roles:
  L<FileGatherer|Dist::Zilla::Role::FileGatherer>.
  
  =item *
  
  Other modules:
  L<Software::License>,
  L<Software::License::Artistic_2_0>.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_LICENSE

$fatpacked{"Dist/Zilla/Plugin/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_MAKEMAKER';
  package Dist::Zilla::Plugin::MakeMaker 6.007;
  # ABSTRACT: build a Makefile.PL that uses ExtUtils::MakeMaker
  
  use Moose;
  
  use namespace::autoclean;
  
  use Config;
  use CPAN::Meta::Requirements 2.121; # requirements_for_module
  use List::Util 1.29 qw(first pairs pairgrep);
  use version;
  use Dist::Zilla::File::InMemory;
  use Dist::Zilla::Plugin::MakeMaker::Runner;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will produce an L<ExtUtils::MakeMaker>-powered F<Makefile.PL> for
  #pod the distribution.  If loaded, the L<Manifest|Dist::Zilla::Plugin::Manifest>
  #pod plugin should also be loaded.
  #pod
  #pod =cut
  
  #pod =attr eumm_version
  #pod
  #pod This option declares the version of ExtUtils::MakeMaker required to configure
  #pod and build the distribution.  There is no default, although one may be added if
  #pod it can be determined that the generated F<Makefile.PL> requires some specific
  #pod minimum.  I<No testing has been done on this front.>
  #pod
  #pod =cut
  
  has eumm_version => (
    isa => 'Str',
    is  => 'rw',
  );
  
  #pod =attr make_path
  #pod
  #pod This option sets the path to F<make>, used to build your dist and run tests.
  #pod It defaults to the value for C<make> in L<Config>, or to C<make> if that isn't
  #pod set.
  #pod
  #pod You probably won't need to set this option.
  #pod
  #pod =cut
  
  has 'make_path' => (
    isa => 'Str',
    is  => 'ro',
    default => $Config{make} || 'make',
  );
  
  #pod =attr static_attribution
  #pod
  #pod This option omits the version number in the "generated by"
  #pod comment in the Makefile.PL.  For setups that copy the Makefile.PL
  #pod back to the repo, this avoids churn just from upgrading Dist::Zilla.
  #pod
  #pod =cut
  
  has 'static_attribution' => (
    isa => 'Bool',
    is  => 'ro',
  );
  
  has '_runner' => (
    is   => 'ro',
    lazy => 1,
    handles => [qw(build test)],
    default => sub {
      my ($self) = @_;
      Dist::Zilla::Plugin::MakeMaker::Runner->new({
        zilla        => $self->zilla,
        plugin_name  => $self->plugin_name . '::Runner',
        make_path    => $self->make_path,
        default_jobs => $self->default_jobs,
      });
    },
  );
  
  # This is here, rather than at the top, so that the "build" and "test" methods
  # will exist, as they are required by BuildRunner and TestRunner respectively.
  # I had originally fixed this with stub methods, but stub methods do not behave
  # properly with this use case until Moose 2.0300. -- rjbs, 2012-02-08
  with qw(
    Dist::Zilla::Role::BuildRunner
    Dist::Zilla::Role::InstallTool
    Dist::Zilla::Role::PrereqSource
    Dist::Zilla::Role::FileGatherer
    Dist::Zilla::Role::TestRunner
    Dist::Zilla::Role::TextTemplate
  );
  
  my $template = q!# This file was automatically generated by {{ $generated_by }}.
  use strict;
  use warnings;
  
  {{ $perl_prereq ? qq[use $perl_prereq;] : ''; }}
  
  use ExtUtils::MakeMaker{{ defined $eumm_version && 0+$eumm_version ? ' ' . $eumm_version : '' }};
  {{ $share_dir_code{preamble} || '' }}
  my {{ $WriteMakefileArgs }}
  
  my {{ $fallback_prereqs }}
  
  unless ( eval { ExtUtils::MakeMaker->VERSION(6.63_03) } ) {
    delete $WriteMakefileArgs{TEST_REQUIRES};
    delete $WriteMakefileArgs{BUILD_REQUIRES};
    $WriteMakefileArgs{PREREQ_PM} = \%FallbackPrereqs;
  }
  
  delete $WriteMakefileArgs{CONFIGURE_REQUIRES}
    unless eval { ExtUtils::MakeMaker->VERSION(6.52) };
  
  WriteMakefile(%WriteMakefileArgs);
  {{ $share_dir_code{postamble} || '' }}!;
  
  sub register_prereqs {
    my ($self) = @_;
  
    $self->zilla->register_prereqs(
      { phase => 'configure' },
      'ExtUtils::MakeMaker' => $self->eumm_version || 0,
    );
  
    return unless keys %{ $self->zilla->_share_dir_map };
  
    $self->zilla->register_prereqs(
      { phase => 'configure' },
      'File::ShareDir::Install' => 0.06,
    );
  }
  
  sub gather_files {
    my ($self) = @_;
  
    require Dist::Zilla::File::InMemory;
  
    my $file = Dist::Zilla::File::InMemory->new({
      name    => 'Makefile.PL',
      content => $template,   # template evaluated later
    });
  
    $self->add_file($file);
    return;
  }
  
  sub share_dir_code {
    my ($self) = @_;
  
    my $share_dir_code = {};
  
    my $share_dir_map = $self->zilla->_share_dir_map;
    if ( keys %$share_dir_map ) {
      my $preamble = <<'PREAMBLE';
  use File::ShareDir::Install;
  $File::ShareDir::Install::INCLUDE_DOTFILES = 1;
  $File::ShareDir::Install::INCLUDE_DOTDIRS = 1;
  PREAMBLE
  
      if ( my $dist_share_dir = $share_dir_map->{dist} ) {
        $dist_share_dir = quotemeta $dist_share_dir;
        $preamble .= qq{install_share dist => "$dist_share_dir";\n};
      }
  
      if ( my $mod_map = $share_dir_map->{module} ) {
        for my $mod ( keys %$mod_map ) {
          my $mod_share_dir = quotemeta $mod_map->{$mod};
          $preamble .= qq{install_share module => "$mod", "$mod_share_dir";\n};
        }
      }
  
      $share_dir_code->{preamble} = "\n" . $preamble . "\n";
      $share_dir_code->{postamble}
        = qq{\n\{\npackage\nMY;\nuse File::ShareDir::Install qw(postamble);\n\}\n};
    }
  
    return $share_dir_code;
  }
  
  sub write_makefile_args {
    my ($self) = @_;
  
    my $name = $self->zilla->name =~ s/-/::/gr;
  
    my @exe_files = map { $_->name }
      @{ $self->zilla->find_files(':ExecFiles') };
  
    $self->log_fatal("can't install files with whitespace in their names")
      if grep { /\s/ } @exe_files;
  
    my %test_dirs;
    for my $file (@{ $self->zilla->files }) {
      next unless $file->name =~ m{\At/.+\.t\z};
      my $dir = $file->name =~ s{/[^/]+\.t\z}{/*.t}gr;
  
      $test_dirs{ $dir } = 1;
    }
  
    my $prereqs = $self->zilla->prereqs;
    my $perl_prereq = $prereqs->requirements_for(qw(runtime requires))
      ->clone
      ->add_requirements($prereqs->requirements_for(qw(configure requires)))
      ->add_requirements($prereqs->requirements_for(qw(build requires)))
      ->add_requirements($prereqs->requirements_for(qw(test requires)))
      ->as_string_hash->{perl};
  
    $perl_prereq = version->parse($perl_prereq)->numify if $perl_prereq;
  
    my $prereqs_dump = sub {
      $self->_normalize_eumm_versions(
        $prereqs->requirements_for(@_)
                ->clone
                ->clear_requirement('perl')
                ->as_string_hash
      );
    };
  
    my %require_prereqs = map {
      $_ => $prereqs_dump->($_, 'requires');
    } qw(configure build test runtime);
  
    # EUMM may soon be able to support this, but until we decide to inject a
    # higher configure-requires version, we should at least warn the user
    # https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker/issues/215
    foreach my $phase (qw(configure build test runtime)) {
      if (my @version_ranges = pairgrep { defined($b) && !version::is_lax($b) } %{ $require_prereqs{$phase} }
          and ($self->eumm_version || 0) < '7.1101') {
        $self->log_fatal([
          'found version range in %s prerequisites, which ExtUtils::MakeMaker cannot parse (must specify eumm_version of at least 7.1101): %s %s',
          $phase, $_->[0], $_->[1]
        ]) foreach pairs @version_ranges;
      }
    }
  
    my %write_makefile_args = (
      DISTNAME  => $self->zilla->name,
      NAME      => $name,
      AUTHOR    => join(q{, }, @{ $self->zilla->authors }),
      ABSTRACT  => $self->zilla->abstract,
      VERSION   => $self->zilla->version,
      LICENSE   => $self->zilla->license->meta_yml_name,
      @exe_files ? ( EXE_FILES => [ sort @exe_files ] ) : (),
  
      CONFIGURE_REQUIRES => $require_prereqs{configure},
      keys %{ $require_prereqs{build} } ? ( BUILD_REQUIRES => $require_prereqs{build} ) : (),
      keys %{ $require_prereqs{test} } ? ( TEST_REQUIRES => $require_prereqs{test} ) : (),
      PREREQ_PM          => $require_prereqs{runtime},
  
      test => { TESTS => join q{ }, sort keys %test_dirs },
    );
  
    $write_makefile_args{MIN_PERL_VERSION} = $perl_prereq if $perl_prereq;
  
    return \%write_makefile_args;
  }
  
  sub _normalize_eumm_versions {
    my ($self, $prereqs) = @_;
    for my $v (values %$prereqs) {
      if (version::is_strict($v)) {
        my $version = version->parse($v);
        if ($version->is_qv) {
          if ((() = $v =~ /\./g) > 1) {
            $v =~ s/^v//;
          }
          else {
            $v = $version->numify;
          }
        }
      }
    }
    return $prereqs;
  }
  
  sub _dump_as {
    my ($self, $ref, $name) = @_;
    require Data::Dumper;
    my $dumper = Data::Dumper->new( [ $ref ], [ $name ] );
    $dumper->Sortkeys( 1 );
    $dumper->Indent( 1 );
    $dumper->Useqq( 1 );
    return $dumper->Dump;
  }
  
  sub fallback_prereq_pm {
    my $self = shift;
    my $fallback
      = $self->_normalize_eumm_versions(
        $self->zilla->prereqs->merged_requires
        ->clone
        ->clear_requirement('perl')
        ->as_string_hash
      );
    return $self->_dump_as( $fallback, '*FallbackPrereqs' );
  }
  
  sub setup_installer {
    my ($self) = @_;
  
    my $write_makefile_args = $self->write_makefile_args;
  
    $self->__write_makefile_args($write_makefile_args); # save for testing
  
    my $perl_prereq = $write_makefile_args->{MIN_PERL_VERSION};
  
    my $dumped_args = $self->_dump_as($write_makefile_args, '*WriteMakefileArgs');
  
    my $file = first { $_->name eq 'Makefile.PL' } @{$self->zilla->files};
  
    $self->log_debug([ 'updating contents of Makefile.PL in memory' ]);
  
    my $attribution = $self->static_attribution
      ? ref($self)
      : sprintf("%s v%s", ref($self), $self->VERSION || '(dev)');
  
    my $content = $self->fill_in_string(
      $file->content,
      {
        eumm_version      => \($self->eumm_version),
        perl_prereq       => \$perl_prereq,
        share_dir_code    => $self->share_dir_code,
        fallback_prereqs  => \($self->fallback_prereq_pm),
        WriteMakefileArgs => \$dumped_args,
        generated_by      => \$attribution,
      },
    );
  
    $file->content($content);
  
    return;
  }
  
  # XXX:  Just here to facilitate testing. -- rjbs, 2010-03-20
  has __write_makefile_args => (
    is   => 'rw',
    isa  => 'HashRef',
  );
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<ModuleBuild|Dist::Zilla::Plugin::ModuleBuild>,
  #pod L<Manifest|Dist::Zilla::Plugin::Manifest>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<BuildRunner|Dist::Zilla::Role::FileGatherer>,
  #pod L<InstallTool|Dist::Zilla::Role::InstallTool>,
  #pod L<PrereqSource|Dist::Zilla::Role::PrereqSource>,
  #pod L<TestRunner|Dist::Zilla::Role::TestRunner>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MakeMaker - build a Makefile.PL that uses ExtUtils::MakeMaker
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin will produce an L<ExtUtils::MakeMaker>-powered F<Makefile.PL> for
  the distribution.  If loaded, the L<Manifest|Dist::Zilla::Plugin::Manifest>
  plugin should also be loaded.
  
  =head1 ATTRIBUTES
  
  =head2 eumm_version
  
  This option declares the version of ExtUtils::MakeMaker required to configure
  and build the distribution.  There is no default, although one may be added if
  it can be determined that the generated F<Makefile.PL> requires some specific
  minimum.  I<No testing has been done on this front.>
  
  =head2 make_path
  
  This option sets the path to F<make>, used to build your dist and run tests.
  It defaults to the value for C<make> in L<Config>, or to C<make> if that isn't
  set.
  
  You probably won't need to set this option.
  
  =head2 static_attribution
  
  This option omits the version number in the "generated by"
  comment in the Makefile.PL.  For setups that copy the Makefile.PL
  back to the repo, this avoids churn just from upgrading Dist::Zilla.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<ModuleBuild|Dist::Zilla::Plugin::ModuleBuild>,
  L<Manifest|Dist::Zilla::Plugin::Manifest>.
  
  Dist::Zilla roles:
  L<BuildRunner|Dist::Zilla::Role::FileGatherer>,
  L<InstallTool|Dist::Zilla::Role::InstallTool>,
  L<PrereqSource|Dist::Zilla::Role::PrereqSource>,
  L<TestRunner|Dist::Zilla::Role::TestRunner>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_MAKEMAKER

$fatpacked{"Dist/Zilla/Plugin/MakeMaker/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_MAKEMAKER_RUNNER';
  package Dist::Zilla::Plugin::MakeMaker::Runner 6.007;
  # ABSTRACT: Test and build dists with a Makefile.PL
  
  use Moose;
  with(
    'Dist::Zilla::Role::BuildRunner',
    'Dist::Zilla::Role::TestRunner',
  );
  
  use namespace::autoclean;
  
  use Config;
  
  has 'make_path' => (
    isa => 'Str',
    is  => 'ro',
    default => $Config{make} || 'make',
  );
  
  sub build {
    my $self = shift;
  
    my $make = $self->make_path;
  
    my $makefile = $^O eq 'VMS' ? 'Descrip.MMS' : 'Makefile';
  
    return
      if -e $makefile and (stat 'Makefile.PL')[9] <= (stat $makefile)[9];
  
    $self->log_debug("running $^X Makefile.PL");
    system($^X => qw(Makefile.PL INSTALLMAN1DIR=none INSTALLMAN3DIR=none)) and die "error with Makefile.PL\n";
  
    $self->log_debug("running $make");
    system($make) and die "error running $make\n";
  
    return;
  }
  
  sub test {
    my ($self, $target, $arg) = @_;
  
    my $make = $self->make_path;
    $self->build;
  
    my $job_count = $arg && exists $arg->{jobs}
                  ? $arg->{jobs}
                  : $self->default_jobs;
  
    my $jobs = "j$job_count";
    my $ho = "HARNESS_OPTIONS";
    local $ENV{$ho} = $ENV{$ho} ? "$ENV{$ho}:$jobs" : $jobs;
  
    $self->log_debug(join(' ', "running $make test", ( $self->zilla->logger->get_debug ? 'TEST_VERBOSE=1' : () )));
    system($make, 'test',
      ( $self->zilla->logger->get_debug || $arg->{test_verbose} ? 'TEST_VERBOSE=1' : () ),
    ) and die "error running $make test\n";
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MakeMaker::Runner - Test and build dists with a Makefile.PL
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_MAKEMAKER_RUNNER

$fatpacked{"Dist/Zilla/Plugin/Manifest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_MANIFEST';
  package Dist::Zilla::Plugin::Manifest 6.007;
  # ABSTRACT: build a MANIFEST file
  
  use Moose;
  with 'Dist::Zilla::Role::FileGatherer';
  
  use namespace::autoclean;
  
  use Dist::Zilla::File::FromCode;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod If included, this plugin will produce a F<MANIFEST> file for the distribution,
  #pod listing all of the files it contains.  For obvious reasons, it should be
  #pod included as close to last as possible.
  #pod
  #pod This plugin is included in the L<@Basic|Dist::Zilla::PluginBundle::Basic>
  #pod bundle.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla core plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Manifest>,
  #pod L<ManifestSkip|Dist::Zilla::Plugin::ManifestSkip>.
  #pod
  #pod Other modules: L<ExtUtils::Manifest>.
  #pod
  #pod =cut
  
  sub __fix_filename {
    my ($name) = @_;
    return $name unless $name =~ /[ '\\]/;
    $name =~ s/\\/\\\\/g;
    $name =~ s/'/\\'/g;
    return qq{'$name'};
  }
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    my $zilla = $self->zilla;
  
    my $file = Dist::Zilla::File::FromCode->new({
      name => 'MANIFEST',
      code_return_type => 'bytes',
      code => sub {
        my $generated_by = sprintf "%s v%s", ref($self), $self->VERSION || '(dev)';
  
        return "# This file was automatically generated by $generated_by.\n"
             . join("\n", map { __fix_filename($_) } sort map { $_->name } @{ $zilla->files })
             . "\n",
      },
    });
  
    $self->add_file($file);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::Manifest - build a MANIFEST file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  If included, this plugin will produce a F<MANIFEST> file for the distribution,
  listing all of the files it contains.  For obvious reasons, it should be
  included as close to last as possible.
  
  This plugin is included in the L<@Basic|Dist::Zilla::PluginBundle::Basic>
  bundle.
  
  =head1 SEE ALSO
  
  Dist::Zilla core plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Manifest>,
  L<ManifestSkip|Dist::Zilla::Plugin::ManifestSkip>.
  
  Other modules: L<ExtUtils::Manifest>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_MANIFEST

$fatpacked{"Dist/Zilla/Plugin/ManifestSkip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_MANIFESTSKIP';
  package Dist::Zilla::Plugin::ManifestSkip 6.007;
  # ABSTRACT: decline to build files that appear in a MANIFEST.SKIP-like file
  
  use Moose;
  with 'Dist::Zilla::Role::FilePruner';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin reads a MANIFEST.SKIP-like file, as used by L<ExtUtils::MakeMaker>
  #pod and L<ExtUtils::Manifest>, and prunes any files that it declares should be
  #pod skipped.
  #pod
  #pod This plugin is included in the L<@Basic|Dist::Zilla::PluginBundle::Basic>
  #pod bundle.
  #pod
  #pod =attr skipfile
  #pod
  #pod This is the name of the file to read for MANIFEST.SKIP-like content.  It
  #pod defaults, unsurprisingly, to F<MANIFEST.SKIP>.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla core plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<PruneCruft|Dist::Zilla::Plugin::PruneCruft>,
  #pod L<PruneFiles|Dist::Zilla::Plugin::PruneFiles>.
  #pod
  #pod Other modules: L<ExtUtils::Manifest>.
  #pod
  #pod =cut
  
  has skipfile => (is => 'ro', required => 1, default => 'MANIFEST.SKIP');
  
  sub prune_files {
    my ($self) = @_;
    my $files = $self->zilla->files;
  
    my $skipfile_name = $self->skipfile;
    my ($skipfile) = grep { $_->name eq $skipfile_name } @$files;
    unless (defined $skipfile) {
      $self->log_debug([ 'file %s not found', $skipfile_name ]);
      return;
    }
  
    my $content = $skipfile->content;
  
    # If the content has been generated in memory or changed from disk,
    # create a temp file with the content.
    # (Unfortunately maniskip can't read from a string ref)
    my $fh;
    if (! -f $skipfile_name || (-s $skipfile_name) != length($content)) {
      $fh = File::Temp->new;
      $skipfile_name = $fh->filename;
      $self->log_debug([ 'create temporary %s', $skipfile_name ]);
      print $fh $content;
      close $fh;
    }
  
    require ExtUtils::Manifest;
    ExtUtils::Manifest->VERSION('1.54');
  
    my $skip = ExtUtils::Manifest::maniskip($skipfile_name);
  
    # Copy list (break reference) so we can mutate.
    for my $file ((), @{ $files }) {
      next unless $skip->($file->name);
  
      $self->log_debug([ 'pruning %s', $file->name ]);
  
      $self->zilla->prune_file($file);
    }
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ManifestSkip - decline to build files that appear in a MANIFEST.SKIP-like file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin reads a MANIFEST.SKIP-like file, as used by L<ExtUtils::MakeMaker>
  and L<ExtUtils::Manifest>, and prunes any files that it declares should be
  skipped.
  
  This plugin is included in the L<@Basic|Dist::Zilla::PluginBundle::Basic>
  bundle.
  
  =head1 ATTRIBUTES
  
  =head2 skipfile
  
  This is the name of the file to read for MANIFEST.SKIP-like content.  It
  defaults, unsurprisingly, to F<MANIFEST.SKIP>.
  
  =head1 SEE ALSO
  
  Dist::Zilla core plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<PruneCruft|Dist::Zilla::Plugin::PruneCruft>,
  L<PruneFiles|Dist::Zilla::Plugin::PruneFiles>.
  
  Other modules: L<ExtUtils::Manifest>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_MANIFESTSKIP

$fatpacked{"Dist/Zilla/Plugin/MetaConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_METACONFIG';
  package Dist::Zilla::Plugin::MetaConfig 6.007;
  # ABSTRACT: summarize Dist::Zilla configuration into distmeta
  
  use Moose;
  with 'Dist::Zilla::Role::MetaProvider';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin adds a top-level C<x_Dist_Zilla> key to the
  #pod L<distmeta|Dist::Zilla/distmeta> for the distribution.  It describe the
  #pod Dist::Zilla version used as well as all the plugins used.  Each plugin's name,
  #pod package, and version will be included.  Plugins may augment their
  #pod implementation of the L<Dist::Zilla::Role::ConfigDumper> role methods to add
  #pod more data to this dump.
  #pod
  #pod More information may be added to the top-level of this metadata as time goes
  #pod on.
  #pod
  #pod =cut
  
  sub metadata {
    my ($self) = @_;
  
    my $dump = { };
  
    my @plugins;
    $dump->{plugins} = \@plugins;
  
    my $config = $self->zilla->dump_config;
    $dump->{zilla} = {
      class   => $self->zilla->meta->name,
      version => $self->zilla->VERSION,
        (keys %$config ? (config => $config) : ()),
    };
  
    $dump->{perl} = {
      version => $],
    };
  
    for my $plugin (@{ $self->zilla->plugins }) {
      my $config = $plugin->dump_config;
  
      push @plugins, {
        class   => $plugin->meta->name,
        name    => $plugin->plugin_name,
        version => $plugin->VERSION,
        (keys %$config ? (config => $config) : ()),
      };
    }
  
    return { x_Dist_Zilla => $dump };
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla roles: L<MetaProvider|Dist::Zilla::Role::MetaProvider>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MetaConfig - summarize Dist::Zilla configuration into distmeta
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin adds a top-level C<x_Dist_Zilla> key to the
  L<distmeta|Dist::Zilla/distmeta> for the distribution.  It describe the
  Dist::Zilla version used as well as all the plugins used.  Each plugin's name,
  package, and version will be included.  Plugins may augment their
  implementation of the L<Dist::Zilla::Role::ConfigDumper> role methods to add
  more data to this dump.
  
  More information may be added to the top-level of this metadata as time goes
  on.
  
  =head1 SEE ALSO
  
  Dist::Zilla roles: L<MetaProvider|Dist::Zilla::Role::MetaProvider>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_METACONFIG

$fatpacked{"Dist/Zilla/Plugin/MetaJSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_METAJSON';
  package Dist::Zilla::Plugin::MetaJSON 6.007;
  # ABSTRACT: produce a META.json
  
  use Moose;
  with 'Dist::Zilla::Role::FileGatherer';
  use Moose::Util::TypeConstraints;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will add a F<META.json> file to the distribution.
  #pod
  #pod This file is meant to replace the old-style F<META.yml>.  For more information
  #pod on this file, see L<Module::Build::API> and L<CPAN::Meta>.
  #pod
  #pod =attr filename
  #pod
  #pod If given, parameter allows you to specify an alternate name for the generated
  #pod file.  It defaults, of course, to F<META.json>.
  #pod
  #pod =cut
  
  has filename => (
    is  => 'ro',
    isa => 'Str',
    default => 'META.json',
  );
  
  #pod =attr version
  #pod
  #pod This parameter lets you pick what version of the spec to use when generating
  #pod the output.  It defaults to 2 at present, but may be updated to new specs as
  #pod they are released and adopted.
  #pod
  #pod If you want a fixed version, specify it.
  #pod
  #pod =cut
  
  my $version_type = subtype(
      as 'Num',
      where { $_ >= 2 },
      message { "MetaJSON version must be 2 or greater" },
  );
  
  has version => (
    is  => 'ro',
    isa => $version_type,
    default => '2',
  );
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    my $zilla = $self->zilla;
  
    require JSON::MaybeXS;
    require Dist::Zilla::File::FromCode;
    require CPAN::Meta::Converter;
    CPAN::Meta::Converter->VERSION(2.101550); # improved downconversion
    require CPAN::Meta::Validator;
    CPAN::Meta::Validator->VERSION(2.101550); # improved downconversion
  
    my $file  = Dist::Zilla::File::FromCode->new({
      name => $self->filename,
      encoding => 'ascii',
      code_return_type => 'text',
      code => sub {
        my $distmeta  = $zilla->distmeta;
  
        my $validator = CPAN::Meta::Validator->new($distmeta);
  
        unless ($validator->is_valid) {
          my $msg = "Invalid META structure.  Errors found:\n";
          $msg .= join( "\n", $validator->errors );
          $self->log_fatal($msg);
        }
  
        my $converter = CPAN::Meta::Converter->new($distmeta);
        my $output    = $converter->convert(version => $self->version);
  
        my $backend = JSON::MaybeXS::JSON();
        $output->{x_serialization_backend} = sprintf '%s version %s',
              $backend, $backend->VERSION;
  
        JSON::MaybeXS->new(canonical => 1, pretty => 1, ascii => 1)->encode($output)
        . "\n";
      },
    });
  
    $self->add_file($file);
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<Manifest|Dist::Zilla::Plugin::Manifest>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<FileGatherer|Dist::Zilla::Role::FileGatherer>.
  #pod
  #pod Other modules:
  #pod L<CPAN::Meta>,
  #pod L<CPAN::Meta::Spec>, L<JSON::MaybeXS>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MetaJSON - produce a META.json
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin will add a F<META.json> file to the distribution.
  
  This file is meant to replace the old-style F<META.yml>.  For more information
  on this file, see L<Module::Build::API> and L<CPAN::Meta>.
  
  =head1 ATTRIBUTES
  
  =head2 filename
  
  If given, parameter allows you to specify an alternate name for the generated
  file.  It defaults, of course, to F<META.json>.
  
  =head2 version
  
  This parameter lets you pick what version of the spec to use when generating
  the output.  It defaults to 2 at present, but may be updated to new specs as
  they are released and adopted.
  
  If you want a fixed version, specify it.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<Manifest|Dist::Zilla::Plugin::Manifest>.
  
  Dist::Zilla roles:
  L<FileGatherer|Dist::Zilla::Role::FileGatherer>.
  
  Other modules:
  L<CPAN::Meta>,
  L<CPAN::Meta::Spec>, L<JSON::MaybeXS>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_METAJSON

$fatpacked{"Dist/Zilla/Plugin/MetaNoIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_METANOINDEX';
  package Dist::Zilla::Plugin::MetaNoIndex 6.007;
  # ABSTRACT: Stop CPAN from indexing stuff
  
  use Moose;
  with 'Dist::Zilla::Role::MetaProvider';
  
  use namespace::autoclean;
  
  #pod =encoding utf8
  #pod
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [MetaNoIndex]
  #pod
  #pod   directory = t/author
  #pod   directory = examples
  #pod
  #pod   file = lib/Foo.pm
  #pod
  #pod   package = My::Module
  #pod
  #pod   namespace = My::Module
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin allows you to prevent PAUSE/CPAN from indexing files you don't
  #pod want indexed. This is useful if you build test classes or example classes
  #pod that are used for those purposes only, and are not part of the distribution.
  #pod It does this by adding a C<no_index> block to your F<META.json> (or
  #pod F<META.yml>) file in your distribution.
  #pod
  #pod =for Pod::Coverage mvp_aliases mvp_multivalue_args
  #pod
  #pod =cut
  
  my %ATTR_ALIAS = (
    directories => [ qw(directory dir folder) ],
    files       => [ qw(file) ],
    packages    => [ qw(package class module) ],
    namespaces  => [ qw(namespace) ],
  );
  
  sub mvp_aliases {
    my %alias_for;
  
    for my $key (keys %ATTR_ALIAS) {
      $alias_for{ $_ } = $key for @{ $ATTR_ALIAS{$key} };
    }
  
    return \%alias_for;
  }
  
  sub mvp_multivalue_args { return keys %ATTR_ALIAS }
  
  #pod =attr directories
  #pod
  #pod Exclude folders and everything in them, for example: F<author.t>
  #pod
  #pod Aliases: C<folder>, C<dir>, C<directory>
  #pod
  #pod =attr files
  #pod
  #pod Exclude a specific file, for example: F<lib/Foo.pm>
  #pod
  #pod Alias: C<file>
  #pod
  #pod =attr packages
  #pod
  #pod Exclude by package name, for example: C<My::Package>
  #pod
  #pod Aliases: C<class>, C<module>, C<package>
  #pod
  #pod =attr namespaces
  #pod
  #pod Exclude everything under a specific namespace, for example: C<My::Package>
  #pod
  #pod Alias: C<namespace>
  #pod
  #pod B<NOTE:> This will not exclude the package C<My::Package>, only everything
  #pod under it like C<My::Package::Foo>.
  #pod
  #pod =cut
  
  for my $attr (keys %ATTR_ALIAS) {
    has $attr => (
      is        => 'ro',
      isa       => 'ArrayRef[Str]',
      init_arg  => $attr,
      predicate => "_has_$attr",
    );
  }
  
  #pod =method metadata
  #pod
  #pod Returns a reference to a hash containing the distribution's no_index metadata.
  #pod
  #pod =cut
  
  sub metadata {
    my $self = shift;
    return {
      no_index => {
        map  {; my $reader = $_->[0];  ($_->[1] => [ sort @{ $self->$reader } ]) }
        grep {; my $pred   = "_has_$_->[0]"; $self->$pred }
        map  {; [ $_ => $ATTR_ALIAS{$_}[0] ] }
        keys %ATTR_ALIAS
      }
    };
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla roles: L<MetaProvider|Dist::Zilla::Role::MetaProvider>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MetaNoIndex - Stop CPAN from indexing stuff
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [MetaNoIndex]
  
    directory = t/author
    directory = examples
  
    file = lib/Foo.pm
  
    package = My::Module
  
    namespace = My::Module
  
  =head1 DESCRIPTION
  
  This plugin allows you to prevent PAUSE/CPAN from indexing files you don't
  want indexed. This is useful if you build test classes or example classes
  that are used for those purposes only, and are not part of the distribution.
  It does this by adding a C<no_index> block to your F<META.json> (or
  F<META.yml>) file in your distribution.
  
  =head1 ATTRIBUTES
  
  =head2 directories
  
  Exclude folders and everything in them, for example: F<author.t>
  
  Aliases: C<folder>, C<dir>, C<directory>
  
  =head2 files
  
  Exclude a specific file, for example: F<lib/Foo.pm>
  
  Alias: C<file>
  
  =head2 packages
  
  Exclude by package name, for example: C<My::Package>
  
  Aliases: C<class>, C<module>, C<package>
  
  =head2 namespaces
  
  Exclude everything under a specific namespace, for example: C<My::Package>
  
  Alias: C<namespace>
  
  B<NOTE:> This will not exclude the package C<My::Package>, only everything
  under it like C<My::Package::Foo>.
  
  =head1 METHODS
  
  =head2 metadata
  
  Returns a reference to a hash containing the distribution's no_index metadata.
  
  =for Pod::Coverage mvp_aliases mvp_multivalue_args
  
  =head1 SEE ALSO
  
  Dist::Zilla roles: L<MetaProvider|Dist::Zilla::Role::MetaProvider>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_METANOINDEX

$fatpacked{"Dist/Zilla/Plugin/MetaResources.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_METARESOURCES';
  package Dist::Zilla::Plugin::MetaResources 6.007;
  # ABSTRACT: provide arbitrary "resources" for distribution metadata
  
  use Moose;
  with 'Dist::Zilla::Role::MetaProvider';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin adds resources entries to the distribution's metadata.
  #pod
  #pod   [MetaResources]
  #pod   homepage          = http://example.com/~dude/project.asp
  #pod   bugtracker.web    = https://rt.cpan.org/Public/Dist/Display.html?Name=Project
  #pod   bugtracker.mailto = bug-Project@rt.cpan.org
  #pod   repository.url    = git://github.com/dude/project.git
  #pod   repository.web    = http://github.com/dude/project
  #pod   repository.type   = git
  #pod
  #pod =cut
  
  has resources => (
    is       => 'ro',
    isa      => 'HashRef',
    required => 1,
  );
  
  around BUILDARGS => sub {
    my $orig = shift;
    my ($class, @arg) = @_;
  
    my $args = $class->$orig(@arg);
    my %copy = %{ $args };
  
    my $zilla = delete $copy{zilla};
    my $name  = delete $copy{plugin_name};
  
    if (exists $copy{license} && ref($copy{license}) ne 'ARRAY') {
        $copy{license} = [ $copy{license} ];
    }
  
    if (exists $copy{bugtracker}) {
      my $tracker = delete $copy{bugtracker};
      $copy{bugtracker}{web} = $tracker;
    }
  
    if (exists $copy{repository}) {
      my $repo = delete $copy{repository};
      $copy{repository}{url} = $repo;
    }
  
    for my $multi (qw( bugtracker repository )) {
      for my $key (grep { /^\Q$multi\E\./ } keys %copy) {
        my $subkey = (split /\./, $key, 2)[1];
        $copy{$multi}{$subkey} = delete $copy{$key};
      }
    }
  
    return {
      zilla       => $zilla,
      plugin_name => $name,
      resources   => \%copy,
    };
  };
  
  sub metadata {
    my ($self) = @_;
  
    return { resources => $self->resources };
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla roles: L<MetaProvider|Dist::Zilla::Role::MetaProvider>.
  #pod
  #pod Dist::Zilla plugins on the CPAN: L<GithubMeta|Dist::Zilla::Plugin::GithubMeta>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MetaResources - provide arbitrary "resources" for distribution metadata
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin adds resources entries to the distribution's metadata.
  
    [MetaResources]
    homepage          = http://example.com/~dude/project.asp
    bugtracker.web    = https://rt.cpan.org/Public/Dist/Display.html?Name=Project
    bugtracker.mailto = bug-Project@rt.cpan.org
    repository.url    = git://github.com/dude/project.git
    repository.web    = http://github.com/dude/project
    repository.type   = git
  
  =head1 SEE ALSO
  
  Dist::Zilla roles: L<MetaProvider|Dist::Zilla::Role::MetaProvider>.
  
  Dist::Zilla plugins on the CPAN: L<GithubMeta|Dist::Zilla::Plugin::GithubMeta>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_METARESOURCES

$fatpacked{"Dist/Zilla/Plugin/MetaTests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_METATESTS';
  package Dist::Zilla::Plugin::MetaTests 6.007;
  # ABSTRACT: common extra tests for META.yml
  
  use Moose;
  extends 'Dist::Zilla::Plugin::InlineFiles';
  with 'Dist::Zilla::Role::PrereqSource';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
  #pod following files:
  #pod
  #pod   xt/release/meta-yaml.t - a standard Test::CPAN::Meta test
  #pod
  #pod L<Test::CPAN::Meta> will be added as a C<develop requires> dependency (which
  #pod can be installed via C<< dzil listdeps --author | cpanm >>).
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<MetaResources|Dist::Zilla::Plugin::MetaResources>,
  #pod L<MetaNoIndex|Dist::Zilla::Plugin::MetaNoIndex>,
  #pod L<MetaYAML|Dist::Zilla::Plugin::MetaYAML>,
  #pod L<MetaJSON|Dist::Zilla::Plugin::MetaJSON>,
  #pod L<MetaConfig|Dist::Zilla::Plugin::MetaConfig>.
  #pod
  #pod =cut
  
  # Register the release test prereq as a "develop requires"
  # so it will be listed in "dzil listdeps --author"
  sub register_prereqs {
    my ($self) = @_;
  
    $self->zilla->register_prereqs(
      {
        phase => 'develop', type  => 'requires',
      },
      'Test::CPAN::Meta'     => 0,
    );
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MetaTests - common extra tests for META.yml
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
  following files:
  
    xt/release/meta-yaml.t - a standard Test::CPAN::Meta test
  
  L<Test::CPAN::Meta> will be added as a C<develop requires> dependency (which
  can be installed via C<< dzil listdeps --author | cpanm >>).
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<MetaResources|Dist::Zilla::Plugin::MetaResources>,
  L<MetaNoIndex|Dist::Zilla::Plugin::MetaNoIndex>,
  L<MetaYAML|Dist::Zilla::Plugin::MetaYAML>,
  L<MetaJSON|Dist::Zilla::Plugin::MetaJSON>,
  L<MetaConfig|Dist::Zilla::Plugin::MetaConfig>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __DATA__
  ___[ xt/release/distmeta.t ]___
  #!perl
  # This file was automatically generated by Dist::Zilla::Plugin::MetaTests.
  
  use Test::CPAN::Meta;
  
  meta_yaml_ok();
DIST_ZILLA_PLUGIN_METATESTS

$fatpacked{"Dist/Zilla/Plugin/MetaYAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_METAYAML';
  package Dist::Zilla::Plugin::MetaYAML 6.007;
  # ABSTRACT: produce a META.yml
  
  use Moose;
  with 'Dist::Zilla::Role::FileGatherer';
  
  use Try::Tiny;
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will add a F<META.yml> file to the distribution.
  #pod
  #pod For more information on this file, see L<Module::Build::API> and L<CPAN::Meta>.
  #pod
  #pod =attr filename
  #pod
  #pod If given, parameter allows you to specify an alternate name for the generated
  #pod file.  It defaults, of course, to F<META.yml>.
  #pod
  #pod =cut
  
  has filename => (
    is  => 'ro',
    isa => 'Str',
    default => 'META.yml',
  );
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    require Dist::Zilla::File::FromCode;
    require YAML::Tiny;
    require CPAN::Meta::Converter;
    CPAN::Meta::Converter->VERSION(2.101550); # improved downconversion
    require CPAN::Meta::Validator;
    CPAN::Meta::Validator->VERSION(2.101550); # improved downconversion
  
    my $zilla = $self->zilla;
  
    my $file  = Dist::Zilla::File::FromCode->new({
      name => $self->filename,
      code_return_type => 'text',
      code => sub {
        my $distmeta  = $zilla->distmeta;
  
        my $validator = CPAN::Meta::Validator->new($distmeta);
  
        unless ($validator->is_valid) {
          my $msg = "Invalid META structure.  Errors found:\n";
          $msg .= join( "\n", $validator->errors );
          $self->log_fatal($msg);
        }
  
        my $converter = CPAN::Meta::Converter->new($distmeta);
        my $output    = $converter->convert(version => '1.4');
        $output->{x_serialization_backend} = sprintf '%s version %s',
              'YAML::Tiny', YAML::Tiny->VERSION;
  
        my $yaml = try {
          YAML::Tiny->new($output)->write_string; # text!
        }
        catch {
          $self->log_fatal("Could not create YAML string: " . YAML::Tiny->errstr)
        };
        return $yaml;
      },
    });
  
    $self->add_file($file);
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<Manifest|Dist::Zilla::Plugin::Manifest>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<FileGatherer|Dist::Zilla::Role::FileGatherer>.
  #pod
  #pod Other modules:
  #pod L<CPAN::Meta>,
  #pod L<CPAN::Meta::Spec>, L<YAML>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::MetaYAML - produce a META.yml
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin will add a F<META.yml> file to the distribution.
  
  For more information on this file, see L<Module::Build::API> and L<CPAN::Meta>.
  
  =head1 ATTRIBUTES
  
  =head2 filename
  
  If given, parameter allows you to specify an alternate name for the generated
  file.  It defaults, of course, to F<META.yml>.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<Manifest|Dist::Zilla::Plugin::Manifest>.
  
  Dist::Zilla roles:
  L<FileGatherer|Dist::Zilla::Role::FileGatherer>.
  
  Other modules:
  L<CPAN::Meta>,
  L<CPAN::Meta::Spec>, L<YAML>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_METAYAML

$fatpacked{"Dist/Zilla/Plugin/ModuleBuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_MODULEBUILD';
  package Dist::Zilla::Plugin::ModuleBuild 6.007;
  # ABSTRACT: build a Build.PL that uses Module::Build
  
  use Moose;
  with (
    'Dist::Zilla::Role::BuildPL',
    'Dist::Zilla::Role::PrereqSource',
    'Dist::Zilla::Role::FileGatherer',
    'Dist::Zilla::Role::TextTemplate',
  );
  
  use namespace::autoclean;
  
  use CPAN::Meta::Requirements 2.121; # requirements_for_module
  use Dist::Zilla::File::InMemory;
  use List::Util 'first';
  use Data::Dumper;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will create a F<Build.PL> for installing the dist using
  #pod L<Module::Build>.
  #pod
  #pod =cut
  
  #pod =attr mb_version
  #pod
  #pod B<Optional:> Specify the minimum version of L<Module::Build> to depend on.
  #pod
  #pod Defaults to 0.3601 if a sharedir is being used, otherwise 0.28.
  #pod
  #pod =attr mb_class
  #pod
  #pod B<Optional:> Specify the class to use to create the build object.  Defaults
  #pod to C<Module::Build> itself.  If another class is specified, then the value
  #pod of mb_lib will be used to generate a line like C<use lib 'inc'> to be added
  #pod to the generated Build.PL file.
  #pod
  #pod =attr mb_lib
  #pod
  #pod B<Optional:> Specify the list of directories to be passed to lib when using 
  #pod mb_class. Defaults to C<inc>. 
  #pod
  #pod =attr build_element
  #pod
  #pod Anything given in a C<build_element> option will be added as a build element
  #pod with Module::Build's L<add_build_element> method.
  #pod
  #pod =cut
  
  has 'mb_version' => (
    isa => 'Str',
    is  => 'rw',
    lazy => 1,
    default => sub {
      my $self = shift;
      keys %{$self->zilla->_share_dir_map} ? '0.3601' : '0.28';
    },
  );
  
  has 'mb_class' => (
    isa => 'Str',
    is  => 'rw',
    default => 'Module::Build',
  );
  
  has 'mb_lib' => (
    isa => 'Str',
    is  => 'rw',
    default => 'inc'
  );
  
  has 'build_element' => (
    isa => 'ArrayRef[Str]',
    is  => 'rw',
    default => sub { [] },
  );
  
  sub mvp_multivalue_args { return qw(build_element) }
  
  my $template = q|
  # This file was automatically generated by {{ $generated_by }}.
  use strict;
  use warnings;
  
  use Module::Build {{ $plugin->mb_version }};
  {{ $plugin->_use_custom_class }}
  
  my {{ $module_build_args }}
  
  my {{ $fallback_build_prereqs }}
  
  unless ( eval { Module::Build->VERSION(0.4004) } ) {
    delete $module_build_args{test_requires};
    $module_build_args{build_requires} = \%fallback_build_requires;
  }
  
  my $build = {{ $plugin->mb_class }}->new(%module_build_args);
  {{ $plugin->_add_build_elements }}
  
  $build->create_build_script;
  |;
  
  sub _use_custom_class {
    my ($self) = @_;
    my $class = $self->mb_class;
    if ( $class eq 'Module::Build' ) {
      return "";
    }
    else {
      return sprintf "use lib qw{%s}; use $class;", join ' ', split ',', $self->mb_lib;
    }
  }
  
  sub _dump_as {
    my ($self, $ref, $name) = @_;
    require Data::Dumper;
    my $dumper = Data::Dumper->new( [ $ref ], [ $name ] );
    $dumper->Sortkeys( 1 );
    $dumper->Indent( 1 );
    $dumper->Useqq( 1 );
    return $dumper->Dump;
  }
  
  sub _add_build_elements {
    my @elems = @{ shift->build_element } or return '';
    return '$build->add_build_element($_) for qw(' . join(' ', @elems) . ');';
  }
  
  sub register_prereqs {
    my ($self) = @_;
  
    $self->zilla->register_prereqs(
      { phase => 'configure' },
      'Module::Build' => $self->mb_version,
    );
  
    $self->zilla->register_prereqs(
      { phase => 'build' },
      'Module::Build' => $self->mb_version,
    );
  }
  
  sub module_build_args {
    my ($self) = @_;
  
    my @exe_files = map { $_->name }
      @{ $self->zilla->find_files(':ExecFiles') };
  
    $self->log_fatal("can't install files with whitespace in their names")
      if grep { /\s/ } @exe_files;
  
    my $prereqs = $self->zilla->prereqs;
    my %prereqs = (
      configure_requires => $prereqs->requirements_for(qw(configure requires)),
      build_requires     => $prereqs->requirements_for(qw(build     requires)),
      test_requires      => $prereqs->requirements_for(qw(test      requires)),
      requires           => $prereqs->requirements_for(qw(runtime   requires)),
      recommends         => $prereqs->requirements_for(qw(runtime   recommends)),
    );
  
    my $name = $self->zilla->name =~ s/-/::/gr;
  
    return {
      module_name   => $name,
      license       => $self->zilla->license->meta_yml_name,
      dist_abstract => $self->zilla->abstract,
      dist_name     => $self->zilla->name,
      dist_version  => $self->zilla->version,
      dist_author   => [ @{ $self->zilla->authors } ],
      @exe_files ? ( script_files  => [ sort @exe_files ] ) : (),
      ( keys %{$self->zilla->_share_dir_map} ? (share_dir => $self->zilla->_share_dir_map) : ()),
  
      (map {; my $modules = $prereqs{$_}->as_string_hash; keys %$modules ? ( $_ => $modules ) : () } keys %prereqs),
      recursive_test_files => 1,
    };
  }
  
  sub fallback_build_requires {
    my $self = shift;
    my $prereqs = $self->zilla->prereqs;
    my $merged = CPAN::Meta::Requirements->new;
    for my $phase ( qw/build test/ ) {
      my $req = $prereqs->requirements_for($phase, 'requires');
      $merged->add_requirements( $req );
    };
    return $self->_dump_as( $merged->as_string_hash, '*fallback_build_requires' );
  }
  
  sub gather_files {
    my ($self) = @_;
  
    require Dist::Zilla::File::InMemory;
  
    my $file = Dist::Zilla::File::InMemory->new({
      name    => 'Build.PL',
      content => $template,   # template evaluated later
    });
  
    $self->add_file($file);
    return;
  }
  
  sub setup_installer {
    my ($self) = @_;
  
    $self->log_fatal("can't build Build.PL; license has no known META.yml value")
      unless $self->zilla->license->meta_yml_name;
  
    my $module_build_args = $self->module_build_args;
  
    $self->__module_build_args($module_build_args);
  
    my $dumped_args = $self->_dump_as($module_build_args, '*module_build_args');
  
    my $fallback_build_requires = $self->fallback_build_requires;
  
    my $file = first { $_->name eq 'Build.PL' } @{$self->zilla->files};
  
    $self->log_debug([ 'updating contents of Build.PL in memory' ]);
    my $content = $self->fill_in_string(
      $file->content,
      {
        plugin                  => \$self,
        module_build_args       => \$dumped_args,
        fallback_build_prereqs  => \$fallback_build_requires,
        generated_by            => \sprintf("%s v%s",
                                      ref($self), $self->VERSION || '(dev)'),
      },
    );
  
    $file->content($content);
  
    return;
  }
  
  # XXX:  Just here to facilitate testing. -- rjbs, 2010-03-20
  has __module_build_args => (
    is   => 'rw',
    isa  => 'HashRef',
  );
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<@Filter|Dist::Zilla::PluginBundle::Filter>,
  #pod L<MakeMaker|Dist::Zilla::Plugin::MakeMaker>,
  #pod L<Manifest|Dist::Zilla::Plugin::Manifest>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<BuildPL|Dist::Zilla::Role::BuildPL>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ModuleBuild - build a Build.PL that uses Module::Build
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin will create a F<Build.PL> for installing the dist using
  L<Module::Build>.
  
  =head1 ATTRIBUTES
  
  =head2 mb_version
  
  B<Optional:> Specify the minimum version of L<Module::Build> to depend on.
  
  Defaults to 0.3601 if a sharedir is being used, otherwise 0.28.
  
  =head2 mb_class
  
  B<Optional:> Specify the class to use to create the build object.  Defaults
  to C<Module::Build> itself.  If another class is specified, then the value
  of mb_lib will be used to generate a line like C<use lib 'inc'> to be added
  to the generated Build.PL file.
  
  =head2 mb_lib
  
  B<Optional:> Specify the list of directories to be passed to lib when using 
  mb_class. Defaults to C<inc>. 
  
  =head2 build_element
  
  Anything given in a C<build_element> option will be added as a build element
  with Module::Build's L<add_build_element> method.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<@Filter|Dist::Zilla::PluginBundle::Filter>,
  L<MakeMaker|Dist::Zilla::Plugin::MakeMaker>,
  L<Manifest|Dist::Zilla::Plugin::Manifest>.
  
  Dist::Zilla roles:
  L<BuildPL|Dist::Zilla::Role::BuildPL>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_MODULEBUILD

$fatpacked{"Dist/Zilla/Plugin/ModuleShareDirs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_MODULESHAREDIRS';
  package Dist::Zilla::Plugin::ModuleShareDirs 6.007;
  # ABSTRACT: install a directory's contents as module-based "ShareDir" content
  
  use Moose;
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [ModuleShareDirs]
  #pod   Foo::Bar = shares/foo_bar
  #pod   Foo::Baz = shares/foo_baz
  #pod
  #pod =cut
  
  has _module_map => (
    is   => 'ro',
    isa  => 'HashRef',
    default => sub { {} },
  );
  
  sub find_files {
    my ($self) = @_;
    my $modmap = $self->_module_map;
    my @files;
  
    for my $mod ( keys %$modmap ) {
      my $dir = $modmap->{$mod};
      my @mod_files = grep { index($_->name, "$dir/") == 0 }
        @{ $self->zilla->files };
      push @files, @mod_files;
    }
  
    return \@files;
  }
  
  sub share_dir_map {
    my ($self) = @_;
    my $modmap = $self->_module_map;
  
    return unless keys %$modmap;
    return { module => $modmap };
  }
  
  around BUILDARGS => sub {
    my $orig = shift;
    my ($class, @arg) = @_;
  
    my $args = $class->$orig(@arg);
    my %copy = %{ $args };
  
    my $zilla = delete $copy{zilla};
    my $name  = delete $copy{plugin_name};
  
    return {
      zilla => $zilla,
      plugin_name => $name,
      _module_map => \%copy,
    }
  };
  
  with 'Dist::Zilla::Role::ShareDir';
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ModuleShareDirs - install a directory's contents as module-based "ShareDir" content
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [ModuleShareDirs]
    Foo::Bar = shares/foo_bar
    Foo::Baz = shares/foo_baz
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_MODULESHAREDIRS

$fatpacked{"Dist/Zilla/Plugin/NextRelease.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_NEXTRELEASE';
  package Dist::Zilla::Plugin::NextRelease 6.007;
  # ABSTRACT: update the next release number in your changelog
  
  use namespace::autoclean;
  
  use Moose;
  with (
    'Dist::Zilla::Role::FileMunger',
    'Dist::Zilla::Role::TextTemplate',
    'Dist::Zilla::Role::AfterRelease',
  );
  
  use Dist::Zilla::Path;
  use Moose::Util::TypeConstraints;
  use List::Util 'first';
  use String::Formatter 0.100680 stringf => {
    -as => '_format_version',
  
    input_processor => 'require_single_input',
    string_replacer => 'method_replace',
    codes => {
      v => sub { $_[0]->zilla->version },
      d => sub {
        require DateTime;
        DateTime->VERSION('0.44'); # CLDR fixes
  
        DateTime->from_epoch(epoch => $^T, time_zone => $_[0]->time_zone)
                ->format_cldr($_[1]),
      },
      t => sub { "\t" },
      n => sub { "\n" },
      E => sub { $_[0]->_user_info('email') },
      U => sub { $_[0]->_user_info('name')  },
      T => sub { $_[0]->zilla->is_trial
                     ? ($_[1] // '-TRIAL') : '' },
      V => sub { $_[0]->zilla->version
                  . ($_[0]->zilla->is_trial
                     ? ($_[1] // '-TRIAL') : '') },
      P => sub {
        my $releaser = first { $_->can('cpanid') } @{ $_[0]->zilla->plugins_with('-Releaser') };
        $_[0]->log_fatal('releaser doesn\'t provide cpanid, but %P used') unless $releaser;
        $releaser->cpanid;
      },
    },
  };
  
  our $DEFAULT_TIME_ZONE = 'local';
  has time_zone => (
    is => 'ro',
    isa => 'Str', # should be more validated later -- apocal
    default => $DEFAULT_TIME_ZONE,
  );
  
  has format => (
    is  => 'ro',
    isa => 'Str', # should be more validated Later -- rjbs, 2008-06-05
    default => '%-9v %{yyyy-MM-dd HH:mm:ssZZZZZ VVVV}d%{ (TRIAL RELEASE)}T',
  );
  
  has filename => (
    is  => 'ro',
    isa => 'Str',
    default => 'Changes',
  );
  
  has update_filename => (
    is  => 'ro',
    isa => 'Str',
    lazy    => 1,
    default => sub { $_[0]->filename },
  );
  
  has user_stash => (
    is      => 'ro',
    isa     => 'Str',
    default => '%User'
  );
  
  has _user_stash_obj => (
    is       => 'ro',
    isa      => maybe_type( class_type('Dist::Zilla::Stash::User') ),
    lazy     => 1,
    init_arg => undef,
    default  => sub { $_[0]->zilla->stash_named( $_[0]->user_stash ) },
  );
  
  sub _user_info {
    my ($self, $field) = @_;
  
    my $stash = $self->_user_stash_obj;
  
    $self->log_fatal([
      "You must enter your %s in the [%s] section in ~/.dzil/config.ini",
      $field, $self->user_stash
    ]) unless $stash and defined(my $value = $stash->$field);
  
    return $value;
  }
  
  sub section_header {
    my ($self) = @_;
  
    return _format_version($self->format, $self);
  }
  
  has _original_changes_content => (
    is  => 'rw',
    isa => 'Str',
    init_arg => undef,
  );
  
  sub munge_files {
    my ($self) = @_;
  
    my ($file) = grep { $_->name eq $self->filename } @{ $self->zilla->files };
    $self->log_fatal([ 'failed to find %s in the distribution', $self->filename ]) if not $file;
  
    # save original unmunged content, for replacing back in the repo later
    my $content = $self->_original_changes_content($file->content);
  
    $content = $self->fill_in_string(
      $content,
      {
        dist    => \($self->zilla),
        version => \($self->zilla->version),
        NEXT    => \($self->section_header),
      },
    );
  
    $self->log_debug([ 'updating contents of %s in memory', $file->name ]);
    $file->content($content);
  }
  
  # new release is part of distribution history, let's record that.
  sub after_release {
    my ($self) = @_;
    my $filename = $self->filename;
    my ($gathered_file) = grep { $_->name eq $filename } @{ $self->zilla->files };
    $self->log_fatal("failed to find $filename in the distribution") if not $gathered_file;
    my $iolayer = sprintf(":raw:encoding(%s)", $gathered_file->encoding);
  
    # read original changelog
    my $content = $self->_original_changes_content;
  
    # add the version and date to file content
    my $delim  = $self->delim;
    my $header = $self->section_header;
    $content =~ s{ (\Q$delim->[0]\E \s*) \$NEXT (\s* \Q$delim->[1]\E) }
                 {$1\$NEXT$2\n\n$header}xs;
  
    my $update_fn = $self->update_filename;
    $self->log_debug([ 'updating contents of %s on disk', $update_fn ]);
  
    # and finally rewrite the changelog on disk
    path($update_fn)->spew({binmode => $iolayer}, $content);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [NextRelease]
  #pod
  #pod In your F<Changes> file:
  #pod
  #pod   {{$NEXT}}
  #pod
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Tired of having to update your F<Changes> file by hand with the new
  #pod version and release date / time each time you release your distribution?
  #pod Well, this plugin is for you.
  #pod
  #pod Add this plugin to your F<dist.ini>, and the following to your
  #pod F<Changes> file:
  #pod
  #pod   {{$NEXT}}
  #pod
  #pod The C<NextRelease> plugin will then do 2 things:
  #pod
  #pod =over 4
  #pod
  #pod =item * At build time, this special marker will be replaced with the
  #pod version and the build date, to form a standard changelog header. This
  #pod will be done to the in-memory file - the original F<Changes> file won't
  #pod be updated.
  #pod
  #pod =item * After release (when running C<dzil release>), since the version
  #pod and build date are now part of your dist's history, the real F<Changes>
  #pod file (not the in-memory one) will be updated with this piece of
  #pod information.
  #pod
  #pod =back
  #pod
  #pod The module accepts the following options in its F<dist.ini> section:
  #pod
  #pod =begin :list
  #pod
  #pod = filename
  #pod the name of your changelog file;  defaults to F<Changes>
  #pod
  #pod = update_filename
  #pod the file to which to write an updated changelog to; defaults to the C<filename>
  #pod
  #pod = format
  #pod sprintf-like string used to compute the next value of C<{{$NEXT}}>;
  #pod defaults to C<%-9v %{yyyy-MM-dd HH:mm:ss VVVV}d>
  #pod
  #pod = time_zone
  #pod the timezone to use when generating the date;  defaults to I<local>
  #pod
  #pod = user_stash
  #pod the name of the stash where the user's name and email address can be found;
  #pod defaults to C<%User>
  #pod
  #pod =end :list
  #pod
  #pod The module allows the following sprintf-like format codes in the C<format>:
  #pod
  #pod =begin :list
  #pod
  #pod = C<%v>
  #pod The distribution version
  #pod
  #pod = C<%{-TRIAL}T>
  #pod Expands to -TRIAL (or any other supplied string) if this
  #pod is a trial release, or the empty string if not.  A bare C<%T> means
  #pod C<%{-TRIAL}T>.
  #pod
  #pod = C<%{-TRIAL}V>
  #pod Equivalent to C<%v%{-TRIAL}T>, to allow for the application of modifiers such
  #pod as space padding to the entire version string produced.
  #pod
  #pod = C<%{CLDR format}d>
  #pod The date of the release.  You can use any CLDR format supported by
  #pod L<DateTime>.  You must specify the format; there is no default.
  #pod
  #pod = C<%U>
  #pod The name of the user making this release (from C<user_stash>).
  #pod
  #pod = C<%E>
  #pod The email address of the user making this release (from C<user_stash>).
  #pod
  #pod = C<%P>
  #pod The CPAN (PAUSE) id of the user making this release (from -Releaser plugins;
  #pod see L<[UploadToCPAN]|Dist::Zilla::Plugin::UploadToCPAN/username>).
  #pod
  #pod = C<%n>
  #pod A newline
  #pod
  #pod = C<%t>
  #pod A tab
  #pod
  #pod =end :list
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>,
  #pod L<PkgVersion|Dist::Zilla::Plugin::PkgVersion>,
  #pod L<PodVersion|Dist::Zilla::Plugin::PodVersion>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<AfterRelease|Dist::Zilla::Plugin::AfterRelease>,
  #pod L<FileMunger|Dist::Zilla::Role::FileMunger>,
  #pod L<TextTemplate|Dist::Zilla::Role::TextTemplate>.
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::NextRelease - update the next release number in your changelog
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [NextRelease]
  
  In your F<Changes> file:
  
    {{$NEXT}}
  
  =head1 DESCRIPTION
  
  Tired of having to update your F<Changes> file by hand with the new
  version and release date / time each time you release your distribution?
  Well, this plugin is for you.
  
  Add this plugin to your F<dist.ini>, and the following to your
  F<Changes> file:
  
    {{$NEXT}}
  
  The C<NextRelease> plugin will then do 2 things:
  
  =over 4
  
  =item * At build time, this special marker will be replaced with the
  version and the build date, to form a standard changelog header. This
  will be done to the in-memory file - the original F<Changes> file won't
  be updated.
  
  =item * After release (when running C<dzil release>), since the version
  and build date are now part of your dist's history, the real F<Changes>
  file (not the in-memory one) will be updated with this piece of
  information.
  
  =back
  
  The module accepts the following options in its F<dist.ini> section:
  
  =over 4
  
  =item filename
  
  the name of your changelog file;  defaults to F<Changes>
  
  =item update_filename
  
  the file to which to write an updated changelog to; defaults to the C<filename>
  
  =item format
  
  sprintf-like string used to compute the next value of C<{{$NEXT}}>;
  defaults to C<%-9v %{yyyy-MM-dd HH:mm:ss VVVV}d>
  
  =item time_zone
  
  the timezone to use when generating the date;  defaults to I<local>
  
  =item user_stash
  
  the name of the stash where the user's name and email address can be found;
  defaults to C<%User>
  
  =back
  
  The module allows the following sprintf-like format codes in the C<format>:
  
  =over 4
  
  =item C<%v>
  
  The distribution version
  
  =item C<%{-TRIAL}T>
  
  Expands to -TRIAL (or any other supplied string) if this
  is a trial release, or the empty string if not.  A bare C<%T> means
  C<%{-TRIAL}T>.
  
  =item C<%{-TRIAL}V>
  
  Equivalent to C<%v%{-TRIAL}T>, to allow for the application of modifiers such
  as space padding to the entire version string produced.
  
  =item C<%{CLDR format}d>
  
  The date of the release.  You can use any CLDR format supported by
  L<DateTime>.  You must specify the format; there is no default.
  
  =item C<%U>
  
  The name of the user making this release (from C<user_stash>).
  
  =item C<%E>
  
  The email address of the user making this release (from C<user_stash>).
  
  =item C<%P>
  
  The CPAN (PAUSE) id of the user making this release (from -Releaser plugins;
  see L<[UploadToCPAN]|Dist::Zilla::Plugin::UploadToCPAN/username>).
  
  =item C<%n>
  
  A newline
  
  =item C<%t>
  
  A tab
  
  =back
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>,
  L<PkgVersion|Dist::Zilla::Plugin::PkgVersion>,
  L<PodVersion|Dist::Zilla::Plugin::PodVersion>.
  
  Dist::Zilla roles:
  L<AfterRelease|Dist::Zilla::Plugin::AfterRelease>,
  L<FileMunger|Dist::Zilla::Role::FileMunger>,
  L<TextTemplate|Dist::Zilla::Role::TextTemplate>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_NEXTRELEASE

$fatpacked{"Dist/Zilla/Plugin/PkgDist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PKGDIST';
  package Dist::Zilla::Plugin::PkgDist 6.007;
  # ABSTRACT: add a $DIST to your packages
  
  use Moose;
  with(
    'Dist::Zilla::Role::FileMunger',
    'Dist::Zilla::Role::FileFinderUser' => {
      default_finders => [ ':InstallModules', ':ExecFiles' ],
    },
    'Dist::Zilla::Role::PPI',
  );
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will add a line like the following to each package in each Perl
  #pod module or program (more or less) within the distribution:
  #pod
  #pod   { our $DIST = 'My-CPAN-Dist'; } # where 'My-CPAN-Dist' is your dist name
  #pod
  #pod It will skip any package declaration that includes a newline between the
  #pod C<package> keyword and the package name, like:
  #pod
  #pod   package
  #pod     Foo::Bar;
  #pod
  #pod This sort of declaration is also ignored by the CPAN toolchain, and is
  #pod typically used when doing monkey patching or other tricky things.
  #pod
  #pod =cut
  
  sub munge_files {
    my ($self) = @_;
  
    $self->munge_file($_) for @{ $self->found_files };
  }
  
  sub munge_file {
    my ($self, $file) = @_;
  
    # XXX: for test purposes, for now! evil! -- rjbs, 2010-03-17
    return                          if $file->name    =~ /^corpus\//;
  
    return                          if $file->name    =~ /\.t$/i;
    return $self->munge_perl($file) if $file->name    =~ /\.(?:pm|pl)$/i;
    return $self->munge_perl($file) if $file->content =~ /^#!(?:.*)perl(?:$|\s)/;
    return;
  }
  
  sub munge_perl {
    my ($self, $file) = @_;
  
    my $dist_name = $self->zilla->name;
  
    my $document = $self->ppi_document_for_file($file);
  
    return unless my $package_stmts = $document->find('PPI::Statement::Package');
  
    if ($self->document_assigns_to_variable($document, '$DIST')) {
      $self->log([ 'skipping %s: assigns to $DIST', $file->name ]);
      return;
    }
  
    my %seen_pkg;
  
    for my $stmt (@$package_stmts) {
      my $package = $stmt->namespace;
  
      if ($seen_pkg{ $package }++) {
        $self->log([ 'skipping package re-declaration for %s', $package ]);
        next;
      }
  
      if ($stmt->content =~ /package\s*\n\s*\Q$package/) {
        $self->log([ 'skipping private package %s', $package ]);
        next;
      }
  
      # the \x20 hack is here so that when we scan *this* document we don't find
      # an assignment to version; it shouldn't be needed, but it's been annoying
      # enough in the past that I'm keeping it here until tests are better
      my $perl = "{\n  \$$package\::DIST\x20=\x20'$dist_name';\n}\n";
  
      my $dist_doc = PPI::Document->new(\$perl);
      my @children = $dist_doc->schildren;
  
      $self->log_debug([
        'adding $DIST assignment to %s in %s',
        $package,
        $file->name,
      ]);
  
      # the extra whitespace element ensures we don't swallow up any blanks
      # lines after 'package ...' in the source file that PkgVersion warns about
      # if it's missing.
      Carp::carp('error inserting $DIST in ' . $file->name)
        unless $stmt->add_element( PPI::Token::Whitespace->new("\n") )
        and    $stmt->insert_after($children[0]->clone)
        and    $stmt->insert_after( PPI::Token::Whitespace->new("\n") );
    }
  
    # the document is no longer correct; it must be reparsed before it can be used again
    $file->content($document->serialize);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PkgDist - add a $DIST to your packages
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin will add a line like the following to each package in each Perl
  module or program (more or less) within the distribution:
  
    { our $DIST = 'My-CPAN-Dist'; } # where 'My-CPAN-Dist' is your dist name
  
  It will skip any package declaration that includes a newline between the
  C<package> keyword and the package name, like:
  
    package
      Foo::Bar;
  
  This sort of declaration is also ignored by the CPAN toolchain, and is
  typically used when doing monkey patching or other tricky things.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_PKGDIST

$fatpacked{"Dist/Zilla/Plugin/PkgVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PKGVERSION';
  package Dist::Zilla::Plugin::PkgVersion 6.007;
  # ABSTRACT: add a $VERSION to your packages
  
  use Moose;
  with(
    'Dist::Zilla::Role::FileMunger',
    'Dist::Zilla::Role::FileFinderUser' => {
      default_finders => [ ':InstallModules', ':ExecFiles' ],
    },
    'Dist::Zilla::Role::PPI',
  );
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod in dist.ini
  #pod
  #pod   [PkgVersion]
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin will add lines like the following to each package in each Perl
  #pod module or program (more or less) within the distribution:
  #pod
  #pod   $MyModule::VERSION = '0.001';
  #pod
  #pod or
  #pod
  #pod   { our $VERSION = '0.001'; }
  #pod
  #pod ...where 0.001 is the version of the dist, and MyModule is the name of the
  #pod package being given a version.  (In other words, it always uses fully-qualified
  #pod names to assign versions.)
  #pod
  #pod It will skip any package declaration that includes a newline between the
  #pod C<package> keyword and the package name, like:
  #pod
  #pod   package
  #pod     Foo::Bar;
  #pod
  #pod This sort of declaration is also ignored by the CPAN toolchain, and is
  #pod typically used when doing monkey patching or other tricky things.
  #pod
  #pod =attr die_on_existing_version
  #pod
  #pod If true, then when PkgVersion sees an existing C<$VERSION> assignment, it will
  #pod throw an exception rather than skip the file.  This attribute defaults to
  #pod false.
  #pod
  #pod =attr die_on_line_insertion
  #pod
  #pod By default, PkgVersion looks for a blank line after each C<package> statement.
  #pod If it finds one, it inserts the C<$VERSION> assignment on that line.  If it
  #pod doesn't, it will insert a new line, which means the shipped copy of the module
  #pod will have different line numbers (off by one) than the source.  If
  #pod C<die_on_line_insertion> is true, PkgVersion will raise an exception rather
  #pod than insert a new line.
  #pod
  #pod =attr use_package
  #pod
  #pod This option, if true, will not insert an assignment to C<$VERSION> but will
  #pod replace the existing C<package> declaration with one that includes a version
  #pod like:
  #pod
  #pod   package Module::Name 0.001;
  #pod
  #pod =attr use_our
  #pod
  #pod The idea here was to insert C<< { our $VERSION = '0.001'; } >> instead of C<<
  #pod $Module::Name::VERSION = '0.001'; >>.  It turns out that this causes problems
  #pod with some analyzers.  Use of this feature is deprecated.
  #pod
  #pod Something else will replace it in the future.
  #pod
  #pod =attr use_begin
  #pod
  #pod If true, the version assignment is wrapped in a BEGIN block.  This may help in
  #pod rare cases, such as when DynaLoader has to be called at BEGIN time, and
  #pod requires VERSION.  This option should be needed rarely.
  #pod
  #pod Also note that assigning to C<$VERSION> before the module has finished
  #pod compiling can lead to confused behavior with attempts to determine whether a
  #pod module was successfully loaded on perl v5.8.
  #pod
  #pod =attr finder
  #pod
  #pod =for stopwords FileFinder
  #pod
  #pod This is the name of a L<FileFinder|Dist::Zilla::Role::FileFinder> for finding
  #pod modules to edit.  The default value is C<:InstallModules> and C<:ExecFiles>;
  #pod this option can be used more than once.
  #pod
  #pod Other predefined finders are listed in
  #pod L<Dist::Zilla::Role::FileFinderUser/default_finders>.
  #pod You can define your own with the
  #pod L<[FileFinder::ByName]|Dist::Zilla::Plugin::FileFinder::ByName> and
  #pod L<[FileFinder::Filter]|Dist::Zilla::Plugin::FileFinder::Filter> plugins.
  #pod
  #pod =cut
  
  sub BUILD {
    my ($self) = @_;
    $self->log("use_our option to PkgVersion is deprecated and will be removed")
      if $self->use_our;
  
    if ($self->use_package && ($self->use_our || $self->use_begin)) {
      $self->log_fatal("use_package and (use_our or use_begin) are not compatible");
    }
  }
  
  sub munge_files {
    my ($self) = @_;
  
    $self->munge_file($_) for @{ $self->found_files };
  }
  
  sub munge_file {
    my ($self, $file) = @_;
  
    if ($file->is_bytes) {
      $self->log_debug($file->name . " has 'bytes' encoding, skipping...");
      return;
    }
  
    if ($file->name =~ /\.pod$/) {
      $self->log_debug($file->name . " is a pod file, skipping...");
      return;
    }
  
    return $self->munge_perl($file);
  }
  
  has die_on_existing_version => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  has die_on_line_insertion => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  has use_package => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  has use_our => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  has use_begin => (
    is  => 'ro',
    isa => 'Bool',
    default => 0,
  );
  
  sub munge_perl {
    my ($self, $file) = @_;
  
    my $version = $self->zilla->version;
  
    require version;
    Carp::croak("invalid characters in version")
      unless version::is_lax($version);
  
    my $document = $self->ppi_document_for_file($file);
  
    my $package_stmts = $document->find('PPI::Statement::Package');
    unless ($package_stmts) {
      $self->log_debug([ 'skipping %s: no package statement found', $file->name ]);
      return;
    }
  
    if ($self->document_assigns_to_variable($document, '$VERSION')) {
      if ($self->die_on_existing_version) {
        $self->log_fatal([ 'existing assignment to $VERSION in %s', $file->name ]);
      }
  
      $self->log([ 'skipping %s: assigns to $VERSION', $file->name ]);
      return;
    }
  
    my %seen_pkg;
  
    my $munged = 0;
    STATEMENT: for my $stmt (@$package_stmts) {
      my $package = $stmt->namespace;
      if ($seen_pkg{ $package }++) {
        $self->log([ 'skipping package re-declaration for %s', $package ]);
        next;
      }
  
      if ($stmt->content =~ /package\s*(?:#.*)?\n\s*\Q$package/) {
        $self->log([ 'skipping private package %s in %s', $package, $file->name ]);
        next;
      }
  
      $self->log("non-ASCII package name is likely to cause problems")
        if $package =~ /\P{ASCII}/;
  
      $self->log("non-ASCII version is likely to cause problems")
        if $version =~ /\P{ASCII}/;
  
      if ($self->use_package) {
        my $perl = sprintf 'package %s %s;', $package, $version;
        $perl .= ' # TRIAL' if $self->zilla->is_trial;
  
        my $newstmt = PPI::Token::Unknown->new($perl);
        Carp::carp("error inserting version in " . $file->name)
          unless $stmt->parent->__replace_child($stmt, $newstmt);
        $munged = 1;
        next STATEMENT;
      }
  
      # the \x20 hack is here so that when we scan *this* document we don't find
      # an assignment to version; it shouldn't be needed, but it's been annoying
      # enough in the past that I'm keeping it here until tests are better
      my $trial = $self->zilla->is_trial ? ' # TRIAL' : '';
      my $perl = $self->use_our
          ? "{ our \$VERSION\x20=\x20'$version'; }$trial"
          : "\$$package\::VERSION\x20=\x20'$version';$trial";
  
      $self->use_begin
        and $perl = "BEGIN { $perl }";
  
      $self->log_debug([
        'adding $VERSION assignment to %s in %s',
        $package,
        $file->name,
      ]);
  
      my $blank;
  
      {
        my $curr = $stmt;
        while (1) {
          # avoid bogus locations due to insert_after
          $document->flush_locations if $munged;
          my $curr_line_number = $curr->line_number + 1;
          my $find = $document->find(sub {
            my $line = $_[1]->line_number;
            return $line > $curr_line_number ? undef : $line == $curr_line_number;
          });
  
          last unless $find and @$find == 1;
  
          if ($find->[0]->isa('PPI::Token::Comment')) {
            $curr = $find->[0];
            next;
          }
  
          if ("$find->[0]" =~ /\A\s*\z/) {
            $blank = $find->[0];
          }
  
          last;
        }
      }
  
      $perl = $blank ? "$perl\n" : "\n$perl";
  
      my $clean_version = $version =~ tr/_//dr;
      $perl .= (
        $self->use_our
          ? "\n\$VERSION\x20=\x20'$clean_version';"
          : "\n\$$package\::VERSION\x20=\x20'$clean_version';"
        ) if $version ne $clean_version;
  
      # Why can't I use PPI::Token::Unknown? -- rjbs, 2014-01-11
      my $bogus_token = PPI::Token::Comment->new($perl);
  
      if ($blank) {
        Carp::carp("error inserting version in " . $file->name)
          unless $blank->insert_after($bogus_token);
        $blank->delete;
      } else {
        my $method = $self->die_on_line_insertion ? 'log_fatal' : 'log';
        $self->$method([
          'no blank line for $VERSION after package %s statement in %s line %s',
          $stmt->namespace,
          $file->name,
          $stmt->line_number,
        ]);
  
        Carp::carp("error inserting version in " . $file->name)
          unless $stmt->insert_after($bogus_token);
      }
  
      $munged = 1;
    }
  
    # the document is no longer correct; it must be reparsed before it can be
    # used again, so we can't just save_ppi_document_to_file
    # Maybe we want a way to clear the cache for the old form, though...
    # -- rjbs, 2016-04-24
    $file->content($document->serialize) if $munged;
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<PodVersion|Dist::Zilla::Plugin::PodVersion>,
  #pod L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>,
  #pod L<NextRelease|Dist::Zilla::Plugin::NextRelease>.
  #pod
  #pod Other Dist::Zilla plugins:
  #pod L<OurPkgVersion|Dist::Zilla::Plugin::OurPkgVersion> inserts version
  #pod numbers using C<our $VERSION = '...';> and without changing line numbers
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PkgVersion - add a $VERSION to your packages
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  in dist.ini
  
    [PkgVersion]
  
  =head1 DESCRIPTION
  
  This plugin will add lines like the following to each package in each Perl
  module or program (more or less) within the distribution:
  
    $MyModule::VERSION = '0.001';
  
  or
  
    { our $VERSION = '0.001'; }
  
  ...where 0.001 is the version of the dist, and MyModule is the name of the
  package being given a version.  (In other words, it always uses fully-qualified
  names to assign versions.)
  
  It will skip any package declaration that includes a newline between the
  C<package> keyword and the package name, like:
  
    package
      Foo::Bar;
  
  This sort of declaration is also ignored by the CPAN toolchain, and is
  typically used when doing monkey patching or other tricky things.
  
  =head1 ATTRIBUTES
  
  =head2 die_on_existing_version
  
  If true, then when PkgVersion sees an existing C<$VERSION> assignment, it will
  throw an exception rather than skip the file.  This attribute defaults to
  false.
  
  =head2 die_on_line_insertion
  
  By default, PkgVersion looks for a blank line after each C<package> statement.
  If it finds one, it inserts the C<$VERSION> assignment on that line.  If it
  doesn't, it will insert a new line, which means the shipped copy of the module
  will have different line numbers (off by one) than the source.  If
  C<die_on_line_insertion> is true, PkgVersion will raise an exception rather
  than insert a new line.
  
  =head2 use_package
  
  This option, if true, will not insert an assignment to C<$VERSION> but will
  replace the existing C<package> declaration with one that includes a version
  like:
  
    package Module::Name 0.001;
  
  =head2 use_our
  
  The idea here was to insert C<< { our $VERSION = '0.001'; } >> instead of C<<
  $Module::Name::VERSION = '0.001'; >>.  It turns out that this causes problems
  with some analyzers.  Use of this feature is deprecated.
  
  Something else will replace it in the future.
  
  =head2 use_begin
  
  If true, the version assignment is wrapped in a BEGIN block.  This may help in
  rare cases, such as when DynaLoader has to be called at BEGIN time, and
  requires VERSION.  This option should be needed rarely.
  
  Also note that assigning to C<$VERSION> before the module has finished
  compiling can lead to confused behavior with attempts to determine whether a
  module was successfully loaded on perl v5.8.
  
  =head2 finder
  
  =for stopwords FileFinder
  
  This is the name of a L<FileFinder|Dist::Zilla::Role::FileFinder> for finding
  modules to edit.  The default value is C<:InstallModules> and C<:ExecFiles>;
  this option can be used more than once.
  
  Other predefined finders are listed in
  L<Dist::Zilla::Role::FileFinderUser/default_finders>.
  You can define your own with the
  L<[FileFinder::ByName]|Dist::Zilla::Plugin::FileFinder::ByName> and
  L<[FileFinder::Filter]|Dist::Zilla::Plugin::FileFinder::Filter> plugins.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<PodVersion|Dist::Zilla::Plugin::PodVersion>,
  L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>,
  L<NextRelease|Dist::Zilla::Plugin::NextRelease>.
  
  Other Dist::Zilla plugins:
  L<OurPkgVersion|Dist::Zilla::Plugin::OurPkgVersion> inserts version
  numbers using C<our $VERSION = '...';> and without changing line numbers
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_PKGVERSION

$fatpacked{"Dist/Zilla/Plugin/PodCoverageTests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PODCOVERAGETESTS';
  package Dist::Zilla::Plugin::PodCoverageTests 6.007;
  # ABSTRACT: a author test for Pod coverage
  
  use Moose;
  extends 'Dist::Zilla::Plugin::InlineFiles';
  with 'Dist::Zilla::Role::PrereqSource';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
  #pod following files:
  #pod
  #pod   xt/author/pod-coverage.t - a standard Test::Pod::Coverage test
  #pod
  #pod This test uses L<Pod::Coverage::TrustPod> to check your Pod coverage.  This
  #pod means that to indicate that some subs should be treated as covered, even if no
  #pod documentation can be found, you can add:
  #pod
  #pod   =for Pod::Coverage sub_name other_sub this_one_too
  #pod
  #pod L<Test::Pod::Coverage> C<1.08> and L<Pod::Coverage::TrustPod> will be added as
  #pod C<develop requires> dependencies.
  #pod
  #pod =cut
  
  # Register the author test prereq as a "develop requires"
  # so it will be listed in "dzil listdeps --author"
  sub register_prereqs {
    my ($self) = @_;
  
    $self->zilla->register_prereqs(
      {
        type  => 'requires',
        phase => 'develop',
      },
      'Test::Pod::Coverage'     => '1.08',
      'Pod::Coverage::TrustPod' => 0,
    );
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PodCoverageTests - a author test for Pod coverage
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
  following files:
  
    xt/author/pod-coverage.t - a standard Test::Pod::Coverage test
  
  This test uses L<Pod::Coverage::TrustPod> to check your Pod coverage.  This
  means that to indicate that some subs should be treated as covered, even if no
  documentation can be found, you can add:
  
    =for Pod::Coverage sub_name other_sub this_one_too
  
  L<Test::Pod::Coverage> C<1.08> and L<Pod::Coverage::TrustPod> will be added as
  C<develop requires> dependencies.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __DATA__
  ___[ xt/author/pod-coverage.t ]___
  #!perl
  # This file was automatically generated by Dist::Zilla::Plugin::PodCoverageTests.
  
  use Test::Pod::Coverage 1.08;
  use Pod::Coverage::TrustPod;
  
  all_pod_coverage_ok({ coverage_class => 'Pod::Coverage::TrustPod' });
DIST_ZILLA_PLUGIN_PODCOVERAGETESTS

$fatpacked{"Dist/Zilla/Plugin/PodSyntaxTests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PODSYNTAXTESTS';
  package Dist::Zilla::Plugin::PodSyntaxTests 6.007;
  # ABSTRACT: a author test for Pod syntax
  
  use Moose;
  extends 'Dist::Zilla::Plugin::InlineFiles';
  with 'Dist::Zilla::Role::PrereqSource';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
  #pod following files:
  #pod
  #pod   xt/author/pod-syntax.t   - a standard Test::Pod test
  #pod
  #pod L<Test::Pod> C<1.41> will be added as a C<develop requires> dependency.
  #pod
  #pod =cut
  
  
  # Register the author test prereq as a "develop requires"
  # so it will be listed in "dzil listdeps --author"
  sub register_prereqs {
    my ($self) = @_;
  
    $self->zilla->register_prereqs(
      {
        type  => 'requires',
        phase => 'develop',
      },
      'Test::Pod' => '1.41',
    );
  }
  
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PodSyntaxTests - a author test for Pod syntax
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is an extension of L<Dist::Zilla::Plugin::InlineFiles>, providing the
  following files:
  
    xt/author/pod-syntax.t   - a standard Test::Pod test
  
  L<Test::Pod> C<1.41> will be added as a C<develop requires> dependency.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __DATA__
  ___[ xt/author/pod-syntax.t ]___
  #!perl
  # This file was automatically generated by Dist::Zilla::Plugin::PodSyntaxTests.
  use strict; use warnings;
  use Test::More;
  use Test::Pod 1.41;
  
  all_pod_files_ok();
DIST_ZILLA_PLUGIN_PODSYNTAXTESTS

$fatpacked{"Dist/Zilla/Plugin/PodVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PODVERSION';
  package Dist::Zilla::Plugin::PodVersion 6.007;
  # ABSTRACT: add a VERSION head1 to each Perl document
  
  use Moose;
  with(
    'Dist::Zilla::Role::FileMunger',
    'Dist::Zilla::Role::FileFinderUser' => {
      default_finders => [ ':InstallModules', ':ExecFiles' ],
    },
  );
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin adds a C<=head1 VERSION> section to most perl files in the
  #pod distribution, indicating the version of the dist being built.  This section is
  #pod added after C<=head1 NAME>.  If there is no such section, the version section
  #pod will not be added.
  #pod
  #pod =cut
  
  sub munge_files {
    my ($self) = @_;
  
    $self->munge_file($_) for @{ $self->found_files };
  }
  
  sub munge_file {
    my ($self, $file) = @_;
  
    return $self->munge_pod($file);
  }
  
  sub munge_pod {
    my ($self, $file) = @_;
  
    my @content = split /\n/, $file->content;
  
    require List::Util;
    List::Util->VERSION('1.33');
    if (List::Util::any(sub { $_ =~ /^=head1 VERSION\b/ }, @content)) {
      $self->log($file->name . ' already has a VERSION section in POD');
      return;
    }
  
    for (0 .. $#content) {
      next until $content[$_] =~ /^=head1 NAME/;
  
      $_++; # move past the =head1 line itself
      $_++ while $content[$_] =~ /^\s*$/;
  
      $_++ while $content[$_] !~ /^\s*$/; # move past the abstract
      $_++ while $content[$_] =~ /^\s*$/;
  
      splice @content, $_ - 1, 0, (
        q{},
        "=head1 VERSION",
        q{},
        "version " . $self->zilla->version . q{},
      );
  
      $self->log_debug([ 'adding VERSION Pod section to %s', $file->name ]);
  
      my $content = join "\n", @content;
      $content .= "\n" if length $content;
      $file->content($content);
      return;
    }
  
    $self->log([
      "couldn't find '=head1 NAME' in %s, not adding '=head1 VERSION'",
      $file->name,
    ]);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<PkgVersion|Dist::Zilla::Plugin::PkgVersion>,
  #pod L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>,
  #pod L<NextRelease|Dist::Zilla::Plugin::NextRelease>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PodVersion - add a VERSION head1 to each Perl document
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin adds a C<=head1 VERSION> section to most perl files in the
  distribution, indicating the version of the dist being built.  This section is
  added after C<=head1 NAME>.  If there is no such section, the version section
  will not be added.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins:
  L<PkgVersion|Dist::Zilla::Plugin::PkgVersion>,
  L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>,
  L<NextRelease|Dist::Zilla::Plugin::NextRelease>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_PODVERSION

$fatpacked{"Dist/Zilla/Plugin/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PREREQS';
  package Dist::Zilla::Plugin::Prereqs 6.007;
  # ABSTRACT: list simple prerequisites
  
  use Moose;
  with 'Dist::Zilla::Role::PrereqSource';
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [Prereqs]
  #pod   Foo::Bar = 1.002
  #pod   MRO::Compat = 10
  #pod   Sub::Exporter = 0
  #pod
  #pod You can specify requirements for different phases and relationships with:
  #pod
  #pod   [Prereqs]
  #pod   -phase = test
  #pod   -relationship = recommends
  #pod
  #pod   Fitz::Fotz    = 1.23
  #pod   Text::SoundEx = 3
  #pod
  #pod Remember that if you load two Prereqs plugins, each will needs its own name,
  #pod added like this:
  #pod
  #pod   [Prereqs / PluginName]
  #pod   -phase = test
  #pod   -relationship = recommends
  #pod
  #pod   Fitz::Fotz    = 1.23
  #pod   Text::SoundEx = 3
  #pod
  #pod If the name is the CamelCase concatenation of a phase and relationship
  #pod (or just a relationship), it will set those parameters implicitly.  If
  #pod you use a custom name, but it does not specify the relationship, and
  #pod you didn't specify either C<-phase> or C<-relationship>, it throws the
  #pod error C<No -phase or -relationship specified>.  This is to prevent a
  #pod typo that makes the name meaningless from slipping by unnoticed.
  #pod
  #pod The example below is equivalent to the example above, except for the name of
  #pod the resulting plugin:
  #pod
  #pod   [Prereqs / TestRecommends]
  #pod   Fitz::Fotz    = 1.23
  #pod   Text::SoundEx = 3
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module adds "fixed" prerequisites to your distribution.  These are prereqs
  #pod with a known, fixed minimum version that doesn't change based on platform or
  #pod other conditions.
  #pod
  #pod You can specify prerequisites for different phases and kinds of relationships.
  #pod In C<RuntimeRequires>, the phase is Runtime and the relationship is Requires.
  #pod These are described in more detail in the L<CPAN::Meta
  #pod specification|CPAN::Meta::Spec/PREREQUISITES>.
  #pod
  #pod The phases are:
  #pod
  #pod =for :list
  #pod * configure
  #pod * build
  #pod * test
  #pod * runtime
  #pod * develop
  #pod
  #pod The relationship types are:
  #pod
  #pod =for :list
  #pod * requires
  #pod * recommends
  #pod * suggests
  #pod * conflicts
  #pod
  #pod If the phase is omitted, it will default to I<runtime>; thus, specifying
  #pod "Prereqs / Recommends" in your dist.ini is equivalent to I<RuntimeRecommends>.
  #pod
  #pod Not all of these phases are useful for all tools, especially tools that only
  #pod understand version 1.x CPAN::Meta files.
  #pod
  #pod =cut
  
  has prereq_phase => (
    is   => 'ro',
    isa  => 'Str',
    lazy => 1,
    init_arg => 'phase',
    default  => 'runtime',
  );
  
  has prereq_type => (
    is   => 'ro',
    isa  => 'Str',
    lazy => 1,
    init_arg => 'type',
    default  => 'requires',
  );
  
  around dump_config => sub {
    my ($orig, $self) = @_;
    my $config = $self->$orig;
  
    my $this_config = {
      type  => $self->prereq_type,
      phase => $self->prereq_phase,
    };
  
    $config->{'' . __PACKAGE__} = $this_config;
  
    return $config;
  };
  
  has _prereq => (
    is   => 'ro',
    isa  => 'HashRef',
    default => sub { {} },
  );
  
  sub mvp_aliases { return { -relationship => '-type' } }
  
  around BUILDARGS => sub {
    my $orig = shift;
    my ($class, @arg) = @_;
  
    my $args = $class->$orig(@arg);
    my %copy = %{ $args };
  
    my $zilla = delete $copy{zilla};
    my $name  = delete $copy{plugin_name};
  
    my @dashed = grep { /^-/ } keys %copy;
  
    my %other;
    for my $dkey (@dashed) {
      my $key = $dkey =~ s/^-//r;
  
      $other{ $key } = delete $copy{ $dkey };
    }
  
    confess "don't try to pass -_prereq as a build arg!" if $other{_prereq};
  
    # Handle magic plugin names:
    unless (($other{phase} and $other{type})
              # plugin comes from a bundle
            or $name =~ m! (?: \A | / ) Prereqs? \z !x) {
  
      my ($phase, $type) = $name =~ /\A
        (Build|Test|Runtime|Configure|Develop)?
        (Requires|Recommends|Suggests|Conflicts)
      \z/x;
  
      if ($type) {
        $other{phase} ||= lc $phase if defined $phase;
        $other{type}  ||= lc $type;
      } else {
        $zilla->chrome->logger->log_fatal({ prefix => "[$name] " },
                                        "No -phase or -relationship specified")
          unless $other{phase} or $other{type};
      }
    }
  
    return {
      zilla => $zilla,
      plugin_name => $name,
      _prereq     => \%copy,
      %other,
    }
  };
  
  sub register_prereqs {
    my ($self) = @_;
  
    $self->zilla->register_prereqs(
      {
        type  => $self->prereq_type,
        phase => $self->prereq_phase,
      },
      %{ $self->_prereq },
    );
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over 4
  #pod
  #pod =item *
  #pod
  #pod Core Dist::Zilla plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<AutoPrereqs|Dist::Zilla::Plugin::AutoPrereqs>.
  #pod
  #pod =item *
  #pod
  #pod The CPAN Meta specification: L<CPAN::Meta/PREREQUISITES>.
  #pod
  #pod =back
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::Prereqs - list simple prerequisites
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [Prereqs]
    Foo::Bar = 1.002
    MRO::Compat = 10
    Sub::Exporter = 0
  
  You can specify requirements for different phases and relationships with:
  
    [Prereqs]
    -phase = test
    -relationship = recommends
  
    Fitz::Fotz    = 1.23
    Text::SoundEx = 3
  
  Remember that if you load two Prereqs plugins, each will needs its own name,
  added like this:
  
    [Prereqs / PluginName]
    -phase = test
    -relationship = recommends
  
    Fitz::Fotz    = 1.23
    Text::SoundEx = 3
  
  If the name is the CamelCase concatenation of a phase and relationship
  (or just a relationship), it will set those parameters implicitly.  If
  you use a custom name, but it does not specify the relationship, and
  you didn't specify either C<-phase> or C<-relationship>, it throws the
  error C<No -phase or -relationship specified>.  This is to prevent a
  typo that makes the name meaningless from slipping by unnoticed.
  
  The example below is equivalent to the example above, except for the name of
  the resulting plugin:
  
    [Prereqs / TestRecommends]
    Fitz::Fotz    = 1.23
    Text::SoundEx = 3
  
  =head1 DESCRIPTION
  
  This module adds "fixed" prerequisites to your distribution.  These are prereqs
  with a known, fixed minimum version that doesn't change based on platform or
  other conditions.
  
  You can specify prerequisites for different phases and kinds of relationships.
  In C<RuntimeRequires>, the phase is Runtime and the relationship is Requires.
  These are described in more detail in the L<CPAN::Meta
  specification|CPAN::Meta::Spec/PREREQUISITES>.
  
  The phases are:
  
  =over 4
  
  =item *
  
  configure
  
  =item *
  
  build
  
  =item *
  
  test
  
  =item *
  
  runtime
  
  =item *
  
  develop
  
  =back
  
  The relationship types are:
  
  =over 4
  
  =item *
  
  requires
  
  =item *
  
  recommends
  
  =item *
  
  suggests
  
  =item *
  
  conflicts
  
  =back
  
  If the phase is omitted, it will default to I<runtime>; thus, specifying
  "Prereqs / Recommends" in your dist.ini is equivalent to I<RuntimeRecommends>.
  
  Not all of these phases are useful for all tools, especially tools that only
  understand version 1.x CPAN::Meta files.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  Core Dist::Zilla plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<AutoPrereqs|Dist::Zilla::Plugin::AutoPrereqs>.
  
  =item *
  
  The CPAN Meta specification: L<CPAN::Meta/PREREQUISITES>.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_PREREQS

$fatpacked{"Dist/Zilla/Plugin/PruneCruft.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PRUNECRUFT';
  package Dist::Zilla::Plugin::PruneCruft 6.007;
  # ABSTRACT: prune stuff that you probably don't mean to include
  
  use Moose;
  use Moose::Util::TypeConstraints;
  with 'Dist::Zilla::Role::FilePruner';
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod This plugin tries to compensate for the stupid crap that turns up in your
  #pod working copy, removing it before it gets into your dist and screws everything
  #pod up.
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [PruneCruft]
  #pod
  #pod If you would like to exclude certain exclusions, use the C<except> option (it
  #pod can be specified multiple times):
  #pod
  #pod   [PruneCruft]
  #pod   except = \.gitignore
  #pod   except = t/.*/\.keep$
  #pod
  #pod This plugin is included in the L<@Basic|Dist::Zilla::PluginBundle::Basic>
  #pod bundle.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla plugins:
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  #pod L<PruneFiles|Dist::Zilla::Plugin::PruneFiles>,
  #pod L<ManifestSkip|Dist::Zilla::Plugin::ManifestSkip>.
  #pod
  #pod =cut
  
  {
    my $type = subtype as 'ArrayRef[RegexpRef]';
    coerce $type, from 'ArrayRef[Str]', via { [map { qr/$_/ } @$_] };
    has except => (
      is      => 'ro',
      isa     => $type,
      coerce  => 1,
      default => sub { [] },
    );
    sub mvp_multivalue_args { qw(except) }
  }
  
  sub _dont_exclude_file {
    my ($self, $file) = @_;
    for my $exception (@{ $self->except }) {
      return 1 if $file->name =~ $exception;
    }
    return;
  }
  
  sub exclude_file {
    my ($self, $file) = @_;
  
    return 0 if $self->_dont_exclude_file($file);
    return 1 if index($file->name, $self->zilla->name . '-') == 0;
    return 1 if $file->name =~ /\A\./;
    return 1 if $file->name =~ /\A(?:Build|Makefile)\z/;
    return 1 if $file->name eq 'Makefile.old';
    return 1 if $file->name =~ /\Ablib/;
    return 1 if $file->name =~ /\.(?:o|bs)$/;
    return 1 if $file->name =~ /\A_Inline/;
    return 1 if $file->name eq 'MYMETA.yml';
    return 1 if $file->name eq 'MYMETA.json';
    return 1 if $file->name eq 'pm_to_blib';
    return 1 if substr($file->name, 0, 6) eq '_eumm/';
    # Avoid bundling fatlib/ dir created by App::FatPacker
    # https://github.com/andk/pause/pull/65
    return 1 if substr($file->name, 0, 7) eq 'fatlib/';
  
    if (my $file = $file->name =~ s/\.c$//r) {
      for my $other (@{ $self->zilla->files }) {
        return 1 if $other->name eq "${file}.xs";
      }
    }
  
    return;
  }
  
  sub prune_files {
    my ($self) = @_;
  
    # Copy list (break reference) so we can mutate.
    for my $file ((), @{ $self->zilla->files }) {
      next unless $self->exclude_file($file);
  
      $self->log_debug([ 'pruning %s', $file->name ]);
  
      $self->zilla->prune_file($file);
    }
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PruneCruft - prune stuff that you probably don't mean to include
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  This plugin tries to compensate for the stupid crap that turns up in your
  working copy, removing it before it gets into your dist and screws everything
  up.
  
  In your F<dist.ini>:
  
    [PruneCruft]
  
  If you would like to exclude certain exclusions, use the C<except> option (it
  can be specified multiple times):
  
    [PruneCruft]
    except = \.gitignore
    except = t/.*/\.keep$
  
  This plugin is included in the L<@Basic|Dist::Zilla::PluginBundle::Basic>
  bundle.
  
  =head1 SEE ALSO
  
  Dist::Zilla plugins:
  L<@Basic|Dist::Zilla::PluginBundle::Basic>,
  L<PruneFiles|Dist::Zilla::Plugin::PruneFiles>,
  L<ManifestSkip|Dist::Zilla::Plugin::ManifestSkip>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_PRUNECRUFT

$fatpacked{"Dist/Zilla/Plugin/PruneFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_PRUNEFILES';
  package Dist::Zilla::Plugin::PruneFiles 6.007;
  # ABSTRACT: prune arbitrary files from the dist
  
  use Moose;
  with 'Dist::Zilla::Role::FilePruner';
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod This plugin allows you to explicitly prune some files from your
  #pod distribution. You can either specify the exact set of files (with the
  #pod "filenames" parameter) or provide the regular expressions to
  #pod check (using "match").
  #pod
  #pod This is useful if another plugin (maybe a FileGatherer) adds a
  #pod bunch of files, and you only want a subset of them.
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [PruneFiles]
  #pod   filename = xt/release/pod-coverage.t ; pod coverage tests are for jerks
  #pod   filename = todo-list.txt             ; keep our secret plans to ourselves
  #pod
  #pod   match     = ^test_data/
  #pod   match     = ^test.cvs$
  #pod
  #pod =cut
  
  sub mvp_multivalue_args { qw(filenames matches) }
  sub mvp_aliases { return { filename => 'filenames', match => 'matches' } }
  
  #pod =attr filenames
  #pod
  #pod This is an arrayref of filenames to be pruned from the distribution.
  #pod
  #pod =cut
  
  has filenames => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  #pod =attr matches
  #pod
  #pod This is an arrayref of regular expressions and files matching any of them,
  #pod will be pruned from the distribution.
  #pod
  #pod =cut
  
  has matches => (
    is   => 'ro',
    isa  => 'ArrayRef',
    default => sub { [] },
  );
  
  sub prune_files {
    my ($self) = @_;
  
    # never match (at least the filename characters)
    my $matches_regex = qr/\000/;
  
    $matches_regex = qr/$matches_regex|$_/ for (@{ $self->matches });
  
    # \A\Q$_\E should also handle the `eq` check
    $matches_regex = qr/$matches_regex|\A\Q$_\E/ for (@{ $self->filenames });
  
    # Copy list (break reference) so we can mutate.
    for my $file ((), @{ $self->zilla->files }) {
      next unless $file->name =~ $matches_regex;
  
      $self->log_debug([ 'pruning %s', $file->name ]);
  
      $self->zilla->prune_file($file);
    }
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla plugins:
  #pod L<PruneCruft|Dist::Zilla::Plugin::PruneCruft>,
  #pod L<GatherDir|Dist::Zilla::Plugin::GatherDir>,
  #pod L<ManifestSkip|Dist::Zilla::Plugin::ManifestSkip>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::PruneFiles - prune arbitrary files from the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  This plugin allows you to explicitly prune some files from your
  distribution. You can either specify the exact set of files (with the
  "filenames" parameter) or provide the regular expressions to
  check (using "match").
  
  This is useful if another plugin (maybe a FileGatherer) adds a
  bunch of files, and you only want a subset of them.
  
  In your F<dist.ini>:
  
    [PruneFiles]
    filename = xt/release/pod-coverage.t ; pod coverage tests are for jerks
    filename = todo-list.txt             ; keep our secret plans to ourselves
  
    match     = ^test_data/
    match     = ^test.cvs$
  
  =head1 ATTRIBUTES
  
  =head2 filenames
  
  This is an arrayref of filenames to be pruned from the distribution.
  
  =head2 matches
  
  This is an arrayref of regular expressions and files matching any of them,
  will be pruned from the distribution.
  
  =head1 SEE ALSO
  
  Dist::Zilla plugins:
  L<PruneCruft|Dist::Zilla::Plugin::PruneCruft>,
  L<GatherDir|Dist::Zilla::Plugin::GatherDir>,
  L<ManifestSkip|Dist::Zilla::Plugin::ManifestSkip>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_PRUNEFILES

$fatpacked{"Dist/Zilla/Plugin/Readme.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_README';
  package Dist::Zilla::Plugin::Readme 6.007;
  # ABSTRACT: build a README file
  
  use Moose;
  with qw/Dist::Zilla::Role::FileGatherer
      Dist::Zilla::Role::TextTemplate
      Dist::Zilla::Role::FileMunger/;
  
  use Moose::Util::TypeConstraints;
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin adds a very simple F<README> file to the distribution, citing the
  #pod dist's name, version, abstract, and license.  It may be more useful or
  #pod informative in the future.
  #pod
  #pod =cut
  
  has _file_obj => (
    is => 'rw', isa => role_type('Dist::Zilla::Role::File'),
  );
  
  sub gather_files {
    my ($self, $arg) = @_;
  
    require Dist::Zilla::File::InMemory;
  
    my $template = q|
  
  This archive contains the distribution {{ $dist->name }},
  version {{ $dist->version }}:
  
    {{ $dist->abstract }}
  
  {{ $dist->license->notice }}
  
  This README file was generated by {{ $generated_by }}.
  
  |;
  
    $self->add_file(
      $self->_file_obj(
        Dist::Zilla::File::InMemory->new(
          name => 'README',
          content => $template,
        )
      )
    );
  
    return;
  }
  
  sub munge_files {
    my $self = shift;
  
    my $file = $self->_file_obj;
  
    $file->content(
      $self->fill_in_string(
        $file->content,
        {
          dist => \($self->zilla),
          generated_by => \sprintf("%s v%s",
                            ref($self), $self->VERSION || '(dev)'),
        }
      )
    );
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::Readme - build a README file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin adds a very simple F<README> file to the distribution, citing the
  dist's name, version, abstract, and license.  It may be more useful or
  informative in the future.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_README

$fatpacked{"Dist/Zilla/Plugin/RemovePrereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_REMOVEPREREQS';
  package Dist::Zilla::Plugin::RemovePrereqs 6.007;
  # ABSTRACT: a plugin to remove gathered prereqs
  
  use Moose;
  with 'Dist::Zilla::Role::PrereqSource';
  
  use namespace::autoclean;
  
  use MooseX::Types::Moose qw(ArrayRef);
  use MooseX::Types::Perl  qw(ModuleName);
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [RemovePrereqs]
  #pod   remove = Foo::Bar
  #pod   remove = MRO::Compat
  #pod
  #pod This will remove any prerequisite of any type from any prereq phase.  This is
  #pod useful for eliminating incorrectly detected prereqs.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Dist::Zilla plugins:
  #pod L<Prereqs|Dist::Zilla::Plugin::Prereqs>,
  #pod L<AutoPrereqs|Dist::Zilla::Plugin::AutoPrereqs>.
  #pod
  #pod =cut
  
  sub mvp_multivalue_args { qw(modules_to_remove) }
  
  sub mvp_aliases {
    return { remove => 'modules_to_remove' }
  }
  
  has modules_to_remove => (
    is  => 'ro',
    isa => ArrayRef[ ModuleName ],
    required => 1,
  );
  
  around dump_config => sub {
    my ($orig, $self) = @_;
    my $config = $self->$orig;
  
    my $this_config = {
      modules_to_remove  => [ sort @{ $self->modules_to_remove } ],
    };
  
    $config->{'' . __PACKAGE__} = $this_config;
  
    return $config;
  };
  
  my @phases = qw(configure build test runtime develop);
  my @types  = qw(requires recommends suggests conflicts);
  
  sub register_prereqs {
    my ($self) = @_;
  
    my $prereqs = $self->zilla->prereqs;
  
    for my $p (@phases) {
      for my $t (@types) {
        for my $m (@{ $self->modules_to_remove }) {
          $prereqs->requirements_for($p, $t)->clear_requirement($m);
        }
      }
    }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::RemovePrereqs - a plugin to remove gathered prereqs
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [RemovePrereqs]
    remove = Foo::Bar
    remove = MRO::Compat
  
  This will remove any prerequisite of any type from any prereq phase.  This is
  useful for eliminating incorrectly detected prereqs.
  
  =head1 SEE ALSO
  
  Dist::Zilla plugins:
  L<Prereqs|Dist::Zilla::Plugin::Prereqs>,
  L<AutoPrereqs|Dist::Zilla::Plugin::AutoPrereqs>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_REMOVEPREREQS

$fatpacked{"Dist/Zilla/Plugin/ShareDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_SHAREDIR';
  package Dist::Zilla::Plugin::ShareDir 6.007;
  # ABSTRACT: install a directory's contents as "ShareDir" content
  
  use Moose;
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [ShareDir]
  #pod   dir = share
  #pod
  #pod If no C<dir> is provided, the default is F<share>.
  #pod
  #pod =cut
  
  has dir => (
    is   => 'ro',
    isa  => 'Str',
    default => 'share',
  );
  
  sub find_files {
    my ($self) = @_;
  
    my $dir = $self->dir;
    my $files = [
      grep { index($_->name, "$dir/") == 0 }
        @{ $self->zilla->files }
    ];
  }
  
  sub share_dir_map {
    my ($self) = @_;
    my $files = $self->find_files;
    return unless @$files;
  
    return { dist => $self->dir };
  }
  
  with 'Dist::Zilla::Role::ShareDir';
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::ShareDir - install a directory's contents as "ShareDir" content
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [ShareDir]
    dir = share
  
  If no C<dir> is provided, the default is F<share>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_SHAREDIR

$fatpacked{"Dist/Zilla/Plugin/TemplateModule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_TEMPLATEMODULE';
  package Dist::Zilla::Plugin::TemplateModule 6.007;
  # ABSTRACT: a simple module-from-template plugin
  
  use Moose;
  with qw(Dist::Zilla::Role::ModuleMaker Dist::Zilla::Role::TextTemplate);
  
  use Dist::Zilla::Path;
  
  use namespace::autoclean;
  
  use autodie;
  
  use Sub::Exporter::ForMethods;
  use Data::Section 0.200002 # encoding and bytes
    { installer => Sub::Exporter::ForMethods::method_installer },
    '-setup';
  use Dist::Zilla::File::InMemory;
  
  #pod =head1 MINTING CONFIGURATION
  #pod
  #pod This module is part of the standard configuration of the default L<Dist::Zilla>
  #pod Minting Profile, and all profiles that don't set a custom ':DefaultModuleMaker'
  #pod so you don't need to normally do anything to configure it.
  #pod
  #pod   dzil new Some::Module
  #pod   # creates ./Some-Module/*
  #pod   # creates ./Some-Module/lib/Some/Module.pm
  #pod
  #pod However, for those who wish to configure this ( or any subclasses ) this is
  #pod presently required:
  #pod
  #pod   [TemplateModule / :DefaultModuleMaker]
  #pod   ; template  = SomeFile.pm
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This is a L<ModuleMaker|Dist::Zilla::Role::ModuleMaker> used for creating new
  #pod Perl modules files when minting a new dist with C<dzil new>.  It uses
  #pod L<Text::Template> (via L<Dist::Zilla::Role::TextTemplate>) to render a template
  #pod into a Perl module.  The template is given two variables for use in rendering:
  #pod C<$name>, the module name; and C<$dist>, the Dist::Zilla object.  The module is
  #pod always created as a file under F<./lib>.
  #pod
  #pod By default, the template looks something like this:
  #pod
  #pod   use strict;
  #pod   use warnings;
  #pod   package {{ $name }};
  #pod
  #pod   1;
  #pod
  #pod =attr template
  #pod
  #pod The C<template> parameter may be given to the plugin to provide a different
  #pod filename, absolute or relative to the build/profile directory.
  #pod
  #pod If this parameter is not specified, this module will use the boilerplate module
  #pod template included in this module.
  #pod
  #pod =cut
  
  has template => (
    is  => 'ro',
    isa => 'Str',
    predicate => 'has_template',
  );
  
  sub make_module {
    my ($self, $arg) = @_;
  
    my $template;
  
    if ($self->has_template) {
      $template = path( $self->template )->slurp_utf8;
    } else {
      $template = ${ $self->section_data('Module.pm') };
    }
  
    my $content = $self->fill_in_string(
      $template,
      {
        dist => \($self->zilla),
        name => $arg->{name},
      },
    );
  
    my $filename = $arg->{name} =~ s{::}{/}gr;
  
    my $file = Dist::Zilla::File::InMemory->new({
      name    => "lib/$filename.pm",
      content => $content,
    });
  
    $self->add_file($file);
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::TemplateModule - a simple module-from-template plugin
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This is a L<ModuleMaker|Dist::Zilla::Role::ModuleMaker> used for creating new
  Perl modules files when minting a new dist with C<dzil new>.  It uses
  L<Text::Template> (via L<Dist::Zilla::Role::TextTemplate>) to render a template
  into a Perl module.  The template is given two variables for use in rendering:
  C<$name>, the module name; and C<$dist>, the Dist::Zilla object.  The module is
  always created as a file under F<./lib>.
  
  By default, the template looks something like this:
  
    use strict;
    use warnings;
    package {{ $name }};
  
    1;
  
  =head1 ATTRIBUTES
  
  =head2 template
  
  The C<template> parameter may be given to the plugin to provide a different
  filename, absolute or relative to the build/profile directory.
  
  If this parameter is not specified, this module will use the boilerplate module
  template included in this module.
  
  =head1 MINTING CONFIGURATION
  
  This module is part of the standard configuration of the default L<Dist::Zilla>
  Minting Profile, and all profiles that don't set a custom ':DefaultModuleMaker'
  so you don't need to normally do anything to configure it.
  
    dzil new Some::Module
    # creates ./Some-Module/*
    # creates ./Some-Module/lib/Some/Module.pm
  
  However, for those who wish to configure this ( or any subclasses ) this is
  presently required:
  
    [TemplateModule / :DefaultModuleMaker]
    ; template  = SomeFile.pm
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __DATA__
  __[ Module.pm ]__
  use strict;
  use warnings;
  package {{ $name }};
  
  1;
DIST_ZILLA_PLUGIN_TEMPLATEMODULE

$fatpacked{"Dist/Zilla/Plugin/TestRelease.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_TESTRELEASE';
  package Dist::Zilla::Plugin::TestRelease 6.007;
  # ABSTRACT: extract archive and run tests before releasing the dist
  
  use Moose;
  with 'Dist::Zilla::Role::BeforeRelease';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin runs before a release happens.  It will extract the to-be-released
  #pod archive into a temporary directory and use the TestRunner plugins to run its
  #pod tests.  If the tests fail, the release is aborted and the temporary directory
  #pod is left in place.  If the tests pass, the temporary directory is cleaned up and
  #pod the release process continues.
  #pod
  #pod This will set the RELEASE_TESTING and AUTHOR_TESTING env vars while running the
  #pod test suite.
  #pod
  #pod =head1 CREDITS
  #pod
  #pod This plugin was originally contributed by Christopher J. Madsen.
  #pod
  #pod =cut
  
  use File::pushd ();
  use Dist::Zilla::Path;
  
  sub before_release {
    my ($self, $tgz) = @_;
    $tgz = $tgz->absolute;
  
    my $build_root = $self->zilla->root->child('.build');
    $build_root->mkpath unless -d $build_root;
  
    my $tmpdir = path( File::Temp::tempdir(DIR => $build_root) );
  
    $self->log("Extracting $tgz to $tmpdir");
  
    require Archive::Tar;
  
    my @files = do {
      my $wd = File::pushd::pushd($tmpdir);
      Archive::Tar->extract_archive("$tgz");
    };
  
    $self->log_fatal([ "Failed to extract archive: %s", Archive::Tar->error ])
      unless @files;
  
    # Run tests on the extracted tarball:
    my $target = $tmpdir->child( $self->zilla->dist_basename );
  
    local $ENV{RELEASE_TESTING} = 1;
    local $ENV{AUTHOR_TESTING} = 1;
    $self->zilla->run_tests_in($target);
  
    $self->log("all's well; removing $tmpdir");
    $tmpdir->remove_tree({ safe => 0 });
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::TestRelease - extract archive and run tests before releasing the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin runs before a release happens.  It will extract the to-be-released
  archive into a temporary directory and use the TestRunner plugins to run its
  tests.  If the tests fail, the release is aborted and the temporary directory
  is left in place.  If the tests pass, the temporary directory is cleaned up and
  the release process continues.
  
  This will set the RELEASE_TESTING and AUTHOR_TESTING env vars while running the
  test suite.
  
  =head1 CREDITS
  
  This plugin was originally contributed by Christopher J. Madsen.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_TESTRELEASE

$fatpacked{"Dist/Zilla/Plugin/UploadToCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGIN_UPLOADTOCPAN';
  package Dist::Zilla::Plugin::UploadToCPAN 6.007;
  # ABSTRACT: upload the dist to CPAN
  
  use Moose;
  with qw(Dist::Zilla::Role::BeforeRelease Dist::Zilla::Role::Releaser);
  
  use File::Spec;
  use Moose::Util::TypeConstraints;
  use Scalar::Util qw(weaken);
  use Try::Tiny;
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod If loaded, this plugin will allow the F<release> command to upload to the CPAN.
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin looks for configuration in your C<dist.ini> or (more
  #pod likely) C<~/.dzil/config.ini>:
  #pod
  #pod   [%PAUSE]
  #pod   username = YOUR-PAUSE-ID
  #pod   password = YOUR-PAUSE-PASSWORD
  #pod
  #pod If this configuration does not exist, it can read the configuration from
  #pod C<~/.pause>, in the same format that L<cpan-upload> requires:
  #pod
  #pod   user YOUR-PAUSE-ID
  #pod   password YOUR-PAUSE-PASSWORD
  #pod
  #pod If neither configuration exists, it will prompt you to enter your
  #pod username and password during the BeforeRelease phase.  Entering a
  #pod blank username or password will abort the release.
  #pod
  #pod You can't put your password in your F<dist.ini>.  C'mon now!
  #pod
  #pod =cut
  
  {
    package
      Dist::Zilla::Plugin::UploadToCPAN::_Uploader;
    # CPAN::Uploader will be loaded later if used
    our @ISA = 'CPAN::Uploader';
    # Report CPAN::Uploader's version, not ours:
    sub _ua_string { CPAN::Uploader->_ua_string }
  
    sub log {
      my $self = shift;
      $self->{'Dist::Zilla'}{plugin}->log(@_);
    }
  }
  
  #pod =attr credentials_stash
  #pod
  #pod This attribute holds the name of a L<PAUSE stash|Dist::Zilla::Stash::PAUSE>
  #pod that will contain the credentials to be used for the upload.  By default,
  #pod UploadToCPAN will look for a C<%PAUSE> stash.
  #pod
  #pod =cut
  
  has credentials_stash => (
    is  => 'ro',
    isa => 'Str',
    default => '%PAUSE'
  );
  
  has _credentials_stash_obj => (
    is   => 'ro',
    isa  => maybe_type( class_type('Dist::Zilla::Stash::PAUSE') ),
    lazy => 1,
    init_arg => undef,
    default  => sub { $_[0]->zilla->stash_named( $_[0]->credentials_stash ) },
  );
  
  sub _credential {
    my ($self, $name) = @_;
  
    return unless my $stash = $self->_credentials_stash_obj;
    return $stash->$name;
  }
  
  sub mvp_aliases {
    return { user => 'username' };
  }
  
  #pod =attr username
  #pod
  #pod This option supplies the user's PAUSE username.
  #pod It will be looked for in the user's PAUSE configuration; if not
  #pod found, the user will be prompted.
  #pod
  #pod =cut
  
  has username => (
    is   => 'ro',
    isa  => 'Str',
    lazy => 1,
    default  => sub {
      my ($self) = @_;
      return $self->_credential('username')
          || $self->pause_cfg->{user}
          || $self->zilla->chrome->prompt_str("PAUSE username: ");
    },
  );
  
  sub cpanid { shift->username }
  
  #pod =attr password
  #pod
  #pod This option supplies the user's PAUSE password.  It cannot be provided via
  #pod F<dist.ini>.  It will be looked for in the user's PAUSE configuration; if not
  #pod found, the user will be prompted.
  #pod
  #pod =cut
  
  has password => (
    is   => 'ro',
    isa  => 'Str',
    init_arg => undef,
    lazy => 1,
    default  => sub {
      my ($self) = @_;
      my $pw = $self->_credential('password') || $self->pause_cfg->{password};
  
      unless ($pw){
        my $uname = $self->username;
        $pw = $self->zilla->chrome->prompt_str(
          "PAUSE password for $uname: ",
          { noecho => 1 },
        );
      }
  
      return $pw;
    },
  );
  
  #pod =attr pause_cfg_file
  #pod
  #pod This is the name of the file containing your pause credentials.  It defaults
  #pod F<.pause>.  If you give a relative path, it is taken to be relative to
  #pod L</pause_cfg_dir>.
  #pod
  #pod =cut
  
  has pause_cfg_file => (
    is      => 'ro',
    isa     => 'Str',
    lazy    => 1,
    default => sub { '.pause' },
  );
  
  #pod =attr pause_cfg_dir
  #pod
  #pod This is the directory for resolving a relative L</pause_cfg_file>.
  #pod It defaults to C<< File::HomeDir->my_home >>.
  #pod
  #pod =cut
  
  has pause_cfg_dir => (
    is      => 'ro',
    isa     => 'Str',
    lazy    => 1,
    default => sub { require File::HomeDir; File::HomeDir::->my_home },
  );
  
  #pod =attr pause_cfg
  #pod
  #pod This is a hashref of defaults loaded from F<~/.pause> -- this attribute is
  #pod subject to removal in future versions, as the config-loading behavior in
  #pod CPAN::Uploader is improved.
  #pod
  #pod =cut
  
  has pause_cfg => (
    is      => 'ro',
    isa     => 'HashRef[Str]',
    lazy    => 1,
    default => sub {
      my $self = shift;
      require CPAN::Uploader;
      my $file = $self->pause_cfg_file;
      $file = File::Spec->catfile($self->pause_cfg_dir, $file)
        unless File::Spec->file_name_is_absolute($file);
      return {} unless -e $file && -r _;
      my $cfg = try {
        CPAN::Uploader->read_config_file($file)
      } catch {
        $self->log("Couldn't load credentials from '$file': $_");
        {};
      };
      return $cfg;
    },
  );
  
  #pod =attr subdir
  #pod
  #pod If given, this specifies a subdirectory under the user's home directory to
  #pod which to upload.  Using this option is not recommended.
  #pod
  #pod =cut
  
  has subdir => (
      is        => 'ro',
      isa       => 'Str',
      predicate => 'has_subdir',
  );
  
  #pod =attr upload_uri
  #pod
  #pod If given, this specifies an alternate URI for the PAUSE upload form.  By
  #pod default, the default supplied by L<CPAN::Uploader> is used.  Using this option
  #pod is not recommended in most cases.
  #pod
  #pod =cut
  
  has upload_uri => (
    is => 'ro',
    isa => 'Str',
    predicate => 'has_upload_uri',
  );
  
  has uploader => (
    is   => 'ro',
    isa  => 'CPAN::Uploader',
    lazy => 1,
    default => sub {
      my ($self) = @_;
  
      # Load the module lazily
      require CPAN::Uploader;
      CPAN::Uploader->VERSION('0.103004');  # require HTTPS
  
      my $uploader = Dist::Zilla::Plugin::UploadToCPAN::_Uploader->new({
        user     => $self->username,
        password => $self->password,
        ($self->has_subdir
             ? (subdir => $self->subdir) : ()),
        ($self->has_upload_uri
             ? (upload_uri => $self->upload_uri) : ()),
      });
  
      $uploader->{'Dist::Zilla'}{plugin} = $self;
      weaken $uploader->{'Dist::Zilla'}{plugin};
  
      return $uploader;
    }
  );
  
  sub before_release {
    my $self = shift;
  
    my $problem;
    try {
      for my $attr (qw(username password)) {
        $problem = $attr;
        die unless length $self->$attr;
      }
      undef $problem;
    };
  
    $self->log_fatal(['You need to supply a %s', $problem]) if $problem;
  }
  
  sub release {
    my ($self, $archive) = @_;
  
    $self->uploader->upload_file("$archive");
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Plugin::UploadToCPAN - upload the dist to CPAN
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  If loaded, this plugin will allow the F<release> command to upload to the CPAN.
  
  =head1 DESCRIPTION
  
  This plugin looks for configuration in your C<dist.ini> or (more
  likely) C<~/.dzil/config.ini>:
  
    [%PAUSE]
    username = YOUR-PAUSE-ID
    password = YOUR-PAUSE-PASSWORD
  
  If this configuration does not exist, it can read the configuration from
  C<~/.pause>, in the same format that L<cpan-upload> requires:
  
    user YOUR-PAUSE-ID
    password YOUR-PAUSE-PASSWORD
  
  If neither configuration exists, it will prompt you to enter your
  username and password during the BeforeRelease phase.  Entering a
  blank username or password will abort the release.
  
  You can't put your password in your F<dist.ini>.  C'mon now!
  
  =head1 ATTRIBUTES
  
  =head2 credentials_stash
  
  This attribute holds the name of a L<PAUSE stash|Dist::Zilla::Stash::PAUSE>
  that will contain the credentials to be used for the upload.  By default,
  UploadToCPAN will look for a C<%PAUSE> stash.
  
  =head2 username
  
  This option supplies the user's PAUSE username.
  It will be looked for in the user's PAUSE configuration; if not
  found, the user will be prompted.
  
  =head2 password
  
  This option supplies the user's PAUSE password.  It cannot be provided via
  F<dist.ini>.  It will be looked for in the user's PAUSE configuration; if not
  found, the user will be prompted.
  
  =head2 pause_cfg_file
  
  This is the name of the file containing your pause credentials.  It defaults
  F<.pause>.  If you give a relative path, it is taken to be relative to
  L</pause_cfg_dir>.
  
  =head2 pause_cfg_dir
  
  This is the directory for resolving a relative L</pause_cfg_file>.
  It defaults to C<< File::HomeDir->my_home >>.
  
  =head2 pause_cfg
  
  This is a hashref of defaults loaded from F<~/.pause> -- this attribute is
  subject to removal in future versions, as the config-loading behavior in
  CPAN::Uploader is improved.
  
  =head2 subdir
  
  If given, this specifies a subdirectory under the user's home directory to
  which to upload.  Using this option is not recommended.
  
  =head2 upload_uri
  
  If given, this specifies an alternate URI for the PAUSE upload form.  By
  default, the default supplied by L<CPAN::Uploader> is used.  Using this option
  is not recommended in most cases.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGIN_UPLOADTOCPAN

$fatpacked{"Dist/Zilla/PluginBundle/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGINBUNDLE_BASIC';
  package Dist::Zilla::PluginBundle::Basic 6.007;
  # ABSTRACT: the basic plugins to maintain and release CPAN dists
  
  use Moose;
  with 'Dist::Zilla::Role::PluginBundle::Easy';
  
  use namespace::autoclean;
  
  sub configure {
    my ($self) = @_;
  
    $self->add_plugins(qw(
      GatherDir
      PruneCruft
      ManifestSkip
      MetaYAML
      License
      Readme
      ExtraTests
      ExecDir
      ShareDir
  
      MakeMaker
      Manifest
  
      TestRelease
      ConfirmRelease
      UploadToCPAN
    ));
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin is meant to be a basic "first step" bundle for using Dist::Zilla.
  #pod It won't munge any of your code, but will generate a F<Makefile.PL> and allows
  #pod easy, reliable releasing of distributions.
  #pod
  #pod It includes the following plugins with their default configuration:
  #pod
  #pod =for :list
  #pod * L<Dist::Zilla::Plugin::GatherDir>
  #pod * L<Dist::Zilla::Plugin::PruneCruft>
  #pod * L<Dist::Zilla::Plugin::ManifestSkip>
  #pod * L<Dist::Zilla::Plugin::MetaYAML>
  #pod * L<Dist::Zilla::Plugin::License>
  #pod * L<Dist::Zilla::Plugin::Readme>
  #pod * L<Dist::Zilla::Plugin::ExtraTests>
  #pod * L<Dist::Zilla::Plugin::ExecDir>
  #pod * L<Dist::Zilla::Plugin::ShareDir>
  #pod * L<Dist::Zilla::Plugin::MakeMaker>
  #pod * L<Dist::Zilla::Plugin::Manifest>
  #pod * L<Dist::Zilla::Plugin::TestRelease>
  #pod * L<Dist::Zilla::Plugin::ConfirmRelease>
  #pod * L<Dist::Zilla::Plugin::UploadToCPAN>
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins: L<@Filter|Dist::Zilla::PluginBundle::Filter>.
  #pod
  #pod Dist::Zilla roles:
  #pod L<PluginBundle|Dist::Zilla::Role::PluginBundle>,
  #pod L<PluginBundle::Easy|Dist::Zilla::Role::PluginBundle::Easy>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::PluginBundle::Basic - the basic plugins to maintain and release CPAN dists
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This plugin is meant to be a basic "first step" bundle for using Dist::Zilla.
  It won't munge any of your code, but will generate a F<Makefile.PL> and allows
  easy, reliable releasing of distributions.
  
  It includes the following plugins with their default configuration:
  
  =over 4
  
  =item *
  
  L<Dist::Zilla::Plugin::GatherDir>
  
  =item *
  
  L<Dist::Zilla::Plugin::PruneCruft>
  
  =item *
  
  L<Dist::Zilla::Plugin::ManifestSkip>
  
  =item *
  
  L<Dist::Zilla::Plugin::MetaYAML>
  
  =item *
  
  L<Dist::Zilla::Plugin::License>
  
  =item *
  
  L<Dist::Zilla::Plugin::Readme>
  
  =item *
  
  L<Dist::Zilla::Plugin::ExtraTests>
  
  =item *
  
  L<Dist::Zilla::Plugin::ExecDir>
  
  =item *
  
  L<Dist::Zilla::Plugin::ShareDir>
  
  =item *
  
  L<Dist::Zilla::Plugin::MakeMaker>
  
  =item *
  
  L<Dist::Zilla::Plugin::Manifest>
  
  =item *
  
  L<Dist::Zilla::Plugin::TestRelease>
  
  =item *
  
  L<Dist::Zilla::Plugin::ConfirmRelease>
  
  =item *
  
  L<Dist::Zilla::Plugin::UploadToCPAN>
  
  =back
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins: L<@Filter|Dist::Zilla::PluginBundle::Filter>.
  
  Dist::Zilla roles:
  L<PluginBundle|Dist::Zilla::Role::PluginBundle>,
  L<PluginBundle::Easy|Dist::Zilla::Role::PluginBundle::Easy>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGINBUNDLE_BASIC

$fatpacked{"Dist/Zilla/PluginBundle/Classic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGINBUNDLE_CLASSIC';
  package Dist::Zilla::PluginBundle::Classic 6.007;
  # ABSTRACT: the classic (old) default configuration for Dist::Zilla
  
  use Moose;
  with 'Dist::Zilla::Role::PluginBundle::Easy';
  
  use namespace::autoclean;
  
  sub configure {
    my ($self) = @_;
  
    $self->add_plugins(qw(
      GatherDir
      PruneCruft
      ManifestSkip
      MetaYAML
      License
      Readme
      PkgVersion
      PodVersion
      PodCoverageTests
      PodSyntaxTests
      ExtraTests
      ExecDir
      ShareDir
  
      MakeMaker
      Manifest
  
      ConfirmRelease
      UploadToCPAN
    ));
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This bundle is more or less the original configuration bundled with
  #pod Dist::Zilla.  More than likely, you'd rather be using
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic> or a more complex bundle.  This one
  #pod will muck around with your code by adding C<$VERSION> declarations and will
  #pod mess with you Pod by adding a C<=head1 VERSION> section, but it won't get you a
  #pod lot of more useful features like autoversioning, autoprereqs, or Pod::Weaver.
  #pod
  #pod It includes the following plugins with their default configuration:
  #pod
  #pod =for :list
  #pod * L<Dist::Zilla::Plugin::GatherDir>
  #pod * L<Dist::Zilla::Plugin::PruneCruft>
  #pod * L<Dist::Zilla::Plugin::ManifestSkip>
  #pod * L<Dist::Zilla::Plugin::MetaYAML>
  #pod * L<Dist::Zilla::Plugin::License>
  #pod * L<Dist::Zilla::Plugin::Readme>
  #pod * L<Dist::Zilla::Plugin::PkgVersion>
  #pod * L<Dist::Zilla::Plugin::PodVersion>
  #pod * L<Dist::Zilla::Plugin::PodCoverageTests>
  #pod * L<Dist::Zilla::Plugin::PodSyntaxTests>
  #pod * L<Dist::Zilla::Plugin::ExtraTests>
  #pod * L<Dist::Zilla::Plugin::ExecDir>
  #pod * L<Dist::Zilla::Plugin::ShareDir>
  #pod * L<Dist::Zilla::Plugin::MakeMaker>
  #pod * L<Dist::Zilla::Plugin::Manifest>
  #pod * L<Dist::Zilla::Plugin::ConfirmRelease>
  #pod * L<Dist::Zilla::Plugin::UploadToCPAN>
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic>
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::PluginBundle::Classic - the classic (old) default configuration for Dist::Zilla
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This bundle is more or less the original configuration bundled with
  Dist::Zilla.  More than likely, you'd rather be using
  L<@Basic|Dist::Zilla::PluginBundle::Basic> or a more complex bundle.  This one
  will muck around with your code by adding C<$VERSION> declarations and will
  mess with you Pod by adding a C<=head1 VERSION> section, but it won't get you a
  lot of more useful features like autoversioning, autoprereqs, or Pod::Weaver.
  
  It includes the following plugins with their default configuration:
  
  =over 4
  
  =item *
  
  L<Dist::Zilla::Plugin::GatherDir>
  
  =item *
  
  L<Dist::Zilla::Plugin::PruneCruft>
  
  =item *
  
  L<Dist::Zilla::Plugin::ManifestSkip>
  
  =item *
  
  L<Dist::Zilla::Plugin::MetaYAML>
  
  =item *
  
  L<Dist::Zilla::Plugin::License>
  
  =item *
  
  L<Dist::Zilla::Plugin::Readme>
  
  =item *
  
  L<Dist::Zilla::Plugin::PkgVersion>
  
  =item *
  
  L<Dist::Zilla::Plugin::PodVersion>
  
  =item *
  
  L<Dist::Zilla::Plugin::PodCoverageTests>
  
  =item *
  
  L<Dist::Zilla::Plugin::PodSyntaxTests>
  
  =item *
  
  L<Dist::Zilla::Plugin::ExtraTests>
  
  =item *
  
  L<Dist::Zilla::Plugin::ExecDir>
  
  =item *
  
  L<Dist::Zilla::Plugin::ShareDir>
  
  =item *
  
  L<Dist::Zilla::Plugin::MakeMaker>
  
  =item *
  
  L<Dist::Zilla::Plugin::Manifest>
  
  =item *
  
  L<Dist::Zilla::Plugin::ConfirmRelease>
  
  =item *
  
  L<Dist::Zilla::Plugin::UploadToCPAN>
  
  =back
  
  =head1 SEE ALSO
  
  L<@Basic|Dist::Zilla::PluginBundle::Basic>
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGINBUNDLE_CLASSIC

$fatpacked{"Dist/Zilla/PluginBundle/FakeClassic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGINBUNDLE_FAKECLASSIC';
  package Dist::Zilla::PluginBundle::FakeClassic 6.007;
  # ABSTRACT: build something more or less like a "classic" CPAN dist
  
  use Moose;
  extends 'Dist::Zilla::PluginBundle::Classic';
  
  use namespace::autoclean;
  
  around bundle_config => sub {
    my ($orig, $self, $arg) = @_;
  
    my @config = $self->$orig($arg);
  
    for my $i (0 .. $#config) {
      if ($config[ $i ][1] eq 'Dist::Zilla::Plugin::UploadToCPAN') {
        require Dist::Zilla::Plugin::FakeRelease;
        $config[ $i ] = [
          "$arg->{name}/FakeRelease",
          'Dist::Zilla::Plugin::FakeRelease',
          $config[ $i ][2]
        ];
      }
    }
  
    return @config;
  };
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::PluginBundle::FakeClassic - build something more or less like a "classic" CPAN dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGINBUNDLE_FAKECLASSIC

$fatpacked{"Dist/Zilla/PluginBundle/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PLUGINBUNDLE_FILTER';
  package Dist::Zilla::PluginBundle::Filter 6.007;
  # ABSTRACT: use another bundle, with some plugins removed
  
  use Moose;
  with 'Dist::Zilla::Role::PluginBundle';
  
  use namespace::autoclean;
  
  use List::Util 1.33 qw(any);
  use Class::Load qw(try_load_class);
  use Dist::Zilla::Util;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod In your F<dist.ini>:
  #pod
  #pod   [@Filter]
  #pod   -bundle = @Basic
  #pod   -version = 5.031
  #pod   -remove = ShareDir
  #pod   -remove = UploadToCPAN
  #pod   option = for_basic
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This plugin bundle actually wraps and modifies another plugin bundle.  It
  #pod includes all the configuration for the bundle named in the C<-bundle> attribute,
  #pod but removes all the entries whose package is given in the C<-remove> attributes.
  #pod
  #pod A minimum required version of the bundle can be specified with the C<-version> 
  #pod attribute.
  #pod
  #pod Options not prefixed with C<-> will be passed to the bundle to be filtered.
  #pod
  #pod B<NOTE:> When you filter a bundle you B<SHOULD NOT> include it directly in
  #pod your C<dist.ini> file. This plugin will take care of including it for you.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins: L<@Basic|Dist::Zilla::PluginBundle::Basic>.
  #pod
  #pod Dist::Zilla roles: L<PluginBundle|Dist::Zilla::Role::PluginBundle>.
  #pod
  #pod =cut
  
  sub mvp_multivalue_args { qw(remove -remove) }
  
  sub bundle_config {
    my ($self, $section) = @_;
    my $class = (ref $self) || $self;
  
    my $config = {};
  
    my $has_filter_args = any { /^-/ } keys %{ $section->{payload} };
    for my $key (keys %{ $section->{payload} }) {
      my $val = $section->{payload}->{$key};
      my $target = $has_filter_args && ($key !~ /^-/)
        ? 'bundle'
        : 'filter';
      $key =~ s/^-// if $target eq 'filter';
      $config->{$target}->{$key} = $val;
    }
  
    Carp::croak("no bundle given for bundle filter")
      unless my $bundle = $config->{filter}->{bundle};
  
    my $pkg = Dist::Zilla::Util->expand_config_package_name($bundle);
  
    my $load_opts = {};
    if( my $v = $config->{filter}->{version} ){
      $load_opts->{'-version'} = $v;
    }
  
    unless (try_load_class($pkg, $load_opts)) {
      # XXX Naughty! -- rjbs, 2013-07-23
      Config::MVP::Section->missing_package($pkg, $bundle);
    }
  
    my @plugins = $pkg->bundle_config({
      name    => $section->{name}, # not 100% sure about this -- rjbs, 2010-03-06
      package => $pkg,
      payload => $config->{bundle} || {},
    });
  
    return @plugins unless my $remove = $config->{filter}->{remove};
  
    for my $i (reverse 0 .. $#plugins) {
      splice @plugins, $i, 1 if any(sub {
        $plugins[$i][1] eq Dist::Zilla::Util->expand_config_package_name($_)
      }, @$remove);
    }
  
    return @plugins;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::PluginBundle::Filter - use another bundle, with some plugins removed
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  In your F<dist.ini>:
  
    [@Filter]
    -bundle = @Basic
    -version = 5.031
    -remove = ShareDir
    -remove = UploadToCPAN
    option = for_basic
  
  =head1 DESCRIPTION
  
  This plugin bundle actually wraps and modifies another plugin bundle.  It
  includes all the configuration for the bundle named in the C<-bundle> attribute,
  but removes all the entries whose package is given in the C<-remove> attributes.
  
  A minimum required version of the bundle can be specified with the C<-version> 
  attribute.
  
  Options not prefixed with C<-> will be passed to the bundle to be filtered.
  
  B<NOTE:> When you filter a bundle you B<SHOULD NOT> include it directly in
  your C<dist.ini> file. This plugin will take care of including it for you.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins: L<@Basic|Dist::Zilla::PluginBundle::Basic>.
  
  Dist::Zilla roles: L<PluginBundle|Dist::Zilla::Role::PluginBundle>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PLUGINBUNDLE_FILTER

$fatpacked{"Dist/Zilla/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_PREREQS';
  package Dist::Zilla::Prereqs 6.007;
  # ABSTRACT: the prerequisites of a Dist::Zilla distribution
  
  use Moose;
  use MooseX::Types::Moose qw(Bool HashRef);
  
  use CPAN::Meta::Prereqs 2.120630; # add_string_requirement
  use String::RewritePrefix;
  use CPAN::Meta::Requirements 2.121; # requirements_for_module
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Dist::Zilla::Prereqs is a subcomponent of Dist::Zilla.  The C<prereqs>
  #pod attribute on your Dist::Zilla object is a Dist::Zilla::Prereqs object, and is
  #pod responsible for keeping track of the distribution's prerequisites.
  #pod
  #pod In fact, a Dist::Zilla::Prereqs object is just a thin layer over a
  #pod L<CPAN::Meta::Prereqs> object, stored in the C<cpan_meta_prereqs> attribute.
  #pod
  #pod Almost everything this object does is proxied to the CPAN::Meta::Prereqs
  #pod object, so you should really read how I<that> works.
  #pod
  #pod Dist::Zilla::Prereqs proxies the following methods to the CPAN::Meta::Prereqs
  #pod object:
  #pod
  #pod =for :list
  #pod * finalize
  #pod * is_finalized
  #pod * requirements_for
  #pod * as_string_hash
  #pod
  #pod =cut
  
  has cpan_meta_prereqs => (
    is  => 'ro',
    isa => 'CPAN::Meta::Prereqs',
    init_arg => undef,
    default  => sub { CPAN::Meta::Prereqs->new },
    handles  => [ qw(
      finalize
      is_finalized
      requirements_for
      as_string_hash
    ) ],
  );
  
  # storing this is sort of gross, but MakeMaker winds up needing the same data
  # anyway. -- xdg, 2013-10-22
  # This does *not* contain configure requires, as MakeMaker explicitly should
  # not have it in its fallback prereqs.
  has merged_requires => (
    is => 'ro',
    isa => 'CPAN::Meta::Requirements',
    init_arg => undef,
    default => sub { CPAN::Meta::Requirements->new },
  );
  
  #pod =method register_prereqs
  #pod
  #pod   $prereqs->register_prereqs(%prereqs);
  #pod
  #pod   $prereqs->register_prereqs(\%arg, %prereqs);
  #pod
  #pod This method adds new minimums to the prereqs object.  If a hashref is the first
  #pod arg, it may have entries for C<phase> and C<type> to indicate what kind of
  #pod prereqs are being registered.  (For more information on phase and type, see
  #pod L<CPAN::Meta::Spec>.)  For example, you might say:
  #pod
  #pod   $prereqs->register_prereqs(
  #pod     { phase => 'test', type => 'recommends' },
  #pod     'Test::Foo' => '1.23',
  #pod     'XML::YZZY' => '2.01',
  #pod   );
  #pod
  #pod If not given, phase and type default to runtime and requires, respectively.
  #pod
  #pod =cut
  
  sub register_prereqs {
    my $self = shift;
    my $arg  = ref($_[0]) ? shift(@_) : {};
    my %prereq = @_;
  
    my $phase = $arg->{phase} || 'runtime';
    my $type  = $arg->{type}  || 'requires';
  
    my $req = $self->requirements_for($phase, $type);
  
    while (my ($package, $version) = each %prereq) {
      $req->add_string_requirement($package, $version || 0);
    }
  
    return;
  }
  
  before 'finalize' => sub {
    my ($self) = @_;
    $self->sync_runtime_build_test_requires;
  };
  
  
  # this avoids a long-standing CPAN.pm bug that incorrectly merges runtime and
  # "build" (build+test) requirements by ensuring requirements stay unified
  # across all three phases
  sub sync_runtime_build_test_requires {
    my $self = shift;
  
    # first pass: generated merged requirements
    for my $phase ( qw/runtime build test/ ) {
      my $req = $self->requirements_for($phase, 'requires');
      $self->merged_requires->add_requirements( $req );
    };
  
    # second pass: update from merged requirements
    for my $phase ( qw/runtime build test/ ) {
      my $req = $self->requirements_for($phase, 'requires');
      for my $mod ( $req->required_modules ) {
        $req->clear_requirement( $mod );
        $req->add_string_requirement(
          $mod => $self->merged_requires->requirements_for_module($mod)
        );
      }
    }
  
    return;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Prereqs - the prerequisites of a Dist::Zilla distribution
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Dist::Zilla::Prereqs is a subcomponent of Dist::Zilla.  The C<prereqs>
  attribute on your Dist::Zilla object is a Dist::Zilla::Prereqs object, and is
  responsible for keeping track of the distribution's prerequisites.
  
  In fact, a Dist::Zilla::Prereqs object is just a thin layer over a
  L<CPAN::Meta::Prereqs> object, stored in the C<cpan_meta_prereqs> attribute.
  
  Almost everything this object does is proxied to the CPAN::Meta::Prereqs
  object, so you should really read how I<that> works.
  
  Dist::Zilla::Prereqs proxies the following methods to the CPAN::Meta::Prereqs
  object:
  
  =over 4
  
  =item *
  
  finalize
  
  =item *
  
  is_finalized
  
  =item *
  
  requirements_for
  
  =item *
  
  as_string_hash
  
  =back
  
  =head1 METHODS
  
  =head2 register_prereqs
  
    $prereqs->register_prereqs(%prereqs);
  
    $prereqs->register_prereqs(\%arg, %prereqs);
  
  This method adds new minimums to the prereqs object.  If a hashref is the first
  arg, it may have entries for C<phase> and C<type> to indicate what kind of
  prereqs are being registered.  (For more information on phase and type, see
  L<CPAN::Meta::Spec>.)  For example, you might say:
  
    $prereqs->register_prereqs(
      { phase => 'test', type => 'recommends' },
      'Test::Foo' => '1.23',
      'XML::YZZY' => '2.01',
    );
  
  If not given, phase and type default to runtime and requires, respectively.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_PREREQS

$fatpacked{"Dist/Zilla/Role/AfterBuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_AFTERBUILD';
  package Dist::Zilla::Role::AfterBuild 6.007;
  # ABSTRACT: something that runs after building is mostly complete
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<after_build> method called once all
  #pod the files have been written out.  It is passed a hashref with the following
  #pod data:
  #pod
  #pod   build_root - the directory in which the dist was built
  #pod
  #pod =cut
  
  requires 'after_build';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::AfterBuild - something that runs after building is mostly complete
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<after_build> method called once all
  the files have been written out.  It is passed a hashref with the following
  data:
  
    build_root - the directory in which the dist was built
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_AFTERBUILD

$fatpacked{"Dist/Zilla/Role/AfterMint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_AFTERMINT';
  package Dist::Zilla::Role::AfterMint 6.007;
  # ABSTRACT: something that runs after minting is mostly complete
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<after_mint> method called once all
  #pod the files have been written out.  It is passed a hashref with the following
  #pod data:
  #pod
  #pod   mint_root - the directory in which the dist was minted
  #pod
  #pod =cut
  
  requires 'after_mint';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::AfterMint - something that runs after minting is mostly complete
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<after_mint> method called once all
  the files have been written out.  It is passed a hashref with the following
  data:
  
    mint_root - the directory in which the dist was minted
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_AFTERMINT

$fatpacked{"Dist/Zilla/Role/AfterRelease.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_AFTERRELEASE';
  package Dist::Zilla::Role::AfterRelease 6.007;
  # ABSTRACT: something that runs after release is mostly complete
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<after_release> method called once
  #pod the release is done. The archive filename, if one was built, is passed as the
  #pod sole argument.
  #pod
  #pod =cut
  
  requires 'after_release';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::AfterRelease - something that runs after release is mostly complete
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<after_release> method called once
  the release is done. The archive filename, if one was built, is passed as the
  sole argument.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_AFTERRELEASE

$fatpacked{"Dist/Zilla/Role/BeforeArchive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_BEFOREARCHIVE';
  package Dist::Zilla::Role::BeforeArchive 6.007;
  # ABSTRACT: something that runs before the archive file is built
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<before_archive> method
  #pod called before the archive is actually built.
  #pod
  #pod =cut
  
  requires 'before_archive';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::BeforeArchive - something that runs before the archive file is built
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<before_archive> method
  called before the archive is actually built.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_BEFOREARCHIVE

$fatpacked{"Dist/Zilla/Role/BeforeBuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_BEFOREBUILD';
  package Dist::Zilla::Role::BeforeBuild 6.007;
  # ABSTRACT: something that runs before building really begins
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<before_build> method called
  #pod before any other plugins are consulted.
  #pod
  #pod =cut
  
  requires 'before_build';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::BeforeBuild - something that runs before building really begins
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<before_build> method called
  before any other plugins are consulted.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_BEFOREBUILD

$fatpacked{"Dist/Zilla/Role/BeforeMint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_BEFOREMINT';
  package Dist::Zilla::Role::BeforeMint 6.007;
  # ABSTRACT: something that runs before minting really begins
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<before_mint> method called
  #pod before any other plugins are consulted.
  #pod
  #pod =cut
  
  requires 'before_mint';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::BeforeMint - something that runs before minting really begins
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<before_mint> method called
  before any other plugins are consulted.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_BEFOREMINT

$fatpacked{"Dist/Zilla/Role/BeforeRelease.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_BEFORERELEASE';
  package Dist::Zilla::Role::BeforeRelease 6.007;
  # ABSTRACT: something that runs before release really begins
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<before_release> method
  #pod called before the release is actually done.
  #pod
  #pod =cut
  
  requires 'before_release';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::BeforeRelease - something that runs before release really begins
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<before_release> method
  called before the release is actually done.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_BEFORERELEASE

$fatpacked{"Dist/Zilla/Role/BuildPL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_BUILDPL';
  package Dist::Zilla::Role::BuildPL 6.007;
  # ABSTRACT: Common ground for Build.PL based builders
  
  use Moose::Role;
  
  with qw(
    Dist::Zilla::Role::InstallTool
    Dist::Zilla::Role::BuildRunner
    Dist::Zilla::Role::TestRunner
  );
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role is a helper for Build.PL based installers. It implements the
  #pod L<Dist::Zilla::Plugin::BuildRunner> and L<Dist::Zilla::Plugin::TestRunner>
  #pod roles, and requires you to implement the L<Dist::Zilla::Plugin::PrereqSource>
  #pod and L<Dist::Zilla::Plugin::InstallTool> roles yourself.
  #pod
  #pod =cut
  
  sub build {
    my $self = shift;
  
    return
      if -e 'Build' and (stat 'Build.PL')[9] <= (stat 'Build')[9];
  
    $self->log_debug("running $^X Build.PL");
    system $^X, 'Build.PL' and die "error with Build.PL\n";
  
    $self->log_debug("running $^X Build");
    system $^X, 'Build'    and die "error running $^X Build\n";
  
    return;
  }
  
  sub test {
    my ($self, $target, $arg) = @_;
  
    $self->build;
  
    my $job_count = $arg && exists $arg->{jobs}
                  ? $arg->{jobs}
                  : $self->default_jobs;
    my $jobs = "j$job_count";
    my $ho = "HARNESS_OPTIONS";
    local $ENV{$ho} = $ENV{$ho} ? "$ENV{$ho}:$jobs" : $jobs;
  
    my @testing = $self->zilla->logger->get_debug || $arg->{test_verbose} ? '--verbose' : ();
  
    $self->log_debug('running ' . join(' ', $^X, 'Build', 'test', @testing));
    system $^X, 'Build', 'test', @testing and die "error running $^X Build test\n";
  
    return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::BuildPL - Common ground for Build.PL based builders
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role is a helper for Build.PL based installers. It implements the
  L<Dist::Zilla::Plugin::BuildRunner> and L<Dist::Zilla::Plugin::TestRunner>
  roles, and requires you to implement the L<Dist::Zilla::Plugin::PrereqSource>
  and L<Dist::Zilla::Plugin::InstallTool> roles yourself.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_BUILDPL

$fatpacked{"Dist/Zilla/Role/BuildRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_BUILDRUNNER';
  package Dist::Zilla::Role::BuildRunner 6.007;
  # ABSTRACT: something used as a delegating agent during 'dzil run'
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<build> method called during
  #pod C<dzil run>.  It's passed the root directory of the build test dir.
  #pod
  #pod =head1 REQUIRED METHODS
  #pod
  #pod =head2 build
  #pod
  #pod This method will throw an exception on failure.
  #pod
  #pod =cut
  
  requires 'build';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::BuildRunner - something used as a delegating agent during 'dzil run'
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<build> method called during
  C<dzil run>.  It's passed the root directory of the build test dir.
  
  =head1 REQUIRED METHODS
  
  =head2 build
  
  This method will throw an exception on failure.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_BUILDRUNNER

$fatpacked{"Dist/Zilla/Role/Chrome.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_CHROME';
  package Dist::Zilla::Role::Chrome 6.007;
  # ABSTRACT: something that provides a user interface for Dist::Zilla
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  requires 'logger';
  
  requires 'prompt_str';
  requires 'prompt_yn';
  requires 'prompt_any_key';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::Chrome - something that provides a user interface for Dist::Zilla
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_CHROME

$fatpacked{"Dist/Zilla/Role/ConfigDumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_CONFIGDUMPER';
  package Dist::Zilla::Role::ConfigDumper 6.007;
  # ABSTRACT: something that can dump its (public, simplified) configuration
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  sub dump_config { return {}; }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::ConfigDumper - something that can dump its (public, simplified) configuration
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_CONFIGDUMPER

$fatpacked{"Dist/Zilla/Role/EncodingProvider.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_ENCODINGPROVIDER';
  package Dist::Zilla::Role::EncodingProvider 6.007;
  # ABSTRACT: something that sets a files' encoding
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod EncodingProvider plugins do their work after files are gathered, but before
  #pod they're munged.  They're meant to set the C<encoding> on files.
  #pod
  #pod The method C<set_file_encodings> is called with no arguments.
  #pod
  #pod =cut
  
  requires 'set_file_encodings';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::EncodingProvider - something that sets a files' encoding
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  EncodingProvider plugins do their work after files are gathered, but before
  they're munged.  They're meant to set the C<encoding> on files.
  
  The method C<set_file_encodings> is called with no arguments.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_ENCODINGPROVIDER

$fatpacked{"Dist/Zilla/Role/ExecFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_EXECFILES';
  package Dist::Zilla::Role::ExecFiles 6.007;
  # ABSTRACT: something that finds files to install as executables
  
  use Moose::Role;
  with 'Dist::Zilla::Role::FileFinder';
  
  use namespace::autoclean;
  
  requires 'dir';
  
  sub find_files {
    my ($self) = @_;
  
    my $dir = $self->dir;
    my $files = [
      grep { index($_->name, "$dir/") == 0 }
        @{ $self->zilla->files }
    ];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::ExecFiles - something that finds files to install as executables
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_EXECFILES

$fatpacked{"Dist/Zilla/Role/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILE';
  package Dist::Zilla::Role::File 6.007;
  # ABSTRACT: something that can act like a file
  
  use Moose::Role;
  
  use Dist::Zilla::Types qw(_Filename);
  use Moose::Util::TypeConstraints;
  use Try::Tiny;
  
  use namespace::autoclean;
  
  with 'Dist::Zilla::Role::StubBuild';
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role describes a file that may be written into the shipped distribution.
  #pod
  #pod =attr name
  #pod
  #pod This is the name of the file to be written out.
  #pod
  #pod =cut
  
  has name => (
    is   => 'rw',
    isa  => _Filename,
    required => 1,
  );
  
  #pod =attr added_by
  #pod
  #pod This is a list of strings describing when and why the file was added
  #pod to the distribution and when it was updated (its content, filename, or other attributes).  It will
  #pod generally be updated by a plugin implementing the
  #pod L<FileMunger|Dist::Zilla::Role::FileMunger> role.  Its accessor will return
  #pod the list of strings, concatenated with C<'; '>.
  #pod
  #pod =cut
  
  has added_by => (
    isa => 'ArrayRef[Str]',
    lazy => 1,
    default => sub { [] },
    traits => ['Array'],
    init_arg => undef,
    handles => {
      _push_added_by => 'push',
      added_by => [ join => '; ' ],
    },
  );
  
  around name => sub {
    my $orig = shift;
    my $self = shift;
    if (@_) {
      my ($pkg, $line) = $self->_caller_of('name');
      $self->_push_added_by(sprintf("filename set by %s (%s line %s)", $self->_caller_plugin_name, $pkg, $line));
    }
    return $self->$orig(@_);
  };
  
  sub _caller_of {
    my ($self, $function) = @_;
  
    for (my $level = 1; $level < 50; ++$level)
    {
      my @frame = caller($level);
      last if not defined $frame[0];
      return ( (caller($level))[0,2] ) if $frame[3] =~ m/::${function}$/;
    }
    return 'unknown', '0';
  }
  
  sub _caller_plugin_name {
    my $self = shift;
  
    for (my $level = 1; $level < 50; ++$level)
    {
      my @frame = caller($level);
      last if not defined $frame[0];
      return $1 if $frame[0] =~ m/^Dist::Zilla::Plugin::(.+)$/;
    }
    return 'unknown';
  }
  
  #pod =attr mode
  #pod
  #pod This is the mode with which the file should be written out.  It's an integer
  #pod with the usual C<chmod> semantics.  It defaults to 0644.
  #pod
  #pod =cut
  
  my $safe_file_mode = subtype(
    as 'Int',
    where   { not( $_ & 0002) },
    message { "file mode would be world-writeable" }
  );
  
  has mode => (
    is      => 'rw',
    isa     => $safe_file_mode,
    default => 0644,
  );
  
  requires 'encoding';
  requires 'content';
  requires 'encoded_content';
  
  #pod =method is_bytes
  #pod
  #pod Returns true if the C<encoding> is bytes.  When true, accessing
  #pod C<content> will be an error.
  #pod
  #pod =cut
  
  sub is_bytes {
      my ($self) = @_;
      return $self->encoding eq 'bytes';
  }
  
  sub _encode {
    my ($self, $text) = @_;
    my $enc = $self->encoding;
    if ( $self->is_bytes ) {
      return $text; # XXX hope you were right that it really was bytes
    }
    else {
      require Encode;
      my $bytes =
        try { Encode::encode($enc, $text, Encode::FB_CROAK()) }
        catch { $self->_throw("encode $enc" => $_) };
      return $bytes;
    }
  }
  
  sub _decode {
    my ($self, $bytes) = @_;
    my $enc = $self->encoding;
    if ( $self->is_bytes ) {
      $self->_throw(decode => "Can't decode text from 'bytes' encoding");
    }
    else {
      require Encode;
      my $text =
        try { Encode::decode($enc, $bytes, Encode::FB_CROAK()) }
        catch { $self->_throw("decode $enc" => $_) };
  
      # Okay, look, buddy…  If you're using a BOM on UTF-8, that's fine.  You can
      # use it.  You're just not going to get it back.  If we don't do this, the
      # sequence of events will be:
      # * read file from UTF-8-BOM file on disk
      # * end up with FEFF as first character of file
      # * pass file content to PPI
      # * PPI blows up
      #
      # I'm not going to try to account for the BOM and add it back.  It's awful!
      #
      # Meanwhile, if you're using UTF-16, you can get the BOM handled by picking
      # the right encoding type, I think. -- rjbs, 2016-04-24
      $enc =~ /^utf-?8$/i && $text =~ s/\A\x{FEFF}//;
  
      return $text;
    }
  }
  
  sub _throw {
    my ($self, $op, $msg) = @_;
    my ($name, $added_by) = map {; $self->$_ } qw/name added_by/;
    confess(
      "Could not $op $name; $added_by; error was: $msg; maybe you need the [Encoding] plugin to specify an encoding"
    );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::File - something that can act like a file
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role describes a file that may be written into the shipped distribution.
  
  =head1 ATTRIBUTES
  
  =head2 name
  
  This is the name of the file to be written out.
  
  =head2 added_by
  
  This is a list of strings describing when and why the file was added
  to the distribution and when it was updated (its content, filename, or other attributes).  It will
  generally be updated by a plugin implementing the
  L<FileMunger|Dist::Zilla::Role::FileMunger> role.  Its accessor will return
  the list of strings, concatenated with C<'; '>.
  
  =head2 mode
  
  This is the mode with which the file should be written out.  It's an integer
  with the usual C<chmod> semantics.  It defaults to 0644.
  
  =head1 METHODS
  
  =head2 is_bytes
  
  Returns true if the C<encoding> is bytes.  When true, accessing
  C<content> will be an error.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILE

$fatpacked{"Dist/Zilla/Role/FileFinder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILEFINDER';
  package Dist::Zilla::Role::FileFinder 6.007;
  # ABSTRACT: something that finds files within the distribution
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod A FileFinder plugin locates files within the distribution.  This role exists so
  #pod that sets of files can be easily described in one configuration section and
  #pod then used by one or more other plugin.
  #pod
  #pod Plugins implementing this role must provide a C<find_files> method which will
  #pod be called with no arguments and must return an arrayref of files.  (This
  #pod arrayref should not be re-used, as it may be altered once returned.)
  #pod
  #pod For example, imagine a simple glob-like FileFinder that expects configuration
  #pod like this:
  #pod
  #pod   [Glob / RootModules]
  #pod   glob = *.pm
  #pod
  #pod This sets up a FileFinder named "RootModules" which will contain all F<pm>
  #pod files in the root directory.
  #pod
  #pod Another plugin that knows how to use FileFinder plugins might be configured
  #pod like this:
  #pod
  #pod   [ModuleRelocator]
  #pod   finder = RootModules
  #pod   relocate_to = attic
  #pod
  #pod Finders may operate on any rules they like, checking file size, content, name,
  #pod or other properties.  They should re-perform their "finding" on each call to
  #pod C<find_files> as the files in the distribution may have changed.
  #pod
  #pod =cut
  
  requires 'find_files';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::FileFinder - something that finds files within the distribution
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  A FileFinder plugin locates files within the distribution.  This role exists so
  that sets of files can be easily described in one configuration section and
  then used by one or more other plugin.
  
  Plugins implementing this role must provide a C<find_files> method which will
  be called with no arguments and must return an arrayref of files.  (This
  arrayref should not be re-used, as it may be altered once returned.)
  
  For example, imagine a simple glob-like FileFinder that expects configuration
  like this:
  
    [Glob / RootModules]
    glob = *.pm
  
  This sets up a FileFinder named "RootModules" which will contain all F<pm>
  files in the root directory.
  
  Another plugin that knows how to use FileFinder plugins might be configured
  like this:
  
    [ModuleRelocator]
    finder = RootModules
    relocate_to = attic
  
  Finders may operate on any rules they like, checking file size, content, name,
  or other properties.  They should re-perform their "finding" on each call to
  C<find_files> as the files in the distribution may have changed.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILEFINDER

$fatpacked{"Dist/Zilla/Role/FileFinderUser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILEFINDERUSER';
  package Dist::Zilla::Role::FileFinderUser 6.007;
  # ABSTRACT: something that uses FileFinder plugins
  
  use MooseX::Role::Parameterized 1.01;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role enables you to search for files in the dist. This makes it easy to find specific
  #pod files and have the code factored out to common methods.
  #pod
  #pod Here's an example of a finder: ( taken from AutoPrereqs )
  #pod
  #pod   with 'Dist::Zilla::Role::FileFinderUser' => {
  #pod       default_finders  => [ ':InstallModules', ':ExecFiles' ],
  #pod   };
  #pod
  #pod Then you use it in your code like this:
  #pod
  #pod   foreach my $file ( @{ $self->found_files }) {
  #pod     # $file is an object! Look at L<Dist::Zilla::Role::File>
  #pod   }
  #pod
  #pod =cut
  
  #pod =attr finder_arg_names
  #pod
  #pod Define the name of the attribute which will hold this finder. Be sure to specify different names
  #pod if you have multiple finders!
  #pod
  #pod This is an ArrayRef.
  #pod
  #pod Default: [ qw( finder ) ]
  #pod
  #pod =cut
  
  parameter finder_arg_names => (
    isa => 'ArrayRef',
    default => sub { [ 'finder' ] },
  );
  
  #pod =attr default_finders
  #pod
  #pod This attribute is an arrayref of plugin names for the default plugins the
  #pod consuming plugin will use as finders.
  #pod
  #pod Example: C<< [ qw( :InstallModules :ExecFiles ) ] >>
  #pod
  #pod The default finders are:
  #pod
  #pod =begin :list
  #pod
  #pod = :InstallModules
  #pod
  #pod Searches your lib/ directory for pm/pod files
  #pod
  #pod = :IncModules
  #pod
  #pod Searches your inc/ directory for pm files
  #pod
  #pod = :MainModule
  #pod
  #pod Finds the C<main_module> of your dist
  #pod
  #pod = :TestFiles
  #pod
  #pod Searches your t/ directory and lists the files in it.
  #pod
  #pod = :ExtraTestFiles
  #pod
  #pod Searches your xt/ directory and lists the files in it.
  #pod
  #pod = :ExecFiles
  #pod
  #pod Searches your distribution for executable files.  Hint: Use the
  #pod L<Dist::Zilla::Plugin::ExecDir> plugin to mark those files as executables.
  #pod
  #pod = :PerlExecFiles
  #pod
  #pod A subset of C<:ExecFiles> limited just to perl scripts (those ending with
  #pod F<.pl>, or with a recognizable perl shebang).
  #pod
  #pod = :ShareFiles
  #pod
  #pod Searches your ShareDir directory and lists the files in it.
  #pod Hint: Use the L<Dist::Zilla::Plugin::ShareDir> plugin to set up the sharedir.
  #pod
  #pod = :AllFiles
  #pod
  #pod Returns all files in the distribution.
  #pod
  #pod = :NoFiles
  #pod
  #pod Returns nothing.
  #pod
  #pod =end :list
  #pod
  #pod =cut
  
  parameter default_finders => (
    isa => 'ArrayRef',
    required => 1,
  );
  
  #pod =attr method
  #pod
  #pod This will be the name of the subroutine installed in your package for this
  #pod finder.  Be sure to specify different names if you have multiple finders!
  #pod
  #pod Default: found_files
  #pod
  #pod =cut
  
  parameter method => (
    isa     => 'Str',
    default => 'found_files',
  );
  
  role {
    my ($p) = @_;
  
    my ($finder_arg, @finder_arg_aliases) = @{ $p->finder_arg_names };
    confess "no finder arg names given!" unless $finder_arg;
  
    around mvp_multivalue_args => sub {
      my ($orig, $self) = @_;
  
      my @start = $self->$orig;
      return (@start, $finder_arg);
    };
  
    if (@finder_arg_aliases) {
      around mvp_aliases => sub {
        my ($orig, $self) = @_;
  
        my $start = $self->$orig;
  
        for my $alias (@finder_arg_aliases) {
          confess "$alias is already an alias to $start->{$alias}"
            if exists $start->{$alias} and $orig->{$alias} ne $finder_arg;
          $start->{ $alias } = $finder_arg;
        }
  
        return $start;
      };
    }
  
    has $finder_arg => (
      is  => 'ro',
      isa => 'ArrayRef[Str]',
      default => sub { [ @{ $p->default_finders } ] },
    );
  
    method $p->method => sub {
      my ($self) = @_;
  
      my @filesets = map {; $self->zilla->find_files($_) }
                     @{ $self->$finder_arg };
  
      my %by_name = map {; $_->name, $_ } map { @$_ } @filesets;
  
      return [ map {; $by_name{$_} } sort keys %by_name ];
    };
  };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::FileFinderUser - something that uses FileFinder plugins
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role enables you to search for files in the dist. This makes it easy to find specific
  files and have the code factored out to common methods.
  
  Here's an example of a finder: ( taken from AutoPrereqs )
  
    with 'Dist::Zilla::Role::FileFinderUser' => {
        default_finders  => [ ':InstallModules', ':ExecFiles' ],
    };
  
  Then you use it in your code like this:
  
    foreach my $file ( @{ $self->found_files }) {
      # $file is an object! Look at L<Dist::Zilla::Role::File>
    }
  
  =head1 ATTRIBUTES
  
  =head2 finder_arg_names
  
  Define the name of the attribute which will hold this finder. Be sure to specify different names
  if you have multiple finders!
  
  This is an ArrayRef.
  
  Default: [ qw( finder ) ]
  
  =head2 default_finders
  
  This attribute is an arrayref of plugin names for the default plugins the
  consuming plugin will use as finders.
  
  Example: C<< [ qw( :InstallModules :ExecFiles ) ] >>
  
  The default finders are:
  
  =over 4
  
  =item :InstallModules
  
  Searches your lib/ directory for pm/pod files
  
  =item :IncModules
  
  Searches your inc/ directory for pm files
  
  =item :MainModule
  
  Finds the C<main_module> of your dist
  
  =item :TestFiles
  
  Searches your t/ directory and lists the files in it.
  
  =item :ExtraTestFiles
  
  Searches your xt/ directory and lists the files in it.
  
  =item :ExecFiles
  
  Searches your distribution for executable files.  Hint: Use the
  L<Dist::Zilla::Plugin::ExecDir> plugin to mark those files as executables.
  
  =item :PerlExecFiles
  
  A subset of C<:ExecFiles> limited just to perl scripts (those ending with
  F<.pl>, or with a recognizable perl shebang).
  
  =item :ShareFiles
  
  Searches your ShareDir directory and lists the files in it.
  Hint: Use the L<Dist::Zilla::Plugin::ShareDir> plugin to set up the sharedir.
  
  =item :AllFiles
  
  Returns all files in the distribution.
  
  =item :NoFiles
  
  Returns nothing.
  
  =back
  
  =head2 method
  
  This will be the name of the subroutine installed in your package for this
  finder.  Be sure to specify different names if you have multiple finders!
  
  Default: found_files
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILEFINDERUSER

$fatpacked{"Dist/Zilla/Role/FileGatherer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILEGATHERER';
  package Dist::Zilla::Role::FileGatherer 6.007;
  # ABSTRACT: something that gathers files into the distribution
  
  use Moose::Role;
  with qw/Dist::Zilla::Role::Plugin Dist::Zilla::Role::FileInjector/;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod A FileGatherer plugin is a special sort of
  #pod L<FileInjector|Dist::Zilla::Role::FileInjector> that runs early in the build
  #pod cycle, finding files to include in the distribution.  It is expected to call
  #pod its C<add_file> method to add one or more files to inclusion.
  #pod
  #pod Plugins implementing FileGatherer must provide a C<gather_files> method, which
  #pod will be called during the build process.
  #pod
  #pod =cut
  
  requires 'gather_files';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::FileGatherer - something that gathers files into the distribution
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  A FileGatherer plugin is a special sort of
  L<FileInjector|Dist::Zilla::Role::FileInjector> that runs early in the build
  cycle, finding files to include in the distribution.  It is expected to call
  its C<add_file> method to add one or more files to inclusion.
  
  Plugins implementing FileGatherer must provide a C<gather_files> method, which
  will be called during the build process.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILEGATHERER

$fatpacked{"Dist/Zilla/Role/FileInjector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILEINJECTOR';
  package Dist::Zilla::Role::FileInjector 6.007;
  # ABSTRACT: something that can add files to the distribution
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role should be implemented by any plugin that plans to add files into the
  #pod distribution.  It provides one method (C<L</add_file>>, documented below),
  #pod which adds a file to the distribution, noting the place of addition.
  #pod
  #pod =method add_file
  #pod
  #pod   $plugin->add_file($dzil_file);
  #pod
  #pod This adds a file to the distribution, setting the file's C<added_by> attribute
  #pod as it does so.
  #pod
  #pod =cut
  
  sub add_file {
    my ($self, $file) = @_;
    my ($pkg, undef, $line) = caller;
  
    $file->_set_added_by(
      sprintf("%s (%s line %s)", $self->plugin_name, $pkg, $line),
    );
  
    $self->log_debug([ 'adding file %s', $file->name ]);
    push @{ $self->zilla->files }, $file;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::FileInjector - something that can add files to the distribution
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role should be implemented by any plugin that plans to add files into the
  distribution.  It provides one method (C<L</add_file>>, documented below),
  which adds a file to the distribution, noting the place of addition.
  
  =head1 METHODS
  
  =head2 add_file
  
    $plugin->add_file($dzil_file);
  
  This adds a file to the distribution, setting the file's C<added_by> attribute
  as it does so.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILEINJECTOR

$fatpacked{"Dist/Zilla/Role/FileMunger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILEMUNGER';
  package Dist::Zilla::Role::FileMunger 6.007;
  # ABSTRACT: something that alters a file's destination or content
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod A FileMunger has an opportunity to mess around with each file that will be
  #pod included in the distribution.  Each FileMunger's C<munge_files> method is
  #pod called once.  By default, this method will just call the C<munge_file> method
  #pod (note the missing terminal 's') once for each file, excluding files with an
  #pod encoding attribute of 'bytes'.
  #pod
  #pod The C<munge_file> method is expected to change attributes about the file before
  #pod it is written out to the built distribution.
  #pod
  #pod If you want to modify all files (including ones with an encoding of 'bytes') or
  #pod want to select a more limited set of files, you can provide your own
  #pod C<munge_files> method.
  #pod
  #pod =cut
  
  sub munge_files {
    my ($self) = @_;
  
    $self->log_fatal("no munge_file behavior implemented!")
      unless $self->can('munge_file');
  
    my @files = @{ $self->zilla->files };
    for my $file ( @files ) {
      if ($file->is_bytes) {
        $self->log_debug($file->name . " has 'bytes' encoding, skipping...");
        next;
      }
  
      $self->munge_file($file);
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::FileMunger - something that alters a file's destination or content
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  A FileMunger has an opportunity to mess around with each file that will be
  included in the distribution.  Each FileMunger's C<munge_files> method is
  called once.  By default, this method will just call the C<munge_file> method
  (note the missing terminal 's') once for each file, excluding files with an
  encoding attribute of 'bytes'.
  
  The C<munge_file> method is expected to change attributes about the file before
  it is written out to the built distribution.
  
  If you want to modify all files (including ones with an encoding of 'bytes') or
  want to select a more limited set of files, you can provide your own
  C<munge_files> method.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILEMUNGER

$fatpacked{"Dist/Zilla/Role/FilePruner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_FILEPRUNER';
  package Dist::Zilla::Role::FilePruner 6.007;
  # ABSTRACT: something that removes found files from the distribution
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing FilePruner have their C<prune_files> method called once
  #pod all the L<FileGatherer|Dist::Zilla::Role::FileGatherer> plugins have been
  #pod called.  They are expected to (optionally) remove files from the list of files
  #pod to be included in the distribution.
  #pod
  #pod =cut
  
  requires 'prune_files';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::FilePruner - something that removes found files from the distribution
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing FilePruner have their C<prune_files> method called once
  all the L<FileGatherer|Dist::Zilla::Role::FileGatherer> plugins have been
  called.  They are expected to (optionally) remove files from the list of files
  to be included in the distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_FILEPRUNER

$fatpacked{"Dist/Zilla/Role/InstallTool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_INSTALLTOOL';
  package Dist::Zilla::Role::InstallTool 6.007;
  # ABSTRACT: something that creates an install program for a dist
  
  use Moose::Role;
  with qw(
    Dist::Zilla::Role::Plugin
    Dist::Zilla::Role::FileInjector
  );
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing InstallTool have their C<setup_installer> method called to
  #pod inject files after all other file injection and munging has taken place.
  #pod They're expected to produce files needed to make the distribution
  #pod installable, like F<Makefile.PL> or F<Build.PL> and add them with the
  #pod C<add_file> method provided by L<Dist::Zilla::Role::FileInjector>, which is
  #pod also composed by this role.
  #pod
  #pod =cut
  
  requires 'setup_installer';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::InstallTool - something that creates an install program for a dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing InstallTool have their C<setup_installer> method called to
  inject files after all other file injection and munging has taken place.
  They're expected to produce files needed to make the distribution
  installable, like F<Makefile.PL> or F<Build.PL> and add them with the
  C<add_file> method provided by L<Dist::Zilla::Role::FileInjector>, which is
  also composed by this role.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_INSTALLTOOL

$fatpacked{"Dist/Zilla/Role/LicenseProvider.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_LICENSEPROVIDER';
  package Dist::Zilla::Role::LicenseProvider 6.007;
  # ABSTRACT: something that provides a license for the dist
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role must provide a C<provide_license> method that
  #pod will be called when setting the dist's license.
  #pod
  #pod If a LicenseProvider offers a license but one has already been set, an
  #pod exception will be raised.  If C<provides_license> returns undef, it will be
  #pod ignored.
  #pod
  #pod =head1 REQUIRED METHODS
  #pod
  #pod =head2 C<< provide_license({ copyright_holder => $holder, copyright_year => $year }) >>
  #pod
  #pod Generate license object. Returned object should be an instance of
  #pod L<Software::License>.
  #pod
  #pod Plugins are responsible for injecting C<$copyright_holder> and
  #pod C<$copyright_year> arguments into the license if these arguments are defined.
  #pod
  #pod =cut
  
  requires 'provide_license';
  
  no Moose::Role;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::LicenseProvider - something that provides a license for the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role must provide a C<provide_license> method that
  will be called when setting the dist's license.
  
  If a LicenseProvider offers a license but one has already been set, an
  exception will be raised.  If C<provides_license> returns undef, it will be
  ignored.
  
  =head1 REQUIRED METHODS
  
  =head2 C<< provide_license({ copyright_holder => $holder, copyright_year => $year }) >>
  
  Generate license object. Returned object should be an instance of
  L<Software::License>.
  
  Plugins are responsible for injecting C<$copyright_holder> and
  C<$copyright_year> arguments into the license if these arguments are defined.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_LICENSEPROVIDER

$fatpacked{"Dist/Zilla/Role/MetaProvider.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_METAPROVIDER';
  package Dist::Zilla::Role::MetaProvider 6.007;
  # ABSTRACT: something that provides metadata (for META.yml/json)
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role provides data to merge into the distribution metadata.
  #pod
  #pod =method metadata
  #pod
  #pod This method (which must be provided by classes implementing this role)
  #pod returns a hashref of data to be (deeply) merged together with pre-existing
  #pod metadata.
  #pod
  #pod =cut
  
  requires 'metadata';
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::MetaProvider - something that provides metadata (for META.yml/json)
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role provides data to merge into the distribution metadata.
  
  =head1 METHODS
  
  =head2 metadata
  
  This method (which must be provided by classes implementing this role)
  returns a hashref of data to be (deeply) merged together with pre-existing
  metadata.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins implementing this role:
  L<ConfigMeta|Dist::Zilla::Plugin::ConfigMeta>.
  L<MetaNoIndex|Dist::Zilla::Plugin::MetaNoIndex>.
  
  Dist::Zilla plugins on the CPAN:
  L<GithubMeta|Dist::Zilla::Plugin::GithubMeta>...
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins implementing this role:
  #pod L<ConfigMeta|Dist::Zilla::Plugin::ConfigMeta>.
  #pod L<MetaNoIndex|Dist::Zilla::Plugin::MetaNoIndex>.
  #pod
  #pod Dist::Zilla plugins on the CPAN:
  #pod L<GithubMeta|Dist::Zilla::Plugin::GithubMeta>...
  #pod
  #pod =cut
DIST_ZILLA_ROLE_METAPROVIDER

$fatpacked{"Dist/Zilla/Role/MintingProfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_MINTINGPROFILE';
  package Dist::Zilla::Role::MintingProfile 6.007;
  # ABSTRACT: something that can find a minting profile dir
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  use Dist::Zilla::Path;
  use File::ShareDir;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role should provide C<profile_dir> method, which,
  #pod given a minting profile name, returns its directory.
  #pod
  #pod The minting profile is a directory, containing arbitrary files used during
  #pod creation of new distribution. Among other things notably, it should contain the
  #pod 'profile.ini' file, listing the plugins used for minter initialization.
  #pod
  #pod The default implementation C<profile_dir> looks in the module's
  #pod L<ShareDir|File::ShareDir>.
  #pod
  #pod After installing your profile, users will be able to start a new distribution,
  #pod based on your profile with the:
  #pod
  #pod   $ dzil new -P Provider -p profile_name Distribution::Name
  #pod
  #pod =cut
  
  requires 'profile_dir';
  
  around profile_dir => sub {
    my ($orig, $self, @args) = @_;
    path($self->$orig(@args));
  };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::MintingProfile - something that can find a minting profile dir
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role should provide C<profile_dir> method, which,
  given a minting profile name, returns its directory.
  
  The minting profile is a directory, containing arbitrary files used during
  creation of new distribution. Among other things notably, it should contain the
  'profile.ini' file, listing the plugins used for minter initialization.
  
  The default implementation C<profile_dir> looks in the module's
  L<ShareDir|File::ShareDir>.
  
  After installing your profile, users will be able to start a new distribution,
  based on your profile with the:
  
    $ dzil new -P Provider -p profile_name Distribution::Name
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_MINTINGPROFILE

$fatpacked{"Dist/Zilla/Role/MintingProfile/ShareDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_MINTINGPROFILE_SHAREDIR';
  package Dist::Zilla::Role::MintingProfile::ShareDir 6.007;
  # ABSTRACT: something that keeps its minting profile in a sharedir
  
  use Moose::Role;
  with 'Dist::Zilla::Role::MintingProfile';
  
  use namespace::autoclean;
  
  use File::ShareDir;
  use Dist::Zilla::Path;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role includes L<Dist::Zilla::Role::MintingProfile>, providing a
  #pod C<profile_dir> method that looks in the I<module>'s L<ShareDir|File::ShareDir>.
  #pod
  #pod =cut
  
  sub profile_dir {
    my ($self, $profile_name) = @_;
  
    my $profile_dir = path( File::ShareDir::module_dir($self->meta->name) )
                    ->child( $profile_name );
  
    return $profile_dir if -d $profile_dir;
  
    confess "Can't find profile $profile_name via $self";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::MintingProfile::ShareDir - something that keeps its minting profile in a sharedir
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role includes L<Dist::Zilla::Role::MintingProfile>, providing a
  C<profile_dir> method that looks in the I<module>'s L<ShareDir|File::ShareDir>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_MINTINGPROFILE_SHAREDIR

$fatpacked{"Dist/Zilla/Role/ModuleMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_MODULEMAKER';
  package Dist::Zilla::Role::ModuleMaker 6.007;
  # ABSTRACT: something that injects module files into the dist
  
  use Moose::Role;
  with qw(
    Dist::Zilla::Role::Plugin
    Dist::Zilla::Role::FileInjector
  );
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<make_module> method called for each
  #pod module requesting creation by the plugin with this name.  It is passed a
  #pod hashref with the following data:
  #pod
  #pod   name - the name of the module to make (a MooseX::Types::Perl::ModuleName)
  #pod
  #pod Classes composing this role also compose
  #pod L<FileInjector|Dist::Zilla::Role::FileInjector> and are expected to inject a
  #pod file for the module being created.
  #pod
  #pod =cut
  
  requires 'make_module';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::ModuleMaker - something that injects module files into the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<make_module> method called for each
  module requesting creation by the plugin with this name.  It is passed a
  hashref with the following data:
  
    name - the name of the module to make (a MooseX::Types::Perl::ModuleName)
  
  Classes composing this role also compose
  L<FileInjector|Dist::Zilla::Role::FileInjector> and are expected to inject a
  file for the module being created.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_MODULEMAKER

$fatpacked{"Dist/Zilla/Role/MutableFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_MUTABLEFILE';
  package Dist::Zilla::Role::MutableFile 6.007;
  # ABSTRACT: something that can act like a file with changeable contents
  
  use Moose::Role;
  
  use Moose::Util::TypeConstraints;
  use MooseX::SetOnce;
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role describes a file whose contents may be modified
  #pod
  #pod =attr encoding
  #pod
  #pod Default is 'UTF-8'. Can only be set once.
  #pod
  #pod =cut
  
  with 'Dist::Zilla::Role::File';
  
  sub encoding;
  
  has encoding => (
    is          => 'rw',
    isa         => 'Str',
    lazy        => 1,
    default     => 'UTF-8',
    traits      => [ qw(SetOnce) ],
  );
  
  #pod =attr content
  #pod
  #pod =cut
  
  has _content => (
    is          => 'rw',
    isa         => 'Str',
    lazy        => 1,
    builder     => '_build_content',
    clearer     => 'clear_content',
    predicate   => 'has_content',
  );
  
  sub content {
    my $self = shift;
    if ( ! @_ ) {
      # if we have it or we're tasked to provide it, return it (possibly lazily
      # generated from a builder); otherwise, get it from the encoded_content
      if ( $self->has_content || $self->_content_source eq 'content' ) {
        return $self->_content;
      }
      else {
        return $self->_content($self->_decode($self->encoded_content));
      }
    }
    else {
      my ($pkg, $line) = $self->_caller_of('content');
      $self->_content_source('content');
      $self->_push_added_by(sprintf("content set by %s (%s line %s)", $self->_caller_plugin_name, $pkg, $line));
      $self->clear_encoded_content;
      return $self->_content(@_);
    }
  }
  
  #pod =attr encoded_content
  #pod
  #pod =cut
  
  has _encoded_content => (
    is          => 'rw',
    isa         => 'Str',
    lazy        => 1,
    builder     => '_build_encoded_content',
    clearer     => 'clear_encoded_content',
    predicate   => 'has_encoded_content',
  );
  
  sub encoded_content {
    my $self = shift;
    if ( ! @_ ) {
      # if we have it or we're tasked to provide it, return it (possibly lazily
      # generated from a builder); otherwise, get it from the content
      if ($self->has_encoded_content || $self->_content_source eq 'encoded_content') {
        return $self->_encoded_content;
      }
      else {
        return $self->_encoded_content($self->_encode($self->content));
      }
    }
    my ($pkg, $line) = $self->_caller_of('encoded_content');
    $self->_content_source('encoded_content');
    $self->_push_added_by(sprintf("encoded_content set by %s (%s line %s)", $self->_caller_plugin_name, $pkg, $line));
    $self->clear_content;
    $self->_encoded_content(@_);
  }
  
  has _content_source => (
      is => 'rw',
      isa => enum([qw/content encoded_content/]),
      lazy => 1,
      builder => '_build_content_source',
  );
  
  sub _set_added_by {
    my ($self, $value) = @_;
    return $self->_push_added_by(sprintf("%s added by %s", $self->_content_source, $value));
  };
  
  # we really only need one of these and only if _content or _encoded_content
  # isn't provided, but roles can't do that, so we'll insist on both just in case
  # and let classes provide stubs if they provide _content or _encoded_content
  # another way
  
  requires '_build_content';
  requires '_build_encoded_content';
  
  # we need to know the content source so we know where we might need to rely on
  # lazy loading to give us content. It should be set by the class if there is a
  # class-wide default or just stubbed if a BUILD modifier sets it per-object.
  
  requires '_build_content_source';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::MutableFile - something that can act like a file with changeable contents
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role describes a file whose contents may be modified
  
  =head1 ATTRIBUTES
  
  =head2 encoding
  
  Default is 'UTF-8'. Can only be set once.
  
  =head2 content
  
  =head2 encoded_content
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_MUTABLEFILE

$fatpacked{"Dist/Zilla/Role/NameProvider.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_NAMEPROVIDER';
  package Dist::Zilla::Role::NameProvider 6.007;
  # ABSTRACT: something that provides a name for the dist
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role must provide a C<provide_name> method that
  #pod will be called when setting the dist's name.
  #pod
  #pod If a NameProvider offers a name but one has already been set, an
  #pod exception will be raised.  If C<provide_name> returns undef, it will be
  #pod ignored.
  #pod
  #pod =cut
  
  requires 'provide_name';
  
  no Moose::Role;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::NameProvider - something that provides a name for the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role must provide a C<provide_name> method that
  will be called when setting the dist's name.
  
  If a NameProvider offers a name but one has already been set, an
  exception will be raised.  If C<provide_name> returns undef, it will be
  ignored.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_NAMEPROVIDER

$fatpacked{"Dist/Zilla/Role/PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_PPI';
  package Dist::Zilla::Role::PPI 6.007;
  # ABSTRACT: a role for plugins which use PPI
  
  use Moose::Role;
  use Digest::MD5 qw(md5);
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This role provides some common utilities for plugins which use L<PPI>.
  #pod
  #pod =method ppi_document_for_file
  #pod
  #pod   my $document = $self->ppi_document_for_file($file);
  #pod
  #pod Given a dzil file object (anything that does L<Dist::Zilla::Role::File>), this
  #pod method returns a new L<PPI::Document> for that file's content.
  #pod
  #pod Internally, this method caches these documents. If multiple plugins want a
  #pod document for the same file, this avoids reparsing it.
  #pod
  #pod =cut
  
  my %CACHE;
  
  sub ppi_document_for_file {
    my ($self, $file) = @_;
  
    my $encoded_content = $file->encoded_content;
  
    # We cache on the MD5 checksum to detect if the document has been modified
    # by some other plugin since it was last parsed, making our document invalid.
    my $md5 = md5($encoded_content);
    return $CACHE{$md5}->clone if $CACHE{$md5};
  
    my $content = $file->content;
  
    require PPI::Document;
    my $document = PPI::Document->new(\$content)
      or Carp::croak(PPI::Document->errstr . ' while processing file ' . $file->name);
  
    return ($CACHE{$md5} = $document)->clone;
  }
  
  #pod =method save_ppi_document_to_file
  #pod
  #pod   my $document = $self->save_ppi_document_to_file($document,$file);
  #pod
  #pod Given a L<PPI::Document> and a dzil file object (anything that does
  #pod L<Dist::Zilla::Role::File>), this method saves the serialized document in the
  #pod file.
  #pod
  #pod It also updates the internal PPI document cache with the new document.
  #pod
  #pod =cut
  
  sub save_ppi_document_to_file {
    my ($self, $document, $file) = @_;
  
    my $new_content = $document->serialize;
  
    $file->content($new_content);
  
    my $encoded = $file->encoded_content;
  
    $CACHE{ md5($encoded) } = $document->clone;
  }
  
  #pod =method document_assigns_to_variable
  #pod
  #pod   if( $self->ppi_document_for_file($document, '$FOO')) { ... }
  #pod
  #pod This method returns true if the document assigns to the given variable (the
  #pod sigil must be included).
  #pod
  #pod =cut
  
  sub document_assigns_to_variable {
    my ($self, $document, $variable) = @_;
  
    my $package_stmts = $document->find('PPI::Statement::Package');
    my @namespaces = map { $_->namespace } @{ $package_stmts || []};
  
    my ($sigil, $varname) = ($variable =~ m'^([$@%*])(.+)$');
  
    my $package;
    my $finder = sub {
      my $node = $_[1];
  
      if ($node->isa('PPI::Statement')
        && !$node->isa('PPI::Statement::End')
        && !$node->isa('PPI::Statement::Data')) {
  
        if ($node->isa('PPI::Statement::Variable')) {
          return (grep { $_ eq $variable } $node->variables) ? 1 : undef;
        }
  
        return 1 if grep {
          my $child = $_;
          $child->isa('PPI::Token::Symbol')
            and grep {
              $child->canonical eq "${sigil}${_}::${varname}"
                  and $node->content =~ /\Q${sigil}${_}::${varname}\E.*=/
            } @namespaces
        } $node->children;
      }
      return 0;   # not found
    };
  
    my $rv = $document->find_any($finder);
    Carp::croak($document->errstr) unless defined $rv;
  
    return $rv;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::PPI - a role for plugins which use PPI
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  This role provides some common utilities for plugins which use L<PPI>.
  
  =head1 METHODS
  
  =head2 ppi_document_for_file
  
    my $document = $self->ppi_document_for_file($file);
  
  Given a dzil file object (anything that does L<Dist::Zilla::Role::File>), this
  method returns a new L<PPI::Document> for that file's content.
  
  Internally, this method caches these documents. If multiple plugins want a
  document for the same file, this avoids reparsing it.
  
  =head2 save_ppi_document_to_file
  
    my $document = $self->save_ppi_document_to_file($document,$file);
  
  Given a L<PPI::Document> and a dzil file object (anything that does
  L<Dist::Zilla::Role::File>), this method saves the serialized document in the
  file.
  
  It also updates the internal PPI document cache with the new document.
  
  =head2 document_assigns_to_variable
  
    if( $self->ppi_document_for_file($document, '$FOO')) { ... }
  
  This method returns true if the document assigns to the given variable (the
  sigil must be included).
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_PPI

$fatpacked{"Dist/Zilla/Role/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_PLUGIN';
  package Dist::Zilla::Role::Plugin 6.007;
  # ABSTRACT: something that gets plugged in to Dist::Zilla
  
  use Moose::Role;
  with 'Dist::Zilla::Role::ConfigDumper';
  
  use Params::Util qw(_HASHLIKE);
  use Moose::Util::TypeConstraints 'class_type';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod The Plugin role should be applied to all plugin classes.  It provides a few key
  #pod methods and attributes that all plugins will need.
  #pod
  #pod =attr plugin_name
  #pod
  #pod The plugin name is generally determined when configuration is read.
  #pod
  #pod =cut
  
  has plugin_name => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  #pod =attr zilla
  #pod
  #pod This attribute contains the Dist::Zilla object into which the plugin was
  #pod plugged.
  #pod
  #pod =cut
  
  has zilla => (
    is  => 'ro',
    isa => class_type('Dist::Zilla'),
    required => 1,
    weak_ref => 1,
  );
  
  #pod =method log
  #pod
  #pod The plugin's C<log> method delegates to the Dist::Zilla object's
  #pod L<Dist::Zilla/log> method after including a bit of argument-munging.
  #pod
  #pod =cut
  
  has logger => (
    is   => 'ro',
    lazy => 1,
    handles => [ qw(log log_debug log_fatal) ],
    default => sub {
      $_[0]->zilla->chrome->logger->proxy({
        proxy_prefix => '[' . $_[0]->plugin_name . '] ',
      });
    },
  );
  
  # We define these effectively-pointless subs here to allow other roles to
  # modify them with around. -- rjbs, 2010-03-21
  sub mvp_multivalue_args {};
  sub mvp_aliases         { return {} };
  
  sub plugin_from_config {
    my ($class, $name, $arg, $section) = @_;
  
    my $self = $class->new({
      %$arg,
      plugin_name => $name,
      zilla       => $section->sequence->assembler->zilla,
    });
  }
  
  sub register_component {
    my ($class, $name, $arg, $section) = @_;
  
    my $self = $class->plugin_from_config($name, $arg, $section);
  
    my $version = $self->VERSION || 0;
  
    $self->log_debug([ 'online, %s v%s', $self->meta->name, $version ]);
  
    push @{ $self->zilla->plugins }, $self;
  
    return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::Plugin - something that gets plugged in to Dist::Zilla
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  The Plugin role should be applied to all plugin classes.  It provides a few key
  methods and attributes that all plugins will need.
  
  =head1 ATTRIBUTES
  
  =head2 plugin_name
  
  The plugin name is generally determined when configuration is read.
  
  =head2 zilla
  
  This attribute contains the Dist::Zilla object into which the plugin was
  plugged.
  
  =head1 METHODS
  
  =head2 log
  
  The plugin's C<log> method delegates to the Dist::Zilla object's
  L<Dist::Zilla/log> method after including a bit of argument-munging.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_PLUGIN

$fatpacked{"Dist/Zilla/Role/PluginBundle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_PLUGINBUNDLE';
  package Dist::Zilla::Role::PluginBundle 6.007;
  # ABSTRACT: something that bundles a bunch of plugins
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod When loading configuration, if the config reader encounters a PluginBundle, it
  #pod will replace its place in the plugin list with the result of calling its
  #pod C<bundle_config> method, which will be passed a Config::MVP::Section to
  #pod configure the bundle.
  #pod
  #pod =cut
  
  sub register_component {
    my ($class, $name, $arg, $self) = @_;
    # ... we should register a placeholder so MetaConfig can tell us about the
    # pluginbundle that was loaded
  }
  
  requires 'bundle_config';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::PluginBundle - something that bundles a bunch of plugins
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  When loading configuration, if the config reader encounters a PluginBundle, it
  will replace its place in the plugin list with the result of calling its
  C<bundle_config> method, which will be passed a Config::MVP::Section to
  configure the bundle.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_PLUGINBUNDLE

$fatpacked{"Dist/Zilla/Role/PluginBundle/Easy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_PLUGINBUNDLE_EASY';
  package Dist::Zilla::Role::PluginBundle::Easy 6.007;
  # ABSTRACT: something that bundles a bunch of plugins easily
  # This plugin was originally contributed by Christopher J. Madsen
  
  use Moose::Role;
  with 'Dist::Zilla::Role::PluginBundle';
  
  use namespace::autoclean;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   package Dist::Zilla::PluginBundle::Example;
  #pod   use Moose;
  #pod   with 'Dist::Zilla::Role::PluginBundle::Easy';
  #pod
  #pod   sub configure {
  #pod     my $self = shift;
  #pod
  #pod     $self->add_plugins('VersionFromModule');
  #pod     $self->add_bundle('Basic');
  #pod   }
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This role builds upon the PluginBundle role, adding methods to take most of the
  #pod grunt work out of creating a bundle.  It supplies the C<bundle_config> method
  #pod for you.  In exchange, you must supply a C<configure> method, which will store
  #pod the bundle's configuration in the C<plugins> attribute by calling
  #pod C<add_plugins> and/or C<add_bundle>.
  #pod
  #pod =cut
  
  use MooseX::Types::Moose qw(Str ArrayRef HashRef);
  
  use String::RewritePrefix 0.005
    rewrite => {
      -as => '_plugin_class',
      prefixes => { '' => 'Dist::Zilla::Plugin::', '=' => '' },
    },
    rewrite => {
      -as => '_bundle_class',
      prefixes => {
        ''  => 'Dist::Zilla::PluginBundle::',
        '@' => 'Dist::Zilla::PluginBundle::',
        '=' => ''
      },
    };
  
  use namespace::autoclean;
  
  requires 'configure';
  
  #pod =attr name
  #pod
  #pod This is the bundle name, taken from the Section passed to
  #pod C<bundle_config>.
  #pod
  #pod =cut
  
  has name => (
    is       => 'ro',
    isa      => Str,
    required => 1,
  );
  
  #pod =attr payload
  #pod
  #pod This hashref contains the bundle's parameters (if any), taken from the
  #pod Section passed to C<bundle_config>.
  #pod
  #pod =cut
  
  has payload => (
    is       => 'ro',
    isa      => HashRef,
    required => 1,
  );
  
  #pod =attr plugins
  #pod
  #pod This arrayref contains the configuration that will be returned by
  #pod C<bundle_config>.  You normally modify this by using the
  #pod C<add_plugins> and C<add_bundle> methods.
  #pod
  #pod =cut
  
  has plugins => (
    is       => 'ro',
    isa      => ArrayRef,
    default  => sub { [] },
  );
  
  sub bundle_config {
    my ($class, $section) = @_;
  
    my $self = $class->new($section);
  
    $self->configure;
  
    return @{ $self->plugins };
  }
  
  #pod =method add_plugins
  #pod
  #pod   $self->add_plugins('Plugin1', [ Plugin2 => \%plugin2config ])
  #pod
  #pod Use this method to add plugins to your bundle.
  #pod
  #pod It is passed a list of plugin specifiers, which can be one of a few things:
  #pod
  #pod =for :list
  #pod * a plugin moniker (like you might provide in your config file)
  #pod * an arrayref of: C<< [ $moniker, $plugin_name, \%plugin_config ] >>
  #pod
  #pod In the case of an arrayref, both C<$plugin_name> and C<\%plugin_config> are
  #pod optional.
  #pod
  #pod The plugins are added to the config in the order given.
  #pod
  #pod =cut
  
  sub add_plugins {
    my ($self, @plugin_specs) = @_;
  
    my $prefix  = $self->name . '/';
    my $plugins = $self->plugins;
  
    foreach my $this_spec (@plugin_specs) {
      my $moniker;
      my $name;
      my $payload;
  
      if (! ref $this_spec) {
        ($moniker, $name, $payload) = ($this_spec, $this_spec, {});
      } elsif (@$this_spec == 1) {
        ($moniker, $name, $payload) = ($this_spec->[0], $this_spec->[0], {});
      } elsif (@$this_spec == 2) {
        $moniker = $this_spec->[0];
        $name    = ref $this_spec->[1] ? $moniker : $this_spec->[1];
        $payload = ref $this_spec->[1] ? $this_spec->[1] : {};
      } else {
        ($moniker, $name, $payload) = @$this_spec;
      }
  
      push @$plugins, [ $prefix . $name => _plugin_class($moniker) => $payload ];
    }
  }
  
  #pod =method add_bundle
  #pod
  #pod   $self->add_bundle(BundleName => \%bundle_config)
  #pod
  #pod Use this method to add all the plugins from another bundle to your bundle.  If
  #pod you omit C<%bundle_config>, an empty hashref will be supplied.
  #pod
  #pod =cut
  
  sub add_bundle {
    my ($self, $bundle, $payload) = @_;
  
    my $package = _bundle_class($bundle);
    $payload  ||= {};
  
    my $load_opts = {};
    if( my $v = $payload->{':version'} ){
      $load_opts->{'-version'} = $v;
    }
    Class::Load::load_class($package, $load_opts);
  
    $bundle = "\@$bundle" unless $bundle =~ /^@/;
  
    push @{ $self->plugins },
      $package->bundle_config({
        name    => $self->name . '/' . $bundle,
        package => $package,
        payload => $payload,
      });
  }
  
  #pod =method config_slice
  #pod
  #pod   $hash_ref = $self->config_slice(arg1, { arg2 => 'plugin_arg2' })
  #pod
  #pod Use this method to extract parameters from your bundle's C<payload> so
  #pod that you can pass them to a plugin or subsidiary bundle.  It supports
  #pod easy renaming of parameters, since a plugin may expect a parameter
  #pod name that's too generic to be suitable for a bundle.
  #pod
  #pod Each arg is either a key in C<payload>, or a hashref that maps keys in
  #pod C<payload> to keys in the hash being constructed.  If any specified
  #pod key does not exist in C<payload>, then it is omitted from the result.
  #pod
  #pod =cut
  
  sub config_slice {
    my $self = shift;
  
    my $payload = $self->payload;
  
    my %arg;
  
    foreach my $arg (@_) {
      if (ref $arg) {
        while (my ($in, $out) = each %$arg) {
          $arg{$out} = $payload->{$in} if exists $payload->{$in};
        }
      } else {
        $arg{$arg} = $payload->{$arg} if exists $payload->{$arg};
      }
    }
  
    return \%arg;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::PluginBundle::Easy - something that bundles a bunch of plugins easily
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
    package Dist::Zilla::PluginBundle::Example;
    use Moose;
    with 'Dist::Zilla::Role::PluginBundle::Easy';
  
    sub configure {
      my $self = shift;
  
      $self->add_plugins('VersionFromModule');
      $self->add_bundle('Basic');
    }
  
  =head1 DESCRIPTION
  
  This role builds upon the PluginBundle role, adding methods to take most of the
  grunt work out of creating a bundle.  It supplies the C<bundle_config> method
  for you.  In exchange, you must supply a C<configure> method, which will store
  the bundle's configuration in the C<plugins> attribute by calling
  C<add_plugins> and/or C<add_bundle>.
  
  =head1 ATTRIBUTES
  
  =head2 name
  
  This is the bundle name, taken from the Section passed to
  C<bundle_config>.
  
  =head2 payload
  
  This hashref contains the bundle's parameters (if any), taken from the
  Section passed to C<bundle_config>.
  
  =head2 plugins
  
  This arrayref contains the configuration that will be returned by
  C<bundle_config>.  You normally modify this by using the
  C<add_plugins> and C<add_bundle> methods.
  
  =head1 METHODS
  
  =head2 add_plugins
  
    $self->add_plugins('Plugin1', [ Plugin2 => \%plugin2config ])
  
  Use this method to add plugins to your bundle.
  
  It is passed a list of plugin specifiers, which can be one of a few things:
  
  =over 4
  
  =item *
  
  a plugin moniker (like you might provide in your config file)
  
  =item *
  
  an arrayref of: C<< [ $moniker, $plugin_name, \%plugin_config ] >>
  
  =back
  
  In the case of an arrayref, both C<$plugin_name> and C<\%plugin_config> are
  optional.
  
  The plugins are added to the config in the order given.
  
  =head2 add_bundle
  
    $self->add_bundle(BundleName => \%bundle_config)
  
  Use this method to add all the plugins from another bundle to your bundle.  If
  you omit C<%bundle_config>, an empty hashref will be supplied.
  
  =head2 config_slice
  
    $hash_ref = $self->config_slice(arg1, { arg2 => 'plugin_arg2' })
  
  Use this method to extract parameters from your bundle's C<payload> so
  that you can pass them to a plugin or subsidiary bundle.  It supports
  easy renaming of parameters, since a plugin may expect a parameter
  name that's too generic to be suitable for a bundle.
  
  Each arg is either a key in C<payload>, or a hashref that maps keys in
  C<payload> to keys in the hash being constructed.  If any specified
  key does not exist in C<payload>, then it is omitted from the result.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_PLUGINBUNDLE_EASY

$fatpacked{"Dist/Zilla/Role/PrereqScanner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_PREREQSCANNER';
  package Dist::Zilla::Role::PrereqScanner 6.007;
  # ABSTRACT: automatically extract prereqs from your modules
  
  use Moose::Role;
  with(
    'Dist::Zilla::Role::FileFinderUser' => {
      default_finders => [ ':InstallModules', ':ExecFiles' ],
    },
    'Dist::Zilla::Role::FileFinderUser' => {
      method           => 'found_test_files',
      finder_arg_names => [ 'test_finder' ],
      default_finders  => [ ':TestFiles' ],
    },
    'Dist::Zilla::Role::FileFinderUser' => {
      method           => 'found_configure_files',
      finder_arg_names => [ 'configure_finder' ],
      default_finders  => [],
    },
    'Dist::Zilla::Role::FileFinderUser' => {
      method           => 'found_develop_files',
      finder_arg_names => [ 'develop_finder' ],
      default_finders  => [ ':ExtraTestFiles' ],
    },
  );
  
  use MooseX::Types;
  
  #pod =attr finder
  #pod
  #pod This is the name of a L<FileFinder|Dist::Zilla::Role::FileFinder>
  #pod whose files will be scanned to determine runtime prerequisites.  It
  #pod may be specified multiple times.  The default value is
  #pod C<:InstallModules> and C<:ExecFiles>.
  #pod
  #pod =attr test_finder
  #pod
  #pod Just like C<finder>, but for test-phase prerequisites.  The default
  #pod value is C<:TestFiles>.
  #pod
  #pod =attr configure_finder
  #pod
  #pod Just like C<finder>, but for configure-phase prerequisites.  There is
  #pod no default value; AutoPrereqs will not determine configure-phase
  #pod prerequisites unless you set configure_finder.
  #pod
  #pod =attr develop_finder
  #pod
  #pod Just like <finder>, but for develop-phase prerequisites.  The default value
  #pod is C<:ExtraTestFiles>.
  #pod
  #pod =attr skips
  #pod
  #pod This is an arrayref of regular expressions, derived from all the 'skip' lines
  #pod in the configuration.  Any module names matching any of these regexes will not
  #pod be registered as prerequisites.
  #pod
  #pod =cut
  
  has skips => (
    is  => 'ro',
    isa => 'ArrayRef[Str]',
  );
  
  around mvp_multivalue_args => sub {
    my ($orig, $self) = @_;
    ($self->$orig, 'skips')
  };
  around mvp_aliases => sub {
    my ($orig, $self) = @_;
    my $aliases = $self->$orig;
    $aliases->{skip}       = 'skips';
    return $aliases
  };
  
  
  requires 'scan_file_reqs';
  
  sub scan_prereqs {
    my $self = shift;
  
    require CPAN::Meta::Requirements;
    require List::Util;
    List::Util->VERSION(1.45);  # uniq
  
    # not a hash, because order is important
    my @sets = (
      # phase => file finder method
      [ configure => 'found_configure_files' ], # must come before runtime
      [ runtime => 'found_files'      ],
      [ test    => 'found_test_files' ],
      [ develop => 'found_develop_files' ],
    );
  
    my %reqs_by_phase;
    my %runtime_final;
    my @modules;
  
    for my $fileset (@sets) {
      my ($phase, $method) = @$fileset;
  
      my $req   = CPAN::Meta::Requirements->new;
      my $files = $self->$method;
  
      foreach my $file (@$files) {
        # skip binary files
        next if $file->is_bytes;
        # parse only perl files
        next unless $file->name =~ /\.(?:pm|pl|t|psgi)$/i
                 || $file->content =~ /^#!(?:.*)perl(?:$|\s)/;
        # RT#76305 skip extra tests produced by ExtraTests plugin
        next if $file->name =~ m{^t/(?:author|release)-[^/]*\.t$};
  
        # store module name, to trim it from require list later on
        my @this_thing = $file->name;
  
        # t/lib/Foo.pm is treated as providing t::lib::Foo, lib::Foo, and Foo
        if ($this_thing[0] =~ /^t/) {
          push @this_thing, ($this_thing[0]) x 2;
          $this_thing[1] =~ s{^t/}{};
          $this_thing[2] =~ s{^t/lib/}{};
        } else {
          $this_thing[0] =~ s{^lib/}{};
        }
        s{\.pm$}{} for @this_thing;
        s{/}{::}g for @this_thing;
  
        # this is a bunk heuristic and can still capture strings from pod - the
        # proper thing to do is grab all packages from Module::Metadata
        push @this_thing, $file->content =~ /^[^#]*?(?:^|\s)package\s+([^\s;#]+)/mg;
        push @modules, @this_thing;
  
        # parse a file, and merge with existing prereqs
        $self->log_debug([ 'scanning %s for %s prereqs', $file->name, $phase ]);
        my $file_req = $self->scan_file_reqs($file);
  
        $req->add_requirements($file_req);
  
      }
  
      # remove prereqs from skiplist
      for my $skip (@{ $self->skips || [] }) {
        my $re   = qr/$skip/;
  
        foreach my $k ($req->required_modules) {
          $req->clear_requirement($k) if $k =~ $re;
        }
      }
  
      # remove prereqs shipped with current dist
      if (@modules) {
        $self->log_debug([
          'excluding local packages: %s',
          sub { join(', ', List::Util::uniq(@modules)) } ]
        )
      }
      $req->clear_requirement($_) for @modules;
  
      $req->clear_requirement($_) for qw(Config DB Errno NEXT Pod::Functions); # never indexed
  
      # we're done, return what we've found
      my %got = %{ $req->as_string_hash };
      if ($phase eq 'runtime') {
        %runtime_final = %got;
      } else {
        # do not test-require things required for runtime
        delete $got{$_} for
          grep { exists $got{$_} and $runtime_final{$_} ge $got{$_} }
          keys %runtime_final;
      }
  
      $reqs_by_phase{$phase} = \%got;
    }
  
    return \%reqs_by_phase
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::PrereqScanner - automatically extract prereqs from your modules
  
  =head1 VERSION
  
  version 6.007
  
  =head1 ATTRIBUTES
  
  =head2 finder
  
  This is the name of a L<FileFinder|Dist::Zilla::Role::FileFinder>
  whose files will be scanned to determine runtime prerequisites.  It
  may be specified multiple times.  The default value is
  C<:InstallModules> and C<:ExecFiles>.
  
  =head2 test_finder
  
  Just like C<finder>, but for test-phase prerequisites.  The default
  value is C<:TestFiles>.
  
  =head2 configure_finder
  
  Just like C<finder>, but for configure-phase prerequisites.  There is
  no default value; AutoPrereqs will not determine configure-phase
  prerequisites unless you set configure_finder.
  
  =head2 develop_finder
  
  Just like <finder>, but for develop-phase prerequisites.  The default value
  is C<:ExtraTestFiles>.
  
  =head2 skips
  
  This is an arrayref of regular expressions, derived from all the 'skip' lines
  in the configuration.  Any module names matching any of these regexes will not
  be registered as prerequisites.
  
  =head1 SEE ALSO
  
  L<Dist::Zilla::Plugin::AutoPrereqs>.
  
  =head1 CREDITS
  
  The role was provided by Olivier Mengué (DOLMEN) and Philippe Bruhat (BOOK) at Perl QA Hackathon 2016
  (but it is just a refactor of the AutoPrereqs plugin).
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  #pod =head1 SEE ALSO
  #pod
  #pod L<Dist::Zilla::Plugin::AutoPrereqs>.
  #pod
  #pod =head1 CREDITS
  #pod
  #pod The role was provided by Olivier Mengué (DOLMEN) and Philippe Bruhat (BOOK) at Perl QA Hackathon 2016
  #pod (but it is just a refactor of the AutoPrereqs plugin).
  #pod
  #pod =cut
  
DIST_ZILLA_ROLE_PREREQSCANNER

$fatpacked{"Dist/Zilla/Role/PrereqSource.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_PREREQSOURCE';
  package Dist::Zilla::Role::PrereqSource 6.007;
  # ABSTRACT: something that registers prerequisites
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod PrereqSource plugins have a C<register_prereqs> method that should register
  #pod prereqs with the Dist::Zilla object.
  #pod
  #pod =cut
  
  requires 'register_prereqs';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::PrereqSource - something that registers prerequisites
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  PrereqSource plugins have a C<register_prereqs> method that should register
  prereqs with the Dist::Zilla object.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_PREREQSOURCE

$fatpacked{"Dist/Zilla/Role/ReleaseStatusProvider.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_RELEASESTATUSPROVIDER';
  package Dist::Zilla::Role::ReleaseStatusProvider 6.007;
  # ABSTRACT: something that provides a release status for the dist
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role must provide a C<provide_release_status>
  #pod method that will be called when setting the dist's version.
  #pod
  #pod If C<provides_release_status> returns undef, it will be ignored.
  #pod
  #pod =cut
  
  requires 'provide_release_status';
  
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins implementing this role:
  #pod L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::ReleaseStatusProvider - something that provides a release status for the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role must provide a C<provide_release_status>
  method that will be called when setting the dist's version.
  
  If C<provides_release_status> returns undef, it will be ignored.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins implementing this role:
  L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_RELEASESTATUSPROVIDER

$fatpacked{"Dist/Zilla/Role/Releaser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_RELEASER';
  package Dist::Zilla::Role::Releaser 6.007;
  # ABSTRACT: something that makes a release of the dist
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<release> method called when
  #pod releasing.  It's passed the distribution tarball to be released.
  #pod
  #pod =cut
  
  requires 'release';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::Releaser - something that makes a release of the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<release> method called when
  releasing.  It's passed the distribution tarball to be released.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_RELEASER

$fatpacked{"Dist/Zilla/Role/ShareDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_SHAREDIR';
  package Dist::Zilla::Role::ShareDir 6.007;
  # ABSTRACT: something that picks a directory to install as shared files
  
  use Moose::Role;
  with 'Dist::Zilla::Role::FileFinder';
  
  use namespace::autoclean;
  
  # Must return a hashref with any of the keys 'dist' and 'module'.  The 'dist'
  # must be a scalar with a directory to include and 'module' must be a hashref
  # mapping module names to directories to include.  If there are no directories
  # to include, it must return undef.
  requires 'share_dir_map';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::ShareDir - something that picks a directory to install as shared files
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_SHAREDIR

$fatpacked{"Dist/Zilla/Role/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_STASH';
  package Dist::Zilla::Role::Stash 6.007;
  # ABSTRACT: something that stores options or data for later reference
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  sub register_component {
    my ($class, $name, $arg, $section) = @_;
  
    # $self->log_debug([ 'online, %s v%s', $self->meta->name, $version ]);
    my $entry = $class->stash_from_config($name, $arg, $section);
  
    $section->sequence->assembler->register_stash($name, $entry);
  
    return;
  }
  
  sub stash_from_config {
    my ($class, $name, $arg, $section) = @_;
  
    my $self = $class->new($arg);
    return $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::Stash - something that stores options or data for later reference
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_STASH

$fatpacked{"Dist/Zilla/Role/Stash/Authors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_STASH_AUTHORS';
  package Dist::Zilla::Role::Stash::Authors 6.007;
  # ABSTRACT: a stash that provides a list of author strings
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Stash';
  
  use namespace::autoclean;
  
  #pod =head1 OVERVIEW
  #pod
  #pod An Authors stash must provide an C<authors> method that returns an arrayref of
  #pod author strings, generally in the form "Name <email>".
  #pod
  #pod =cut
  
  requires 'authors';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::Stash::Authors - a stash that provides a list of author strings
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  An Authors stash must provide an C<authors> method that returns an arrayref of
  author strings, generally in the form "Name <email>".
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_STASH_AUTHORS

$fatpacked{"Dist/Zilla/Role/Stash/Login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_STASH_LOGIN';
  package Dist::Zilla::Role::Stash::Login 6.007;
  # ABSTRACT: a stash with username/password credentials
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Stash';
  
  use namespace::autoclean;
  
  #pod =head1 OVERVIEW
  #pod
  #pod A Login stash must provide a C<username> and C<password> method.
  #pod
  #pod =cut
  
  requires 'username';
  requires 'password';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::Stash::Login - a stash with username/password credentials
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  A Login stash must provide a C<username> and C<password> method.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_STASH_LOGIN

$fatpacked{"Dist/Zilla/Role/StubBuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_STUBBUILD';
  package Dist::Zilla::Role::StubBuild 6.007;
  # ABSTRACT: provides an empty BUILD methods
  
  use Moose::Role;
  
  sub BUILD {}
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::StubBuild - provides an empty BUILD methods
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_STUBBUILD

$fatpacked{"Dist/Zilla/Role/TestRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_TESTRUNNER';
  package Dist::Zilla::Role::TestRunner 6.007;
  # ABSTRACT: something used as a delegating agent to 'dzil test'
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role have their C<test> method called when
  #pod testing.  It's passed the root directory of the build test dir and an
  #pod optional hash reference of arguments.  Valid arguments include:
  #pod
  #pod =for :list
  #pod * jobs -- if parallel testing is supported, this indicates how many to run at once
  #pod
  #pod =method test
  #pod
  #pod This method should throw an exception on failure.
  #pod
  #pod =cut
  
  requires 'test';
  
  #pod =attr default_jobs
  #pod
  #pod This attribute is the default value that should be used as the C<jobs> argument
  #pod to the C<test> method.
  #pod
  #pod =cut
  
  has default_jobs => (
    is      => 'ro',
    isa     => 'Int', # non-negative
    default => 1,
  );
  
  around dump_config => sub {
    my ($orig, $self) = @_;
    my $config = $self->$orig;
  
    $config->{'' . __PACKAGE__} = { default_jobs => $self->default_jobs };
  
    return $config;
  };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::TestRunner - something used as a delegating agent to 'dzil test'
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role have their C<test> method called when
  testing.  It's passed the root directory of the build test dir and an
  optional hash reference of arguments.  Valid arguments include:
  
  =over 4
  
  =item *
  
  jobs -- if parallel testing is supported, this indicates how many to run at once
  
  =back
  
  =head1 ATTRIBUTES
  
  =head2 default_jobs
  
  This attribute is the default value that should be used as the C<jobs> argument
  to the C<test> method.
  
  =head1 METHODS
  
  =head2 test
  
  This method should throw an exception on failure.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_TESTRUNNER

$fatpacked{"Dist/Zilla/Role/TextTemplate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_TEXTTEMPLATE';
  package Dist::Zilla::Role::TextTemplate 6.007;
  # ABSTRACT: something that renders a Text::Template template string
  
  use Moose::Role;
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing TextTemplate may call their own C<L</fill_in_string>>
  #pod method to render templates using L<Text::Template|Text::Template>.
  #pod
  #pod =cut
  
  use Text::Template;
  
  #pod =attr delim
  #pod
  #pod This attribute (which can't easily be set!) is a two-element array reference
  #pod returning the Text::Template delimiters to use.  It defaults to C<{{> and
  #pod C<}}>.
  #pod
  #pod =cut
  
  # XXX: Later, add a way to set this in config. -- rjbs, 2008-06-02
  has delim => (
    is   => 'ro',
    isa  => 'ArrayRef',
    lazy => 1,
    init_arg => undef,
    default  => sub { [ qw(  {{  }}  ) ] },
  );
  
  #pod =method fill_in_string
  #pod
  #pod   my $rendered = $plugin->fill_in_string($template, \%stash, \%arg);
  #pod
  #pod This uses Text::Template to fill in the given template using the variables
  #pod given in the C<%stash>.  The stash becomes the HASH argument to Text::Template,
  #pod so scalars must be scalar references rather than plain scalars.
  #pod
  #pod C<%arg> is dereferenced and passed in as extra arguments to Text::Template's
  #pod C<new> routine.
  #pod
  #pod =cut
  
  sub fill_in_string {
    my ($self, $string, $stash, $arg) = @_;
  
    $self->log_fatal("Cannot use undef as a template string")
      unless defined $string;
  
    my $tmpl = Text::Template->new(
      TYPE       => 'STRING',
      SOURCE     => $string,
      DELIMITERS => $self->delim,
      BROKEN     => sub { my %hash = @_; die $hash{error}; },
      %$arg,
    );
  
    $self->log_fatal("Could not create a Text::Template object from:\n$string")
      unless $tmpl;
  
    my $content = $tmpl->fill_in(%$arg, HASH => $stash);
  
    $self->log_fatal("Filling in the template returned undef for:\n$string")
      unless defined $content;
  
    return $content;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::TextTemplate - something that renders a Text::Template template string
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing TextTemplate may call their own C<L</fill_in_string>>
  method to render templates using L<Text::Template|Text::Template>.
  
  =head1 ATTRIBUTES
  
  =head2 delim
  
  This attribute (which can't easily be set!) is a two-element array reference
  returning the Text::Template delimiters to use.  It defaults to C<{{> and
  C<}}>.
  
  =head1 METHODS
  
  =head2 fill_in_string
  
    my $rendered = $plugin->fill_in_string($template, \%stash, \%arg);
  
  This uses Text::Template to fill in the given template using the variables
  given in the C<%stash>.  The stash becomes the HASH argument to Text::Template,
  so scalars must be scalar references rather than plain scalars.
  
  C<%arg> is dereferenced and passed in as extra arguments to Text::Template's
  C<new> routine.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_TEXTTEMPLATE

$fatpacked{"Dist/Zilla/Role/VersionProvider.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_ROLE_VERSIONPROVIDER';
  package Dist::Zilla::Role::VersionProvider 6.007;
  # ABSTRACT: something that provides a version number for the dist
  
  use Moose::Role;
  with 'Dist::Zilla::Role::Plugin';
  
  use namespace::autoclean;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Plugins implementing this role must provide a C<provide_version> method that
  #pod will be called when setting the dist's version.
  #pod
  #pod If a VersionProvider offers a version but one has already been set, an
  #pod exception will be raised.  If C<provides_version> returns undef, it will be
  #pod ignored.
  #pod
  #pod =cut
  
  requires 'provide_version';
  
  1;
  
  #pod =head1 SEE ALSO
  #pod
  #pod Core Dist::Zilla plugins implementing this role:
  #pod L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>.
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Role::VersionProvider - something that provides a version number for the dist
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Plugins implementing this role must provide a C<provide_version> method that
  will be called when setting the dist's version.
  
  If a VersionProvider offers a version but one has already been set, an
  exception will be raised.  If C<provides_version> returns undef, it will be
  ignored.
  
  =head1 SEE ALSO
  
  Core Dist::Zilla plugins implementing this role:
  L<AutoVersion|Dist::Zilla::Plugin::AutoVersion>.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_ROLE_VERSIONPROVIDER

$fatpacked{"Dist/Zilla/Stash/Mint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_STASH_MINT';
  package Dist::Zilla::Stash::Mint 6.007;
  # ABSTRACT: a stash of your default minting provider/profile
  
  use Moose;
  with 'Dist::Zilla::Role::Stash';
  
  use namespace::autoclean;
  
  has provider => (
    is  => 'ro',
    isa => 'Str',
    required => 0,
    default => 'Default',
  );
  
  has profile => (
    is  => 'ro',
    isa => 'Str',
    required => 0,
    default => 'default',
  );
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Stash::Mint - a stash of your default minting provider/profile
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_STASH_MINT

$fatpacked{"Dist/Zilla/Stash/PAUSE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_STASH_PAUSE';
  package Dist::Zilla::Stash::PAUSE 6.007;
  # ABSTRACT: a stash of your PAUSE credentials
  
  use Moose;
  
  use namespace::autoclean;
  
  #pod =head1 OVERVIEW
  #pod
  #pod The PAUSE stash is a L<Login|Dist::Zilla::Role::Stash::Login> stash generally
  #pod used for uploading to PAUSE.
  #pod
  #pod =cut
  
  sub mvp_aliases {
    return { user => 'username' };
  }
  
  has username => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  has password => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  with 'Dist::Zilla::Role::Stash::Login';
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Stash::PAUSE - a stash of your PAUSE credentials
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  The PAUSE stash is a L<Login|Dist::Zilla::Role::Stash::Login> stash generally
  used for uploading to PAUSE.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_STASH_PAUSE

$fatpacked{"Dist/Zilla/Stash/Rights.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_STASH_RIGHTS';
  package Dist::Zilla::Stash::Rights 6.007;
  # ABSTRACT: a stash of your default licensing terms
  
  use Moose;
  with 'Dist::Zilla::Role::Stash';
  
  use namespace::autoclean;
  
  has license_class => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  has copyright_holder => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  has copyright_year => (
    is  => 'ro',
    isa => 'Int',
  );
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Stash::Rights - a stash of your default licensing terms
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_STASH_RIGHTS

$fatpacked{"Dist/Zilla/Stash/User.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_STASH_USER';
  package Dist::Zilla::Stash::User 6.007;
  # ABSTRACT: a stash of user name and email
  
  use Moose;
  
  use namespace::autoclean;
  
  has name => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  has email => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
  );
  
  sub authors {
    my ($self) = @_;
    return [ sprintf "%s <%s>", $self->name, $self->email ];
  }
  
  with 'Dist::Zilla::Role::Stash::Authors';
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Stash::User - a stash of user name and email
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_STASH_USER

$fatpacked{"Dist/Zilla/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_TESTER';
  package Dist::Zilla::Tester 6.007;
  # ABSTRACT: a testing-enabling stand-in for Dist::Zilla
  
  use Moose;
  extends 'Dist::Zilla::Dist::Builder';
  
  # XXX: Adding this autoclean causes problem.  "Builder" and "Minter" do not
  # show in tests.  I'm really not sure why. -- rjbs, 2011-08-19
  # use namespace::autoclean;
  
  use autodie;
  use Dist::Zilla::Chrome::Test;
  use File::pushd ();
  use File::Spec;
  use File::Temp;
  use Dist::Zilla::Path;
  
  use Sub::Exporter::Util ();
  use Sub::Exporter -setup => {
    exports => [
      Builder => sub { $_[0]->can('builder') },
      Minter  => sub { $_[0]->can('minter')  },
    ],
  
    groups  => [ default => [ qw(Builder Minter) ] ],
  };
  
  sub from_config {
    my ($self, @arg) = @_;
  
    # The only thing using a local time zone should be NextRelease.  Normally it
    # defaults to "local," but since some users won't have an automatically
    # determinable time zone, we'll switch to not-local times for testing.
    # -- rjbs, 2015-11-26
    local $Dist::Zilla::Plugin::NextRelease::DEFAULT_TIME_ZONE = 'GMT';
  
    return $self->builder->from_config(@arg);
  }
  
  sub builder { 'Dist::Zilla::Tester::_Builder' }
  
  sub minter { 'Dist::Zilla::Tester::_Minter' }
  
  {
    package
      Dist::Zilla::Tester::_Role;
  
    use Moose::Role;
  
    has tempdir_root => (
      is => 'rw', isa => 'Str|Undef',
      writer => '_set_tempdir_root',
    );
    has tempdir_obj => (
      is => 'ro', isa => 'File::Temp::Dir',
      clearer => '_clear_tempdir_obj',
      writer => '_set_tempdir_obj',
    );
  
    sub DEMOLISH {}
    around DEMOLISH => sub {
      my $orig = shift;
      my $self = shift;
  
      # File::Temp deletes the directory when it goes out of scope
      $self->_clear_tempdir_obj;
  
      rmdir $self->tempdir_root if $self->tempdir_root;
      return $self->$orig(@_);
    };
  
    has tempdir => (
      is   => 'ro',
      writer   => '_set_tempdir',
      init_arg => undef,
    );
  
    sub clear_log_events {
      my ($self) = @_;
      $self->chrome->logger->clear_events;
    }
  
    sub log_events {
      my ($self) = @_;
      $self->chrome->logger->events;
    }
  
    sub log_messages {
      my ($self) = @_;
      [ map {; $_->{message} } @{ $self->chrome->logger->events } ];
    }
  
    sub slurp_file {
      my ($self, $filename) = @_;
  
      Dist::Zilla::Path::path(
        $self->tempdir->child($filename)
      )->slurp_utf8;
    }
  
    sub slurp_file_raw {
      my ($self, $filename) = @_;
  
      Dist::Zilla::Path::path(
        $self->tempdir->child($filename)
      )->slurp_raw;
    }
  
    sub _metadata_generator_id { 'Dist::Zilla::Tester' }
  
    no Moose::Role;
  }
  
  {
    package Dist::Zilla::Tester::_Builder 6.007;
  
    use Moose;
    extends 'Dist::Zilla::Dist::Builder';
    with 'Dist::Zilla::Tester::_Role';
  
    use File::Copy::Recursive qw(dircopy);
    use Dist::Zilla::Path;
  
    our $Log_Events = [];
    sub most_recent_log_events {
      return @{ $Log_Events }
    }
  
    around from_config => sub {
      my ($orig, $self, $arg, $tester_arg) = @_;
  
      confess "dist_root required for from_config" unless $arg->{dist_root};
  
      my $source = $arg->{dist_root};
  
      my $tempdir_root = exists $tester_arg->{tempdir_root}
                       ? $tester_arg->{tempdir_root}
                       : 'tmp';
  
      mkdir $tempdir_root if defined $tempdir_root and not -d $tempdir_root;
  
      my $tempdir_obj = File::Temp->newdir(
        CLEANUP => 1,
        (defined $tempdir_root ? (DIR => $tempdir_root) : ()),
      );
  
      my $tempdir = path( path($tempdir_obj)->absolute) ;
  
      my $root = $tempdir->child('source');
      $root->mkpath;
  
      dircopy($source, $root);
  
      if ($tester_arg->{also_copy}) {
        while (my ($src, $dest) = each %{ $tester_arg->{also_copy} }) {
          dircopy($src, $tempdir->child($dest));
        }
      }
  
      if (my $files = $tester_arg->{add_files}) {
        while (my ($name, $content) = each %$files) {
          die "Unix path '$name' does not seem to be portable to the current OS"
            if !unix_path_seems_portable($name);
          my $fn = $tempdir->child($name);
          $fn->parent->mkpath;
          Dist::Zilla::Path::path($fn)->spew_utf8($content);
        }
      }
  
      local $arg->{dist_root} = "$root";
      local $arg->{chrome} = Dist::Zilla::Chrome::Test->new;
  
      $Log_Events = $arg->{chrome}->logger->events;
  
      local @INC = @INC;
  
      my $had_dot;
      if ($INC[-1] eq '.') {
        $had_dot = 1;
        pop @INC;
      }
  
      @INC = map {; ref($_) ? $_ : File::Spec->rel2abs($_) } @INC;
  
      push @INC, '.' if $had_dot;
  
      # We do this so that . in @INC will find plugins like [=inc::YourFace]
      # -- rjbs, 2016-04-24
      my $wd = File::pushd::pushd($arg->{dist_root});
  
  
      local $ENV{DZIL_GLOBAL_CONFIG_ROOT};
      $ENV{DZIL_GLOBAL_CONFIG_ROOT} = $tester_arg->{global_config_root}
        if defined $tester_arg->{global_config_root};
  
      my $zilla = $self->$orig($arg);
  
      $zilla->_set_tempdir_root($tempdir_root);
      $zilla->_set_tempdir_obj($tempdir_obj);
      $zilla->_set_tempdir($tempdir);
  
      return $zilla;
    };
  
    around build_in => sub {
      my ($orig, $self, $target) = @_;
  
      # XXX: We *must eliminate* the need for this!  It's only here because right
      # now building a dist with (root <> cwd) doesn't work. -- rjbs, 2010-03-08
      my $wd = File::pushd::pushd($self->root);
  
      $target ||= do {
        my $target = path($self->tempdir)->child('build');
        $target->mkpath;
        $target;
      };
  
      return $self->$orig($target);
    };
  
    around ['test', 'release'] => sub {
      my ($orig, $self) = @_;
  
      # XXX: We *must eliminate* the need for this!  It's only here because right
      # now building a dist with (root <> cwd) doesn't work. -- rjbs, 2010-03-08
      my $wd = File::pushd::pushd($self->root);
  
      return $self->$orig;
    };
  
    no Moose;
  
    sub unix_path_seems_portable {
      return 1 if $^O eq "linux"; # this check only makes sense on non-unixes
  
      my ($unix_path) = @_;
  
      # split the  $unix_path into 3 strings: $volume, $directories, $file; with:
      my @native_parts = File::Spec->splitpath($unix_path); # current OS rules
      my @unix_parts = File::Spec::Unix->splitpath($unix_path); # unix rules
      return unless join(qq{\0}, @native_parts) eq join(qq{\0}, @unix_parts);
  
      # split the $directories string into a list of the sub-directories; with:
      my @native_dirs = File::Spec->splitdir($native_parts[1]); # current OS rules
      my @unix_dirs = File::Spec::Unix->splitdir($unix_parts[1]); # unix rules
      return unless join(qq{\0}, @native_dirs) eq join(qq{\0}, @unix_dirs);
  
      return 1;
    }
  }
  
  {
    package Dist::Zilla::Tester::_Minter 6.007;
  
    use Moose;
    extends 'Dist::Zilla::Dist::Minter';
    with 'Dist::Zilla::Tester::_Role';
  
    use File::Copy::Recursive qw(dircopy);
    use Dist::Zilla::Path;
  
    our $Log_Events = [];
    sub most_recent_log_events {
      return @{ $Log_Events }
    }
  
    sub _mint_target_dir {
      my ($self) = @_;
  
      my $name = $self->name;
      my $dir  = $self->tempdir->child('mint')->absolute;
  
      $self->log_fatal("$dir already exists") if -e $dir;
  
      return $dir;
    }
  
    sub _setup_global_config {
      my ($self, $dir, $arg) = @_;
  
      my $config_base = path($dir)->child('config');
  
      my $stash_registry = {};
  
      require Dist::Zilla::MVP::Assembler::GlobalConfig;
      require Dist::Zilla::MVP::Section;
      my $assembler = Dist::Zilla::MVP::Assembler::GlobalConfig->new({
        chrome => $arg->{chrome},
        stash_registry => $stash_registry,
        section_class  => 'Dist::Zilla::MVP::Section', # make this DZMA default
      });
  
      require Dist::Zilla::MVP::Reader::Finder;
      my $reader = Dist::Zilla::MVP::Reader::Finder->new;
  
      my $seq = $reader->read_config($config_base, { assembler => $assembler });
  
      return $stash_registry;
    }
  
    around _new_from_profile => sub {
      my ($orig, $self, $profile_data, $arg, $tester_arg) = @_;
  
      my $tempdir_root = exists $tester_arg->{tempdir_root}
                       ? $tester_arg->{tempdir_root}
                       : 'tmp';
  
      mkdir $tempdir_root if defined $tempdir_root and not -d $tempdir_root;
  
      my $tempdir_obj = File::Temp->newdir(
          CLEANUP => 1,
          (defined $tempdir_root ? (DIR => $tempdir_root) : ()),
      );
      my $tempdir = path($tempdir_obj)->absolute;
  
      local $arg->{chrome} = Dist::Zilla::Chrome::Test->new;
      $Log_Events = $arg->{chrome}->logger->events;
  
      local @INC = map {; ref($_) ? $_ : File::Spec->rel2abs($_) } @INC;
  
      my $global_config_root = path($tester_arg->{global_config_root})->absolute;
  
      local $ENV{DZIL_GLOBAL_CONFIG_ROOT} = $global_config_root;
  
      my $global_stashes = $self->_setup_global_config(
        $global_config_root,
        { chrome => $arg->{chrome} },
      );
  
      local $arg->{_global_stashes} = $global_stashes;
  
      my $zilla = $self->$orig($profile_data, $arg);
  
      $zilla->_set_tempdir_root($tempdir_root);
      $zilla->_set_tempdir_obj($tempdir_obj);
      $zilla->_set_tempdir($tempdir);
  
      return $zilla;
    };
  }
  
  no Moose; # XXX: namespace::autoclean caused problems -- rjbs, 2011-08-19
  __PACKAGE__->meta->make_immutable;
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Tester - a testing-enabling stand-in for Dist::Zilla
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_TESTER

$fatpacked{"Dist/Zilla/Tutorial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_TUTORIAL';
  use strict;
  use warnings;
  package Dist::Zilla::Tutorial 6.007;
  # ABSTRACT: how to use this "Dist::Zilla" thing
  
  use Carp ();
  Carp::confess "you're not meant to use the tutorial, just read it!";
  1;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod B<BEFORE YOU GET STARTED>:  Maybe you should be looking at the web-based
  #pod tutorial instead.  It's more complete.  L<http://dzil.org/tutorial/start.html>
  #pod
  #pod Dist::Zilla builds distributions to be uploaded to the CPAN.  That means that
  #pod the first thing you'll need is some code.
  #pod
  #pod Once you've got that, you'll need to configure Dist::Zilla.  Here's a simple
  #pod F<dist.ini>:
  #pod
  #pod   name    = Carbon-Dating
  #pod   version = 0.003
  #pod   author  = Alan Smithee <asmithee@example.org>
  #pod   license = Perl_5
  #pod   copyright_holder = Alan Smithee
  #pod
  #pod   [@Basic]
  #pod
  #pod   [Prereqs]
  #pod   App::Cmd          = 0.013
  #pod   Number::Nary      = 0
  #pod   Sub::Exporter     = 0.981
  #pod
  #pod The topmost section configures Dist::Zilla itself.  Here are some of the
  #pod entries it expects:
  #pod
  #pod   name     - (required) the name of the dist being built
  #pod   version  - (required) the version of the dist
  #pod   abstract - (required) a short description of the dist
  #pod   author   - (optional) the dist author (you may have multiple entries for this)
  #pod   license  - (required) the dist license; must be a Software::License::* name
  #pod
  #pod   copyright_holder - (required) the entity holding copyright on the dist
  #pod
  #pod Some of the required values above may actually be provided by means other than
  #pod the top-level section of the config.  For example,
  #pod L<VersionProvider|Dist::Zilla::Role::VersionProvider> plugins can
  #pod set the version, and a line like this in the "main module" of the dist will set
  #pod the abstract:
  #pod
  #pod   # ABSTRACT: a totally cool way to do totally great stuff
  #pod
  #pod The main modules is the module that shares the same name as the dist, in
  #pod general.
  #pod
  #pod Named sections load plugins, with the following rules:
  #pod
  #pod If a section name begins with an equals sign (C<=>), the rest of the section
  #pod name is left intact and not expanded.  If the section name begins with an at
  #pod sign (C<@>), it is prepended with C<Dist::Zilla::PluginBundle::>.  Otherwise,
  #pod it is prepended with C<Dist::Zilla::Plugin::>.
  #pod
  #pod The values inside a section are given as configuration to the plugin.  Consult
  #pod each plugin's documentation for more information.
  #pod
  #pod The "Basic" bundle, seen above, builds a fairly normal distribution.  It
  #pod rewrites tests from F<./xt>, adds some information to POD, and builds a
  #pod F<Makefile.PL>.  For more information, you can look at the docs for
  #pod L<@Basic|Dist::Zilla::PluginBundle::Basic> and see the plugins it includes.
  #pod
  #pod =head1 BUILDING YOUR DIST
  #pod
  #pod Maybe we're getting ahead of ourselves, here.  Configuring a bunch of plugins
  #pod won't do you a lot of good unless you know how to use them to build your dist.
  #pod
  #pod Dist::Zilla ships with a command called F<dzil> that will get installed by
  #pod default.  While it can be extended to offer more commands, there are two really
  #pod useful ones:
  #pod
  #pod   $ dzil build
  #pod
  #pod The C<build> command will build the distribution.  Say you're using the
  #pod configuration in the SYNOPSIS above.  You'll end up with a file called
  #pod F<Carbon-Dating-0.004.tar.gz>.  As long as you've done everything right, it
  #pod will be suitable for uploading to the CPAN.
  #pod
  #pod Of course, you should really test it out first.  You can test the dist you'd be
  #pod building by running another F<dzil> command:
  #pod
  #pod   $ dzil test
  #pod
  #pod This will build a new copy of your distribution and run its tests, so you'll
  #pod know whether the dist that C<build> would build is worth releasing!
  #pod
  #pod =head1 HOW BUILDS GET BUILT
  #pod
  #pod This is really more of a sketchy overview than a spec.
  #pod
  #pod First, all the plugins that perform the
  #pod L<BeforeBuild|Dist::Zilla::Role::BeforeBuild> perform their C<before_build>
  #pod tasks.
  #pod
  #pod The build root (where the dist is being built) is made.
  #pod
  #pod The L<FileGatherer|Dist::Zilla::Role::FileGatherer>s gather and inject files
  #pod into the distribution, then the L<FilePruner|Dist::Zilla::Role::FilePruner>s
  #pod remove some of them.
  #pod
  #pod All the L<FileMunger|Dist::Zilla::Role::FileMunger>s get a chance to muck about
  #pod with each file, possibly changing its name, content, or installability.
  #pod
  #pod Now that the distribution is basically set up, it needs an install tool, like a
  #pod F<Makefile.PL>.  All the
  #pod L<InstallTool|Dist::Zilla::Role::InstallTool>-performing plugins are used to
  #pod do whatever is needed to make the dist installable.
  #pod
  #pod Everything is just about done.  The files are all written out to disk and the
  #pod L<AfterBuild|Dist::Zilla::Role::AfterBuild> plugins do their thing.
  #pod
  #pod =head1 RELEASING YOUR DIST
  #pod
  #pod By running C<dzil release>, you'll test your
  #pod distribution, build a tarball of it, and upload it to the CPAN.  Plugins are
  #pod able to do things like check your version control system to make sure you're
  #pod releasing a new version and that you tag the version you've just uploaded.  It
  #pod can also update your Changelog file, too, making sure that you don't need to
  #pod know what your next version number will be before releasing.
  #pod
  #pod The final CPAN release process is implemented by the
  #pod L<UploadToCPAN|Dist::Zilla::Plugin::UploadToCPAN> plugin. However you can
  #pod replace it by your own to match your own (company?) process.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod L<dzil>
  #pod
  #pod =cut
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Tutorial - how to use this "Dist::Zilla" thing
  
  =head1 VERSION
  
  version 6.007
  
  =head1 SYNOPSIS
  
  B<BEFORE YOU GET STARTED>:  Maybe you should be looking at the web-based
  tutorial instead.  It's more complete.  L<http://dzil.org/tutorial/start.html>
  
  Dist::Zilla builds distributions to be uploaded to the CPAN.  That means that
  the first thing you'll need is some code.
  
  Once you've got that, you'll need to configure Dist::Zilla.  Here's a simple
  F<dist.ini>:
  
    name    = Carbon-Dating
    version = 0.003
    author  = Alan Smithee <asmithee@example.org>
    license = Perl_5
    copyright_holder = Alan Smithee
  
    [@Basic]
  
    [Prereqs]
    App::Cmd          = 0.013
    Number::Nary      = 0
    Sub::Exporter     = 0.981
  
  The topmost section configures Dist::Zilla itself.  Here are some of the
  entries it expects:
  
    name     - (required) the name of the dist being built
    version  - (required) the version of the dist
    abstract - (required) a short description of the dist
    author   - (optional) the dist author (you may have multiple entries for this)
    license  - (required) the dist license; must be a Software::License::* name
  
    copyright_holder - (required) the entity holding copyright on the dist
  
  Some of the required values above may actually be provided by means other than
  the top-level section of the config.  For example,
  L<VersionProvider|Dist::Zilla::Role::VersionProvider> plugins can
  set the version, and a line like this in the "main module" of the dist will set
  the abstract:
  
    # ABSTRACT: a totally cool way to do totally great stuff
  
  The main modules is the module that shares the same name as the dist, in
  general.
  
  Named sections load plugins, with the following rules:
  
  If a section name begins with an equals sign (C<=>), the rest of the section
  name is left intact and not expanded.  If the section name begins with an at
  sign (C<@>), it is prepended with C<Dist::Zilla::PluginBundle::>.  Otherwise,
  it is prepended with C<Dist::Zilla::Plugin::>.
  
  The values inside a section are given as configuration to the plugin.  Consult
  each plugin's documentation for more information.
  
  The "Basic" bundle, seen above, builds a fairly normal distribution.  It
  rewrites tests from F<./xt>, adds some information to POD, and builds a
  F<Makefile.PL>.  For more information, you can look at the docs for
  L<@Basic|Dist::Zilla::PluginBundle::Basic> and see the plugins it includes.
  
  =head1 BUILDING YOUR DIST
  
  Maybe we're getting ahead of ourselves, here.  Configuring a bunch of plugins
  won't do you a lot of good unless you know how to use them to build your dist.
  
  Dist::Zilla ships with a command called F<dzil> that will get installed by
  default.  While it can be extended to offer more commands, there are two really
  useful ones:
  
    $ dzil build
  
  The C<build> command will build the distribution.  Say you're using the
  configuration in the SYNOPSIS above.  You'll end up with a file called
  F<Carbon-Dating-0.004.tar.gz>.  As long as you've done everything right, it
  will be suitable for uploading to the CPAN.
  
  Of course, you should really test it out first.  You can test the dist you'd be
  building by running another F<dzil> command:
  
    $ dzil test
  
  This will build a new copy of your distribution and run its tests, so you'll
  know whether the dist that C<build> would build is worth releasing!
  
  =head1 HOW BUILDS GET BUILT
  
  This is really more of a sketchy overview than a spec.
  
  First, all the plugins that perform the
  L<BeforeBuild|Dist::Zilla::Role::BeforeBuild> perform their C<before_build>
  tasks.
  
  The build root (where the dist is being built) is made.
  
  The L<FileGatherer|Dist::Zilla::Role::FileGatherer>s gather and inject files
  into the distribution, then the L<FilePruner|Dist::Zilla::Role::FilePruner>s
  remove some of them.
  
  All the L<FileMunger|Dist::Zilla::Role::FileMunger>s get a chance to muck about
  with each file, possibly changing its name, content, or installability.
  
  Now that the distribution is basically set up, it needs an install tool, like a
  F<Makefile.PL>.  All the
  L<InstallTool|Dist::Zilla::Role::InstallTool>-performing plugins are used to
  do whatever is needed to make the dist installable.
  
  Everything is just about done.  The files are all written out to disk and the
  L<AfterBuild|Dist::Zilla::Role::AfterBuild> plugins do their thing.
  
  =head1 RELEASING YOUR DIST
  
  By running C<dzil release>, you'll test your
  distribution, build a tarball of it, and upload it to the CPAN.  Plugins are
  able to do things like check your version control system to make sure you're
  releasing a new version and that you tag the version you've just uploaded.  It
  can also update your Changelog file, too, making sure that you don't need to
  know what your next version number will be before releasing.
  
  The final CPAN release process is implemented by the
  L<UploadToCPAN|Dist::Zilla::Plugin::UploadToCPAN> plugin. However you can
  replace it by your own to match your own (company?) process.
  
  =head1 SEE ALSO
  
  L<dzil>
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_TUTORIAL

$fatpacked{"Dist/Zilla/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_TYPES';
  package Dist::Zilla::Types 6.007;
  # ABSTRACT: dzil-specific type library
  
  use namespace::autoclean;
  
  #pod =head1 OVERVIEW
  #pod
  #pod This library provides L<MooseX::Types> types for use by Dist::Zilla.  These
  #pod types are not (yet?) for public consumption, and you should not rely on them.
  #pod
  #pod Dist::Zilla uses a number of types found in L<MooseX::Types::Perl>.  Maybe
  #pod that's what you want.
  #pod
  #pod =cut
  
  use MooseX::Types -declare => [qw(
    License OneZero YesNoStr ReleaseStatus 
    Path
    _Filename
  )];
  use MooseX::Types::Moose qw(Str Int Defined);
  
  subtype License, as class_type('Software::License');
  
  subtype Path, as class_type('Path::Tiny');
  coerce Path, from Defined, via {
    require Dist::Zilla::Path;
    Dist::Zilla::Path::path($_);
  };
  
  subtype OneZero, as Str, where { $_ eq '0' or $_ eq '1' };
  
  subtype YesNoStr, as Str, where { /\A(?:y|ye|yes)\Z/i or /\A(?:n|no)\Z/i };
  
  subtype ReleaseStatus, as Str, where { /\A(?:stable|testing|unstable)\z/ };
  
  coerce OneZero, from YesNoStr, via { /\Ay/i ? 1 : 0 };
  
  subtype _Filename, as Str,
    where   { $_ !~ qr/(?:\x{0a}|\x{0b}|\x{0c}|\x{0d}|\x{85}|\x{2028}|\x{2029})/ },
    message { "Filename contains a newline or other vertical whitespace" };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Types - dzil-specific type library
  
  =head1 VERSION
  
  version 6.007
  
  =head1 OVERVIEW
  
  This library provides L<MooseX::Types> types for use by Dist::Zilla.  These
  types are not (yet?) for public consumption, and you should not rely on them.
  
  Dist::Zilla uses a number of types found in L<MooseX::Types::Perl>.  Maybe
  that's what you want.
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_TYPES

$fatpacked{"Dist/Zilla/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_UTIL';
  use strict;
  use warnings;
  package Dist::Zilla::Util 6.007;
  # ABSTRACT: random snippets of code that Dist::Zilla wants
  
  use Carp ();
  use Encode ();
  
  {
    package
      Dist::Zilla::Util::PEA;
    @Dist::Zilla::Util::PEA::ISA = ('Pod::Eventual');
    sub _new  {
      # Load Pod::Eventual only when used (and not yet loaded)
      unless (exists $INC{'Pod/Eventual.pm'}) {
        require Pod::Eventual;
        Pod::Eventual->VERSION(0.091480); # better nonpod/blank events
      }
  
      bless {} => shift;
    }
    sub handle_nonpod {
      my ($self, $event) = @_;
      return if $self->{abstract};
      return $self->{abstract} = $1
        if $event->{content}=~ /^\s*#+\s*ABSTRACT:[ \t]*(\S.*)$/m;
      return;
    }
    sub handle_event {
      my ($self, $event) = @_;
      return if $self->{abstract};
      if (
        ! $self->{in_name}
        and $event->{type} eq 'command'
        and $event->{command} eq 'head1'
        and $event->{content} =~ /^NAME\b/
      ) {
        $self->{in_name} = 1;
        return;
      }
  
      return unless $self->{in_name};
  
      if (
        $event->{type} eq 'text'
        and $event->{content} =~ /^(?:\S+\s+)+?-+\s+(.+)\n$/s
      ) {
        $self->{abstract} = $1;
        $self->{abstract} =~ s/\s+/\x20/g;
      }
    }
  }
  
  #pod =method abstract_from_file
  #pod
  #pod This method, I<which is likely to change or go away>, tries to guess the
  #pod abstract of a given file, assuming that it's Perl code.  It looks for a POD
  #pod C<=head1> section called "NAME" or a comment beginning with C<ABSTRACT:>.
  #pod
  #pod =cut
  
  sub abstract_from_file {
    my ($self, $file) = @_;
    my $e = Dist::Zilla::Util::PEA->_new;
  
    my $chars = $file->content;
    my $bytes = Encode::encode('UTF-8', $chars, Encode::FB_CROAK);
  
    $e->read_string($bytes);
  
    return $e->{abstract};
  }
  
  #pod =method expand_config_package_name
  #pod
  #pod   my $pkg_name = Dist::Zilla::Util->expand_config_package_name($string);
  #pod
  #pod This method, I<which is likely to change or go away>, rewrites the given string
  #pod into a package name.
  #pod
  #pod Prefixes are rewritten as follows:
  #pod
  #pod =for :list
  #pod * C<=> becomes nothing
  #pod * C<@> becomes C<Dist::Zilla::PluginBundle::>
  #pod * C<%> becomes C<Dist::Zilla::Stash::>
  #pod * otherwise, C<Dist::Zilla::Plugin::> is prepended
  #pod
  #pod =cut
  
  use String::RewritePrefix 0.006 rewrite => {
    -as => '_expand_config_package_name',
    prefixes => {
      '=' => '',
      '@' => 'Dist::Zilla::PluginBundle::',
      '%' => 'Dist::Zilla::Stash::',
      ''  => 'Dist::Zilla::Plugin::',
    },
  };
  sub expand_config_package_name {
    shift; goto &_expand_config_package_name
  }
  
  sub _global_config_root {
    require Dist::Zilla::Path;
    return Dist::Zilla::Path::path($ENV{DZIL_GLOBAL_CONFIG_ROOT}) if $ENV{DZIL_GLOBAL_CONFIG_ROOT};
  
    require File::HomeDir;
    my $homedir = File::HomeDir->my_home
      or Carp::croak("couldn't determine home directory");
  
    return Dist::Zilla::Path::path($homedir)->child('.dzil');
  }
  
  sub _assert_loaded_class_version_ok {
    my ($self, $pkg, $version) = @_;
  
    require CPAN::Meta::Requirements;
    my $req = CPAN::Meta::Requirements->from_string_hash({
      $pkg => $version,
    });
  
    my $have_version = $pkg->VERSION;
    unless ($req->accepts_module($pkg => $have_version)) {
      die( sprintf
        "%s version (%s) does not match required version: %s\n",
        $pkg,
        $have_version // 'undef',
        $version,
      );
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Util - random snippets of code that Dist::Zilla wants
  
  =head1 VERSION
  
  version 6.007
  
  =head1 METHODS
  
  =head2 abstract_from_file
  
  This method, I<which is likely to change or go away>, tries to guess the
  abstract of a given file, assuming that it's Perl code.  It looks for a POD
  C<=head1> section called "NAME" or a comment beginning with C<ABSTRACT:>.
  
  =head2 expand_config_package_name
  
    my $pkg_name = Dist::Zilla::Util->expand_config_package_name($string);
  
  This method, I<which is likely to change or go away>, rewrites the given string
  into a package name.
  
  Prefixes are rewritten as follows:
  
  =over 4
  
  =item *
  
  C<=> becomes nothing
  
  =item *
  
  C<@> becomes C<Dist::Zilla::PluginBundle::>
  
  =item *
  
  C<%> becomes C<Dist::Zilla::Stash::>
  
  =item *
  
  otherwise, C<Dist::Zilla::Plugin::> is prepended
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_UTIL

$fatpacked{"Dist/Zilla/Util/AuthorDeps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_ZILLA_UTIL_AUTHORDEPS';
  use strict;
  use warnings;
  package Dist::Zilla::Util::AuthorDeps 6.007;
  # ABSTRACT: Utils for listing your distribution's author dependencies
  
  use Dist::Zilla::Util;
  use Path::Tiny;
  use List::Util 1.45 ();
  
  
  sub format_author_deps {
    my ($reqs, $versions) = @_;
  
    my $formatted = '';
    foreach my $rec (@{ $reqs }) {
      my ($mod, $ver) = each(%{ $rec });
      $formatted .= $versions ? "$mod = $ver\n" : "$mod\n";
    }
    chomp($formatted);
    return $formatted;
  }
  
  sub extract_author_deps {
    my ($root, $missing) = @_;
  
    my $ini = path($root, 'dist.ini');
  
    die "dzil authordeps only works on dist.ini files, and you don't have one\n"
      unless -e $ini;
  
    my $fh = $ini->openr_utf8;
  
    require Config::INI::Reader;
    my $config = Config::INI::Reader->read_handle($fh);
  
    require CPAN::Meta::Requirements;
    my $reqs = CPAN::Meta::Requirements->new;
  
    if (defined (my $license = $config->{_}->{license})) {
      $license = 'Software::License::'.$license;
      $reqs->add_minimum($license => 0);
    }
  
    for my $section ( sort keys %$config ) {
      next if q[_] eq $section;
      my $pack = $section;
      $pack =~ s{\s*/.*$}{}; # trim optional space and slash-delimited suffix
  
      my $version = 0;
      $version = $config->{$section}->{':version'} if exists $config->{$section}->{':version'};
  
      my $realname = Dist::Zilla::Util->expand_config_package_name($pack);
      $reqs->add_minimum($realname => $version);
    }
  
    seek $fh, 0, 0;
  
    my $in_filter = 0;
    while (<$fh>) {
      next unless $in_filter or /^\[\s*\@Filter/;
      $in_filter = 0, next if /^\[/ and ! /^\[\s*\@Filter/;
      $in_filter = 1;
  
      next unless /\A-bundle\s*=\s*([^;\s]+)/;
      my $pname = $1;
      chomp($pname);
      $reqs->add_minimum(Dist::Zilla::Util->expand_config_package_name($1) => 0)
    }
  
    seek $fh, 0, 0;
  
    my @packages;
    while (<$fh>) {
      chomp;
      next unless /\A\s*;\s*authordep\s*(\S+)\s*(?:=\s*([^;]+))?\s*/;
      my $module = $1;
      my $ver = $2 // "0";
      $ver =~ s/\s+$//;
      # Any "; authordep " is inserted at the beginning of the list
      # in the file order so the user can control the order of at least a part of
      # the plugin list
      push @packages, $module;
      # And added to the requirements so we can use it later
      $reqs->add_string_requirement($module => $ver);
    }
  
    my $vermap = $reqs->as_string_hash;
    # Add the other requirements
    push(@packages, sort keys %{ $vermap });
  
    # Move inc:: first in list as they may impact the loading of other
    # plugins (in particular local ones).
    # Also order inc:: so that those that want to hack @INC with inc:: plugins
    # can have a consistent playground.
    # We don't sort the others packages to preserve the same (random) ordering
    # for the common case (no inc::, no '; authordep') as in previous dzil
    # releases.
    @packages = ((sort grep /^inc::/, @packages), (grep !/^inc::/, @packages));
    @packages = List::Util::uniq(@packages);
  
    if ($missing) {
      require Module::Runtime;
  
      @packages =
        grep {
          $_ eq 'perl'
          ? ! ($vermap->{perl} && eval "use $vermap->{perl}; 1")
          : do {
              my $m = $_;
              ! eval {
                # This will die if module is missing
                Module::Runtime::require_module($m);
                my $v = $vermap->{$m};
                # This will die if VERSION is too low
                !$v || $m->VERSION($v);
                # Success!
                1
              }
            }
        } @packages;
    }
  
    # Now that we have a sorted list of packages, use that to build an array of
    # hashrefs for display.
    [ map { { $_ => $vermap->{$_} } } @packages ]
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::Zilla::Util::AuthorDeps - Utils for listing your distribution's author dependencies
  
  =head1 VERSION
  
  version 6.007
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_ZILLA_UTIL_AUTHORDEPS

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;
  
  use strict;
  use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);
  use Module::Pluggable::Object;
  
  use if $] > 5.017, 'deprecate';
  
  # ObQuote:
  # Bob Porter: Looks like you've been missing a lot of work lately.
  # Peter Gibbons: I wouldn't say I've been missing it, Bob!
  
  
  $VERSION = '5.2';
  $FORCE_SEARCH_ALL_PATHS = 0;
  
  sub import {
      my $class        = shift;
      my %opts         = @_;
  
      my ($pkg, $file) = caller;
      # the default name for the method is 'plugins'
      my $sub          = $opts{'sub_name'}  || 'plugins';
      # get our package
      my ($package)    = $opts{'package'} || $pkg;
      $opts{filename}  = $file;
      $opts{package}   = $package;
      $opts{force_search_all_paths} = $FORCE_SEARCH_ALL_PATHS unless exists $opts{force_search_all_paths};
  
  
      my $finder       = Module::Pluggable::Object->new(%opts);
      my $subroutine   = sub { my $self = shift; return $finder->plugins(@_) };
  
      my $searchsub = sub {
                my $self = shift;
                my ($action,@paths) = @_;
  
                $finder->{'search_path'} = ["${package}::Plugin"] if ($action eq 'add'  and not   $finder->{'search_path'} );
                push @{$finder->{'search_path'}}, @paths      if ($action eq 'add');
                $finder->{'search_path'}       = \@paths      if ($action eq 'new');
                return $finder->{'search_path'};
      };
  
  
      my $onlysub = sub {
          my ($self, $only) = @_;
  
          if (defined $only) {
              $finder->{'only'} = $only;
          };
  
          return $finder->{'only'};
      };
  
      my $exceptsub = sub {
          my ($self, $except) = @_;
  
          if (defined $except) {
              $finder->{'except'} = $except;
          };
  
          return $finder->{'except'};
      };
  
  
      no strict 'refs';
      no warnings qw(redefine prototype);
  
      *{"$package\::$sub"}        = $subroutine;
      *{"$package\::search_path"} = $searchsub;
      *{"$package\::only"}        = $onlysub;
      *{"$package\::except"}      = $exceptsub;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable;
  
  
  and then later ...
  
      use MyClass;
      my $mc = MyClass->new();
      # returns the names of all plugins installed under MyClass::Plugin::*
      my @plugins = $mc->plugins();
  
  =head1 EXAMPLE
  
  Why would you want to do this? Say you have something that wants to pass an
  object to a number of different plugins in turn. For example you may
  want to extract meta-data from every email you get sent and do something
  with it. Plugins make sense here because then you can keep adding new
  meta data parsers and all the logic and docs for each one will be
  self contained and new handlers are easy to add without changing the
  core code. For that, you might do something like ...
  
      package Email::Examiner;
  
      use strict;
      use Email::Simple;
      use Module::Pluggable require => 1;
  
      sub handle_email {
          my $self  = shift;
          my $email = shift;
  
          foreach my $plugin ($self->plugins) {
              $plugin->examine($email);
          }
  
          return 1;
      }
  
  
  
  .. and all the plugins will get a chance in turn to look at it.
  
  This can be trivially extended so that plugins could save the email
  somewhere and then no other plugin should try and do that.
  Simply have it so that the C<examine> method returns C<1> if
  it has saved the email somewhere. You might also want to be paranoid
  and check to see if the plugin has an C<examine> method.
  
          foreach my $plugin ($self->plugins) {
              next unless $plugin->can('examine');
              last if     $plugin->examine($email);
          }
  
  
  And so on. The sky's the limit.
  
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that
  looks through a search path for .pm files and turn those into class names.
  
  Optionally it instantiates those classes for you.
  
  =head1 ADVANCED USAGE
  
  Alternatively, if you don't want to use 'plugins' as the method ...
  
      package MyClass;
      use Module::Pluggable sub_name => 'foo';
  
  
  and then later ...
  
      my @plugins = $mc->foo();
  
  
  Or if you want to look in another namespace
  
      package MyClass;
      use Module::Pluggable search_path => ['Acme::MyClass::Plugin', 'MyClass::Extend'];
  
  or directory
  
      use Module::Pluggable search_dirs => ['mylibs/Foo'];
  
  
  Or if you want to instantiate each plugin rather than just return the name
  
      package MyClass;
      use Module::Pluggable instantiate => 'new';
  
  and then
  
      # whatever is passed to 'plugins' will be passed
      # to 'new' for each plugin
      my @plugins = $mc->plugins(@options);
  
  
  alternatively you can just require the module without instantiating it
  
      package MyClass;
      use Module::Pluggable require => 1;
  
  since requiring automatically searches inner packages, which may not be desirable, you can turn this off
  
  
      package MyClass;
      use Module::Pluggable require => 1, inner => 0;
  
  
  You can limit the plugins loaded using the except option, either as a string,
  array ref or regex
  
      package MyClass;
      use Module::Pluggable except => 'MyClass::Plugin::Foo';
  
  or
  
      package MyClass;
      use Module::Pluggable except => ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];
  
  or
  
      package MyClass;
      use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
  
  
  and similarly for only which will only load plugins which match.
  
  Remember you can use the module more than once
  
      package MyClass;
      use Module::Pluggable search_path => 'MyClass::Filters' sub_name => 'filters';
      use Module::Pluggable search_path => 'MyClass::Plugins' sub_name => 'plugins';
  
  and then later ...
  
      my @filters = $self->filters;
      my @plugins = $self->plugins;
  
  =head1 PLUGIN SEARCHING
  
  Every time you call 'plugins' the whole search path is walked again. This allows
  for dynamically loading plugins even at run time. However this can get expensive
  and so if you don't expect to want to add new plugins at run time you could do
  
  
    package Foo;
    use strict;
    use Module::Pluggable sub_name => '_plugins';
  
    our @PLUGINS;
    sub plugins { @PLUGINS ||= shift->_plugins }
    1;
  
  =head1 INNER PACKAGES
  
  If you have, for example, a file B<lib/Something/Plugin/Foo.pm> that
  contains package definitions for both C<Something::Plugin::Foo> and
  C<Something::Plugin::Bar> then as long as you either have either
  the B<require> or B<instantiate> option set then we'll also find
  C<Something::Plugin::Bar>. Nifty!
  
  =head1 OPTIONS
  
  You can pass a hash of options when importing this module.
  
  The options can be ...
  
  =head2 sub_name
  
  The name of the subroutine to create in your namespace.
  
  By default this is 'plugins'
  
  =head2 search_path
  
  An array ref of namespaces to look in.
  
  =head2 search_dirs
  
  An array ref of directories to look in before @INC.
  
  =head2 instantiate
  
  Call this method on the class. In general this will probably be 'new'
  but it can be whatever you want. Whatever arguments are passed to 'plugins'
  will be passed to the method.
  
  The default is 'undef' i.e just return the class name.
  
  =head2 require
  
  Just require the class, don't instantiate (overrides 'instantiate');
  
  =head2 inner
  
  If set to 0 will B<not> search inner packages.
  If set to 1 will override C<require>.
  
  =head2 only
  
  Takes a string, array ref or regex describing the names of the only plugins to
  return. Whilst this may seem perverse ... well, it is. But it also
  makes sense. Trust me.
  
  =head2 except
  
  Similar to C<only> it takes a description of plugins to exclude
  from returning. This is slightly less perverse.
  
  =head2 package
  
  This is for use by extension modules which build on C<Module::Pluggable>:
  passing a C<package> option allows you to place the plugin method in a
  different package other than your own.
  
  =head2 file_regex
  
  By default C<Module::Pluggable> only looks for I<.pm> files.
  
  By supplying a new C<file_regex> then you can change this behaviour e.g
  
      file_regex => qr/\.plugin$/
  
  =head2 include_editor_junk
  
  By default C<Module::Pluggable> ignores files that look like they were
  left behind by editors. Currently this means files ending in F<~> (~),
  the extensions F<.swp> or F<.swo>, or files beginning with F<.#>.
  
  Setting C<include_editor_junk> changes C<Module::Pluggable> so it does
  not ignore any files it finds.
  
  =head2 follow_symlinks
  
  Whether, when searching directories, to follow symlinks.
  
  Defaults to 1 i.e do follow symlinks.
  
  =head2 min_depth, max_depth
  
  This will allow you to set what 'depth' of plugin will be allowed.
  
  So, for example, C<MyClass::Plugin::Foo> will have a depth of 3 and
  C<MyClass::Plugin::Foo::Bar> will have a depth of 4 so to only get the former
  (i.e C<MyClass::Plugin::Foo>) do
  
          package MyClass;
          use Module::Pluggable max_depth => 3;
  
  and to only get the latter (i.e C<MyClass::Plugin::Foo::Bar>)
  
          package MyClass;
          use Module::Pluggable min_depth => 4;
  
  
  =head1 TRIGGERS
  
  Various triggers can also be passed in to the options.
  
  If any of these triggers return 0 then the plugin will not be returned.
  
  =head2 before_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will not be required either.
  
  =head2 on_require_error <plugin> <err>
  
  Gets called when there's an error on requiring the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_require_error handler is to C<carp> the error and return 0.
  
  =head2 on_instantiate_error <plugin> <err>
  
  Gets called when there's an error on instantiating the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_instantiate_error handler is to C<carp> the error and return 0.
  
  =head2 after_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will be required but not returned as a plugin.
  
  =head1 METHODs
  
  =head2 search_path
  
  The method C<search_path> is exported into you namespace as well.
  You can call that at any time to change or replace the
  search_path.
  
      $self->search_path( add => "New::Path" ); # add
      $self->search_path( new => "New::Path" ); # replace
  
  =head1 BEHAVIOUR UNDER TEST ENVIRONMENT
  
  In order to make testing reliable we exclude anything not from blib if blib.pm is
  in %INC.
  
  However if the module being tested used another module that itself used C<Module::Pluggable>
  then the second module would fail. This was fixed by checking to see if the caller
  had (^|/)blib/ in their filename.
  
  There's an argument that this is the wrong behaviour and that modules should explicitly
  trigger this behaviour but that particular code has been around for 7 years now and I'm
  reluctant to change the default behaviour.
  
  You can now (as of version 4.1) force Module::Pluggable to look outside blib in a test environment by doing either
  
          require Module::Pluggable;
          $Module::Pluggable::FORCE_SEARCH_ALL_PATHS = 1;
          import Module::Pluggable;
  
  or
  
          use Module::Pluggable force_search_all_paths => 1;
  
  =head1 @INC hooks and App::FatPacker
  
  If a module's @INC has a hook and that hook is an object which has a C<files()> method then we will
  try and require those files too. See C<t/26inc_hook.t> for an example.
  
  This has allowed L<App::FatPacker> (as of version 0.10.0) to provide support for Module::Pluggable.
  
  This should also, theoretically, allow someone to modify PAR to do the same thing.
  
  =head1 Module::Require recommended
  
  Up until version 5.2 L<Module::Pluggable> used a string C<eval> to require plugins.
  
  This has now been changed to optionally use L<Module::Runtime> and it's C<require_module> method when
  available and fall back to using a path based C<require> when not.
  
  It's recommended, but not required, that you install Module::Runtime.
  
  =head1 FUTURE PLANS
  
  This does everything I need and I can't really think of any other
  features I want to add. Famous last words of course (not least
  because we're up to version 5.0 at the time of writing).
  
  However suggestions (and patches) are always welcome.
  
  =head1 DEVELOPMENT
  
  The master repo for this module is at
  
  https://github.com/simonwistow/Module-Pluggable
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<File::Find>, L<File::Basename>, L<Class::Factory::Util>, L<Module::Pluggable::Ordered>
  
  =cut
  
  
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;
  
  use strict;
  use File::Find ();
  use File::Basename;
  use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);
  use Carp qw(croak carp confess);
  use Devel::InnerPackage;
  use vars qw($VERSION $MR);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '5.2';
  
  BEGIN {
      eval {  require Module::Runtime };
      unless ($@) {
          Module::Runtime->import('require_module');
      } else {
          *require_module = sub {
              my $module = shift;
              my $path   = $module . ".pm";
              $path =~ s{::}{/}g;
              require $path;
          };
      }
  }
  
  
  sub new {
      my $class = shift;
      my %opts  = @_;
  
      return bless \%opts, $class;
  
  }
  
  ### Eugggh, this code smells 
  ### This is what happens when you keep adding patches
  ### *sigh*
  
  
  sub plugins {
      my $self = shift;
      my @args = @_;
  
      # override 'require'
      $self->{'require'} = 1 if $self->{'inner'};
  
      my $filename   = $self->{'filename'};
      my $pkg        = $self->{'package'};
  
      # Get the exception params instantiated
      $self->_setup_exceptions;
  
      # automatically turn a scalar search path or namespace into a arrayref
      for (qw(search_path search_dirs)) {
          $self->{$_} = [ $self->{$_} ] if exists $self->{$_} && !ref($self->{$_});
      }
  
      # default search path is '<Module>::<Name>::Plugin'
      $self->{'search_path'} ||= ["${pkg}::Plugin"]; 
  
      # default error handler
      $self->{'on_require_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't require $plugin : $err"; return 0 };
      $self->{'on_instantiate_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't instantiate $plugin: $err"; return 0 };
  
      # default whether to follow symlinks
      $self->{'follow_symlinks'} = 1 unless exists $self->{'follow_symlinks'};
  
      # check to see if we're running under test
      my @SEARCHDIR = exists $INC{"blib.pm"} && defined $filename && $filename =~ m!(^|/)blib/! && !$self->{'force_search_all_paths'} ? grep {/blib/} @INC : @INC;
  
      # add any search_dir params
      unshift @SEARCHDIR, @{$self->{'search_dirs'}} if defined $self->{'search_dirs'};
  
      # set our @INC up to include and prefer our search_dirs if necessary
      my @tmp = @INC;
      unshift @tmp, @{$self->{'search_dirs'} || []};
      local @INC = @tmp if defined $self->{'search_dirs'};
  
      my @plugins = $self->search_directories(@SEARCHDIR);
      push(@plugins, $self->handle_inc_hooks($_, @SEARCHDIR)) for @{$self->{'search_path'}};
      push(@plugins, $self->handle_innerpackages($_)) for @{$self->{'search_path'}};
      
      # return blank unless we've found anything
      return () unless @plugins;
  
      # remove duplicates
      # probably not necessary but hey ho
      my %plugins;
      for(@plugins) {
          next unless $self->_is_legit($_);
          $plugins{$_} = 1;
      }
  
      # are we instantiating or requiring?
      if (defined $self->{'instantiate'}) {
          my $method = $self->{'instantiate'};
          my @objs   = ();
          foreach my $package (sort keys %plugins) {
              next unless $package->can($method);
              my $obj = eval { $package->$method(@_) };
              $self->{'on_instantiate_error'}->($package, $@) if $@;
              push @objs, $obj if $obj;           
          }
          return @objs;
      } else { 
          # no? just return the names
          my @objs= sort keys %plugins;
          return @objs;
      }
  }
  
  sub _setup_exceptions {
      my $self = shift;
  
      my %only;   
      my %except; 
      my $only;
      my $except;
  
      if (defined $self->{'only'}) {
          if (ref($self->{'only'}) eq 'ARRAY') {
              %only   = map { $_ => 1 } @{$self->{'only'}};
          } elsif (ref($self->{'only'}) eq 'Regexp') {
              $only = $self->{'only'}
          } elsif (ref($self->{'only'}) eq '') {
              $only{$self->{'only'}} = 1;
          }
      }
          
  
      if (defined $self->{'except'}) {
          if (ref($self->{'except'}) eq 'ARRAY') {
              %except   = map { $_ => 1 } @{$self->{'except'}};
          } elsif (ref($self->{'except'}) eq 'Regexp') {
              $except = $self->{'except'}
          } elsif (ref($self->{'except'}) eq '') {
              $except{$self->{'except'}} = 1;
          }
      }
      $self->{_exceptions}->{only_hash}   = \%only;
      $self->{_exceptions}->{only}        = $only;
      $self->{_exceptions}->{except_hash} = \%except;
      $self->{_exceptions}->{except}      = $except;
          
  }
  
  sub _is_legit {
      my $self   = shift;
      my $plugin = shift;
      my %only   = %{$self->{_exceptions}->{only_hash}||{}};
      my %except = %{$self->{_exceptions}->{except_hash}||{}};
      my $only   = $self->{_exceptions}->{only};
      my $except = $self->{_exceptions}->{except};
      my $depth  = () = split '::', $plugin, -1;
  
      return 0 if     (keys %only   && !$only{$plugin}     );
      return 0 unless (!defined $only || $plugin =~ m!$only!     );
  
      return 0 if     (keys %except &&  $except{$plugin}   );
      return 0 if     (defined $except &&  $plugin =~ m!$except! );
      
      return 0 if     defined $self->{max_depth} && $depth>$self->{max_depth};
      return 0 if     defined $self->{min_depth} && $depth<$self->{min_depth};
  
      return 1;
  }
  
  sub search_directories {
      my $self      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      # go through our @INC
      foreach my $dir (@SEARCHDIR) {
          push @plugins, $self->search_paths($dir);
      }
      return @plugins;
  }
  
  
  sub search_paths {
      my $self = shift;
      my $dir  = shift;
      my @plugins;
  
      my $file_regex = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # and each directory in our search path
      foreach my $searchpath (@{$self->{'search_path'}}) {
          # create the search directory in a cross platform goodness way
          my $sp = catdir($dir, (split /::/, $searchpath));
  
          # if it doesn't exist or it's not a dir then skip it
          next unless ( -e $sp && -d _ ); # Use the cached stat the second time
  
          my @files = $self->find_files($sp);
  
          # foreach one we've found 
          foreach my $file (@files) {
              # untaint the file; accept .pm only
              next unless ($file) = ($file =~ /(.*$file_regex)$/); 
              # parse the file to get the name
              my ($name, $directory, $suffix) = fileparse($file, $file_regex);
  
              next if (!$self->{include_editor_junk} && $self->_is_editor_junk($name));
  
              $directory = abs2rel($directory, $sp);
  
              # If we have a mixed-case package name, assume case has been preserved
              # correctly.  Otherwise, root through the file to locate the case-preserved
              # version of the package name.
              my @pkg_dirs = ();
              if ( $name eq lc($name) || $name eq uc($name) ) {
                  my $pkg_file = catfile($sp, $directory, "$name$suffix");
                  open PKGFILE, "<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";
                  my $in_pod = 0;
                  while ( my $line = <PKGFILE> ) {
                      $in_pod = 1 if $line =~ m/^=\w/;
                      $in_pod = 0 if $line =~ /^=cut/;
                      next if ($in_pod || $line =~ /^=cut/);  # skip pod text
                      next if $line =~ /^\s*#/;               # and comments
                      if ( $line =~ m/^\s*package\s+(.*::)?($name)\s*;/i ) {
                          @pkg_dirs = split /::/, $1 if defined $1;;
                          $name = $2;
                          last;
                      }
                  }
                  close PKGFILE;
              }
  
              # then create the class name in a cross platform way
              $directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);       # remove volume
              my @dirs = ();
              if ($directory) {
                  ($directory) = ($directory =~ /(.*)/);
                  @dirs = grep(length($_), splitdir($directory)) 
                      unless $directory eq curdir();
                  for my $d (reverse @dirs) {
                      my $pkg_dir = pop @pkg_dirs; 
                      last unless defined $pkg_dir;
                      $d =~ s/\Q$pkg_dir\E/$pkg_dir/i;  # Correct case
                  }
              } else {
                  $directory = "";
              }
              my $plugin = join '::', $searchpath, @dirs, $name;
  
              next unless $plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;
  
              $self->handle_finding_plugin($plugin, \@plugins)
          }
  
          # now add stuff that may have been in package
          # NOTE we should probably use all the stuff we've been given already
          # but then we can't unload it :(
          push @plugins, $self->handle_innerpackages($searchpath);
      } # foreach $searchpath
  
      return @plugins;
  }
  
  sub _is_editor_junk {
      my $self = shift;
      my $name = shift;
  
      # Emacs (and other Unix-y editors) leave temp files ending in a
      # tilde as a backup.
      return 1 if $name =~ /~$/;
      # Emacs makes these files while a buffer is edited but not yet
      # saved.
      return 1 if $name =~ /^\.#/;
      # Vim can leave these files behind if it crashes.
      return 1 if $name =~ /\.sw[po]$/;
  
      return 0;
  }
  
  sub handle_finding_plugin {
      my $self    = shift;
      my $plugin  = shift;
      my $plugins = shift;
      my $no_req  = shift || 0;
      
      return unless $self->_is_legit($plugin);
      unless (defined $self->{'instantiate'} || $self->{'require'}) {
          push @$plugins, $plugin;
          return;
      } 
  
      $self->{before_require}->($plugin) || return if defined $self->{before_require};
      unless ($no_req) {
          my $tmp = $@;
          my $res = eval { require_module($plugin) };
          my $err = $@;
          $@      = $tmp;
          if ($err) {
              if (defined $self->{on_require_error}) {
                  $self->{on_require_error}->($plugin, $err) || return; 
              } else {
                  return;
              }
          }
      }
      $self->{after_require}->($plugin) || return if defined $self->{after_require};
      push @$plugins, $plugin;
  }
  
  sub find_files {
      my $self         = shift;
      my $search_path  = shift;
      my $file_regex   = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # find all the .pm files in it
      # this isn't perfect and won't find multiple plugins per file
      #my $cwd = Cwd::getcwd;
      my @files = ();
      { # for the benefit of perl 5.6.1's Find, localize topic
          local $_;
          File::Find::find( { no_chdir => 1, 
                              follow   => $self->{'follow_symlinks'}, 
                              wanted   => sub { 
                               # Inlined from File::Find::Rule C< name => '*.pm' >
                               return unless $File::Find::name =~ /$file_regex/;
                               (my $path = $File::Find::name) =~ s#^\\./##;
                               push @files, $path;
                             }
                        }, $search_path );
      }
      #chdir $cwd;
      return @files;
  
  }
  
  sub handle_inc_hooks {
      my $self      = shift;
      my $path      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      for my $dir ( @SEARCHDIR ) {
          next unless ref $dir && eval { $dir->can( 'files' ) };
  
          foreach my $plugin ( $dir->files ) {
              $plugin =~ s/\.pm$//;
              $plugin =~ s{/}{::}g;
              next unless $plugin =~ m!^${path}::!;
              $self->handle_finding_plugin( $plugin, \@plugins );
          }
      }
      return @plugins;
  }
  
  sub handle_innerpackages {
      my $self = shift;
      return () if (exists $self->{inner} && !$self->{inner});
  
      my $path = shift;
      my @plugins;
  
      foreach my $plugin (Devel::InnerPackage::list_packages($path)) {
          $self->handle_finding_plugin($plugin, \@plugins, 1);
      }
      return @plugins;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable::Object - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable::Object;
      
      my $finder = Module::Pluggable::Object->new(%opts);
      print "My plugins are: ".join(", ", $finder->plugins)."\n";
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  This object is wrapped by C<Module::Pluggable>. If you want to do something
  odd or add non-general special features you're probably best to wrap this
  and produce your own subclass.
  
  =head1 OPTIONS
  
  See the C<Module::Pluggable> docs.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<Module::Pluggable>
  
  =cut 
  
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"String/RewritePrefix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_REWRITEPREFIX';
  use strict;
  use warnings;
  package String::RewritePrefix;
  {
    $String::RewritePrefix::VERSION = '0.007';
  }
  use Carp ();
  # ABSTRACT: rewrite strings based on a set of known prefixes
  
  # 0.972 allows \'method_name' form -- rjbs, 2010-10-25
  use Sub::Exporter 0.972 -setup => {
    exports => [ rewrite => \'_new_rewriter' ],
  };
  
  
  sub rewrite {
    my ($self, $arg, @rest) = @_;
    return $self->_new_rewriter(rewrite => { prefixes => $arg })->(@rest);
  }
  
  sub _new_rewriter {
    my ($self, $name, $arg) = @_;
    my $rewrites = $arg->{prefixes} || {};
  
    my @rewrites;
    for my $prefix (sort { length $b <=> length $a } keys %$rewrites) {
      push @rewrites, ($prefix, $rewrites->{$prefix});
    }
  
    return sub {
      my @result;
  
      Carp::cluck("string rewriter invoked in void context")
        unless defined wantarray;
  
      Carp::croak("attempt to rewrite multiple strings outside of list context")
        if @_ > 1 and ! wantarray;
  
      STRING: for my $str (@_) {
        for (my $i = 0; $i < @rewrites; $i += 2) {
          if (index($str, $rewrites[$i]) == 0) {
            if (ref $rewrites[$i+1]) {
              my $rest = substr $str, length($rewrites[$i]);
              my $str  = $rewrites[ $i+1 ]->($rest);
              push @result, (defined $str ? $str : '') . $rest;
            } else {
              push @result, $rewrites[$i+1] . substr $str, length($rewrites[$i]);
            }
            next STRING;
          }
        }
  
        push @result, $str;
      }
      
      return wantarray ? @result : $result[0];
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  String::RewritePrefix - rewrite strings based on a set of known prefixes
  
  =head1 VERSION
  
  version 0.007
  
  =head1 SYNOPSIS
  
    use String::RewritePrefix;
    my @to_load = String::RewritePrefix->rewrite(
      { '' => 'MyApp::', '+' => '' },
      qw(Plugin Mixin Addon +Corporate::Thinger),
    );
  
    # now you have:
    qw(MyApp::Plugin MyApp::Mixin MyApp::Addon Corporate::Thinger)
  
  You can also import a rewrite routine:
  
    use String::RewritePrefix rewrite => {
      -as => 'rewrite_dt_prefix',
      prefixes => { '' => 'MyApp::', '+' => '' },
    };
  
    my @to_load = rewrite_dt_prefix( qw(Plugin Mixin Addon +Corporate::Thinger));
  
    # now you have:
    qw(MyApp::Plugin MyApp::Mixin MyApp::Addon Corporate::Thinger)
  
  =head1 METHODS
  
  =head2 rewrite
  
    String::RewritePrefix->rewrite(\%prefix, @strings);
  
  This rewrites all the given strings using the rules in C<%prefix>.  Its keys
  are known prefixes for which its values will be substituted.  This is performed
  in longest-first order, and only one prefix will be rewritten.
  
  If the prefix value is a coderef, it will be executed with the remaining string
  as its only argument.  The return value will be used as the prefix.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
STRING_REWRITEPREFIX

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Test/DZil.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DZIL';
  use strict;
  use warnings;
  package Test::DZil 6.007;
  # ABSTRACT: tools for testing Dist::Zilla plugins
  
  use Params::Util qw(_HASH0);
  use JSON::MaybeXS;
  use Scalar::Util qw(blessed);
  use Test::Deep ();
  use YAML::Tiny;
  
  use Sub::Exporter -setup => {
    exports => [
      is_filelist =>
      is_yaml     =>
      is_json     =>
      dist_ini    => \'_dist_ini',
      simple_ini  => \'_simple_ini',
      Builder     =>
      Minter      =>
    ],
    groups  => [ default => [ qw(-all) ] ],
  };
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Test::DZil provides routines for writing tests for Dist::Zilla plugins.
  #pod
  #pod =cut
  
  #pod =func Builder
  #pod
  #pod =func Minter
  #pod
  #pod   my $tzil = Builder->from_config(...);
  #pod
  #pod These return class names that subclass L<Dist::Zilla::Dist::Builder> or
  #pod L<Dist::Zilla::Dist::Minter>, respectively, with the L<Dist::Zilla::Tester>
  #pod behavior added.
  #pod
  #pod =cut
  
  sub Builder {
    require Dist::Zilla::Tester;
    Dist::Zilla::Tester::builder();
  }
  
  sub Minter {
    require Dist::Zilla::Tester;
    Dist::Zilla::Tester::minter();
  }
  
  #pod =func is_filelist
  #pod
  #pod   is_filelist( \@files_we_have, \@files_we_want, $desc );
  #pod
  #pod This test assertion compares two arrayrefs of filenames, taking care of slash
  #pod normalization and sorting.  C<@files_we_have> may also contain objects that
  #pod do L<Dist::Zilla::Role::File>.
  #pod
  #pod =cut
  
  sub is_filelist {
    my ($have, $want, $comment) = @_;
  
    my @want = @$want;
    my @have = map { my $str = (blessed $_ and
                                $_->DOES('Dist::Zilla::Role::File'))
                         ? $_->name
                         : $_;
                     $str =~ s{\\}{/}g; $str } @$have;
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    Test::Deep::cmp_bag(\@have, \@want, $comment);
  }
  
  #pod =func is_yaml
  #pod
  #pod   is_yaml( $yaml_string, $want_struct, $comment );
  #pod
  #pod This test assertion deserializes the given YAML string and does a
  #pod C<L<cmp_deeply|Test::Deep/cmp_deeply>>.
  #pod
  #pod =cut
  
  sub is_yaml {
    my ($yaml, $want, $comment) = @_;
  
    my $have = YAML::Tiny->read_string($yaml)
      or die "Cannot decode YAML";
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    Test::Deep::cmp_deeply($have->[0], $want, $comment);
  }
  
  #pod =func is_json
  #pod
  #pod   is_json( $json_string, $want_struct, $comment );
  #pod
  #pod This test assertion deserializes the given JSON string and does a
  #pod C<L<cmp_deeply|Test::Deep/cmp_deeply>>.
  #pod
  #pod =cut
  
  sub is_json {
    my ($json, $want, $comment) = @_;
  
    my $have = JSON::MaybeXS->new(ascii => 1)->decode($json)
      or die "Cannot decode JSON";
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    Test::Deep::cmp_deeply($have, $want, $comment);
  }
  
  sub _build_ini_builder {
    my ($starting_core) = @_;
    $starting_core ||= {};
  
    sub {
      my (@arg) = @_;
      my $new_core = _HASH0($arg[0]) ? shift(@arg) : {};
  
      my $core_config = { %$starting_core, %$new_core };
  
      my $config = '';
  
      for my $key (sort keys %$core_config) {
        my @values = ref $core_config->{ $key }
                   ? @{ $core_config->{ $key } }
                   : $core_config->{ $key };
  
        $config .= "$key = $_\n" for grep {defined} @values;
      }
  
      $config .= "\n" if length $config;
  
      for my $line (@arg) {
        my @plugin = ref $line ? @$line : ($line, {});
        my $moniker = shift @plugin;
        my $name    = _HASH0($plugin[0]) ? undef : shift @plugin;
        my $payload = shift(@plugin) || {};
  
        Carp::confess("bogus plugin configuration: too many args") if @plugin;
  
        $config .= '[' . $moniker;
        $config .= ' / ' . $name if defined $name;
        $config .= "]\n";
  
        for my $key (sort keys %$payload) {
          my @values = ref $payload->{ $key }
                     ? @{ $payload->{ $key } }
                     : $payload->{ $key };
  
          $config .= "$key = $_\n" for grep {defined} @values;
        }
  
        $config .= "\n";
      }
  
      return $config;
    }
  }
  
  #pod =func dist_ini
  #pod
  #pod   my $ini_text = dist_ini(\%root_config, @plugins);
  #pod
  #pod This routine returns a string that could be used to populate a simple
  #pod F<dist.ini> file.  The C<%root_config> gives data for the "root" section of the
  #pod configuration.  To provide a line multiple times, provide an arrayref.  For
  #pod example, the root section could read:
  #pod
  #pod   {
  #pod     name   => 'Dist-Sample',
  #pod     author => [
  #pod       'J. Smith <jsmith@example.com>',
  #pod       'Q. Smith <qsmith@example.com>',
  #pod     ],
  #pod   }
  #pod
  #pod The root section is optional.
  #pod
  #pod Plugins can be given in a few ways:
  #pod
  #pod =begin :list
  #pod
  #pod = C<"PluginMoniker">
  #pod
  #pod = C<[ "PluginMoniker" ]>
  #pod
  #pod These become C<[PluginMoniker]>
  #pod
  #pod = C<[ "PluginMoniker", "PluginName" ]>
  #pod
  #pod This becomes C<[PluginMoniker / PluginName]>
  #pod
  #pod = C<[ "PluginMoniker", { ... } ]>
  #pod
  #pod = C<[ "PluginMoniker", "PluginName", { ... } ]>
  #pod
  #pod These use the given hashref as the parameters inside the section, with the same
  #pod semantics as the root section.
  #pod
  #pod =end :list
  #pod
  #pod =cut
  
  sub _dist_ini {
    _build_ini_builder;
  }
  
  #pod =func simple_ini
  #pod
  #pod This behaves exactly like C<dist_ini>, but it merges any given root config into
  #pod a starter config, which means that you can often skip any explicit root config.
  #pod The starter config may change slightly over time, but is something like this:
  #pod
  #pod   {
  #pod     name     => 'DZT-Sample',
  #pod     abstract => 'Sample DZ Dist',
  #pod     version  => '0.001',
  #pod     author   => 'E. Xavier Ample <example@example.org>',
  #pod     license  => 'Perl_5',
  #pod     copyright_holder => 'E. Xavier Ample',
  #pod   }
  #pod
  #pod =cut
  
  sub _simple_ini {
    _build_ini_builder({
      name     => 'DZT-Sample',
      abstract => 'Sample DZ Dist',
      version  => '0.001',
      author   => 'E. Xavier Ample <example@example.org>',
      license  => 'Perl_5',
      copyright_holder => 'E. Xavier Ample',
    });
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::DZil - tools for testing Dist::Zilla plugins
  
  =head1 VERSION
  
  version 6.007
  
  =head1 DESCRIPTION
  
  Test::DZil provides routines for writing tests for Dist::Zilla plugins.
  
  =head1 FUNCTIONS
  
  =head2 Builder
  
  =head2 Minter
  
    my $tzil = Builder->from_config(...);
  
  These return class names that subclass L<Dist::Zilla::Dist::Builder> or
  L<Dist::Zilla::Dist::Minter>, respectively, with the L<Dist::Zilla::Tester>
  behavior added.
  
  =head2 is_filelist
  
    is_filelist( \@files_we_have, \@files_we_want, $desc );
  
  This test assertion compares two arrayrefs of filenames, taking care of slash
  normalization and sorting.  C<@files_we_have> may also contain objects that
  do L<Dist::Zilla::Role::File>.
  
  =head2 is_yaml
  
    is_yaml( $yaml_string, $want_struct, $comment );
  
  This test assertion deserializes the given YAML string and does a
  C<L<cmp_deeply|Test::Deep/cmp_deeply>>.
  
  =head2 is_json
  
    is_json( $json_string, $want_struct, $comment );
  
  This test assertion deserializes the given JSON string and does a
  C<L<cmp_deeply|Test::Deep/cmp_deeply>>.
  
  =head2 dist_ini
  
    my $ini_text = dist_ini(\%root_config, @plugins);
  
  This routine returns a string that could be used to populate a simple
  F<dist.ini> file.  The C<%root_config> gives data for the "root" section of the
  configuration.  To provide a line multiple times, provide an arrayref.  For
  example, the root section could read:
  
    {
      name   => 'Dist-Sample',
      author => [
        'J. Smith <jsmith@example.com>',
        'Q. Smith <qsmith@example.com>',
      ],
    }
  
  The root section is optional.
  
  Plugins can be given in a few ways:
  
  =over 4
  
  =item C<"PluginMoniker">
  
  =item C<[ "PluginMoniker" ]>
  
  These become C<[PluginMoniker]>
  
  =item C<[ "PluginMoniker", "PluginName" ]>
  
  This becomes C<[PluginMoniker / PluginName]>
  
  =item C<[ "PluginMoniker", { ... } ]>
  
  =item C<[ "PluginMoniker", "PluginName", { ... } ]>
  
  These use the given hashref as the parameters inside the section, with the same
  semantics as the root section.
  
  =back
  
  =head2 simple_ini
  
  This behaves exactly like C<dist_ini>, but it merges any given root config into
  a starter config, which means that you can often skip any explicit root config.
  The starter config may change slightly over time, but is something like this:
  
    {
      name     => 'DZT-Sample',
      abstract => 'Sample DZ Dist',
      version  => '0.001',
      author   => 'E. Xavier Ample <example@example.org>',
      license  => 'Perl_5',
      copyright_holder => 'E. Xavier Ample',
    }
  
  =head1 AUTHOR
  
  Ricardo SIGNES 😏 <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEST_DZIL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.23-3-g5ee27f1
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.24';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    _subname("${caller}::try {...} " => $try)
      if _HAS_SUBNAME;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::catch {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::finally {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.24
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jonathan Yu Marc Mims Stosberg
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"darwin-2level/Class/Load/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_LOAD_XS';
  package Class::Load::XS;
  # git description: v0.08-18-g349ac6e
  $Class::Load::XS::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Class::Load 0.20;
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      exists $Class::Load::XS::{VERSION}
          ? ${ $Class::Load::XS::{VERSION} }
          : (),
  );
  
  1;
  
  # ABSTRACT: XS implementation of parts of Class::Load
  # KEYWORDS: class module load require use runtime XS
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load::XS - XS implementation of parts of Class::Load
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
      use Class::Load;
  
  =head1 DESCRIPTION
  
  This module provides an XS implementation for portions of L<Class::Load>. See
  L<Class::Load> for API details.
  
  =for Pod::Coverage is_class_loaded
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2011 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Jesse Luehrs hurricup
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Karen Etheridge <github@froods.org>
  
  =item *
  
  hurricup <hurricup@gmail.com>
  
  =back
  
  =cut
DARWIN-2LEVEL_CLASS_LOAD_XS

$fatpacked{"darwin-2level/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.45";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
DARWIN-2LEVEL_LIST_UTIL

$fatpacked{"darwin-2level/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.45";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_LIST_UTIL_XS

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DARWIN-2LEVEL_PARAMS_UTIL

$fatpacked{"darwin-2level/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SCALAR_UTIL

$fatpacked{"darwin-2level/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
DARWIN-2LEVEL_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl
use strict;
use warnings;
package
  dzil;
use Dist::Zilla::App;
# Let dzil --version know what to report:
$main::VERSION = $Dist::Zilla::App::VERSION;

# PODNAME:  dzil
# ABSTRACT: do stuff with your dist
Dist::Zilla::App->run;

#pod =head1 OVERVIEW
#pod
#pod For help with L<Dist::Zilla|Dist::Zilla>, start with L<http://dzil.org/> or
#pod by running C<dzil commands>.
#pod
#pod =cut

__END__

=pod

=encoding UTF-8

=head1 NAME

dzil - do stuff with your dist

=head1 VERSION

version 6.007

=head1 OVERVIEW

For help with L<Dist::Zilla|Dist::Zilla>, start with L<http://dzil.org/> or
by running C<dzil commands>.

=head1 AUTHOR

Ricardo SIGNES 😏 <rjbs@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2016 by Ricardo SIGNES.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
