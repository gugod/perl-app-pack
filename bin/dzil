#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Cmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD';
  use strict;
  use warnings;
  use 5.006;
  
  package App::Cmd;
  $App::Cmd::VERSION = '0.331';
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  # ABSTRACT: write command line apps with less suffering
  
  use File::Basename ();
  use Module::Pluggable::Object ();
  use Class::Load ();
  
  use Sub::Exporter -setup => {
    collectors => {
      -ignore  => \'_setup_ignore',
      -command => \'_setup_command',
      -run     => sub {
        warn "using -run to run your command is deprecated\n";
        $_[1]->{class}->run; 1
      },
    },
  };
  
  sub _setup_command {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -command setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    {
      my $base = $self->_default_command_base;
      Class::Load::load_class($base);
      no strict 'refs';
      push @{"$into\::ISA"}, $base;
    }
  
    $self->_register_command($into);
  
    for my $plugin ($self->_plugin_plugins) {
      $plugin->import_from_plugin({ into => $into });
    }
  
    1;
  }
  
  sub _setup_ignore {
    my ($self, $val, $data ) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -ignore setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    $self->_register_ignore($into);
  
    1;
  }
  
  sub _plugin_plugins { return }
  
  #pod =head1 SYNOPSIS
  #pod
  #pod in F<yourcmd>:
  #pod
  #pod   use YourApp;
  #pod   YourApp->run;
  #pod
  #pod in F<YourApp.pm>:
  #pod
  #pod   package YourApp;
  #pod   use App::Cmd::Setup -app;
  #pod   1;
  #pod
  #pod in F<YourApp/Command/blort.pm>:
  #pod
  #pod   package YourApp::Command::blort;
  #pod   use YourApp -command;
  #pod   use strict; use warnings;
  #pod
  #pod   sub abstract { "blortex algorithm" }
  #pod
  #pod   sub description { "Long description on blortex algorithm" }
  #pod
  #pod   sub opt_spec {
  #pod     return (
  #pod       [ "blortex|X",  "use the blortex algorithm" ],
  #pod       [ "recheck|r",  "recheck all results"       ],
  #pod     );
  #pod   }
  #pod
  #pod   sub validate_args {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     # no args allowed but options!
  #pod     $self->usage_error("No args allowed") if @$args;
  #pod   }
  #pod
  #pod   sub execute {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     my $result = $opt->{blortex} ? blortex() : blort();
  #pod
  #pod     recheck($result) if $opt->{recheck};
  #pod
  #pod     print $result;
  #pod   }
  #pod
  #pod and, finally, at the command line:
  #pod
  #pod   knight!rjbs$ yourcmd blort --recheck
  #pod
  #pod   All blorts successful.
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod App::Cmd is intended to make it easy to write complex command-line applications
  #pod without having to think about most of the annoying things usually involved.
  #pod
  #pod For information on how to start using App::Cmd, see L<App::Cmd::Tutorial>.
  #pod
  #pod =method new
  #pod
  #pod   my $cmd = App::Cmd->new(\%arg);
  #pod
  #pod This method returns a new App::Cmd object.  During initialization, command
  #pod plugins will be loaded.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   no_commands_plugin - if true, the command list plugin is not added
  #pod
  #pod   no_help_plugin     - if true, the help plugin is not added
  #pod
  #pod   no_version_plugin  - if true, the version plugin is not added
  #pod
  #pod   show_version_cmd -   if true, the version command will be shown in the
  #pod                        command list
  #pod
  #pod   plugin_search_path - The path to search for commands in. Defaults to
  #pod                        results of plugin_search_path method
  #pod
  #pod If C<no_commands_plugin> is not given, L<App::Cmd::Command::commands> will be
  #pod required, and it will be registered to handle all of its command names not
  #pod handled by other plugins.
  #pod
  #pod If C<no_help_plugin> is not given, L<App::Cmd::Command::help> will be required,
  #pod and it will be registered to handle all of its command names not handled by
  #pod other plugins. B<Note:> "help" is the default command, so if you do not load
  #pod the default help plugin, you should provide your own or override the
  #pod C<default_command> method.
  #pod
  #pod If C<no_version_plugin> is not given, L<App::Cmd::Command::version> will be
  #pod required to show the application's version with command C<--version>. By
  #pod default, the version command is not included in the command list. Pass
  #pod C<show_version_cmd> to include the version command in the list.
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
  
    my $arg0 = $0;
    my $base = File::Basename::basename $arg0;
  
    my $self = {
      command      => $class->_command($arg),
      arg0         => $base,
      full_arg0    => $arg0,
      show_version => $arg->{show_version_cmd} || 0,
    };
  
    bless $self => $class;
  }
  
  # effectively, returns the command-to-plugin mapping guts of a Cmd
  # if called on a class or on a Cmd with no mapping, construct a new hashref
  # suitable for use as the object's mapping
  sub _command {
    my ($self, $arg) = @_;
    return $self->{command} if ref $self and $self->{command};
  
    # TODO _default_command_base can be wrong if people are not using
    # ::Setup and have no ::Command :(
    #
    #  my $want_isa = $self->_default_command_base;
    # -- kentnl, 2010-12
    my $want_isa = 'App::Cmd::Command';
  
    my %plugin;
    for my $plugin ($self->_plugins) {
  
      Class::Load::load_class($plugin);
  
      # relies on either the plugin itself registering as ignored
      # during compile ( use MyApp::Cmd -ignore )
      # or being explicitly registered elsewhere ( blacklisted )
      # via $app_cmd->_register_ignore( $class )
      #  -- kentnl, 2011-09
      next if $self->should_ignore( $plugin );
  
      die "$plugin is not a " . $want_isa
        unless $plugin->isa($want_isa);
  
      next unless $plugin->can("command_names");
  
      foreach my $command (map { lc } $plugin->command_names) {
        die "two plugins for command $command: $plugin and $plugin{$command}\n"
          if exists $plugin{$command};
  
        $plugin{$command} = $plugin;
      }
    }
  
    $self->_load_default_plugin($_, $arg, \%plugin) for qw(commands help version);
  
    if ($self->allow_any_unambiguous_abbrev) {
      # add abbreviations to list of authorized commands
      require Text::Abbrev;
      my %abbrev = Text::Abbrev::abbrev( keys %plugin );
      @plugin{ keys %abbrev } = @plugin{ values %abbrev };
    }
  
    return \%plugin;
  }
  
  # ->_plugins won't be called more than once on any given App::Cmd, but since
  # finding plugins can be a bit expensive, we'll do a lousy cache here.
  # -- rjbs, 2007-10-09
  my %plugins_for;
  sub _plugins {
    my ($self) = @_;
    my $class = ref $self || $self;
  
    return @{ $plugins_for{$class} } if $plugins_for{$class};
  
    my $finder = Module::Pluggable::Object->new(
      search_path => $self->plugin_search_path,
      $self->_module_pluggable_options,
    );
  
    my @plugins = $finder->plugins;
    $plugins_for{$class} = \@plugins;
  
    return @plugins;
  }
  
  sub _register_command {
    my ($self, $cmd_class) = @_;
    $self->_plugins;
  
    my $class = ref $self || $self;
    push @{ $plugins_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $plugins_for{ $class } };
  }
  
  my %ignored_for;
  
  sub should_ignore {
    my ( $self , $cmd_class ) = @_;
    my $class = ref $self || $self;
    for ( @{ $ignored_for{ $class } } ) {
      return 1 if $_ eq $cmd_class;
    }
    return;
  }
  
  sub _register_ignore {
    my ($self, $cmd_class) = @_;
    my $class = ref $self || $self;
    push @{ $ignored_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $ignored_for{ $class } };
  }
  
  sub _module_pluggable_options {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return;
  }
  
  # load one of the stock plugins, unless requested to squash; unlike normal
  # plugin loading, command-to-plugin mapping conflicts are silently ignored
  sub _load_default_plugin {
    my ($self, $plugin_name, $arg, $plugin_href) = @_;
    unless ($arg->{"no_$plugin_name\_plugin"}) {
      my $plugin = "App::Cmd::Command::$plugin_name";
      Class::Load::load_class($plugin);
      for my $command (map { lc } $plugin->command_names) {
        $plugin_href->{$command} ||= $plugin;
      }
    }
  }
  
  #pod =method run
  #pod
  #pod   $cmd->run;
  #pod
  #pod This method runs the application.  If called the class, it will instantiate a
  #pod new App::Cmd object to run.
  #pod
  #pod It determines the requested command (generally by consuming the first
  #pod command-line argument), finds the plugin to handle that command, parses the
  #pod remaining arguments according to that plugin's rules, and runs the plugin.
  #pod
  #pod It passes the contents of the global argument array (C<@ARGV>) to
  #pod L</C<prepare_command>>, but C<@ARGV> is not altered by running an App::Cmd.
  #pod
  #pod =cut
  
  sub run {
    my ($self) = @_;
  
    # We should probably use Class::Default.
    $self = $self->new unless ref $self;
  
    # prepare the command we're going to run...
    my @argv = $self->prepare_args();
    my ($cmd, $opt, @args) = $self->prepare_command(@argv);
  
    # ...and then run it
    $self->execute_command($cmd, $opt, @args);
  }
  
  #pod =method prepare_args
  #pod
  #pod Normally App::Cmd uses C<@ARGV> for its commandline arguments. You can override
  #pod this method to change that behavior for testing or otherwise.
  #pod
  #pod =cut
  
  sub prepare_args {
    my ($self) = @_;
    return scalar(@ARGV)
      ? (@ARGV)
      : (@{$self->default_args});
  }
  
  #pod =method default_args
  #pod
  #pod If C<L</prepare_args>> is not changed and there are no arguments in C<@ARGV>,
  #pod this method is called and should return an arrayref to be used as the arguments
  #pod to the program.  By default, it returns an empty arrayref.
  #pod
  #pod =cut
  
  use constant default_args => [];
  
  #pod =method abstract 
  #pod
  #pod    sub abstract { "command description" }
  #pod
  #pod Defines the command abstract: a short description that will be printed in the
  #pod main command options list.
  #pod
  #pod =method description
  #pod
  #pod    sub description { "Long description" }
  #pod
  #pod Defines a longer command description that will be shown when the user asks for
  #pod help on a specific command.
  #pod
  #pod =method arg0
  #pod
  #pod =method full_arg0
  #pod
  #pod   my $program_name = $app->arg0;
  #pod
  #pod   my $full_program_name = $app->full_arg0;
  #pod
  #pod These methods return the name of the program invoked to run this application.
  #pod This is determined by inspecting C<$0> when the App::Cmd object is
  #pod instantiated, so it's probably correct, but doing weird things with App::Cmd
  #pod could lead to weird values from these methods.
  #pod
  #pod If the program was run like this:
  #pod
  #pod   knight!rjbs$ ~/bin/rpg dice 3d6
  #pod
  #pod Then the methods return:
  #pod
  #pod   arg0      - rpg
  #pod   full_arg0 - /Users/rjbs/bin/rpg
  #pod
  #pod These values are captured when the App::Cmd object is created, so it is safe to
  #pod assign to C<$0> later.
  #pod
  #pod =cut
  
  sub arg0      { $_[0]->{arg0} }
  sub full_arg0 { $_[0]->{full_arg0} }
  
  #pod =method prepare_command
  #pod
  #pod   my ($cmd, $opt, @args) = $app->prepare_command(@ARGV);
  #pod
  #pod This method will load the plugin for the requested command, use its options to
  #pod parse the command line arguments, and eventually return everything necessary to
  #pod actually execute the command.
  #pod
  #pod =cut
  
  sub prepare_command {
    my ($self, @args) = @_;
  
    # figure out first-level dispatch
    my ($command, $opt, @sub_args) = $self->get_command(@args);
  
    # set up the global options (which we just determined)
    $self->set_global_options($opt);
  
    # find its plugin or else call default plugin (default default is help)
    if ($command) {
      $self->_prepare_command($command, $opt, @sub_args);
    } else {
      $self->_prepare_default_command($opt, @sub_args);
    }
  }
  
  sub _prepare_command {
    my ($self, $command, $opt, @args) = @_;
    if (my $plugin = $self->plugin_for($command)) {
      return $plugin->prepare($self, @args);
    } else {
      return $self->_bad_command($command, $opt, @args);
    }
  }
  
  sub _prepare_default_command {
    my ($self, $opt, @sub_args) = @_;
    $self->_prepare_command($self->default_command, $opt, @sub_args);
  }
  
  sub _bad_command {
    my ($self, $command, $opt, @args) = @_;
    print "Unrecognized command: $command.\n\nUsage:\n" if defined($command);
  
    # This should be class data so that, in Bizarro World, two App::Cmds will not
    # conflict.
    our $_bad++;
    $self->prepare_command(qw(commands --stderr));
  }
  
  END { exit 1 if our $_bad };
  
  #pod =method default_command
  #pod
  #pod This method returns the name of the command to run if none is given on the
  #pod command line.  The default default is "help"
  #pod
  #pod =cut
  
  sub default_command { "help" }
  
  #pod =method execute_command
  #pod
  #pod   $app->execute_command($cmd, \%opt, @args);
  #pod
  #pod This method will invoke C<validate_args> and then C<run> on C<$cmd>.
  #pod
  #pod =cut
  
  sub execute_command {
    my ($self, $cmd, $opt, @args) = @_;
  
    local our $active_cmd = $cmd;
  
    $cmd->validate_args($opt, \@args);
    $cmd->execute($opt, \@args);
  }
  
  #pod =method plugin_search_path
  #pod
  #pod This method returns the plugin_search_path as set.  The default implementation,
  #pod if called on "YourApp::Cmd" will return "YourApp::Cmd::Command"
  #pod
  #pod This is a method because it's fun to override it with, for example:
  #pod
  #pod   use constant plugin_search_path => __PACKAGE__;
  #pod
  #pod =cut
  
  sub _default_command_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Command";
  }
  
  sub _default_plugin_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Plugin";
  }
  
  sub plugin_search_path {
    my ($self) = @_;
  
    my $dcb = $self->_default_command_base;
    my $ccb = $dcb eq 'App::Cmd::Command'
            ? $self->App::Cmd::_default_command_base
            : $self->_default_command_base;
  
    my @default = ($ccb, $self->_default_plugin_base);
  
    if (ref $self) {
      return $self->{plugin_search_path} ||= \@default;
    } else {
      return \@default;
    }
  }
  
  #pod =method allow_any_unambiguous_abbrev
  #pod
  #pod If this method returns true (which, by default, it does I<not>), then any
  #pod unambiguous abbreviation for a registered command name will be allowed as a
  #pod means to use that command.  For example, given the following commands:
  #pod
  #pod   reticulate
  #pod   reload
  #pod   rasterize
  #pod
  #pod Then the user could use C<ret> for C<reticulate> or C<ra> for C<rasterize> and
  #pod so on.
  #pod
  #pod =cut
  
  sub allow_any_unambiguous_abbrev { return 0 }
  
  #pod =method global_options
  #pod
  #pod   if ($cmd->app->global_options->{verbose}) { ... }
  #pod
  #pod This method returns the running application's global options as a hashref.  If
  #pod there are no options specified, an empty hashref is returned.
  #pod
  #pod =cut
  
  sub global_options {
  	my $self = shift;
  	return $self->{global_options} ||= {} if ref $self;
    return {};
  }
  
  #pod =method set_global_options
  #pod
  #pod   $app->set_global_options(\%opt);
  #pod
  #pod This method sets the global options.
  #pod
  #pod =cut
  
  sub set_global_options {
    my ($self, $opt) = @_;
    return $self->{global_options} = $opt;
  }
  
  #pod =method command_names
  #pod
  #pod   my @names = $cmd->command_names;
  #pod
  #pod This returns the commands names which the App::Cmd object will handle.
  #pod
  #pod =cut
  
  sub command_names {
    my ($self) = @_;
    keys %{ $self->_command };
  }
  
  #pod =method command_groups
  #pod
  #pod   my @groups = $cmd->commands_groups;
  #pod
  #pod This method can be implemented to return a grouped list of command names with
  #pod optional headers. Each group is given as arrayref and each header as string.
  #pod If an empty list is returned, the commands plugin will show two groups without
  #pod headers: the first group is for the "help" and "commands" commands, and all
  #pod other commands are in the second group.
  #pod
  #pod =cut
  
  sub command_groups { }
  
  #pod =method command_plugins
  #pod
  #pod   my @plugins = $cmd->command_plugins;
  #pod
  #pod This method returns the package names of the plugins that implement the
  #pod App::Cmd object's commands.
  #pod
  #pod =cut
  
  sub command_plugins {
    my ($self) = @_;
    my %seen = map {; $_ => 1 } values %{ $self->_command };
    keys %seen;
  }
  
  #pod =method plugin_for
  #pod
  #pod   my $plugin = $cmd->plugin_for($command);
  #pod
  #pod This method returns the plugin (module) for the given command.  If no plugin
  #pod implements the command, it returns false.
  #pod
  #pod =cut
  
  sub plugin_for {
    my ($self, $command) = @_;
    return unless $command;
    return unless exists $self->_command->{ $command };
  
    return $self->_command->{ $command };
  }
  
  #pod =method get_command
  #pod
  #pod   my ($command_name, $opt, @args) = $app->get_command(@args);
  #pod
  #pod Process arguments and into a command name and (optional) global options.
  #pod
  #pod =cut
  
  sub get_command {
    my ($self, @args) = @_;
  
    my ($opt, $args, %fields)
      = $self->_process_args(\@args, $self->_global_option_processing_params);
  
    # map --help to help command
    if ($opt->{help}) {
        unshift @$args, 'help';
        delete $opt->{help};
    }
  
    my ($command, $rest) = $self->_cmd_from_args($args);
  
    $self->{usage} = $fields{usage};
  
    return ($command, $opt, @$rest);
  }
  
  sub _cmd_from_args {
    my ($self, $args) = @_;
  
    my $command = shift @$args;
    return ($command, $args);
  }
  
  sub _global_option_processing_params {
    my ($self, @args) = @_;
  
    return (
      $self->usage_desc(@args),
      $self->global_opt_spec(@args),
      { getopt_conf => [qw/pass_through/] },
    );
  }
  
  #pod =method usage
  #pod
  #pod   print $self->app->usage->text;
  #pod
  #pod Returns the usage object for the global options.
  #pod
  #pod =cut
  
  sub usage { $_[0]{usage} };
  
  #pod =method usage_desc
  #pod
  #pod The top level usage line. Looks something like
  #pod
  #pod   "yourapp <command> [options]"
  #pod
  #pod =cut
  
  sub usage_desc {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return "%c <command> %o";
  }
  
  #pod =method global_opt_spec
  #pod
  #pod Returns a list with help command unless C<no_help_plugin> has been specified or
  #pod an empty list. Can be overridden for pre-dispatch option processing.  This is
  #pod useful for flags like --verbose.
  #pod
  #pod =cut
  
  sub global_opt_spec {
    my ($self) = @_;
  
    my $cmd = $self->{command};
    my %seen;
    my @help = grep { ! $seen{$_}++ }
               reverse sort map { s/^--?//; $_ }
               grep { $cmd->{$_} eq 'App::Cmd::Command::help' } keys %$cmd;
  
    return (@help ? [ join('|', @help) => "show help" ] : ());
  }
  
  #pod =method usage_error
  #pod
  #pod   $self->usage_error("Something's wrong!");
  #pod
  #pod Used to die with nice usage output, during C<validate_args>.
  #pod
  #pod =cut
  
  sub usage_error {
    my ($self, $error) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    my $text = $self->usage->text;
    $text =~ s/\A(\s+)/!/;
    return $text;
  }
  
  #pod =head1 TODO
  #pod
  #pod =for :list
  #pod * publish and bring in Log::Speak (simple quiet/verbose output)
  #pod * publish and use our internal enhanced describe_options
  #pod * publish and use our improved simple input routines
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd - write command line apps with less suffering
  
  =head1 VERSION
  
  version 0.331
  
  =head1 SYNOPSIS
  
  in F<yourcmd>:
  
    use YourApp;
    YourApp->run;
  
  in F<YourApp.pm>:
  
    package YourApp;
    use App::Cmd::Setup -app;
    1;
  
  in F<YourApp/Command/blort.pm>:
  
    package YourApp::Command::blort;
    use YourApp -command;
    use strict; use warnings;
  
    sub abstract { "blortex algorithm" }
  
    sub description { "Long description on blortex algorithm" }
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ yourcmd blort --recheck
  
    All blorts successful.
  
  =head1 DESCRIPTION
  
  App::Cmd is intended to make it easy to write complex command-line applications
  without having to think about most of the annoying things usually involved.
  
  For information on how to start using App::Cmd, see L<App::Cmd::Tutorial>.
  
  =head1 METHODS
  
  =head2 new
  
    my $cmd = App::Cmd->new(\%arg);
  
  This method returns a new App::Cmd object.  During initialization, command
  plugins will be loaded.
  
  Valid arguments are:
  
    no_commands_plugin - if true, the command list plugin is not added
  
    no_help_plugin     - if true, the help plugin is not added
  
    no_version_plugin  - if true, the version plugin is not added
  
    show_version_cmd -   if true, the version command will be shown in the
                         command list
  
    plugin_search_path - The path to search for commands in. Defaults to
                         results of plugin_search_path method
  
  If C<no_commands_plugin> is not given, L<App::Cmd::Command::commands> will be
  required, and it will be registered to handle all of its command names not
  handled by other plugins.
  
  If C<no_help_plugin> is not given, L<App::Cmd::Command::help> will be required,
  and it will be registered to handle all of its command names not handled by
  other plugins. B<Note:> "help" is the default command, so if you do not load
  the default help plugin, you should provide your own or override the
  C<default_command> method.
  
  If C<no_version_plugin> is not given, L<App::Cmd::Command::version> will be
  required to show the application's version with command C<--version>. By
  default, the version command is not included in the command list. Pass
  C<show_version_cmd> to include the version command in the list.
  
  =head2 run
  
    $cmd->run;
  
  This method runs the application.  If called the class, it will instantiate a
  new App::Cmd object to run.
  
  It determines the requested command (generally by consuming the first
  command-line argument), finds the plugin to handle that command, parses the
  remaining arguments according to that plugin's rules, and runs the plugin.
  
  It passes the contents of the global argument array (C<@ARGV>) to
  L</C<prepare_command>>, but C<@ARGV> is not altered by running an App::Cmd.
  
  =head2 prepare_args
  
  Normally App::Cmd uses C<@ARGV> for its commandline arguments. You can override
  this method to change that behavior for testing or otherwise.
  
  =head2 default_args
  
  If C<L</prepare_args>> is not changed and there are no arguments in C<@ARGV>,
  this method is called and should return an arrayref to be used as the arguments
  to the program.  By default, it returns an empty arrayref.
  
  =head2 abstract 
  
     sub abstract { "command description" }
  
  Defines the command abstract: a short description that will be printed in the
  main command options list.
  
  =head2 description
  
     sub description { "Long description" }
  
  Defines a longer command description that will be shown when the user asks for
  help on a specific command.
  
  =head2 arg0
  
  =head2 full_arg0
  
    my $program_name = $app->arg0;
  
    my $full_program_name = $app->full_arg0;
  
  These methods return the name of the program invoked to run this application.
  This is determined by inspecting C<$0> when the App::Cmd object is
  instantiated, so it's probably correct, but doing weird things with App::Cmd
  could lead to weird values from these methods.
  
  If the program was run like this:
  
    knight!rjbs$ ~/bin/rpg dice 3d6
  
  Then the methods return:
  
    arg0      - rpg
    full_arg0 - /Users/rjbs/bin/rpg
  
  These values are captured when the App::Cmd object is created, so it is safe to
  assign to C<$0> later.
  
  =head2 prepare_command
  
    my ($cmd, $opt, @args) = $app->prepare_command(@ARGV);
  
  This method will load the plugin for the requested command, use its options to
  parse the command line arguments, and eventually return everything necessary to
  actually execute the command.
  
  =head2 default_command
  
  This method returns the name of the command to run if none is given on the
  command line.  The default default is "help"
  
  =head2 execute_command
  
    $app->execute_command($cmd, \%opt, @args);
  
  This method will invoke C<validate_args> and then C<run> on C<$cmd>.
  
  =head2 plugin_search_path
  
  This method returns the plugin_search_path as set.  The default implementation,
  if called on "YourApp::Cmd" will return "YourApp::Cmd::Command"
  
  This is a method because it's fun to override it with, for example:
  
    use constant plugin_search_path => __PACKAGE__;
  
  =head2 allow_any_unambiguous_abbrev
  
  If this method returns true (which, by default, it does I<not>), then any
  unambiguous abbreviation for a registered command name will be allowed as a
  means to use that command.  For example, given the following commands:
  
    reticulate
    reload
    rasterize
  
  Then the user could use C<ret> for C<reticulate> or C<ra> for C<rasterize> and
  so on.
  
  =head2 global_options
  
    if ($cmd->app->global_options->{verbose}) { ... }
  
  This method returns the running application's global options as a hashref.  If
  there are no options specified, an empty hashref is returned.
  
  =head2 set_global_options
  
    $app->set_global_options(\%opt);
  
  This method sets the global options.
  
  =head2 command_names
  
    my @names = $cmd->command_names;
  
  This returns the commands names which the App::Cmd object will handle.
  
  =head2 command_groups
  
    my @groups = $cmd->commands_groups;
  
  This method can be implemented to return a grouped list of command names with
  optional headers. Each group is given as arrayref and each header as string.
  If an empty list is returned, the commands plugin will show two groups without
  headers: the first group is for the "help" and "commands" commands, and all
  other commands are in the second group.
  
  =head2 command_plugins
  
    my @plugins = $cmd->command_plugins;
  
  This method returns the package names of the plugins that implement the
  App::Cmd object's commands.
  
  =head2 plugin_for
  
    my $plugin = $cmd->plugin_for($command);
  
  This method returns the plugin (module) for the given command.  If no plugin
  implements the command, it returns false.
  
  =head2 get_command
  
    my ($command_name, $opt, @args) = $app->get_command(@args);
  
  Process arguments and into a command name and (optional) global options.
  
  =head2 usage
  
    print $self->app->usage->text;
  
  Returns the usage object for the global options.
  
  =head2 usage_desc
  
  The top level usage line. Looks something like
  
    "yourapp <command> [options]"
  
  =head2 global_opt_spec
  
  Returns a list with help command unless C<no_help_plugin> has been specified or
  an empty list. Can be overridden for pre-dispatch option processing.  This is
  useful for flags like --verbose.
  
  =head2 usage_error
  
    $self->usage_error("Something's wrong!");
  
  Used to die with nice usage output, during C<validate_args>.
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  publish and bring in Log::Speak (simple quiet/verbose output)
  
  =item *
  
  publish and use our internal enhanced describe_options
  
  =item *
  
  publish and use our improved simple input routines
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Adam Prime ambs Andreas Hernitscheck A. Sinan Unur Chris 'BinGOs' Williams David Golden Steinbrunner Davor Cubranic Denis Ibaev Diab Jerius Glenn Fowler Ingy dot Net Jakob Voss Jérôme Quelin John SJ Anderson Karen Etheridge Kent Fredric Matthew Astley mokko Olivier Mengué Ricardo SIGNES Ryan C. Thompson Salvatore Bonaccorso Sergey Romanov Stephen Caldwell Yuval Kogman
  
  =over 4
  
  =item *
  
  Adam Prime <aprime@oanda.com>
  
  =item *
  
  ambs <ambs@cpan.org>
  
  =item *
  
  Andreas Hernitscheck <andreash@lxhe.(none)>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Chris 'BinGOs' Williams <chris@bingosnet.co.uk>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Davor Cubranic <cubranic@stat.ubc.ca>
  
  =item *
  
  Denis Ibaev <dionys@gmail.com>
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Ingy dot Net <ingy@ingy.net>
  
  =item *
  
  Jakob Voss <jakob@nichtich.de>
  
  =item *
  
  Jakob Voss <voss@gbv.de>
  
  =item *
  
  Jérôme Quelin <jquelin@gmail.com>
  
  =item *
  
  John SJ Anderson <genehack@genehack.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Matthew Astley <mca@sanger.ac.uk>
  
  =item *
  
  mokko <mauricemengel@gmail.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =item *
  
  Ryan C. Thompson <rct@thompsonclan.org>
  
  =item *
  
  Salvatore Bonaccorso <carnil@debian.org>
  
  =item *
  
  Sergey Romanov <sromanov-dev@yandex.ru>
  
  =item *
  
  Stephen Caldwell <steve@campusexplorer.com>
  
  =item *
  
  Yuval Kogman <nuffin@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD

$fatpacked{"App/Cmd/ArgProcessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_ARGPROCESSOR';
  use strict;
  use warnings;
  
  package App::Cmd::ArgProcessor;
  $App::Cmd::ArgProcessor::VERSION = '0.331';
  # ABSTRACT: App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  sub _process_args {
    my ($class, $args, @params) = @_;
    local @ARGV = @$args;
  
    require Getopt::Long::Descriptive;
    Getopt::Long::Descriptive->VERSION(0.084);
  
    my ($opt, $usage) = Getopt::Long::Descriptive::describe_options(@params);
  
    return (
      $opt,
      [ @ARGV ], # whatever remained
      usage => $usage,
    );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::ArgProcessor - App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  =head1 VERSION
  
  version 0.331
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_ARGPROCESSOR

$fatpacked{"App/Cmd/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND';
  use strict;
  use warnings;
  
  package App::Cmd::Command;
  $App::Cmd::Command::VERSION = '0.331';
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  
  # ABSTRACT: a base class for App::Cmd commands
  
  use Carp ();
  
  #pod =method prepare
  #pod
  #pod   my ($cmd, $opt, $args) = $class->prepare($app, @args);
  #pod
  #pod This method is the primary way in which App::Cmd::Command objects are built.
  #pod Given the remaining command line arguments meant for the command, it returns
  #pod the Command object, parsed options (as a hashref), and remaining arguments (as
  #pod an arrayref).
  #pod
  #pod In the usage above, C<$app> is the App::Cmd object that is invoking the
  #pod command.
  #pod
  #pod =cut
  
  sub prepare {
    my ($class, $app, @args) = @_;
  
    my ($opt, $args, %fields)
      = $class->_process_args(\@args, $class->_option_processing_params($app));
  
    return (
      $class->new({ app => $app, %fields }),
      $opt,
      @$args,
    );
  }
  
  sub _option_processing_params {
    my ($class, @args) = @_;
  
    return (
      $class->usage_desc(@args),
      $class->opt_spec(@args),
    );
  }
  
  #pod =method new
  #pod
  #pod This returns a new instance of the command plugin.  Probably only C<prepare>
  #pod should use this.
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
    bless $arg => $class;
  }
  
  #pod =method execute
  #pod
  #pod   $command_plugin->execute(\%opt, \@args);
  #pod
  #pod This method does whatever it is the command should do!  It is passed a hash
  #pod reference of the parsed command-line options and an array reference of left
  #pod over arguments.
  #pod
  #pod If no C<execute> method is defined, it will try to call C<run> -- but it will
  #pod warn about this behavior during testing, to remind you to fix the method name!
  #pod
  #pod =cut
  
  sub execute {
    my $class = shift;
  
    if (my $run = $class->can('run')) {
      warn "App::Cmd::Command subclasses should implement ->execute not ->run"
        if $ENV{HARNESS_ACTIVE};
  
      return $class->$run(@_);
    }
  
    Carp::croak ref($class) . " does not implement mandatory method 'execute'\n";
  }
  
  #pod =method app
  #pod
  #pod This method returns the App::Cmd object into which this command is plugged.
  #pod
  #pod =cut
  
  sub app { $_[0]->{app}; }
  
  #pod =method usage
  #pod
  #pod This method returns the usage object for this command.  (See
  #pod L<Getopt::Long::Descriptive>).
  #pod
  #pod =cut
  
  sub usage { $_[0]->{usage}; }
  
  #pod =method command_names
  #pod
  #pod This method returns a list of command names handled by this plugin. The
  #pod first item returned is the 'canonical' name of the command.
  #pod
  #pod If this method is not overridden by an App::Cmd::Command subclass, it will
  #pod return the last part of the plugin's package name, converted to lowercase.
  #pod For example, YourApp::Cmd::Command::Init will, by default, handle the command
  #pod "init".
  #pod
  #pod Subclasses should generally get the superclass value of C<command_names>
  #pod and then append aliases.
  #pod
  #pod =cut
  
  sub command_names {
    # from UNIVERSAL::moniker
    (ref( $_[0] ) || $_[0]) =~ /([^:]+)$/;
    return lc $1;
  }
  
  #pod =method usage_desc
  #pod
  #pod This method should be overridden to provide a usage string.  (This is the first
  #pod argument passed to C<describe_options> from Getopt::Long::Descriptive.)
  #pod
  #pod If not overridden, it returns "%c COMMAND %o";  COMMAND is the first item in
  #pod the result of the C<command_names> method.
  #pod
  #pod =cut
  
  sub usage_desc {
    my ($self) = @_;
  
    my ($command) = $self->command_names;
    return "%c $command %o"
  }
  
  #pod =method opt_spec
  #pod
  #pod This method should be overridden to provide option specifications.  (This is
  #pod list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  #pod after the first.)
  #pod
  #pod If not overridden, it returns an empty list.
  #pod
  #pod =cut
  
  sub opt_spec {
    return;
  }
  
  #pod =method validate_args
  #pod
  #pod   $command_plugin->validate_args(\%opt, \@args);
  #pod
  #pod This method is passed a hashref of command line options (as processed by
  #pod Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  #pod an exception (preferably by calling C<usage_error>, below) if they are invalid,
  #pod or it may do nothing to allow processing to continue.
  #pod
  #pod =cut
  
  sub validate_args { }
  
  #pod =method usage_error
  #pod
  #pod   $self->usage_error("This command must not be run by root!");
  #pod
  #pod This method should be called to die with human-friendly usage output, during
  #pod C<validate_args>.
  #pod
  #pod =cut
  
  sub usage_error {
    my ( $self, $error ) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    local $@;
    join "\n", eval { $self->app->_usage_text }, eval { $self->usage->text };
  }
  
  #pod =method abstract
  #pod
  #pod This method returns a short description of the command's purpose.  If this
  #pod method is not overridden, it will return the abstract from the module's Pod.
  #pod If it can't find the abstract, it will look for a comment starting with
  #pod "ABSTRACT:" like the ones used by L<Pod::Weaver::Section::Name>.
  #pod
  #pod =cut
  
  # stolen from ExtUtils::MakeMaker
  sub abstract {
    my ($class) = @_;
    $class = ref $class if ref $class;
  
    my $result;
    my $weaver_abstract;
  
    # classname to filename
    (my $pm_file = $class) =~ s!::!/!g;
    $pm_file .= '.pm';
    $pm_file = $INC{$pm_file} or return "(unknown)";
  
    # if the pm file exists, open it and parse it
    open my $fh, "<", $pm_file or return "(unknown)";
  
    local $/ = "\n";
    my $inpod;
  
    while (local $_ = <$fh>) {
      # =cut toggles, it doesn't end :-/
      $inpod = /^=cut/ ? !$inpod : $inpod || /^=(?!cut)/;
  
      if (/#+\s*ABSTRACT: (.*)/){
        # takes ABSTRACT: ... if no POD defined yet
        $weaver_abstract = $1;
      }
  
      next unless $inpod;
      chomp;
  
      next unless /^(?:$class\s-\s)(.*)/;
  
      $result = $1;
      last;
    }
  
    return $result || $weaver_abstract || "(unknown)";
  }
  
  #pod =method description
  #pod
  #pod This method can be overridden to provide full option description. It
  #pod is used by the built-in L<help|App::Cmd::Command::help> command.
  #pod
  #pod If not overridden, it uses L<Pod::Usage> to extract the description
  #pod from the module's Pod DESCRIPTION section or the empty string.
  #pod
  #pod =cut
  
  sub description {
      my ($class) = @_;
      $class = ref $class if ref $class;
  
      # classname to filename
      (my $pm_file = $class) =~ s!::!/!g;
      $pm_file .= '.pm';
      $pm_file = $INC{$pm_file} or return '';
  
      open my $input, "<", $pm_file or return '';
  
      my $descr = "";
      open my $output, ">", \$descr;
  
      require Pod::Usage;
      Pod::Usage::pod2usage( -input => $input,
                 -output => $output,
                 -exit => "NOEXIT", 
                 -verbose => 99,
                 -sections => "DESCRIPTION",
                 indent => 0
      );
      $descr =~ s/Description:\n//m;
      chomp $descr;
  
      return $descr;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command - a base class for App::Cmd commands
  
  =head1 VERSION
  
  version 0.331
  
  =head1 METHODS
  
  =head2 prepare
  
    my ($cmd, $opt, $args) = $class->prepare($app, @args);
  
  This method is the primary way in which App::Cmd::Command objects are built.
  Given the remaining command line arguments meant for the command, it returns
  the Command object, parsed options (as a hashref), and remaining arguments (as
  an arrayref).
  
  In the usage above, C<$app> is the App::Cmd object that is invoking the
  command.
  
  =head2 new
  
  This returns a new instance of the command plugin.  Probably only C<prepare>
  should use this.
  
  =head2 execute
  
    $command_plugin->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  If no C<execute> method is defined, it will try to call C<run> -- but it will
  warn about this behavior during testing, to remind you to fix the method name!
  
  =head2 app
  
  This method returns the App::Cmd object into which this command is plugged.
  
  =head2 usage
  
  This method returns the usage object for this command.  (See
  L<Getopt::Long::Descriptive>).
  
  =head2 command_names
  
  This method returns a list of command names handled by this plugin. The
  first item returned is the 'canonical' name of the command.
  
  If this method is not overridden by an App::Cmd::Command subclass, it will
  return the last part of the plugin's package name, converted to lowercase.
  For example, YourApp::Cmd::Command::Init will, by default, handle the command
  "init".
  
  Subclasses should generally get the superclass value of C<command_names>
  and then append aliases.
  
  =head2 usage_desc
  
  This method should be overridden to provide a usage string.  (This is the first
  argument passed to C<describe_options> from Getopt::Long::Descriptive.)
  
  If not overridden, it returns "%c COMMAND %o";  COMMAND is the first item in
  the result of the C<command_names> method.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $command_plugin->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>, below) if they are invalid,
  or it may do nothing to allow processing to continue.
  
  =head2 usage_error
  
    $self->usage_error("This command must not be run by root!");
  
  This method should be called to die with human-friendly usage output, during
  C<validate_args>.
  
  =head2 abstract
  
  This method returns a short description of the command's purpose.  If this
  method is not overridden, it will return the abstract from the module's Pod.
  If it can't find the abstract, it will look for a comment starting with
  "ABSTRACT:" like the ones used by L<Pod::Weaver::Section::Name>.
  
  =head2 description
  
  This method can be overridden to provide full option description. It
  is used by the built-in L<help|App::Cmd::Command::help> command.
  
  If not overridden, it uses L<Pod::Usage> to extract the description
  from the module's Pod DESCRIPTION section or the empty string.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND

$fatpacked{"App/Cmd/Command/commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_COMMANDS';
  use strict;
  use warnings;
  
  package App::Cmd::Command::commands;
  $App::Cmd::Command::commands::VERSION = '0.331';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' };
  
  # ABSTRACT: list the application's commands
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will list all of the application commands available and their
  #pod abstracts.
  #pod
  #pod =method execute
  #pod
  #pod This is the command's primary method and raison d'etre.  It prints the
  #pod application's usage text (if any) followed by a sorted listing of the
  #pod application's commands and their abstracts.
  #pod
  #pod The commands are printed in sorted groups (created by C<sort_commands>); each
  #pod group is set off by blank lines.
  #pod
  #pod =cut
  
  sub execute {
    my ($self, $opt, $args) = @_;
  
    my $target = $opt->stderr ? *STDERR : *STDOUT;
   
    my @cmd_groups = $self->app->command_groups;
    my @primary_commands = map { @$_ if ref $_ } @cmd_groups;
  
    if (!@cmd_groups) {
      @primary_commands =
        grep { $_ ne 'version' or $self->app->{show_version} }
        map { ($_->command_names)[0] }
        $self->app->command_plugins;
  
      @cmd_groups = $self->sort_commands(@primary_commands);
    }
  
    my $fmt_width = 0;
    for (@primary_commands) { $fmt_width = length if length > $fmt_width }
    $fmt_width += 2; # pretty
  
    foreach my $cmd_set (@cmd_groups) {
      if (!ref $cmd_set) {
        print { $target } "$cmd_set:\n";
        next;
      }
      for my $command (@$cmd_set) {
        my $abstract = $self->app->plugin_for($command)->abstract;
        printf { $target } "%${fmt_width}s: %s\n", $command, $abstract;
      }
      print { $target } "\n";
    }
  }
  
  #pod =method C<sort_commands>
  #pod
  #pod   my @sorted = $cmd->sort_commands(@unsorted);
  #pod
  #pod This method orders the list of commands into groups which it returns as a list of
  #pod arrayrefs, and optional group header strings.
  #pod
  #pod By default, the first group is for the "help" and "commands" commands, and all
  #pod other commands are in the second group.
  #pod
  #pod This method can be overridden by implementing the C<commands_groups> method in
  #pod your application base clase.
  #pod
  #pod =cut
  
  sub sort_commands {
    my ($self, @commands) = @_;
  
    my $float = qr/^(?:help|commands)$/;
  
    my @head = sort grep { $_ =~ $float } @commands;
    my @tail = sort grep { $_ !~ $float } @commands;
  
    return (\@head, \@tail);
  }
  
  sub opt_spec {
    return (
      [ 'stderr' => 'hidden' ],
    );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::commands - list the application's commands
  
  =head1 VERSION
  
  version 0.331
  
  =head1 DESCRIPTION
  
  This command will list all of the application commands available and their
  abstracts.
  
  =head1 METHODS
  
  =head2 execute
  
  This is the command's primary method and raison d'etre.  It prints the
  application's usage text (if any) followed by a sorted listing of the
  application's commands and their abstracts.
  
  The commands are printed in sorted groups (created by C<sort_commands>); each
  group is set off by blank lines.
  
  =head2 C<sort_commands>
  
    my @sorted = $cmd->sort_commands(@unsorted);
  
  This method orders the list of commands into groups which it returns as a list of
  arrayrefs, and optional group header strings.
  
  By default, the first group is for the "help" and "commands" commands, and all
  other commands are in the second group.
  
  This method can be overridden by implementing the C<commands_groups> method in
  your application base clase.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_COMMANDS

$fatpacked{"App/Cmd/Command/help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_HELP';
  use strict;
  use warnings;
  
  package App::Cmd::Command::help;
  $App::Cmd::Command::help::VERSION = '0.331';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display a command's help screen
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will either list all of the application commands and their
  #pod abstracts, or display the usage screen for a subcommand with its
  #pod description.
  #pod
  #pod =head1 USAGE
  #pod
  #pod The help text is generated from three sources:
  #pod
  #pod =for :list
  #pod * The C<usage_desc> method
  #pod * The C<description> method
  #pod * The C<opt_spec> data structure
  #pod
  #pod The C<usage_desc> method provides the opening usage line, following the
  #pod specification described in L<Getopt::Long::Descriptive>.  In some cases,
  #pod the default C<usage_desc> in L<App::Cmd::Command> may be sufficient and
  #pod you will only need to override it to provide additional command line
  #pod usage information.
  #pod
  #pod The C<opt_spec> data structure is used with L<Getopt::Long::Descriptive>
  #pod to generate the description of the options.
  #pod
  #pod Subcommand classes should override the C<discription> method to provide
  #pod additional information that is prepended before the option descriptions.
  #pod
  #pod For example, consider the following subcommand module:
  #pod
  #pod   package YourApp::Command::initialize;
  #pod
  #pod   # This is the default from App::Cmd::Command
  #pod   sub usage_desc {
  #pod     my ($self) = @_;
  #pod     my $desc = $self->SUPER::usage_desc; # "%c COMMAND %o"
  #pod     return "$desc [DIRECTORY]";
  #pod   }
  #pod
  #pod   sub description {
  #pod     return "The initialize command prepares the application...";
  #pod   }
  #pod
  #pod   sub opt_spec {
  #pod     return (
  #pod       [ "skip-refs|R",  "skip reference checks during init", ],
  #pod       [ "values|v=s@",  "starting values", { default => [ 0, 1, 3 ] } ],
  #pod     );
  #pod   }
  #pod
  #pod   ...
  #pod
  #pod That module would generate help output like this:
  #pod
  #pod   $ yourapp help initialize
  #pod   yourapp initialize [-Rv] [long options...] [DIRECTORY]
  #pod
  #pod   The initialize command prepares the application...
  #pod
  #pod         --help            This usage screen
  #pod         -R --skip-refs    skip reference checks during init
  #pod         -v --values       starting values
  #pod
  #pod =cut
  
  sub usage_desc { '%c help [subcommand]' }
  
  sub command_names { qw/help --help -h -?/ }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    if (!@$args) {
      print $self->app->usage->text . "\n";
  
      print "Available commands:\n\n";
  
      $self->app->execute_command( $self->app->_prepare_command("commands") );
    } else {
      my ($cmd, $opt, $args) = $self->app->prepare_command(@$args);
  
      local $@;
      my $desc = $cmd->description;
      $desc = "\n$desc" if length $desc;
  
      my $ut = join "\n",
        eval { $cmd->usage->leader_text },
        $desc,
        eval { $cmd->usage->option_text };
  
      print "$ut\n";
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::help - display a command's help screen
  
  =head1 VERSION
  
  version 0.331
  
  =head1 DESCRIPTION
  
  This command will either list all of the application commands and their
  abstracts, or display the usage screen for a subcommand with its
  description.
  
  =head1 USAGE
  
  The help text is generated from three sources:
  
  =over 4
  
  =item *
  
  The C<usage_desc> method
  
  =item *
  
  The C<description> method
  
  =item *
  
  The C<opt_spec> data structure
  
  =back
  
  The C<usage_desc> method provides the opening usage line, following the
  specification described in L<Getopt::Long::Descriptive>.  In some cases,
  the default C<usage_desc> in L<App::Cmd::Command> may be sufficient and
  you will only need to override it to provide additional command line
  usage information.
  
  The C<opt_spec> data structure is used with L<Getopt::Long::Descriptive>
  to generate the description of the options.
  
  Subcommand classes should override the C<discription> method to provide
  additional information that is prepended before the option descriptions.
  
  For example, consider the following subcommand module:
  
    package YourApp::Command::initialize;
  
    # This is the default from App::Cmd::Command
    sub usage_desc {
      my ($self) = @_;
      my $desc = $self->SUPER::usage_desc; # "%c COMMAND %o"
      return "$desc [DIRECTORY]";
    }
  
    sub description {
      return "The initialize command prepares the application...";
    }
  
    sub opt_spec {
      return (
        [ "skip-refs|R",  "skip reference checks during init", ],
        [ "values|v=s@",  "starting values", { default => [ 0, 1, 3 ] } ],
      );
    }
  
    ...
  
  That module would generate help output like this:
  
    $ yourapp help initialize
    yourapp initialize [-Rv] [long options...] [DIRECTORY]
  
    The initialize command prepares the application...
  
          --help            This usage screen
          -R --skip-refs    skip reference checks during init
          -v --values       starting values
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_HELP

$fatpacked{"App/Cmd/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_VERSION';
  use strict;
  use warnings;
  
  package App::Cmd::Command::version;
  $App::Cmd::Command::version::VERSION = '0.331';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display an app's version
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This command will display the program name, its base class
  #pod with version number, and the full program name.
  #pod
  #pod =cut
  
  sub command_names { qw/version --version/ }
  
  sub version_for_display {
    $_[0]->version_package->VERSION
  }
  
  sub version_package {
    ref($_[0]->app)
  }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    printf "%s (%s) version %s (%s)\n",
      $self->app->arg0, $self->version_package,
      $self->version_for_display, $self->app->full_arg0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::version - display an app's version
  
  =head1 VERSION
  
  version 0.331
  
  =head1 DESCRIPTION
  
  This command will display the program name, its base class
  with version number, and the full program name.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_VERSION

$fatpacked{"App/Cmd/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_PLUGIN';
  use strict;
  use warnings;
  package App::Cmd::Plugin;
  $App::Cmd::Plugin::VERSION = '0.331';
  # ABSTRACT: a plugin for App::Cmd commands
  
  sub _faux_curried_method {
    my ($class, $name, $arg) = @_;
  
    return sub {
      my $cmd = $App::Cmd::active_cmd;
      $class->$name($cmd, @_);
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Plugin - a plugin for App::Cmd commands
  
  =head1 VERSION
  
  version 0.331
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_PLUGIN

$fatpacked{"App/Cmd/Setup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SETUP';
  use strict;
  use warnings;
  package App::Cmd::Setup;
  $App::Cmd::Setup::VERSION = '0.331';
  # ABSTRACT: helper for setting up App::Cmd classes
  
  #pod =head1 OVERVIEW
  #pod
  #pod App::Cmd::Setup is a helper library, used to set up base classes that will be
  #pod used as part of an App::Cmd program.  For the most part you should refer to
  #pod L<the tutorial|App::Cmd::Tutorial> for how you should use this library.
  #pod
  #pod This class is useful in three scenarios:
  #pod
  #pod =begin :list
  #pod
  #pod = when writing your App::Cmd subclass
  #pod
  #pod Instead of writing:
  #pod
  #pod   package MyApp;
  #pod   use base 'App::Cmd';
  #pod
  #pod ...you can write:
  #pod
  #pod   package MyApp;
  #pod   use App::Cmd::Setup -app;
  #pod
  #pod The benefits of doing this are mostly minor, and relate to sanity-checking your
  #pod class.  The significant benefit is that this form allows you to specify
  #pod plugins, as in:
  #pod
  #pod   package MyApp;
  #pod   use App::Cmd::Setup -app => { plugins => [ 'Prompt' ] };
  #pod
  #pod Plugins are described in L<App::Cmd::Tutorial> and L<App::Cmd::Plugin>.
  #pod
  #pod = when writing abstract base classes for commands
  #pod
  #pod That is: when you write a subclass of L<App::Cmd::Command> that is intended for
  #pod other commands to use as their base class, you should use App::Cmd::Setup.  For
  #pod example, if you want all the commands in MyApp to inherit from MyApp::Command,
  #pod you may want to write that package like this:
  #pod
  #pod   package MyApp::Command;
  #pod   use App::Cmd::Setup -command;
  #pod
  #pod Do not confuse this with the way you will write specific commands:
  #pod
  #pod   package MyApp::Command::mycmd;
  #pod   use MyApp -command;
  #pod
  #pod Again, this form mostly performs some validation and setup behind the scenes
  #pod for you.  You can use C<L<base>> if you prefer.
  #pod
  #pod = when writing App::Cmd plugins
  #pod
  #pod L<App::Cmd::Plugin> is a mechanism that allows an App::Cmd class to inject code
  #pod into all its command classes, providing them with utility routines.
  #pod
  #pod To write a plugin, you must use App::Cmd::Setup.  As seen above, you must also
  #pod use App::Cmd::Setup to set up your App::Cmd subclass if you wish to consume
  #pod plugins.
  #pod
  #pod For more information on writing plugins, see L<App::Cmd::Manual> and
  #pod L<App::Cmd::Plugin>.
  #pod
  #pod =end :list
  #pod
  #pod =cut
  
  use App::Cmd ();
  use App::Cmd::Command ();
  use App::Cmd::Plugin ();
  use Carp ();
  use Data::OptList ();
  use String::RewritePrefix ();
  
  # 0.06 is needed for load_optional_class
  use Class::Load 0.06 qw();
  
  use Sub::Exporter -setup => {
    -as     => '_import',
    exports => [ qw(foo) ],
    collectors => [
      -app     => \'_make_app_class',
      -command => \'_make_command_class',
      -plugin  => \'_make_plugin_class',
    ],
  };
  
  sub import {
    goto &_import;
  }
  
  sub _app_base_class { 'App::Cmd' }
  
  sub _make_app_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    $val ||= {};
    Carp::confess "invalid argument to -app setup"
      if grep { $_ ne 'plugins' } keys %$val;
  
    Carp::confess "app setup requested on App::Cmd subclass $into"
      if $into->isa('App::Cmd');
  
    $self->_make_x_isa_y($into, $self->_app_base_class);
  
    if ( ! Class::Load::load_optional_class( $into->_default_command_base ) ) {
      my $base = $self->_command_base_class;
      Sub::Install::install_sub({
        code => sub { $base },
        into => $into,
        as   => '_default_command_base',
      });
    }
  
    # TODO Check this is right. -- kentnl, 2010-12
    #
    #  my $want_plugin_base = $self->_plugin_base_class;
    my $want_plugin_base = 'App::Cmd::Plugin';
  
    my @plugins;
    for my $plugin (@{ $val->{plugins} || [] }) {
      $plugin = String::RewritePrefix->rewrite(
        {
          ''  => 'App::Cmd::Plugin::',
          '=' => ''
        },
        $plugin,
      );
      Class::Load::load_class( $plugin );
      unless( $plugin->isa( $want_plugin_base ) ){
          die "$plugin is not a " . $want_plugin_base;
      }
      push @plugins, $plugin;
    }
  
    Sub::Install::install_sub({
      code => sub { @plugins },
      into => $into,
      as   => '_plugin_plugins',
    });
  
    return 1;
  }
  
  sub _command_base_class { 'App::Cmd::Command' }
  
  sub _make_command_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "command setup requested on App::Cmd::Command subclass $into"
      if $into->isa('App::Cmd::Command');
  
    $self->_make_x_isa_y($into, $self->_command_base_class);
  
    return 1;
  }
  
  sub _make_x_isa_y {
    my ($self, $x, $y) = @_;
  
    no strict 'refs';
    push @{"$x\::ISA"}, $y;
  }
  
  sub _plugin_base_class { 'App::Cmd::Plugin' }
  sub _make_plugin_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "plugin setup requested on App::Cmd::Plugin subclass $into"
      if $into->isa('App::Cmd::Plugin');
  
    Carp::confess "plugin setup requires plugin configuration" unless $val;
  
    $self->_make_x_isa_y($into, $self->_plugin_base_class);
  
    # In this special case, exporting everything by default is the sensible thing
    # to do. -- rjbs, 2008-03-31
    $val->{groups} = [ default => [ -all ] ] unless $val->{groups};
  
    my @exports;
    for my $pair (@{ Data::OptList::mkopt($val->{exports}) }) {
      push @exports, $pair->[0], ($pair->[1] || \'_faux_curried_method');
    }
  
    $val->{exports} = \@exports;
  
    Sub::Exporter::setup_exporter({
      %$val,
      into => $into,
      as   => 'import_from_plugin',
    });
  
    return 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Setup - helper for setting up App::Cmd classes
  
  =head1 VERSION
  
  version 0.331
  
  =head1 OVERVIEW
  
  App::Cmd::Setup is a helper library, used to set up base classes that will be
  used as part of an App::Cmd program.  For the most part you should refer to
  L<the tutorial|App::Cmd::Tutorial> for how you should use this library.
  
  This class is useful in three scenarios:
  
  =over 4
  
  =item when writing your App::Cmd subclass
  
  Instead of writing:
  
    package MyApp;
    use base 'App::Cmd';
  
  ...you can write:
  
    package MyApp;
    use App::Cmd::Setup -app;
  
  The benefits of doing this are mostly minor, and relate to sanity-checking your
  class.  The significant benefit is that this form allows you to specify
  plugins, as in:
  
    package MyApp;
    use App::Cmd::Setup -app => { plugins => [ 'Prompt' ] };
  
  Plugins are described in L<App::Cmd::Tutorial> and L<App::Cmd::Plugin>.
  
  =item when writing abstract base classes for commands
  
  That is: when you write a subclass of L<App::Cmd::Command> that is intended for
  other commands to use as their base class, you should use App::Cmd::Setup.  For
  example, if you want all the commands in MyApp to inherit from MyApp::Command,
  you may want to write that package like this:
  
    package MyApp::Command;
    use App::Cmd::Setup -command;
  
  Do not confuse this with the way you will write specific commands:
  
    package MyApp::Command::mycmd;
    use MyApp -command;
  
  Again, this form mostly performs some validation and setup behind the scenes
  for you.  You can use C<L<base>> if you prefer.
  
  =item when writing App::Cmd plugins
  
  L<App::Cmd::Plugin> is a mechanism that allows an App::Cmd class to inject code
  into all its command classes, providing them with utility routines.
  
  To write a plugin, you must use App::Cmd::Setup.  As seen above, you must also
  use App::Cmd::Setup to set up your App::Cmd subclass if you wish to consume
  plugins.
  
  For more information on writing plugins, see L<App::Cmd::Manual> and
  L<App::Cmd::Plugin>.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SETUP

$fatpacked{"App/Cmd/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SIMPLE';
  use strict;
  use warnings;
  
  package App::Cmd::Simple;
  $App::Cmd::Simple::VERSION = '0.331';
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' }
  
  # ABSTRACT: a helper for building one-command App::Cmd applications
  
  use App::Cmd;
  use Sub::Install;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod in F<simplecmd>:
  #pod
  #pod   use YourApp::Cmd;
  #pod   Your::Cmd->run;
  #pod
  #pod in F<YourApp/Cmd.pm>:
  #pod
  #pod   package YourApp::Cmd;
  #pod   use base qw(App::Cmd::Simple);
  #pod
  #pod   sub opt_spec {
  #pod     return (
  #pod       [ "blortex|X",  "use the blortex algorithm" ],
  #pod       [ "recheck|r",  "recheck all results"       ],
  #pod     );
  #pod   }
  #pod
  #pod   sub validate_args {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     # no args allowed but options!
  #pod     $self->usage_error("No args allowed") if @$args;
  #pod   }
  #pod
  #pod   sub execute {
  #pod     my ($self, $opt, $args) = @_;
  #pod
  #pod     my $result = $opt->{blortex} ? blortex() : blort();
  #pod
  #pod     recheck($result) if $opt->{recheck};
  #pod
  #pod     print $result;
  #pod   }
  #pod
  #pod and, finally, at the command line:
  #pod
  #pod   knight!rjbs$ simplecmd --recheck
  #pod
  #pod   All blorts successful.
  #pod
  #pod =head1 SUBCLASSING
  #pod
  #pod When writing a subclass of App::Cmd:Simple, there are only a few methods that
  #pod you might want to implement.  They behave just like the same-named methods in
  #pod App::Cmd.
  #pod
  #pod =head2 opt_spec
  #pod
  #pod This method should be overridden to provide option specifications.  (This is
  #pod list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  #pod after the first.)
  #pod
  #pod If not overridden, it returns an empty list.
  #pod
  #pod =head2 usage_desc
  #pod
  #pod This method should be overridden to provide the top level usage line.
  #pod It's a one-line summary of how the command is to be invoked, and
  #pod should be given in the format used for the C<$usage_desc> parameter to
  #pod C<describe_options> in Getopt::Long::Descriptive.
  #pod
  #pod If not overriden, it returns something that prints out like:
  #pod
  #pod   yourapp [-?h] [long options...]
  #pod
  #pod =head2 validate_args
  #pod
  #pod   $cmd->validate_args(\%opt, \@args);
  #pod
  #pod This method is passed a hashref of command line options (as processed by
  #pod Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  #pod an exception (preferably by calling C<usage_error>) if they are invalid, or it
  #pod may do nothing to allow processing to continue.
  #pod
  #pod =head2 execute
  #pod
  #pod   Your::App::Cmd::Simple->execute(\%opt, \@args);
  #pod
  #pod This method does whatever it is the command should do!  It is passed a hash
  #pod reference of the parsed command-line options and an array reference of left
  #pod over arguments.
  #pod
  #pod =cut
  
  # The idea here is that the user will someday replace "Simple" in his ISA with
  # "Command" and then write a standard App::Cmd package.  To make that possible,
  # we produce a behind-the-scenes App::Cmd object when the user says 'use
  # MyApp::Simple' and redirect MyApp::Simple->run to that.
  my $i;
  BEGIN { $i = 0 }
  
  sub import {
    my ($class) = @_;
    return if $class eq __PACKAGE__;
  
    # This signals that something has already set the target up.
    return $class if $class->_cmd_pkg;
  
    my $core_execute = App::Cmd::Command->can('execute');
    my $our_execute  = $class->can('execute');
    Carp::confess(
      "App::Cmd::Simple subclasses must implement ->execute, not ->run"
    ) unless $our_execute and $our_execute != $core_execute;
  
    # I doubt the $i will ever be needed, but let's start paranoid.
    my $generated_name = join('::', $class, '_App_Cmd', $i++);
  
    {
      no strict 'refs';
      *{$generated_name . '::ISA'} = [ 'App::Cmd' ];
    }
  
    Sub::Install::install_sub({
      into => $class,
      as   => '_cmd_pkg',
      code => sub { $generated_name },
    });
  
    Sub::Install::install_sub({
        into => $class,
        as => 'command_names',
        code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_plugins',
      code => sub { $class },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => 'default_command',
      code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_cmd_from_args',
      code => sub {
        my ($self, $args) = @_;
        if (defined(my $command = $args->[0])) {
          my $plugin = $self->plugin_for($command);
          # If help was requested, show the help for the command, not the
          # main help. Because the main help would talk about subcommands,
          # and a "Simple" app has no subcommands.
          if ($plugin and $plugin eq $self->plugin_for("help")) {
            return ($command, [ $self->default_command ]);
          }
          # Any other value for "command" isn't really a command at all --
          # it's the first argument. So call the default command instead.
        }
        return ($self->default_command, $args);
      },
    });
  
    Sub::Install::install_sub({
      into => $class,
      as   => 'run',
      code => sub {
        $generated_name->new({
          no_help_plugin     => 0,
          no_commands_plugin => 1,
        })->run(@_);
      }
    });
  
    return $class;
  }
  
  sub usage_desc {
    return "%c %o"
  }
  
  sub _cmd_pkg { }
  
  #pod =head1 WARNINGS
  #pod
  #pod B<This should be considered experimental!>  Although it is probably not going
  #pod to change much, don't build your business model around it yet, okay?
  #pod
  #pod App::Cmd::Simple is not rich in black magic, but it does do some somewhat
  #pod gnarly things to make an App::Cmd::Simple look as much like an
  #pod App::Cmd::Command as possible.  This means that you can't deviate too much from
  #pod the sort of thing shown in the synopsis as you might like.  If you're doing
  #pod something other than writing a fairly simple command, and you want to screw
  #pod around with the App::Cmd-iness of your program, Simple might not be the best
  #pod choice.
  #pod
  #pod B<One specific warning...>  if you are writing a program with the
  #pod App::Cmd::Simple class embedded in it, you B<must> call import on the class.
  #pod That's how things work.  You can just do this:
  #pod
  #pod   YourApp::Cmd->import->run;
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Simple - a helper for building one-command App::Cmd applications
  
  =head1 VERSION
  
  version 0.331
  
  =head1 SYNOPSIS
  
  in F<simplecmd>:
  
    use YourApp::Cmd;
    Your::Cmd->run;
  
  in F<YourApp/Cmd.pm>:
  
    package YourApp::Cmd;
    use base qw(App::Cmd::Simple);
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ simplecmd --recheck
  
    All blorts successful.
  
  =head1 SUBCLASSING
  
  When writing a subclass of App::Cmd:Simple, there are only a few methods that
  you might want to implement.  They behave just like the same-named methods in
  App::Cmd.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 usage_desc
  
  This method should be overridden to provide the top level usage line.
  It's a one-line summary of how the command is to be invoked, and
  should be given in the format used for the C<$usage_desc> parameter to
  C<describe_options> in Getopt::Long::Descriptive.
  
  If not overriden, it returns something that prints out like:
  
    yourapp [-?h] [long options...]
  
  =head2 validate_args
  
    $cmd->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>) if they are invalid, or it
  may do nothing to allow processing to continue.
  
  =head2 execute
  
    Your::App::Cmd::Simple->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  =head1 WARNINGS
  
  B<This should be considered experimental!>  Although it is probably not going
  to change much, don't build your business model around it yet, okay?
  
  App::Cmd::Simple is not rich in black magic, but it does do some somewhat
  gnarly things to make an App::Cmd::Simple look as much like an
  App::Cmd::Command as possible.  This means that you can't deviate too much from
  the sort of thing shown in the synopsis as you might like.  If you're doing
  something other than writing a fairly simple command, and you want to screw
  around with the App::Cmd-iness of your program, Simple might not be the best
  choice.
  
  B<One specific warning...>  if you are writing a program with the
  App::Cmd::Simple class embedded in it, you B<must> call import on the class.
  That's how things work.  You can just do this:
  
    YourApp::Cmd->import->run;
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SIMPLE

$fatpacked{"App/Cmd/Subdispatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SUBDISPATCH';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch;
  $App::Cmd::Subdispatch::VERSION = '0.331';
  use App::Cmd;
  use App::Cmd::Command;
  BEGIN { our @ISA = qw(App::Cmd::Command App::Cmd) } 
  
  # ABSTRACT: an App::Cmd::Command that is also an App::Cmd
  
  #pod =method new
  #pod
  #pod A hackish new that allows us to have an Command instance before they normally
  #pod exist.
  #pod
  #pod =cut
  
  sub new {
  	my ($inv, $fields, @args) = @_;
  	if (ref $inv) {
  		@{ $inv }{ keys %$fields } = values %$fields;
  		return $inv;
  	} else {
  		$inv->SUPER::new($fields, @args);
  	}
  }
  
  #pod =method prepare
  #pod
  #pod   my $subcmd = $subdispatch->prepare($app, @args);
  #pod
  #pod An overridden version of L<App::Cmd::Command/prepare> that performs a new
  #pod dispatch cycle.
  #pod
  #pod =cut
  
  sub prepare {
  	my ($class, $app, @args) = @_;
  
  	my $self = $class->new({ app => $app });
  
  	my ($subcommand, $opt, @sub_args) = $self->get_command(@args);
  
    $self->set_global_options($opt);
  
  	if (defined $subcommand) {
      return $self->_prepare_command($subcommand, $opt, @sub_args);
    } else {
      if (@args) {
        return $self->_bad_command(undef, $opt, @sub_args);
      } else {
        return $self->_prepare_default_command($opt, @sub_args);
      }
    }
  }
  
  sub _plugin_prepare {
    my ($self, $plugin, @args) = @_;
    return $plugin->prepare($self->choose_parent_app($self->app, $plugin), @args);
  }
  
  #pod =method app
  #pod
  #pod   $subdispatch->app;
  #pod
  #pod This method returns the application that this subdispatch is a command of.
  #pod
  #pod =cut
  
  sub app { $_[0]{app} }
  
  #pod =method choose_parent_app
  #pod
  #pod   $subcmd->prepare(
  #pod     $subdispatch->choose_parent_app($app, $opt, $plugin),
  #pod     @$args
  #pod   );
  #pod
  #pod A method that chooses whether the parent app or the subdispatch is going to be
  #pod C<< $cmd->app >>.
  #pod
  #pod =cut
  
  sub choose_parent_app {
  	my ( $self, $app, $plugin ) = @_;
  
  	if (
      $plugin->isa("App::Cmd::Command::commands")
      or $plugin->isa("App::Cmd::Command::help")
      or scalar keys %{ $self->global_options }
    ) {
  		return $self;
  	} else {
  		return $app;
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Subdispatch - an App::Cmd::Command that is also an App::Cmd
  
  =head1 VERSION
  
  version 0.331
  
  =head1 METHODS
  
  =head2 new
  
  A hackish new that allows us to have an Command instance before they normally
  exist.
  
  =head2 prepare
  
    my $subcmd = $subdispatch->prepare($app, @args);
  
  An overridden version of L<App::Cmd::Command/prepare> that performs a new
  dispatch cycle.
  
  =head2 app
  
    $subdispatch->app;
  
  This method returns the application that this subdispatch is a command of.
  
  =head2 choose_parent_app
  
    $subcmd->prepare(
      $subdispatch->choose_parent_app($app, $opt, $plugin),
      @$args
    );
  
  A method that chooses whether the parent app or the subdispatch is going to be
  C<< $cmd->app >>.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SUBDISPATCH

$fatpacked{"App/Cmd/Subdispatch/DashedStyle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SUBDISPATCH_DASHEDSTYLE';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch::DashedStyle;
  $App::Cmd::Subdispatch::DashedStyle::VERSION = '0.331';
  use App::Cmd::Subdispatch;
  BEGIN { our @ISA = 'App::Cmd::Subdispatch' };
  
  # ABSTRACT: "app cmd --subcmd" style subdispatching
  
  #pod =method get_command
  #pod
  #pod   my ($subcommand, $opt, $args) = $subdispatch->get_command(@args)
  #pod
  #pod A version of get_command that chooses commands as options in the following
  #pod style:
  #pod
  #pod   mytool mycommand --mysubcommand
  #pod
  #pod =cut
  
  sub get_command {
  	my ($self, @args) = @_;
  
  	my (undef, $opt, @sub_args)
      = $self->App::Cmd::Command::prepare($self->app, @args);
  
  	if (my $cmd = delete $opt->{subcommand}) {
  		delete $opt->{$cmd}; # useless boolean
  		return ($cmd, $opt, @sub_args);
  	} else {
      return (undef, $opt, @sub_args);
    }
  }
  
  #pod =method opt_spec
  #pod
  #pod A version of C<opt_spec> that calculates the getopt specification from the
  #pod subcommands.
  #pod
  #pod =cut
  
  sub opt_spec {
  	my ($self, $app) = @_;
  
  	my $subcommands = $self->_command;
  	my %plugins = map {
  		$_ => [ $_->command_names ],
  	} values %$subcommands;
  
  	foreach my $opt_spec (values %plugins) {
  		$opt_spec = join("|", grep { /^\w/ } @$opt_spec);
  	}
  
  	my @subcommands = map { [ $plugins{$_} =>  $_->abstract ] } keys %plugins;
  
  	return (
  		[ subcommand => hidden => { one_of => \@subcommands } ],
  		$self->global_opt_spec($app),
  		{ getopt_conf => [ 'pass_through' ] },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Subdispatch::DashedStyle - "app cmd --subcmd" style subdispatching
  
  =head1 VERSION
  
  version 0.331
  
  =head1 METHODS
  
  =head2 get_command
  
    my ($subcommand, $opt, $args) = $subdispatch->get_command(@args)
  
  A version of get_command that chooses commands as options in the following
  style:
  
    mytool mycommand --mysubcommand
  
  =head2 opt_spec
  
  A version of C<opt_spec> that calculates the getopt specification from the
  subcommands.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SUBDISPATCH_DASHEDSTYLE

$fatpacked{"App/Cmd/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_TESTER';
  use strict;
  use warnings;
  package App::Cmd::Tester;
  $App::Cmd::Tester::VERSION = '0.331';
  # ABSTRACT: for capturing the result of running an app
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Test::More tests => 4;
  #pod   use App::Cmd::Tester;
  #pod
  #pod   use YourApp;
  #pod
  #pod   my $result = test_app(YourApp => [ qw(command --opt value) ]);
  #pod
  #pod   like($result->stdout, qr/expected output/, 'printed what we expected');
  #pod
  #pod   is($result->stderr, '', 'nothing sent to sderr');
  #pod
  #pod   is($result->error, undef, 'threw no exceptions');
  #pod
  #pod   my $result = test_app(YourApp => [ qw(command --opt value --quiet) ]);
  #pod
  #pod   is($result->output, '', 'absolutely no output with --quiet');
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod One of the reasons that user-executed programs are so often poorly tested is
  #pod that they are hard to test.  App::Cmd::Tester is one of the tools App-Cmd
  #pod provides to help make it easy to test App::Cmd-based programs.
  #pod
  #pod It provides one routine: test_app.
  #pod
  #pod =method test_app
  #pod
  #pod B<Note>: while C<test_app> is a method, it is by default exported as a
  #pod subroutine into the namespace that uses App::Cmd::Tester.  In other words: you
  #pod probably don't need to think about this as a method unless you want to subclass
  #pod App::Cmd::Tester.
  #pod
  #pod   my $result = test_app($app_class => \@argv_contents);
  #pod
  #pod This will locally set C<@ARGV> to simulate command line arguments, and will
  #pod then call the C<run> method on the given application class (or application).
  #pod Output to the standard output and standard error filehandles  will be captured.
  #pod
  #pod C<$result> is an App::Cmd::Tester::Result object, which has methods to access
  #pod the following data:
  #pod
  #pod   stdout - the output sent to stdout
  #pod   stderr - the output sent to stderr
  #pod   output - the combined output of stdout and stderr
  #pod   error  - the exception thrown by running the application, or undef
  #pod   run_rv - the return value of the run method (generally irrelevant)
  #pod   exit_code - the numeric exit code that would've been issued (0 is 'okay')
  #pod
  #pod The output is captured using L<IO::TieCombine>, which I<can> ensure that the
  #pod ordering is preserved in the combined output, but I<can't> capture the output
  #pod of external programs.  You can reverse these tradeoffs by using
  #pod L<App::Cmd::Tester::CaptureExternal> instead.
  #pod
  #pod =cut
  
  use Sub::Exporter::Util qw(curry_method);
  use Sub::Exporter -setup => {
    exports => { test_app => curry_method },
    groups  => { default  => [ qw(test_app) ] },
  };
  
  our $TEST_IN_PROGRESS;
  BEGIN {
    *CORE::GLOBAL::exit = sub {
      my ($rc) = @_;
      return CORE::exit($rc) unless $TEST_IN_PROGRESS;
      App::Cmd::Tester::Exited->throw($rc);
    };
  }
  
  #pod =for Pod::Coverage result_class
  #pod
  #pod =cut
  
  sub result_class { 'App::Cmd::Tester::Result' }
  
  sub test_app {
    my ($class, $app, $argv) = @_;
  
    local $App::Cmd::_bad = 0;
  
    $app = $app->new unless ref($app) or $app->isa('App::Cmd::Simple');
  
    my $result = $class->_run_with_capture($app, $argv);
  
    my $error = $result->{error};
  
    my $exit_code = defined $error ? ((0+$!)||-1) : 0;
  
    if ($error and eval { $error->isa('App::Cmd::Tester::Exited') }) {
      $exit_code = $$error;
    }
  
    $exit_code =1 if $App::Cmd::_bad && ! $exit_code;
  
    $class->result_class->new({
      app    => $app,
      exit_code => $exit_code,
      %$result,
    });
  }
  
  sub _run_with_capture {
    my ($class, $app, $argv) = @_;
  
    require IO::TieCombine;
    my $hub = IO::TieCombine->new;
  
    my $stdout = tie local *STDOUT, $hub, 'stdout';
    my $stderr = tie local *STDERR, $hub, 'stderr';
  
    my $run_rv;
  
    my $ok = eval {
      local $TEST_IN_PROGRESS = 1;
      local @ARGV = @$argv;
      $run_rv = $app->run;
      1;
    };
  
    my $error = $ok ? undef : $@;
  
    return {
      stdout => $hub->slot_contents('stdout'),
      stderr => $hub->slot_contents('stderr'),
      output => $hub->combined_contents,
      error  => $error,
      run_rv => $run_rv,
    };
  }
  
  {
    package App::Cmd::Tester::Result;
  $App::Cmd::Tester::Result::VERSION = '0.331';
  sub new {
      my ($class, $arg) = @_;
      bless $arg => $class;
    }
  
    for my $attr (qw(app stdout stderr output error run_rv exit_code)) {
      Sub::Install::install_sub({
        code => sub { $_[0]->{$attr} },
        as   => $attr,
      });
    }
  }
  
  {
    package App::Cmd::Tester::Exited;
  $App::Cmd::Tester::Exited::VERSION = '0.331';
  sub throw {
      my ($class, $code) = @_;
      $code = 0 unless defined $code;
      my $self = (bless \$code => $class);
      die $self;
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Tester - for capturing the result of running an app
  
  =head1 VERSION
  
  version 0.331
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    is($result->error, undef, 'threw no exceptions');
  
    my $result = test_app(YourApp => [ qw(command --opt value --quiet) ]);
  
    is($result->output, '', 'absolutely no output with --quiet');
  
  =head1 DESCRIPTION
  
  One of the reasons that user-executed programs are so often poorly tested is
  that they are hard to test.  App::Cmd::Tester is one of the tools App-Cmd
  provides to help make it easy to test App::Cmd-based programs.
  
  It provides one routine: test_app.
  
  =head1 METHODS
  
  =head2 test_app
  
  B<Note>: while C<test_app> is a method, it is by default exported as a
  subroutine into the namespace that uses App::Cmd::Tester.  In other words: you
  probably don't need to think about this as a method unless you want to subclass
  App::Cmd::Tester.
  
    my $result = test_app($app_class => \@argv_contents);
  
  This will locally set C<@ARGV> to simulate command line arguments, and will
  then call the C<run> method on the given application class (or application).
  Output to the standard output and standard error filehandles  will be captured.
  
  C<$result> is an App::Cmd::Tester::Result object, which has methods to access
  the following data:
  
    stdout - the output sent to stdout
    stderr - the output sent to stderr
    output - the combined output of stdout and stderr
    error  - the exception thrown by running the application, or undef
    run_rv - the return value of the run method (generally irrelevant)
    exit_code - the numeric exit code that would've been issued (0 is 'okay')
  
  The output is captured using L<IO::TieCombine>, which I<can> ensure that the
  ordering is preserved in the combined output, but I<can't> capture the output
  of external programs.  You can reverse these tradeoffs by using
  L<App::Cmd::Tester::CaptureExternal> instead.
  
  =for Pod::Coverage result_class
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_TESTER

$fatpacked{"App/Cmd/Tester/CaptureExternal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_TESTER_CAPTUREEXTERNAL';
  use strict;
  use warnings;
  package App::Cmd::Tester::CaptureExternal;
  $App::Cmd::Tester::CaptureExternal::VERSION = '0.331';
  use parent 'App::Cmd::Tester';
  use Capture::Tiny 0.13 qw/capture/;
  
  # ABSTRACT: Extends App::Cmd::Tester to capture from external subprograms
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Test::More tests => 4;
  #pod   use App::Cmd::Tester::CaptureExternal;
  #pod
  #pod   use YourApp;
  #pod
  #pod   my $result = test_app(YourApp => [ qw(command --opt value) ]);
  #pod
  #pod   like($result->stdout, qr/expected output/, 'printed what we expected');
  #pod
  #pod   is($result->stderr, '', 'nothing sent to sderr');
  #pod
  #pod   ok($result->output, "STDOUT concatenated with STDERR");
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod L<App::Cmd::Tester> provides a useful scaffold for testing applications, but it
  #pod is unable to capture output generated from any external subprograms that are
  #pod invoked from the application.
  #pod
  #pod This subclass uses an alternate mechanism for capturing output
  #pod (L<Capture::Tiny>) that does capture from external programs, with one
  #pod major limitation.
  #pod
  #pod It is not possible to capture externally from both STDOUT and STDERR while
  #pod also having appropriately interleaved combined output.  Therefore, the
  #pod C<output> from this subclass simply concatenates the two.
  #pod
  #pod You can still use C<output> for testing if there is any output at all or for
  #pod testing if something appeared in either output stream, but you can't rely on
  #pod the ordering being correct between lines to STDOUT and lines to STDERR.
  #pod
  #pod =cut
  
  sub _run_with_capture {
    my ($class, $app, $argv) = @_;
  
    my $run_rv;
  
    my ($stdout, $stderr, $ok) = capture {
      eval {
        local $App::Cmd::Tester::TEST_IN_PROGRESS = 1;
        local @ARGV = @$argv;
        $run_rv = $app->run;
        1;
      };
    };
  
    my $error = $ok ? undef : $@;
  
    return {
      stdout => $stdout,
      stderr => $stderr,
      output => $stdout . $stderr,
      error  => $error,
      run_rv => $run_rv,
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Tester::CaptureExternal - Extends App::Cmd::Tester to capture from external subprograms
  
  =head1 VERSION
  
  version 0.331
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester::CaptureExternal;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    ok($result->output, "STDOUT concatenated with STDERR");
  
  =head1 DESCRIPTION
  
  L<App::Cmd::Tester> provides a useful scaffold for testing applications, but it
  is unable to capture output generated from any external subprograms that are
  invoked from the application.
  
  This subclass uses an alternate mechanism for capturing output
  (L<Capture::Tiny>) that does capture from external programs, with one
  major limitation.
  
  It is not possible to capture externally from both STDOUT and STDERR while
  also having appropriately interleaved combined output.  Therefore, the
  C<output> from this subclass simply concatenates the two.
  
  You can still use C<output> for testing if there is any output at all or for
  testing if something appeared in either output stream, but you can't rely on
  the ordering being correct between lines to STDOUT and lines to STDERR.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_TESTER_CAPTUREEXTERNAL

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;
  
  use strict;
  use Exporter 5.57 'import';
  use vars qw($VERSION @EXPORT_OK);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '0.4';
  @EXPORT_OK = qw(list_packages);
  
  =pod
  
  =head1 NAME
  
  Devel::InnerPackage - find all the inner packages of a package
  
  =head1 SYNOPSIS
  
      use Foo::Bar;
      use Devel::InnerPackage qw(list_packages);
  
      my @inner_packages = list_packages('Foo::Bar');
  
  
  =head1 DESCRIPTION
  
  
  Given a file like this
  
  
      package Foo::Bar;
  
      sub foo {}
  
  
      package Foo::Bar::Quux;
  
      sub quux {}
  
      package Foo::Bar::Quirka;
  
      sub quirka {}
  
      1;
  
  then
  
      list_packages('Foo::Bar');
  
  will return
  
      Foo::Bar::Quux
      Foo::Bar::Quirka
  
  =head1 METHODS
  
  =head2 list_packages <package name>
  
  Return a list of all inner packages of that package.
  
  =cut
  
  sub list_packages {
              my $pack = shift; $pack .= "::" unless $pack =~ m!::$!;
  
              no strict 'refs';
              my @packs;
              my @stuff = grep !/^(main|)::$/, keys %{$pack};
              for my $cand (grep /::$/, @stuff)
              {
                  $cand =~ s!::$!!;
                  my @children = list_packages($pack.$cand);
      
                  push @packs, "$pack$cand" unless $cand =~ /^::/ ||
                      !__PACKAGE__->_loaded($pack.$cand); # or @children;
                  push @packs, @children;
              }
              return grep {$_ !~ /::(::ISA::CACHE|SUPER)/} @packs;
  }
  
  ### XXX this is an inlining of the Class-Inspector->loaded()
  ### method, but inlined to remove the dependency.
  sub _loaded {
         my ($class, $name) = @_;
  
          no strict 'refs';
  
         # Handle by far the two most common cases
         # This is very fast and handles 99% of cases.
         return 1 if defined ${"${name}::VERSION"};
         return 1 if @{"${name}::ISA"};
  
         # Are there any symbol table entries other than other namespaces
         foreach ( keys %{"${name}::"} ) {
                 next if substr($_, -2, 2) eq '::';
                 return 1 if defined &{"${name}::$_"};
         }
  
         # No functions, and it doesn't have a version, and isn't anything.
         # As an absolute last resort, check for an entry in %INC
         my $filename = join( '/', split /(?:'|::)/, $name ) . '.pm';
         return 1 if defined $INC{$filename};
  
         '';
  }
  
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2005 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =cut 
  
  
  
  
  
  1;
DEVEL_INNERPACKAGE

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;
  
  use strict;
  use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);
  use Module::Pluggable::Object;
  
  use if $] > 5.017, 'deprecate';
  
  # ObQuote:
  # Bob Porter: Looks like you've been missing a lot of work lately.
  # Peter Gibbons: I wouldn't say I've been missing it, Bob!
  
  
  $VERSION = '5.2';
  $FORCE_SEARCH_ALL_PATHS = 0;
  
  sub import {
      my $class        = shift;
      my %opts         = @_;
  
      my ($pkg, $file) = caller;
      # the default name for the method is 'plugins'
      my $sub          = $opts{'sub_name'}  || 'plugins';
      # get our package
      my ($package)    = $opts{'package'} || $pkg;
      $opts{filename}  = $file;
      $opts{package}   = $package;
      $opts{force_search_all_paths} = $FORCE_SEARCH_ALL_PATHS unless exists $opts{force_search_all_paths};
  
  
      my $finder       = Module::Pluggable::Object->new(%opts);
      my $subroutine   = sub { my $self = shift; return $finder->plugins(@_) };
  
      my $searchsub = sub {
                my $self = shift;
                my ($action,@paths) = @_;
  
                $finder->{'search_path'} = ["${package}::Plugin"] if ($action eq 'add'  and not   $finder->{'search_path'} );
                push @{$finder->{'search_path'}}, @paths      if ($action eq 'add');
                $finder->{'search_path'}       = \@paths      if ($action eq 'new');
                return $finder->{'search_path'};
      };
  
  
      my $onlysub = sub {
          my ($self, $only) = @_;
  
          if (defined $only) {
              $finder->{'only'} = $only;
          };
  
          return $finder->{'only'};
      };
  
      my $exceptsub = sub {
          my ($self, $except) = @_;
  
          if (defined $except) {
              $finder->{'except'} = $except;
          };
  
          return $finder->{'except'};
      };
  
  
      no strict 'refs';
      no warnings qw(redefine prototype);
  
      *{"$package\::$sub"}        = $subroutine;
      *{"$package\::search_path"} = $searchsub;
      *{"$package\::only"}        = $onlysub;
      *{"$package\::except"}      = $exceptsub;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable;
  
  
  and then later ...
  
      use MyClass;
      my $mc = MyClass->new();
      # returns the names of all plugins installed under MyClass::Plugin::*
      my @plugins = $mc->plugins();
  
  =head1 EXAMPLE
  
  Why would you want to do this? Say you have something that wants to pass an
  object to a number of different plugins in turn. For example you may
  want to extract meta-data from every email you get sent and do something
  with it. Plugins make sense here because then you can keep adding new
  meta data parsers and all the logic and docs for each one will be
  self contained and new handlers are easy to add without changing the
  core code. For that, you might do something like ...
  
      package Email::Examiner;
  
      use strict;
      use Email::Simple;
      use Module::Pluggable require => 1;
  
      sub handle_email {
          my $self  = shift;
          my $email = shift;
  
          foreach my $plugin ($self->plugins) {
              $plugin->examine($email);
          }
  
          return 1;
      }
  
  
  
  .. and all the plugins will get a chance in turn to look at it.
  
  This can be trivially extended so that plugins could save the email
  somewhere and then no other plugin should try and do that.
  Simply have it so that the C<examine> method returns C<1> if
  it has saved the email somewhere. You might also want to be paranoid
  and check to see if the plugin has an C<examine> method.
  
          foreach my $plugin ($self->plugins) {
              next unless $plugin->can('examine');
              last if     $plugin->examine($email);
          }
  
  
  And so on. The sky's the limit.
  
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that
  looks through a search path for .pm files and turn those into class names.
  
  Optionally it instantiates those classes for you.
  
  =head1 ADVANCED USAGE
  
  Alternatively, if you don't want to use 'plugins' as the method ...
  
      package MyClass;
      use Module::Pluggable sub_name => 'foo';
  
  
  and then later ...
  
      my @plugins = $mc->foo();
  
  
  Or if you want to look in another namespace
  
      package MyClass;
      use Module::Pluggable search_path => ['Acme::MyClass::Plugin', 'MyClass::Extend'];
  
  or directory
  
      use Module::Pluggable search_dirs => ['mylibs/Foo'];
  
  
  Or if you want to instantiate each plugin rather than just return the name
  
      package MyClass;
      use Module::Pluggable instantiate => 'new';
  
  and then
  
      # whatever is passed to 'plugins' will be passed
      # to 'new' for each plugin
      my @plugins = $mc->plugins(@options);
  
  
  alternatively you can just require the module without instantiating it
  
      package MyClass;
      use Module::Pluggable require => 1;
  
  since requiring automatically searches inner packages, which may not be desirable, you can turn this off
  
  
      package MyClass;
      use Module::Pluggable require => 1, inner => 0;
  
  
  You can limit the plugins loaded using the except option, either as a string,
  array ref or regex
  
      package MyClass;
      use Module::Pluggable except => 'MyClass::Plugin::Foo';
  
  or
  
      package MyClass;
      use Module::Pluggable except => ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];
  
  or
  
      package MyClass;
      use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
  
  
  and similarly for only which will only load plugins which match.
  
  Remember you can use the module more than once
  
      package MyClass;
      use Module::Pluggable search_path => 'MyClass::Filters' sub_name => 'filters';
      use Module::Pluggable search_path => 'MyClass::Plugins' sub_name => 'plugins';
  
  and then later ...
  
      my @filters = $self->filters;
      my @plugins = $self->plugins;
  
  =head1 PLUGIN SEARCHING
  
  Every time you call 'plugins' the whole search path is walked again. This allows
  for dynamically loading plugins even at run time. However this can get expensive
  and so if you don't expect to want to add new plugins at run time you could do
  
  
    package Foo;
    use strict;
    use Module::Pluggable sub_name => '_plugins';
  
    our @PLUGINS;
    sub plugins { @PLUGINS ||= shift->_plugins }
    1;
  
  =head1 INNER PACKAGES
  
  If you have, for example, a file B<lib/Something/Plugin/Foo.pm> that
  contains package definitions for both C<Something::Plugin::Foo> and
  C<Something::Plugin::Bar> then as long as you either have either
  the B<require> or B<instantiate> option set then we'll also find
  C<Something::Plugin::Bar>. Nifty!
  
  =head1 OPTIONS
  
  You can pass a hash of options when importing this module.
  
  The options can be ...
  
  =head2 sub_name
  
  The name of the subroutine to create in your namespace.
  
  By default this is 'plugins'
  
  =head2 search_path
  
  An array ref of namespaces to look in.
  
  =head2 search_dirs
  
  An array ref of directories to look in before @INC.
  
  =head2 instantiate
  
  Call this method on the class. In general this will probably be 'new'
  but it can be whatever you want. Whatever arguments are passed to 'plugins'
  will be passed to the method.
  
  The default is 'undef' i.e just return the class name.
  
  =head2 require
  
  Just require the class, don't instantiate (overrides 'instantiate');
  
  =head2 inner
  
  If set to 0 will B<not> search inner packages.
  If set to 1 will override C<require>.
  
  =head2 only
  
  Takes a string, array ref or regex describing the names of the only plugins to
  return. Whilst this may seem perverse ... well, it is. But it also
  makes sense. Trust me.
  
  =head2 except
  
  Similar to C<only> it takes a description of plugins to exclude
  from returning. This is slightly less perverse.
  
  =head2 package
  
  This is for use by extension modules which build on C<Module::Pluggable>:
  passing a C<package> option allows you to place the plugin method in a
  different package other than your own.
  
  =head2 file_regex
  
  By default C<Module::Pluggable> only looks for I<.pm> files.
  
  By supplying a new C<file_regex> then you can change this behaviour e.g
  
      file_regex => qr/\.plugin$/
  
  =head2 include_editor_junk
  
  By default C<Module::Pluggable> ignores files that look like they were
  left behind by editors. Currently this means files ending in F<~> (~),
  the extensions F<.swp> or F<.swo>, or files beginning with F<.#>.
  
  Setting C<include_editor_junk> changes C<Module::Pluggable> so it does
  not ignore any files it finds.
  
  =head2 follow_symlinks
  
  Whether, when searching directories, to follow symlinks.
  
  Defaults to 1 i.e do follow symlinks.
  
  =head2 min_depth, max_depth
  
  This will allow you to set what 'depth' of plugin will be allowed.
  
  So, for example, C<MyClass::Plugin::Foo> will have a depth of 3 and
  C<MyClass::Plugin::Foo::Bar> will have a depth of 4 so to only get the former
  (i.e C<MyClass::Plugin::Foo>) do
  
          package MyClass;
          use Module::Pluggable max_depth => 3;
  
  and to only get the latter (i.e C<MyClass::Plugin::Foo::Bar>)
  
          package MyClass;
          use Module::Pluggable min_depth => 4;
  
  
  =head1 TRIGGERS
  
  Various triggers can also be passed in to the options.
  
  If any of these triggers return 0 then the plugin will not be returned.
  
  =head2 before_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will not be required either.
  
  =head2 on_require_error <plugin> <err>
  
  Gets called when there's an error on requiring the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_require_error handler is to C<carp> the error and return 0.
  
  =head2 on_instantiate_error <plugin> <err>
  
  Gets called when there's an error on instantiating the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_instantiate_error handler is to C<carp> the error and return 0.
  
  =head2 after_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will be required but not returned as a plugin.
  
  =head1 METHODs
  
  =head2 search_path
  
  The method C<search_path> is exported into you namespace as well.
  You can call that at any time to change or replace the
  search_path.
  
      $self->search_path( add => "New::Path" ); # add
      $self->search_path( new => "New::Path" ); # replace
  
  =head1 BEHAVIOUR UNDER TEST ENVIRONMENT
  
  In order to make testing reliable we exclude anything not from blib if blib.pm is
  in %INC.
  
  However if the module being tested used another module that itself used C<Module::Pluggable>
  then the second module would fail. This was fixed by checking to see if the caller
  had (^|/)blib/ in their filename.
  
  There's an argument that this is the wrong behaviour and that modules should explicitly
  trigger this behaviour but that particular code has been around for 7 years now and I'm
  reluctant to change the default behaviour.
  
  You can now (as of version 4.1) force Module::Pluggable to look outside blib in a test environment by doing either
  
          require Module::Pluggable;
          $Module::Pluggable::FORCE_SEARCH_ALL_PATHS = 1;
          import Module::Pluggable;
  
  or
  
          use Module::Pluggable force_search_all_paths => 1;
  
  =head1 @INC hooks and App::FatPacker
  
  If a module's @INC has a hook and that hook is an object which has a C<files()> method then we will
  try and require those files too. See C<t/26inc_hook.t> for an example.
  
  This has allowed L<App::FatPacker> (as of version 0.10.0) to provide support for Module::Pluggable.
  
  This should also, theoretically, allow someone to modify PAR to do the same thing.
  
  =head1 Module::Require recommended
  
  Up until version 5.2 L<Module::Pluggable> used a string C<eval> to require plugins.
  
  This has now been changed to optionally use L<Module::Runtime> and it's C<require_module> method when
  available and fall back to using a path based C<require> when not.
  
  It's recommended, but not required, that you install Module::Runtime.
  
  =head1 FUTURE PLANS
  
  This does everything I need and I can't really think of any other
  features I want to add. Famous last words of course (not least
  because we're up to version 5.0 at the time of writing).
  
  However suggestions (and patches) are always welcome.
  
  =head1 DEVELOPMENT
  
  The master repo for this module is at
  
  https://github.com/simonwistow/Module-Pluggable
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<File::Find>, L<File::Basename>, L<Class::Factory::Util>, L<Module::Pluggable::Ordered>
  
  =cut
  
  
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;
  
  use strict;
  use File::Find ();
  use File::Basename;
  use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);
  use Carp qw(croak carp confess);
  use Devel::InnerPackage;
  use vars qw($VERSION $MR);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '5.2';
  
  BEGIN {
      eval {  require Module::Runtime };
      unless ($@) {
          Module::Runtime->import('require_module');
      } else {
          *require_module = sub {
              my $module = shift;
              my $path   = $module . ".pm";
              $path =~ s{::}{/}g;
              require $path;
          };
      }
  }
  
  
  sub new {
      my $class = shift;
      my %opts  = @_;
  
      return bless \%opts, $class;
  
  }
  
  ### Eugggh, this code smells 
  ### This is what happens when you keep adding patches
  ### *sigh*
  
  
  sub plugins {
      my $self = shift;
      my @args = @_;
  
      # override 'require'
      $self->{'require'} = 1 if $self->{'inner'};
  
      my $filename   = $self->{'filename'};
      my $pkg        = $self->{'package'};
  
      # Get the exception params instantiated
      $self->_setup_exceptions;
  
      # automatically turn a scalar search path or namespace into a arrayref
      for (qw(search_path search_dirs)) {
          $self->{$_} = [ $self->{$_} ] if exists $self->{$_} && !ref($self->{$_});
      }
  
      # default search path is '<Module>::<Name>::Plugin'
      $self->{'search_path'} ||= ["${pkg}::Plugin"]; 
  
      # default error handler
      $self->{'on_require_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't require $plugin : $err"; return 0 };
      $self->{'on_instantiate_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't instantiate $plugin: $err"; return 0 };
  
      # default whether to follow symlinks
      $self->{'follow_symlinks'} = 1 unless exists $self->{'follow_symlinks'};
  
      # check to see if we're running under test
      my @SEARCHDIR = exists $INC{"blib.pm"} && defined $filename && $filename =~ m!(^|/)blib/! && !$self->{'force_search_all_paths'} ? grep {/blib/} @INC : @INC;
  
      # add any search_dir params
      unshift @SEARCHDIR, @{$self->{'search_dirs'}} if defined $self->{'search_dirs'};
  
      # set our @INC up to include and prefer our search_dirs if necessary
      my @tmp = @INC;
      unshift @tmp, @{$self->{'search_dirs'} || []};
      local @INC = @tmp if defined $self->{'search_dirs'};
  
      my @plugins = $self->search_directories(@SEARCHDIR);
      push(@plugins, $self->handle_inc_hooks($_, @SEARCHDIR)) for @{$self->{'search_path'}};
      push(@plugins, $self->handle_innerpackages($_)) for @{$self->{'search_path'}};
      
      # return blank unless we've found anything
      return () unless @plugins;
  
      # remove duplicates
      # probably not necessary but hey ho
      my %plugins;
      for(@plugins) {
          next unless $self->_is_legit($_);
          $plugins{$_} = 1;
      }
  
      # are we instantiating or requiring?
      if (defined $self->{'instantiate'}) {
          my $method = $self->{'instantiate'};
          my @objs   = ();
          foreach my $package (sort keys %plugins) {
              next unless $package->can($method);
              my $obj = eval { $package->$method(@_) };
              $self->{'on_instantiate_error'}->($package, $@) if $@;
              push @objs, $obj if $obj;           
          }
          return @objs;
      } else { 
          # no? just return the names
          my @objs= sort keys %plugins;
          return @objs;
      }
  }
  
  sub _setup_exceptions {
      my $self = shift;
  
      my %only;   
      my %except; 
      my $only;
      my $except;
  
      if (defined $self->{'only'}) {
          if (ref($self->{'only'}) eq 'ARRAY') {
              %only   = map { $_ => 1 } @{$self->{'only'}};
          } elsif (ref($self->{'only'}) eq 'Regexp') {
              $only = $self->{'only'}
          } elsif (ref($self->{'only'}) eq '') {
              $only{$self->{'only'}} = 1;
          }
      }
          
  
      if (defined $self->{'except'}) {
          if (ref($self->{'except'}) eq 'ARRAY') {
              %except   = map { $_ => 1 } @{$self->{'except'}};
          } elsif (ref($self->{'except'}) eq 'Regexp') {
              $except = $self->{'except'}
          } elsif (ref($self->{'except'}) eq '') {
              $except{$self->{'except'}} = 1;
          }
      }
      $self->{_exceptions}->{only_hash}   = \%only;
      $self->{_exceptions}->{only}        = $only;
      $self->{_exceptions}->{except_hash} = \%except;
      $self->{_exceptions}->{except}      = $except;
          
  }
  
  sub _is_legit {
      my $self   = shift;
      my $plugin = shift;
      my %only   = %{$self->{_exceptions}->{only_hash}||{}};
      my %except = %{$self->{_exceptions}->{except_hash}||{}};
      my $only   = $self->{_exceptions}->{only};
      my $except = $self->{_exceptions}->{except};
      my $depth  = () = split '::', $plugin, -1;
  
      return 0 if     (keys %only   && !$only{$plugin}     );
      return 0 unless (!defined $only || $plugin =~ m!$only!     );
  
      return 0 if     (keys %except &&  $except{$plugin}   );
      return 0 if     (defined $except &&  $plugin =~ m!$except! );
      
      return 0 if     defined $self->{max_depth} && $depth>$self->{max_depth};
      return 0 if     defined $self->{min_depth} && $depth<$self->{min_depth};
  
      return 1;
  }
  
  sub search_directories {
      my $self      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      # go through our @INC
      foreach my $dir (@SEARCHDIR) {
          push @plugins, $self->search_paths($dir);
      }
      return @plugins;
  }
  
  
  sub search_paths {
      my $self = shift;
      my $dir  = shift;
      my @plugins;
  
      my $file_regex = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # and each directory in our search path
      foreach my $searchpath (@{$self->{'search_path'}}) {
          # create the search directory in a cross platform goodness way
          my $sp = catdir($dir, (split /::/, $searchpath));
  
          # if it doesn't exist or it's not a dir then skip it
          next unless ( -e $sp && -d _ ); # Use the cached stat the second time
  
          my @files = $self->find_files($sp);
  
          # foreach one we've found 
          foreach my $file (@files) {
              # untaint the file; accept .pm only
              next unless ($file) = ($file =~ /(.*$file_regex)$/); 
              # parse the file to get the name
              my ($name, $directory, $suffix) = fileparse($file, $file_regex);
  
              next if (!$self->{include_editor_junk} && $self->_is_editor_junk($name));
  
              $directory = abs2rel($directory, $sp);
  
              # If we have a mixed-case package name, assume case has been preserved
              # correctly.  Otherwise, root through the file to locate the case-preserved
              # version of the package name.
              my @pkg_dirs = ();
              if ( $name eq lc($name) || $name eq uc($name) ) {
                  my $pkg_file = catfile($sp, $directory, "$name$suffix");
                  open PKGFILE, "<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";
                  my $in_pod = 0;
                  while ( my $line = <PKGFILE> ) {
                      $in_pod = 1 if $line =~ m/^=\w/;
                      $in_pod = 0 if $line =~ /^=cut/;
                      next if ($in_pod || $line =~ /^=cut/);  # skip pod text
                      next if $line =~ /^\s*#/;               # and comments
                      if ( $line =~ m/^\s*package\s+(.*::)?($name)\s*;/i ) {
                          @pkg_dirs = split /::/, $1 if defined $1;;
                          $name = $2;
                          last;
                      }
                  }
                  close PKGFILE;
              }
  
              # then create the class name in a cross platform way
              $directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);       # remove volume
              my @dirs = ();
              if ($directory) {
                  ($directory) = ($directory =~ /(.*)/);
                  @dirs = grep(length($_), splitdir($directory)) 
                      unless $directory eq curdir();
                  for my $d (reverse @dirs) {
                      my $pkg_dir = pop @pkg_dirs; 
                      last unless defined $pkg_dir;
                      $d =~ s/\Q$pkg_dir\E/$pkg_dir/i;  # Correct case
                  }
              } else {
                  $directory = "";
              }
              my $plugin = join '::', $searchpath, @dirs, $name;
  
              next unless $plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;
  
              $self->handle_finding_plugin($plugin, \@plugins)
          }
  
          # now add stuff that may have been in package
          # NOTE we should probably use all the stuff we've been given already
          # but then we can't unload it :(
          push @plugins, $self->handle_innerpackages($searchpath);
      } # foreach $searchpath
  
      return @plugins;
  }
  
  sub _is_editor_junk {
      my $self = shift;
      my $name = shift;
  
      # Emacs (and other Unix-y editors) leave temp files ending in a
      # tilde as a backup.
      return 1 if $name =~ /~$/;
      # Emacs makes these files while a buffer is edited but not yet
      # saved.
      return 1 if $name =~ /^\.#/;
      # Vim can leave these files behind if it crashes.
      return 1 if $name =~ /\.sw[po]$/;
  
      return 0;
  }
  
  sub handle_finding_plugin {
      my $self    = shift;
      my $plugin  = shift;
      my $plugins = shift;
      my $no_req  = shift || 0;
      
      return unless $self->_is_legit($plugin);
      unless (defined $self->{'instantiate'} || $self->{'require'}) {
          push @$plugins, $plugin;
          return;
      } 
  
      $self->{before_require}->($plugin) || return if defined $self->{before_require};
      unless ($no_req) {
          my $tmp = $@;
          my $res = eval { require_module($plugin) };
          my $err = $@;
          $@      = $tmp;
          if ($err) {
              if (defined $self->{on_require_error}) {
                  $self->{on_require_error}->($plugin, $err) || return; 
              } else {
                  return;
              }
          }
      }
      $self->{after_require}->($plugin) || return if defined $self->{after_require};
      push @$plugins, $plugin;
  }
  
  sub find_files {
      my $self         = shift;
      my $search_path  = shift;
      my $file_regex   = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # find all the .pm files in it
      # this isn't perfect and won't find multiple plugins per file
      #my $cwd = Cwd::getcwd;
      my @files = ();
      { # for the benefit of perl 5.6.1's Find, localize topic
          local $_;
          File::Find::find( { no_chdir => 1, 
                              follow   => $self->{'follow_symlinks'}, 
                              wanted   => sub { 
                               # Inlined from File::Find::Rule C< name => '*.pm' >
                               return unless $File::Find::name =~ /$file_regex/;
                               (my $path = $File::Find::name) =~ s#^\\./##;
                               push @files, $path;
                             }
                        }, $search_path );
      }
      #chdir $cwd;
      return @files;
  
  }
  
  sub handle_inc_hooks {
      my $self      = shift;
      my $path      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      for my $dir ( @SEARCHDIR ) {
          next unless ref $dir && eval { $dir->can( 'files' ) };
  
          foreach my $plugin ( $dir->files ) {
              $plugin =~ s/\.pm$//;
              $plugin =~ s{/}{::}g;
              next unless $plugin =~ m!^${path}::!;
              $self->handle_finding_plugin( $plugin, \@plugins );
          }
      }
      return @plugins;
  }
  
  sub handle_innerpackages {
      my $self = shift;
      return () if (exists $self->{inner} && !$self->{inner});
  
      my $path = shift;
      my @plugins;
  
      foreach my $plugin (Devel::InnerPackage::list_packages($path)) {
          $self->handle_finding_plugin($plugin, \@plugins, 1);
      }
      return @plugins;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable::Object - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable::Object;
      
      my $finder = Module::Pluggable::Object->new(%opts);
      print "My plugins are: ".join(", ", $finder->plugins)."\n";
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  This object is wrapped by C<Module::Pluggable>. If you want to do something
  odd or add non-general special features you're probably best to wrap this
  and produce your own subclass.
  
  =head1 OPTIONS
  
  See the C<Module::Pluggable> docs.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<Module::Pluggable>
  
  =cut 
  
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl

eval 'exec /home/gugod/perl5/perlbrew/perls/v18/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use strict;
use warnings;
package
  dzil;
use Dist::Zilla::App;
# Let dzil --version know what to report:
$main::VERSION = $Dist::Zilla::App::VERSION;

# PODNAME:  dzil
# ABSTRACT: do stuff with your dist
Dist::Zilla::App->run;

#pod =head1 OVERVIEW
#pod
#pod For help with L<Dist::Zilla|Dist::Zilla>, start with L<http://dzil.org/> or
#pod by running C<dzil commands>.
#pod
#pod =cut

__END__

=pod

=encoding UTF-8

=head1 NAME

dzil - do stuff with your dist

=head1 VERSION

version 6.012

=head1 OVERVIEW

For help with L<Dist::Zilla|Dist::Zilla>, start with L<http://dzil.org/> or
by running C<dzil commands>.

=head1 AUTHOR

Ricardo SIGNES 😏 <rjbs@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2018 by Ricardo SIGNES.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
