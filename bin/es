#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Any/URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANY_URI_ESCAPE';
  package Any::URI::Escape;
  
  use strict;
  use warnings;
  
  our $VERSION = 0.01;
  
  =head1 NAME
  
  Any::URI::Escape - Load URI::Escape::XS preferentially over URI::Escape
  
  =cut
  
  use base 'Exporter';
  our @EXPORT = qw( uri_escape uri_unescape );
  
  BEGIN {
  
      eval 'require URI::Escape::XS';
  
      my $pkg;
      if ($@) {
  
          # xs version not installed, use URI::Escape
          require URI::Escape;
          $pkg = 'URI::Escape';
  
      }
      else {
  
          $pkg = 'URI::Escape::XS';
      }
      no strict 'refs';
      my $class = __PACKAGE__;
      *{"$class\::uri_escape"} = *{"$pkg\::uri_escape"};
      *{"$class\::uri_unescape"} = *{"$pkg\::uri_unescape"};
  }
  
  
  1;
  
  =head1 SYNOPSIS
  
    use Any::URI::Escape;
    $escaped_url = uri_escape($url);
  
    # URI::Escape::XS will be used instead of URI::Escape if it is installed.
  
  =head1 DESCRIPTION
  
  URI::Escape is great, but URI::Escape::XS is faster.  This module loads
  URI::Escape::XS and imports the two most common methods if XS is installed.
  
  The insides of this module aren't completely shaken out yet, so patches
  welcome.
  
  =head1 SEE ALSO
  
  L<URI::Escape>
  
  L<URI::Escape::XS>
  
  =head1 AUTHOR
  
  Fred Moyer, E<lt>fred@redhotpenguin.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2010 by Fred Moyer
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.12.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  
  =cut
ANY_URI_ESCAPE

$fatpacked{"App/es.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_ES';
  package App::es;
  our $VERSION = "0.1";
  1;
  __END__
  
  =head1 NAME
  
  App::es - ElasticSearch command line client.
  
  =head1 DESCRIPTION
  
  Please read the usage and document in the L<es> program.
  
  =head1 AUTHORS
  
  Mickey Nasriachi E<lt>mickey75@gmail.comE<gt>
  
  Kang-min Liu E<lt>gugod@gugod.orgE<gt>
  
  
  =head1 ACKNOWLEDGMENT
  
  This module was originally developed for Booking.com. With approval from
  Booking.com, this module was generalized and published on CPAN, for which the
  authors would like to express their gratitude.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2013 by Mickey Nasriachi
  
  Copyright (C) 2013 by Kang-min Liu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
APP_ES

$fatpacked{"ElasticSearch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH';
  package ElasticSearch;
  
  use strict;
  use warnings FATAL => 'all';
  use ElasticSearch::Transport();
  use ElasticSearch::Error();
  use ElasticSearch::RequestParser;
  use ElasticSearch::Util qw(throw parse_params);
  
  our $VERSION = '0.68';
  our $DEBUG   = 0;
  
  #===================================
  sub new {
  #===================================
      my ( $proto, $params ) = parse_params(@_);
      my $self = {
          _base_qs       => {},
          _default       => {},
          _builder_class => 'ElasticSearch::SearchBuilder'
      };
  
      bless $self, ref $proto || $proto;
      $self->{_transport} = ElasticSearch::Transport->new($params);
      $self->$_( $params->{$_} ) for keys %$params;
      return $self;
  }
  
  #===================================
  sub builder_class {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_builder_class} = shift;
          delete $self->{_builder};
      }
      return $self->{_builder_class};
  }
  
  #===================================
  sub builder {
  #===================================
      my $self = shift;
      unless ( $self->{_builder} ) {
          my $class = $self->{_builder_class}
              or $self->throw( 'Param', "No builder_class specified" );
          eval "require $class; 1"
              or $self->throw( 'Internal',
              "Couldn't load class $class: " . ( $@ || 'Unknown error' ) );
          $self->{_builder} = $class->new(@_);
      }
      return $self->{_builder};
  }
  
  #===================================
  sub request {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      return $self->transport->request($params);
  }
  
  #===================================
  sub use_index {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_default}{index} = shift;
      }
      return $self->{_default}{index};
  }
  
  #===================================
  sub use_type {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_default}{type} = shift;
      }
      return $self->{_default}{type};
  }
  
  #===================================
  sub reindex {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      my $source = $params->{source}
          or $self->throw( 'Param', 'Missing source param' );
  
      my $transform  = $params->{transform} || sub { shift() };
      my $verbose    = !$params->{quiet};
      my $dest_index = $params->{dest_index};
      my $bulk_size  = $params->{bulk_size} || 1000;
      my $method     = $params->{_method_name} || 'next';
  
      local $| = $verbose;
      printf( "Reindexing %d docs\n", $source->total )
          if $verbose;
  
      my @docs;
      while (1) {
          my $doc = $source->$method();
          if ( !$doc or @docs == $bulk_size ) {
              my $results = $self->bulk_index(
                  docs => \@docs,
                  map { $_ => $params->{$_} } qw(on_conflict on_error),
              );
              $results = $results->recv
                  if ref $results ne 'HASH'
                      && $results->isa('AnyEvent::CondVar');
              if ( my $err = $results->{errors} ) {
                  my @errors = splice @$err, 0, 5;
                  push @errors, sprintf "...and %d more", scalar @$err
                      if @$err;
                  $self->throw( 'Request', "Errors occurred while reindexing:",
                      \@errors );
              }
              @docs = ();
              print "." if $verbose;
          }
          last unless $doc;
  
          $doc = $transform->($doc) or next;
          $doc->{version_type} = 'external'
              if defined $doc->{_version};
          if ( my $fields = delete $doc->{fields} ) {
              $doc->{parent} = $fields->{_parent}
                  if defined $fields->{_parent};
          }
          $doc->{_index} = $dest_index
              if $dest_index;
          push @docs, $doc;
      }
  
      print "\nDone\n" if $verbose;
  }
  
  #===================================
  sub transport       { shift()->{_transport} }
  sub trace_calls     { shift->transport->trace_calls(@_) }
  sub timeout         { shift->transport->timeout(@_) }
  sub refresh_servers { shift->transport->refresh_servers(@_) }
  #===================================
  
  #===================================
  sub query_parser {
  #===================================
      require ElasticSearch::QueryParser;
      shift;    # drop class/$self
      ElasticSearch::QueryParser->new(@_);
  }
  
  =head1 NAME
  
  ElasticSearch - DEPRECATED: An API for communicating with ElasticSearch
  
  =head1 VERSION
  
  Version 0.68, tested against ElasticSearch server version 0.90.0.
  
  =head1 DEPRECATION
  
  This module is being deprecated in favour of the new official client
  L<Search::Elasticsearch|https://metacpan.org/release/Search::Elasticsearch>
  and will be removed from CPAN in 2015.
  
  =head1 DESCRIPTION
  
  ElasticSearch is an Open Source (Apache 2 license), distributed, RESTful
  Search Engine based on Lucene, and built for the cloud, with a JSON API.
  
  Check out its features: L<http://www.elasticsearch.org/>
  
  This module is a thin API which makes it easy to communicate with an
  ElasticSearch cluster.
  
  It maintains a list of all servers/nodes in the ElasticSearch cluster, and
  spreads the load across these nodes in round-robin fashion.
  If the current active node disappears, then it attempts to connect to another
  node in the list.
  
  Forking a process triggers a server list refresh, and a new connection to
  a randomly chosen node in the list.
  
  =cut
  
  =head1 SYNOPSIS
  
  
      use ElasticSearch;
      my $es = ElasticSearch->new(
          servers      => 'search.foo.com:9200',  # default '127.0.0.1:9200'
          transport    => 'http'                  # default 'http'
                          | 'httplite'
                          | 'httptiny'
                          | 'curl'
                          | 'aehttp'
                          | 'aecurl'
                          | 'thrift',
          max_requests => 10_000,                 # default 10_000
          trace_calls  => 'log_file',
          no_refresh   => 0 | 1,
      );
  
      $es->index(
          index => 'twitter',
          type  => 'tweet',
          id    => 1,
          data  => {
              user        => 'kimchy',
              post_date   => '2009-11-15T14:12:12',
              message     => 'trying out Elastic Search'
          }
      );
  
      $data = $es->get(
          index => 'twitter',
          type  => 'tweet',
          id    => 1
      );
  
      # native elasticsearch query language
      $results = $es->search(
          index => 'twitter',
          type  => 'tweet',
          query => {
              text => { user => 'kimchy' }
          }
      );
  
      # ElasticSearch::SearchBuilder Perlish query language
      $results = $es->search(
          index  => 'twitter',
          type   => 'tweet',
          queryb => {
              message   => 'Perl API',
              user      => 'kimchy',
              post_date => {
                  '>'   => '2010-01-01',
                  '<='  => '2011-01-01',
              }
          }
      );
  
  
      $dodgy_qs = "foo AND AND bar";
      $results = $es->search(
          index => 'twitter',
          type  => 'tweet',
          query => {
              query_string => {
                  query => $es->query_parser->filter($dodgy_qs)
              },
          }
      );
  
  See the C<examples/> directory for a simple working example.
  
  =cut
  
  =head1 GETTING ElasticSearch
  
  You can download the latest released version of ElasticSearch from
  L<http://www.elasticsearch.org/download/>.
  
  See here for setup instructions:
  L<http://www.elasticsearch.org/tutorials/2010/07/01/setting-up-elasticsearch.html>
  
  =cut
  
  =head1 CALLING CONVENTIONS
  
  I've tried to follow the same terminology as used in the ElasticSearch docs
  when naming methods, so it should be easy to tie the two together.
  
  Some methods require a specific C<index> and a specific C<type>, while others
  allow a list of indices or types, or allow you to specify all indices or
  types. I distinguish between them as follows:
  
     $es->method( index => multi, type => single, ...)
  
  C<single> values must be a scalar, and are required parameters
  
        type  => 'tweet'
  
  C<multi> values can be:
  
        index   => 'twitter'          # specific index
        index   => ['twitter','user'] # list of indices
        index   => undef              # (or not specified) = all indices
  
  C<multi_req> values work like C<multi> values, but at least one value is
  required, so:
  
        index   => 'twitter'          # specific index
        index   => ['twitter','user'] # list of indices
        index   => '_all'             # all indices
  
        index   => []                 # error
        index   => undef              # error
  
  
  Also, see L</"use_index()/use_type()">.
  
  =head2 as_json
  
  If you pass C<< as_json => 1 >> to any request to the ElasticSearch server,
  it will return the raw UTF8-decoded JSON response, rather than a Perl
  datastructure.
  
  =cut
  
  =head1 RETURN VALUES AND EXCEPTIONS
  
  Methods that query the ElasticSearch cluster return the raw data structure
  that the cluster returns.  This may change in the future, but as these
  data structures are still in flux, I thought it safer not to try to interpret.
  
  Anything that is known to be an error throws an exception, eg trying to delete
  a non-existent index.
  
  =cut
  
  =head1 INTEGRATION WITH ElasticSearch::SearchBuilder
  
  L<ElasticSearch::SearchBuilder> provides a concise Perlish
  L<SQL::Abstract>-style query language, which gets translated into the native
  L<Query DSL|http://www.elasticsearch.org/guide/reference/query-dsl> that
  ElasticSearch uses.
  
  For instance:
  
      {
          content => 'search keywords',
          -filter => {
              tags        => ['perl','ruby'],
              date        => {
                  '>'     => '2010-01-01',
                  '<='    => '2011-01-01'
              },
          }
      }
  
  Would be translated to:
  
      { query => {
          filtered => {
              query  => { text => { content => "search keywords" } },
              filter => {
                  and => [
                      { terms => { tags => ["perl", "ruby"] } },
                      { numeric_range => {
                          date => {
                              gt => "2010-01-01",
                              lte => "2011-01-01"
                      }}},
                  ],
              }
      }}}
  
  All you have to do to start using L<ElasticSearch::SearchBuilder> is to change
  your C<query> or C<filter> parameter to C<queryb> or C<filterb> (where the
  extra C<b> stands for C<builder>):
  
      $es->search(
          queryb => { content => 'keywords' }
      )
  
  If you want to see what your SearchBuilder-style query is being converted into,
  you can either use L</"trace_calls()"> or access it directly with:
  
      $native_query  = $es->builder->query( $query )
      $native_filter = $es->builder->filter( $filter )
  
  See the L<ElasticSearch::SearchBuilder> docs for more information about
  the syntax.
  
  =head1 METHODS
  
  =head2 Creating a new ElasticSearch instance
  
  =head3 new()
  
      $es = ElasticSearch->new(
              transport    =>  'http',
              servers      =>  '127.0.0.1:9200'                   # single server
                                | ['es1.foo.com:9200',
                                   'es2.foo.com:9200'],           # multiple servers
              trace_calls  => 1 | '/path/to/log/file' | $fh
              timeout      => 30,
              max_requests => 10_000,                             # refresh server list
                                                                  # after max_requests
  
              no_refresh   => 0 | 1                               # don't retrieve the live
                                                                  # server list. Instead, use
                                                                  # just the servers specified
       );
  
  C<servers> can be either a single server or an ARRAY ref with a list of servers.
  If not specified, then it defaults to C<localhost> and the port for the
  specified transport (eg C<9200> for C<http*> or C<9500> for C<thrift>).
  
  These servers are used in a round-robin fashion. If any server fails to
  connect, then the other servers in the list are tried, and if any
  succeeds, then a list of all servers/nodes currently known to the
  ElasticSearch cluster are retrieved and stored.
  
  Every C<max_requests> (default 10,000) this list of known nodes is refreshed
  automatically.  To disable this automatic refresh, you can set C<max_requests>
  to C<0>.
  
  To force a lookup of live nodes, you can do:
  
      $es->refresh_servers();
  
  =head4 no_refresh()
  
  Regardless of the C<max_requests> setting, a list of live nodes will still be
  retrieved on the first request.  This may not be desirable behaviour
  if, for instance, you are connecting to remote servers which use internal
  IP addresses, or which don't allow remote C<nodes()> requests.
  
  If you want to disable this behaviour completely, set C<no_refresh> to C<1>,
  in which case the transport module will round robin through the
  C<servers> list only. Failed nodes will be removed from the list
  (but added back in every C<max_requests> or when all nodes have failed).
  
  =head4 Transport Backends
  
  There are various C<transport> backends that ElasticSearch can use:
  C<http> (the default, based on LWP), C<httplite> (based on L<HTTP::Lite>),
  C<httptiny> (based on L<HTTP::Tiny>), C<curl> (based on L<WWW::Curl>),
  C<aehttp> (based on L<AnyEvent::HTTP>), C<aecurl> (based on
  L<AnyEvent::Curl::Multi>) and C<thrift> (which uses the Thrift protocol).
  
  Although the C<thrift> interface has the right buzzwords (binary, compact,
  sockets), the generated Perl code is very slow. Until that is improved, I
  recommend one of the C<http> backends instead.
  
  The C<httplite> backend is about 30% faster than the default C<http> backend,
  and will probably become the default after more testing in production.
  
  The C<httptiny> backend is 1% faster again than C<httplite>.
  
  See also: L<ElasticSearch::Transport>, L</"timeout()">, L</"trace_calls()">,
  L<http://www.elasticsearch.org/guide/reference/modules/http.html>
  and L<http://www.elasticsearch.org/guide/reference/modules/thrift.html>
  
  =cut
  
  =head2 Document-indexing methods
  
  =head3 index()
  
      $result = $es->index(
          index       => single,
          type        => single,
          id          => $document_id,        # optional, otherwise auto-generated
          data        => {
              key => value,
              ...
          },
  
          # optional
          consistency  => 'quorum' | 'one' | 'all',
          create       => 0 | 1,
          parent       => $parent,
          percolate    => $percolate,
          refresh      => 0 | 1,
          replication  => 'sync' | 'async',
          routing      => $routing,
          timeout      => eg '1m' or '10s'
          version      => int,
          version_type => 'internal' | 'external',
      );
  
  eg:
  
      $result = $es->index(
          index   => 'twitter',
          type    => 'tweet',
          id      => 1,
          data    => {
              user        => 'kimchy',
              post_date   => '2009-11-15T14:12:12',
              message     => 'trying out Elastic Search'
          },
      );
  
  Used to add a document to a specific C<index> as a specific C<type> with
  a specific C<id>. If the C<index/type/id> combination already exists,
  then that document is updated, otherwise it is created.
  
  Note:
  
  =over
  
  =item *
  
  If the C<id> is not specified, then ElasticSearch autogenerates a unique
  ID and a new document is always created.
  
  =item *
  
  If C<version> is passed, and the current version in ElasticSearch is
  different, then a C<Conflict> error will be thrown.
  
  =item *
  
  C<data> can also be a raw JSON encoded string (but ensure that it is correctly
  encoded, otherwise you see errors when trying to retrieve it from ElasticSearch).
  
      $es->index(
          index   => 'foo',
          type    =>  'bar',
          id      =>  1,
          data    =>  '{"foo":"bar"}'
      );
  
  =item *
  
  C<timeout> for all CRUD methods and L</"search()"> is a query timeout,
  specifying the amount of time ElasticSearch will spend (roughly) processing a
  query. Units can be concatenated with the integer value, e.g., C<500ms> or
  C<1s>.
  
  See also: L<http://www.elasticsearch.org/guide/reference/api/search/request-body.html>
  
  Note: this is distinct from the transport timeout, see L</"timeout()">.
  
  =back
  
  See also: L<http://www.elasticsearch.org/guide/reference/api/index_.html>,
  L</"bulk()"> and L</"put_mapping()">
  
  =head3 set()
  
  C<set()> is a synonym for L</"index()">
  
  
  =head3 create()
  
      $result = $es->create(
          index       => single,
          type        => single,
          id          => $document_id,        # optional, otherwise auto-generated
          data        => {
              key => value,
              ...
          },
  
          # optional
          consistency  => 'quorum' | 'one' | 'all',
          parent       => $parent,
          percolate    => $percolate,
          refresh      => 0 | 1,
          replication  => 'sync' | 'async',
          routing      => $routing,
          timeout      => eg '1m' or '10s',
          version      => int,
          version_type => 'internal' | 'external',
      );
  
  eg:
  
      $result = $es->create(
          index   => 'twitter',
          type    => 'tweet',
          id      => 1,
          data    => {
              user        => 'kimchy',
              post_date   => '2009-11-15T14:12:12',
              message     => 'trying out Elastic Search'
          },
      );
  
  Used to add a NEW document to a specific C<index> as a specific C<type> with
  a specific C<id>. If the C<index/type/id> combination already exists,
  then a C<Conflict> error is thrown.
  
  If the C<id> is not specified, then ElasticSearch autogenerates a unique
  ID.
  
  If you pass a C<version> parameter to C<create>, then it must be C<0> unless
  you also set C<version_type> to C<external>.
  
  See also: L</"index()">
  
  =head3 update()
  
      $result = $es->update(
          index             => single,
          type              => single,
          id                => single,
  
          # required
          script            => $script,
        | doc               => $doc
  
          # optional
          params            => { params },
          upsert            => { new_doc },
          consistency       => 'quorum' | 'one' | 'all',
          fields            => ['_source'],
          ignore_missing    => 0 | 1,
          parent            => $parent,
          percolate         => $percolate,
          retry_on_conflict => 2,
          routing           => $routing,
          timeout           => '10s',
          replication       => 'sync' | 'async'
      )
  
  The C<update()> method accepts a C<script> to update, or a C<doc> to be merged
  with, an existing doc, without having to retrieve and reindex the doc yourself,
  eg:
  
      $es->update(
          index   => 'test',
          type    => 'foo',
          id      => 123,
          script  => 'ctx._source.tags+=[tag]',
          params  => { tag => 'red' }
      );
  
  You can also pass a new doc which will be inserted if the doc does not
  already exist, via the C<upsert> paramater.
  
  See L<http://www.elasticsearch.org/guide/reference/api/update.html> for more.
  
  =head3 get()
  
      $result = $es->get(
          index   => single,
          type    => single or blank,
          id      => single,
  
          # optional
          fields          => 'field' or ['field1',...]
          preference      => '_local' | '_primary' | '_primary_first' | $string,
          refresh         => 0 | 1,
          routing         => $routing,
          parent          => $parent,
          ignore_missing  => 0 | 1,
  
      );
  
  Returns the document stored at C<index/type/id> or throws an exception if
  the document doesn't exist.
  
  Example:
  
      $es->get( index => 'twitter', type => 'tweet', id => 1)
  
  Returns:
  
      {
        _id     => 1,
        _index  => "twitter",
        _source => {
                     message => "trying out Elastic Search",
                     post_date=> "2009-11-15T14:12:12",
                     user => "kimchy",
                   },
        _type   => "tweet",
      }
  
  By default the C<_source> field is returned.  Use C<fields> to specify
  a list of (stored) fields to return instead, or C<[]> to return no fields.
  
  Pass a true value for C<refresh> to force an index refresh before performing
  the get.
  
  If the requested C<index>, C<type> or C<id> is not found, then a C<Missing>
  exception is thrown, unless C<ignore_missing> is true.
  
  See also: L</"bulk()">, L<http://www.elasticsearch.org/guide/reference/api/get.html>
  
  =head3 exists()
  
      $bool = $es->exists(
          index           => single,
          type            => single,
          id              => single,
  
          preference      => '_local' | '_primary' | '_primary_first' | $string,
          refresh         => 0 | 1,
          routing         => $routing,
          parent          => $parent,
      );
  
  Returns true or false depending on whether the doc exists.
  
  =head3 mget()
  
      $docs = $es->mget(
          index          => single,
          type           => single or blank,
          ids            => \@ids,
          fields         => ['field_1','field_2'],
          filter_missing => 0 | 1
      );
  
      $docs = $es->mget(
          index          => single or blank,
          type           => single or blank,
          docs           => \@doc_info,
          fields         => ['field_1','field_2'],
          filter_missing => 0 | 1
      );
  
  C<mget> or "multi-get" returns multiple documents at once. There are two
  ways to call C<mget()>:
  
  If all docs come from the same index (and potentially the same type):
  
      $docs = $es->mget(
          index => 'myindex',
          type  => 'mytype',   # optional
          ids   => [1,2,3],
      )
  
  Alternatively you can specify each doc separately:
  
      $docs = $es->mget(
          docs => [
              { _index => 'index_1', _type => 'type_1', _id => 1 },
              { _index => 'index_2', _type => 'type_2', _id => 2 },
          ]
      )
  
  Or:
  
      $docs = $es->mget(
          index  => 'myindex',                    # default index
          type   => 'mytype',                     # default type
          fields => ['field_1','field_2'],        # default fields
          docs => [
              { _id => 1 },                       # uses defaults
              { _index => 'index_2',
                _type  => 'type_2',
                _id    => 2,
                fields => ['field_2','field_3'],
              },
          ]
      );
  
  If C<$docs> or C<$ids> is an empty array ref, then C<mget()> will just return
  an empty array ref.
  
  Returns an array ref containing all of the documents requested.  If a document
  is not found, then its entry will include C<< {exists => 0} >>. If you would
  rather filter these missing docs, pass C<< filter_missing => 1 >>.
  
  See L<http://www.elasticsearch.org/guide/reference/api/multi-get.html>
  
  =head3 delete()
  
      $result = $es->delete(
          index           => single,
          type            => single,
          id              => single,
  
          # optional
          consistency     => 'quorum' | 'one' | 'all'
          ignore_missing  => 0 | 1
          refresh         => 0 | 1
          parent          => $parent,
          routing         => $routing,
          replication     => 'sync' | 'async'
          version         => int
      );
  
  Deletes the document stored at C<index/type/id> or throws an C<Missing>
  exception if the document doesn't exist and C<ignore_missing> is not true.
  
  If you specify a C<version> and the current version of the document is
  different (or if the document is not found), a C<Conflict> error will
  be thrown.
  
  If C<refresh> is true, an index refresh will be forced after the delete has
  completed.
  
  Example:
  
      $es->delete( index => 'twitter', type => 'tweet', id => 1);
  
  See also: L</"bulk()">,
  L<http://www.elasticsearch.org/guide/reference/api/delete.html>
  
  =head3 bulk()
  
      $result = $es->bulk( [ actions ] )
  
      $result = $es->bulk(
          actions     => [ actions ]                  # required
  
          index       => 'foo',                       # optional
          type        => 'bar',                       # optional
          consistency => 'quorum' |  'one' | 'all'    # optional
          refresh     => 0 | 1,                       # optional
          replication => 'sync' | 'async',            # optional
  
          on_conflict => sub {...} | 'IGNORE'         # optional
          on_error    => sub {...} | 'IGNORE'         # optional
      );
  
  
  Perform multiple C<index>, C<create> and C<delete> actions in a single request.
  This is about 10x as fast as performing each action in a separate request.
  
  Each C<action> is a HASH ref with a key indicating the action type (C<index>,
  C<create> or C<delete>), whose value is another HASH ref containing the
  associated metadata.
  
  The C<index> and C<type> parameters can be specified for each individual action,
  or inherited from the top level C<index> and C<type> parameters, as shown
  above.
  
  NOTE: C<bulk()> also accepts the C<_index>, C<_type>, C<_id>, C<_source>,
  C<_parent>, C<_routing> and C<_version> parameters so that you can pass search
  results directly to C<bulk()>.
  
  =head4 C<index> and C<create> actions
  
      { index  => {
          index           => 'foo',
          type            => 'bar',
          id              => 123,
          data            => { text => 'foo bar'},
  
          # optional
          routing         => $routing,
          parent          => $parent,
          percolate       => $percolate,
          timestamp       => $timestamp,
          ttl             => $ttl,
          version         => $version,
          version_type    => 'internal' | 'external'
      }}
  
      { create  => { ... same options as for 'index' }}
  
  The C<index> and C<type> parameters, if not specified, are inherited from
  the top level bulk request.
  
  C<data> can also be a raw JSON encoded string (but ensure that it is correctly
  encoded, otherwise you see errors when trying to retrieve it from ElasticSearch).
  
      actions => [{
          index => {
              index   => 'foo',
              type    =>  'bar',
              id      =>  1,
              data    =>  '{"foo":"bar"}'
          }
      }]
  
  =head4 C<delete> action
  
      { delete  => {
          index           => 'foo',
          type            => 'bar',
          id              => 123,
  
          # optional
          routing         => $routing,
          parent          => $parent,
          version         => $version,
          version_type    => 'internal' | 'external'
      }}
  
  The C<index> and C<type> parameters, if not specified, are inherited from
  the top level bulk request.
  
  =head4 Error handlers
  
  The C<on_conflict> and C<on_error> parameters accept either a coderef or the
  string C<'IGNORE'>.  Normally, any errors are returned under the C<errors>
  key (see L</Return values>).
  
  The logic works as follows:
  
  =over
  
  =item *
  
  If the error is a versioning conflict error, or if you try to C<create> a doc
  whose ID already exists,  and there is an C<on_conflict>
  handler, then call the handler and move on to the next document
  
  =item *
  
  If the error is still unhandled, and we have an C<on_error> handler, then call
  it and move on to the next document.
  
  =item *
  
  If no handler exists, then add the error to the C<@errors> array which is
  returned by L</bulk()>
  
  =back
  
  Setting C<on_conflict> or C<on_error> to C<'IGNORE'> is the equivalent
  of passing an empty no-op handler.
  
  The handler callbacks are called as:
  
      $handler->( $action, $document, $error, $req_no );
  
  For instance:
  
  =over
  
  =item C<$action>
  
      "index"
  
  =item C<$document>
  
      { id => 1, data => { count => "foo" }}
  
  =item C<$error>
  
      "MapperParsingException[Failed to parse [count]]; ... etc ... "
  
  =item  C<$req_no>
  
      0
  
  =back
  
  The C<$req_no> is the array index of the current C<$action> from the original
  array of C<@actions>.
  
  =head4 Return values
  
  The L</"bulk()"> method returns a HASH ref containing:
  
      {
          actions => [ the list of actions you passed in ],
          results => [ the result of each of the actions ],
          errors  => [ a list of any errors              ]
      }
  
  The C<results> ARRAY ref contains the same values that would be returned
  for individiual C<index>/C<create>/C<delete> statements, eg:
  
      results => [
           { create => { _id => 123, _index => "foo", _type => "bar", _version => 1 } },
           { index  => { _id => 123, _index => "foo", _type => "bar", _version => 2 } },
           { delete => { _id => 123, _index => "foo", _type => "bar", _version => 3 } },
      ]
  
  The C<errors> key is only present if an error has occured and has not been handled
  by an C<on_conflict> or C<on_error> handler, so you can do:
  
      $results = $es->bulk(\@actions);
      if ($results->{errors}) {
          # handle errors
      }
  
  Each error element contains the C<error> message plus the C<action> that
  triggered the error.  Each C<result> element will also contain the error
  message., eg:
  
  
      $result = {
          actions => [
  
              ## NOTE - num is numeric
              {   index => { index => 'bar', type  => 'bar', id => 123,
                             data  => { num => 123 } } },
  
              ## NOTE - num is a string
              {   index => { index => 'bar', type  => 'bar', id => 123,
                             data  => { num => 'foo bar' } } },
          ],
          errors => [
              {
                  action => {
                      index => { index => 'bar', type  => 'bar', id => 123,
                                 data  => { num => 'text foo' } }
                  },
                  error => "MapperParsingException[Failed to parse [num]]; ...",
              },
          ],
          results => [
              { index => { _id => 123, _index => "bar", _type => "bar", _version => 1 }},
              {   index => {
                      error => "MapperParsingException[Failed to parse [num]];...",
                      id    => 123, index => "bar", type  => "bar",
                  },
              },
          ],
  
      };
  
  See L<http://www.elasticsearch.org/guide/reference/api/bulk.html> for
  more details.
  
  =head3 bulk_index(), bulk_create(), bulk_delete()
  
  These are convenience methods which allow you to pass just the metadata, without
  the C<index>, C<create> or C<index> action for each record.
  
  These methods accept the same parameters as the L</"bulk()"> method, except
  that the C<actions> parameter is replaced by C<docs>, eg:
  
      $result = $es->bulk_index( [ docs ] );
  
      $result = $es->bulk_index(
          docs        => [ docs ],                    # required
  
          index       => 'foo',                       # optional
          type        => 'bar',                       # optional
          consistency => 'quorum' |  'one' | 'all'    # optional
          refresh     => 0 | 1,                       # optional
          replication => 'sync' | 'async',            # optional
  
          on_conflict => sub {...} | 'IGNORE'         # optional
          on_error    => sub {...} | 'IGNORE'         # optional
      );
  
  For instance:
  
      $es->bulk_index(
          index   => 'foo',
          type    => 'bar',
          refresh => 1,
          docs    => [
              { id => 123,                data => { text=>'foo'} },
              { id => 124, type => 'baz', data => { text=>'bar'} },
          ]
      );
  
  
  =head3 reindex()
  
      $es->reindex(
          source      => $scrolled_search,
  
          # optional
          bulk_size   => 1000,
          dest_index  => $index,
          quiet       => 0 | 1,
          transform   => sub {....},
  
          on_conflict => sub {...} | 'IGNORE'
          on_error    => sub {...} | 'IGNORE'
      )
  
  C<reindex()> is a utility method which can be used for reindexing data
  from one index to another (eg if the mapping has changed), or copying
  data from one cluster to another.
  
  =head4 Params
  
  =over
  
  =item *
  
  C<source> is a required parameter, and should be an instance of
  L<ElasticSearch::ScrolledSearch>.
  
  =item *
  
  C<dest_index> is the name of the destination index, ie where the docs are
  indexed to.  If you are indexing your data from one cluster to another,
  and you want to use the same index name in your destination cluster, then
  you can leave this blank.
  
  =item *
  
  C<bulk_size> - the number of docs that will be indexed at a time. Defaults
  to 1,000
  
  =item *
  
  Set C<quiet> to C<1> if you don't want any progress information to be
  printed to C<STDOUT>
  
  =item *
  
  C<transform> should be a sub-ref which will be called for each doc, allowing
  you to transform some element of the doc, or to skip the doc by returning
  C<undef>.
  
  =item *
  
  See L</Error handlers> for an explanation C<on_conflict> and C<on_error>.
  
  =back
  
  =head4 Examples:
  
  To copy the ElasticSearch website index locally, you could do:
  
      my $local = ElasticSearch->new(
          servers => 'localhost:9200'
      );
      my $remote = ElasticSearch->new(
          servers    => 'search.elasticsearch.org:80',
          no_refresh => 1
      );
  
      my $source = $remote->scrolled_search(
          search_type => 'scan',
          scroll      => '5m'
      );
      $local->reindex(source=>$source);
  
  To copy one local index to another, make the title upper case,
  exclude docs of type C<boring>, and to preserve the version numbers
  from the original index:
  
      my $source = $es->scrolled_search(
          index       => 'old_index',
          search_type => 'scan',
          scroll      => '5m',
          version     => 1
      );
  
      $es->reindex(
          source      => $source,
          dest_index  => 'new_index',
          transform   => sub {
              my $doc = shift;
              return if $doc->{_type} eq 'boring';
              $doc->{_source}{title} = uc( $doc->{_source}{title} );
              return $doc;
          }
      );
  
  B<NOTE:> If some of your docs have parent/child relationships, and you want
  to preserve this relationship, then you should add this to your
  scrolled search parameters: C<< fields => ['_source','_parent'] >>.
  
  For example:
  
      my $source = $es->scrolled_search(
          index       => 'old_index',
          search_type => 'scan',
          fields      => ['_source','_parent'],
          version     => 1
      );
  
      $es->reindex(
          source      => $source,
          dest_index  => 'new_index',
      );
  
  See also L</"scrolled_search()">, L<ElasticSearch::ScrolledSearch>,
  and L</"search()">.
  
  =head3 analyze()
  
      $result = $es->analyze(
        text          =>  $text_to_analyze,           # required
        index         =>  single,                     # optional
  
        # either
        field         =>  'type.fieldname',           # requires index
  
        analyzer      =>  $analyzer,
  
        tokenizer     => $tokenizer,
        filters       => \@filters,
  
        # other options
        format        =>  'detailed' | 'text',
        prefer_local  =>  1 | 0
      );
  
  The C<analyze()> method allows you to see how ElasticSearch is analyzing
  the text that you pass in, eg:
  
      $result = $es->analyze( text => 'The Man' )
  
      $result = $es->analyze(
          text        => 'The Man',
          analyzer    => 'simple'
      );
  
      $result = $es->analyze(
          text        => 'The Man',
          tokenizer   => 'keyword',
          filters     => ['lowercase'],
      );
  
      $result = $es->analyze(
          text        => 'The Man',
          index       => 'my_index',
          analyzer    => 'my_custom_analyzer'
      );
  
      $result = $es->analyze(
          text        => 'The Man',
          index       => 'my_index',
          field       => 'my_type.my_field',
      );
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-analyze.html> for
  more.
  
  =cut
  
  =head2 Query methods
  
  =head3 search()
  
      $result = $es->search(
          index           => multi,
          type            => multi,
  
          # optional
          query           => { native query },
          queryb          => { searchbuilder query },
  
          filter          => { native filter },
          filterb         => { searchbuilder filter },
  
          explain         => 1 | 0,
          facets          => { facets },
          fields          => [$field_1,$field_n],
          partial_fields  => { my_field => { include => 'foo.bar.*' }},
          from            => $start_from,
          highlight       => { highlight }.
          ignore_indices  => 'none' | 'missing',
          indices_boost   => { index_1 => 1.5,... },
          min_score       => $score,
          preference      => '_local' | '_primary' | '_primary_first' | $string,
          routing         => [$routing, ...]
          script_fields   => { script_fields }
          search_type     => 'dfs_query_then_fetch'
                             | 'dfs_query_and_fetch'
                             | 'query_then_fetch'
                             | 'query_and_fetch'
                             | 'count'
                             | 'scan'
          size            => $no_of_results
          sort            => ['_score',$field_1]
          scroll          => '5m' | '30s',
          stats           => ['group_1','group_2'],
          track_scores    => 0 | 1,
          timeout         => '10s'
          version         => 0 | 1
      );
  
  Searches for all documents matching the query, with a request-body search.
  Documents can be matched against multiple indices and multiple types, eg:
  
      $result = $es->search(
          index   => undef,                           # all
          type    => ['user','tweet'],
          query   => { term => {user => 'kimchy' }}
      );
  
  You can provide either the C<query> parameter, which uses the native
  ElasticSearch Query DSL, or the C<queryb> parameter, which uses the
  more concise L<ElasticSearch::SearchBuilder> query syntax.
  
  Similarly, use C<filterb> instead of C<filter>. SearchBuilder can also be
  used in facets, for instance, instead of:
  
      $es->search(
          facets  => {
              wow_facet => {
                  query        => { text => { content => 'wow'  }},
                  facet_filter => { term => {status => 'active' }},
              }
          }
      )
  
  You can use:
  
      $es->search(
          facets  => {
              wow_facet => {
                  queryb        => { content => 'wow'   },  # note the extra 'b'
                  facet_filterb => { status => 'active' },  # note the extra 'b'
              }
          }
      )
  
  See L</"INTEGRATION WITH ElasticSearch::SearchBuilder"> for more.
  
  For all of the options that can be included in the native C<query> parameter,
  see L<http://www.elasticsearch.org/guide/reference/api/search>,
  L<http://www.elasticsearch.org/guide/reference/api/search/request-body.html>
  and L<http://www.elasticsearch.org/guide/reference/query-dsl>
  
  =head3 searchqs()
  
      $result = $es->searchqs(
          index                    => multi,
          type                     => multi,
  
          # optional
          q                        => $query_string,
          analyze_wildcard         => 0 | 1,
          analyzer                 => $analyzer,
          default_operator         => 'OR | AND ',
          df                       => $default_field,
          explain                  => 1 | 0,
          fields                   => [$field_1,$field_n],
          from                     => $start_from,
          ignore_indices           => 'none' | 'missing',
          lenient                  => 0 | 1,
          lowercase_expanded_terms => 0 | 1,
          preference               => '_local' | '_primary' | '_primary_first' | $string,
          quote_analyzer           => $analyzer,
          quote_field_suffix       => '.unstemmed',
          routing                  => [$routing, ...]
          search_type              => $search_type
          size                     => $no_of_results
          sort                     => ['_score:asc','last_modified:desc'],
          scroll                   => '5m' | '30s',
          stats                    => ['group_1','group_2'],
          timeout                  => '10s'
          version                  => 0 | 1
  
  Searches for all documents matching the C<q> query_string, with a URI request.
  Documents can be matched against multiple indices and multiple types, eg:
  
      $result = $es->searchqs(
          index   => undef,                           # all
          type    => ['user','tweet'],
          q       => 'john smith'
      );
  
  For all of the options that can be included in the C<query> parameter, see
  L<http://www.elasticsearch.org/guide/reference/api/search> and
  L<http://www.elasticsearch.org/guide/reference/api/search/uri-request.html>.
  
  =head3 scroll()
  
      $result = $es->scroll(
          scroll_id => $scroll_id,
          scroll    => '5m' | '30s',
      );
  
  If a search has been executed with a C<scroll> parameter, then the returned
  C<scroll_id> can be used like a cursor to scroll through the rest of the
  results.
  
  If a further scroll request will be issued, then the C<scroll> parameter
  should be passed as well.  For instance;
  
      my $result = $es->search(
                      query=>{match_all=>{}},
                      scroll => '5m'
                   );
  
      while (1) {
          my $hits = $result->{hits}{hits};
          last unless @$hits;                 # if no hits, we're finished
  
          do_something_with($hits);
  
          $result = $es->scroll(
              scroll_id   => $result->{_scroll_id},
              scroll      => '5m'
          );
      }
  
  See L<http://www.elasticsearch.org/guide/reference/api/search/scroll.html>
  
  =head3 scrolled_search()
  
  C<scrolled_search()> returns a convenience iterator for scrolled
  searches. It accepts the standard search parameters that would be passed
  to L</"search()"> and requires a C<scroll> parameter, eg:
  
      $scroller = $es->scrolled_search(
                      query  => {match_all=>{}},
                      scroll => '5m'               # keep the scroll request
                                                   # live for 5 minutes
                  );
  
  See L<ElasticSearch::ScrolledSearch>, L</"search()">, L</"searchqs()">
  and L</"scroll()">.
  
  =head3 count()
  
      $result = $es->count(
          index           => multi,
          type            => multi,
  
          # optional
          routing         => [$routing,...]
          ignore_indices  => 'none' | 'missing',
  
          # one of:
          query           => { native query },
          queryb          => { search builder query },
      );
  
  Counts the number of documents matching the query. Documents can be matched
  against multiple indices and multiple types, eg
  
      $result = $es->count(
          index   => undef,               # all
          type    => ['user','tweet'],
          queryb  => { user  => 'kimchy' }
      );
  
  B<Note>: C<count()> supports L<ElasticSearch::SearchBuilder>-style
  queries via the C<queryb> parameter.  See
  L</"INTEGRATION WITH ElasticSearch::SearchBuilder"> for more details.
  
  C<query> defaults to C<< {match_all=>{}} >> unless specified.
  
  B<DEPRECATION>: C<count()> previously took query types at the top level, eg
  C<< $es->count( term=> { ... }) >>. This form still works, but is deprecated.
  Instead use the C<queryb> or C<query> parameter as you would in L</"search()">.
  
  See also L</"search()">,
  L<http://www.elasticsearch.org/guide/reference/api/count.html>
  and L<http://www.elasticsearch.org/guide/reference/query-dsl>
  
  =head3 msearch()
  
      $results = $es->msearch(
          index       => multi,
          type        => multi,
          queries     => \@queries | \%queries,
          search_type => $search_type,
      );
  
  With L</"msearch()"> you can run multiple searches in parallel. C<queries>
  can contain either an array of queries, or a hash of named queries.  C<$results>
  will return either an array or hash of results, depending on what you pass in.
  
  The top-level C<index>, C<type> and C<search_type> parameters define default
  values which will be used for each query, although these can be overridden in
  the query parameters:
  
      $results = $es->msearch(
          index   => 'my_index',
          type    => 'my_type',
          queries => {
              first   => {
                  query => { match_all: {}}   # my_index/my_type
              },
              second  => {
                  index => 'other_index',
                  query => { match_all: {}}   # other_index/my_type
              },
          }
      )
  
  In the above example, C<$results> would look like:
  
      {
          first  => { hits => ... },
          second => { hits => ... }
      }
  
  A query can contain the following options:
  
      {
            index          => 'index_name' | ['index_1',...],
            type           => 'type_name'  | ['type_1',...],
  
            query          => { native query },
            queryb         => { search_builder query },
            filter         => { native filter },
            filterb        => { search_builder filter },
  
            facets         => { facets },
            from           => 0,
            size           => 10,
            sort           => { sort },
            highlight      => { highlight },
            fields         => [ 'field1', ... ],
  
            explain        => 0 | 1,
            indices_boost  => { index_1 => 5, ... },
            ignore_indices => 'none' | 'missing',
            min_score      => 2,
            partial_fields => { partial fields },
            preference     => '_local' | '_primary' | '_primary_first' | $string,
            routing        => 'routing' | ['route_1',...],
            script_fields  => { script fields },
            search_type    => $search_type,
            stats          => 'group_1' | ['group_1','group_2'],
            timeout        => '30s',
            track_scores   => 0 | 1,
            version        => 0 | 1,
      }
  
  See L<http://www.elasticsearch.org/guide/reference/api/multi-search.html>.
  
  =head3 delete_by_query()
  
      $result = $es->delete_by_query(
          index           => multi,
          type            => multi,
  
          # optional
          consistency     => 'quorum' | 'one' | 'all'
          replication     => 'sync' | 'async'
          routing         => [$routing,...]
  
          # one of:
          query           => { native query },
          queryb          => { search builder query },
  
      );
  
  Deletes any documents matching the query. Documents can be matched against
  multiple indices and multiple types, eg
  
      $result = $es->delete_by_query(
          index   => undef,               # all
          type    => ['user','tweet'],
          queryb  => {user => 'kimchy' },
      );
  
  B<Note>: C<delete_by_query()> supports L<ElasticSearch::SearchBuilder>-style
  queries via the C<queryb> parameter.  See
  L</"INTEGRATION WITH ElasticSearch::SearchBuilder"> for more details.
  
  B<DEPRECATION>: C<delete_by_query()> previously took query types at the top level,
  eg C<< $es->delete_by_query( term=> { ... }) >>. This form still works, but is
  deprecated. Instead use the C<queryb> or C<query> parameter as you would in
  L</"search()">.
  
  See also L</"search()">,
  L<http://www.elasticsearch.org/guide/reference/api/delete-by-query.html>
  and L<http://www.elasticsearch.org/guide/reference/query-dsl>
  
  
  =head3 mlt()
  
      # mlt == more_like_this
  
      $results = $es->mlt(
          index               => single,              # required
          type                => single,              # required
          id                  => $id,                 # required
  
          # optional more-like-this params
          boost_terms          =>  float
          mlt_fields           =>  'scalar' or ['scalar_1', 'scalar_n']
          max_doc_freq         =>  integer
          max_query_terms      =>  integer
          max_word_len         =>  integer
          min_doc_freq         =>  integer
          min_term_freq        =>  integer
          min_word_len         =>  integer
          pct_terms_to_match   =>  float
          stop_words           =>  'scalar' or ['scalar_1', 'scalar_n']
  
          # optional search params
          explain              =>  {explain}
          facets               =>  {facets}
          fields               =>  {fields}
          filter               =>  { native filter },
          filterb              =>  { search builder filter },
          indices_boost        =>  { index_1 => 1.5,... }
          min_score            =>  $score
          routing              =>  [$routing,...]
          script_fields        =>  { script_fields }
          search_scroll        =>  '5m' | '10s',
          search_indices       =>  ['index1','index2],
          search_from          =>  integer,
          search_size          =>  integer,
          search_type          =>  $search_type
          search_types         =>  ['type1','type],
          sort                 =>  {sort}
          scroll               =>  '5m' | '30s'
      )
  
  More-like-this (mlt) finds related/similar documents. It is possible to run
  a search query with a C<more_like_this> clause (where you pass in the text
  you're trying to match), or to use this method, which uses the text of
  the document referred to by C<index/type/id>.
  
  This gets transformed into a search query, so all of the search parameters
  are also available.
  
  Note: C<mlt()> supports L<ElasticSearch::SearchBuilder>-style filters via
  the C<filterb> parameter.  See L</"INTEGRATION WITH ElasticSearch::SearchBuilder">
  for more details.
  
  See L<http://www.elasticsearch.org/guide/reference/api/more-like-this.html>
  and L<http://www.elasticsearch.org/guide/reference/query-dsl/mlt-query.html>
  
  =head3 explain()
  
      $result = $ex->explain(
          index                      =>  single,
          type                       =>  single,
          id                         =>  single,
  
  
          query                      => { native query}
        | queryb                     => { search builder query }
        | q                          => $query_string,
  
          analyze_wildcard           => 1 | 0,
          analyzer                   => $string,
          default_operator           => 'OR' | 'AND',
          df                         => $default_field
          fields                     => ['_source'],
          lenient                    => 1 | 0,
          lowercase_expanded_terms   => 1 | 0,
          preference                 => _local | _primary | _primary_first | $string,
          routing                    => $routing
      );
  
  The L<explain()> method is very useful for debugging queries.  It will run
  the query on the specified document and report whether the document matches
  the query or not, and why.
  
  See L<http://www.elasticsearch.org/guide/reference/api/search/explain.html>
  
  =head3 validate_query()
  
      $bool = $es->validate_query(
          index          => multi,
          type           => multi,
  
          query          => { native query }
        | queryb         => { search builder query }
        | q              => $query_string
  
          explain        => 0 | 1,
          ignore_indices => 'none' | 'missing',
      );
  
  Returns a hashref with C<< { valid => 1} >> if the passed in C<query>
  (native ES query) C<queryb> (SearchBuilder style query) or C<q> (Lucene
  query string) is valid. Otherwise C<valid> is false. Set C<explain> to C<1>
  to include the explanation of why the query is invalid.
  
  See L<http://www.elasticsearch.org/guide/reference/api/validate.html>
  
  =cut
  
  =head2 Index Admin methods
  
  =head3 index_status()
  
      $result = $es->index_status(
          index           => multi,
          recovery        => 0 | 1,
          snapshot        => 0 | 1,
          ignore_indices  => 'none' | 'missing',
      );
  
  Returns the status of
      $result = $es->index_status();                               #all
      $result = $es->index_status( index => ['twitter','buzz'] );
      $result = $es->index_status( index => 'twitter' );
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-status.html>
  
  =head3 index_stats()
  
      $result = $es->index_stats(
          index           => multi,
          types           => multi,
  
          docs            => 1|0,
          store           => 1|0,
          indexing        => 1|0,
          get             => 1|0,
  
          all             => 0|1,  # returns all stats
          clear           => 0|1,  # clears default docs,store,indexing,get,search
  
          flush           => 0|1,
          merge           => 0|1
          refresh         => 0|1,
  
          level           => 'shards',
          ignore_indices  => 'none' | 'missing',
      );
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-stats.html>
  
  
  =head3 index_segments()
  
      $result = $es->index_segments(
          index           => multi,
          ignore_indices  => 'none' | 'missing',
      );
  
  Returns low-level Lucene segments information for the specified indices.
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-segments.html>
  
  =head3 create_index()
  
      $result = $es->create_index(
          index       => single,
  
          # optional
          settings    => {...},
          mappings    => {...},
          warmers     => {...},
      );
  
  Creates a new index, optionally passing index settings and mappings, eg:
  
      $result = $es->create_index(
          index   => 'twitter',
          settings => {
              number_of_shards      => 3,
              number_of_replicas    => 2,
              analysis => {
                  analyzer => {
                      default => {
                          tokenizer   => 'standard',
                          char_filter => ['html_strip'],
                          filter      => [qw(standard lowercase stop asciifolding)],
                      }
                  }
              }
          },
          mappings => {
              tweet   => {
                  properties  => {
                      user    => { type => 'string' },
                      content => { type => 'string' },
                      date    => { type => 'date'   }
                  }
              }
          },
          warmers => {
              warmer_1 => {
                  types  => ['tweet'],
                  source => {
                      queryb => { date    => { gt => '2012-01-01' }},
                      facets => {
                          content => {
                              terms => {
                                  field=>'content'
                              }
                          }
                      }
                  }
              }
          }
      );
  
  Throws an exception if the index already exists.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-create-index.html>
  
  =head3 delete_index()
  
      $result = $es->delete_index(
          index           => multi_req,
          ignore_missing  => 0 | 1        # optional
      );
  
  Deletes one or more existing indices, or throws a C<Missing> exception if a
  specified index doesn't exist and C<ignore_missing> is not true:
  
      $result = $es->delete_index( index => 'twitter' );
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-index.html>
  
  =head3 index_exists()
  
      $result = $e->index_exists(
          index => multi
      );
  
  Returns C<< {ok => 1} >> if all specified indices exist, or an empty list
  if it doesn't.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-indices-exists.html>
  
  =head3 index_settings()
  
      $result = $es->index_settings(
          index           => multi,
      );
  
  Returns the current settings for all, one or many indices.
  
      $result = $es->index_settings( index=> ['index_1','index_2'] );
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-get-settings.html>
  
  
  =head3 update_index_settings()
  
      $result = $es->update_index_settings(
          index           => multi,
          settings        => { ... settings ...},
      );
  
  Update the settings for all, one or many indices.  Currently only the
  C<number_of_replicas> is exposed:
  
      $result = $es->update_index_settings(
          settings    => {  number_of_replicas => 1 }
      );
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-update-settings.html>
  
  =head3 aliases()
  
      $result = $es->aliases( actions => [actions] | {actions} )
  
  Adds or removes an alias for an index, eg:
  
      $result = $es->aliases( actions => [
                  { remove => { index => 'foo', alias => 'bar' }},
                  { add    => { index => 'foo', alias => 'baz'  }}
                ]);
  
  C<actions> can be a single HASH ref, or an ARRAY ref containing multiple HASH
  refs.
  
  Note: C<aliases()> supports L<ElasticSearch::SearchBuilder>-style
  filters via the C<filterb> parameter.  See
  L</"INTEGRATION WITH ElasticSearch::SearchBuilder"> for more details.
  
      $result = $es->aliases( actions => [
          { add    => {
              index           => 'foo',
              alias           => 'baz',
              index_routing   => '1',
              search_routing  => '1,2',
              filterb => { foo => 'bar' }
          }}
      ]);
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html>
  
  =head3 get_aliases()
  
      $result = $es->get_aliases(
          index          => multi,
          ignore_missing => 0 | 1,
      );
  
  Returns a hashref listing all indices and their corresponding aliases, eg:
  
      {
         "foo" : {
            "aliases" : {
               "foo_1" : {
                  "search_routing" : "1,2",
                  "index_routing" : "1"
                  "filter" : {
                     "term" : {
                        "foo" : "bar"
                     }
                  }
               },
               "foo_2" : {}
            }
         }
      }
  
  If you pass in the optional C<index> argument, which can be an index name
  or an alias name, then it will only return the indices related
  to that argument.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html>
  
  =head3 open_index()
  
      $result = $es->open_index( index => single);
  
  Opens a closed index.
  
  The open and close index APIs allow you to close an index, and later on open
  it.
  
  A closed index has almost no overhead on the cluster (except for maintaining
  its metadata), and is blocked for read/write operations. A closed index can
  be opened which will then go through the normal recovery process.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-open-close.html> for more
  
  =head3 close_index()
  
      $result = $es->close_index( index => single);
  
  Closes an open index.  See
  L<http://www.elasticsearch.org/guide/reference/api/admin-indices-open-close.html> for more
  
  =head3 create_index_template()
  
      $result = $es->create_index_template(
          name     => single,
          template => $template,  # required
          mappings => {...},      # optional
          settings => {...},      # optional
          warmers  => {...},      # optional
          order    => $order,     # optional
      );
  
  Index templates allow you to define templates that will automatically be
  applied to newly created indices. You can specify both C<settings> and
  C<mappings>, and a simple pattern C<template> that controls whether
  the template will be applied to a new index.
  
  For example:
  
      $result = $es->create_index_template(
          name        => 'my_template',
          template    => 'small_*',
          settings    =>  { number_of_shards => 1 }
      );
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-templates.html> for more.
  
  =head3 index_template()
  
      $result = $es->index_template(
          name    => single
      );
  
  Retrieves the named index template.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-templates.html#GETting_a_Template>
  
  =head3 delete_index_template()
  
      $result = $es->delete_index_template(
          name            => single,
          ignore_missing  => 0 | 1    # optional
      );
  
  Deletes the named index template.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-templates.html#Deleting_a_Template>
  
  =head3 flush_index()
  
      $result = $es->flush_index(
          index           => multi,
          full            => 0 | 1,
          refresh         => 0 | 1,
          ignore_indices  => 'none' | 'missing',
      );
  
  Flushes one or more indices, which frees
  memory from the index by flushing data to the index storage and clearing the
  internal transaction log. By default, ElasticSearch uses memory heuristics
  in order to automatically trigger flush operations as required in order to
  clear memory.
  
  Example:
  
      $result = $es->flush_index( index => 'twitter' );
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-flush.html>
  
  =head3 refresh_index()
  
      $result = $es->refresh_index(
          index           => multi,
          ignore_indices  => 'none' | 'missing',
      );
  
  Explicitly refreshes one or more indices, making all operations performed
  since the last refresh available for search. The (near) real-time capabilities
  depends on the index engine used. For example, the robin one requires
  refresh to be called, but by default a refresh is scheduled periodically.
  
  Example:
  
      $result = $es->refresh_index( index => 'twitter' );
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-refresh.html>
  
  =head3 optimize_index()
  
      $result = $es->optimize_index(
          index               => multi,
          only_deletes        => 0 | 1,  # only_expunge_deletes
          flush               => 0 | 1,  # flush after optmization
          refresh             => 0 | 1,  # refresh after optmization
          wait_for_merge      => 1 | 0,  # wait for merge to finish
          max_num_segments    => int,    # number of segments to optimize to
          ignore_indices      => 'none' | 'missing',
      )
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-optimize.html>
  
  =head3 gateway_snapshot()
  
      $result = $es->gateway_snapshot(
          index           => multi,
          ignore_indices  => 'none' | 'missing',
      );
  
  Explicitly performs a snapshot through the gateway of one or more indices
  (backs them up ). By default, each index gateway periodically snapshot changes,
  though it can be disabled and be controlled completely through this API.
  
  Example:
  
      $result = $es->gateway_snapshot( index => 'twitter' );
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-gateway-snapshot.html>
  and L<http://www.elasticsearch.org/guide/reference/modules/gateway>
  
  =head3 snapshot_index()
  
  C<snapshot_index()> is a synonym for L</"gateway_snapshot()">
  
  =head3 clear_cache()
  
      $result = $es->clear_cache(
          index           => multi,
          bloom           => 0 | 1,
          field_data      => 0 | 1,
          filter          => 0 | 1,
          id              => 0 | 1,
          fields          => 'field1' | ['field1','fieldn',...],
          ignore_indices  => 'none' | 'missing',
      );
  
  Clears the caches for the specified indices. By default, clears all caches,
  but if any of C<id>, C<field>, C<field_data> or C<bloom> are true, then
  it clears just the specified caches.
  
  Throws a C<Missing> exception if the specified indices do not exist.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-clearcache.html>
  
  =cut
  
  =head2 Mapping methods
  
  =head3 put_mapping()
  
      $result = $es->put_mapping(
          index               => multi,
          type                => single,
          mapping             => { ... }      # required
          ignore_conflicts    => 0 | 1
      );
  
  A C<mapping> is the data definition of a C<type>.  If no mapping has been
  specified, then ElasticSearch tries to infer the types of each field in
  document, by looking at its contents, eg
  
      'foo'       => string
      123         => integer
      1.23        => float
  
  However, these heuristics can be confused, so it safer (and much more powerful)
  to specify an official C<mapping> instead, eg:
  
      $result = $es->put_mapping(
          index   => ['twitter','buzz'],
          type    => 'tweet',
          mapping => {
              _source => { compress => 1 },
              properties  =>  {
                  user        =>  {type  =>  "string", index      =>  "not_analyzed"},
                  message     =>  {type  =>  "string", null_value =>  "na"},
                  post_date   =>  {type  =>  "date"},
                  priority    =>  {type  =>  "integer"},
                  rank        =>  {type  =>  "float"}
              }
          }
      );
  
  See also: L<http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html>
  and L<http://www.elasticsearch.org/guide/reference/mapping>
  
  B<DEPRECATION>: C<put_mapping()> previously took the mapping parameters
  at the top level, eg C<< $es->put_mapping( properties=> { ... }) >>.
  This form still works, but is deprecated. Instead use the C<mapping>
  parameter.
  
  =head3 delete_mapping()
  
      $result = $es->delete_mapping(
          index           => multi_req,
          type            => single,
          ignore_missing  => 0 | 1,
      );
  
  Deletes a mapping/type in one or more indices.
  See also L<http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-mapping.html>
  
  Throws a C<Missing> exception if the indices or type don't exist and
  C<ignore_missing> is false.
  
  =head3 mapping()
  
      $mapping = $es->mapping(
          index       => single,
          type        => multi
      );
  
  Returns the mappings for all types in an index, or the mapping for the specified
  type(s), eg:
  
      $mapping = $es->mapping(
          index       => 'twitter',
          type        => 'tweet'
      );
  
      $mappings = $es->mapping(
          index       => 'twitter',
          type        => ['tweet','user']
      );
      # { twitter => { tweet => {mapping}, user => {mapping}} }
  
  Note: the index name which as used in the results is the actual index name. If
  you pass an alias name as the C<index> name, then this key will be the
  index (or indices) that the alias points to.
  
  See also: L<http://www.elasticsearch.org/guide/reference/api/admin-indices-get-mapping.html>
  
  =head3 type_exists()
  
      $result = $e->type_exists(
          index          => multi,             # optional
          type           => multi,             # required
          ignore_indices => 'none' | 'missing',
      );
  
  Returns C<< {ok => 1} >> if all specified types exist in all specified indices,
  or an empty list if they doesn't.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-indices-types-exists.html>
  
  
  =cut
  
  =head2 Warmer methods
  
  Index warming allow you to run typical search requests to "warm up"
  new segments before they become available for search.
  Warmup searches typically include requests that require heavy loading of
  data, such as faceting or sorting on specific fields.
  
  =head3 create_warmer()
  
      $es->create_warmer(
          warmer        => $warmer,
          index         => multi,
          type          => multi,
  
          # optional
  
          query         => { raw query }
        | queryb        => { search builder query },
  
          filter        => { raw filter }
        | filterb       => { search builder filter},
  
          facets        => { facets },
          script_fields => { script fields },
          sort          => { sort },
      );
  
  Create an index warmer called C<$warmer>: a search which is run whenever a
  matching C<index>/C<type> segment is about to be brought online.
  
  See L<https://github.com/elasticsearch/elasticsearch/issues/1913> for more.
  
  =head2 warmer()
  
      $result = $es->warmer(
          index          => multi,       # optional
          warmer         => $warmer,     # optional
  
          ignore_missing => 0 | 1
      );
  
  Returns any matching registered warmers. The C<$warmer> can be blank,
  the name of a particular warmer, or use wilcards, eg C<"warmer_*">. Throws
  an error if no matching warmer is found, and C<ignore_missing> is false.
  
  See L<https://github.com/elasticsearch/elasticsearch/issues/1913> for more.
  
  =head2 delete_warmer()
  
      $result = $es->delete_warmer(
          index          => multi,       # required
          warmer         => $warmer,     # required
  
          ignore_missing => 0 | 1
      );
  
  Deletes any matching registered warmers. The C<index> parameter is
  required and can be set to C<_all> to match all indices. The C<$warmer> can be
  the name of a particular warmer, or use wilcards, eg C<"warmer_*">
  or C<"*"> for any warmer. Throws an error if no matching warmer is found,
  and C<ignore_missing> is false.
  
  See L<https://github.com/elasticsearch/elasticsearch/issues/1913> for more.
  
  
  =head2 River admin methods
  
  See L<http://www.elasticsearch.org/guide/reference/river/>
  and L<http://www.elasticsearch.org/guide/reference/river/twitter.html>.
  
  =head3 create_river()
  
      $result = $es->create_river(
          river   => $river_name,     # required
          type    => $type,           # required
          $type   => {...},           # depends on river type
          index   => {...},           # depends on river type
      );
  
  Creates a new river with name C<$name>, eg:
  
      $result = $es->create_river(
          river   => 'my_twitter_river',
          type    => 'twitter',
          twitter => {
              user        => 'user',
              password    => 'password',
          },
          index   => {
              index       => 'my_twitter_index',
              type        => 'status',
              bulk_size   => 100
          }
      )
  
  =head3 get_river()
  
      $result = $es->get_river(
          river           => $river_name,
          ignore_missing  => 0 | 1        # optional
      );
  
  Returns the river details eg
  
      $result = $es->get_river ( river => 'my_twitter_river' )
  
  Throws a C<Missing> exception if the river doesn't exist and C<ignore_missing>
  is false.
  
  =head3 delete_river()
  
      $result = $es->delete_river( river => $river_name );
  
  Deletes the corresponding river, eg:
  
      $result = $es->delete_river ( river => 'my_twitter_river' )
  
  See L<http://www.elasticsearch.org/guide/reference/river/>.
  
  =head3 river_status()
  
      $result = $es->river_status(
          river           => $river_name,
          ignore_missing  => 0 | 1        # optional
      );
  
  Returns the status doc for the named river.
  
  Throws a C<Missing> exception if the river doesn't exist and C<ignore_missing>
  is false.
  
  =cut
  
  =head2 Percolate methods
  
  See also: L<http://www.elasticsearch.org/guide/reference/api/percolate.html>
  and L<http://www.elasticsearch.org/blog/2011/02/08/percolator.html>
  
  =head3 create_percolator()
  
      $es->create_percolator(
          index           =>  single
          percolator      =>  $percolator
  
          # one of queryb or query is required
          query           =>  { native query }
          queryb          =>  { search builder query }
  
          # optional
          data            =>  {data}
      )
  
  Create a percolator, eg:
  
      $es->create_percolator(
          index           => 'myindex',
          percolator      => 'mypercolator',
          queryb          => { field => 'foo'  },
          data            => { color => 'blue' }
      )
  
  Note: C<create_percolator()> supports L<ElasticSearch::SearchBuilder>-style
  queries via the C<queryb> parameter.  See
  L</"INTEGRATION WITH ElasticSearch::SearchBuilder"> for more details.
  
  =head3 get_percolator()
  
      $es->get_percolator(
          index           =>  single
          percolator      =>  $percolator,
          ignore_missing  =>  0 | 1,
      )
  
  Retrieves a percolator, eg:
  
      $es->get_percolator(
          index           => 'myindex',
          percolator      => 'mypercolator',
      )
  
  Throws a C<Missing> exception if the specified index or percolator does not exist,
  and C<ignore_missing> is false.
  
  =head3 delete_percolator()
  
      $es->delete_percolator(
          index           =>  single
          percolator      =>  $percolator,
          ignore_missing  =>  0 | 1,
      )
  
  Deletes a percolator, eg:
  
      $es->delete_percolator(
          index           => 'myindex',
          percolator      => 'mypercolator',
      )
  
  Throws a C<Missing> exception if the specified index or percolator does not exist,
  and C<ignore_missing> is false.
  
  =head3 percolate()
  
      $result = $es->percolate(
          index           => single,
          type            => single,
          doc             => { doc to percolate },
  
          # optional
          query           => { query to filter percolators },
          prefer_local    => 1 | 0,
      )
  
  Check for any percolators which match a document, optionally filtering
  which percolators could match by passing a C<query> param, for instance:
  
      $result = $es->percolate(
          index           => 'myindex',
          type            => 'mytype',
          doc             => { text => 'foo' },
          query           => { term => { color => 'blue' }}
      );
  
  Returns:
  
      {
          ok      => 1,
          matches => ['mypercolator']
      }
  
  =cut
  
  =head2 Cluster admin methods
  
  =head3 cluster_state()
  
      $result = $es->cluster_state(
           # optional
           filter_blocks          => 0 | 1,
           filter_nodes           => 0 | 1,
           filter_metadata        => 0 | 1,
           filter_routing_table   => 0 | 1,
           filter_indices         => [ 'index_1', ... 'index_n' ],
      );
  
  Returns cluster state information.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-state.html>
  
  =head3 cluster_health()
  
      $result = $es->cluster_health(
          index                         => multi,
          level                         => 'cluster' | 'indices' | 'shards',
          timeout                       => $seconds
          wait_for_status               => 'red' | 'yellow' | 'green',
          | wait_for_relocating_shards  => $number_of_shards,
          | wait_for_nodes              => eg '>=2',
      );
  
  Returns the status of the cluster, or index|indices or shards, where the
  returned status means:
  
  =over
  
  =item C<red>: Data not allocated
  
  =item C<yellow>: Primary shard allocated
  
  =item C<green>: All shards allocated
  
  =back
  
  It can block to wait for a particular status (or better), or can block to
  wait until the specified number of shards have been relocated (where 0 means
  all) or the specified number of nodes have been allocated.
  
  If waiting, then a timeout can be specified.
  
  For example:
  
      $result = $es->cluster_health( wait_for_status => 'green', timeout => '10s')
  
  See: L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-health.html>
  
  =head3 cluster_settings()
  
      $result = $es->cluster_settings()
  
  Returns any cluster wide settings that have been set with
  L</"update_cluster_settings">.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-update-settings.html>
  
  
  =head3 update_cluster_settings()
  
      $result = $es->update_cluster_settings(
          persistent  => {...},
          transient   => {...},
      )
  
  For example:
  
      $result = $es->update_cluster_settings(
          persistent  => {
              "discovery.zen.minimum_master_nodes" => 2
          },
      )
  
  C<persistent> settings will survive a full cluster restart. C<transient>
  settings won't.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-update-settings.html>
  
  =head3 nodes()
  
      $result = $es->nodes(
          nodes       => multi,
          settings    => 0 | 1,
          http        => 0 | 1,
          jvm         => 0 | 1,
          network     => 0 | 1,
          os          => 0 | 1,
          process     => 0 | 1,
          thread_pool => 0 | 1,
          transport   => 0 | 1
      );
  
  Returns information about one or more nodes or servers in the cluster.
  
  See: L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-nodes-info.html>
  
  =head3 nodes_stats()
  
      $result = $es->nodes_stats(
          node    => multi,
  
          indices     => 1 | 0,
          clear       => 0 | 1,
          all         => 0 | 1,
          fs          => 0 | 1,
          http        => 0 | 1,
          jvm         => 0 | 1,
          network     => 0 | 1,
          os          => 0 | 1,
          process     => 0 | 1,
          thread_pool => 0 | 1,
          transport   => 0 | 1,
  
      );
  
  Returns various statistics about one or more nodes in the cluster.
  
  See: L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-nodes-stats.html>
  
  =head3 cluster_reroute()
  
      $result = $es->cluster_reroute(
          commands => [
              { move => {
                    index     => 'test',
                    shard     => 0,
                    from_node => 'node1',
                    to_node   => 'node2',
              }},
              { allocate => {
                    index         => 'test',
                    shard         => 1,
                    node          => 'node3',
                    allow_primary => 0 | 1
              }},
              { cancel => {
                    index         => 'test',
                    shard         => 2,
                    node          => 'node4',
                    allow_primary => 0 | 1
              }},
          ],
          dry_run  => 0 | 1
      );
  
  The L</cluster_reroute> command allows you to explicitly affect shard allocation
  within a cluster. For example, a shard can be moved from one node to another,
  an allocation can be cancelled, or an unassigned shard can be explicitly
  allocated on a specific node.
  
  B<NOTE:> after executing the commands, the cluster will automatically
  rebalance itself if it is out of balance.  Use the C<dry_run> parameter
  to see what the final outcome will be after automatic rebalancing, before
  executing the real L</cluster_reroute> call.
  
  Without any C<\@commands>, the current cluster routing will be returned.
  
  See L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-reroute.html>
  
  =head3 shutdown()
  
      $result = $es->shutdown(
          node        => multi,
          delay       => '5s' | '10m'        # optional
      );
  
  
  Shuts down one or more nodes (or the whole cluster if no nodes specified),
  optionally with a delay.
  
  C<node> can also have the values C<_local>, C<_master> or C<_all>.
  
  See: L<http://www.elasticsearch.org/guide/reference/api/admin-cluster-nodes-shutdown.html>
  
  =head3 restart()
  
      $result = $es->restart(
          node        => multi,
          delay       => '5s' | '10m'        # optional
      );
  
  
  Restarts one or more nodes (or the whole cluster if no nodes specified),
  optionally with a delay.
  
  C<node> can also have the values C<_local>, C<_master> or C<_all>.
  
  See: L</"KNOWN ISSUES">
  
  =head3 current_server_version()
  
      $version = $es->current_server_version()
  
  Returns a HASH containing the version C<number> string and
  whether or not the current server is a C<snapshot_build>.
  
  =cut
  
  =head2 Other methods
  
  =head3 use_index()/use_type()
  
  C<use_index()> and C<use_type()> can be used to set default values for
  any C<index> or C<type> parameter. The default value can be overridden
  by passing a parameter (including C<undef>) to any request.
  
      $es->use_index('one');
      $es->use_type(['foo','bar']);
  
      $es->index(                         # index: one, types: foo,bar
          data=>{ text => 'my text' }
      );
  
      $es->index(                         # index: two, type: foo,bar
          index=>'two',
          data=>{ text => 'my text' }
      )
  
      $es->search( type => undef );       # index: one, type: all
  
  =head3 trace_calls()
  
      $es->trace_calls(1);            # log to STDERR
      $es->trace_calls($filename);    # log to $filename.$PID
      $es->trace_calls(\*STDOUT);     # log to STDOUT
      $es->trace_calls($fh);          # log to given filehandle
      $es->trace_calls(0 | undef);    # disable logging
  
  C<trace_calls()> is used for debugging.  All requests to the cluster
  are logged either to C<STDERR>, or the specified filehandle,
  or the specified filename, with the
  current C<$PID> appended, in a form that can be rerun with curl.
  
  The cluster response will also be logged, and commented out.
  
  Example: C<< $es->cluster_health >> is logged as:
  
      # [Tue Oct 19 15:32:31 2010] Protocol: http, Server: 127.0.0.1:9200
      curl -XGET 'http://127.0.0.1:9200/_cluster/health'
  
      # [Tue Oct 19 15:32:31 2010] Response:
      # {
      #    "relocating_shards" : 0,
      #    "active_shards" : 0,
      #    "status" : "green",
      #    "cluster_name" : "elasticsearch",
      #    "active_primary_shards" : 0,
      #    "timed_out" : false,
      #    "initializing_shards" : 0,
      #    "number_of_nodes" : 1,
      #    "unassigned_shards" : 0
      # }
  
  =head3 query_parser()
  
      $qp = $es->query_parser(%opts);
  
  Returns an L<ElasticSearch::QueryParser> object for tidying up
  query strings so that they won't cause an error when passed to ElasticSearch.
  
  See L<ElasticSearch::QueryParser> for more information.
  
  =head3 transport()
  
      $transport = $es->transport
  
  Returns the Transport object, eg L<ElasticSearch::Transport::HTTP>.
  
  =head3 timeout()
  
      $timeout = $es->timeout($timeout)
  
  Convenience method which does the same as:
  
     $es->transport->timeout($timeout)
  
  =head3 refresh_servers()
  
      $es->refresh_servers()
  
  Convenience method which does the same as:
  
      $es->transport->refresh_servers()
  
  This tries to retrieve a list of all known live servers in the ElasticSearch
  cluster by connecting to each of the last known live servers (and the initial
  list of servers passed to C<new()>) until it succeeds.
  
  This list of live servers is then used in a round-robin fashion.
  
  C<refresh_servers()> is called on the first request and every C<max_requests>.
  This automatic refresh can be disabled by setting C<max_requests> to C<0>:
  
      $es->transport->max_requests(0)
  
  Or:
  
      $es = ElasticSearch->new(
              servers         => '127.0.0.1:9200',
              max_requests    => 0,
      );
  
  =head3 builder_class() | builder()
  
  The C<builder_class> is set to L<ElasticSearch::SearchBuilder> by default.
  This can be changed, eg:
  
      $es = ElasticSearch->new(
              servers         => '127.0.0.1:9200',
              builder_class   => 'My::Builder'
      );
  
  C<builder()> will C<require> the module set in C<builder_class()>, create
  an instance, and store that instance for future use.  The C<builder_class>
  should implement the C<filter()> and C<query()> methods.
  
  =head3 camel_case()
  
      $bool = $es->camel_case($bool)
  
  Gets/sets the camel_case flag. If true, then all JSON keys returned by
  ElasticSearch are in camelCase, instead of with_underscores.  This flag
  does not apply to the source document being indexed or fetched.
  
  Defaults to false.
  
  =head3 error_trace()
  
      $bool = $es->error_trace($bool)
  
  If the ElasticSearch server is returning an error, setting C<error_trace>
  to true will return some internal information about where the error originates.
  Mostly useful for debugging.
  
  =cut
  
  =head2 GLOBAL VARIABLES
  
      $Elasticsearch::DEBUG = 0 | 1;
  
  If C<$Elasticsearch::DEBUG> is set to true, then ElasticSearch exceptions
  will include a stack trace.
  
  =cut
  
  =head1 AUTHOR
  
  Clinton Gormley, C<< <drtech at cpan.org> >>
  
  =head1 KNOWN ISSUES
  
  =over
  
  =item   L</"get()">
  
  The C<_source> key that is returned from a L</"get()"> contains the original JSON
  string that was used to index the document initially.  ElasticSearch parses
  JSON more leniently than L<JSON::XS>, so if invalid JSON is used to index the
  document (eg unquoted keys) then C<< $es->get(....) >> will fail with a
  JSON exception.
  
  Any documents indexed via this module will be not susceptible to this problem.
  
  =item L</"restart()">
  
  C<restart()> is currently disabled in ElasticSearch as it doesn't work
  correctly.  Instead you can L</"shutdown()"> one or all nodes and then
  start them up from the command line.
  
  =back
  
  =head1 BUGS
  
  This is a stable AP - but it will evolve as the API of ElasticSearch itself
  changes.
  
  If you have any suggestions for improvements, or find any bugs, please report
  them to L<http://github.com/clintongormley/ElasticSearch.pm/issues>.
  I will be notified, and then you'll automatically be notified of progress on
  your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc ElasticSearch
  
  You can also look for information at:
  
  =over 4
  
  =item * GitHub
  
  L<http://github.com/clintongormley/ElasticSearch.pm>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/ElasticSearch>
  
  =item * Search MetaCPAN
  
  L<https://metacpan.org/module/ElasticSearch>
  
  =item * IRC
  
  The L<#elasticsearch|irc://irc.freenode.net/elasticsearch> channel on
  C<irc.freenode.net>.
  
  =item * Mailing list
  
  The main L<ElasticSearch mailing list|http://www.elasticsearch.org/community/forum/>.
  
  =back
  
  =head1 TEST SUITE
  
  The full test suite requires a live ElasticSearch cluster to run.  CPAN
  testers doesn't support this.  You can see full test results here:
  L<http://travis-ci.org/#!/clintongormley/ElasticSearch/builds>.
  
  To run the full test suite locally, run it as:
  
      perl Makefile.PL
      ES_HOME=/path/to/elasticsearch make test
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Shay Banon, the ElasticSearch author, for producing an amazingly
  easy to use search engine.
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
ELASTICSEARCH

$fatpacked{"ElasticSearch/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_ERROR';
  package ElasticSearch::Error;
  $ElasticSearch::Error::VERSION = '0.68';
  @ElasticSearch::Error::Internal::ISA       = __PACKAGE__;
  @ElasticSearch::Error::Param::ISA          = __PACKAGE__;
  @ElasticSearch::Error::NoServers::ISA      = __PACKAGE__;
  @ElasticSearch::Error::ClusterBlocked::ISA = __PACKAGE__;
  @ElasticSearch::Error::Request::ISA        = __PACKAGE__;
  @ElasticSearch::Error::Timeout::ISA        = __PACKAGE__;
  @ElasticSearch::Error::Connection::ISA     = __PACKAGE__;
  @ElasticSearch::Error::JSON::ISA           = __PACKAGE__;
  @ElasticSearch::Error::QueryParser::ISA    = __PACKAGE__;
  @ElasticSearch::Error::Conflict::ISA
      = ( 'ElasticSearch::Error::Request', __PACKAGE__ );
  @ElasticSearch::Error::Missing::ISA
      = ( 'ElasticSearch::Error::Request', __PACKAGE__ );
  
  @ElasticSearch::Error::NotReady::ISA
      = ( 'ElasticSearch::Error::Connection', __PACKAGE__ );
  
  use strict;
  use warnings FATAL => 'all', NONFATAL => 'redefine';
  
  use overload (
      '""'  => 'stringify',
      'cmp' => 'compare',
  );
  use Data::Dumper;
  
  #===================================
  sub stringify {
  #===================================
      my $error = shift;
      local $Data::Dumper::Terse  = 1;
      local $Data::Dumper::Indent = 1;
  
      my $msg
          = '[ERROR] ** '
          . ( ref($error) || 'ElasticSearch::Error' ) . ' at '
          . $error->{-file}
          . ' line '
          . $error->{-line} . " : \n"
          . ( $error->{-text} || 'Missing error message' ) . "\n"
          . (
          $error->{-vars}
          ? "\nWith vars:" . Dumper( $error->{-vars} ) . "\n"
          : ''
          ) . ( $error->{'-stacktrace'} || '' );
      return $msg;
  }
  
  #===================================
  sub compare {
  #===================================
      my ( $error, $other, $swap ) = @_;
      $error .= '';
      ( $error, $other ) = ( $other, $error ) if $swap;
      return $error cmp $other;
  }
  
  =head1 NAME
  
  ElasticSearch::Error - Exception objects for ElasticSearch
  
  =head1 DESCRIPTION
  
  ElasticSearch::Error is a base class for exceptions thrown by any ElasticSearch
  code.
  
  There are several exception subclasses, which indicate different types of error.
  All of them inherit from L<ElasticSearch::Error>, and all include:
  
      $error->{-text}         # error message
      $error->{-file}         # file where error was thrown
      $error->{-line}         # line where error was thrown
  
  They may also include:
  
      $error->{-vars}         # Any relevant variables related to the error
      $error->{-stacktrace}   # A stacktrace, if $ElasticSearch::DEBUG == 1
  
  Error objects can be stringified, and include all of the above information
  in the string output.
  
  =head1 EXCEPTION CLASSES
  
  =over
  
  =item * ElasticSearch::Error::Param
  
  An incorrect parameter was passed in
  
  =item * ElasticSearch::Error::Timeout
  
  The request timed out
  
  =item * ElasticSearch::Error::Connection
  
  There was an error connecting to the current node. The request will be
  retried on another node.
  
  =item * ElasticSearch::Error::NotReady
  
  The current node is not yet able to serve requests. The request will be
  retried on another node. C<ElasticSearch::Error::NotReady> inherits from
  C<ElasticSearch::Error::Connection>.
  
  =item * ElasticSearch::Error::ClusterBlocked
  
  The cluster was unable to process the request because it is currently blocking,
  eg the requested index is closed.
  
  =item * ElasticSearch::Error::Request
  
  There was some other error performing the request
  
  =item * ElasticSearch::Error::Conflict
  
  There was a versioning conflict while performing an index/create/delete
  operation.  C<ElasticSearch::Error::Conflict> inherits from
  C<ElasticSearch::Error::Request>.
  
  The lastest version number is available as:
  
      $error->{-vars}{current_version};
  
  =item * ElasticSearch::Error::Missing
  
  Tried to get/delete a document or index that doesn't exist.
  C<ElasticSearch::Error::Missing> inherits from
  C<ElasticSearch::Error::Request>.
  
  =item * ElasticSearch::Error::NoServers
  
  No servers are available
  
  =item * ElasticSearch::Error::JSON
  
  There was an error parsing a JSON doc
  
  =item * ElasticSearch::Error::Internal
  
  An internal error - you shouldn't see these
  
  =back
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
  
ELASTICSEARCH_ERROR

$fatpacked{"ElasticSearch/QueryParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_QUERYPARSER';
  package ElasticSearch::QueryParser;
  $ElasticSearch::QueryParser::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use ElasticSearch::Util qw(parse_params throw build_error);
  use Scalar::Util qw(weaken);
  
  =head1 NAME
  
  ElasticSearch::QueryParser - Check or filter query strings
  
  =head1 DESCRIPTION
  
  Passing an illegal query string to ElasticSearch, the request will fail.
  When using a query string from an external source, eg the keywords field
  from a web search form, it is important to filter it to avoid these
  failures.
  
  You may also want to allow or disallow certain query string features, eg
  the ability to search on a particular field.
  
  The L<ElasticSearch::QueryParser> takes care of this for you.
  
  See L<http://lucene.apache.org/java/3_0_3/queryparsersyntax.html>
  for more information about the Lucene Query String syntax, and
  L<http://www.elasticsearch.org/guide/reference/query-dsl/query-string-query.html#Syntax_Extension>
  for custom ElasticSearch extensions to the query string syntax.
  
  =head1 SYNOPSIS
  
      use ElasticSearch;
      my $es = ElasticSearch->new(servers=>'127.0.0.1:9200');
      my $qp = $es->query_parser(%opts);
  
      my $filtered_query_string = $qp->filter($unchecked_query_string)
  
      my $results = $es->search( query=> {
                        query_string=>{ query => $filtered_query_string }
                    });
  
  For example:
  
      my $qs = 'foo NOT AND -bar - baz * foo* secret_field:SIKRIT "quote';
  
      print $qp->filter($qs);
      # foo AND -bar baz foo* "quote"
  
  =head1 METHODS
  
  =head2 new()
  
      my $qp = ElasticSearch::QueryParser->new(%opts);
      my $qp = $es->query_parser(%opts);
  
  Creates a new L<ElasticSearch::QueryParser> object, and sets the passed in
  options (see L</"OPTIONS">).
  
  =head2 filter()
  
      $filtered_query_string = $qp->filter($unchecked_query_string, %opts)
  
  Checks a passed in query string and returns a filtered version which is
  suitable to pass to ElasticSearch.
  
  Note: C<filter()> can still return an empty string, which is not considered
  a valid query string, so you should still check for that before passing
  to ElasticSearch.
  
  If any C<%opts> are passed in to C<filter()>, these are added to the default
  C<%opts> as set by L</"new()">, and apply only for the current run.
  
  L</"filter()"> does not promise to parse the query string in exactly
  the same way as Lucene, just to clear it up so that it won't throw an
  error when passed to ElasticSearch.
  
  =head2 check()
  
      $filtered_query_string = $qp->check($unchecked_query_string, %opts)
  
  Checks a passed in query string and throws an error if it is not valid.
  This is useful for debugging your own query strings.
  
  If any C<%opts> are passed in to C<check()>, these are added to the default
  C<%opts> as set by L</"new()">, and apply only for the current run.
  
  
  =head1 OPTIONS
  
  You can set various options to control how your query strings are filtered.
  
  The defaults (if no options are passed in) are:
  
      escape_reserved => 0
      fields          => 0
      boost           => 1
      allow_bool      => 1
      allow_boost     => 1
      allow_fuzzy     => 1
      allow_slop      => 1
      allow_ranges    => 0
      wildcard_prefix => 1
  
  Any options passed in to L</"new()"> are merged with these defaults. These
  options apply for the life of the QueryParser instance.
  
  Any options passed in to L</"filter()"> or L</"check()"> are merged with
  the options set in L</"new()"> and apply only for the current run.
  
  For instance:
  
      $qp = ElasticSearch::QueryParser->new(allow_fuzzy => 0);
  
      $qs = "foo~0.5 bar^2 foo:baz";
  
      print $qp->filter($qs, allow_fuzzy => 1, allow_boost => 0);
      # foo~0.5 bar baz
  
      print $qp->filter($qs, fields => 1 );
      # foo bar^2 foo:baz
  
  =head2 escape_reserved
  
  Reserved characters must be escaped to be used in the query string. By default,
  L</"filter()"> will remove these characters. Set C<escape_reserved> to true
  if you want them to be escaped instead.
  
  Reserved characters: C< + - && || ! ( ) { } [ ] ^ " ~ * ? : \>
  
  
  =head2 fields
  
  Normally, you don't want to allow your users to specify which fields to
  search.  By default, L</"filter()"> removes any field prefixes, eg:
  
      $qp->filter('foo:bar secret_field:SIKRIT')
      # bar SIKRIT
  
  You can set C<fields> to C<1> to allow all fields, or pass in a hashref
  with a list of approved fieldnames, eg:
  
      $qp->filter('foo:bar secret_field:SIKRIT', fields => 1);
      # foo:bar secret_field:SIKRIT
  
      $qp->filter('foo:bar secret_field:SIKRIT', fields => {foo => 1});
      # foo:bar SIKRIT
  
  ElasticSearch extends the standard Lucene syntax to include:
  
      _exists_:fieldname
    and
      _missing_:fieldname
  
  The C<fields> option applies to these fieldnames as well.
  
  =head2 allow_bool
  
  Query strings can use boolean operators like:
  
      foo AND bar NOT baz OR ! (foo && bar)
  
  By default, boolean operators are allowed.  Set C<allow_bool> to C<false>
  to disable them.
  
  Note: This doesn't affect the C<+> or C<-> operators, which are always
  allowed. eg:
  
      +apple -crab
  
  =head2 allow_boost
  
  Boost allows you to give a more importance to a particular word, group
  of words or phrase, eg:
  
      foo^2  (bar baz)^3  "this exact phrase"^5
  
  By default, boost is enabled.  Setting C<allow_boost> to C<false> would convert
  the above example to:
  
      foo (bar baz) "this exact phrase"
  
  =head2 allow_fuzzy
  
  Lucene supports fuzzy searches based on the Levenshtein Distance, eg:
  
      supercalifragilisticexpialidocious~0.5
  
  To disable these, set C<allow_fuzzy> to false.
  
  =head2 allow_slop
  
  While a C<phrase search> (eg C<"this exact phrase">) looks for the exact
  phrase, in the same order, you can use phrase slop to find all the words in
  the phrase, in any order, within a certain number of words, eg:
  
      For the phrase: "The quick brown fox jumped over the lazy dog."
  
      Query string:               Matches:
      "quick brown"               Yes
      "brown quick"               No
      "quick fox"                 No
      "brown quick"~2             Yes  # within 2 words of each other
      "fox dog"~6                 Yes  # within 6 words of each other
  
  To disable this "phrase slop", set C<allow_slop> to C<false>
  
  =head2 allow_ranges
  
  Lucene can accept ranges, eg:
  
      date:[2001 TO 2010]   name:[alan TO john]
  
  To enable these, set C<allow_ranges> to C<true>.
  
  =head2 wildcard_prefix
  
  Lucene can accept wildcard searches such as:
  
      jo*n  smith?
  
  Lucene takes these wildcards and expands the search to include all matching
  terms, eg C<jo*n> could be expanded to C<jon>, C<john>, C<jonathan> etc
  
  This can result in a huge number of terms, so it is advisable to require
  that the first C<$min> characters of the word are not wildcards.
  
  By default, the C<wildcard_prefix> requires that at least the first character
  is not a wildcard, ie C<*> is not acceptable, but C<s*> is.
  
  You can change the minimum length of the non-wildcard prefix by setting
  C<wildcard_prefix>, eg:
  
      $qp->filter("foo* foobar*", wildcard_prefix=>4)
      # "foo foobar*"
  
  =cut
  
  #===================================
  sub new {
  #===================================
      my ( $proto, $params ) = parse_params(@_);
      my $class = ref $proto || $proto;
      $params = {
          escape_reserved => 0,
          fields          => 0,
          wildcard_prefix => 1,
          allow_bool      => 1,
          allow_boost     => 1,
          allow_fuzzy     => 1,
          allow_slop      => 1,
          allow_ranges    => 0,
          %$params,
      };
      return bless {
          _default_opts => $params,
          _opts         => $params,
      }, $class;
  }
  
  #===================================
  sub filter {
  #===================================
      my $self = shift;
      my $text = shift;
      my ( undef, $opts ) = parse_params( $self, @_ );
      $opts->{fix} = 1;
      return $self->_parse( $text, $opts );
  }
  
  #===================================
  sub check {
  #===================================
      my $self = shift;
      my $text = shift;
      my ( undef, $opts ) = parse_params( $self, @_ );
      $opts->{fix} = 0;
      return $self->_parse( $text, $opts );
  }
  
  #===================================
  sub _parse {
  #===================================
      my $self = shift;
      my $text = shift;
      $text = '' unless defined $text;
      utf8::upgrade($text);
  
      my $opts = shift;
      $self->{_opts} = { %{ $self->{_default_opts} }, %$opts };
  
      $self->{_tokeniser} = $self->_init_tokeniser($text);
      $self->{_tokens}    = [];
      $self->{_stack}     = [ {} ];
      $self->{_start_pos} = 0;
      $self->{_done}      = 0;
  
      my $phrase;
      eval {
          $phrase = $self->_multi_clauses;
          die "Syntax error\n"
              unless $self->{_done} || $opts->{fix};
      };
      if ($@) {
          $@ =~ s/\n$/:\n/;
          substr( $text, $self->{_start_pos}, 0, ' <HERE> ' );
          $self->throw( 'QueryParser', "$@$text" );
      }
      return $phrase;
  }
  
  #===================================
  sub _dump_tokens {
  #===================================
      my $self = shift;
      my $text = shift;
      $text = '' unless defined $text;
      utf8::upgrade($text);
  
      my $tokeniser = $self->_init_tokeniser($text);
  
      while ( my $next = $tokeniser->() ) {
          printf "TOKEN: %-15s VARS: %s\n", shift @$next,
              join( ', ', grep { defined $_ } @$next );
      }
  }
  
  #===================================
  sub _next_token {
  #===================================
      my $self = shift;
      my $next = shift @{ $self->{_tokens} }
          || $self->{_tokeniser}->();
      return $next if $next;
      $self->{_done} = 1;
      return;
  }
  
  #===================================
  sub _return_token {
  #===================================
      my $self = shift;
      push @{ $self->{_tokens} }, shift;
      $self->{_done} = 0;
  }
  
  # 1     = Can follow
  # 0     = Cannot follow, drop token and try next token
  # undef = Cannot follow, stop looking
  
  my %Clauses = (
      _LPAREN     => 1,
      _PLUS_MINUS => 1,
      _EXISTS     => 1,
      _FIELD      => 1,
      _TERM       => 1,
      _PHRASE     => 1,
      _WILDTERM   => 1,
      _RANGE      => 1,
      _NOT        => 1,
      _AND_OR     => 1,
      _SPACE      => 1,
      _RESERVED   => 1,
      _ESCAPE     => 1,
  );
  
  my %Boost = ( _BOOST => 1 );
  
  my %Allowed = (
      _CLAUSE     => \%Clauses,
      _LPAREN     => { %Clauses, _RPAREN => 1 },
      _AND_OR     => { %Clauses, _AND_OR => 0 },
      _NOT        => { %Clauses, _NOT => 0, _AND_OR => 0 },
      _PLUS_MINUS => {
          %Clauses,
          _NOT        => 0,
          _AND_OR     => 0,
          _PLUS_MINUS => 0,
          _SPACE      => undef,
      },
      _FIELD => {
          _LPAREN   => 1,
          _TERM     => 1,
          _WILDTERM => 1,
          _PHRASE   => 1,
          _RANGE    => 1,
      },
      _PHRASE   => { _BOOST => 1, _FUZZY => 1 },
      _TERM     => { _BOOST => 1, _FUZZY => 1 },
      _WILDTERM => \%Boost,
      _RANGE    => \%Boost,
      _FUZZY    => \%Boost,
      _RPAREN   => \%Boost,
      _EXISTS   => \%Boost,
      _BOOST    => {},
      _SPACE    => {},
      _RESERVED => {},
      _ESCAPE   => {},
  );
  
  #===================================
  sub _parse_context {
  #===================================
      my $self    = shift;
      my $context = shift;
      my $allowed = $Allowed{$context};
  
  TOKEN: {
          my $token = $self->_next_token or return;
  
          my ( $type, @args ) = @$token;
          if ( $allowed->{$type} ) {
              redo TOKEN if $type eq '_SPACE';
              return $self->$type(@args);
          }
          elsif ( defined $allowed->{$type} ) {
              die "Syntax error\n" unless $self->{_opts}{fix};
              redo TOKEN;
          }
          else {
              $self->_return_token($token);
              return undef;
          }
      }
  }
  
  #===================================
  sub _multi_clauses {
  #===================================
      my $self = shift;
      my @clauses;
      while (1) {
          my $clause = $self->_parse_context('_CLAUSE');
          if ( !defined $clause ) {
              last
                  if @{ $self->{_stack} } > 1
                  || !$self->{_opts}{fix}
                  || $self->{_done};
              $self->_next_token;
              next;
          }
          next unless length $clause;
          push @clauses, $clause;
          $self->{_stack}[-1]{clauses}++;
      }
      return join( ' ', @clauses );
  }
  
  #===================================
  sub _AND_OR {
  #===================================
      my $self = shift;
      my $op   = shift;
      my $opts = $self->{_opts};
  
      unless ( $self->{_stack}[-1]{clauses} ) {
          return '' if $opts->{fix};
          die "$op must be preceded by another clause\n";
      }
      unless ( $opts->{allow_bool} ) {
          die qq("$op" not allowed) unless $opts->{fix};
          return '';
      }
  
      my $next = $self->_parse_context('_AND_OR');
      return "$op $next"
          if defined $next && length $next;
  
      return '' if $opts->{fix};
      die "$op must be followed by a clause\n";
  }
  
  #===================================
  sub _NOT {
  #===================================
      my $self = shift;
      my $op   = shift;
  
      my $opts = $self->{_opts};
      unless ( $opts->{allow_bool} ) {
          die qq("$op" not allowed) unless $opts->{fix};
          return '';
      }
  
      my $next = $self->_parse_context('_NOT');
      $next = '' unless defined $next;
  
      die "$op cannot be followed by + or -"
          if $next =~ s/^[+-]+// && !$opts->{fix};
  
      return "$op $next"
          if length $next;
  
      return '' if $opts->{fix};
      die "$op must be followed by a clause\n";
  }
  
  #===================================
  sub _PLUS_MINUS {
  #===================================
      my $self = shift;
      my $op   = shift;
      my $next = $self->_parse_context('_PLUS_MINUS');
  
      return "$op$next" if defined $next && length $next;
  
      return '' if $self->{_opts}{fix};
      die "$op must be followed by a clause";
  }
  
  #===================================
  sub _LPAREN {
  #===================================
      my $self = shift;
      push @{ $self->{_stack} }, {};
      my $clause = $self->_multi_clauses;
  
      my $close  = ')';
      my $rparen = $self->_next_token;
      if ( $rparen && $rparen->[0] eq '_RPAREN' ) {
          my $next = $self->_parse_context('_RPAREN') || '';
          $close .= $next if $next;
          pop @{ $self->{_stack} };
      }
      elsif ( $self->{_opts}{fix} ) {
          $self->_return_token($rparen);
      }
      else {
          die "Missing closing parenthesis\n";
      }
      return $clause ? "(${clause}${close}" : '';
  }
  
  #===================================
  sub _BOOST {
  #===================================
      my $self = shift;
      unless ( $self->{_opts}{allow_boost} ) {
          die "Boost not allowed" unless $self->{_opts}{fix};
          return '';
      }
      my $val = shift;
      unless ( defined $val && length $val ) {
          return '' if $self->{_opts}{fix};
          die "Missing boost value\n";
      }
      return "^$val";
  }
  
  #===================================
  sub _FUZZY {
  #===================================
      my $self  = shift;
      my $fuzzy = shift;
      my $opts  = $self->{_opts};
      my $fix   = $opts->{fix};
  
      if ( $self->{current} eq '_PHRASE' ) {
  
          # phrase slop
          if ( $opts->{allow_slop} ) {
              $fuzzy = int( $fuzzy || 0 );
              $fuzzy = $fuzzy ? "~$fuzzy" : '';
          }
          else {
              die "Phrase slop not allowed\n" unless $fix;
              $fuzzy = '';
          }
      }
      else {
  
          # fuzzy
          if ( $opts->{allow_fuzzy} ) {
              if ( defined $fuzzy ) {
                  if ( $fuzzy <= 1 ) {
                      $fuzzy = "~$fuzzy";
                  }
                  else {
                      die "Fuzzy value must be between 0.0 and 1.0\n"
                          unless $fix;
                      $fuzzy = '';
                  }
              }
              else {
                  $fuzzy = '~';
              }
          }
          else {
              die "Fuzzy not allowed\n"
                  unless $fix;
              $fuzzy = '';
          }
      }
  
      my $next = $self->_parse_context('_FUZZY') || '';
      return "$fuzzy$next";
  }
  
  #===================================
  sub _PHRASE {
  #===================================
      my $self   = shift;
      my $string = shift;
  
      local $self->{current} = '_PHRASE';
      my $next = $self->_parse_context('_PHRASE') || '';
  
      return qq("$string"$next);
  }
  
  #===================================
  sub _EXISTS {
  #===================================
      my $self   = shift;
      my $prefix = shift;
      my $field  = shift;
  
      my $opts = $self->{_opts};
      my $next = $self->_parse_context('_EXISTS') || '';
      unless ( $opts->{fields}
          and ( !ref $opts->{fields} || $opts->{fields}{$field} ) )
      {
          return '' if $opts->{fix};
          die qq("Field "$field" not allowed);
      }
  
      return "$prefix:$field$next"
          if $field;
      return '' if $self->{_opts}{fix};
      die "Missing field name for $prefix\n";
  }
  
  #===================================
  sub _FIELD {
  #===================================
      my $self  = shift;
      my $field = shift;
  
      my $opts = $self->{_opts};
      my $next = $self->_parse_context('_FIELD');
  
      unless ( defined $next && length $next ) {
          die "Missing clause after field $field\n"
              unless $opts->{fix};
          return '';
      }
  
      return "$field:$next"
          if $opts->{fields}
          and !ref $opts->{fields} || $opts->{fields}{$field};
  
      die qq("Field "$field" not allowed)
          unless $opts->{fix};
  
      return $next;
  }
  
  #===================================
  sub _TERM {
  #===================================
      my $self = shift;
      local $self->{current} = '_TERM';
      my $next = $self->_parse_context('_TERM') || '';
      return shift(@_) . $next;
  }
  
  #===================================
  sub _WILDTERM {
  #===================================
      my $self = shift;
      my $term = shift;
      my $min  = $self->{_opts}{wildcard_prefix};
      my $next = $self->_parse_context('_WILDTERM') || '';
      if ( $term !~ /^[^*?]{$min}/ ) {
          die "Wildcard cannot have * or ? "
              . (
              $min == 1 ? 'as first character' : "in first $min characters" )
              unless $self->{_opts}{fix};
          $term =~ s/[*?].*//;
          return '' unless length $term;
      }
      return "$term$next";
  }
  
  #===================================
  sub _RANGE {
  #===================================
      my $self = shift;
      my ( $open, $close, $from, $to ) = @_;
      my $opts = $self->{_opts};
      my $next = $self->_parse_context('_RANGE') || '';
      unless ( $opts->{allow_ranges} ) {
          die "Ranges not allowed\n"
              unless $opts->{fix};
          return '';
      }
      unless ( defined $to ) {
          die "Malformed range\n" unless $opts->{fix};
          return '';
      }
      return "$open$from TO $to$close$next";
  }
  
  #===================================
  sub _RESERVED {
  #===================================
      my $self = shift;
      my $char = shift;
      die "Reserved character $char\n"
          unless $self->{_opts}{fix};
      return $self->{_opts}{escape_reserved}
          ? "\\$char"
          : '';
  }
  
  #===================================
  sub _ESCAPE {
  #===================================
      my $self = shift;
      die qq(Cannot end with "\\"\n)
          unless $self->{_opts}{fix};
      return '';
  }
  
  my $DECIMAL  = qr/[0-9]+(?:[.][0-9]+)?/;
  my $NUM_CHAR = qr/[0-9]/;
  my $ESC_CHAR = qr/\\./;
  my $WS       = qr/[ \t\n\r\x{3000}]/;
  my $TERM_START_CHAR
      = qr/[^ \t\n\r\x{3000}+\-!():^[\]"{}~*?\\&|] | $ESC_CHAR/x;
  my $TERM_CHAR   = qr/$TERM_START_CHAR |$ESC_CHAR | [-+]/x;
  my $QUOTE_RANGE = qr/(?: " (?: \\" | [^"] )* ")/x;
  my $RANGE_SEP   = qr/ \s+ (?: TO \s+)?/x;
  
  #===================================
  sub _init_tokeniser {
  #===================================
      my $self = shift;
      my $text = shift;
  
      my $weak_self = $self;
      Scalar::Util::weaken($weak_self);
      return sub {
      TOKEN: {
              $weak_self->{_start_pos} = pos($text) || 0;
              return ['_SPACE']
                  if $text =~ m/\G$WS/gc;
              return [ '_AND_OR', $1 ]
                  if $text =~ m/\G(AND\b | && | OR\b | \|{2})/gcx;
              return [ '_NOT', $1 ]
                  if $text =~ m/\G(NOT\b | !)/gcx;
              return [ '_PLUS_MINUS', $1 ]
                  if $text =~ m/\G([-+])/gc;
              return ['_LPAREN']
                  if $text =~ m/\G[(]/gc;
              return ['_RPAREN']
                  if $text =~ m/\G[)]/gc;
              return [ '_BOOST', $1 ]
                  if $text =~ m/\G\^($DECIMAL)?/gc;
              return [ '_FUZZY', $1 ]
                  if $text =~ m/\G[~]($DECIMAL)?/gc;
              return [ '_PHRASE', $1, $2 ]
                  if $text =~ m/\G " ( (?: $ESC_CHAR | [^"\\])*) "/gcx;
              return [ '_EXISTS', $1, $2 ]
                  if $text =~ m/\G
                                  (_exists_|_missing_):
                                  ((?:$TERM_START_CHAR $TERM_CHAR*)?)
                              /gcx;
              return [ '_FIELD', $1 ]
                  if $text =~ m/\G ($TERM_START_CHAR $TERM_CHAR*):/gcx;
              return [ '_TERM', $1 ]
                  if $text =~ m/\G
                                  ( $TERM_START_CHAR $TERM_CHAR*)
                                  (?!$TERM_CHAR | [*?])
                              /gcx;
              return [ '_WILDTERM', $1 ]
                  if $text =~ m/\G (
                                      (?:$TERM_START_CHAR | [*?])
                                      (?:$TERM_CHAR | [*?])*
                              )/gcx;
              return [ '_RANGE', '[', ']', $1, $2 ]
                  if $text =~ m/\G \[
                                  ( $QUOTE_RANGE | [^ \]]+ )
                                  (?: $RANGE_SEP
                                      ( $QUOTE_RANGE | [^ \]]* )
                                  )?
                              \]
                              /gcx;
              return [ '_RANGE', '{', '}', $1, $2 ]
                  if $text =~ m/\G \{
                                  ( $QUOTE_RANGE | [^ }]+ )
                                  (?:
                                      $RANGE_SEP
                                      ( $QUOTE_RANGE | [^ }]* )
                                  )?
                              \}
                              /gcx;
  
              return [ '_RESERVED', $1 ]
                  if $text =~ m/\G ( ["&|!(){}[\]~^:+\-] )/gcx;
  
              return ['_ESCAPE']
                  if $text =~ m/\G\\$/gc;
          }
          return;
  
      };
  }
  
  =head1 BUGS
  
  This is a new module, so it is likely that there will be bugs, and the list
  of options and how L</"filter()"> cleans up the query string may well change.
  
  If you have any suggestions for improvements, or find any bugs, please report
  them to L<http://github.com/clintongormley/ElasticSearch.pm/issues>.
  
  Patches welcome!
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
  
ELASTICSEARCH_QUERYPARSER

$fatpacked{"ElasticSearch/RequestParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_REQUESTPARSER';
  package ElasticSearch;
  $ElasticSearch::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use Any::URI::Escape qw(uri_escape);
  use Carp;
  use constant {
      ONE_REQ     => 1,
      ONE_OPT     => 2,
      ONE_ALL     => 3,
      MULTI_ALL   => 4,
      MULTI_BLANK => 5,
      MULTI_REQ   => 6,
  };
  
  use constant {
      CMD_NONE          => [],
      CMD_INDEX_TYPE_ID => [ index => ONE_REQ, type => ONE_REQ, id => ONE_REQ ],
      CMD_INDEX_TYPE_id => [ index => ONE_REQ, type => ONE_REQ, id => ONE_OPT ],
      CMD_INDEX_type_ID => [ index => ONE_REQ, type => ONE_ALL, id => ONE_REQ ],
      CMD_Index           => [ index => ONE_OPT ],
      CMD_index           => [ index => MULTI_BLANK ],
      CMD_indices         => [ index => MULTI_ALL ],
      CMD_INDICES         => [ index => MULTI_REQ ],
      CMD_INDEX           => [ index => ONE_REQ ],
      CMD_INDEX_TYPE      => [ index => ONE_REQ, type => ONE_REQ ],
      CMD_INDEX_type      => [ index => ONE_REQ, type => MULTI_BLANK ],
      CMD_index_TYPE      => [ index => MULTI_ALL, type => ONE_REQ ],
      CMD_index_types     => [ index => MULTI_ALL, type => MULTI_REQ ],
      CMD_INDICES_TYPE    => [ index => MULTI_REQ, type => ONE_REQ ],
      CMD_index_type      => [ index => MULTI_ALL, type => MULTI_BLANK ],
      CMD_index_then_type => [ index => ONE_OPT, type => ONE_OPT ],
      CMD_RIVER           => [ river => ONE_REQ ],
      CMD_nodes           => [ node  => MULTI_BLANK ],
      CMD_NAME            => [ name  => ONE_REQ ],
      CMD_INDEX_PERC      => [ index => ONE_REQ, percolator => ONE_REQ ],
  
      CONSISTENCY => [ 'enum', [ 'one', 'quorum', 'all' ] ],
      REPLICATION => [ 'enum', [ 'async', 'sync' ] ],
      SEARCH_TYPE => [
          'enum',
          [   'dfs_query_then_fetch', 'dfs_query_and_fetch',
              'query_then_fetch',     'query_and_fetch',
              'count',                'scan'
          ]
      ],
      IGNORE_INDICES => [ 'enum', [ 'missing', 'none' ] ],
  
  };
  
  our %QS_Format = (
      boolean  => '1 | 0',
      duration => "'5m' | '10s'",
      optional => "'scalar value'",
      flatten  => "'scalar' or ['scalar_1', 'scalar_n']",
      'int'    => "integer",
      string   => sub {
          my $k = shift;
          return $k eq 'preference'
              ? '_local | _primary | _primary_first | $string'
              : $k eq 'percolate' || $k eq 'q' ? '$query_string'
              : $k eq 'scroll_id' ? '$scroll_id'
              : $k eq 'df'        ? '$default_field'
              :                     '$string';
      },
      float   => 'float',
      enum    => sub { join " | ", @{ $_[1][1] } },
      coderef => 'sub {..} | "IGNORE"',
  );
  
  our %QS_Formatter = (
      boolean => sub {
          my $key = shift;
          my $val = $_[0] ? $_[1] : $_[2];
          return unless defined $val;
          return ref $val ? $val : [ $key, $val ? 'true' : 'false' ];
      },
      duration => sub {
          my ( $k, $t ) = @_;
          return unless defined $t;
          return [ $k, $t ] if $t =~ /^\d+([smh]|ms)$/i;
          die "$k '$t' is not in the form $QS_Format{duration}\n";
      },
      flatten => sub {
          my $key = shift;
          my $array = shift or return;
          return [ $key, ref $array ? join( ',', @$array ) : $array ];
      },
      'int' => sub {
          my $key = shift;
          my $int = shift;
          return unless defined $int;
          eval { $int += 0; 1 } or die "'$key' is not an integer";
          return [ $key, $int ];
      },
      'float' => sub {
          my $key   = shift;
          my $float = shift;
          return unless defined $float;
          $key = shift if @_;
          eval { $float += 0; 1 } or die "'$key' is not a float";
          return [ $key, $float ];
      },
      'string' => sub {
          my $key    = shift;
          my $string = shift;
          return unless defined $string;
          return [ $key, $string ];
      },
      'coderef' => sub {
          my $key     = shift;
          my $coderef = shift;
          return unless defined $coderef;
          unless ( ref $coderef ) {
              die "'$key' is not a code ref or the string 'IGNORE'"
                  unless $coderef eq 'IGNORE';
              $coderef = sub { };
          }
          return [ $key, $coderef ];
      },
      'enum' => sub {
          my $key = shift;
          my $val = shift;
          return unless defined $val;
          my $vals = $_[0];
          for (@$vals) {
              return [ $key, $val ] if $val eq $_;
          }
          die "Unrecognised value '$val'. Allowed values: "
              . join( ', ', @$vals );
      },
  
  );
  
  ##################################
  ## DOCUMENT MANAGEMENT
  ##################################
  
  #===================================
  sub get {
  #===================================
      shift()->_do_action(
          'get',
          {   cmd => CMD_INDEX_type_ID,
              qs  => {
                  fields         => ['flatten'],
                  ignore_missing => [ 'boolean', 1 ],
                  preference     => ['string'],
                  refresh        => [ 'boolean', 1 ],
                  routing        => ['string'],
                  parent         => ['string'],
              },
          },
          @_
      );
  }
  
  #===================================
  sub exists : method {
  #===================================
      shift()->_do_action(
          'exists',
          {   method => 'HEAD',
              cmd    => CMD_INDEX_TYPE_ID,
              qs     => {
                  preference => ['string'],
                  refresh    => [ 'boolean', 1 ],
                  routing    => ['string'],
                  parent     => ['string'],
              },
              fixup => sub { $_[1]->{qs}{ignore_missing} = 1 }
          },
          @_
      );
  }
  
  #===================================
  sub mget {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $params->{$_} ||= $self->{_default}{$_} for qw(index type);
  
      if ( $params->{index} ) {
          if ( my $ids = delete $params->{ids} ) {
              $self->throw( 'Param', 'mget',
                  'Cannot specify both ids and docs in mget()' )
                  if $params->{docs};
              $params->{docs} = [ map { +{ _id => $_ } } @$ids ];
          }
      }
      else {
          $self->throw( 'Param',
              'Cannot specify a type for mget() without specifying index' )
              if $params->{type};
          $self->throw( 'Param',
              'Use of the ids param with mget() requires an index' )
              if $params->{ids};
      }
  
      my $filter;
      $self->_do_action(
          'mget',
          {   cmd     => [ index => ONE_OPT, type => ONE_OPT ],
              postfix => '_mget',
              data => { docs => 'docs' },
              qs   => {
                  fields         => ['flatten'],
                  filter_missing => [ 'boolean', 1 ],
              },
              fixup => sub {
                  $_[1]->{skip} = [] unless @{ $_[1]{data}{docs} };
                  $filter = delete $_[1]->{qs}{filter_missing};
              },
              post_process => sub {
                  my $result = shift;
                  my $docs   = $result->{docs};
                  return $filter ? [ grep { $_->{exists} } @$docs ] : $docs;
                  }
          },
          $params
      );
  }
  
  my %Index_Defn = (
      cmd => CMD_INDEX_TYPE_id,
      qs  => {
          consistency => CONSISTENCY,
          create      => [ 'boolean', [ op_type => 'create' ] ],
          parent      => ['string'],
          percolate   => ['string'],
          refresh     => [ 'boolean', 1 ],
          replication => REPLICATION,
          routing     => ['string'],
          timeout     => ['duration'],
          timestamp   => ['string'],
          ttl         => ['int'],
          version     => ['int'],
          version_type => [ 'enum', [ 'internal', 'external' ] ],
      },
      data  => { data => 'data' },
      fixup => sub {
          my $data = $_[1]{data}{data};
          $_[1]{data} = ref $data eq 'HASH' ? $data : \$data;
      }
  );
  
  #===================================
  sub index {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $self->_index( 'index', \%Index_Defn, $params );
  }
  
  #===================================
  sub set {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $self->_index( 'set', \%Index_Defn, $params );
  }
  
  #===================================
  sub create {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $self->_index( 'create', \%Index_Defn, { %$params, create => 1 } );
  }
  
  #===================================
  sub _index {
  #===================================
      my $self = shift;
      $_[1]->{method} = $_[2]->{id} ? 'PUT' : 'POST';
      $self->_do_action(@_);
  }
  
  #===================================
  sub update {
  #===================================
      shift()->_do_action(
          'update',
          {   method  => 'POST',
              cmd     => CMD_INDEX_TYPE_ID,
              postfix => '_update',
              data    => {
                  script => ['script'],
                  params => ['params'],
                  doc    => ['doc'],
                  upsert => ['upsert'],
              },
              qs => {
                  consistency       => CONSISTENCY,
                  fields            => ['flatten'],
                  ignore_missing    => [ 'boolean', 1 ],
                  parent            => ['string'],
                  percolate         => ['string'],
                  retry_on_conflict => ['int'],
                  routing           => ['string'],
                  timeout           => ['duration'],
                  replication       => REPLICATION,
              }
          },
          @_
      );
  }
  
  #===================================
  sub delete {
  #===================================
      shift()->_do_action(
          'delete',
          {   method => 'DELETE',
              cmd    => CMD_INDEX_TYPE_ID,
              qs     => {
                  consistency    => CONSISTENCY,
                  ignore_missing => [ 'boolean', 1 ],
                  refresh        => [ 'boolean', 1 ],
                  parent         => ['string'],
                  routing        => ['string'],
                  version        => ['int'],
                  replication    => REPLICATION,
              }
          },
          @_
      );
  }
  
  #===================================
  sub analyze {
  #===================================
      shift()->_do_action(
          'analyze',
          {   method  => 'GET',
              cmd     => CMD_Index,
              postfix => '_analyze',
              qs      => {
                  text         => ['string'],
                  analyzer     => ['string'],
                  tokenizer    => ['string'],
                  filters      => ['flatten'],
                  field        => ['string'],
                  format       => [ 'enum', [ 'detailed', 'text' ] ],
                  prefer_local => [ 'boolean', undef, 0 ],
              }
          },
          @_
      );
  }
  
  ##################################
  ## BULK INTERFACE
  ##################################
  
  #===================================
  sub bulk {
  #===================================
      my $self = shift;
      $self->_bulk( 'bulk', $self->_bulk_params( 'actions', @_ ) );
  }
  
  #===================================
  sub _bulk {
  #===================================
      my ( $self, $method, $params ) = @_;
      my %callbacks;
      my $actions = $params->{actions} || [];
  
      $self->_do_action(
          $method,
          {   cmd     => CMD_index_then_type,
              method  => 'POST',
              postfix => '_bulk',
              qs      => {
                  consistency => CONSISTENCY,
                  replication => REPLICATION,
                  refresh     => [ 'boolean', 1 ],
                  on_conflict => ['coderef'],
                  on_error    => ['coderef'],
              },
              data  => { actions => 'actions' },
              fixup => sub {
                  die "Cannot specify type without index"
                      if $params->{type} && !$params->{index};
                  $_[1]->{data} = $self->_bulk_request($actions);
                  $_[1]->{skip} = { actions => [], results => [] }
                      unless ${ $_[1]->{data} };
                  $callbacks{$_} = delete $_[1]->{qs}{$_}
                      for qw(on_error on_conflict);
              },
              post_process => sub {
                  $self->_bulk_response( \%callbacks, $actions, @_ );
              },
          },
          $params
      );
  }
  
  #===================================
  sub bulk_index  { shift->_bulk_action( 'index',  @_ ) }
  sub bulk_create { shift->_bulk_action( 'create', @_ ) }
  sub bulk_delete { shift->_bulk_action( 'delete', @_ ) }
  #===================================
  
  #===================================
  sub _bulk_action {
  #===================================
      my $self   = shift;
      my $action = shift;
      my $params = $self->_bulk_params( 'docs', @_ );
      $params->{actions}
          = [ map { +{ $action => $_ } } @{ delete $params->{docs} } ];
      return $self->_bulk( "bulk_$action", $params );
  }
  
  #===================================
  sub _bulk_params {
  #===================================
      my $self = shift;
      my $key  = shift;
  
      return { $key => [], @_ } unless ref $_[0];
      return
          ref $_[0] eq 'ARRAY' ? { $key => $_[0] } : { $key => [], %{ $_[0] } }
          unless @_ > 1;
  
      carp "The method signature for bulk methods has changed. "
          . "Please check the docs.";
  
      if ( ref $_[0] eq 'ARRAY' ) {
          my $first = shift;
          my $params = ref $_[0] ? shift : {@_};
          $params->{$key} = $first;
          return $params;
      }
      return { $key => \@_ };
  }
  
  my %Bulk_Actions = (
      'delete' => {
          index        => ONE_OPT,
          type         => ONE_OPT,
          id           => ONE_REQ,
          parent       => ONE_OPT,
          routing      => ONE_OPT,
          version      => ONE_OPT,
          version_type => ONE_OPT,
      },
      'index' => {
          index        => ONE_OPT,
          type         => ONE_OPT,
          id           => ONE_OPT,
          data         => ONE_REQ,
          routing      => ONE_OPT,
          parent       => ONE_OPT,
          percolate    => ONE_OPT,
          timestamp    => ONE_OPT,
          ttl          => ONE_OPT,
          version      => ONE_OPT,
          version_type => ONE_OPT,
      },
  );
  $Bulk_Actions{create} = $Bulk_Actions{index};
  
  #===================================
  sub _bulk_request {
  #===================================
      my $self    = shift;
      my $actions = shift;
  
      my $json      = $self->transport->JSON;
      my $indenting = $json->get_indent;
      $json->indent(0);
  
      my $json_docs = '';
      my $error;
      eval {
          for my $data (@$actions)
          {
              die "'actions' must be an ARRAY ref of HASH refs"
                  unless ref $data eq 'HASH';
  
              my ( $action, $params ) = %$data;
              $action ||= '';
              my $defn = $Bulk_Actions{$action}
                  || die "Unknown action '$action'";
  
              my %metadata;
              $params = {%$params};
              delete @{$params}{qw(_score sort)};
              $params->{data} ||= delete $params->{_source}
                  if $params->{_source};
  
              for my $key ( keys %$defn ) {
                  my $val = delete $params->{$key};
                  $val = delete $params->{"_$key"} unless defined $val;
                  unless ( defined $val ) {
                      next if $defn->{$key} == ONE_OPT;
                      die "Missing required param '$key' for action '$action'";
                  }
                  $metadata{"_$key"} = $val;
              }
              die "Unknown params for bulk action '$action': "
                  . join( ', ', keys %$params )
                  if keys %$params;
  
              my $data = delete $metadata{_data};
              my $request = $json->encode( { $action => \%metadata } ) . "\n";
              if ($data) {
                  $data = $json->encode($data) if ref $data eq 'HASH';
                  $request .= $data . "\n";
              }
              $json_docs .= $request;
          }
          1;
      } or $error = $@ || 'Unknown error';
  
      $json->indent($indenting);
      die $error if $error;
  
      return \$json_docs;
  }
  
  #===================================
  sub _bulk_response {
  #===================================
      my $self      = shift;
      my $callbacks = shift;
      my $actions   = shift;
      my $results   = shift;
  
      my $items = ref($results) eq 'HASH' && $results->{items}
          || $self->throw( 'Request', 'Malformed response to bulk query',
          $results );
  
      my ( @errors, %matches );
      my ( $on_conflict, $on_error ) = @{$callbacks}{qw(on_conflict on_error)};
  
      for ( my $i = 0; $i < @$actions; $i++ ) {
          my ( $action, $item ) = ( %{ $items->[$i] } );
          if ( my $match = $item->{matches} ) {
              push @{ $matches{$_} }, $item for @$match;
          }
  
          my $error = $items->[$i]{$action}{error} or next;
          if (    $on_conflict
              and $error =~ /
                        VersionConflictEngineException
                      | DocumentAlreadyExistsException
                    /x
              )
          {
              $on_conflict->( $action, $actions->[$i]{$action}, $error, $i );
          }
          elsif ($on_error) {
              $on_error->( $action, $actions->[$i]{$action}, $error, $i );
          }
          else {
              push @errors, { action => $actions->[$i], error => $error };
          }
      }
  
      return {
          actions => $actions,
          results => $items,
          matches => \%matches,
          took    => $results->{took},
          ( @errors ? ( errors => \@errors ) : () )
      };
  }
  
  ##################################
  ## DSL FIXUP
  ##################################
  
  #===================================
  sub _to_dsl {
  #===================================
      my $self = shift;
      my $ops  = shift;
      my $builder;
      foreach my $clause (@_) {
          while ( my ( $old, $new ) = each %$ops ) {
              my $src = delete $clause->{$old} or next;
              die "Cannot specify $old and $new parameters.\n"
                  if $clause->{$new};
              $builder ||= $self->builder;
              my $method = $new eq 'query' ? 'query' : 'filter';
              my $sub_clause = $builder->$method($src) or next;
              $clause->{$new} = $sub_clause->{$method};
          }
      }
  }
  
  #===================================
  sub _data_fixup {
  #===================================
      my $self = shift;
      my $data = shift;
      $self->_to_dsl( { queryb => 'query', filterb => 'filter' }, $data );
  
      my $facets = $data->{facets} or return;
      die "(facets) must be a HASH ref" unless ref $facets eq 'HASH';
      $facets = $data->{facets} = {%$facets};
      for ( values %$facets ) {
          die "All (facets) must be HASH refs" unless ref $_ eq 'HASH';
          $_ = my $facet = {%$_};
          $self->_to_dsl( {
                  queryb        => 'query',
                  filterb       => 'filter',
                  facet_filterb => 'facet_filter'
              },
              $facet
          );
      }
  }
  
  #===================================
  sub _query_fixup {
  #===================================
      my $self = shift;
      my $args = shift;
      $self->_to_dsl( { queryb => 'query' }, $args->{data} );
      if ( my $query = delete $args->{data}{query} ) {
          my ( $k, $v ) = %$query;
          $args->{data}{$k} = $v;
      }
  }
  
  #===================================
  sub _warmer_fixup {
  #===================================
      my ( $self, $args ) = @_;
      my $warmers = $args->{data}{warmers} or return;
      $warmers = $args->{data}{warmers} = {%$warmers};
      for ( values %$warmers ) {
          $_ = {%$_};
          my $source = $_->{source} or next;
          $_->{source} = $source = {%$source};
          $self->_data_fixup($source);
      }
  }
  
  ##################################
  ## QUERIES
  ##################################
  
  my %Search_Data = (
      explain       => ['explain'],
      facets        => ['facets'],
      fields        => ['fields'],
      filter        => ['filter'],
      filterb       => ['filterb'],
      from          => ['from'],
      highlight     => ['highlight'],
      indices_boost => ['indices_boost'],
      min_score     => ['min_score'],
      script_fields => ['script_fields'],
      size          => ['size'],
      'sort'        => ['sort'],
      track_scores  => ['track_scores'],
  );
  
  my %Search_Defn = (
      cmd     => CMD_index_type,
      postfix => '_search',
      data    => {
          %Search_Data,
          query          => ['query'],
          queryb         => ['queryb'],
          partial_fields => ['partial_fields']
      },
      qs => {
          search_type    => SEARCH_TYPE,
          ignore_indices => IGNORE_INDICES,
          preference     => ['string'],
          routing        => ['flatten'],
          timeout        => ['duration'],
          scroll         => ['duration'],
          stats          => ['flatten'],
          version        => [ 'boolean', 1 ]
      },
      fixup => sub { $_[0]->_data_fixup( $_[1]->{data} ) },
  );
  
  my %SearchQS_Defn = (
      cmd     => CMD_index_type,
      postfix => '_search',
      qs      => {
          q                => ['string'],
          df               => ['string'],
          analyze_wildcard => [ 'boolean', 1 ],
          analyzer         => ['string'],
          default_operator => [ 'enum', [ 'OR', 'AND' ] ],
          explain                  => [ 'boolean', 1 ],
          fields                   => ['flatten'],
          from                     => ['int'],
          ignore_indices           => IGNORE_INDICES,
          lenient                  => [ 'boolean', 1 ],
          lowercase_expanded_terms => [ 'boolean', 1 ],
          min_score                => ['float'],
          preference               => ['string'],
          quote_analyzer           => ['string'],
          quote_field_suffix       => ['string'],
          routing                  => ['flatten'],
          scroll                   => ['duration'],
          search_type              => SEARCH_TYPE,
          size                     => ['int'],
          'sort'                   => ['flatten'],
          stats                    => ['flatten'],
          timeout                  => ['duration'],
          version                  => [ 'boolean', 1 ],
      },
  );
  
  my %Query_Defn = (
      data => {
          query  => ['query'],
          queryb => ['queryb'],
      },
      deprecated => {
          bool               => ['bool'],
          boosting           => ['boosting'],
          constant_score     => ['constant_score'],
          custom_score       => ['custom_score'],
          dis_max            => ['dis_max'],
          field              => ['field'],
          field_masking_span => ['field_masking_span'],
          filtered           => ['filtered'],
          flt                => [ 'flt', 'fuzzy_like_this' ],
          flt_field          => [ 'flt_field', 'fuzzy_like_this_field' ],
          fuzzy              => ['fuzzy'],
          has_child          => ['has_child'],
          ids                => ['ids'],
          match_all          => ['match_all'],
          mlt                => [ 'mlt', 'more_like_this' ],
          mlt_field          => [ 'mlt_field', 'more_like_this_field' ],
          prefix             => ['prefix'],
          query_string       => ['query_string'],
          range              => ['range'],
          span_first         => ['span_first'],
          span_near          => ['span_near'],
          span_not           => ['span_not'],
          span_or            => ['span_or'],
          span_term          => ['span_term'],
          term               => ['term'],
          terms              => [ 'terms', 'in' ],
          text               => ['text'],
          text_phrase        => ['text_phrase'],
          text_phrase_prefix => ['text_phrase_prefix'],
          top_children       => ['top_children'],
          wildcard           => ['wildcard'],
      }
  );
  
  #===================================
  sub search   { shift()->_do_action( 'search',   \%Search_Defn,   @_ ) }
  sub searchqs { shift()->_do_action( 'searchqs', \%SearchQS_Defn, @_ ) }
  #===================================
  
  #===================================
  sub msearch {
  #===================================
      my $self    = shift;
      my $params  = $self->parse_params(@_);
      my $queries = $params->{queries} || [];
  
      my $order;
      if ( ref $queries eq 'HASH' ) {
          $order = {};
          my $i = 0;
          my @queries;
          for ( sort keys %$queries ) {
              $order->{$_} = $i++;
              push @queries, $queries->{$_};
          }
          $queries = \@queries;
      }
  
      $self->_do_action(
          'msearch',
          {   cmd     => CMD_index_type,
              method  => 'GET',
              postfix => '_msearch',
              qs      => { search_type => SEARCH_TYPE },
              data    => { queries => 'queries' },
              fixup   => sub {
                  my ( $self, $args ) = @_;
                  $args->{data} = $self->_msearch_queries($queries);
                  $args->{skip} = $order ? {} : [] unless ${ $args->{data} };
              },
              post_process => sub {
                  my $responses = shift->{responses};
                  return $responses unless $order;
                  return {
                      map { $_ => $responses->[ $order->{$_} ] }
                          keys %$order
                  };
              },
          },
          $params
      );
  }
  
  my %MSearch = (
      ( map { $_ => 'h' } 'index', 'type', keys %{ $Search_Defn{qs} } ),
      ( map { $_ => 'b' } 'version', keys %{ $Search_Defn{data} } )
  );
  delete $MSearch{scroll};
  
  #===================================
  sub _msearch_queries {
  #===================================
      my $self    = shift;
      my $queries = shift;
  
      my $json      = $self->transport->JSON;
      my $indenting = $json->get_indent;
      $json->indent(0);
  
      my $json_docs = '';
      my $error;
      eval {
          for my $query (@$queries)
          {
              die "'queries' must contain HASH refs\n"
                  unless ref $query eq 'HASH';
  
              my %request = ( h => {}, b => {} );
              for ( keys %$query ) {
                  my $dest = $MSearch{$_}
                      or die "Unknown param for msearch: $_\n";
                  $request{$dest}{$_} = $query->{$_};
              }
  
              # flatten arrays
              for (qw(index type stats routing)) {
                  $request{h}{$_} = join ",", @{ $request{h}{$_} }
                      if ref $request{h}{$_} eq 'ARRAY';
              }
              $self->_data_fixup( $request{b} );
              $json_docs .= $json->encode( $request{h} ) . "\n"
                  . $json->encode( $request{b} ) . "\n";
          }
          1;
      } or $error = $@ || 'Unknown error';
  
      $json->indent($indenting);
      die $error if $error;
  
      return \$json_docs;
  }
  
  #===================================
  sub validate_query {
  #===================================
      shift->_do_action(
          'validate_query',
          {   cmd     => CMD_index_type,
              postfix => '_validate/query',
              data    => {
                  query  => ['query'],
                  queryb => ['queryb'],
              },
              qs => {
                  q              => ['string'],
                  explain        => [ 'boolean', 1 ],
                  ignore_indices => IGNORE_INDICES,
              },
              fixup => sub {
                  my $args = $_[1];
                  if ( defined $args->{qs}{q} ) {
                      die "Cannot specify q and query/queryb parameters.\n"
                          if %{ $args->{data} };
                      delete $args->{data};
                  }
                  else {
                      eval { _query_fixup(@_); 1 } or do {
                          die $@ if $@ =~ /Cannot specify queryb and query/;
                      };
                  }
              },
          },
          @_
      );
  }
  
  #===================================
  sub explain {
  #===================================
      shift->_do_action(
          'explain',
          {   cmd     => CMD_INDEX_TYPE_ID,
              postfix => '_explain',
              data    => {
                  query  => ['query'],
                  queryb => ['queryb'],
              },
              qs => {
                  preference               => ['string'],
                  routing                  => ['string'],
                  q                        => ['string'],
                  df                       => ['string'],
                  analyzer                 => ['string'],
                  analyze_wildcard         => [ 'boolean', 1 ],
                  default_operator         => [ 'enum', [ 'OR', 'AND' ] ],
                  fields                   => ['flatten'],
                  lowercase_expanded_terms => [ 'boolean', undef, 0 ],
                  lenient => [ 'boolean', 1 ],
              },
              fixup => sub {
                  my $args = $_[1];
                  if ( defined $args->{qs}{q} ) {
                      die "Cannot specify q and query/queryb parameters.\n"
                          if %{ $args->{data} };
                      delete $args->{data};
                  }
                  else {
                      $_[0]->_data_fixup( $args->{data} );
                  }
              },
          },
          @_
      );
  }
  
  #===================================
  sub scroll {
  #===================================
      shift()->_do_action(
          'scroll',
          {   cmd    => [],
              prefix => '_search/scroll',
              qs     => {
                  scroll_id => ['string'],
                  scroll    => ['duration'],
              }
          },
          @_
      );
  }
  
  #===================================
  sub scrolled_search {
  #===================================
      my $self = shift;
      require ElasticSearch::ScrolledSearch;
      return ElasticSearch::ScrolledSearch->new( $self, @_ );
  }
  
  #===================================
  sub delete_by_query {
  #===================================
      shift()->_do_action(
          'delete_by_query',
          {   %Search_Defn,
              method  => 'DELETE',
              postfix => '_query',
              qs      => {
                  consistency => CONSISTENCY,
                  replication => REPLICATION,
                  routing     => ['flatten'],
              },
              %Query_Defn,
              fixup => sub {
                  _query_fixup(@_);
                  die "Missing required param 'query' or 'queryb'\n"
                      unless %{ $_[1]->{data} };
              },
          },
          @_
      );
  }
  
  #===================================
  sub count {
  #===================================
      shift()->_do_action(
          'count',
          {   %Search_Defn,
              postfix => '_count',
              %Query_Defn,
              qs => {
                  routing        => ['flatten'],
                  ignore_indices => IGNORE_INDICES,
              },
              fixup => sub {
                  _query_fixup(@_);
                  delete $_[1]{data} unless %{ $_[1]{data} };
              },
          },
          @_
      );
  }
  
  #===================================
  sub mlt {
  #===================================
      shift()->_do_action(
          'mlt',
          {   cmd    => CMD_INDEX_TYPE_ID,
              method => 'GET',
              qs     => {
                  mlt_fields         => ['flatten'],
                  pct_terms_to_match => [ 'float', 'percent_terms_to_match' ],
                  min_term_freq      => ['int'],
                  max_query_terms    => ['int'],
                  stop_words         => ['flatten'],
                  min_doc_freq       => ['int'],
                  max_doc_freq       => ['int'],
                  min_word_len       => ['int'],
                  max_word_len       => ['int'],
                  boost_terms        => ['float'],
                  routing            => ['flatten'],
                  search_indices     => ['flatten'],
                  search_from        => ['int'],
                  search_size        => ['int'],
                  search_type        => SEARCH_TYPE,
                  search_types       => ['flatten'],
                  search_scroll      => ['string'],
              },
              postfix => '_mlt',
              data    => {
                  explain       => ['explain'],
                  facets        => ['facets'],
                  fields        => ['fields'],
                  filter        => ['filter'],
                  filterb       => ['filterb'],
                  highlight     => ['highlight'],
                  indices_boost => ['indices_boost'],
                  min_score     => ['min_score'],
                  script_fields => ['script_fields'],
                  'sort'        => ['sort'],
                  track_scores  => ['track_scores'],
              },
              fixup => sub {
                  shift()->_to_dsl( { filterb => 'filter' }, $_[0]->{data} );
              },
          },
          @_
      );
  }
  
  ##################################
  ## PERCOLATOR
  ##################################
  #===================================
  sub create_percolator {
  #===================================
      shift()->_do_action(
          'create_percolator',
          {   cmd    => CMD_INDEX_PERC,
              prefix => '_percolator',
              method => 'PUT',
              data   => {
                  query  => ['query'],
                  queryb => ['queryb'],
                  data   => ['data']
              },
              fixup => sub {
                  my $self = shift;
                  my $args = shift;
                  $self->_to_dsl( { queryb => 'query' }, $args->{data} );
                  die('create_percolator() requires either the query or queryb param'
                  ) unless $args->{data}{query};
                  die 'The "data" param cannot include a "query" key'
                      if $args->{data}{data}{query};
                  $args->{data} = {
                      query => $args->{data}{query},
                      %{ $args->{data}{data} }
                  };
              },
          },
          @_
      );
  }
  
  #===================================
  sub delete_percolator {
  #===================================
      shift()->_do_action(
          'delete_percolator',
          {   cmd    => CMD_INDEX_PERC,
              prefix => '_percolator',
              method => 'DELETE',
              qs     => { ignore_missing => [ 'boolean', 1 ], }
          },
          @_
      );
  }
  
  #===================================
  sub get_percolator {
  #===================================
      shift()->_do_action(
          'get_percolator',
          {   cmd          => CMD_INDEX_PERC,
              prefix       => '_percolator',
              method       => 'GET',
              qs           => { ignore_missing => [ 'boolean', 1 ], },
              post_process => sub {
                  my $result = shift;
                  return $result
                      unless ref $result eq 'HASH';
                  return {
                      index      => $result->{_type},
                      percolator => $result->{_id},
                      query      => delete $result->{_source}{query},
                      data       => $result->{_source},
                  };
              },
          },
          @_
      );
  }
  
  #===================================
  sub percolate {
  #===================================
      shift()->_do_action(
          'percolate',
          {   cmd     => CMD_INDEX_TYPE,
              postfix => '_percolate',
              method  => 'GET',
              qs      => { prefer_local => [ 'boolean', undef, 0 ] },
              data    => { doc => 'doc', query => ['query'] },
          },
          @_
      );
  }
  
  ##################################
  ## INDEX ADMIN
  ##################################
  
  #===================================
  sub index_status {
  #===================================
      shift()->_do_action(
          'index_status',
          {   cmd     => CMD_index,
              postfix => '_status',
              qs      => {
                  recovery       => [ 'boolean', 1 ],
                  snapshot       => [ 'boolean', 1 ],
                  ignore_indices => IGNORE_INDICES,
              },
          },
          @_
      );
  }
  
  #===================================
  sub index_stats {
  #===================================
      shift()->_do_action(
          'index_stats',
          {   cmd     => CMD_index,
              postfix => '_stats',
              qs      => {
                  docs     => [ 'boolean', 1, 0 ],
                  store    => [ 'boolean', 1, 0 ],
                  indexing => [ 'boolean', 1, 0 ],
                  get      => [ 'boolean', 1, 0 ],
                  search   => [ 'boolean', 1, 0 ],
                  clear    => [ 'boolean', 1 ],
                  all      => [ 'boolean', 1 ],
                  merge    => [ 'boolean', 1 ],
                  flush    => [ 'boolean', 1 ],
                  refresh  => [ 'boolean', 1 ],
                  types    => ['flatten'],
                  groups   => ['flatten'],
                  level => [ 'enum', [qw(shards)] ],
                  ignore_indices => IGNORE_INDICES,
              },
          },
          @_
      );
  }
  
  #===================================
  sub index_segments {
  #===================================
      shift()->_do_action(
          'index_segments',
          {   cmd     => CMD_index,
              postfix => '_segments',
              qs      => { ignore_indices => IGNORE_INDICES, }
          },
          @_
      );
  }
  
  #===================================
  sub create_index {
  #===================================
      shift()->_do_action(
          'create_index',
          {   method  => 'PUT',
              cmd     => CMD_INDEX,
              postfix => '',
              data    => {
                  settings => ['settings'],
                  mappings => ['mappings'],
                  warmers  => ['warmers'],
              },
              fixup => \&_warmer_fixup
          },
          @_
      );
  }
  
  #===================================
  sub delete_index {
  #===================================
      shift()->_do_action(
          'delete_index',
          {   method  => 'DELETE',
              cmd     => CMD_INDICES,
              qs      => { ignore_missing => [ 'boolean', 1 ], },
              postfix => ''
          },
          @_
      );
  }
  
  #===================================
  sub index_exists {
  #===================================
      shift()->_do_action(
          'index_exists',
          {   method => 'HEAD',
              cmd    => CMD_index,
              fixup  => sub { $_[1]->{qs}{ignore_missing} = 1 }
          },
          @_
      );
  }
  
  #===================================
  sub open_index {
  #===================================
      shift()->_do_action(
          'open_index',
          {   method  => 'POST',
              cmd     => CMD_INDEX,
              postfix => '_open'
          },
          @_
      );
  }
  
  #===================================
  sub close_index {
  #===================================
      shift()->_do_action(
          'close_index',
          {   method  => 'POST',
              cmd     => CMD_INDEX,
              postfix => '_close'
          },
          @_
      );
  }
  
  #===================================
  sub aliases {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      my $actions = $params->{actions};
      if ( defined $actions && ref $actions ne 'ARRAY' ) {
          $params->{actions} = [$actions];
      }
  
      $self->_do_action(
          'aliases',
          {   prefix => '_aliases',
              method => 'POST',
              cmd    => [],
              data   => { actions => 'actions' },
              fixup  => sub {
                  my $self    = shift;
                  my $args    = shift;
                  my @actions = @{ $args->{data}{actions} };
                  for (@actions) {
                      my ( $key, $value ) = %$_;
                      $value = {%$value};
                      $self->_to_dsl( { filterb => 'filter' }, $value );
                      $_ = { $key => $value };
                  }
                  $args->{data}{actions} = \@actions;
              },
          },
          $params
      );
  }
  
  #===================================
  sub get_aliases {
  #===================================
      shift->_do_action(
          'aliases',
          {   postfix => '_aliases',
              cmd     => CMD_index,
              qs      => { ignore_missing => [ 'boolean', 1 ] },
          },
          @_
      );
  }
  
  #===================================
  sub create_warmer {
  #===================================
      shift()->_do_action(
          'create_warmer',
          {   method  => 'PUT',
              cmd     => CMD_index_type,
              postfix => '_warmer/',
              data    => {
                  warmer        => 'warmer',
                  facets        => ['facets'],
                  filter        => ['filter'],
                  filterb       => ['filterb'],
                  script_fields => ['script_fields'],
                  'sort'        => ['sort'],
                  query         => ['query'],
                  queryb        => ['queryb'],
              },
              fixup => sub {
                  my ( $self, $args ) = @_;
                  $args->{cmd} .= delete $args->{data}{warmer};
                  $self->_data_fixup( $args->{data} );
              },
          },
          @_
      );
  }
  
  #===================================
  sub warmer {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $params->{warmer} = '*'
          unless defined $params->{warmer} and length $params->{warmer};
  
      $self->_do_action(
          'warmer',
          {   method  => 'GET',
              cmd     => CMD_indices,
              postfix => '_warmer/',
              data    => { warmer => ['warmer'] },
              qs      => { ignore_missing => [ 'boolean', 1 ] },
              fixup   => sub {
                  my ( $self, $args ) = @_;
                  $args->{cmd} .= delete $args->{data}{warmer};
              },
          },
          $params
      );
  }
  
  #===================================
  sub delete_warmer {
  #===================================
      shift()->_do_action(
          'delete_warmer',
          {   method  => 'DELETE',
              cmd     => CMD_INDICES,
              postfix => '_warmer/',
              data    => { warmer => 'warmer' },
              qs      => { ignore_missing => [ 'boolean', 1 ] },
              fixup   => sub {
                  my ( $self, $args ) = @_;
                  $args->{cmd} .= delete $args->{data}{warmer};
              },
          },
          @_
      );
  }
  
  #===================================
  sub create_index_template {
  #===================================
      shift()->_do_action(
          'create_index_template',
          {   method => 'PUT',
              cmd    => CMD_NAME,
              prefix => '_template',
              data   => {
                  template => 'template',
                  settings => ['settings'],
                  mappings => ['mappings'],
                  warmers  => ['warmers'],
                  order    => ['order'],
              },
              fixup => \&_warmer_fixup
          },
          @_
      );
  }
  
  #===================================
  sub delete_index_template {
  #===================================
      shift()->_do_action(
          'delete_index_template',
          {   method => 'DELETE',
              cmd    => CMD_NAME,
              prefix => '_template',
              qs     => { ignore_missing => [ 'boolean', 1 ] },
          },
          @_
      );
  }
  
  #===================================
  sub index_template {
  #===================================
      shift()->_do_action(
          'index_template',
          {   method => 'GET',
              cmd    => CMD_NAME,
              prefix => '_template',
          },
          @_
      );
  }
  
  #===================================
  sub flush_index {
  #===================================
      shift()->_do_action(
          'flush_index',
          {   method  => 'POST',
              cmd     => CMD_index,
              postfix => '_flush',
              qs      => {
                  refresh        => [ 'boolean', 1 ],
                  full           => [ 'boolean', 1 ],
                  ignore_indices => IGNORE_INDICES,
              },
          },
          @_
      );
  }
  
  #===================================
  sub refresh_index {
  #===================================
      shift()->_do_action(
          'refresh_index',
          {   method  => 'POST',
              cmd     => CMD_index,
              postfix => '_refresh',
              qs      => { ignore_indices => IGNORE_INDICES, }
          },
          @_
      );
  }
  
  #===================================
  sub optimize_index {
  #===================================
      shift()->_do_action(
          'optimize_index',
          {   method  => 'POST',
              cmd     => CMD_index,
              postfix => '_optimize',
              qs      => {
                  only_deletes =>
                      [ 'boolean', [ only_expunge_deletes => 'true' ] ],
                  max_num_segments => ['int'],
                  refresh          => [ 'boolean', undef, 0 ],
                  flush            => [ 'boolean', undef, 0 ],
                  wait_for_merge   => [ 'boolean', undef, 0 ],
                  ignore_indices   => IGNORE_INDICES,
              },
          },
          @_
      );
  }
  
  #===================================
  sub snapshot_index {
  #===================================
      shift()->_do_action(
          'snapshot_index',
          {   method  => 'POST',
              cmd     => CMD_index,
              postfix => '_gateway/snapshot',
              qs      => { ignore_indices => IGNORE_INDICES, }
          },
          @_
      );
  }
  
  #===================================
  sub gateway_snapshot {
  #===================================
      shift()->_do_action(
          'gateway_snapshot',
          {   method  => 'POST',
              cmd     => CMD_index,
              postfix => '_gateway/snapshot'
          },
          @_
      );
  }
  
  #===================================
  sub put_mapping {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      my %defn = (
          data       => { mapping => 'mapping' },
          deprecated => {
              dynamic           => ['dynamic'],
              dynamic_templates => ['dynamic_templates'],
              properties        => ['properties'],
              _all              => ['_all'],
              _analyzer         => ['_analyzer'],
              _boost            => ['_boost'],
              _id               => ['_id'],
              _index            => ['_index'],
              _meta             => ['_meta'],
              _parent           => ['_parent'],
              _routing          => ['_routing'],
              _source           => ['_source'],
          },
      );
  
      $defn{deprecated}{mapping} = undef
          if !$params->{mapping} && grep { exists $params->{$_} }
              keys %{ $defn{deprecated} };
  
      my $type = $params->{type} || $self->{_default}{type};
      $self->_do_action(
          'put_mapping',
          {   method  => 'PUT',
              cmd     => CMD_index_TYPE,
              postfix => '_mapping',
              qs      => { ignore_conflicts => [ 'boolean', 1 ] },
              %defn,
              fixup => sub {
                  my $args = $_[1];
                  my $mapping = $args->{data}{mapping} || $args->{data};
                  $args->{data} = { $type => $mapping };
              },
          },
          $params
      );
  }
  
  #===================================
  sub delete_mapping {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $self->_do_action(
          'delete_mapping',
          {   method => 'DELETE',
              cmd    => CMD_INDICES_TYPE,
              qs     => { ignore_missing => [ 'boolean', 1 ], }
          },
          $params
      );
  }
  
  #===================================
  sub mapping {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $self->_do_action(
          'mapping',
          {   method  => 'GET',
              cmd     => CMD_index_type,
              postfix => '_mapping',
              qs      => { ignore_missing => [ 'boolean', 1 ], }
          },
          $params
      );
  }
  
  #===================================
  sub type_exists {
  #===================================
      shift()->_do_action(
          'type_exists',
          {   method => 'HEAD',
              cmd    => CMD_index_types,
              qs     => { ignore_indices => IGNORE_INDICES, },
              fixup  => sub { $_[1]->{qs}{ignore_missing} = 1 }
          },
          @_
      );
  }
  
  #===================================
  sub clear_cache {
  #===================================
      shift()->_do_action(
          'clear_cache',
          {   method  => 'POST',
              cmd     => CMD_index,
              postfix => '_cache/clear',
              qs      => {
                  id             => [ 'boolean', 1 ],
                  filter         => [ 'boolean', 1 ],
                  field_data     => [ 'boolean', 1 ],
                  bloom          => [ 'boolean', 1 ],
                  fields         => ['flatten'],
                  ignore_indices => IGNORE_INDICES,
              }
          },
          @_
      );
  }
  
  #===================================
  sub index_settings {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $self->_do_action(
          'index_settings',
          {   method  => 'GET',
              cmd     => CMD_index,
              postfix => '_settings'
          },
          $params
      );
  }
  
  #===================================
  sub update_index_settings {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $self->_do_action(
          'update_index_settings',
          {   method  => 'PUT',
              cmd     => CMD_index,
              postfix => '_settings',
              data    => { index => 'settings' }
          },
          $params
      );
  }
  
  ##################################
  ## RIVER MANAGEMENT
  ##################################
  
  #===================================
  sub create_river {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      my $type = $params->{type}
          or $self->throw( 'Param', 'No river type specified', $params );
      my $data = { type => 'type', index => ['index'], $type => [$type] };
      $self->_do_action(
          'create_river',
          {   method  => 'PUT',
              prefix  => '_river',
              cmd     => CMD_RIVER,
              postfix => '_meta',
              data    => $data
          },
          $params
      );
  }
  
  #===================================
  sub get_river {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $self->_do_action(
          'get_river',
          {   method  => 'GET',
              prefix  => '_river',
              cmd     => CMD_RIVER,
              postfix => '_meta',
              qs      => { ignore_missing => [ 'boolean', 1 ] }
          },
          $params
      );
  }
  
  #===================================
  sub delete_river {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $self->_do_action(
          'delete_river',
          {   method => 'DELETE',
              prefix => '_river',
              cmd    => CMD_RIVER,
          },
          $params
      );
  }
  
  #===================================
  sub river_status {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $self->_do_action(
          'river_status',
          {   method  => 'GET',
              prefix  => '_river',
              cmd     => CMD_RIVER,
              postfix => '_status',
              qs      => { ignore_missing => [ 'boolean', 1 ] }
          },
          $params
      );
  }
  
  ##################################
  ## CLUSTER MANAGEMENT
  ##################################
  
  #===================================
  sub cluster_state {
  #===================================
      shift()->_do_action(
          'cluster_state',
          {   prefix => '_cluster/state',
              qs     => {
                  filter_blocks        => [ 'boolean', 1 ],
                  filter_nodes         => [ 'boolean', 1 ],
                  filter_metadata      => [ 'boolean', 1 ],
                  filter_routing_table => [ 'boolean', 1 ],
                  filter_indices       => ['flatten'],
                  }
  
          },
          @_
      );
  }
  
  #===================================
  sub current_server_version {
  #===================================
      shift()->_do_action(
          'current_server_version',
          {   cmd          => CMD_NONE,
              prefix       => '',
              post_process => sub {
                  return shift->{version};
              },
          }
      );
  }
  
  #===================================
  sub nodes {
  #===================================
      shift()->_do_action(
          'nodes',
          {   prefix => '_cluster/nodes',
              cmd    => CMD_nodes,
              qs     => {
                  settings    => [ 'boolean', 1 ],
                  http        => [ 'boolean', 1 ],
                  jvm         => [ 'boolean', 1 ],
                  network     => [ 'boolean', 1 ],
                  os          => [ 'boolean', 1 ],
                  process     => [ 'boolean', 1 ],
                  thread_pool => [ 'boolean', 1 ],
                  transport   => [ 'boolean', 1 ],
              },
          },
          @_
      );
  }
  
  #===================================
  sub nodes_stats {
  #===================================
      shift()->_do_action(
          'nodes',
          {   prefix  => '_cluster/nodes',
              postfix => 'stats',
              cmd     => CMD_nodes,
              qs      => {
                  indices     => [ 'boolean', 1, 0 ],
                  clear       => [ 'boolean', 1 ],
                  all         => [ 'boolean', 1 ],
                  fs          => [ 'boolean', 1 ],
                  http        => [ 'boolean', 1 ],
                  jvm         => [ 'boolean', 1 ],
                  network     => [ 'boolean', 1 ],
                  os          => [ 'boolean', 1 ],
                  process     => [ 'boolean', 1 ],
                  thread_pool => [ 'boolean', 1 ],
                  transport   => [ 'boolean', 1 ],
              },
          },
          @_
      );
  }
  
  #===================================
  sub shutdown {
  #===================================
      shift()->_do_action(
          'shutdown',
          {   method  => 'POST',
              prefix  => '_cluster/nodes',
              cmd     => CMD_nodes,
              postfix => '_shutdown',
              qs      => { delay => ['duration'] }
          },
          @_
      );
  }
  
  #===================================
  sub restart {
  #===================================
      shift()->_do_action(
          'shutdown',
          {   method  => 'POST',
              prefix  => '_cluster/nodes',
              cmd     => CMD_nodes,
              postfix => '_restart',
              qs      => { delay => ['duration'] }
          },
          @_
      );
  }
  
  #===================================
  sub cluster_health {
  #===================================
      shift()->_do_action(
          'cluster_health',
          {   prefix => '_cluster/health',
              cmd    => CMD_index,
              qs     => {
                  level           => [ 'enum', [qw(cluster indices shards)] ],
                  wait_for_status => [ 'enum', [qw(green yellow red)] ],
                  wait_for_relocating_shards => ['int'],
                  wait_for_nodes             => ['string'],
                  timeout                    => ['duration']
              }
          },
          @_
      );
  }
  
  #===================================
  sub cluster_settings {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $self->_do_action(
          'cluster_settings',
          {   method  => 'GET',
              cmd     => CMD_NONE,
              postfix => '_cluster/settings'
          },
          $params
      );
  }
  
  #===================================
  sub update_cluster_settings {
  #===================================
      my ( $self, $params ) = parse_params(@_);
  
      $self->_do_action(
          'update_cluster_settings',
          {   method  => 'PUT',
              cmd     => CMD_NONE,
              postfix => '_cluster/settings',
              data    => {
                  persistent => ['persistent'],
                  transient  => ['transient']
              }
          },
          $params
      );
  }
  
  #===================================
  sub cluster_reroute {
  #===================================
      my ( $self, $params ) = parse_params(@_);
      $params->{commands} = [ $params->{commands} ]
          if $params->{commands} and ref( $params->{commands} ) ne 'ARRAY';
  
      $self->_do_action(
          'cluster_reroute',
          {   prefix => '_cluster/reroute',
              cmd    => [],
              method => 'POST',
              data   => { commands => ['commands'] },
              qs     => { dry_run => [ 'boolean', 1 ], },
          },
          $params
      );
  }
  
  ##################################
  ## FLAGS
  ##################################
  
  #===================================
  sub camel_case {
  #===================================
      my $self = shift;
      if (@_) {
          if ( shift() ) {
              $self->{_base_qs}{case} = 'camelCase';
          }
          else {
              delete $self->{_base_qs}{case};
          }
      }
      return $self->{_base_qs}{case} ? 1 : 0;
  }
  
  #===================================
  sub error_trace {
  #===================================
      my $self = shift;
      if (@_) {
          if ( shift() ) {
              $self->{_base_qs}{error_trace} = 'true';
          }
          else {
              delete $self->{_base_qs}{error_trace};
          }
      }
      return $self->{_base_qs}{error_trace} ? 1 : 0;
  }
  
  ##################################
  ## INTERNAL
  ##################################
  
  #===================================
  sub _do_action {
  #===================================
      my $self            = shift;
      my $action          = shift || '';
      my $defn            = shift || {};
      my $original_params = $self->parse_params(@_);
  
      my $error;
  
      my $params = {%$original_params};
      my %args = ( method => $defn->{method} || 'GET' );
      $args{as_json} = delete $params->{as_json};
  
      eval {
          $args{cmd}
              = $self->_build_cmd( $params, @{$defn}{qw(prefix cmd postfix)} );
          $args{qs} = $self->_build_qs( $params, $defn->{qs} );
          $args{data}
              = $self->_build_data( $params, @{$defn}{ 'data', 'deprecated' } );
          if ( my $fixup = $defn->{fixup} ) {
              $fixup->( $self, \%args );
          }
          die "Unknown parameters: " . join( ', ', keys %$params ) . "\n"
              if keys %$params;
          1;
      } or $error = $@ || 'Unknown error';
  
      $args{post_process} = $defn->{post_process};
      if ($error) {
          die $error if ref $error;
          $self->throw(
              'Param',
              $error . $self->_usage( $action, $defn ),
              { params => $original_params }
          );
      }
      if ( my $skip = $args{skip} ) {
          return $self->transport->skip_request( $args{as_json}, $skip );
      }
      return $self->request( \%args );
  }
  
  #===================================
  sub _usage {
  #===================================
      my $self   = shift;
      my $action = shift;
      my $defn   = shift;
  
      my $usage = "Usage for '$action()':\n";
      my @cmd = @{ $defn->{cmd} || [] };
      while ( my $key = shift @cmd ) {
          my $type = shift @cmd;
          my $arg_format
              = $type == ONE_REQ ? "\$$key"
              : $type == ONE_OPT ? "\$$key"
              :                    "\$$key | [\$${key}_1,\$${key}_n]";
  
          my $required
              = ( $type == ONE_REQ or $type == MULTI_REQ )
              ? 'required'
              : 'optional';
          $usage .= sprintf( "  - %-26s =>  %-45s # %s\n",
              $key, $arg_format, $required );
      }
  
      if ( my $data = $defn->{data} ) {
          my @keys = sort { $a->[0] cmp $b->[0] }
              map { ref $_ ? [ $_->[0], 'optional' ] : [ $_, 'required' ] }
              values %$data;
  
          for (@keys) {
              $usage .= sprintf(
                  "  - %-26s =>  %-45s # %s\n",
                  $_->[0], '{' . $_->[0] . '}',
                  $_->[1]
              );
          }
      }
  
      if ( my $qs = $defn->{qs} ) {
          for ( sort keys %$qs ) {
              my $arg_format = $QS_Format{ $qs->{$_}[0] };
              my @extra;
              $arg_format = $arg_format->( $_, $qs->{$_} )
                  if ref $arg_format;
              if ( length($arg_format) > 45 ) {
                  ( $arg_format, @extra ) = split / [|] /, $arg_format;
              }
              $usage .= sprintf( "  - %-26s =>  %-45s # optional\n", $_,
                  $arg_format );
              $usage .= ( ' ' x 34 ) . " | $_\n" for @extra;
          }
      }
  
      return $usage;
  }
  
  #===================================
  sub _build_qs {
  #===================================
      my $self   = shift;
      my $params = shift;
      my $defn   = shift || {};
      my %qs     = %{ $self->{_base_qs} };
      foreach my $key ( keys %$defn ) {
          my ( $format_name, @args ) = @{ $defn->{$key} || [] };
          $format_name ||= '';
  
          next unless exists $params->{$key};
  
          my $formatter = $QS_Formatter{$format_name}
              or die "Unknown QS formatter '$format_name'";
  
          my $val = $formatter->( $key, delete $params->{$key}, @args )
              or next;
          $qs{ $val->[0] } = $val->[1];
      }
      return \%qs;
  }
  
  #===================================
  sub _build_data {
  #===================================
      my $self   = shift;
      my $params = shift;
      my $defn   = shift or return;
  
      if ( my $deprecated = shift ) {
          $defn = { %$defn, %$deprecated };
      }
  
      my %data;
  KEY: while ( my ( $key, $source ) = each %$defn ) {
          next unless defined $source;
          if ( ref $source eq 'ARRAY' ) {
              foreach (@$source) {
                  my $val = delete $params->{$_};
                  next unless defined $val;
                  $data{$key} = $val;
                  next KEY;
              }
          }
          else {
              $data{$key} = delete $params->{$source}
                  or die "Missing required param '$source'\n";
          }
      }
      return \%data;
  }
  
  #===================================
  sub _build_cmd {
  #===================================
      my $self   = shift;
      my $params = shift;
      my ( $prefix, $defn, $postfix ) = @_;
  
      my @defn = ( @{ $defn || [] } );
      my @cmd;
      while (@defn) {
          my $key  = shift @defn;
          my $type = shift @defn;
  
          my $val
              = exists $params->{$key}
              ? delete $params->{$key}
              : $self->{_default}{$key};
  
          $val = '' unless defined $val;
  
          if ( ref $val eq 'ARRAY' ) {
              die "'$key' must be a single value\n"
                  if $type <= ONE_ALL;
              $val = join ',', @$val;
          }
          unless ( length $val ) {
              next if $type == ONE_OPT || $type == MULTI_BLANK;
              die "Param '$key' is required\n"
                  if $type == ONE_REQ || $type == MULTI_REQ;
              $val = '_all';
          }
          push @cmd, uri_escape($val);
      }
  
      return join '/', '', grep {defined} ( $prefix, @cmd, $postfix );
  }
  1;
ELASTICSEARCH_REQUESTPARSER

$fatpacked{"ElasticSearch/ScrolledSearch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_SCROLLEDSEARCH';
  package ElasticSearch::ScrolledSearch;
  $ElasticSearch::ScrolledSearch::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all', NONFATAL => 'redefine';
  
  use ElasticSearch::Util qw(parse_params);
  
  =head1 NAME
  
  ElasticSearch::ScrolledSearch - Description
  
  =head1 SYNOPSIS
  
      $scroller = $es->scrolled_search($search_params);
    OR
      $scroller = ElasticSearch::ScrolledSearch($es,$search_params);
  
      while (my $result = $scroller->next) {
          # do something
      }
  
      $total  = $scroller->total;
      $bool   = $scroller->eof
      $score  = $scroller->max_score;
      $facets = $scroller->facets;
  
  =head1 DESCRIPTION
  
  C<ElasticSearch::ScrolledSearch> is a convenience iterator for scrolled
  searches. It accepts the standard search parameters that would be passed
  to L<ElasticSearch/"search()">. The C<scroll> parameter defaults to C<1m>.
  
      $scroller = $es->scrolled_search(
                      query  => {match_all=>{}},
                      scroll => '5m'               # keep the scroll request
                                                   # live for 5 minutes
                  );
  
  =head1 METHODS
  
  =head2 C<new()>
  
      $scroller = $es->scrolled_search($search_params);
    OR
      $scroller = ElasticSearch::ScrolledSearch($es,$search_params);
  
  =cut
  
  #===================================
  sub new {
  #===================================
      my $class = shift;
      my ( $es, $params ) = parse_params(@_);
  
      my $scroll = $params->{scroll} ||= '1m';
      my $method  = $params->{q} ? 'searchqs' : 'search';
      my $as_json = delete $params->{as_json};
      my $results = $es->$method($params);
      $results = $results->recv
          if ref $results ne 'HASH' and $results->isa('AnyEvent::CondVar');
      my $self = {
          _es        => $es,
          _scroll_id => $results->{_scroll_id},
          _scroll    => $scroll,
          _total     => $results->{hits}{total},
          _buffer    => $results->{hits}{hits},
          _max_score => $results->{hits}{max_score},
          _facets    => $results->{facets},
          _eof       => 0,
          _as_json   => $as_json,
      };
      return bless( $self, $class );
  }
  
  =head2 next()
  
      @results = $scroller->next()
      @results = $scroller->next($no_of_results);
  
  Returns the next result, or the next C<$no_of_results> or an empty list when
  no more results are available.
  
  An error is thrown if the C<scroll> has already expired.
  
  If C<< as_json => 1 >> is specified, then L</"next()"> will always return
  a JSON array:
  
     $scroller->next()
     # '[{...}]'
  
     $scroller->next(2)
     # '[{...},{...}]'
  
     # if no results left: '[]'
  
  =cut
  
  #===================================
  sub next {
  #===================================
      my $self = shift;
      my $size = shift || 1;
      while ( @{ $self->{_buffer} } < $size && !$self->{_eof} ) {
          $self->refill_buffer;
      }
      my @results = splice @{ $self->{_buffer} }, 0, $size;
      return $self->{_as_json}
          ? $self->{_es}->transport->JSON->encode( \@results )
          : $size == 1 ? $results[0]
          :              @results;
  }
  
  =head2 drain_buffer()
  
      @docs = $scroller->drain_buffer;
  
  Returns and removes all docs that are currently stored in the buffer.
  
  =cut
  
  #===================================
  sub drain_buffer {
  #===================================
      my $self = shift;
      if ( my $size = @{ $self->{_buffer} } ) {
          return $self->next($size);
      }
      return $self->{_as_json} ? '[]' : ();
  }
  
  =head2 refill_buffer()
  
      $buffer_size = $scroller->refill_buffer
  
  Pulls the next set of results from ElasticSearch (if any) and returns
  the total number of docs stored in the internal buffer.
  
  =cut
  
  #===================================
  sub refill_buffer {
  #===================================
      my $self = shift;
      unless ( $self->{_eof} ) {
          my $results = $self->{_es}->scroll(
              scroll    => $self->{_scroll},
              scroll_id => $self->{_scroll_id}
          );
          $results = $results->recv
              if ref $results ne 'HASH' and $results->isa('AnyEvent::CondVar');
          my @hits = @{ $results->{hits}{hits} };
          $self->{_eof}++ if @hits == 0;
          $self->{_scroll_id} = $results->{_scroll_id};
          push @{ $self->{_buffer} }, @hits;
      }
      return scalar @{ $self->{_buffer} };
  }
  
  =head2 total()
  
      $total = $scroller->total
  
  The total number of hits
  
  =head2 max_score()
  
      $score = $scroller->max_score
  
  The C<max_score> returned from the first search request (if available).
  
  =head2 eof()
  
      $bool = $scroller->eof
  
  Returns C<true> if no more results are available. Note: if no results
  match the search, then C<eof()> could be C<false> but the first call
  to C<next()> will return zero results.
  
  =cut
  
  #===================================
  sub total     { shift->{_total} }
  sub max_score { shift->{_max_score} }
  sub eof       { shift->{_eof} }
  #===================================
  
  =head2 facets()
  
      $facets = $scroller->facets
  
  The C<facets> returned from the first search request (if any).
  
  If C<< as_json => 1 >> is specified, then L</"facets()"> will always return
  a JSON object.
  
  =cut
  
  #===================================
  sub facets {
  #===================================
      my $self = shift;
      return $self->{_as_json}
          ? $self->{_es}->transport->JSON->encode( $self->{_facets} || {} )
          : $self->{_facets}
  
  }
  
  =head1 SEE ALSO
  
  L<ElasticSearch/"scrolled_search()">, L<ElasticSearch/"search()"> and
  L<ElasticSearch/"scroll()">
  
  =head1 BUGS
  
  None known
  
  =head1 AUTHOR
  
  Clinton Gormley, E<lt>clinton@traveljury.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2011 by Clinton Gormley
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.7 or,
  at your option, any later version of Perl 5 you may have available.
  
  
  =cut
  
  1
ELASTICSEARCH_SCROLLEDSEARCH

$fatpacked{"ElasticSearch/TestServer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_TESTSERVER';
  package ElasticSearch::TestServer;
  $ElasticSearch::TestServer::VERSION = '0.68';
  use strict;
  use warnings;
  use ElasticSearch();
  use POSIX 'setsid';
  use IO::Socket();
  use File::Temp 0.22 ();
  use File::Spec::Functions qw(catfile);
  use YAML qw(DumpFile);
  use File::Path qw(rmtree);
  
  use parent 'ElasticSearch';
  
  =head1 NAME
  
  ElasticSearch::TestServer - Start an ElasticSearch cluster for testing
  
  =head1 SYNOPSIS
  
      use ElasticSearch::TestServer;
  
      $ENV{ES_HOME} = '/path/to/elasticsearch';
      $ENV{ES_TRANSPORT} = 'http';
  
      my $es = ElasticSearch::TestServer->new(
          home        => '/path/to/elasticsearch',
          instances   => 3,
          transport   => 'http',
          ip          => '127.0.0.1',
          trace_calls => 'logfile',
          port        => '9200',
          config      => { values to override}
      );
  
  =head1 DESCRIPTION
  
  ElasticSearch::TestServer is a utility module which will start an
  ElasticSearch cluster intended for testing, and shut the cluster
  down at the end, even if your code exits abnormally.
  
  By default, it uses C<http> transport, the C<local> gateway, and
  starts 3 instances on C<localhost>, starting with C<port> 9200 if
  the C<transport> is C<http>, C<httplite>, C<httptiny>, C<curl>, C<aehttp>
   or 9500 if C<thrift>.
  
  It is a subclass of L<ElasticSearch>, so C<< ElasticSearch::TestServer->new >>
  returns an ElasticSearch instance.
  
  =cut
  
  #===================================
  sub new {
  #===================================
      my $class  = shift;
      my %params = (
          home      => $ENV{ES_HOME},
          transport => $ENV{ES_TRANSPORT} || 'http',
          instances => 3,
          ip        => '127.0.0.1',
          ref $_[0] eq 'HASH' ? %{ shift() } : @_
      );
  
      my $home = delete $params{home} or die <<NO_HOME;
  
  ************************************************************
      ElasticSearch home directory not specified
  
      Please either set \$ENV{ES_HOME} or pass a value
      for 'home' to new()
  
  ************************************************************
  
  NO_HOME
  
      my $transport = $params{transport};
      my $port      = delete $params{port}
          || ( $transport eq 'thrift' ? 9500 : 9200 );
      my $instances = delete $params{instances};
      my $plugin    = $ElasticSearch::Transport::Transport{$transport}
          or die "Unknown transport '$transport'";
      eval "require  $plugin" or die $@;
      $plugin->_make_sync if $plugin->can('_make_sync');
      my $protocol = $plugin->protocol;
  
      my %config = (
          cluster => { name => 'es_test' },
          gateway => { type => 'local', expected_nodes => $instances },
          network => { host => 'localhost' },
          "$protocol.port" => "$port-" . ( $port + $instances - 1 ),
          %{ $params{config} || {} }
      );
  
      my $ip = $config{network}{host} = delete $params{ip};
      my @servers = map {"$ip:$_"} $port .. $port + $instances - 1;
      my @publish = map {"$ip:$_"} 9300 .. 9300 + $instances - 1;
      $config{'discovery.zen.ping.unicast.hosts'} = \@publish;
  
      foreach (@servers) {
          if ( IO::Socket::INET->new($_) ) {
              die <<RUNNING;
  
  ************************************************************
  
      There is already a server running on $_.
      Please shut it down before starting the test server
  
  ************************************************************
  RUNNING
          }
      }
  
      my $server = $servers[0];
  
      print "Starting test server installed in $home\n";
  
      my $cmd          = catfile( $home, 'bin', 'elasticsearch' );
      my $pid_file     = File::Temp->new;
      my $blank_config = File::Temp->new( SUFFIX => '.yml' );
      my $config_path  = $blank_config->filename();
  
      my $dir     = '';
      my $dirname = '';
      my $PIDs    = [];
  
      unless ( $config{path}{data} ) {
          $dir = File::Temp->newdir(
              'elastic_XXXXX',
              CLEANUP => 0,
              TMPDIR  => 1
          );
          $dirname = $config{path}{data} = $dir->dirname;
      }
  
      my $old_SIGINT = $SIG{INT};
      my $new_SIGINT = sub {
          $class->_shutdown_servers( $PIDs, $dirname );
          if ( ref $old_SIGINT eq 'CODE' ) {
              return $old_SIGINT->();
          }
          exit(1);
      };
      $SIG{INT} = $new_SIGINT;
  
      DumpFile( $blank_config->filename, \%config );
  
      for ( 1 .. $instances ) {
          print "Starting test node $_\n";
          my $int_caught = 0;
          local $SIG{INT} = sub { $int_caught++; };
          defined( my $pid = fork ) or die "Couldn't fork a new process: $!";
          if ( $pid == 0 ) {
              die "Can't start a new session: $!" if setsid == -1;
              exec( $cmd, '-p', $pid_file->filename,
                  '-Des.config=' . $config_path );
          }
          else {
              sleep 1;
              open my $pid_fh, '<', $pid_file->filename;
              my $pid = <$pid_fh>;
              die "ES is running, but no PID found" unless $pid;
              chomp $pid;
              push @$PIDs, $pid;
          }
          $new_SIGINT->() if $int_caught;
      }
  
      print "Waiting for servers to warm up\n";
  
      my $timeout = 20;
      while (@servers) {
          if ( IO::Socket::INET->new( $servers[0] ) ) {
              print "Node running on $servers[0]\n";
              shift @servers;
          }
          else {
              sleep 1;
          }
          $timeout--;
          last if $timeout == 0;
      }
      if (@servers) {
          eval { $class->_shutdown_servers( $PIDs, $dirname ) };
          die "Couldn't start $instances nodes for transport $transport";
      }
  
      my $es = eval {
          $class->SUPER::new(
              %params,
              servers     => $server,
              trace_calls => $params{trace_calls},
              transport   => $transport,
              pids        => $PIDs,
              tmpdir      => $dirname,
          );
      };
      unless ($es) {
          my $error = $@;
          $class->_shutdown_servers( $PIDs, $dirname );
          die $error;
      }
  
      my $attempts = 20;
      while (1) {
          eval { @{ $es->refresh_servers } == $instances } && last;
          die("**** Couldn't connect to ElasticSearch at $server ****\n")
              unless --$attempts;
          print "Connection failed. Retrying\n";
          sleep 1;
      }
      print "Connected\n";
  
      return $es;
  }
  
  #===================================
  sub pids {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_pids} = shift;
      }
      return $self->{_pids};
  }
  
  #===================================
  sub tmpdir {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_tmpdir} = shift;
      }
      return $self->{_tmpdir};
  }
  
  #===================================
  sub _shutdown_servers {
  #===================================
      my ( $self, $PIDs, $dir ) = @_;
  
      local $?;
  
      $PIDs = $self->pids   unless defined $PIDs;
      $dir  = $self->tmpdir unless defined $dir;
  
      return unless $PIDs;
  
      kill 9, @$PIDs;
      sleep 1;
  
      while (1) { last if wait == -1 }
      if ( defined $dir ) {
          rmtree( $dir, { error => \my $error } );
      }
      undef $dir;
  }
  
  sub DESTROY { shift->_shutdown_servers; }
  
  =head1 AUTHOR
  
  Clinton Gormley, E<lt>clinton@traveljury.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2011 by Clinton Gormley
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.7 or,
  at your option, any later version of Perl 5 you may have available.
  
  
  =cut
  
  1
ELASTICSEARCH_TESTSERVER

$fatpacked{"ElasticSearch/Transport.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_TRANSPORT';
  package ElasticSearch::Transport;
  $ElasticSearch::Transport::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use ElasticSearch::Util qw(throw build_error parse_params);
  use URI();
  use JSON();
  use Encode qw(decode_utf8);
  use Scalar::Util qw(openhandle);
  use List::Util qw(shuffle min);
  use IO::Handle();
  
  our %Transport = (
      'http'     => 'ElasticSearch::Transport::HTTP',
      'httplite' => 'ElasticSearch::Transport::HTTPLite',
      'thrift'   => 'ElasticSearch::Transport::Thrift',
      'httptiny' => 'ElasticSearch::Transport::HTTPTiny',
      'curl'     => 'ElasticSearch::Transport::Curl',
      'aehttp'   => 'ElasticSearch::Transport::AEHTTP',
      'aecurl'   => 'ElasticSearch::Transport::AECurl',
  );
  
  our %Min_Versions = (
      'ElasticSearch::Transport::Thrift' => '0.03',
      'ElasticSearch::Transport::Curl'   => '0.07',
      'ElasticSearch::Transport::AEHTTP' => '0.06',
      'ElasticSearch::Transport::AECurl' => '0.06',
  );
  
  #===================================
  sub new {
  #===================================
      my $class           = shift;
      my $params          = shift;
      my $transport_name  = delete $params->{transport} || 'http';
      my $transport_class = $Transport{$transport_name}
          or $class->throw(
          'Param',
          "Unknown transport '$transport_name'",
          { Available => \%Transport }
          );
  
      eval "require  $transport_class" or $class->throw( "Internal", $@ );
      if ( my $min = $Min_Versions{$transport_class} ) {
          my $version = $transport_class->VERSION;
          $class->throw( 'Internal',
              "$transport_class v$min required but v$version installed." )
              unless $version ge $min;
      }
  
      my $self = bless {
          _JSON               => JSON->new(),
          _timeout            => 120,
          _max_requests       => 10_000,
          _max_content_length => 104_857_600,
          _failed             => {},
          },
          $transport_class;
  
      my $servers = delete $params->{servers}
          || '127.0.0.1:' . $transport_class->default_port;
  
      $self->{_default_servers}
          = [ shuffle( ref $servers eq 'ARRAY' ? @$servers : $servers ) ];
  
      for (qw(timeout max_requests no_refresh deflate max_content_length)) {
          next unless exists $params->{$_};
          $self->$_( delete $params->{$_} );
      }
      $self->init($params);
      return $self;
  }
  
  #===================================
  sub init { shift() }
  #===================================
  
  #===================================
  sub request {
  #===================================
      my $self          = shift;
      my $params        = shift;
      my $single_server = shift;
  
      my $args = $self->_tidy_params($params);
      $self->reset_failed_servers();
  
      my $json;
      while (1) {
          my $srvr = $single_server || $self->next_server;
          $self->log_request( $srvr, $args ) unless $single_server;
  
          $json = eval { $self->send_request( $srvr, $args ) || '{"ok":true}' }
              and last;
  
          my $error = $@ || 'Unknown error';
          next if !$single_server && $self->should_retry( $srvr, $error );
          $error = $self->_handle_error( $srvr, $params, $error )
              or return;
          die $error;
      }
      return $self->_response( $json, $params, $single_server );
  
  }
  
  #===================================
  sub _response {
  #===================================
      my $self          = shift;
      my $response_json = shift;
      my $params        = shift;
      my $skip_log      = shift;
  
      my $as_json      = $params->{as_json};
      my $post_process = $params->{post_process};
  
      my $result;
      $result = $self->JSON->decode($response_json)
          unless $as_json && !$post_process && $skip_log;
  
      $self->log_response( $result || $response_json )
          unless $skip_log;
  
      if ($post_process) {
          $result = $post_process->($result);
          if ($as_json) {
              $response_json = $self->JSON->encode($result);
              $result        = undef;
          }
      }
  
      return $as_json ? $response_json : $result;
  }
  
  #===================================
  sub skip_request {
  #===================================
      my $self    = shift;
      my $as_json = shift;
      my $result  = shift;
      return $result unless $as_json;
      return $self->JSON->encode($result);
  }
  
  #===================================
  sub should_retry {
  #===================================
      my $self   = shift;
      my $server = shift;
      my $error  = shift;
  
      return unless $error->isa('ElasticSearch::Error::Connection');
  
      warn "Error connecting to '$server' : "
          . ( $error->{-text} || 'Unknown' ) . "\n\n";
  
      if ( $self->no_refresh || $error->isa('ElasticSearch::Error::NotReady') )
      {
          $self->_remove_server($server);
      }
      else {
          $self->{_refresh_in} = 0;
      }
  
      return 1;
  }
  
  #===================================
  sub _handle_error {
  #===================================
      my $self   = shift;
      my $server = shift;
      my $params = shift;
      my $error  = shift || 'Unknown error';
  
      $error = build_error( $self, 'Request', $error, { request => $params } )
          unless ref $error;
  
      return
          if $error->isa('ElasticSearch::Error::Missing')
          && $params->{qs}{ignore_missing};
  
      $error->{-vars}{request} = $params;
  
      if ( my $raw = $error->{-vars}{content} ) {
          $error->{-vars}{current_version} = $1
              if $error->isa('ElasticSearch::Error::Conflict')
              and $raw =~ /: version conflict, current \[(\d+)\]/;
  
          my $content = eval { $self->JSON->decode($raw) } || $raw;
          $self->log_response($content);
          if ( ref $content and $content->{error} ) {
              $error->{-text} = $content->{error};
              $error->{-vars}{error_trace} = $content->{error_trace}
                  if $content->{error_trace};
              delete $error->{-vars}{content};
          }
      }
      return $error;
  }
  
  #===================================
  sub _tidy_params {
  #===================================
      my $self   = shift;
      my $params = shift;
  
      $params->{method} ||= 'GET';
      $params->{cmd}    ||= '/';
      $params->{qs}     ||= {};
  
      my $data = $params->{data};
      $data
          = ref $data eq 'SCALAR'
          ? $$data
          : $self->JSON->encode($data)
          if $data;
  
      return { data => $data, map { $_ => $params->{$_} } qw(method cmd qs) };
  }
  
  #===================================
  sub refresh_servers {
  #===================================
      my $self = shift;
  
      $self->{_refresh_in} = 0;
      delete $self->{_current_server};
  
      my %servers = map { $_ => 1 }
          ( @{ $self->servers }, @{ $self->default_servers } );
  
      my @all_servers = keys %servers;
      my $protocol    = $self->protocol;
  
      foreach my $server (@all_servers) {
          next unless $server;
  
          my $nodes = eval {
              $self->request( { cmd => '/_cluster/nodes', qs => { http => 1 } },
                  $server );
          }
              or next;
  
          my @servers = grep {$_}
              map {m{/([^]]+)}}
              map {
                     $_->{ $protocol . '_address' }
                  || $_->{ $protocol . 'Address' }
                  || ''
              } values %{ $nodes->{nodes} };
          next unless @servers;
  
          if ( $protocol eq 'http' ) {
              my $content_length = min( $self->max_content_length,
                  grep {$_} map { $_->{http}{max_content_length_in_bytes} }
                      values %{ $nodes->{nodes} } );
              $self->max_content_length($content_length);
          }
  
          @servers = shuffle(@servers);
  
          $self->{_refresh_in} = $self->max_requests - 1;
          return $self->servers( \@servers );
      }
  
      $self->throw(
          'NoServers',
          "Could not retrieve a list of active servers:\n$@",
          { servers => \@all_servers }
      );
  }
  
  #===================================
  sub next_server {
  #===================================
      my $self = shift;
      unless ( $self->{_refresh_in}-- ) {
          if ( $self->no_refresh ) {
              $self->servers( $self->default_servers );
              $self->{_refresh_in} = $self->max_requests - 1;
              $self->reset_failed_servers();
          }
          else {
              $self->refresh_servers;
          }
      }
  
      my @servers = @{ $self->servers };
  
      unless (@servers) {
          my $failed = $self->{_failed};
          @servers = grep { !$failed->{$_} } @{ $self->default_servers };
          unless (@servers) {
              $self->{_refresh_in} = 0;
              $self->throw(
                  "NoServers",
                  "No servers available:\n",
                  { servers => $self->default_servers }
              );
          }
  
      }
  
      my $next = shift(@servers);
  
      $self->{_current_server} = { $$ => $next };
      $self->servers( @servers, $next );
      return $next;
  }
  
  #===================================
  sub _remove_server {
  #===================================
      my $self   = shift;
      my $server = shift;
      $self->{_failed}{$server}++;
      my @servers = grep { $_ ne $server } @{ $self->servers };
      $self->servers( \@servers );
  }
  
  #===================================
  sub reset_failed_servers {
  #===================================
      my $self = shift;
      $self->{_failed} = {};
  }
  
  #===================================
  sub current_server {
  #===================================
      my $self = shift;
      return $self->{_current_server}{$$} || $self->next_server;
  }
  
  #===================================
  sub servers {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_servers} = ref $_[0] eq 'ARRAY' ? shift : [@_];
      }
      return $self->{_servers} ||= [];
  }
  
  #===================================
  sub max_requests {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_max_requests} = shift;
      }
      return $self->{_max_requests} || 0;
  }
  
  #===================================
  sub max_content_length {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_max_content_length} = shift;
      }
      return $self->{_max_content_length} || 0;
  }
  
  #===================================
  sub check_content_length {
  #===================================
      my $self   = shift;
      my $length = length ${ $_[0] };
      return unless $length > $self->max_content_length;
  
      my $msg
          = "Content length ($length) greater than max_content_length ("
          . $self->max_content_length
          . ") for request:\n"
          . substr( ${ $_[0] }, 0, 500 ) . '...';
      $self->throw( 'Request', $msg );
  }
  
  #===================================
  sub default_servers { shift->{_default_servers} }
  #===================================
  
  #===================================
  sub http_uri {
  #===================================
      my $self   = shift;
      my $server = shift;
      my $cmd    = shift;
      $cmd = '' unless defined $cmd;
      my $uri = URI->new( 'http://' . $server . $cmd );
      $uri->query_form(shift) if $_[0];
      return $uri->as_string;
  }
  
  #===================================
  sub inflate {
  #===================================
      my $self    = shift;
      my $content = shift;
      my $output;
      require IO::Uncompress::Inflate;
  
      no warnings 'once';
      IO::Uncompress::Inflate::inflate( \$content, \$output, Transparent => 0 )
          or die "Couldn't inflate response: "
          . $IO::Uncompress::Inflate::InflateError;
      return $output;
  }
  
  #===================================
  sub timeout {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_timeout} = shift;
          $self->clear_clients;
      }
      return $self->{_timeout} || 0;
  }
  
  #===================================
  sub deflate {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_deflate} = shift;
          $self->clear_clients;
      }
      return $self->{_deflate} || 0;
  }
  
  #===================================
  sub no_refresh {
  #===================================
      my $self = shift;
      if (@_) {
          $self->{_no_refresh} = !!shift();
      }
      return $self->{_no_refresh} || 0;
  }
  
  #===================================
  sub trace_calls {
  #===================================
      my $self = shift;
      if (@_) {
          delete $self->{_log_fh};
          $self->{_trace_calls} = shift;
          $self->JSON->pretty( !!$self->{_trace_calls} );
  
      }
      return $self->{_trace_calls};
  }
  
  #===================================
  sub _log_fh {
  #===================================
      my $self = shift;
      unless ( exists $self->{_log_fh}{$$} ) {
          my $log_fh;
          if ( my $file = $self->trace_calls ) {
              $file = \*STDERR if $file eq 1;
              my $open_mode = '>>';
              if ( openhandle($file) ) {
                  $open_mode = '>>&';
              }
              else {
                  $file .= ".$$";
              }
              open $log_fh, $open_mode, $file
                  or $self->throw( 'Internal',
                  "Couldn't open '$file' for trace logging: $!" );
              binmode( $log_fh, ':utf8' );
              $log_fh->autoflush(1);
          }
          $self->{_log_fh}{$$} = $log_fh;
      }
      return $self->{_log_fh}{$$};
  }
  
  #===================================
  sub log_request {
  #===================================
      my $self   = shift;
      my $log    = $self->_log_fh or return;
      my $server = shift;
      my $params = shift;
  
      my $data = $params->{data};
      if ( defined $data and $data ne "{}\n" ) {
          $data =~ s/'/\\u0027/g;
          $data = " -d '\n${data}'";
      }
      else {
          $data = '';
      }
  
      printf $log (
          "# [%s] Protocol: %s, Server: %s\n",
          scalar localtime(),
          $self->protocol, ${server}
      );
      my %qs = ( %{ $params->{qs} }, pretty => 1 );
      my $uri = $self->http_uri( '127.0.0.1:9200', $params->{cmd}, \%qs );
  
      my $method = $params->{method};
      print $log "curl -X$method '$uri' ${data}\n\n";
  }
  
  #===================================
  sub log_response {
  #===================================
      my $self    = shift;
      my $log     = $self->_log_fh or return;
      my $content = shift;
      my $out     = ref $content ? $self->JSON->encode($content) : $content;
      my @lines   = split /\n/, $out;
      printf $log ( "# [%s] Response:\n", scalar localtime() );
      while (@lines) {
          my $line = shift @lines;
          if ( length $line > 65 ) {
              my ($spaces) = ( $line =~ /^(?:> )?(\s*)/ );
              $spaces = substr( $spaces, 0, 20 ) if length $spaces > 20;
              unshift @lines, '> ' . $spaces . substr( $line, 65 );
              $line = substr $line, 0, 65;
          }
          print $log "# $line\n";
      }
      print $log "\n";
  }
  
  #===================================
  sub clear_clients {
  #===================================
      my $self = shift;
      delete $self->{_client};
  }
  
  #===================================
  sub JSON { shift()->{_JSON} }
  #===================================
  
  my %Statuses = (
      100 => 'CONT',
      101 => 'SWITCHING_PROTOCOLS',
      200 => 'OK',
      201 => 'CREATED',
      202 => 'ACCEPTED',
      203 => 'NON_AUTHORITATIVE_INFORMATION',
      204 => 'NO_CONTENT',
      205 => 'RESET_CONTENT',
      206 => 'PARTIAL_CONTENT',
      207 => 'MULTI_STATUS',
      300 => 'MULTIPLE_CHOICES',
      301 => 'MOVED_PERMANENTLY',
      302 => 'FOUND',
      303 => 'SEE_OTHER',
      304 => 'NOT_MODIFIED',
      305 => 'USE_PROXY',
      307 => 'TEMPORARY_REDIRECT',
      400 => 'BAD_REQUEST',
      401 => 'UNAUTHORIZED',
      402 => 'PAYMENT_REQUIRED',
      403 => 'FORBIDDEN',
      404 => 'NOT_FOUND',
      405 => 'METHOD_NOT_ALLOWED',
      406 => 'NOT_ACCEPTABLE',
      407 => 'PROXY_AUTHENTICATION',
      408 => 'REQUEST_TIMEOUT',
      409 => 'CONFLICT',
      410 => 'GONE',
      411 => 'LENGTH_REQUIRED',
      412 => 'PRECONDITION_FAILED',
      413 => 'REQUEST_ENTITY_TOO_LARGE',
      414 => 'REQUEST_URI_TOO_LONG',
      415 => 'UNSUPPORTED_MEDIA_TYPE',
      416 => 'REQUESTED_RANGE_NOT_SATISFIED',
      417 => 'EXPECTATION_FAILED',
      422 => 'UNPROCESSABLE_ENTITY',
      423 => 'LOCKED',
      424 => 'FAILED_DEPENDENCY',
      500 => 'INTERNAL_SERVER_ERROR',
      501 => 'NOT_IMPLEMENTED',
      502 => 'BAD_GATEWAY',
      503 => 'SERVICE_UNAVAILABLE',
      504 => 'GATEWAY_TIMEOUT',
      506 => 'INSUFFICIENT_STORAGE',
  );
  
  #===================================
  sub http_status {
  #===================================
      my $code = $_[1] || 0;
      return $Statuses{$code} || 'Unknown code ' . $code;
  }
  
  my %Code_To_Error = (
      409 => 'Conflict',
      404 => 'Missing',
      403 => 'ClusterBlocked',
      503 => 'NotReady'
  );
  
  #===================================
  sub code_to_error {
  #===================================
      my $self = shift;
      my $code = shift || return;
      return $Code_To_Error{$code};
  }
  
  #===================================
  sub register {
  #===================================
      my $class = shift;
      my $name  = shift
          || $class->throw( 'Param',
          'No transport name passed to register_transport()' );
      my $module = shift
          || $class->throw( 'Param',
          'No module name passed to register_transport()' );
      return $Transport{$name} = $module;
  }
  
  =head1 NAME
  
  ElasticSearch::Transport - Base class for communicating with ElasticSearch
  
  =head1 DESCRIPTION
  
  ElasticSearch::Transport is a base class for the modules which communicate
  with the ElasticSearch server.
  
  It handles failover to the next node in case the current node closes
  the connection.
  
  All requests are round-robin'ed to all live servers as returned by
  C</_cluster/nodes>, except we C<shuffle> the server list when we
  retrieve it, and thus avoid having all our instances make their first
  request to the same server.
  
  On the first request and every C<max_requests> after that (default 10,000),
  the list of live nodes is automatically refreshed.  This can be disabled
  by setting C<max_requests> to C<0>.
  
  Regardless of the C<max_requests> setting, a list of live nodes will still be
  retrieved on the first request.  This may not be desirable behaviour
  if, for instance, you are connecting to remote servers which use internal
  IP addresses, or which don't allow remote C<nodes()> requests.
  
  If you want to disable this behaviour completely, set C<no_refresh> to C<1>,
  in which case the transport module will round robin through the
  C<servers> list only. Failed nodes will be removed from the list
  (but added back in every C<max_requests> or when all nodes have failed):
  
  The HTTP clients check that the post body content length is not greater than the
  L<max_content_length>, which defaults to 104,857,600 bytes (100MB) - the default
  that is configured in Elasticsearch.  From version 0.19.12, when C<no_refresh>
  set to false, the HTTP transport clients will auto-detect the minimum
  C<max_content_length> from the cluster.
  
  Currently, the available backends are:
  
  =over
  
  =item * C<http> (default)
  
  Uses L<LWP> to communicate using HTTP. See L<ElasticSearch::Transport::HTTP>
  
  =item * C<httplite>
  
  Uses L<HTTP::Lite> to communicate using HTTP.
  See L<ElasticSearch::Transport::HTTPLite>
  
  =item * C<httptiny>
  
  Uses L<HTTP::Tiny> to communicate using HTTP.
  See L<ElasticSearch::Transport::HTTPTiny>
  
  =item * C<curl>
  
  Uses L<WWW::Curl> and thus L<libcurl|http://curl.haxx.se/libcurl/>
  to communicate using HTTP. See L<ElasticSearch::Transport::Curl>
  
  =item * C<aehttp>
  
  Uses L<AnyEvent::HTTP> to communicate asynchronously using HTTP.
  See L<ElasticSearch::Transport::AEHTTP>
  
  =item * C<aecurl>
  
  Uses L<AnyEvent::Curl::Multi> (and thus L<libcurl|http://curl.haxx.se/libcurl/>)
  to communicate asynchronously using HTTP. See L<ElasticSearch::Transport::AECurl>
  
  =item * C<thrift>
  
  Uses C<thrift>  to communicate using a compact binary protocol over sockets.
  See L<ElasticSearch::Transport::Thrift>. You need to have the
  C<transport-thrift> plugin installed on your ElasticSearch server for this
  to work.
  
  =back
  
  You shouldn't need to talk to the transport modules directly - everything
  happens via the main L<ElasticSearch> class.
  
  =cut
  
  =head1 SYNOPSIS
  
  
      use ElasticSearch;
      my $e = ElasticSearch->new(
          servers            => 'search.foo.com:9200',
          transport          => 'httplite',
          timeout            => '10',
          no_refresh         => 0 | 1,
          deflate            => 0 | 1,
          max_content_length => 104_857_600,
      );
  
      my $t = $e->transport;
  
      $t->max_requests(5)             # refresh_servers every 5 requests
      $t->protocol                    # eg 'http'
      $t->next_server                 # next node to use
      $t->current_server              # eg '127.0.0.1:9200' ie last used node
      $t->default_servers             # seed servers passed in to new()
  
      $t->servers                     # eg ['192.168.1.1:9200','192.168.1.2:9200']
      $t->servers(@servers);          # set new 'live' list
  
      $t->refresh_servers             # refresh list of live nodes
  
      $t->clear_clients               # clear all open clients
  
      $t->no_refresh(0|1)             # don't retrieve the live node list
                                      # instead, use just the nodes specified
  
      $t->deflate(0|1);               # should ES deflate its responses
                                      # useful if ES is on a remote network.
                                      # ES needs compression enabled with
                                      #     http.compression: true
  
      $t->max_content_length(1000);   # set the max HTTP body content length
  
      $t->register('foo',$class)      # register new Transport backend
  
  =head1 WHICH TRANSPORT SHOULD YOU USE
  
  Although the C<thrift> interface has the right buzzwords (binary, compact,
  sockets), the generated Perl code is very slow. Until that is improved, I
  recommend one of the C<http> backends instead.
  
  The HTTP backends in increasing order of speed are:
  
  =over
  
  =item *
  
  C<http> - L<LWP> based
  
  =item *
  
  C<httplite> - L<HTTP::Lite> based, about 30% faster than C<http>
  
  =item *
  
  C<httptiny> - L<HTTP::Tiny> based, about 1% faster than C<httplite>
  
  =item *
  
  C<curl> - L<WWW::Curl> based, about 60% faster than C<httptiny>!
  
  =back
  
  See also:
  L<http://www.elasticsearch.org/guide/reference/modules/http.html>
  and L<http://www.elasticsearch.org/guide/reference/modules/thrift.html>
  
  =head1 SUBCLASSING TRANSPORT
  
  If you want to add a new transport backend, then these are the methods
  that you should subclass:
  
  =head2 init()
  
      $t->init($params)
  
  By default, a no-op. Receives a HASH ref with the parameters passed in to
  C<new()>, less C<servers>, C<transport> and C<timeout>.
  
  Any parameters specific to your module should be deleted from C<$params>
  
  =head2 send_request()
  
      $json = $t->send_request($server,$params)
  
      where $params = {
          method  => 'GET',
          cmd     => '/_cluster',
          qs      => { pretty => 1 },
          data    => '{ "foo": "bar"}',
      }
  
  This must be overridden in the subclass - it is the method called to
  actually talk to the server.
  
  See L<ElasticSearch::Transport::HTTP> for an example implementation.
  
  =head2 protocol()
  
      $t->protocol
  
  This must return the protocol in use, eg C<"http"> or C<"thrift">. It is
  used to extract the list of bound addresses from ElasticSearch, eg
  C<http_address> or C<thrift_address>.
  
  =head2 client()
  
      $client = $t->client($server)
  
  Returns the client object used in L</"send_request()">. The server param
  will look like C<"192.168.5.1:9200">. It should store its clients in a PID
  specific slot in C<< $t->{_client} >> as C<clear_clients()> deletes
  this key.
  
  See L<ElasticSearch::Transport::HTTP/"client()"> and
  L<ElasticSearch::Transport::Thrift/"client()">
  for an example implementation.
  
  =head1 Registering your Transport backend
  
  You can register your Transport backend as follows:
  
      BEGIN {
          ElasticSearch::Transport->register('mytransport',__PACKAGE__);
      }
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<ElasticSearch>
  
  =item * L<ElasticSearch::Transport::HTTP>
  
  =item * L<ElasticSearch::Transport::HTTPLite>
  
  =item * L<ElasticSearch::Transport::HTTPTiny>
  
  =item * L<ElasticSearch::Transport::Curl>
  
  =item * L<ElasticSearch::Transport::AEHTTP>
  
  =item * L<ElasticSearch::Transport::AECurl>
  
  =item * L<ElasticSearch::Transport::Thrift>
  
  =back
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
ELASTICSEARCH_TRANSPORT

$fatpacked{"ElasticSearch/Transport/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_TRANSPORT_HTTP';
  package ElasticSearch::Transport::HTTP;
  $ElasticSearch::Transport::HTTP::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use LWP::UserAgent();
  use LWP::ConnCache();
  use HTTP::Request();
  use Encode qw(decode_utf8);
  
  use parent 'ElasticSearch::Transport';
  
  #===================================
  sub protocol     {'http'}
  sub default_port {9200}
  #===================================
  
  #===================================
  sub send_request {
  #===================================
      my $self   = shift;
      my $server = shift;
      my $params = shift;
  
      my $method  = $params->{method};
      my $uri     = $self->http_uri( $server, $params->{cmd}, $params->{qs} );
      my $request = HTTP::Request->new( $method, $uri );
  
      $request->header( 'Accept-Encoding' => 'deflate' )
          if $self->deflate;
  
      if ( defined $params->{data} ) {
          $request->add_content_utf8( $params->{data} );
          $self->check_content_length( $request->content_ref );
      }
  
      my $client          = $self->client;
      my $server_response = $client->request($request);
      my $content         = $server_response->decoded_content;
      $content = decode_utf8($content) if defined $content;
  
      return $content if $server_response->is_success;
  
      my $msg  = $server_response->message;
      my $code = $server_response->code;
      my $type = $self->code_to_error($code)
          || (
            $msg eq 'read timeout' ? 'Timeout'
          : $msg =~ /Can't connect|Server closed connection/ ? 'Connection'
          : 'Request'
          );
      my $error_params = {
          server      => $server,
          status_code => $code,
          status_msg  => $msg,
      };
  
      if ( $type eq 'Request' or $type eq 'Conflict' or $type eq 'Missing' ) {
          $error_params->{content} = $content;
      }
  
      $client->conn_cache->drop
          if $method eq 'HEAD';
  
      $self->throw( $type, $msg . ' (' . $code . ')', $error_params );
  }
  
  #===================================
  sub client {
  #===================================
      my $self = shift;
      unless ( $self->{_client}{$$} ) {
          $self->{_client} = {
              $$ => LWP::UserAgent->new(
                  timeout    => $self->timeout,
                  conn_cache => LWP::ConnCache->new(
                      total_capacity => 0 + $self->servers
                  )
              )
          };
  
      }
      return $self->{_client}{$$};
  }
  
  =head1 NAME
  
  ElasticSearch::Transport::HTTP - LWP based HTTP backend
  
  =head1 DESCRIPTION
  
  ElasticSearch::Transport::HTTP uses L<LWP> to talk to ElasticSearch
  over HTTP.
  
  It is currently the default backend if no C<transport> is specified, but
  consider trying L<ElasticSearch::Transport:HTTPLite> instead - it is
  30% faster.
  
  
  =head1 SYNOPSIS
  
  
      use ElasticSearch;
      my $e = ElasticSearch->new(
          servers     => 'search.foo.com:9200',
          # transport   => 'http',
          timeout     => '10',
      );
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<ElasticSearch>
  
  =item * L<ElasticSearch::Transport>
  
  =item * L<ElasticSearch::Transport::HTTPLite>
  
  =item * L<ElasticSearch::Transport::HTTPTiny>
  
  =item * L<ElasticSearch::Transport::Curl>
  
  =item * L<ElasticSearch::Transport::AEHTTP>
  
  =item * L<ElasticSearch::Transport::AECurl>
  
  =item * L<ElasticSearch::Transport::Thrift>
  
  =back
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
ELASTICSEARCH_TRANSPORT_HTTP

$fatpacked{"ElasticSearch/Transport/HTTPLite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_TRANSPORT_HTTPLITE';
  package ElasticSearch::Transport::HTTPLite;
  $ElasticSearch::Transport::HTTPLite::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use HTTP::Lite();
  use Encode qw(decode_utf8);
  
  use parent 'ElasticSearch::Transport';
  
  my $Connection_Error = qr/ Connection.(?:timed.out|re(?:set|fused))
                         | No.route.to.host
                         | temporarily.unavailable
                         /x;
  
  #===================================
  sub protocol     {'http'}
  sub default_port {9200}
  #===================================
  
  #===================================
  sub send_request {
  #===================================
      my $self   = shift;
      my $server = shift;
      my $params = shift;
  
      my $method = $params->{method};
      my $uri    = $self->http_uri( $server, $params->{cmd}, $params->{qs} );
      my $client = $self->client;
      $client->add_req_header( 'Accept-Encoding' => 'deflate' )
          if $self->deflate;
  
      $client->method($method);
      if ( my $data = $params->{data} ) {
          utf8::encode($data);
          $self->check_content_length( \$data );
          $client->{content} = $data;
      }
  
      my $code = $client->request($uri) || 500;
      my $msg = $!;
  
      my $content = $client->body || '';
  
      my $ce = ( $client->get_header('Content-Encoding') || [] )->[0] || '';
      $content = $self->inflate($content) if $ce eq 'deflate';
      $content = decode_utf8 $content;
  
      return $content if $code && $code >= 200 && $code <= 209;
  
      $msg ||= $client->status_message || 'read timeout';
      my $type = $self->code_to_error($code)
          || (
            $msg =~ /$Connection_Error/ ? 'Connection'
          : $msg =~ /read timeout/      ? 'Timeout'
          : 'Request'
          );
      my $error_params = {
          server      => $server,
          status_code => $code,
          status_msg  => $msg,
      };
  
      if ( $type eq 'Request' or $type eq 'Conflict' or $type eq 'Missing' ) {
          $error_params->{content} = $content;
      }
      $self->throw( $type, $msg . ' (' . ( $code || 500 ) . ')',
          $error_params );
  }
  
  #===================================
  sub client {
  #===================================
      my $self = shift;
      unless ( $self->{_client}{$$} ) {
          my $client = HTTP::Lite->new;
          $client->{timeout} = $self->timeout || 10000;
          $self->{_client}{$$} = $client;
      }
      my $client = $self->{_client}{$$};
      $client->reset;
      return $client;
  }
  
  =head1 NAME
  
  ElasticSearch::Transport::HTTPLite - HTTP::Lite based HTTP backend
  
  =head1 DESCRIPTION
  
  ElasticSearch::Transport::HTTPLite uses L<HTTP::Lite> to talk to ElasticSearch
  over HTTP.
  
  It is a new backend and will probably become the default, as it is about 30%
  faster than L<ElasticSearch::Transport.:HTTP>.
  
  
  =head1 SYNOPSIS
  
      use ElasticSearch;
      my $e = ElasticSearch->new(
          servers     => 'search.foo.com:9200',
          transport   => 'httplite',
          timeout     => '10',
      );
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<ElasticSearch>
  
  =item * L<ElasticSearch::Transport>
  
  =item * L<ElasticSearch::Transport::HTTP>
  
  =item * L<ElasticSearch::Transport::HTTPTiny>
  
  =item * L<ElasticSearch::Transport::Curl>
  
  =item * L<ElasticSearch::Transport::AEHTTP>
  
  =item * L<ElasticSearch::Transport::AECurl>
  
  =item * L<ElasticSearch::Transport::Thrift>
  
  =back
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
ELASTICSEARCH_TRANSPORT_HTTPLITE

$fatpacked{"ElasticSearch/Transport/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_TRANSPORT_HTTPTINY';
  package ElasticSearch::Transport::HTTPTiny;
  $ElasticSearch::Transport::HTTPTiny::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use HTTP::Tiny();
  use Encode qw(decode_utf8);
  
  use parent 'ElasticSearch::Transport';
  
  my $Connection_Error = qr/ Connection.(?:timed.out|re(?:set|fused))
                         | No.route.to.host
                         | temporarily.unavailable
                         /x;
  
  #===================================
  sub protocol     {'http'}
  sub default_port {9200}
  #===================================
  
  #===================================
  sub send_request {
  #===================================
      my $self   = shift;
      my $server = shift;
      my $params = shift;
  
      my $method = $params->{method};
      my $uri    = $self->http_uri( $server, $params->{cmd}, $params->{qs} );
      my $client = $self->client;
  
      my $opts = {};
      if ( my $data = $params->{data} ) {
          utf8::encode($data);
          $self->check_content_length( \$data );
          $opts = {
              content => $data,
              headers =>
                  { 'content-type' => 'application/x-www-form-urlencoded' }
          };
      }
  
      my $response = $client->request( $method, $uri, $opts );
  
      my $code    = $response->{status};
      my $msg     = $response->{reason};
      my $content = $response->{content} || '';
  
      my $ce = $response->{headers}{'content-encoding'} || '';
      $content = $self->inflate($content) if $ce eq 'deflate';
      $content = decode_utf8 $content;
  
      return $content if $code && $code >= 200 && $code <= 209;
  
      if ( $code eq '599' ) {
          $msg     = $content;
          $content = '';
      }
  
      my $type = $self->code_to_error($code)
          || (
            $msg =~ /Timed out/         ? 'Timeout'
          : $msg =~ /$Connection_Error/ ? 'Connection'
          : 'Request'
          );
  
      my $error_params = {
          server      => $server,
          status_code => $code,
          status_msg  => $msg,
      };
  
      if ( $type eq 'Request' or $type eq 'Conflict' or $type eq 'Missing' ) {
          $error_params->{content} = $content;
      }
      $self->throw( $type, $msg . ' (' . ( $code || 500 ) . ')',
          $error_params );
  }
  
  #===================================
  sub client {
  #===================================
      my $self = shift;
      unless ( $self->{_client}{$$} ) {
          my %params = ( timeout => $self->timeout || 10000 );
          $params{default_headers} = { 'Accept-Encoding' => 'deflate' }
              if $self->deflate;
          my $client = HTTP::Tiny->new(%params);
          $self->{_client}{$$} = $client;
      }
      return $self->{_client}{$$};
  }
  
  =head1 NAME
  
  ElasticSearch::Transport::HTTPTiny - HTTP::Tiny based HTTP backend
  
  =head1 DESCRIPTION
  
  ElasticSearch::Transport::HTTPTiny uses L<HTTP::Tiny> to talk to ElasticSearch
  over HTTP.
  
  It is slightly (1%) faster thab L<ElasticSearch::Transport::HTTPLite>.
  
  
  =head1 SYNOPSIS
  
      use ElasticSearch;
      my $e = ElasticSearch->new(
          servers     => 'search.foo.com:9200',
          transport   => 'httptiny',
          timeout     => '10',
      );
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<ElasticSearch>
  
  =item * L<ElasticSearch::Transport>
  
  =item * L<ElasticSearch::Transport::HTTP>
  
  =item * L<ElasticSearch::Transport::HTTPLite>
  
  =item * L<ElasticSearch::Transport::Curl>
  
  =item * L<ElasticSearch::Transport::AEHTTP>
  
  =item * L<ElasticSearch::Transport::AECurl>
  
  =item * L<ElasticSearch::Transport::Thrift>
  
  =back
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
ELASTICSEARCH_TRANSPORT_HTTPTINY

$fatpacked{"ElasticSearch/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ELASTICSEARCH_UTIL';
  package ElasticSearch::Util;
  $ElasticSearch::Util::VERSION = '0.68';
  use strict;
  use warnings FATAL => 'all';
  use ElasticSearch::Error();
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(filter_keywords parse_params throw build_error);
  
  #===================================
  sub filter_keywords {
  #===================================
      local $_ = shift;
  
      s{[^[:alpha:][:digit:] \-+'"*@\._]+}{ }g;
  
      return '' unless /[[:alpha:][:digit:]]/;
  
      s/\s*\b(?:and|or|not)\b\s*/ /gi;
  
      # remove '-' that don't have spaces before them
      s/(?<! )-/\ /g;
  
      # remove the spaces after a + or -
      s/([+-])\s+/$1/g;
  
      # remove + or - not followed by a letter, number or "
      s/[+-](?![[:alpha:][:digit:]"])/ /g;
  
      # remove * without 3 char prefix
      s/(?<![[:alpha:][:digit:]\-@\._]{3})\*/ /g;
  
      my $quotes = (tr/"//);
      if ( $quotes % 2 ) { $_ .= '"' }
  
      s/^\s+//;
      s/\s+$//;
  
      return $_;
  }
  
  #===================================
  sub parse_params {
  #===================================
      my $self = shift;
      my %params;
      if ( @_ % 2 ) {
          $self->throw(
              "Param",
              'Expecting a HASH ref or a list of key-value pairs',
              { params => \@_ }
          ) unless ref $_[0] eq 'HASH';
          %params = %{ shift() };
      }
      else {
          %params = @_;
      }
      return ( $self, \%params );
  }
  
  #===================================
  sub throw {
  #===================================
      my ( $self, $type, $msg, $vars ) = @_;
      die build_error( $self, $type, $msg, $vars, 1 );
  }
  
  #===================================
  sub build_error {
  #===================================
      my $self   = shift;
      my $type   = shift;
      my $msg    = shift;
      my $vars   = shift;
      my $caller = shift || 0;
  
      my $class = ref $self || $self;
      my $error_class = 'ElasticSearch::Error::' . $type;
  
      $msg = 'Unknown error' unless defined $msg;
      $msg =~ s/\n/\n    /g;
  
      my ( undef, $file, $line ) = caller($caller);
      my $error_params = {
          -text => $msg,
          -line => $line,
          -file => $file,
          -vars => $vars,
      };
      {
          no warnings 'once';
          $error_params->{-stacktrace} = _stack_trace()
              if $ElasticSearch::DEBUG;
      }
      return bless $error_params, $error_class;
  
  }
  
  #===================================
  sub _stack_trace {
  #===================================
      my $i    = 2;
      my $line = ( '-' x 60 ) . "\n";
      my $o    = $line
          . sprintf( "%-4s %-30s %-5s %s\n",
          ( '#', 'Package', 'Line', 'Sub-routine' ) )
          . $line;
      while ( my @caller = caller($i) ) {
          $o .= sprintf( "%-4d %-30s %4d  %s\n", $i++, @caller[ 0, 2, 3 ] );
      }
      return $o .= $line;
  }
  
  =head1 NAME
  
  ElasticSearch::Util - Util subs for ElasticSearch
  
  =head1 DESCRIPTION
  
  ElasticSearch::Util provides various subs useful to other modules in
  ElasticSearch.
  
  The only sub useful to users is L</"filter_keywords()">, which can be
  exported.
  
  =head1 SYNOPSIS
  
      use ElasticSearch::Util qw(filter_keywords);
  
      my $filtered = filter_keywords($unfiltered)
  
  =head1 SUBROUTINES
  
  =head2 filter_keywords()
  
  This tidies up a string to be used as a query string in (eg)
  L<ElasticSearch/"search()"> so that user input won't cause a search query
  to return an error.
  
  It is not flexible at all, and may or may not be useful to you.
  
  Have a look at L<ElasticSearch::QueryParser> which gives you much more control
  over your query strings.
  
  The current implementation does the following:
  
  =over
  
  =item * Removes any character which isn't a letter, a number, a space or
    C<-+'"*@._>.
  
  =item * Removes C<and>, C<or> and C<not>
  
  =item * Removes any C<-> that doesn't have a space in front of it ( "foo -bar")
        is acceptable as it means C<'foo' but not with 'bar'>
  
  =item * Removes any space after a C<+> or C<->
  
  =item * Removes any C<+> or C<-> which is not followed by a letter, number
        or a double quote
  
  =item * Removes any C<*> that doesn't have at least 3 letters before it, ie
        we only allow wildcard searches on words with at least 3 characters
  
  =item * Closes any open double quotes
  
  =item * Removes leading and trailing whitespace
  
  =back
  
  YMMV
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2010 - 2011 Clinton Gormley.
  
  This program is free software; you can redistribute it and/or modify it
  under the terms of either: the GNU General Public License as published
  by the Free Software Foundation; or the Artistic License.
  
  See http://dev.perl.org/licenses/ for more information.
  
  
  =cut
  
  1;
  
ELASTICSEARCH_UTIL

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as} ? $globals->{as}->($name) :
  		ref    $value->{-as}  ? $value->{-as}->($name) :
  		exists $value->{-as}  ? $value->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	unless (ref($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)         if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"File/Slurp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURP';
  package File::Slurp;
  
  use 5.6.2 ;
  
  use strict;
  use warnings ;
  
  use Carp ;
  use Exporter ;
  use Fcntl qw( :DEFAULT ) ;
  use POSIX qw( :fcntl_h ) ;
  use Errno ;
  #use Symbol ;
  
  use vars qw( @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION ) ;
  @ISA = qw( Exporter ) ;
  
  $VERSION = '9999.19';
  
  my @std_export = qw(
  	read_file
  	write_file
  	overwrite_file
  	append_file
  	read_dir
  ) ;
  
  my @edit_export = qw( 
  	edit_file
  	edit_file_lines
  ) ;
  
  my @ok_export = qw( 
  ) ;
  
  @EXPORT_OK = (
  	@edit_export,
  	qw(
  		slurp
  		prepend_file
  	),
  ) ;
  
  %EXPORT_TAGS = (
  	'all'	=> [ @std_export, @edit_export, @EXPORT_OK ],
  	'edit'	=> [ @edit_export ],
  	'std'	=> [ @std_export ],
  ) ;
  
  @EXPORT = @std_export ;
  
  my $max_fast_slurp_size = 1024 * 100 ;
  
  my $is_win32 = $^O =~ /win32/i ;
  
  # Install subs for various constants that aren't set in older perls
  # (< 5.005).  Fcntl on old perls uses Exporter to define subs without a
  # () prototype These can't be overridden with the constant pragma or
  # we get a prototype mismatch.  Hence this less than aesthetically
  # appealing BEGIN block:
  
  BEGIN {
  	unless( defined &SEEK_SET ) {
  		*SEEK_SET = sub { 0 };
  		*SEEK_CUR = sub { 1 };
  		*SEEK_END = sub { 2 };
  	}
  
  	unless( defined &O_BINARY ) {
  		*O_BINARY = sub { 0 };
  		*O_RDONLY = sub { 0 };
  		*O_WRONLY = sub { 1 };
  	}
  
  	unless ( defined &O_APPEND ) {
  
  		if ( $^O =~ /olaris/ ) {
  			*O_APPEND = sub { 8 };
  			*O_CREAT = sub { 256 };
  			*O_EXCL = sub { 1024 };
  		}
  		elsif ( $^O =~ /inux/ ) {
  			*O_APPEND = sub { 1024 };
  			*O_CREAT = sub { 64 };
  			*O_EXCL = sub { 128 };
  		}
  		elsif ( $^O =~ /BSD/i ) {
  			*O_APPEND = sub { 8 };
  			*O_CREAT = sub { 512 };
  			*O_EXCL = sub { 2048 };
  		}
  	}
  }
  
  # print "OS [$^O]\n" ;
  
  # print "O_BINARY = ", O_BINARY(), "\n" ;
  # print "O_RDONLY = ", O_RDONLY(), "\n" ;
  # print "O_WRONLY = ", O_WRONLY(), "\n" ;
  # print "O_APPEND = ", O_APPEND(), "\n" ;
  # print "O_CREAT   ", O_CREAT(), "\n" ;
  # print "O_EXCL   ", O_EXCL(), "\n" ;
  
  
  *slurp = \&read_file ;
  
  sub read_file {
  
  	my $file_name = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;
  
  # this is the optimized read_file for shorter files.
  # the test for -s > 0 is to allow pseudo files to be read with the
  # regular loop since they return a size of 0.
  
  	if ( !ref $file_name && -e $file_name && -s _ > 0 &&
  	     -s _ < $max_fast_slurp_size && !%{$opts} && !wantarray ) {
  
  
  		my $fh ;
  		unless( sysopen( $fh, $file_name, O_RDONLY ) ) {
  
  			@_ = ( $opts, "read_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  
  		my $read_cnt = sysread( $fh, my $buf, -s _ ) ;
  
  		unless ( defined $read_cnt ) {
  
  			@_ = ( $opts,
  				"read_file '$file_name' - small sysread: $!");
  			goto &_error ;
  		}
  
  		$buf =~ s/\015\012/\n/g if $is_win32 ;
  		return $buf ;
  	}
  
  # set the buffer to either the passed in one or ours and init it to the null
  # string
  
  	my $buf ;
  	my $buf_ref = $opts->{'buf_ref'} || \$buf ;
  	${$buf_ref} = '' ;
  
  	my( $read_fh, $size_left, $blk_size ) ;
  
  # deal with ref for a file name
  # it could be an open handle or an overloaded object
  
  	if ( ref $file_name ) {
  
  		my $ref_result = _check_ref( $file_name ) ;
  
  		if ( ref $ref_result ) {
  
  # we got an error, deal with it
  
  			@_ = ( $opts, $ref_result ) ;
  			goto &_error ;
  		}
  
  		if ( $ref_result ) {
  
  # we got an overloaded object and the result is the stringified value
  # use it as the file name
  
  			$file_name = $ref_result ;
  		}
  		else {
  
  # here we have just an open handle. set $read_fh so we don't do a sysopen
  
  			$read_fh = $file_name ;
  			$blk_size = $opts->{'blk_size'} || 1024 * 1024 ;
  			$size_left = $blk_size ;
  		}
  	}
  
  # see if we have a path we need to open
  
  	unless ( $read_fh ) {
  
  # a regular file. set the sysopen mode
  
  		my $mode = O_RDONLY ;
  
  #printf "RD: BINARY %x MODE %x\n", O_BINARY, $mode ;
  
  		$read_fh = local( *FH ) ;
  #		$read_fh = gensym ;
  		unless ( sysopen( $read_fh, $file_name, $mode ) ) {
  			@_ = ( $opts, "read_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  
  		if ( my $binmode = $opts->{'binmode'} ) {
  			binmode( $read_fh, $binmode ) ;
  		}
  
  # get the size of the file for use in the read loop
  
  		$size_left = -s $read_fh ;
  
  #print "SIZE $size_left\n" ;
  
  # we need a blk_size if the size is 0 so we can handle pseudofiles like in
  # /proc. these show as 0 size but have data to be slurped.
  
  		unless( $size_left ) {
  
  			$blk_size = $opts->{'blk_size'} || 1024 * 1024 ;
  			$size_left = $blk_size ;
  		}
  	}
  
  # infinite read loop. we exit when we are done slurping
  
  	while( 1 ) {
  
  # do the read and see how much we got
  
  		my $read_cnt = sysread( $read_fh, ${$buf_ref},
  				$size_left, length ${$buf_ref} ) ;
  
  # since we're using sysread Perl won't automatically restart the call
  # when interrupted by a signal.
  
  		next if $!{EINTR};
  
  		unless ( defined $read_cnt ) {
  
  			@_ = ( $opts, "read_file '$file_name' - loop sysread: $!");
  			goto &_error ;
  		}
  
  # good read. see if we hit EOF (nothing left to read)
  
  		last if $read_cnt == 0 ;
  
  # loop if we are slurping a handle. we don't track $size_left then.
  
  		next if $blk_size ;
  
  # count down how much we read and loop if we have more to read.
  
  		$size_left -= $read_cnt ;
  		last if $size_left <= 0 ;
  	}
  
  # fix up cr/lf to be a newline if this is a windows text file
  
  	${$buf_ref} =~ s/\015\012/\n/g if $is_win32 && !$opts->{'binmode'} ;
  
  	my $sep = $/ ;
  	$sep = '\n\n+' if defined $sep && $sep eq '' ;
  
  # see if caller wants lines
  
  	if( wantarray || $opts->{'array_ref'} ) {
  
  		use re 'taint' ;
  
  		my @lines = length(${$buf_ref}) ?
  			${$buf_ref} =~ /(.*?$sep|.+)/sg : () ;
  
  		chomp @lines if $opts->{'chomp'} ;
  
  # caller wants an array ref
  
  		return \@lines if $opts->{'array_ref'} ;
  
  # caller wants list of lines
  
  		return @lines ;
  	}
  
  # caller wants a scalar ref to the slurped text
  
  	return $buf_ref if $opts->{'scalar_ref'} ;
  
  # caller wants a scalar with the slurped text (normal scalar context)
  
  	return ${$buf_ref} if defined wantarray ;
  
  # caller passed in an i/o buffer by reference (normal void context)
  
  	return ;
  }
  
  # errors in this sub are returned as scalar refs
  # a normal IO/GLOB handle is an empty return
  # an overloaded object returns its stringified as a scalarfilename
  
  sub _check_ref {
  
  	my( $handle ) = @_ ;
  
  # check if we are reading from a handle (GLOB or IO object)
  
  	if ( eval { $handle->isa( 'GLOB' ) || $handle->isa( 'IO' ) } ) {
  
  # we have a handle. deal with seeking to it if it is DATA
  
  		my $err = _seek_data_handle( $handle ) ;
  
  # return the error string if any
  
  		return \$err if $err ;
  
  # we have good handle
  		return ;
  	}
  
  	eval { require overload } ;
  
  # return an error if we can't load the overload pragma
  # or if the object isn't overloaded
  
  	return \"Bad handle '$handle' is not a GLOB or IO object or overloaded"
  		 if $@ || !overload::Overloaded( $handle ) ;
  
  # must be overloaded so return its stringified value
  
  	return "$handle" ;
  }
  
  sub _seek_data_handle {
  
  	my( $handle ) = @_ ;
  
  # DEEP DARK MAGIC. this checks the UNTAINT IO flag of a
  # glob/handle. only the DATA handle is untainted (since it is from
  # trusted data in the source file). this allows us to test if this is
  # the DATA handle and then to do a sysseek to make sure it gets
  # slurped correctly. on some systems, the buffered i/o pointer is not
  # left at the same place as the fd pointer. this sysseek makes them
  # the same so slurping with sysread will work.
  
  	eval{ require B } ;
  
  	if ( $@ ) {
  
  		return <<ERR ;
  Can't find B.pm with this Perl: $!.
  That module is needed to properly slurp the DATA handle.
  ERR
  	}
  
  	if ( B::svref_2object( $handle )->IO->IoFLAGS & 16 ) {
  
  # set the seek position to the current tell.
  
  		unless( sysseek( $handle, tell( $handle ), SEEK_SET ) ) {
  			return "read_file '$handle' - sysseek: $!" ;
  		}
  	}
  
  # seek was successful, return no error string
  
  	return ;
  }
  
  
  sub write_file {
  
  	my $file_name = shift ;
  
  # get the optional argument hash ref from @_ or an empty hash ref.
  
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  	my( $buf_ref, $write_fh, $no_truncate, $orig_file_name, $data_is_ref ) ;
  
  # get the buffer ref - it depends on how the data is passed into write_file
  # after this if/else $buf_ref will have a scalar ref to the data.
  
  	if ( ref $opts->{'buf_ref'} eq 'SCALAR' ) {
  
  # a scalar ref passed in %opts has the data
  # note that the data was passed by ref
  
  		$buf_ref = $opts->{'buf_ref'} ;
  		$data_is_ref = 1 ;
  	}
  	elsif ( ref $_[0] eq 'SCALAR' ) {
  
  # the first value in @_ is the scalar ref to the data
  # note that the data was passed by ref
  
  		$buf_ref = shift ;
  		$data_is_ref = 1 ;
  	}
  	elsif ( ref $_[0] eq 'ARRAY' ) {
  
  # the first value in @_ is the array ref to the data so join it.
  
  		${$buf_ref} = join '', @{$_[0]} ;
  	}
  	else {
  
  # good old @_ has all the data so join it.
  
  		${$buf_ref} = join '', @_ ;
  	}
  
  # deal with ref for a file name
  
  	if ( ref $file_name ) {
  
  		my $ref_result = _check_ref( $file_name ) ;
  
  		if ( ref $ref_result ) {
  
  # we got an error, deal with it
  
  			@_ = ( $opts, $ref_result ) ;
  			goto &_error ;
  		}
  
  		if ( $ref_result ) {
  
  # we got an overloaded object and the result is the stringified value
  # use it as the file name
  
  			$file_name = $ref_result ;
  		}
  		else {
  
  # we now have a proper handle ref.
  # make sure we don't call truncate on it.
  
  			$write_fh = $file_name ;
  			$no_truncate = 1 ;
  		}
  	}
  
  # see if we have a path we need to open
  
  	unless( $write_fh ) {
  
  # spew to regular file.
  
  		if ( $opts->{'atomic'} ) {
  
  # in atomic mode, we spew to a temp file so make one and save the original
  # file name.
  			$orig_file_name = $file_name ;
  			$file_name .= ".$$" ;
  		}
  
  # set the mode for the sysopen
  
  		my $mode = O_WRONLY | O_CREAT ;
  		$mode |= O_APPEND if $opts->{'append'} ;
  		$mode |= O_EXCL if $opts->{'no_clobber'} ;
  
  		my $perms = $opts->{perms} ;
  		$perms = 0666 unless defined $perms ;
  
  #printf "WR: BINARY %x MODE %x\n", O_BINARY, $mode ;
  
  # open the file and handle any error.
  
  		$write_fh = local( *FH ) ;
  #		$write_fh = gensym ;
  		unless ( sysopen( $write_fh, $file_name, $mode, $perms ) ) {
  
  			@_ = ( $opts, "write_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  	}
  
  	if ( my $binmode = $opts->{'binmode'} ) {
  		binmode( $write_fh, $binmode ) ;
  	}
  
  	sysseek( $write_fh, 0, SEEK_END ) if $opts->{'append'} ;
  
  #print 'WR before data ', unpack( 'H*', ${$buf_ref}), "\n" ;
  
  # fix up newline to write cr/lf if this is a windows text file
  
  	if ( $is_win32 && !$opts->{'binmode'} ) {
  
  # copy the write data if it was passed by ref so we don't clobber the
  # caller's data
  		$buf_ref = \do{ my $copy = ${$buf_ref}; } if $data_is_ref ;
  		${$buf_ref} =~ s/\n/\015\012/g ;
  	}
  
  #print 'after data ', unpack( 'H*', ${$buf_ref}), "\n" ;
  
  # get the size of how much we are writing and init the offset into that buffer
  
  	my $size_left = length( ${$buf_ref} ) ;
  	my $offset = 0 ;
  
  # loop until we have no more data left to write
  
  	do {
  
  # do the write and track how much we just wrote
  
  		my $write_cnt = syswrite( $write_fh, ${$buf_ref},
  				$size_left, $offset ) ;
  
  # since we're using syswrite Perl won't automatically restart the call
  # when interrupted by a signal.
  
  		next if $!{EINTR};
  
  		unless ( defined $write_cnt ) {
  
  			@_ = ( $opts, "write_file '$file_name' - syswrite: $!");
  			goto &_error ;
  		}
  
  # track how much left to write and where to write from in the buffer
  
  		$size_left -= $write_cnt ;
  		$offset += $write_cnt ;
  
  	} while( $size_left > 0 ) ;
  
  # we truncate regular files in case we overwrite a long file with a shorter file
  # so seek to the current position to get it (same as tell()).
  
  	truncate( $write_fh,
  		  sysseek( $write_fh, 0, SEEK_CUR ) ) unless $no_truncate ;
  
  	close( $write_fh ) ;
  
  # handle the atomic mode - move the temp file to the original filename.
  
  	if ( $opts->{'atomic'} && !rename( $file_name, $orig_file_name ) ) {
  
  		@_ = ( $opts, "write_file '$file_name' - rename: $!" ) ;
  		goto &_error ;
  	}
  
  	return 1 ;
  }
  
  # this is for backwards compatibility with the previous File::Slurp module. 
  # write_file always overwrites an existing file
  
  *overwrite_file = \&write_file ;
  
  # the current write_file has an append mode so we use that. this
  # supports the same API with an optional second argument which is a
  # hash ref of options.
  
  sub append_file {
  
  # get the optional opts hash ref
  	my $opts = $_[1] ;
  	if ( ref $opts eq 'HASH' ) {
  
  # we were passed an opts ref so just mark the append mode
  
  		$opts->{append} = 1 ;
  	}
  	else {
  
  # no opts hash so insert one with the append mode
  
  		splice( @_, 1, 0, { append => 1 } ) ;
  	}
  
  # magic goto the main write_file sub. this overlays the sub without touching
  # the stack or @_
  
  	goto &write_file
  }
  
  # prepend data to the beginning of a file
  
  sub prepend_file {
  
  	my $file_name = shift ;
  
  #print "FILE $file_name\n" ;
  
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  	my $prepend_data = shift ;
  	$prepend_data = '' unless defined $prepend_data ;
  	$prepend_data = ${$prepend_data} if ref $prepend_data eq 'SCALAR' ;
  
  #print "PRE [$prepend_data]\n" ;
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  	$opts->{ scalar_ref } = 1 ;
  
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts,
  		       $prepend_data, $$existing_data ) ;
  	} ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  # edit a file as a scalar in $_
  
  sub edit_file(&$;$) {
  
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  
  # 	my $edit_code = shift ;
  # 	my $file_name = shift ;
  # 	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  #print "FILE $file_name\n" ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  # keep the user err_mode and force croaking on internal errors
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  
  # get a scalar ref for speed and slurp the file into a scalar
  
  	$opts->{ scalar_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	my( $edited_data ) = map { $edit_code->(); $_ } $$existing_data ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, $edited_data ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  sub edit_file_lines(&$;$) {
  
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  
  # 	my $edit_code = shift ;
  # 	my $file_name = shift ;
  # 	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  #print "FILE $file_name\n" ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  # keep the user err_mode and force croaking on internal errors
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  
  # get an array ref for speed and slurp the file into lines
  
  	$opts->{ array_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	my @edited_data = map { $edit_code->(); $_ } @$existing_data ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, @edited_data ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  # basic wrapper around opendir/readdir
  
  sub read_dir {
  
  	my $dir = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;
  
  # this handle will be destroyed upon return
  
  	local(*DIRH);
  
  # open the dir and handle any errors
  
  	unless ( opendir( DIRH, $dir ) ) {
  
  		@_ = ( $opts, "read_dir '$dir' - opendir: $!" ) ;
  		goto &_error ;
  	}
  
  	my @dir_entries = readdir(DIRH) ;
  
  	@dir_entries = grep( $_ ne "." && $_ ne "..", @dir_entries )
  		unless $opts->{'keep_dot_dot'} ;
  
  	if ( $opts->{'prefix'} ) {
  
  		substr( $_, 0, 0, "$dir/" ) for @dir_entries ;
  	}
  
  	return @dir_entries if wantarray ;
  	return \@dir_entries ;
  }
  
  # error handling section
  #
  # all the error handling uses magic goto so the caller will get the
  # error message as if from their code and not this module. if we just
  # did a call on the error code, the carp/croak would report it from
  # this module since the error sub is one level down on the call stack
  # from read_file/write_file/read_dir.
  
  
  my %err_func = (
  	'carp'	=> \&carp,
  	'croak'	=> \&croak,
  ) ;
  
  sub _error {
  
  	my( $opts, $err_msg ) = @_ ;
  
  # get the error function to use
  
   	my $func = $err_func{ $opts->{'err_mode'} || 'croak' } ;
  
  # if we didn't find it in our error function hash, they must have set
  # it to quiet and we don't do anything.
  
  	return unless $func ;
  
  # call the carp/croak function
  
  	$func->($err_msg) if $func ;
  
  # return a hard undef (in list context this will be a single value of
  # undef which is not a legal in-band value)
  
  	return undef ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Slurp - Simple and Efficient Reading/Writing/Modifying of Complete Files
  
  =head1 SYNOPSIS
  
    use File::Slurp;
  
  # read in a whole file into a scalar
    my $text = read_file( 'filename' ) ;
  
  # read in a whole file into an array of lines
    my @lines = read_file( 'filename' ) ;
  
  # write out a whole file from a scalar
    write_file( 'filename', $text ) ;
  
  # write out a whole file from an array of lines
    write_file( 'filename', @lines ) ;
  
  # Here is a simple and fast way to load and save a simple config file
  # made of key=value lines.
    my %conf = read_file( $file_name ) =~ /^(\w+)=(.*)$/mg ;
    write_file( $file_name, {atomic => 1}, map "$_=$conf{$_}\n", keys %conf ) ;
  
  # insert text at the beginning of a file
    prepend_file( 'filename', $text ) ;
  
  # in-place edit to replace all 'foo' with 'bar' in file 
    edit_file { s/foo/bar/g } 'filename' ;
  
  # in-place edit to delete all lines with 'foo' from file
    edit_file_lines sub { $_ = '' if /foo/ }, 'filename' ;
  
  # read in a whole directory of file names (skipping . and ..)
    my @files = read_dir( '/path/to/dir' ) ;
  
  =head1 DESCRIPTION
  
  This module provides subs that allow you to read or write entire files
  with one simple call. They are designed to be simple to use, have
  flexible ways to pass in or get the file contents and to be very
  efficient.  There is also a sub to read in all the files in a
  directory other than C<.> and C<..>
  
  These slurp/spew subs work for files, pipes and sockets, stdio,
  pseudo-files, and the DATA handle. Read more about why slurping files is
  a good thing in the file 'slurp_article.pod' in the extras/ directory.
  
  If you are interested in how fast these calls work, check out the
  slurp_bench.pl program in the extras/ directory. It compares many
  different forms of slurping. You can select the I/O direction, context
  and file sizes. Use the --help option to see how to run it.
  
  =head2 B<read_file>
  
  This sub reads in an entire file and returns its contents to the
  caller.  In scalar context it returns the entire file as a single
  scalar. In list context it will return a list of lines (using the
  current value of $/ as the separator including support for paragraph
  mode when it is set to '').
  
    my $text = read_file( 'filename' ) ;
    my $bin = read_file( 'filename' { binmode => ':raw' } ) ;
    my @lines = read_file( 'filename' ) ;
    my $lines = read_file( 'filename', array_ref => 1 ) ;
  
  The first argument is the file to slurp in. If the next argument is a
  hash reference, then it is used as the options. Otherwise the rest of
  the argument list are is used as key/value options.
  
  If the file argument is a handle (if it is a ref and is an IO or GLOB
  object), then that handle is slurped in. This mode is supported so you
  slurp handles such as C<DATA> and C<STDIN>. See the test handle.t for
  an example that does C<open( '-|' )> and the child process spews data
  to the parant which slurps it in.  All of the options that control how
  the data is returned to the caller still work in this case.
  
  If the first argument is an overloaded object then its stringified value
  is used for the filename and that file is opened.  This is a new feature
  in 9999.14. See the stringify.t test for an example.
  
  By default C<read_file> returns an undef in scalar contex or a single
  undef in list context if it encounters an error. Those are both
  impossible to get with a clean read_file call which means you can check
  the return value and always know if you had an error. You can change how
  errors are handled with the C<err_mode> option.
  
  Speed Note: If you call read_file and just get a scalar return value
  it is now optimized to handle shorter files. This is only used if no
  options are used, the file is shorter then 100k bytes, the filename is
  a plain scalar and a scalar file is returned. If you want the fastest
  slurping, use the C<buf_ref> or C<scalar_ref> options (see below)
  
  NOTE: as of version 9999.06, read_file works correctly on the C<DATA>
  handle. It used to need a sysseek workaround but that is now handled
  when needed by the module itself.
  
  You can optionally request that C<slurp()> is exported to your code. This
  is an alias for read_file and is meant to be forward compatible with
  Perl 6 (which will have slurp() built-in).
  
  The options for C<read_file> are:
  
  =head3 binmode
  
  If you set the binmode option, then its value is passed to a call to
  binmode on the opened handle. You can use this to set the file to be
  read in binary mode, utf8, etc. See perldoc -f binmode for more.
  
  	my $bin_data = read_file( $bin_file, binmode => ':raw' ) ;
  	my $utf_text = read_file( $bin_file, binmode => ':utf8' ) ;
  
  =head3 array_ref
  
  If this boolean option is set, the return value (only in scalar
  context) will be an array reference which contains the lines of the
  slurped file. The following two calls are equivalent:
  
  	my $lines_ref = read_file( $bin_file, array_ref => 1 ) ;
  	my $lines_ref = [ read_file( $bin_file ) ] ;
  
  =head3 chomp
  
  If this boolean option is set, the lines are chomped. This only
  happens if you are slurping in a list context or using the
  C<array_ref> option.
  
  =head3 scalar_ref
  
  If this boolean option is set, the return value (only in scalar
  context) will be an scalar reference to a string which is the contents
  of the slurped file. This will usually be faster than returning the
  plain scalar. It will also save memory as it will not make a copy of
  the file to return. Run the extras/slurp_bench.pl script to see speed
  comparisons.
  
  	my $text_ref = read_file( $bin_file, scalar_ref => 1 ) ;
  
  =head3 buf_ref
  
  You can use this option to pass in a scalar reference and the slurped
  file contents will be stored in the scalar. This can be used in
  conjunction with any of the other options. This saves an extra copy of
  the slurped file and can lower ram usage vs returning the file. It is
  usually the fastest way to read a file into a scalar. Run the
  extras/slurp_bench.pl script to see speed comparisons.
  
  
  	read_file( $bin_file, buf_ref => \$buffer ) ;
  
  =head3 blk_size
  
  You can use this option to set the block size used when slurping from
  an already open handle (like \*STDIN). It defaults to 1MB.
  
  	my $text_ref = read_file( $bin_file, blk_size => 10_000_000,
  					     array_ref => 1 ) ;
  
  =head3 err_mode
  
  You can use this option to control how read_file behaves when an error
  occurs. This option defaults to 'croak'. You can set it to 'carp' or to
  'quiet to have no special error handling. This code wants to carp and
  then read another file if it fails.
  
  	my $text_ref = read_file( $file, err_mode => 'carp' ) ;
  	unless ( $text_ref ) {
  
  		# read a different file but croak if not found
  		$text_ref = read_file( $another_file ) ;
  	}
  	
  	# process ${$text_ref}
  
  =head2 B<write_file>
  
  This sub writes out an entire file in one call.
  
    write_file( 'filename', @data ) ;
  
  The first argument to C<write_file> is the filename. The next argument
  is an optional hash reference and it contains key/values that can
  modify the behavior of C<write_file>. The rest of the argument list is
  the data to be written to the file.
  
    write_file( 'filename', {append => 1 }, @data ) ;
    write_file( 'filename', {binmode => ':raw'}, $buffer ) ;
  
  As a shortcut if the first data argument is a scalar or array reference,
  it is used as the only data to be written to the file. Any following
  arguments in @_ are ignored. This is a faster way to pass in the output
  to be written to the file and is equivalent to the C<buf_ref> option of
  C<read_file>. These following pairs are equivalent but the pass by
  reference call will be faster in most cases (especially with larger
  files).
  
    write_file( 'filename', \$buffer ) ;
    write_file( 'filename', $buffer ) ;
  
    write_file( 'filename', \@lines ) ;
    write_file( 'filename', @lines ) ;
  
  If the first argument is a handle (if it is a ref and is an IO or GLOB
  object), then that handle is written to. This mode is supported so you
  spew to handles such as \*STDOUT. See the test handle.t for an example
  that does C<open( '-|' )> and child process spews data to the parent
  which slurps it in.  All of the options that control how the data are
  passed into C<write_file> still work in this case.
  
  If the first argument is an overloaded object then its stringified value
  is used for the filename and that file is opened.  This is new feature
  in 9999.14. See the stringify.t test for an example.
  
  By default C<write_file> returns 1 upon successfully writing the file or
  undef if it encountered an error. You can change how errors are handled
  with the C<err_mode> option.
  
  The options are:
  
  =head3 binmode
  
  If you set the binmode option, then its value is passed to a call to
  binmode on the opened handle. You can use this to set the file to be
  read in binary mode, utf8, etc. See perldoc -f binmode for more.
  
  	write_file( $bin_file, {binmode => ':raw'}, @data ) ;
  	write_file( $bin_file, {binmode => ':utf8'}, $utf_text ) ;
  
  =head3 perms
  
  The perms option sets the permissions of newly-created files. This value
  is modified by your process's umask and defaults to 0666 (same as
  sysopen).
  
  NOTE: this option is new as of File::Slurp version 9999.14;
  
  =head3 buf_ref
  
  You can use this option to pass in a scalar reference which has the
  data to be written. If this is set then any data arguments (including
  the scalar reference shortcut) in @_ will be ignored. These are
  equivalent:
  
  	write_file( $bin_file, { buf_ref => \$buffer } ) ;
  	write_file( $bin_file, \$buffer ) ;
  	write_file( $bin_file, $buffer ) ;
  
  =head3 atomic
  
  If you set this boolean option, the file will be written to in an
  atomic fashion. A temporary file name is created by appending the pid
  ($$) to the file name argument and that file is spewed to. After the
  file is closed it is renamed to the original file name (and rename is
  an atomic operation on most OS's). If the program using this were to
  crash in the middle of this, then the file with the pid suffix could
  be left behind.
  
  =head3 append
  
  If you set this boolean option, the data will be written at the end of
  the current file. Internally this sets the sysopen mode flag O_APPEND.
  
  	write_file( $file, {append => 1}, @data ) ;
  
   You
  can import append_file and it does the same thing.
  
  =head3 no_clobber
  
  If you set this boolean option, an existing file will not be overwritten.
  
  	write_file( $file, {no_clobber => 1}, @data ) ;
  
  =head3 err_mode
  
  You can use this option to control how C<write_file> behaves when an
  error occurs. This option defaults to 'croak'. You can set it to
  'carp' or to 'quiet' to have no error handling other than the return
  value. If the first call to C<write_file> fails it will carp and then
  write to another file. If the second call to C<write_file> fails, it
  will croak.
  
  	unless ( write_file( $file, { err_mode => 'carp', \$data ) ;
  
  		# write a different file but croak if not found
  		write_file( $other_file, \$data ) ;
  	}
  
  =head2 overwrite_file
  
  This sub is just a typeglob alias to write_file since write_file
  always overwrites an existing file. This sub is supported for
  backwards compatibility with the original version of this module. See
  write_file for its API and behavior.
  
  =head2 append_file
  
  This sub will write its data to the end of the file. It is a wrapper
  around write_file and it has the same API so see that for the full
  documentation. These calls are equivalent:
  
  	append_file( $file, @data ) ;
  	write_file( $file, {append => 1}, @data ) ;
  
  
  =head2 prepend_file
  
  This sub writes data to the beginning of a file. The previously existing
  data is written after that so the effect is prepending data in front of
  a file. It is a counterpart to the append_file sub in this module. It
  works by first using C<read_file> to slurp in the file and then calling
  C<write_file> with the new data and the existing file data.
  
  The first argument to C<prepend_file> is the filename. The next argument
  is an optional hash reference and it contains key/values that can modify
  the behavior of C<prepend_file>. The rest of the argument list is the
  data to be written to the file and that is passed to C<write_file> as is
  (see that for allowed data).
  
  Only the C<binmode> and C<err_mode> options are supported. The
  C<write_file> call has the C<atomic> option set so you will always have
  a consistant file. See above for more about those options.
  
  C<prepend_file> is not exported by default, you need to import it
  explicitly.
  
  	use File::Slurp qw( prepend_file ) ;
  	prepend_file( $file, $header ) ;
  	prepend_file( $file, \@lines ) ;
  	prepend_file( $file, { binmode => 'raw:'}, $bin_data ) ;
  
  
  =head2 edit_file, edit_file_lines
  
  These subs read in a file into $_, execute a code block which should
  modify $_ and then write $_ back to the file. The difference between
  them is that C<edit_file> reads the whole file into $_ and calls the
  code block one time. With C<edit_file_lines> each line is read into $_
  and the code is called for each line. In both cases the code should
  modify $_ if desired and it will be written back out. These subs are
  the equivalent of the -pi command line options of Perl but you can
  call them from inside your program and not fork out a process. They
  are in @EXPORT_OK so you need to request them to be imported on the
  use line or you can import both of them with:
  
  	use File::Slurp qw( :edit ) ;
  
  The first argument to C<edit_file> and C<edit_file_lines> is a code
  block or a code reference. The code block is not followed by a comma
  (as with grep and map) but a code reference is followed by a
  comma. See the examples below for both styles. The next argument is
  the filename. The last argument is an optional hash reference and it
  contains key/values that can modify the behavior of
  C<prepend_file>. 
  
  Only the C<binmode> and C<err_mode> options are supported. The
  C<write_file> call has the C<atomic> option set so you will always
  have a consistant file. See above for more about those options.
  
  Each group of calls below show a Perl command line instance and the
  equivalent calls to C<edit_file> and C<edit_file_lines>.
  
  	perl -0777 -pi -e 's/foo/bar/g' filename
  	use File::Slurp qw( edit_file ) ;
  	edit_file { s/foo/bar/g } 'filename' ;
  	edit_file sub { s/foo/bar/g }, 'filename' ;
  	edit_file \&replace_foo, 'filename' ;
  	sub replace_foo { s/foo/bar/g }
  
  	perl -pi -e '$_ = "" if /foo/' filename
  	use File::Slurp qw( edit_file_lines ) ;
  	use File::Slurp ;
  	edit_file_lines { $_ = '' if /foo/ } 'filename' ;
  	edit_file_lines sub { $_ = '' if /foo/ }, 'filename' ;
  	edit_file \&delete_foo, 'filename' ;
  	sub delete_foo { $_ = '' if /foo/ }
  
  =head2 read_dir
  
  This sub reads all the file names from directory and returns them to
  the caller but C<.> and C<..> are removed by default.
  
  	my @files = read_dir( '/path/to/dir' ) ;
  
  The first argument is the path to the directory to read.  If the next
  argument is a hash reference, then it is used as the options.
  Otherwise the rest of the argument list are is used as key/value
  options.
  
  In list context C<read_dir> returns a list of the entries in the
  directory. In a scalar context it returns an array reference which has
  the entries.
  
  =head3 err_mode
  
  If the C<err_mode> option is set, it selects how errors are handled (see
  C<err_mode> in C<read_file> or C<write_file>).
  
  =head3 keep_dot_dot
  
  If this boolean option is set, C<.> and C<..> are not removed from the
  list of files.
  
  	my @all_files = read_dir( '/path/to/dir', keep_dot_dot => 1 ) ;
  
  =head3 prefix
  
  If this boolean option is set, the string "$dir/" is prefixed to each
  dir entry. This means you can directly use the results to open
  files. A common newbie mistake is not putting the directory in front
  of entries when opening themn.
  
  	my @paths = read_dir( '/path/to/dir', prefix => 1 ) ;
  
  =head2 EXPORT
  
    These are exported by default or with
  	use File::Slurp qw( :std ) ;
  
    read_file write_file overwrite_file append_file read_dir
  
    These are exported with
  	use File::Slurp qw( :edit ) ;
  
    edit_file edit_file_lines
  
    You can get all subs in the module exported with 
  	use File::Slurp qw( :all ) ;
  
  =head2 LICENSE
  
    Same as Perl.
  
  =head2 SEE ALSO
  
  An article on file slurping in extras/slurp_article.pod. There is
  also a benchmarking script in extras/slurp_bench.pl.
  
  =head2 BUGS
  
  If run under Perl 5.004, slurping from the DATA handle will fail as
  that requires B.pm which didn't get into core until 5.005.
  
  =head1 AUTHOR
  
  Uri Guttman, E<lt>uri AT stemsystems DOT comE<gt>
  
  =cut
FILE_SLURP

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use Exporter;
  BEGIN { @JSON::ISA = 'Exporter' }
  
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.97001';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my %RequiredVersion = (
      'JSON::PP' => '2.27203',
      'JSON::XS' => '2.34',
  );
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw/allow_tags/; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1') {
          $backend = 'JSON::XS,JSON::PP';
      }
      elsif ($backend eq '0') {
          $backend = 'JSON::PP';
      }
      elsif ($backend eq '2') {
          $backend = 'JSON::XS';
      }
      $backend =~ s/\s+//g;
  
      my @backend_modules = split /,/, $backend;
      while(my $module = shift @backend_modules) {
          if ($module =~ /JSON::XS/) {
              _load_xs($module, @backend_modules ? $_INSTALL_DONT_DIE : 0);
          }
          elsif ($module =~ /JSON::PP/) {
              _load_pp($module);
          }
          elsif ($module =~ /JSON::backportPP/) {
              _load_pp($module);
          }
          else {
              Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
          }
          last if $JSON::Backend;
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend->is_xs);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              my $org_encode = $JSON::Backend->can('encode');
              eval q|
                  require B;
                  local $^W;
                  no strict 'refs';
                  *{"${JSON::Backend}\::encode"} = sub {
                      # only works with Perl 5.18+
                      local *UNIVERSAL::TO_JSON = sub {
                          my $b_obj = B::svref_2object( $_[0] );
                          return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                                  : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                                  : undef
                                  ;
                      };
                      $org_encode->(@_);
                  };
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $RequiredVersion{'JSON::XS'}; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend->is_xs;
  }
  
  
  sub is_pp {
      return $_[0]->backend->is_pp;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub __load_xs {
      my ($module, $opt) = @_;
  
      $JSON::DEBUG and Carp::carp "Load $module.";
      my $required_version = $RequiredVersion{$module} || '';
  
      eval qq|
          use $module $required_version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $module...($@)";
              return 0;
          }
          Carp::croak $@;
      }
      $JSON::BackendModuleXS = $module;
      return 1;
  }
  
  sub _load_xs {
      my ($module, $opt) = @_;
      __load_xs($module, $opt) or return;
  
      my $data = join("", <DATA>); # this code is from Jcode 2.xx.
      close(DATA);
      eval $data;
      JSON::Backend::XS->init($module);
  
      return 1;
  };
  
  
  sub __load_pp {
      my ($module, $opt) = @_;
  
      $JSON::DEBUG and Carp::carp "Load $module.";
      my $required_version = $RequiredVersion{$module} || '';
  
      eval qq| use $module $required_version () |;
  
      if ($@) {
          if ( $module eq 'JSON::PP' ) {
              $JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";
              $module = 'JSON::backportPP';
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $module |;
          }
          Carp::croak $@ if $@;
      }
      $JSON::BackendModulePP = $module;
      return 1;
  }
  
  sub _load_pp {
      my ($module, $opt) = @_;
      __load_pp($module, $opt);
  
      JSON::Backend::PP->init($module);
  };
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      my ($class, $module) = @_;
  
      # name may vary, but the module should (always) be a JSON::PP
  
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::is_bool"} = \&{"JSON::PP::is_bool"};
  
      $JSON::true  = ${"JSON::PP::true"};
      $JSON::false = ${"JSON::PP::false"};
  
      push @JSON::Backend::PP::ISA, 'JSON::PP';
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      for my $method (@XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 0 };
  sub is_pp { 1 };
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  sub init {
      my ($class, $module) = @_;
  
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"$module\::decode_json"};
      *{"JSON::encode_json"} = \&{"$module\::encode_json"};
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::Backend::XS::ISA, $module;
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      if ( $module->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      for my $method (@PPOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 1 };
  sub is_pp { 0 };
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      JSON::__load_pp('JSON::PP');
  
      local $^W;
      no strict qw(refs);
  
      for my $method (@methods) {
          my $pp_method = JSON::PP->can($method) or next;
          *{"JSON::$method"} = sub {
              if (!$_[0]->isa('JSON::PP')) {
                  my $xs_self = $_[0];
                  my $pp_self = JSON::PP->new;
                  for (@Properties) {
                       my $getter = "get_$_";
                      $pp_self->$_($xs_self->$getter);
                  }
                  $_[0] = $pp_self;
              }
              $pp_method->(@_);
          };
      }
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
  
  =head1 VERSION
  
      2.97001
  
  =head1 DESCRIPTION
  
  This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
  additional features. All the backend modules convert a Perl data structure
  to a JSON text as of RFC4627 (which we know is obsolete but we still stick
  to; see below for an option to support part of RFC7159) and vice versa.
  This module uses L<JSON::XS> by default, and when JSON::XS is not available,
  this module falls back on L<JSON::PP>, which is in the Perl core since 5.14.
  If JSON::PP is not available either, this module then falls back on
  JSON::backportPP (which is actually JSON::PP in a different .pm file)
  bundled in the same distribution as this module. You can also explicitly
  specify to use L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban.
  
  All these backend modules have slight incompatibilities between them,
  including extra features that other modules don't support, but as long as you
  use only common features (most important ones are described below), migration
  from backend to backend should be reasonably easy. For details, see each
  backend module you use.
  
  =head1 CHOOSING BACKEND
  
  This module respects an environmental variable called C<PERL_JSON_BACKEND>
  when it decides a backend module to use. If this environmental variable is
  not set, it tries to load JSON::XS, and if JSON::XS is not available, it
  falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
  either.
  
  If you always don't want it to fall back on pure perl modules, set the
  variable like this (C<export> may be C<setenv>, C<set> and the likes,
  depending on your environment):
  
    > export PERL_JSON_BACKEND=JSON::XS
  
  If you prefer Cpanel::JSON::XS to JSON::XS, then:
  
    > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
  
  You may also want to set this variable at the top of your test files, in order
  not to be bothered with incompatibilities between backends (you need to wrap
  this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
  its backend as soon as it's loaded):
  
    BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
    use JSON;
  
  =head1 USING OPTIONAL FEATURES
  
  There are a few options you can set when you C<use> this module:
  
  =over
  
  =item -support_by_pp
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     # escape_slash is for JSON::PP only.
     $json->allow_nonref->escape_slash->encode("/");
  
  With this option, this module loads its pure perl backend along with
  its XS backend (if available), and lets the XS backend to watch if you set
  a flag only JSON::PP supports. When you do, the internal JSON::XS object
  is replaced with a newly created JSON::PP object with the setting copied
  from the XS object, so that you can use JSON::PP flags (and its slower
  C<decode>/C<encode> methods) from then on. In other words, this is not
  something that allows you to hook JSON::XS to change its behavior while
  keeping its speed. JSON::XS and JSON::PP objects are quite different
  (JSON::XS object is a blessed scalar reference, while JSON::PP object is
  a blessed hash reference), and can't share their internals.
  
  To avoid needless overhead (by copying settings), you are advised not
  to use this option and just to use JSON::PP explicitly when you need
  JSON::PP features.
  
  =item -convert_blessed_universally
  
     use JSON -convert_blessed_universally;
  
     my $json = JSON->new->allow_nonref->convert_blessed;
     my $object = bless {foo => 'bar'}, 'Foo';
     $json->encode($object); # => {"foo":"bar"}
  
  JSON::XS-compatible backend modules don't encode blessed objects by
  default (except for their boolean values, which are typically blessed
  JSON::PP::Boolean objects). If you need to encode a data structure
  that may contain objects, you usually need to look into the structure
  and replace objects with alternative non-blessed values, or enable
  C<convert_blessed> and provide a C<TO_JSON> method for each object's
  (base) class that may be found in the structure, in order to let the
  methods replace the objects with whatever scalar values the methods
  return.
  
  If you need to serialise data structures that may contain arbitrary
  objects, it's probably better to use other serialisers (such as
  L<Sereal> or L<Storable> for example), but if you do want to use
  this module for that purpose, C<-convert_blessed_universally> option
  may help, which tweaks C<encode> method of the backend to install
  C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
  all the objects that don't have their own C<TO_JSON> method can
  fall back on the method in the C<UNIVERSAL> namespace. Note that you
  still need to enable C<convert_blessed> flag to actually encode
  objects in a data structure, and C<UNIVERSAL::TO_JSON> method
  installed by this option only converts blessed hash/array references
  into their unblessed clone (including private keys/values that are
  not supposed to be exposed). Other blessed references will be
  converted into null.
  
  This feature is experimental and may be removed in the future.
  
  =item -no_export
  
  When you don't want to import functional interfaces from a module, you
  usually supply C<()> to its C<use> statement.
  
      use JSON (); # no functional interfaces
  
  If you don't want to import functional interfaces, but you also want to
  use any of the above options, add C<-no_export> to the option list.
  
     # no functional interfaces, while JSON::PP support is enabled.
     use JSON -support_by_pp, -no_export;
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS. C<encode_json> and C<decode_json>
  are exported by default.
  
  This module also exports C<to_json> and C<from_json> for backward
  compatibility. These are slower, and may expect/generate different stuff
  from what C<encode_json> and C<decode_json> do, depending on their
  options. It's better just to use Object-Oriented interfaces than using
  these two functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar[, $optional_hashref])
  
  Converts the given Perl data structure to a Unicode string by default.
  Croaks on error.
  
  Basically, this function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Except being slower.
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<to_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
     # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text[, $optional_hashref])
  
  The opposite of C<to_json>: expects a Unicode string and tries
  to parse it, returning the resulting reference. Croaks on error.
  
  Basically, this function call is functionally identical to:
  
      $perl_scalar = JSON->new->decode($json_text)
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<from_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
      # => JSON->new->utf8(1)->decode($json_text)
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON->new
  
  Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the backend object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 ADDITIONAL METHODS
  
  The following methods are for this module only.
  
  =head2 backend
  
      $backend = $json->backend
  
  Since 2.92, C<backend> method returns an abstract backend module used currently,
  which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
  or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
  backend module globally.
  
  If you need to know what is used actually, use C<isa>, instead of string comparison.
  
  =head2 is_xs
  
      $boolean = $json->is_xs
  
  Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
  
  =head2 is_pp
  
      $boolean = $json->is_pp
  
  Returns true if the backend inherits JSON::PP.
  
  =head2 property
  
      $settings = $json->property()
  
  Returns a reference to a hash that holds all the common flag settings.
  
      $json = $json->property('utf8' => 1)
      $value = $json->property('utf8') # 1
  
  You can use this to get/set a value of a particular flag.
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how the backend modules map Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, this module will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, this module only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. This module can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same data structure will
  serialise to the same JSON text (given same settings and version of
  the same backend), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     encode_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: this module will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As for Perl objects, this module only supports a pure JSON representation
  (without the ability to deserialise the object automatically again).
  
  =head3 SERIALISATION
  
  What happens when this module encounters a Perl object depends on the
  C<allow_blessed> and C<convert_blessed> settings, which are used in
  this order:
  
  =over 4
  
  =item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 3. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  this module throws an exception.
  
  =back
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BACKWARD INCOMPATIBILITY
  
  Since version 2.90, stringification (and string comparison) for
  C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
  matter as long as you treat them as boolean values, but a code that
  expects they are stringified as "true" or "false" doesn't work as
  you have expected any more.
  
      if (JSON::true eq 'true') {  # now fails
  
      print "The result is $JSON::true now."; # => The result is 1 now.
  
  And now these boolean values don't inherit JSON::Boolean, either.
  When you need to test a value is a JSON boolean value or not, use
  C<JSON::is_bool> function, instead of testing the value inherits
  a particular boolean class or not.
  
  =head1 BUGS
  
  Please report bugs on backend selection and additional features
  this module provides to RT or GitHub issues for this module:
  
  =over 4
  
  =item https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON
  
  =item https://github.com/makamaka/JSON/issues
  
  =back
  
  Please report bugs and feature requests on decoding/encoding
  and boolean behaviors to the author of the backend module you
  are using.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
  
  L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  
  use Exporter ();
  BEGIN { @JSON::backportPP::ISA = ('Exporter') }
  
  use overload ();
  use JSON::backportPP::Boolean;
  
  use Carp ();
  #use Devel::Peek;
  
  $JSON::backportPP::VERSION = '2.97001';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  use constant USE_B => 0;
  
  BEGIN {
  if (USE_B) {
      require B;
  }
  }
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enabled?
      # Helper module sets @JSON::PP::_properties.
      if ( OLD_PERL ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $property_id = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      if (defined $_[1] and ref $_[1] eq 'CODE') {
          $_[0]->{cb_object} = $_[1];
      } else {
          delete $_[0]->{cb_object};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ == 1 or @_ > 3) {
          Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)");
      }
      if (defined $_[2] and ref $_[2] eq 'CODE') {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      } else {
          delete $_[0]->{cb_sk_object}->{$_[1]};
          delete $_[0]->{cb_sk_object} unless %{$_[0]->{cb_sk_object} || {}};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
      $_[0]->allow_bignum;
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $props = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$props}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$props->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($props->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
  
                  if ($allow_blessed) {
                      return $self->blessed_to_json($obj) if ($as_nonblessed); # will be removed.
                      return 'null';
                  }
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  );
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, $self->string_to_json( $k )
                            .  $del
                            . ( ref $obj->{$k} ? $self->object_to_json( $obj->{$k} ) : $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '{}' unless @res;
          return '{' . $pre . join( ",$pre", @res ) . $post . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, ref($v) ? $self->object_to_json($v) : $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[]' unless @res;
          return '[' . $pre . join( ",$pre", @res ) . $post . ']';
      }
  
      sub _looks_like_number {
          my $value = shift;
          if (USE_B) {
              my $b_obj = B::svref_2object(\$value);
              my $flags = $b_obj->FLAGS;
              return 1 if $flags & ( B::SVp_IOK() | B::SVp_NOK() ) and !( $flags & B::SVp_POK() );
              return;
          } else {
              no warnings 'numeric';
              # if the utf8 flag is on, it almost certainly started as a string
              return if utf8::is_utf8($value);
              # detect numbers
              # string & "" -> ""
              # number & "" -> 0 (with warning)
              # nan and inf can detect as numbers, so check with * 0
              return unless length((my $dummy = "") & $value);
              return unless 0 + $value eq $value;
              return 1 if $value * 0 == 0;
              return -1; # inf/nan
          }
      }
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $type = ref($value);
  
          if (!$type) {
              if (_looks_like_number($value)) {
                  return $value;
              }
              return $self->string_to_json($value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          else {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
              if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                  return 'null';
              }
              else {
                  if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                  }
                  else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                  }
              }
  
          }
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # first character
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bignum;   # using Math::BigInt/BigFloat
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      sub _detect_utf_encoding {
          my $text = shift;
          my @octets = unpack('C4', $text);
          return 'unknown' unless defined $octets[3];
          return ( $octets[0] and  $octets[1]) ? 'UTF-8'
               : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
               : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
               : ( $octets[2]                ) ? 'UTF-16LE'
               : (!$octets[2]                ) ? 'UTF-32LE'
               : 'unknown';
      }
  
      sub PP_decode_json {
          my ($self, $want_offset);
  
          ($self, $text, $want_offset) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $props = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bignum, $allow_barekey, $singlequote)
              = @{$props}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              $encoding = _detect_utf_encoding($text);
              if ($encoding ne 'UTF-8' and $encoding ne 'unknown') {
                  require Encode;
                  Encode::from_to($text, $encoding, 'utf-8');
              } else {
                  utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
              }
          }
          else {
              utf8::upgrade( $text );
              utf8::encode( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          white(); # remove head white space
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          if ( !$props->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          return ( $result, $consumed ) if $want_offset; # all right if decode_prefix
  
          decode_error("garbage after JSON object") if defined $ch;
  
          $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          my $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          unless( $ch = is_valid_utf8($ch) ) {
                              $at -= 1;
                              decode_error("malformed UTF-8 character in JSON string");
                          }
                          else {
                              $at += $utf8_len - 1;
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){
                  next_chr();
              }
              elsif($relaxed and $ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
          my $is_dec;
          my $is_exp;
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              if($peek =~ /^[0-9a-dfA-DF]/){ # e may be valid (exponential)
                  decode_error("malformed number (leading zero must not be followed by another digit)");
              }
              $n .= $ch;
              next_chr;
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
              $is_dec = 1;
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              $is_exp = 1;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($is_dec or $is_exp) {
              if ($allow_bignum) {
                  require Math::BigFloat;
                  return Math::BigFloat->new($v);
              }
          } else {
              if (length $v > $max_intsize) {
                  if ($allow_bignum) { # from Adam Sussman
                      require Math::BigInt;
                      return Math::BigInt->new($v);
                  }
                  else {
                      return "$v";
                  }
              }
          }
  
          return $is_dec ? $v/1.0 : 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = 'U*';
  
          if ( OLD_PERL ) {
              my $type   =  $] <  5.006           ? 'C*'
                          : utf8::is_utf8( $str ) ? 'U*' # 5.6
                          : 'C*'
                          ;
          }
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( !OLD_PERL ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
          if ($] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
              package # hide from PAUSE
                JSON::PP;
              require subs;
              subs->import('join');
              eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |;
          }
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          require B;
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { blessed $_[0] and $_[0]->isa("JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::backportPP::IncrParser::VERSION = '1.01';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_pos     => 0,
          incr_mode    => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
      if ( defined wantarray ) {
          my $max_size = $coder->get_max_size;
          my $p = $self->{incr_pos};
          my @ret;
          {
              do {
                  unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->_incr_parse( $coder );
  
                      if ( $max_size and $self->{incr_pos} > $max_size ) {
                          Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size");
                      }
                      unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                          # as an optimisation, do not accumulate white space in the incr buffer
                          if ( $self->{incr_mode} == INCR_M_WS and $self->{incr_pos} ) {
                              $self->{incr_pos} = 0;
                              $self->{incr_text} = '';
                          }
                          last;
                      }
                  }
  
                  my ($obj, $offset) = $coder->PP_decode_json( $self->{incr_text}, 0x00000001 );
                  push @ret, $obj;
                  use bytes;
                  $self->{incr_text} = substr( $self->{incr_text}, $offset || 0 );
                  $self->{incr_pos} = 0;
                  $self->{incr_nest} = 0;
                  $self->{incr_mode} = 0;
                  last unless wantarray;
              } while ( wantarray );
          }
  
          if ( wantarray ) {
              return @ret;
          }
          else { # in scalar context
              return $ret[0] ? $ret[0] : undef;
          }
      }
  }
  
  
  sub _incr_parse {
      my ($self, $coder) = @_;
      my $text = $self->{incr_text};
      my $len = length $text;
      my $p = $self->{incr_pos};
  
  INCR_PARSE:
      while ( $len > $p ) {
          my $s = substr( $text, $p, 1 );
          last INCR_PARSE unless defined $s;
          my $mode = $self->{incr_mode};
  
          if ( $mode == INCR_M_WS ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( ord($s) > 0x20 ) {
                      if ( $s eq '#' ) {
                          $self->{incr_mode} = INCR_M_C0;
                          redo INCR_PARSE;
                      } else {
                          $self->{incr_mode} = INCR_M_JSON;
                          redo INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_BS ) {
              $p++;
              $self->{incr_mode} = INCR_M_STR;
              redo INCR_PARSE;
          } elsif ( $mode == INCR_M_C0 or $mode == INCR_M_C1 ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq "\n" ) {
                      $self->{incr_mode} = $self->{incr_mode} == INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;
                      last;
                  }
                  $p++;
              }
              next;
          } elsif ( $mode == INCR_M_STR ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq '"' ) {
                      $p++;
                      $self->{incr_mode} = INCR_M_JSON;
  
                      last INCR_PARSE unless $self->{incr_nest};
                      redo INCR_PARSE;
                  }
                  elsif ( $s eq '\\' ) {
                      $p++;
                      if ( !defined substr($text, $p, 1) ) {
                          $self->{incr_mode} = INCR_M_BS;
                          last INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_JSON ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p++, 1 );
                  if ( $s eq "\x00" ) {
                      $p--;
                      last INCR_PARSE;
                  } elsif ( $s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20" ) {
                      if ( !$self->{incr_nest} ) {
                          $p--; # do not eat the whitespace, let the next round do it
                          last INCR_PARSE;
                      }
                      next;
                  } elsif ( $s eq '"' ) {
                      $self->{incr_mode} = INCR_M_STR;
                      redo INCR_PARSE;
                  } elsif ( $s eq '[' or $s eq '{' ) {
                      if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                          Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                      }
                      next;
                  } elsif ( $s eq ']' or $s eq '}' ) {
                      if ( --$self->{incr_nest} <= 0 ) {
                          last INCR_PARSE;
                      }
                  } elsif ( $s eq '#' ) {
                      $self->{incr_mode} = INCR_M_C1;
                      redo INCR_PARSE;
                  }
              }
          }
      }
  
      $self->{incr_pos} = $p;
      $self->{incr_parsing} = $p ? 1 : 0; # for backward compatibility
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_pos} ) {
          Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_pos} );
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $json = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $pretty_printed_json_text = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.97001
  
  =head1 DESCRIPTION
  
  JSON::PP is a pure perl JSON decoder/encoder (as of RFC4627, which
  we know is obsolete but we still stick to; see below for an option
  to support part of RFC7159), and (almost) compatible to much
  faster L<JSON::XS> written by Marc Lehmann in C. JSON::PP works as
  a fallback module when you use L<JSON> module without having
  installed JSON::XS.
  
  Because of this fallback feature of JSON.pm, JSON::PP tries not to
  be more JavaScript-friendly than JSON::XS (i.e. not to escape extra
  characters such as U+2028 and U+2029 nor support RFC7159/ECMA-404),
  in order for you not to lose such JavaScript-friendliness silently
  when you use JSON.pm and install JSON::XS for speed or by accident.
  If you need JavaScript-friendly RFC7159-compliant pure perl module,
  try L<JSON::Tiny>, which is derived from L<Mojolicious> web
  framework and is also smaller and faster than JSON::PP.
  
  JSON::PP has been in the Perl core since Perl 5.14, mainly for
  CPAN toolchain modules to parse META.json.
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS almost verbatim. C<encode_json>
  and C<decode_json> are exported by default.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Creates a new JSON::PP object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON::PP object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::PP->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =item * C-style multiple-line '/* */'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C-style multiple-line comments are additionally
  allowed. Everything between C</*> and C<*/> is a comment, after which
  more white-space and comments are allowed.
  
    [
       1, /* this comment not allowed in JSON */
          /* neither this one... */
    ]
  
  =item * C++-style one-line '//'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C++-style one-line comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, // this comment not allowed in JSON
          // neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk (i.e. downgraded if possible).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is false, then JSON::PP does nothing.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::PP->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 FLAGS FOR JSON::PP ONLY
  
  The following flags and properties are for JSON::PP only. If you use
  any of these, you can't make your application run faster by replacing
  JSON::PP with JSON::XS. If you need these and also speed boost,
  try L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban, which
  supports some of these.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
      $enabled = $json->get_allow_singlequote
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain strings that begin and end with
  single quotation marks. C<encode> will not be affected in anyway.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_singlequote->decode(qq|{"foo":'bar'}|);
      $json->allow_singlequote->decode(qq|{'foo':"bar"}|);
      $json->allow_singlequote->decode(qq|{'foo':'bar'}|);
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
      $enabled = $json->get_allow_barekey
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain JSON objects whose names don't
  begin and end with quotation marks. C<encode> will not be affected
  in anyway. I<Be aware that this option makes you accept invalid JSON
  texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_barekey->decode(qq|{foo:"bar"}|);
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
      $enabled = $json->get_allow_bignum
  
  If C<$enable> is true (or missing), then C<decode> will convert
  big integers Perl cannot handle as integer into L<Math::BigInt>
  objects and convert floating numbers into L<Math::BigFloat>
  objects. C<encode> will convert C<Math::BigInt> and C<Math::BigFloat>
  objects into JSON numbers.
  
     $json->allow_nonref->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See also L<MAPPING>.
  
  =head2 loose
  
      $json = $json->loose([$enable])
      $enabled = $json->get_loose
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c]
  characters. C<encode> will not be affected in anyway.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
      $enabled = $json->get_escape_slash
  
  If C<$enable> is true (or missing), then C<encode> will explicitly
  escape I<slash> (solidus; C<U+002F>) characters to reduce the risk of
  XSS (cross site scripting) that may be caused by C<< </script> >>
  in a JSON text, with the cost of bloating the size of JSON texts.
  
  This option may be useful when you embed JSON in HTML, but embedding
  arbitrary JSON in HTML (by some HTML template toolkit or by string
  interpolation) is risky in general. You must escape necessary
  characters in correct order, depending on the context.
  
  C<decode> will not be affected in anyway.
  
  =head2 indent_length
  
      $json = $json->indent_length($number_of_spaces)
      $length = $json->get_indent_length
  
  This option is only useful when you also enable C<indent> or C<pretty>.
  
  JSON::XS indents with three spaces when you C<encode> (if requested
  by C<indent> or C<pretty>), and the number cannot be changed.
  JSON::PP allows you to change/get the number of indent spaces with these
  mutator/accessor. The default number of spaces is three (the same as
  JSON::XS), and the acceptable range is from C<0> (no indentation;
  it'd be better to disable indentation by C<indent(0)>) to C<15>.
  
  =head2 sort_by
  
      $json = $json->sort_by($code_ref)
      $json = $json->sort_by($subroutine_name)
  
  If you just want to sort keys (names) in JSON objects when you
  C<encode>, enable C<canonical> option (see above) that allows you to
  sort object keys alphabetically.
  
  If you do need to sort non-alphabetically for whatever reasons,
  you can give a code reference (or a subroutine name) to C<sort_by>,
  then the argument will be passed to Perl's C<sort> built-in function.
  
  As the sorting is done in the JSON::PP scope, you usually need to
  prepend C<JSON::PP::> to the subroutine name, and the special variables
  C<$a> and C<$b> used in the subrontine used by C<sort> function.
  
  Example:
  
     my %ORDER = (id => 1, class => 2, name => 3);
     $json->sort_by(sub {
         ($ORDER{$JSON::PP::a} // 999) <=> ($ORDER{$JSON::PP::b} // 999)
         or $JSON::PP::a cmp $JSON::PP::b
     });
     print $json->encode([
         {name => 'CPAN', id => 1, href => 'http://cpan.org'}
     ]);
     # [{"id":1,"name":"CPAN","href":"http://cpan.org"}]
  
  Note that C<sort_by> affects all the plain hashes in the data structure.
  If you need finer control, C<tie> necessary hashes with a module that
  implements ordered hash (such as L<Hash::Ordered> and L<Tie::IxHash>).
  C<canonical> and C<sort_by> don't affect the key order in C<tie>d
  hashes.
  
     use Hash::Ordered;
     tie my %hash, 'Hash::Ordered',
         (name => 'CPAN', id => 1, href => 'http://cpan.org');
     print $json->encode([\%hash]);
     # [{"name":"CPAN","id":1,"href":"http://cpan.org"}] # order is kept
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::PP will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON::PP->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how JSON::PP maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::PP will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::PP only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enabled, big integer values and any numeric
  values will be converted into L<Math::BigInt> and L<Math::BigFloat>
  objects respectively, without becoming string scalars or losing
  precision.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::PP::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::PP can optionally sort the hash keys
  (determined by the I<canonical> flag and/or I<sort_by> property), so
  the same data structure will serialise to the same JSON text (given
  same settings and version of JSON::PP), but this incurs a runtime
  overhead and is only rarely useful, e.g. when you want to compare some
  JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::PP::false> and C<JSON::PP::true> to improve
  readability.
  
     to_json [\0, JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item JSON::PP::null
  
  This special value becomes JSON null.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::PP>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
                  # (but for older perls)
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You cannot currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON::PP (and JSON::XS) trusts what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON::PP considers tainted and
  doesn't trust). As JSON::PP doesn't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As for Perl objects, JSON::PP only supports a pure JSON representation (without the ability to deserialise the object automatically again).
  
  =head3 SERIALISATION
  
  What happens when C<JSON::PP> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_bignum> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<allow_bignum> is enabled and the object is a C<Math::BigInt> or C<Math::BigFloat>.
  
  The object will be serialised as a JSON number value.
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::PP> throws an exception.
  
  =back
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 SEE ALSO
  
  The F<json_pp> command line utility for quick experiments.
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, and L<JSON::Tiny> for faster alternatives.
  L<JSON> and L<JSON::MaybeXS> for easy migration.
  
  L<JSON::backportPP::Compat5005> and L<JSON::backportPP::Compat5006> for older perl users.
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2016 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  package # This is JSON::backportPP
      JSON::PP::Boolean;
  
  use strict;
  use overload (
      "0+"     => sub { ${$_[0]} },
      "++"     => sub { $_[0] = ${$_[0]} + 1 },
      "--"     => sub { $_[0] = ${$_[0]} - 1 },
      fallback => 1,
  );
  
  $JSON::backportPP::Boolean::VERSION = '2.97001';
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  my $have_xs;
  our $VERSION = '0.428';
  
  BEGIN
  {
      unless (defined($have_xs))
      {
          eval { require List::MoreUtils::XS; } unless $ENV{LIST_MOREUTILS_PP};
          die $@ if $@ && defined $ENV{LIST_MOREUTILS_PP} && $ENV{LIST_MOREUTILS_PP} == 0;
          $have_xs = 0+defined( $INC{'List/MoreUtils/XS.pm'});
      }
  
      use List::MoreUtils::PP qw();
  }
  
  use Exporter::Tiny qw();
  
  my @junctions = qw(any all none notall);
  my @v0_22     = qw(
    true false
    firstidx lastidx
    insert_after insert_after_string
    apply indexes
    after after_incl before before_incl
    firstval lastval
    each_array each_arrayref
    pairwise natatime
    mesh uniq
    minmax part
    _XScompiled
  );
  my @v0_24  = qw(bsearch);
  my @v0_33  = qw(sort_by nsort_by);
  my @v0_400 = qw(one any_u all_u none_u notall_u one_u
    firstres onlyidx onlyval onlyres lastres
    singleton bsearchidx
  );
  my @v0_420 = qw(arrayify duplicates minmaxstr samples zip6 reduce_0 reduce_1 reduce_u
    listcmp frequency occurrences mode
    binsert bremove equal_range lower_bound upper_bound qsort);
  
  my @all_functions = (@junctions, @v0_22, @v0_24, @v0_33, @v0_400, @v0_420);
  
  no strict "refs";
  if ($have_xs)
  {
      my $x;
      for (@all_functions)
      {
          List::MoreUtils->can($_) or *$_ = $x if ($x = List::MoreUtils::XS->can($_));
      }
  }
  List::MoreUtils->can($_) or *$_ = List::MoreUtils::PP->can($_) for (@all_functions);
  use strict;
  
  my %alias_list = (
      v0_22 => {
          first_index => "firstidx",
          last_index  => "lastidx",
          first_value => "firstval",
          last_value  => "lastval",
          zip         => "mesh",
      },
      v0_33 => {
          distinct => "uniq",
      },
      v0_400 => {
          first_result  => "firstres",
          only_index    => "onlyidx",
          only_value    => "onlyval",
          only_result   => "onlyres",
          last_result   => "lastres",
          bsearch_index => "bsearchidx",
      },
      v0_420 => {
  	bsearch_insert => "binsert",
  	bsearch_remove => "bremove",
  	zip_unflatten  => "zip6",
      },
  );
  
  our @ISA         = qw(Exporter::Tiny);
  our @EXPORT_OK   = (@all_functions, map { keys %$_ } values %alias_list);
  our %EXPORT_TAGS = (
      all         => \@EXPORT_OK,
      'like_0.22' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          none_u   => {-as => 'none'},
          notall_u => {-as => 'notall'},
          @v0_22,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.24' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          notall_u => {-as => 'notall'},
          'none',
          @v0_22,
          @v0_24,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.33' => [
          @junctions,
          @v0_22,
          # v0_24 functions were omitted
          @v0_33,
          keys %{$alias_list{v0_22}},
          keys %{$alias_list{v0_33}},
      ],
  );
  
  for my $set (values %alias_list)
  {
      for my $alias (keys %$set)
      {
          no strict qw(refs);
          *$alias = __PACKAGE__->can($set->{$alias});
      }
  }
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      # import specific functions
  
      use List::MoreUtils qw(any uniq);
  
      if ( any { /foo/ } uniq @has_duplicates ) {
          # do stuff
      }
  
      # import everything
  
      use List::MoreUtils ':all';
  
      # import by API
  
      # has "original" any/all/none/notall behavior
      use List::MoreUtils ':like_0.22';
      # 0.22 + bsearch
      use List::MoreUtils ':like_0.24';
      # has "simplified" any/all/none/notall behavior + (n)sort_by
      use List::MoreUtils ':like_0.33';
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =head1 EXPORTS
  
  =head2 Default behavior
  
  Nothing by default. To import all of this module's symbols use the C<:all> tag.
  Otherwise functions can be imported by name as usual:
  
      use List::MoreUtils ':all';
  
      use List::MoreUtils qw{ any firstidx };
  
  Because historical changes to the API might make upgrading List::MoreUtils
  difficult for some projects, the legacy API is available via special import
  tags.
  
  =head2 Like version 0.22 (last release with original API)
  
  This API was available from 2006 to 2009, returning undef for empty lists on
  C<all>/C<any>/C<none>/C<notall>:
  
      use List::MoreUtils ':like_0.22';
  
  This import tag will import all functions available as of version 0.22.
  However, it will import C<any_u> as C<any>, C<all_u> as C<all>, C<none_u> as
  C<none>, and C<notall_u> as C<notall>.
  
  =head2 Like version 0.24 (first incompatible change)
  
  This API was available from 2010 to 2011.  It changed the return value of C<none>
  and added the C<bsearch> function.
  
      use List::MoreUtils ':like_0.24';
  
  This import tag will import all functions available as of version 0.24.
  However it will import C<any_u> as C<any>, C<all_u> as C<all>, and
  C<notall_u> as C<notall>.  It will import C<none> as described in
  the documentation below (true for empty list).
  
  =head2 Like version 0.33 (second incompatible change)
  
  This API was available from 2011 to 2014. It is widely used in several CPAN
  modules and thus it's closest to the current API.  It changed the return values
  of C<any>, C<all>, and C<notall>.  It added the C<sort_by> and C<nsort_by> functions
  and the C<distinct> alias for C<uniq>.  It omitted C<bsearch>.
  
      use List::MoreUtils ':like_0.33';
  
  This import tag will import all functions available as of version 0.33.  Note:
  it will not import C<bsearch> for consistency with the 0.33 API.
  
  =head1 FUNCTIONS
  
  =head2 Junctions
  
  =head3 I<Treatment of an empty list>
  
  There are two schools of thought for how to evaluate a junction on an
  empty list:
  
  =over
  
  =item *
  
  Reduction to an identity (boolean)
  
  =item *
  
  Result is undefined (three-valued)
  
  =back
  
  In the first case, the result of the junction applied to the empty list is
  determined by a mathematical reduction to an identity depending on whether
  the underlying comparison is "or" or "and".  Conceptually:
  
                      "any are true"      "all are true"
                      --------------      --------------
      2 elements:     A || B || 0         A && B && 1
      1 element:      A || 0              A && 1
      0 elements:     0                   1
  
  In the second case, three-value logic is desired, in which a junction
  applied to an empty list returns C<undef> rather than true or false 
  
  Junctions with a C<_u> suffix implement three-valued logic.  Those
  without are boolean.
  
  =head3 all BLOCK LIST
  
  =head3 all_u BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "All values are non-negative"
      if all { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<all> returns true (i.e. no values failed the condition)
  and C<all_u> returns C<undef>.
  
  Thus, C<< all_u(@list) >> is equivalent to C<< @list ? all(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<all_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 any BLOCK LIST
  
  =head3 any_u BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "At least one non-negative value"
      if any { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<any> returns false and C<any_u> returns C<undef>.
  
  Thus, C<< any_u(@list) >> is equivalent to C<< @list ? any(@list) : undef >>.
  
  =head3 none BLOCK LIST
  
  =head3 none_u BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "No non-negative values"
      if none { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<none> returns true (i.e. no values failed the condition)
  and C<none_u> returns C<undef>.
  
  Thus, C<< none_u(@list) >> is equivalent to C<< @list ? none(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<none_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 notall BLOCK LIST
  
  =head3 notall_u BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
    print "Not all values are non-negative"
      if notall { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<notall> returns false and C<notall_u> returns C<undef>.
  
  Thus, C<< notall_u(@list) >> is equivalent to C<< @list ? notall(@list) : undef >>.
  
  =head3 one BLOCK LIST
  
  =head3 one_u BLOCK LIST
  
  Returns a true value if precisely one item in LIST meets the criterion
  given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "Precisely one value defined"
          if one { defined($_) } @list;
  
  Returns false otherwise.
  
  For an empty LIST, C<one> returns false and C<one_u> returns C<undef>.
  
  The expression C<one BLOCK LIST> is almost equivalent to
  C<1 == true BLOCK LIST>, except for short-cutting.
  Evaluation of BLOCK will immediately stop at the second true value.
  
  =head2 Transformation
  
  =head3 apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
    my @list = (1 .. 4);
    my @mult = apply { $_ *= 2 } @list;
    print "\@list = @list\n";
    print "\@mult = @mult\n";
    __END__
    @list = 1 2 3 4
    @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
    for (my @mult = @list) { $_ *= 2 }
  
  =head3 insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
    my @list = qw/This is a list/;
    insert_after { $_ eq "a" } "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
    my @list = qw/This is a list/;
    insert_after_string "a", "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
    @a = (1 .. 5);
    @b = (11 .. 15);
    @x = pairwise { $a + $b } @a, @b;     # returns 12, 14, 16, 18, 20
  
    # mesh with pairwise
    @a = qw/a b c/;
    @b = qw/1 2 3/;
    @x = pairwise { ($a, $b) } @a, @b;    # returns a, 1, b, 2, c, 3
  
  =head3 mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =head3 zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = mesh @x, @y;         # returns a, 1, b, 2, c, 3, d, 4
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =head3 zip6
  
  =head3 zip_unflatten
  
  Returns a list of arrays consisting of the first elements of each array,
  then the second, then the third, etc, until all arrays are exhausted.
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = zip6 @x, @y;         # returns [a, 1], [b, 2], [c, 3], [d, 4]
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = zip6 @a, @b, @c;     # [x, 1, zip], [undef, 2, zap], [undef, undef, zot]
  
  C<zip_unflatten> is an alias for C<zip6>.
  
  =head3 listcmp ARRAY0 ARRAY1 [ ARRAY2 ... ]
  
  Returns an associative list of elements and every I<id> of the list it
  was found in. Allowes easy implementation of @a & @b, @a | @b, @a ^ @b and
  so on.
  Undefined entries in any given array are skipped.
  
    my @a = qw(one two three four five six seven eight nine ten eleven twelve thirteen);
    my @b = qw(two three five seven eleven thirteen seventeen);
    my @c = qw(one one two three five eight thirteen twentyone);
    my %cmp = listcmp @a, @b, @c; # returns (one => [0, 2], two => [0, 1, 2], three => [0, 1, 2], four => [0], ...)
  
    my @seq = (1, 2, 3);
    my @prim = (undef, 2, 3, 5);
    my @fib = (1, 1, 2);
    my $cmp = listcmp @seq, @prim, @fib;
    # returns { 1 => [0, 2], 2 => [0, 1, 2], 3 => [0, 1], 5 => [1] }
  
  =head3 arrayify LIST[,LIST[,LIST...]]
  
  Returns a list costisting of each element of given arrays. Recursive arrays
  are flattened, too.
  
    @a = (1, [[2], 3], 4, [5], 6, [7], 8, 9);
    @l = arrayify @a;         # returns 1, 2, 3, 4, 5, 6, 7, 8, 9
  
  =head3 uniq LIST
  
  =head3 distinct LIST
  
  Returns a new list by stripping duplicate values in LIST by comparing
  the values as hash keys, except that undef is considered separate from ''.
  The order of elements in the returned list is the same as in LIST. In
  scalar context, returns the number of unique elements in LIST.
  
    my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
    my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
    # returns "Mike", "Michael", "Richard", "Rick"
    my @n = distinct "Mike", "Michael", "Richard", "Rick", "Michael", "Rick"
    # returns "A8", "", undef, "A5", "S1"
    my @s = distinct "A8", "", undef, "A5", "S1", "A5", "A8"
    # returns "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C"
    my @w = uniq "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C", "Giulietta", "Giulia"
  
  C<distinct> is an alias for C<uniq>.
  
  B<RT#49800> can be used to give feedback about this behavior.
  
  =head3 singleton LIST
  
  Returns a new list by stripping values in LIST occurring more than once by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @x = singleton 1,1,2,2,3,4,5 # returns 3 4 5
  
  =head3 duplicates LIST
  
  Returns a new list by stripping values in LIST occuring less than twice by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @y = duplicates 1,1,2,4,7,2,3,4,6,9; #returns 1,2,4
  
  =head3 frequency LIST
  
  Returns an associative list of distinct values and the corresponding frequency.
  
    my @f = frequency values %radio_nrw; # returns (
    #  'Deutschlandfunk (DLF)' => 9, 'WDR 3' => 10,
    #  'WDR 4' => 11, 'WDR 5' => 14, 'WDR Eins Live' => 14,
    #  'Deutschlandradio Kultur' => 8,...)
  
  =head3 occurrences LIST
  
  Returns a new list of frequencies and the corresponding values from LIST.
  
    my @o = occurrences ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4);
    #  @o = (undef, undef, [3, 5], [1], [2, 6], undef, undef, [4]);
  
  =head3 mode LIST
  
  Returns the modal value of LIST. In scalar context, just the modal value
  is returned, in list context all probes occuring I<modal> times are returned,
  too.
  
    my @m = mode ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4, (7) x 3, (8) x 7);
    #  @m = (7, 4, 8) - bimodal LIST
  
  =head2 Partitioning
  
  =head3 after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
    @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =head3 after_incl BLOCK LIST
  
  Same as C<after> but also includes the element for which BLOCK is true.
  
  =head3 before BLOCK LIST
  
  Returns a list of values of LIST up to (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =head3 before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =head3 part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
    my $i = 0;
    my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
    my @part = part { 2 } 1 .. 10;            # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
    my @part = part { -1 } 1 .. 10;
    __END__
    Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
    my @idx  = ( 0, 1, -1 );
    my $i    = 0;
    my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =head3 samples COUNT LIST
  
  Returns a new list containing COUNT random samples from LIST. Is similar to
  L<List::Util/shuffle>, but stops after COUNT.
  
    @r  = samples 10, 1..10; # same as shuffle
    @r2 = samples 5, 1..10; # gives 5 values from 1..10;
  
  =head2 Iteration
  
  =head3 each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
    my $ea = each_array(@a, @b, @c);
    while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it returns
  the index of the last fetched set of values, as a scalar.
  
  =head3 each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =head3 natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
    my @x = ('a' .. 'g');
    my $it = natatime 3, @x;
    while (my @vals = $it->())
    {
      print "@vals\n";
    }
  
  This prints
  
    a b c
    d e f
    g
  
  =head2 Searching
  
  =head3 firstval BLOCK LIST
  
  =head3 first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_value> is an alias for C<firstval>.
  
  =head3 onlyval BLOCK LIST
  
  =head3 only_value BLOCK LIST
  
  Returns the only element in LIST for which BLOCK evaluates to true. Sets
  C<$_> for each item in LIST in turn. Returns C<undef> if no such element
  has been found.
  
  C<only_value> is an alias for C<onlyval>.
  
  =head3 lastval BLOCK LIST
  
  =head3 last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_value> is an alias for C<lastval>.
  
  =head3 firstres BLOCK LIST
  
  =head3 first_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<first_result> is an alias for C<firstres>.
  
  =head3 onlyres BLOCK LIST
  
  =head3 only_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Sets C<$_> for each item in LIST in turn. Returns
  C<undef> if no such element has been found.
  
  C<only_result> is an alias for C<onlyres>.
  
  =head3 lastres BLOCK LIST
  
  =head3 last_result BLOCK LIST
  
  Returns the result of BLOCK for the last element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<last_result> is an alias for C<lastres>.
  
  =head3 indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
    @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =head3 firstidx BLOCK LIST
  
  =head3 first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
    __END__
    item with index 1 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =head3 onlyidx BLOCK LIST
  
  =head3 only_index BLOCK LIST
  
  Returns the index of the only element in LIST for which the criterion
  in BLOCK is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 3, 4, 3, 2, 4);
      printf "uniqe index of item 2 in list is %i", onlyidx { $_ == 2 } @list;
      __END__
      unique index of item 2 in list is 4
  
  Returns C<-1> if either no such item or more than one of these
  has been found.
  
  C<only_index> is an alias for C<onlyidx>.
  
  =head3 lastidx BLOCK LIST
  
  =head3 last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
    __END__
    item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =head2 Sorting
  
  =head3 sort_by BLOCK LIST
  
  Returns the list of values sorted according to the string values returned by the
  KEYFUNC block or function. A typical use of this may be to sort objects according
  to the string value of some accessor, such as
  
    sort_by { $_->name } @people
  
  The key function is called in scalar context, being passed each value in turn as
  both $_ and the only argument in the parameters, @_. The values are then sorted
  according to string comparisons on the values returned.
  This is equivalent to
  
    sort { $a->name cmp $b->name } @people
  
  except that it guarantees the name accessor will be executed only once per value.
  One interesting use-case is to sort strings which may have numbers embedded in them
  "naturally", rather than lexically.
  
    sort_by { s/(\d+)/sprintf "%09d", $1/eg; $_ } @strings
  
  This sorts strings by generating sort keys which zero-pad the embedded numbers to
  some level (9 digits in this case), helping to ensure the lexical sort puts them
  in the correct order.
  
  =head3 nsort_by BLOCK LIST
  
  Similar to sort_by but compares its key values numerically.
  
  =head3 qsort BLOCK ARRAY
  
  This sorts the given array B<in place> using the given compare code. Except for
  tiny compare code like C<< $a <=> $b >>, qsort is much faster than Perl's C<sort>
  depending on the version.
  
  Compared 5.8 and 5.26:
  
    my @rl;
    for(my $i = 0; $i < 1E6; ++$i) { push @rl, rand(1E5) }
    my $idx;
  
    sub ext_cmp { $_[0] <=> $_[1] }
  
    cmpthese( -60, {
        'qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($a, $b) } @qrl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @qrl
        },
        'reverse qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($b, $a) } @qrl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @qrl
        },
        'sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($a, $b) } @srl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @srl
        },
        'reverse sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($b, $a) } @srl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @srl
        },
    });
  
  5.8 results
  
  		  s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    6.21            --           -0%           -8%          -10%
    sort            6.19            0%            --           -7%          -10%
    reverse qsort   5.73            8%            8%            --           -2%
    qsort           5.60           11%           11%            2%            --
  
  5.26 results
  
  		s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    4.54            --           -0%          -96%          -96%
    sort            4.52            0%            --          -96%          -96%
    reverse qsort  0.203         2139%         2131%            --          -19%
    qsort          0.164         2666%         2656%           24%            --
  
  Use it where external data sources might have to be compared (think of L<Unix::Statgrab>
  "tables").
  
  C<qsort> is available from List::MoreUtils::XS only. It's insane to maintain
  a wrapper around Perl's sort nor having a pure Perl implementation. One could
  create a flip-book in same speed as PP runs a qsort.
  
  =head2 Searching in sorted Lists
  
  =head3 bsearch BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns a boolean value in scalar context. In list context, it returns the element
  if it was found, otherwise the empty list.
  
  =head3 bsearchidx BLOCK LIST
  
  =head3 bsearch_index BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns the index of found element, otherwise C<-1>.
  
  C<bsearch_index> is an alias for C<bsearchidx>.
  
  =head3 lower_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<less than val>. Technically it's the first element in LIST which does
  not return a value below zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = lower_bound { $_ <=> 2 } @ids; # returns 2
    $lb = lower_bound { $_ <=> 4 } @ids; # returns 10
  
  lower_bound has a complexity of O(log n).
  
  =head3 upper_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<greater than val>. Technically it's the first element in LIST which does
  not return a value below or equal to zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = upper_bound { $_ <=> 2 } @ids; # returns 4
    $lb = upper_bound { $_ <=> 4 } @ids; # returns 14
  
  upper_bound has a complexity of O(log n).
  
  =head3 equal_range BLOCK LIST
  
  Returns a pair of indices containing the lower_bound and the upper_bound.
  
  =head2 Operations on sorted Lists
  
  =head3 binsert BLOCK ITEM LIST
  
  =head3 bsearch_insert BLOCK ITEM LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  ITEM is inserted at the index where the ITEM should be placed (based on above
  search). That means, it's inserted before the next bigger element.
  
    @l = (2,3,5,7);
    binsert { $_ <=> 4 }  4, @l; # @l = (2,3,4,5,7)
    binsert { $_ <=> 6 } 42, @l; # @l = (2,3,4,42,7)
  
  You take care that the inserted element matches the compare result.
  
  =head3 bremove BLOCK LIST
  
  =head3 bsearch_remove BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  The item at the found position is removed and returned.
  
    @l = (2,3,4,5,7);
    bremove { $_ <=> 4 }, @l; # @l = (2,3,5,7);
  
  =head2 Counting and calculation
  
  =head3 true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
    printf "%i item(s) are defined", true { defined($_) } @list;
  
  =head3 false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
    printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =head3 reduce_0 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 0.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_0 is B<summation> (addition of a sequence of numbers).
  
  =head3 reduce_1 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_1 is product of a sequence of numbers.
  
  =head3 reduce_u BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  This function has been added if one might need the extra of the index
  value but need an individual initialization.
  
  B<Use with caution>: In most cases L<List::Util/reduce> will do the
  job better.
  
  =head3 minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =head3 minmaxstr LIST
  
  Computes the minimum and maximum of LIST using string compare and returns a
  two element list with the first element being the minimum and the second the
  maximum. Returns the empty list if LIST was empty.
  
  The implementation is similar to C<minmax>.
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 MAINTENANCE
  
  The maintenance goal is to preserve the documented semantics of the API;
  bug fixes that bring actual behavior in line with semantics are allowed.
  New API functions may be added over time.  If a backwards incompatible
  change is unavoidable, we will attempt to provide support for the legacy
  API using the same export tag mechanism currently in place.
  
  This module attempts to use few non-core dependencies. Non-core
  configuration and testing modules will be bundled when reasonable;
  run-time dependencies will be added only if they deliver substantial
  benefit.
  
  =head1 CONTRIBUTING
  
  While contributions are appreciated, a contribution should not cause more
  effort for the maintainer than the contribution itself saves (see
  L<Open Source Contribution Etiquette|http://tirania.org/blog/archive/2010/Dec-31.html>).
  
  To get more familiar where help could be needed - see L<List::MoreUtils::Contributing>.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  You can find documentation for this module with the perldoc command.
  
      perldoc List::MoreUtils
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<https://rt.cpan.org/Dist/Display.html?Name=List-MoreUtils>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/List-MoreUtils>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/dist/List-MoreUtils>
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/List-MoreUtils>
  
  =item * CPAN Search
  
  L<http://search.cpan.org/dist/List-MoreUtils/>
  
  =item * Git Repository
  
  L<https://github.com/perl5-utils/List-MoreUtils>
  
  =back
  
  =head2 Where can I go for help?
  
  If you have a bug report, a patch or a suggestion, please open a new
  report ticket at CPAN (but please check previous reports first in case
  your issue has already been addressed) or open an issue on GitHub.
  
  Report tickets should contain a detailed description of the bug or
  enhancement request and at least an easily verifiable way of
  reproducing the issue or fix. Patches are always welcome, too - and
  it's cheap to send pull-requests on GitHub. Please keep in mind that
  code changes are more likely accepted when they're bundled with an
  approving test.
  
  If you think you've found a bug then please read
  "How to Report Bugs Effectively" by Simon Tatham:
  L<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
  
  =head2 Where can I go for help with a concrete version?
  
  Bugs and feature requests are accepted against the latest version
  only. To get patches for earlier versions, you need to get an
  agreement with a developer of your choice - who may or not report the
  issue and a suggested fix upstream (depends on the license you have
  chosen).
  
  =head2 Business support and maintenance
  
  Generally, in volunteered projects, there is no right for support.
  While every maintainer is happy to improve the provided software,
  spare time is limited.
  
  For those who have a use case which requires guaranteed support, one of
  the maintainers should be hired or contracted.  For business support you
  can contact Jens via his CPAN email address rehsackATcpan.org. Please
  keep in mind that business support is neither available for free nor
  are you eligible to receive any support based on the license distributed
  with this package.
  
  =head1 THANKS
  
  =head2 Tassilo von Parseval
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete.
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head2 Jens Rehsack
  
  Credits goes to all people contributing feedback during the v0.400
  development releases.
  
  Special thanks goes to David Golden who spent a lot of effort to develop
  a design to support current state of CPAN as well as ancient software
  somewhere in the dark. He also contributed a lot of patches to refactor
  the API frontend to welcome any user of List::MoreUtils - from ancient
  past to recently last used.
  
  Toby Inkster provided a lot of useful feedback for sane importer code
  and was a nice sounding board for API discussions.
  
  Peter Rabbitson provided a sane git repository setup containing entire
  package history.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>, L<List::AllUtils>, L<List::UtilsBy>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  our $VERSION = '0.428';
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils::PP - Provide List::MoreUtils pure Perl implementation
  
  =head1 SYNOPSIS
  
    BEGIN { $ENV{LIST_MOREUTILS_PP} = 1; }
    use List::MoreUtils qw(:all);
  
  =cut
  
  sub any (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 if $f->();
      }
      return 0;
  }
  
  sub all (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 unless $f->();
      }
      return 1;
  }
  
  sub none (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 if $f->();
      }
      return 1;
  }
  
  sub notall (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 unless $f->();
      }
      return 0;
  }
  
  sub one (&@)
  {
      my $f     = shift;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub any_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 1 foreach (@_);
      return 0;
  }
  
  sub all_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 0 foreach (@_);
      return 1;
  }
  
  sub none_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 0 foreach (@_);
      return 1;
  }
  
  sub notall_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 1 foreach (@_);
      return 0;
  }
  
  sub one_u (&@)
  {
      my $f = shift;
      return if !@_;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub reduce_u(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \();
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_0(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \0;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_1(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \1;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub true (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() and ++$count foreach (@_);
      return $count;
  }
  
  sub false (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() or ++$count foreach (@_);
      return $count;
  }
  
  sub firstidx (&@)
  {
      my $f = shift;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub firstval (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub firstres (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          my $testval = $test->();
          $testval and return $testval;
      }
      return undef;
  }
  
  sub onlyidx (&@)
  {
      my $f = shift;
      my $found;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          $f->() or next;
          defined $found and return -1;
          $found = $i;
      }
      return defined $found ? $found : -1;
  }
  
  sub onlyval (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          $test->() or next;
          $result = $_;
          $found++ and return undef;
      }
      return $result;
  }
  
  sub onlyres (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          my $rv = $test->() or next;
          $result = $rv;
          $found++ and return undef;
      }
      return $found ? $result : undef;
  }
  
  sub lastidx (&@)
  {
      my $f = shift;
      foreach my $i (reverse 0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastval (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub lastres (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $testval if $testval;
      }
      return undef;
  }
  
  sub insert_after (&$\@)
  {
      my ($f, $val, $list) = @_;
      my $c = &firstidx($f, @$list);
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@)
  {
      my ($string, $val, $list) = @_;
      my $c = firstidx { defined $_ and $string eq $_ } @$list;
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@)
  {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@)
  {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do
      {
          my $x = $lag;
          $lag = $test->();
          $x;
      }, @_;
  }
  
  sub after_incl (&@)
  {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@)
  {
      my $test = shift;
      my $more = 1;
      grep $more &&= !$test->(), @_;
  }
  
  sub before_incl (&@)
  {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do
      {
          my $x = $lag;
          $lag = !$test->();
          $x;
      }, @_;
  }
  
  sub indexes (&@)
  {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub pairwise (&\@\@)
  {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local (*A, *B) = @_;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B ? $#A : $#B;
  
      # This map expression is also the return value
      local (*$caller_a, *$caller_b);
      map {
          # Assign to $a, $b as refs to caller's array elements
          (*$caller_a, *$caller_b) = \($#A < $_ ? undef : $A[$_], $#B < $_ ? undef : $B[$_]);
  
          # Perform the transformation
          $op->();
      } 0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      return each_arrayref(@_);
  }
  
  sub each_arrayref
  {
      my @list  = @_;    # The list of references to the arrays
      my $index = 0;     # Which one the caller will get next
      my $max   = 0;     # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach (@list)
      {
          unless (ref $_ eq 'ARRAY')
          {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if (@_)
          {
              my $method = shift;
              unless ($method eq 'index')
              {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0 || $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list;
        }
  }
  
  sub natatime ($@)
  {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
        }
  }
  
  # "leaks" when lexically hidden in arrayify
  my $flatten;
  $flatten = sub {
      map { (ref $_ and ("ARRAY" eq ref $_ or overload::Method($_, '@{}'))) ? ($flatten->(@{$_})) : ($_) } @_;
  };
  
  sub arrayify
  {
      map { $flatten->($_) } @_;
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max;
  }
  
  sub zip6 (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          [map $_->[$ix], @_];
      } 0 .. $max;
  }
  
  sub listcmp (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my %ret;
      for (my $i = 0; $i < scalar @_; ++$i)
      {
          my %seen;
          my $k;
          foreach my $w (grep { defined $_ and not $seen{$k = $_}++ } @{$_[$i]})
          {
              $ret{$w} ||= [];
              push @{$ret{$w}}, $i;
          }
      }
      %ret;
  }
  
  sub uniq (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub singleton (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 == (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub duplicates (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 < (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub frequency (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my %h = map { defined $_ ? ($_ => $seen{$k = $_}) : () }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
      wantarray or return (scalar keys %h) + ($seen_undef ? 1 : 0);
      undef $k;
      (%h, $seen_undef ? (\$k => $seen_undef) : ());
  }
  
  sub occurrences (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my @ret;
      foreach my $l (map { $_ } grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_)
      {
          my $n = defined $l ? $seen{$l} : $seen_undef;
          defined $ret[$n] or $ret[$n] = [];
          push @{$ret[$n]}, $l;
      }
      @ret;
  }
  
  sub mode (@)
  {
      my %seen = ();
      my ($max, $k, $seen_undef) = (1);
  
      foreach (@_) { defined $_ ? ($max < ++$seen{$k = $_} and ++$max) : ($max < ++$seen_undef and ++$max) }
      wantarray or return $max;
  
      my @ret = ($max);
      foreach my $l (grep { $seen{$_} == $max } keys %seen)
      {
          push @ret, $l;
      }
      $seen_undef and $seen_undef == $max and push @ret, undef;
      @ret;
  }
  
  sub samples ($@)
  {
      my $n = shift;
      if ($n > @_)
      {
          require Carp;
          Carp::croak(sprintf("Cannot get %d samples from %d elements", $n, scalar @_));
      }
  
      for (my $i = @_; @_ - $i > $n;)
      {
          my $idx  = @_ - $i;
          my $swp  = $idx + int(rand(--$i));
          my $xchg = $_[$swp];
          $_[$swp] = $_[$idx];
          $_[$idx] = $xchg;
      }
  
      return splice @_, 0, $n;
  }
  
  sub minmax (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub minmaxstr (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@)
  {
      my ($code, @list) = @_;
      my @parts;
      push @{$parts[$code->($_)]}, $_ foreach @list;
      return @parts;
  }
  
  sub bsearch(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0
            and return wantarray ? $_ : 1;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return;
  }
  
  sub bsearchidx(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return -1;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0 and return $k;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return -1;
  }
  
  sub lower_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() < 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub upper_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() <= 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub equal_range(&@)
  {
      my $lb = &lower_bound(@_);
      my $ub = &upper_bound(@_);
      ($lb, $ub);
  }
  
  sub binsert (&$\@)
  {
      my $lb = &lower_bound($_[0], @{$_[2]});
      splice @{$_[2]}, $lb, 0, $_[1];
      $lb;
  }
  
  sub bremove (&\@)
  {
      my $lb = &lower_bound($_[0], @{$_[1]});
      splice @{$_[1]}, $lb, 1;
  }
  
  sub qsort(&\@)
  {
      require Carp;
      Carp::croak("It's insane to use a pure-perl qsort");
  }
  
  sub sort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] cmp $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub nsort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] <=> $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub _XScompiled { 0 }
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS_PP

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  my %require_attempted;
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          if (not exists $require_attempted{$ic}) {
              # Try to load it
              my $_old_error = $@;
              eval "require $ic";
              die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
              $@ = $_old_error;
          }
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      return undef unless defined $text;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = '1.74';
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = '1.74';
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = '1.74';
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = '1.74';
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = "$]" < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = '1.74';
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use strict;
    use warnings;
    use utf8;
  
    use URI::_punycode qw(encode_punycode decode_punycode);
  
    # encode a unicode string
    my $punycode = encode_punycode('http://.net'); # http://.net-xc8g
    $punycode = encode_punycode('bcher'); # bcher-kva
    $punycode = encode_punycode(''); # ihqwcrb4cv8a8dqg056pqjye
  
    # decode a punycode string back into a unicode string
    my $unicode = decode_punycode('http://.net-xc8g'); # http://.net
    $unicode = decode_punycode('bcher-kva'); # bcher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 
  
  =head1 DESCRIPTION
  
  L<URI::_punycode> is a module to encode / decode Unicode strings into
  L<Punycode|https://tools.ietf.org/html/rfc3492>, an efficient
  encoding of Unicode for use with L<IDNA|https://tools.ietf.org/html/rfc5890>.
  
  =head1 FUNCTIONS
  
  All functions throw exceptions on failure. You can C<catch> them with
  L<Syntax::Keyword::Try> or L<Try::Tiny>. The following functions are exported
  by default.
  
  =head2 encode_punycode
  
    my $punycode = encode_punycode('http://.net');  # http://.net-xc8g
    $punycode = encode_punycode('bcher'); # bcher-kva
    $punycode = encode_punycode('') # ihqwcrb4cv8a8dqg056pqjye
  
  Takes a Unicode string (UTF8-flagged variable) and returns a Punycode
  encoding for it.
  
  =head2 decode_punycode
  
    my $unicode = decode_punycode('http://.net-xc8g'); # http://.net
    $unicode = decode_punycode('bcher-kva'); # bcher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 
  
  Takes a Punycode encoding and returns original Unicode string.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa <F<miyagawa@bulknews.net>> is the author of
  L<IDNA::Punycode> which was the basis for this module.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, L<RFC 3492|https://tools.ietf.org/html/rfc3492>,
  L<RFC 5891|https://tools.ietf.org/html/rfc5891>
  
  =head1 COPYRIGHT AND LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.74';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn() || '') eq $host ||
  	lc(Net::Domain::hostname() || '') eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = '1.74';
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  my %require_attempted;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
              if (not exists $require_attempted{$impclass}) {
                  # Try to load it
                  my $_old_error = $@;
                  eval "require $impclass";
                  die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
                  $@ = $_old_error;
              }
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl

use strict;
use warnings;

use App::es;

use encoding 'utf8';
use Term::ANSIColor;
use List::MoreUtils qw{ uniq };
use File::Slurp     qw{ read_file };
use JSON            qw{ decode_json to_json };

use ElasticSearch;

my @cmds = (qw/
    alias
    create
    delete
    get
    ls
    ls-types
    put
    search
    unalias
/);

# get args
my $cmd = shift or do {
    print "es - version $App::es::VERSION\n\n";
    require Pod::Usage;
    Pod::Usage::pod2usage();
};

die "illegal command\n" unless grep {/^$cmd$/} @cmds;

my @params = @ARGV;

# create ES object
my $es = ElasticSearch->new( servers => $ENV{ELASTIC_SEARCH_SERVERS} );

my @aliases = @{ _get_elastic_search_aliases($es) };

_validate_params();

( $cmd eq 'ls'       ) and index_ls       ( @params );
( $cmd eq 'ls-types' ) and index_ls_types ( @params );
( $cmd eq 'create'   ) and index_create   ( @params );
( $cmd eq 'delete'   ) and index_delete   ( @params );
( $cmd eq 'put'      ) and index_put_doc  ( @params );
( $cmd eq 'search'   ) and index_search   ( @params );
( $cmd eq 'get'      ) and index_get      ( @params );
( $cmd eq 'alias'    ) and index_alias    ( @params );
( $cmd eq 'unalias'  ) and index_unalias  ( @params );

exit 0;


sub index_create {
    my ( $index ) = @_;

    my $result;
    eval {
        $result = $es->create_index( index => $index );
        1;
    };

    warn "[ERROR] failed to create index: $index\n"
        unless ref($result) eq 'HASH' and $result->{ok};
}

sub index_delete {
    my ( $index ) = @_;

    my $result = $es->delete_index(
        index => $index,
        ignore_missing => 1,
    );
    warn "[ERROR] failed to delete index: $index\n" unless $result->{ok};
}

sub index_ls {
    my ( $str ) = @_;

    my $aliases = $es->get_aliases;

    my @indices =$ElasticSearch::VERSION < 0.52
        ? keys %{ $aliases->{indices} }
        : keys %{ $aliases };

    my $stats;
    eval {
        $stats = $es->index_stats(
            index => \@indices,
            docs  => 1,
            store => 1,
        );
        1;
    } or do {
        die "[ERROR] failed to obtain stats for index: $str\n";
    };


  INDEX: for my $i ( keys %{ $stats->{_all}{indices} } ) {
        next INDEX if $str and $i !~ /$str/;

        my $size  = $stats->{_all}{indices}{$i}{primaries}{store}{size};
        my $count = $stats->{_all}{indices}{$i}{primaries}{docs}{count};

        printf "%s %s %s\n", $i, $size, $count;
    }
}

sub index_ls_types {
    my ( $index ) = @_;

    my @indices = ( $index );

    if ( grep { $index eq $_ } @aliases ) {
        my $x = _get_elastic_search_index_alias_mapping($es);
        @indices = @{ $x->{$index} };
    }

    for my $n (@indices) {
        my $mapping = $es->mapping( index => $n );

    TYPE: for my $type ( keys %{ $mapping->{$n} } ) {
            my $search = $es->count(
                index => $n,
                type  => $type,
            );

            printf "%s: %s\n", $type, $search->{count};
        }
    }
}

sub index_put_doc {
    my ( $index, $type, $doc ) = @_;

    my $json;
    eval {
        $json = decode_json( read_file($doc) );
        1;
    } or do {
        die "[ERROR] invlid json data in $doc\n";
    };

    $es->index(
        index => $index,
        type  => $type,
        data  => $json,
        create => 1
    );
}

sub index_search {
    my ( $index, $type, $string, $size ) = @_;

    my ( $field, $text ) = split q{:} => $string;
    my $query = {
        query_string => {
            default_field => $field,
            query         => $text,
        }
    };

    my $result = $es->search(
        index => $index,
        type  => $type,
        size  => $size || 24,
        query => $query,
        highlight => { fields => { $field => {} },
                       pre_tags  => [ '__STARTCOLOR__' ],
                       post_tags => [ '__ENDCOLOR__' ],
                     },
    );

    my @output =
        map { { id => $_->{_id},
                lines => $_->{highlight}{$field},
              }
            }
        @{ $result->{hits}{hits} };

    for my $o ( @output ) {
        for my $line ( @{ $o->{lines} } ) {
            $line =~ s/\n/ /g;
            $line =~ s/__STARTCOLOR__/color 'bold red'/eg;
            $line =~ s/__ENDCOLOR__/color 'reset'/eg;
            printf "%s: %s\n", colored ($o->{id}, 'cyan'), $line;
        }
    }
}

sub index_get {
    my ( $index, $type, $doc_id ) = @_;

    my $get = $es->get(
        index => $index,
        type  => $type,
        id    => $doc_id,
    );

    print to_json($get->{_source}, { pretty => 1 }), "\n";
}

sub index_alias {
    my ( $index, $alias ) = @_;

    my $result = $es->aliases( actions => [
        { add => { index => $index, alias => $alias } }
    ] );
    warn "[ERROR] failed to create alias $alias for index $index\n" unless $result->{ok};
}

sub index_unalias {
    my ( $index, $alias ) = @_;

    my $result = $es->aliases( actions => [
        { remove => { index => $index, alias => $alias } }
    ] );
    warn "[ERROR] failed to remove alias $alias for index $index\n" unless $result->{ok};
}

sub _get_elastic_search_aliases {
    my ($es) = @_;
    my @aliases;
    my $aliases = $es->get_aliases;

    if ($ElasticSearch::VERSION < 0.52) {
        @aliases = keys %{$aliases->{aliases}};
    }
    else {
        for my $i (keys %$aliases) {
            push @aliases, keys %{$aliases->{$i}{aliases}};
        }
        @aliases = uniq @aliases;
    }

    return \@aliases;
}

sub _get_elastic_search_index_alias_mapping {
    my ($es) = @_;
    my $aliases = $es->get_aliases;
    my %mapping;

    if ($ElasticSearch::VERSION < 0.52) {
        for (keys %{$aliases->{indices}}) {
            push @{ $mapping{$_} ||=[] }, @{ $aliases->{indices}{$_} };
        }
        for (keys %{$aliases->{aliases}}) {
            push @{ $mapping{$_} ||=[] }, @{ $aliases->{aliases}{$_} };
        }
    }
    else {
        for my $i (keys %$aliases) {
            for my $a (@{ $mapping{$i} = [keys %{$aliases->{$i}{aliases}}] }) {
                push @{$mapping{$a} ||=[]}, $i;
            }
        }
    }
    return \%mapping;
}

sub _validate_params {
    # index_ls
    if ( $cmd eq 'ls' ) {
        die "[ERROR] illegal index name sub-string: " . $params[0] . "\n"
            if $params[0] and $params[0] !~ /^[a-zA-Z0-9_-]+$/;

        return;
    }

    my $index = $params[0];

    # check common params
    unless ( $cmd =~ /^(?:ls)$/ ) {
        die "[ERROR] illegal index name: $index\n"
            unless $index and $index =~ /^[a-zA-Z0-9_-]+$/;
    }

    if ( $cmd =~ /^(?:put|search|get)$/ ) {
        my $type = $params[1];
        die "[ERROR] must provide a valid type\n"
            unless $type and $type =~ /^[a-zA-Z0-9_-]+$/;
    }

    # check existance of an index if applicable
    if ( $cmd =~ /^(?:ls-types|delete|put|search|get|alias|unalias)$/ ) {
        my $check_index = $es->index_exists( index => $index );
        die "[ERROR] index $index does not exists\n" unless $check_index->{ok};

    } elsif ( $cmd eq 'create' ) {
        my $check_index = $es->index_exists( index => $index );
        die "[ERROR] index $index already exists\n" if $check_index->{ok};
    }

    # check document file where applicable
    if ( $cmd eq 'put' ) {
        die "[ERROR] must provide a valid json file\n"
            unless $params[2] and -f $params[2];
    }

    # check document id where applicable
    if ( $cmd eq 'get' ) {
        my $doc_id = $params[2];
        die "[ERROR] must provide a valid doc_id\n"
            unless $doc_id and $doc_id =~ /^[a-zA-Z0-9\/_-]+$/;
    }

    # check alias name where applicable
    if ( $cmd =~ /alias/ ) {
        my $alias = $params[1];
        die "[ERROR] must provide a valid alias name\n"
            unless $alias and $alias =~ /^[a-zA-Z0-9_-]+$/;

        die "[ERROR] $index is an alias\n" if grep { /^$index$/ } @aliases;

        my $check_alias = $es->index_exists( index => $alias );
        if ( $cmd eq 'alias' ) {
            die "[ERROR] alias $alias already exists" if $check_alias->{ok};

        } else {
            die "[ERROR] alias doesn't exist" unless $check_alias->{ok};
        }
    }

    # check search params
    if ( $cmd eq 'search' ) {
        my $string = $params[2];
        my $size   = $params[3];

        utf8::decode($string);
        die "[ERROR] must provide a query string\n"
            unless $string and $string =~ /^[a-zA-Z0-9_-]+ : [\w\d_\s-]+$/x;

        die "[ERROR] invalid size\n"
            if $size and $size !~ /^[0-9]+$/;
    }
}

__END__

=head1 NAME

es -- The command line client of ElasticSearch.

=head1 SYNOPSIS

    # List document count / size per index / type
    es ls
    es ls-types <index>

    # Create / delete an index
    es create <index>
    es delete <index>

    # Indexing / getting a document
    es put <index> <doc> # doc needs to be a JSON file
    es get <name> <type> <doc_id>

    # Search by a field
    es search <name> <type> <field>:<search string> [<size>]

    # Aliasing
    es alias   <index-name> <alias>
    es unalias <index-name> <alias>

See `perldoc es` for more info.

=head1 DESCRIPTION

This program can be used to basic manipulation for day-to-day development need
with ElasticSearch server. The default server is C<localhost:9200>, to use
different server, you can change it with C<ELASTIC_SEARCH_SERVERS> environment variable.

    ESASTIC_SEARCH_SERVERS=search-server.company.com:9200

You may supply a list of servers seperate by comma

    ESASTIC_SEARCH_SERVERS=search-server-1.company.com:9200,search-server-2.company.com:9200

The list of servers are used in a round-robin manner, which is the default
behaviour of the underlying L<ElasticSearch> perl module.

=head1 COMMANDS

=head2 ls [<index sub-string>]

List all indices. Or if a sub-string is provided, list only matching ones.

=head2 ls-types <index>

List all document type of the given index.

=head2 create <index>

Create the index.

=head2 delete <index>

Delete the index

=head2 alias <index> <alias>

Add an alias for the index.

=head2 unalias <index> <alias>

Remove an alias to the index.

=head2 put <index> <type> <doc>

Put the content of doc into the index.  <type> is the the documentation type.
<doc> must be a valid JSON file.

=head2 get <index> <type> <doc_id>

Print the specic document as JSON.

=head2 search <index> <type> <field>:<query_string>

Perform a simple text query. Need to provide field name and a query string.

=head1 AUTHORS

Mickey Nasriachi E<lt>mickey75@gmail.comE<gt>

Kang-min Liu E<lt>gugod@gugod.orgE<gt>


=head1 ACKNOWLEDGMENT

This module was originally developed for Booking.com. With approval from
Booking.com, this module was generalized and published on CPAN, for which the
authors would like to express their gratitude.

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013 by Mickey Nasriachi

Copyright (C) 2013 by Kang-min Liu

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

