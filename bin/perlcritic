#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"B/Keywords.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_KEYWORDS';
  ## no critic (PodSections,UseWarnings,Interpolation,EndWithOne,NoisyQuotes)
  
  package B::Keywords;
  
  use strict;
  
  require Exporter;
  *import = *import = \&Exporter::import;
  
  use vars qw( @EXPORT_OK %EXPORT_TAGS );
  @EXPORT_OK = qw( @Scalars @Arrays @Hashes @Filehandles @Symbols
                   @Functions @Barewords @TieIOMethods @UNIVERSALMethods
                   @ExporterSymbols );
  %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  use vars '$VERSION';
  $VERSION = '1.18';
  my $CPERL = $^V =~ /c$/ ? 1 : 0;
  
  use vars '@Scalars';
  @Scalars = (
      qw( $a
          $b
          $_ $ARG
          $& $MATCH
          $` $PREMATCH
          $' $POSTMATCH
          $+ $LAST_PAREN_MATCH ),
      ($] < 5.008001 ?
      qw( $* $MULTILINE_MATCHING) : ()),
      qw( $. $INPUT_LINE_NUMBER $NR
          $/ $INPUT_RECORD_SEPARATOR $RS
          $| $OUTPUT_AUTOFLUSH ), '$,', qw( $OUTPUT_FIELD_SEPARATOR $OFS
          $\ $OUTPUT_RECORD_SEPARATOR $ORS
          $" $LIST_SEPARATOR
          $; $SUBSCRIPT_SEPARATOR $SUBSEP
      ), '$#', qw( $OFMT
          $% $FORMAT_PAGE_NUMBER
          $= $FORMAT_LINES_PER_PAGE
          $- $FORMAT_LINES_LEFT
          $~ $FORMAT_NAME
          $^ $FORMAT_TOP_NAME
          $: $FORMAT_LINE_BREAK_CHARACTERS
          $? $CHILD_ERROR $^CHILD_ERROR_NATIVE
          $! $ERRNO $OS_ERROR
          $@ $EVAL_ERROR
          $$ $PROCESS_ID $PID
          $< $REAL_USER_ID $UID
          $> $EFFECTIVE_USER_ID $EUID ), 
         '$(', qw( $REAL_GROUP_ID $GID ), 
         '$)', qw( $EFFECTIVE_GROUP_ID $EGID
          $0 $PROGRAM_NAME
          $[
          $]
          $^A $ACCUMULATOR
          $^C $COMPILING
          $^CHILD_ERROR_NATIVE
          $^D $DEBUGGING
          $^E $EXTENDED_OS_ERROR
          $^ENCODING
          $^F $SYSTEM_FD_MAX
          $^GLOBAL_PHASE
          $^H
          $^I $INPLACE_EDIT
          $^L $FORMAT_FORMFEED
          $^LAST_FH
          $^M
          $^MATCH
          $^N $LAST_SUBMATCH_RESULT
          $^O $OSNAME
          $^OPEN
          $^P $PERLDB
          $^PREMATCH $^POSTMATCH
          $^R $LAST_REGEXP_CODE_RESULT
          $^RE_DEBUG_FLAGS
          $^RE_TRIE_MAXBUF
          $^S $EXCEPTIONS_BEING_CAUGHT
          $^T $BASETIME
          $^TAINT
          $^UNICODE
          $^UTF8CACHE
          $^UTF8LOCALE
          $^V $PERL_VERSION
          $^W $WARNING $^WARNING_BITS
          $^WIDE_SYSTEM_CALLS
          $^WIN32_SLOPPY_STAT
          $^X $EXECUTABLE_NAME
          $ARGV
          ),
  );
  
  use vars '@Arrays';
  @Arrays = qw(
      @+ $LAST_MATCH_END
      @- @LAST_MATCH_START
      @ARGV
      @F
      @INC
      @_ @ARG
  );
  
  use vars '@Hashes';
  @Hashes = qw(
      %OVERLOAD
      %+ %LAST_MATCH_END
      %- %LAST_MATCH_START
      %! %OS_ERROR %ERRNO
      %^H
      %INC
      %ENV
      %SIG
  );
  
  use vars '@Filehandles';
  @Filehandles = qw(
      *ARGV ARGV
      *_ _
      ARGVOUT
      DATA
      STDIN
      STDOUT
      STDERR
  );
  
  use vars '@Functions';
  @Functions = (
    ($] >= 5.015006 ? qw(
      __SUB__
    ) : ()), qw(
      AUTOLOAD
      BEGIN
      DESTROY
      END ),
      # STOP was between 5.5.64 - v5.6.0
    ($] >= 5.005064 && $] < 5.006
      ? qw(STOP) : qw(CHECK)),
      # INIT was called RESTART before 5.004_50
    ($] >= 5.006
      ? qw(INIT) : qw(RESTART)),
    ($] < 5.007003 ? qw(
      EQ GE GT LE LT NE
    ) : ()), qw(
      UNITCHECK
      abs
      accept
      alarm
      atan2
      bind
      binmode
      bless ),
    ($] >= 5.009003 && ($] < 5.027007 || $] >= 5.027008 || $CPERL) ? qw(
      break
    ) : ()), qw(
      caller
      chdir
      chmod
      chomp
      chop
      chown
      chr
      chroot
      close
      closedir
      connect
      cos
      crypt
      dbmclose
      dbmopen ),
    ($] >= 5.009003 && ($] < 5.027007 || $CPERL) ? qw(
      default
    ) : ()), qw(
      defined
      delete
      die
      dump
      each
      endgrent
      endhostent
      endnetent
      endprotoent
      endpwent
      endservent
      eof
      eval ),
    ($] >= 5.015005 ? qw(
      evalbytes
    ) : ()), qw(
      exec
      exists
      exit
      exp ),
    ($] >= 5.015008 ? qw(
      fc
    ) : ()), qw(
      fcntl
      fileno
      flock
      fork
      format
      formline
      getc
      getgrent
      getgrgid
      getgrnam
      gethostbyaddr
      gethostbyname
      gethostent
      getlogin
      getnetbyaddr
      getnetbyname
      getnetent
      getpeername
      getpgrp
      getppid
      getpriority
      getprotobyname
      getprotobynumber
      getprotoent
      getpwent
      getpwnam
      getpwuid
      getservbyname
      getservbyport
      getservent
      getsockname
      getsockopt ),
    ($] >= 5.009003 ? qw(
      given
    ) : ()), qw(
      glob
      gmtime
      goto
      grep
      hex
      index
      int
      import
      ioctl
      join
      keys
      kill
      last
      lc
      lcfirst
      length
      link
      listen
      local
      localtime ),
    ($] >= 5.004 ? qw(
      lock
    ) : ()), qw(
      log
      lstat
      map
      mkdir
      msgctl
      msgget
      msgrcv
      msgsnd
      my
      next
      not
      oct
      open
      opendir
      ord
      our
      pack
      pipe
      pop
      pos
      print
      printf
      prototype
      push
      quotemeta
      rand
      read
      readdir
      readline
      readlink
      readpipe
      recv
      redo
      ref
      rename
      require
      reset
      return
      reverse
      rewinddir
      rindex
      rmdir ),
    ($] >= 5.009003 ? qw(
      say
    ) : ()), qw(
      scalar
      seek
      seekdir
      select
      semctl
      semget
      semop
      send
      setgrent
      sethostent
      setnetent
      setpgrp
      setpriority
      setprotoent
      setpwent
      setservent
      setsockopt
      shift
      shmctl
      shmget
      shmread
      shmwrite
      shutdown
      sin
      sleep
      socket
      socketpair
      sort
      splice
      split
      sprintf
      sqrt
      srand
      stat
      state
      study
      substr
      symlink
      syscall
      sysopen
      sysread
      sysseek
      system
      syswrite
      tell
      telldir
      tie
      tied
      time
      times
      truncate
      uc
      ucfirst
      umask
      undef
      unlink
      unimport
      unpack
      unshift
      untie
      use
      utime
      values
      vec
      wait
      waitpid
      wantarray
      warn ),
    ($] >= 5.009003 && ($] < 5.027007 || $] >= 5.027008 || $CPERL) ? qw(
      when
    ) : ($] >= 5.009003 && !$CPERL) ? qw(
      whereis
      whereso
    ) : ()), qw(
      write
  
      -r -w -x -o
      -R -W -X -O -e -z -s
      -f -d -l -p -S -b -c -t
      -u -g -k
      -T -B
      -M -A -C
  ));
  
  use vars '@Barewords';
  @Barewords = (
    qw(
      __FILE__
      __LINE__
      __PACKAGE__
      __DATA__
      __END__
      CORE
      EQ
      GE
      GT
      LE
      LT
      NE
      NULL
      and ),
    ($CPERL && $] >= 5.027001 ? qw(
      class method role multi has
    ) : ()), qw(
      cmp
      continue
      default
      do
      else
      elsif
      eq ),
    ($] >= 5.008001 && $] < 5.010 ? qw(
      err
    ) : ()), qw(
      for
      foreach
      ge
      given
      gt
      if
      le
      lock
      lt
      m
      ne
      no
      or
      package
      q
      qq ),
    ($] >= 5.004072 ? qw(
      qr
    ) : ()),
    ($] == 5.007003 ? qw(
      qu
    ) : ()), qw(
      qw
      qx
      s
      sub
      tr
      unless
      until
      when
      while
      x
      xor
      y
  ));
  
  use vars '@TieIOMethods';
  @TieIOMethods = qw(
      BINMODE CLEAR CLEARERR CLONE CLONE_SKIP CLOSE DELETE EOF
      ERROR EXISTS EXTEND FDOPEN FETCH FETCHSIZE FILENO FILL FIRSTKEY FLUSH
      GETC NEXTKEY OPEN POP POPPED PRINT PRINTF PUSH PUSHED READ READLINE
      SCALAR SEEK SETLINEBUF SHIFT SPLICE STORE STORESIZE SYSOPEN TELL
      TIEARRAY TIEHANDLE TIEHASH TIESCALAR UNREAD UNSHIFT UNTIE UTF8 WRITE
  );
  
  use vars '@UNIVERSALMethods';
  @UNIVERSALMethods = qw(
      can isa DOES VERSION
  );
  
  use vars '@ExporterSymbols';
  @ExporterSymbols = qw(
      @EXPORT @EXPORT_OK @EXPORT_FAIL
      @EXPORT_TAGS _push_tags _rebuild_cache as_heavy export export_fail
      export_fail_in export_ok_tags export_tags export_to_level heavy_export
      heavy_export_ok_tags heavy_export_tags heavy_export_to_level
      heavy_require_version require_version
  );
  
  use vars '@Symbols';
  @Symbols = ( @Scalars, @Arrays, @Hashes, @Filehandles, @Functions );
  
  # This quote is blatantly copied from ErrantStory.com, Michael Poe's
  # comic.
  BEGIN { $^W = 0 }
  "You know, when you stop and think about it, Cthulhu is a bit a Mary Sue isn't he?"
  
  __END__
  
  =encoding UTF-8
  
  =head1 NAME
  
  B::Keywords - Lists of reserved barewords and symbol names
  
  =head1 SYNOPSIS
  
    use B::Keywords qw( @Symbols @Barewords );
    print join "\n", @Symbols,
                     @Barewords;
  
  =head1 DESCRIPTION
  
  C<B::Keywords> supplies several arrays of exportable keywords:
  C<@Scalars>, C<@Arrays>, C<@Hashes>, C<@Filehandles>, C<@Symbols>,
  C<@Functions>, C<@Barewords>, C<@TieIOMethods>, C<@UNIVERSALMethods>
  and C<@ExporterSymbols>.
  
  The C<@Symbols> array includes the contents of each
  of C<@Scalars>, C<@Arrays>, C<@Hashes>, C<@Functions> and C<@Filehandles>.
  
  Similarly, C<@Barewords> adds a few non-function keywords and
  operators to the C<@Functions> array.
  
  All additions and modifications are welcome.
  
  The perl parser uses a static list of keywords from
  F<regen/keywords.pl> which constitutes the strict list of keywords
  @Functions and @Barewords, though some @Functions are not functions
  in the strict sense.
  Several library functions use more special symbols, handles and methods.
  
  =head1 DATA
  
  =over
  
  =item C<@Scalars>
  
  =item C<@Arrays>
  
  =item C<@Hashes>
  
  =item C<@Filehandles>
  
  =item C<@Functions>
  
  The above are lists of variables, special file handles, and built in
  functions.
  
  =item C<@Symbols>
  
  This is just the combination of all of the above: variables, file
  handles, and functions.
  
  =item C<@Barewords>
  
  This is a list of other special keywords in perl including operators
  and all the control structures.
  
  =item C<@TieIOMethods>
  
  Those are special tie or PerlIO methods called by the perl core,
  namely for tieing or PerlIO::via (or both of those) or threads.
  
  =item C<@UNIVERSALMethods>
  
  Methods defined by the core package UNIVERSAL.
  
  =item C<@ExporterSymbols>
  
  Variables or functions used by Exporter (some internal), which is
  almost as good as being keywords, for you mustn't use them for any
  other purpose in any package that isa Exporter, which is quite common.
  
  =back
  
  =head1 EXPORT
  
  Anything can be exported if you desire. Use the :all tag to get
  everything.
  
  =head1 SEE ALSO
  
  F<regen/keywords.pl> from the perl source, L<perlvar>, L<perlfunc>,
  L<perldelta>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests to C<bug-B-Keywords at
  rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=B-Keywords>. I will be
  notified, and then you'll automatically be notified of progress on
  your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
    perldoc B::Keywords
  
  You can also look for information at:
  
  =over
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=B-Keywords>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/B-Keywords>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/B-Keywords>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/B-Keywords>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Michael G Schwern, Reini Urban, Florian Ragwitz and Zsbán Ambrus
  for patches and releases.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2009 Joshua ben Jore, All rights reserved.
  Copyright 2013, 2015, 2017, 2018 Reini Urban, All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of either:
  
  a) the GNU General Public License as published by the Free Software
     Foundation; version 2, or
  
  b) the "Artistic License" which comes with Perl.
  
  =head1 SOURCE AVAILABILITY
  
  This source is in Github: L<git://github.com/rurban/b-keywords.git>
  
  =head1 AUTHOR
  
  Joshua ben Jore <jjore@cpan.org>
  
  =head1 MAINTAINER
  
  Reini Urban <rurban@cpan.org>
B_KEYWORDS

$fatpacked{"Class/Data/Inheritable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_DATA_INHERITABLE';
  package Class::Data::Inheritable;
  
  use strict qw(vars subs);
  use vars qw($VERSION);
  $VERSION = '0.08';
  
  sub mk_classdata {
      my ($declaredclass, $attribute, $data) = @_;
  
      if( ref $declaredclass ) {
          require Carp;
          Carp::croak("mk_classdata() is a class method, not an object method");
      }
  
      my $accessor = sub {
          my $wantclass = ref($_[0]) || $_[0];
  
          return $wantclass->mk_classdata($attribute)->(@_)
            if @_>1 && $wantclass ne $declaredclass;
  
          $data = $_[1] if @_>1;
          return $data;
      };
  
      my $alias = "_${attribute}_accessor";
      *{$declaredclass.'::'.$attribute} = $accessor;
      *{$declaredclass.'::'.$alias}     = $accessor;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Data::Inheritable - Inheritable, overridable class data
  
  =head1 SYNOPSIS
  
    package Stuff;
    use base qw(Class::Data::Inheritable);
  
    # Set up DataFile as inheritable class data.
    Stuff->mk_classdata('DataFile');
  
    # Declare the location of the data file for this class.
    Stuff->DataFile('/etc/stuff/data');
  
    # Or, all in one shot:
    Stuff->mk_classdata(DataFile => '/etc/stuff/data');
  
  =head1 DESCRIPTION
  
  Class::Data::Inheritable is for creating accessor/mutators to class
  data.  That is, if you want to store something about your class as a
  whole (instead of about a single object).  This data is then inherited
  by your subclasses and can be overriden.
  
  For example:
  
    Pere::Ubu->mk_classdata('Suitcase');
  
  will generate the method Suitcase() in the class Pere::Ubu.
  
  This new method can be used to get and set a piece of class data.
  
    Pere::Ubu->Suitcase('Red');
    $suitcase = Pere::Ubu->Suitcase;
  
  The interesting part happens when a class inherits from Pere::Ubu:
  
    package Raygun;
    use base qw(Pere::Ubu);
    
    # Raygun's suitcase is Red.
    $suitcase = Raygun->Suitcase;
  
  Raygun inherits its Suitcase class data from Pere::Ubu.
  
  Inheritance of class data works analogous to method inheritance.  As
  long as Raygun does not "override" its inherited class data (by using
  Suitcase() to set a new value) it will continue to use whatever is set
  in Pere::Ubu and inherit further changes:
  
    # Both Raygun's and Pere::Ubu's suitcases are now Blue
    Pere::Ubu->Suitcase('Blue');
  
  However, should Raygun decide to set its own Suitcase() it has now
  "overridden" Pere::Ubu and is on its own, just like if it had
  overriden a method:
  
    # Raygun has an orange suitcase, Pere::Ubu's is still Blue.
    Raygun->Suitcase('Orange');
  
  Now that Raygun has overridden Pere::Ubu futher changes by Pere::Ubu
  no longer effect Raygun.
  
    # Raygun still has an orange suitcase, but Pere::Ubu is using Samsonite.
    Pere::Ubu->Suitcase('Samsonite');
  
  =head1 Methods
  
  =head2 mk_classdata
  
    Class->mk_classdata($data_accessor_name);
    Class->mk_classdata($data_accessor_name => $value);
  
  This is a class method used to declare new class data accessors.
  A new accessor will be created in the Class using the name from
  $data_accessor_name, and optionally initially setting it to the given
  value.
  
  To facilitate overriding, mk_classdata creates an alias to the
  accessor, _field_accessor().  So Suitcase() would have an alias
  _Suitcase_accessor() that does the exact same thing as Suitcase().
  This is useful if you want to alter the behavior of a single accessor
  yet still get the benefits of inheritable class data.  For example.
  
    sub Suitcase {
        my($self) = shift;
        warn "Fashion tragedy" if @_ and $_[0] eq 'Plaid';
  
        $self->_Suitcase_accessor(@_);
    }
  
  =head1 AUTHOR
  
  Original code by Damian Conway.
  
  Maintained by Michael G Schwern until September 2005.
  
  Now maintained by Tony Bowden.
  
  =head1 BUGS and QUERIES
  
  Please direct all correspondence regarding this module to:
    bug-Class-Data-Inheritable@rt.cpan.org
  
  =head1 COPYRIGHT and LICENSE
  
  Copyright (c) 2000-2005, Damian Conway and Michael G Schwern. 
  All Rights Reserved.  
  
  This module is free software. It may be used, redistributed and/or
  modified under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<perltooc> has a very elaborate discussion of class data in Perl.
  
CLASS_DATA_INHERITABLE

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.03';
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      $p{unsafe_ref_capture} = !delete $p{no_refs}
          if exists $p{no_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data;
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      my $filter = $self->{filter_frames_early} && $self->_make_frame_filter;
  
      # We exclude this method by starting at least one frame back.
      my $x = 1 + ( $self->{skip_frames} || 0 );
  
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              ## no critic (Modules::ProhibitMultiplePackages, Variables::ProhibitPackageVars)
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          ## no critic (Variables::ProhibitPackageVars)
          @args = $self->{no_args} ? () : @DB::args;
          ## use critic
  
          my $raw = {
              caller => \@c,
              args   => \@args,
          };
  
          next if $filter && !$filter->($raw);
  
          unless ( $self->{unsafe_ref_capture} ) {
              $raw->{args} = [ map { ref $_ ? $self->_ref_to_string($_) : $_ }
                      @{ $raw->{args} } ];
          }
  
          push @{ $self->{raw} }, $raw;
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      ## no critic (Variables::RequireInitializationForLocalVars)
      local $@;
      local $SIG{__DIE__};
      ## use critic
  
      my $str = eval { $ref . q{} };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = !$self->{filter_frames_early} && $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next if $filter && !$filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub {1};
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          ## no critic (Variables::RequireInitializationForLocalVars)
          local $@;
          local $SIG{__DIE__};
          ## use critic
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames;
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          ## no critic (Subroutines::ProhibitExplicitReturnUndef)
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames;
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          ## no critic (Subroutines::ProhibitExplicitReturnUndef)
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  
      return;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
          delete $self->{raw};
      }
      else {
          $self->_make_frames if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames );
  }
  
  sub message { $_[0]->{message} }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my @frames = $self->frames;
      if (@frames) {
          my $st    = q{};
          my $first = 1;
          for my $f (@frames) {
              $st .= $f->as_string( $first, $p ) . "\n";
              $first = 0;
          }
  
          return $st;
      }
  
      my $msg = $self->message;
      return $msg if defined $msg;
  
      return 'Trace begun';
  }
  
  {
      ## no critic (Modules::ProhibitMultiplePackages, ClassHierarchies::ProhibitExplicitISA)
      package    # hide from PAUSE
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 2.03
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new;
  
    print $trace->as_string; # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame ) {
        print "Has args\n" if $frame->hasargs;
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame ) {
        print "Sub: ", $frame->subroutine, "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C<Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new;  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the call to
  its constructor.
  
  However, you may want to filter out some frames with more granularity than
  'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data for each
  frame. This is a hash reference with two keys, "caller", and "args", both of
  which are array references. The "caller" key is the raw data as returned by
  Perl's C<caller> function, and the "args" key are the subroutine arguments
  found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or false if it
  should be skipped.
  
  =item * filter_frames_early => $boolean
  
  If this parameter is true, C<frame_filter> will be called as soon as the
  stacktrace is created, and before refs are stringified (if
  C<unsafe_ref_capture> is not set), rather than being filtered lazily when
  L<Devel::StackTrace::Frame> objects are first needed.
  
  This is useful if you want to filter based on the frame's arguments and want
  to be able to examine object properties, for example.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on the
  stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages (or is the
  same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package' parameter,
  meaning that the Devel::StackTrace package is B<ALWAYS> ignored. However, if
  you create a subclass of Devel::StackTrace it will not be ignored.
  
  =item * skip_frames => $integer
  
  This will cause this number of stack frames to be excluded from top of the
  stack trace. This prevents the frames from being captured at all, and applies
  before the C<frame_filter>, C<ignore_package>, or C<ignore_class> options,
  even with C<filter_frames_early>.
  
  =item * unsafe_ref_capture => $boolean
  
  If this parameter is true, then Devel::StackTrace will store references
  internally when generating stacktrace frames.
  
  B<This option is very dangerous, and should never be used with exception
  objects>. Using this option will keep any objects or references alive past
  their normal lifetime, until the stack trace object goes out of scope. It can
  keep objects alive even after their C<DESTROY> sub is called, resulting it it
  being called multiple times on the same object.
  
  If not set, Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef> to get the
  underlying string representation of an object, instead of respecting the
  object's stringification overloading. If you would prefer to see the
  overloaded representation of objects in stack traces, then set this parameter
  to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess>.
  
  =back
  
  =head2 $trace->next_frame
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame >> or C<<
  $trace->prev_frame >> will work properly.
  
  =head2 $trace->prev_frame
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame >> or C<< $trace->prev_frame >> will work
  properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame >> or C<<
  $trace->prev_frame >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  If all the frames in a trace are skipped then this just returns the C<message>
  passed to the constructor or the string C<"Trace begun">.
  
  =head2 $trace->message
  
  Returns the message passed to the constructor. If this wasn't passed then this
  method returns C<undef>.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Devel-StackTrace/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Devel-StackTrace can be found at L<https://github.com/houseabsolute/Devel-StackTrace>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David Cantrell Graham Knop Ivan Bessarabov Mark Fowler Ricardo Signes
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David Cantrell <david@cantrell.org.uk>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2017 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.03';
  
  # Create accessor routines
  BEGIN {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
  
      my @attrs = qw(
          package
          filename
          line
          subroutine
          hasargs
          wantarray
          evaltext
          is_require
          hints
          bitmask
      );
  
      for my $a (@attrs) {
          *{$a} = sub { my $s = shift; return $s->{$a} };
      }
  }
  
  {
      my @args = qw(
          package
          filename
          line
          subroutine
          hasargs
          wantarray
          evaltext
          is_require
          hints
          bitmask
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@args} = @{ shift() };
          $self->{args}             = shift;
          $self->{respect_overload} = shift;
          $self->{max_arg_length}   = shift;
          $self->{message}          = shift;
          $self->{indent}           = shift;
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked. All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  unless ( defined $_ ) {
                      $_ = 'undef';
                      next;
                  }
  
                  # hack!
                  ## no critic (Subroutines::ProtectPrivateSubs)
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
                  ## use critic;
  
                  ## no critic (Variables::RequireInitializationForLocalVars)
                  local $SIG{__DIE__};
                  local $@;
                  ## use critic;
  
                  ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          ## no critic (BuiltinFunctions::ProhibitLvalueSubstr)
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
                  ## use critic
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 2.03
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller> documentation for more information on what these
  methods return.
  
  =head2 $frame->package
  
  =head2 $frame->filename
  
  =head2 $frame->line
  
  =head2 $frame->subroutine
  
  =head2 $frame->hasargs
  
  =head2 $frame->wantarray
  
  =head2 $frame->evaltext
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args
  
  Returns the arguments passed to the frame. Note that any arguments that are
  references are returned as references, not copies.
  
  =head2 $frame->hints
  
  =head2 $frame->bitmask
  
  =head2 $frame->as_string
  
  Returns a string containing a description of the frame.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Devel-StackTrace/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Devel-StackTrace can be found at L<https://github.com/houseabsolute/Devel-StackTrace>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2017 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Exception/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS';
  package Exception::Class;
  
  use 5.008001;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.44';
  
  use Exception::Class::Base;
  use Scalar::Util qw( blessed reftype );
  
  our $BASE_EXC_CLASS;
  BEGIN { $BASE_EXC_CLASS ||= 'Exception::Class::Base'; }
  
  our %CLASSES;
  
  sub import {
      my $class = shift;
  
      ## no critic (Variables::ProhibitPackageVars)
      local $Exception::Class::Caller = caller();
  
      my %c;
  
      my %needs_parent;
      while ( my $subclass = shift ) {
          my $def = ref $_[0] ? shift : {};
          $def->{isa}
              = $def->{isa}
              ? ( ref $def->{isa} ? $def->{isa} : [ $def->{isa} ] )
              : [];
  
          $c{$subclass} = $def;
      }
  
      # We need to sort by length because if we check for keys in the
      # Foo::Bar:: stash, this creates a "Bar::" key in the Foo:: stash!
  MAKE_CLASSES:
      foreach my $subclass ( sort { length $a <=> length $b } keys %c ) {
          my $def = $c{$subclass};
  
          # We already made this one.
          next if $CLASSES{$subclass};
  
          {
              ## no critic (TestingAndDebugging::ProhibitNoStrict)
              no strict 'refs';
              foreach my $parent ( @{ $def->{isa} } ) {
                  unless ( keys %{"$parent\::"} ) {
                      $needs_parent{$subclass} = {
                          parents => $def->{isa},
                          def     => $def
                      };
                      next MAKE_CLASSES;
                  }
              }
          }
  
          $class->_make_subclass(
              subclass => $subclass,
              def      => $def || {},
          );
      }
  
      foreach my $subclass ( keys %needs_parent ) {
  
          # This will be used to spot circular references.
          my %seen;
          $class->_make_parents( \%needs_parent, $subclass, \%seen );
      }
  }
  
  sub _make_parents {
      my $class    = shift;
      my $needs    = shift;
      my $subclass = shift;
      my $seen     = shift;
      my $child    = shift;    # Just for error messages.
  
      ## no critic (TestingAndDebugging::ProhibitNoStrict, TestingAndDebugging::ProhibitProlongedStrictureOverride)
      no strict 'refs';
  
      # What if someone makes a typo in specifying their 'isa' param?
      # This should catch it. Either it's been made because it didn't
      # have missing parents OR it's in our hash as needing a parent.
      # If neither of these is true then the _only_ place it is
      # mentioned is in the 'isa' param for some other class, which is
      # not a good enough reason to make a new class.
      die
          "Class $subclass appears to be a typo as it is only specified in the 'isa' param for $child\n"
          unless exists $needs->{$subclass}
          || $CLASSES{$subclass}
          || keys %{"$subclass\::"};
  
      foreach my $c ( @{ $needs->{$subclass}{parents} } ) {
  
          # It's been made
          next if $CLASSES{$c} || keys %{"$c\::"};
  
          die "There appears to be some circularity involving $subclass\n"
              if $seen->{$subclass};
  
          $seen->{$subclass} = 1;
  
          $class->_make_parents( $needs, $c, $seen, $subclass );
      }
  
      return if $CLASSES{$subclass} || keys %{"$subclass\::"};
  
      $class->_make_subclass(
          subclass => $subclass,
          def      => $needs->{$subclass}{def}
      );
  }
  
  sub _make_subclass {
      my $class = shift;
      my %p     = @_;
  
      my $subclass = $p{subclass};
      my $def      = $p{def};
  
      my $isa;
      if ( $def->{isa} ) {
          $isa = ref $def->{isa} ? join q{ }, @{ $def->{isa} } : $def->{isa};
      }
      $isa ||= $BASE_EXC_CLASS;
  
      my $version_name = 'VERSION';
  
      my $code = <<"EOPERL";
  package $subclass;
  
  use base qw($isa);
  
  our \$$version_name = '1.1';
  
  1;
  
  EOPERL
  
      if ( $def->{description} ) {
          ( my $desc = $def->{description} ) =~ s/([\\\'])/\\$1/g;
          $code .= <<"EOPERL";
  sub description
  {
      return '$desc';
  }
  EOPERL
      }
  
      my @fields;
      if ( my $fields = $def->{fields} ) {
          @fields
              = ref $fields && reftype $fields eq 'ARRAY' ? @$fields : $fields;
  
          $code
              .= 'sub Fields { return ($_[0]->SUPER::Fields, '
              . join( ', ', map {"'$_'"} @fields )
              . ") }\n\n";
  
          foreach my $field (@fields) {
              $code .= sprintf( "sub %s { \$_[0]->{%s} }\n", $field, $field );
          }
      }
  
      if ( my $alias = $def->{alias} ) {
          ## no critic (Variables::ProhibitPackageVars)
          die 'Cannot make alias without caller'
              unless defined $Exception::Class::Caller;
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{"$Exception::Class::Caller\::$alias"}
              = sub { $subclass->throw(@_) };
      }
  
      if ( my $defaults = $def->{defaults} ) {
          $code
              .= "sub _defaults { return shift->SUPER::_defaults, our \%_DEFAULTS }\n";
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{"$subclass\::_DEFAULTS"} = {%$defaults};
      }
  
      ## no critic (BuiltinFunctions::ProhibitStringyEval, ErrorHandling::RequireCheckingReturnValueOfEval)
      eval $code;
      die $@ if $@;
  
      ( my $filename = "$subclass.pm" ) =~ s{::}{/}g;
      $INC{$filename} = __FILE__;
  
      $CLASSES{$subclass} = 1;
  }
  
  sub caught {
      my $e = $@;
  
      return $e unless $_[1];
  
      return unless blessed($e) && $e->isa( $_[1] );
      return $e;
  }
  
  sub Classes { sort keys %Exception::Class::CLASSES }
  
  1;
  
  # ABSTRACT: A module that allows you to declare real exception classes in Perl
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Exception::Class - A module that allows you to declare real exception classes in Perl
  
  =head1 VERSION
  
  version 1.44
  
  =head1 SYNOPSIS
  
    use Exception::Class (
        'MyException',
  
        'AnotherException' => { isa => 'MyException' },
  
        'YetAnotherException' => {
            isa         => 'AnotherException',
            description => 'These exceptions are related to IPC'
        },
  
        'ExceptionWithFields' => {
            isa    => 'YetAnotherException',
            fields => [ 'grandiosity', 'quixotic' ],
            alias  => 'throw_fields',
        },
    );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        MyException->throw( error => 'I feel funny.' );
    }
    catch {
        die $_ unless blessed $_ && $_->can('rethrow');
  
        if ( $_->isa('Exception::Class') ) {
            warn $_->error, "\n", $_->trace->as_string, "\n";
            warn join ' ', $_->euid, $_->egid, $_->uid, $_->gid, $_->pid, $_->time;
  
            exit;
        }
        elsif ( $_->isa('ExceptionWithFields') ) {
            if ( $_->quixotic ) {
                handle_quixotic_exception();
            }
            else {
                handle_non_quixotic_exception();
            }
        }
        else {
            $_->rethrow;
        }
    };
  
    # without Try::Tiny
    eval { ... };
    if ( my $e = Exception::Class->caught ) { ... }
  
    # use an alias - without parens subroutine name is checked at
    # compile time
    throw_fields error => "No strawberry", grandiosity => "quite a bit";
  
  =head1 DESCRIPTION
  
  B<RECOMMENDATION 1>: If you are writing modern Perl code with L<Moose> or
  L<Moo> I highly recommend using L<Throwable> instead of this module.
  
  B<RECOMMENDATION 2>: Whether or not you use L<Throwable>, you should use
  L<Try::Tiny>.
  
  Exception::Class allows you to declare exception hierarchies in your modules
  in a "Java-esque" manner.
  
  It features a simple interface allowing programmers to 'declare' exception
  classes at compile time. It also has a base exception class,
  L<Exception::Class::Base>, that can be easily extended.
  
  It is designed to make structured exception handling simpler and better by
  encouraging people to use hierarchies of exceptions in their applications, as
  opposed to a single catch-all exception class.
  
  This module does not implement any try/catch syntax. Please see the "OTHER
  EXCEPTION MODULES (try/catch syntax)" section for more information on how to
  get this syntax.
  
  You will also want to look at the documentation for L<Exception::Class::Base>,
  which is the default base class for all exception objects created by this
  module.
  
  =for Pod::Coverage     Classes
      caught
  
  =head1 DECLARING EXCEPTION CLASSES
  
  Importing C<Exception::Class> allows you to automagically create
  L<Exception::Class::Base> subclasses. You can also create subclasses via the
  traditional means of defining your own subclass with C<@ISA>.  These two
  methods may be easily combined, so that you could subclass an exception class
  defined via the automagic import, if you desired this.
  
  The syntax for the magic declarations is as follows:
  
    'MANDATORY CLASS NAME' => \%optional_hashref
  
  The hashref may contain the following options:
  
  =over 4
  
  =item * isa
  
  This is the class's parent class. If this isn't provided then the class name
  in C<$Exception::Class::BASE_EXC_CLASS> is assumed to be the parent (see
  below).
  
  This parameter lets you create arbitrarily deep class hierarchies.  This can
  be any other L<Exception::Class::Base> subclass in your declaration I<or> a
  subclass loaded from a module.
  
  To change the default exception class you will need to change the value of
  C<$Exception::Class::BASE_EXC_CLASS> I<before> calling C<import>. To do this
  simply do something like this:
  
    BEGIN { $Exception::Class::BASE_EXC_CLASS = 'SomeExceptionClass'; }
  
  If anyone can come up with a more elegant way to do this please let me know.
  
  CAVEAT: If you want to automagically subclass an L<Exception::Class::Base>
  subclass loaded from a file, then you I<must> compile the class (via use or
  require or some other magic) I<before> you import C<Exception::Class> or
  you'll get a compile time error.
  
  =item * fields
  
  This allows you to define additional attributes for your exception class. Any
  field you define can be passed to the C<throw> or C<new> methods as additional
  parameters for the constructor. In addition, your exception object will have
  an accessor method for the fields you define.
  
  This parameter can be either a scalar (for a single field) or an array
  reference if you need to define multiple fields.
  
  Fields will be inherited by subclasses.
  
  =item * alias
  
  Specifying an alias causes this class to create a subroutine of the specified
  name in the I<caller's> namespace. Calling this subroutine is equivalent to
  calling C<< <class>->throw(@_) >> for the given exception class.
  
  Besides convenience, using aliases also allows for additional compile time
  checking. If the alias is called I<without parentheses>, as in C<throw_fields
  "an error occurred">, then Perl checks for the existence of the
  C<throw_fields> subroutine at compile time. If instead you do C<<
  ExceptionWithFields->throw(...) >>, then Perl checks the class name at
  runtime, meaning that typos may sneak through.
  
  =item * description
  
  Each exception class has a description method that returns a fixed
  string. This should describe the exception I<class> (as opposed to any
  particular exception object). This may be useful for debugging if you start
  catching exceptions you weren't expecting (particularly if someone forgot to
  document them) and you don't understand the error messages.
  
  =back
  
  The C<Exception::Class> magic attempts to detect circular class hierarchies
  and will die if it finds one. It also detects missing links in a chain, for
  example if you declare Bar to be a subclass of Foo and never declare Foo.
  
  =head1 L<Try::Tiny>
  
  If you are interested in adding try/catch/finally syntactic sugar to your code
  then I recommend you check out L<Try::Tiny>. This is a great module that helps
  you ignore some of the weirdness with C<eval> and C<$@>. Here's an example of
  how the two modules work together:
  
    use Exception::Class ( 'My::Exception' );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        might_throw();
    }
    catch {
        if ( blessed $_ && $_->isa('My::Exception') ) {
            handle_it();
        }
        else {
            die $_;
        }
    };
  
  Note that you B<cannot> use C<< Exception::Class->caught >> with L<Try::Tiny>.
  
  =head1 Catching Exceptions Without L<Try::Tiny>
  
  C<Exception::Class> provides some syntactic sugar for catching exceptions in a
  safe manner:
  
    eval {...};
  
    if ( my $e = Exception::Class->caught('My::Error') ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  The C<caught> method takes a class name and returns an exception object if the
  last thrown exception is of the given class, or a subclass of that class. If
  it is not given any arguments, it simply returns C<$@>.
  
  You should B<always> make a copy of the exception object, rather than using
  C<$@> directly. This is necessary because if your C<cleanup> function uses
  C<eval>, or calls something which uses it, then C<$@> is overwritten. Copying
  the exception preserves it for the call to C<do_something_with_exception>.
  
  Exception objects also provide a caught method so you can write:
  
    if ( my $e = My::Error->caught ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  =head2 Uncatchable Exceptions
  
  Internally, the C<caught> method will call C<isa> on the exception object. You
  could make an exception "uncatchable" by overriding C<isa> in that class like
  this:
  
   package Exception::Uncatchable;
  
   sub isa { shift->rethrow }
  
  Of course, this only works if you always call C<< Exception::Class->caught >>
  after an C<eval>.
  
  =head1 USAGE RECOMMENDATION
  
  If you're creating a complex system that throws lots of different types of
  exceptions, consider putting all the exception declarations in one place. For
  an app called Foo you might make a C<Foo::Exceptions> module and use that in
  all your code. This module could just contain the code to make
  C<Exception::Class> do its automagic class creation. Doing this allows you to
  more easily see what exceptions you have, and makes it easier to keep track of
  them.
  
  This might look something like this:
  
    package Foo::Bar::Exceptions;
  
    use Exception::Class (
        Foo::Bar::Exception::Senses =>
            { description => 'sense-related exception' },
  
        Foo::Bar::Exception::Smell => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => 'odor',
            description => 'stinky!'
        },
  
        Foo::Bar::Exception::Taste => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => [ 'taste', 'bitterness' ],
            description => 'like, gag me with a spoon!'
        },
  
        ...
    );
  
  You may want to create a real module to subclass L<Exception::Class::Base> as
  well, particularly if you want your exceptions to have more methods.
  
  =head2 Subclassing Exception::Class::Base
  
  As part of your usage of C<Exception::Class>, you may want to create your own
  base exception class which subclasses L<Exception::Class::Base>. You should
  feel free to subclass any of the methods documented above. For example, you
  may want to subclass C<new> to add additional information to your exception
  objects.
  
  =head1 Exception::Class FUNCTIONS
  
  The C<Exception::Class> method offers one function, C<Classes>, which is not
  exported. This method returns a list of the classes that have been created by
  calling the C<Exception::Class> C<import> method.  Note that this is I<all>
  the subclasses that have been created, so it may include subclasses created by
  things like CPAN modules, etc. Also note that if you simply define a subclass
  via the normal Perl method of setting C<@ISA> or C<use base>, then your
  subclass will not be included.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Exception-Class/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Exception-Class can be found at L<https://github.com/houseabsolute/Exception-Class>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alexander Batyrshin Leon Timmermans Ricardo Signes
  
  =over 4
  
  =item *
  
  Alexander Batyrshin <0x62ash@gmail.com>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
EXCEPTION_CLASS

$fatpacked{"Exception/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS_BASE';
  package Exception::Class::Base;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.44';
  
  use Class::Data::Inheritable 0.02;
  use Devel::StackTrace 2.00;
  use Scalar::Util qw( blessed );
  
  use base qw(Class::Data::Inheritable);
  
  BEGIN {
      __PACKAGE__->mk_classdata('Trace');
      __PACKAGE__->mk_classdata('UnsafeRefCapture');
  
      __PACKAGE__->mk_classdata('NoContextInfo');
      __PACKAGE__->NoContextInfo(0);
  
      __PACKAGE__->mk_classdata('RespectOverload');
      __PACKAGE__->RespectOverload(0);
  
      __PACKAGE__->mk_classdata('MaxArgLength');
      __PACKAGE__->MaxArgLength(0);
  
      sub NoRefs {
          my $self = shift;
          if (@_) {
              my $val = shift;
              return $self->UnsafeRefCapture( !$val );
          }
          else {
              return $self->UnsafeRefCapture;
          }
      }
  
      sub Fields { () }
  }
  
  use overload
  
      # an exception is always true
      bool => sub {1}, '""' => 'as_string', fallback => 1;
  
  # Create accessor routines
  BEGIN {
      my @fields = qw( message pid uid euid gid egid time trace );
  
      foreach my $f (@fields) {
          my $sub = sub { my $s = shift; return $s->{$f}; };
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$f} = $sub;
      }
      *error = \&message;
  
      my %trace_fields = (
          package => 'package',
          file    => 'filename',
          line    => 'line',
      );
  
      while ( my ( $f, $m ) = each %trace_fields ) {
          my $sub = sub {
              my $s = shift;
              return $s->{$f} if exists $s->{$f};
  
              my $frame = $s->trace->frame(0);
  
              return $s->{$f} = $frame ? $frame->$m : undef;
          };
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$f} = $sub;
      }
  }
  
  sub Classes { Exception::Class::Classes() }
  
  sub throw {
      my $proto = shift;
  
      $proto->rethrow if ref $proto;
  
      die $proto->new(@_);
  }
  
  sub rethrow {
      my $self = shift;
  
      die $self;
  }
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self = bless {}, $class;
  
      $self->_initialize(@_);
  
      return $self;
  }
  
  sub _initialize {
      my $self = shift;
      my %p = @_ == 1 ? ( error => $_[0] ) : @_;
  
      $self->{message} = $p{message} || $p{error} || q{};
  
      $self->{show_trace} = $p{show_trace} if exists $p{show_trace};
  
      if ( $self->NoContextInfo ) {
          $self->{show_trace} = 0;
          $self->{package} = $self->{file} = $self->{line} = undef;
      }
      else {
          # CORE::time is important to fix an error with some versions of
          # Perl
          $self->{time} = CORE::time();
          $self->{pid}  = $$;
          $self->{uid}  = $<;
          $self->{euid} = $>;
          $self->{gid}  = $(;
          $self->{egid} = $);
  
          my @ignore_class   = (__PACKAGE__);
          my @ignore_package = 'Exception::Class';
  
          if ( my $i = delete $p{ignore_class} ) {
              push @ignore_class, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          if ( my $i = delete $p{ignore_package} ) {
              push @ignore_package, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          $self->{trace} = Devel::StackTrace->new(
              ignore_class       => \@ignore_class,
              ignore_package     => \@ignore_package,
              unsafe_ref_capture => $self->UnsafeRefCapture,
              respect_overload   => $self->RespectOverload,
              max_arg_length     => $self->MaxArgLength,
              map { $p{$_} ? ( $_ => delete $p{$_} ) : () } qw(
                  frame_filter
                  filter_frames_early
                  skip_frames
                  ),
          );
      }
  
      my %fields = map { $_ => 1 } $self->Fields;
      while ( my ( $key, $value ) = each %p ) {
          next if $key =~ /^(?:error|message|show_trace)$/;
  
          if ( $fields{$key} ) {
              $self->{$key} = $value;
          }
          else {
              Exception::Class::Base->throw(
                  error => "unknown field $key passed to constructor for class "
                      . ref $self );
          }
      }
  }
  
  sub context_hash {
      my $self = shift;
  
      return {
          time => $self->{time},
          pid  => $self->{pid},
          uid  => $self->{uid},
          euid => $self->{euid},
          gid  => $self->{gid},
          egid => $self->{egid},
      };
  }
  
  sub field_hash {
      my $self = shift;
  
      my $hash = {};
  
      for my $field ( $self->Fields ) {
          $hash->{$field} = $self->$field;
      }
  
      return $hash;
  }
  
  sub description {
      return 'Generic exception';
  }
  
  sub show_trace {
      my $self = shift;
  
      return 0 unless $self->{trace};
  
      if (@_) {
          $self->{show_trace} = shift;
      }
  
      return exists $self->{show_trace} ? $self->{show_trace} : $self->Trace;
  }
  
  sub as_string {
      my $self = shift;
  
      my $str = $self->full_message;
      unless ( defined $str && length $str ) {
          my $desc = $self->description;
          $str = defined $desc
              && length $desc ? "[$desc]" : '[Generic exception]';
      }
  
      $str .= "\n\n" . $self->trace->as_string
          if $self->show_trace;
  
      return $str;
  }
  
  sub full_message { $_[0]->message }
  
  #
  # The %seen bit protects against circular inheritance.
  #
  ## no critic (BuiltinFunctions::ProhibitStringyEval, ErrorHandling::RequireCheckingReturnValueOfEval)
  eval <<'EOF' if $] == 5.006;
  sub isa {
      my ( $inheritor, $base ) = @_;
      $inheritor = ref($inheritor) if ref($inheritor);
  
      my %seen;
  
      no strict 'refs';
      my @parents = ( $inheritor, @{"$inheritor\::ISA"} );
      while ( my $class = shift @parents ) {
          return 1 if $class eq $base;
  
          push @parents, grep { !$seen{$_}++ } @{"$class\::ISA"};
      }
      return 0;
  }
  EOF
  
  sub caught {
      my $class = shift;
  
      my $e = $@;
  
      return unless defined $e && blessed($e) && $e->isa($class);
      return $e;
  }
  
  1;
  
  # ABSTRACT: A base class for exception objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Exception::Class::Base - A base class for exception objects
  
  =head1 VERSION
  
  version 1.44
  
  =head1 SYNOPSIS
  
    use Exception::Class 'MyException';
  
    eval { MyException->throw( error => 'I feel funny.' ) };
  
    print $@->error;
  
  =head1 DESCRIPTION
  
  This class is the base class for all exceptions created by
  L<Exception::Class>. It provides a number of methods for getting information
  about the exception.
  
  =for Pod::Coverage     Classes
      caught
      NoRefs
  
  =head1 METHODS
  
  =head2 MyException->Trace($boolean)
  
  Each C<Exception::Class::Base> subclass can be set individually to include a
  stacktrace when the C<as_string> method is called. The default is to not
  include a stacktrace. Calling this method with a value changes this
  behavior. It always returns the current value (after any change is applied).
  
  This value is inherited by any subclasses. However, if this value is set for a
  subclass, it will thereafter be independent of the value in
  C<Exception::Class::Base>.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  This is a class method, not an object method.
  
  =head2 MyException->UnsafeRefCapture($boolean)
  
  When a C<Devel::StackTrace> object is created, it walks through the stack and
  stores the arguments which were passed to each subroutine on the stack. If any
  of these arguments are references, then that means that the
  C<Devel::StackTrace> ends up increasing the ref count of these references,
  delaying their destruction.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally, this
  method provides a way to tell C<Devel::StackTrace> not to store these
  references. Instead, C<Devel::StackTrace> replaces references with their
  stringified representation.
  
  This method defaults to false. As with C<Trace>, it is inherited by subclasses
  but setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->RespectOverload($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it ignores
  stringification overloading on any objects being dealt with.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally, this
  method provides a way to tell C<Devel::StackTrace> to respect overloading.
  
  This method defaults to false. As with C<Trace>, it is inherited by subclasses
  but setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->MaxArgLength($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it displays the
  full argument for each function. This parameter can be used to limit the
  maximum length of each argument.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally, this
  method provides a way to tell C<Devel::StackTrace> to limit the length of
  arguments.
  
  This method defaults to 0. As with C<Trace>, it is inherited by subclasses but
  setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->Fields
  
  This method returns the extra fields defined for the given class, as a list.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->throw( $message )
  
  =head2 MyException->throw( message => $message )
  
  =head2 MyException->throw( error => $error )
  
  This method creates a new object with the given error message. If no error
  message is given, this will be an empty string. It then dies with this object
  as its argument.
  
  This method also takes a C<show_trace> parameter which indicates whether or
  not the particular exception object being created should show a stacktrace
  when its C<as_string> method is called. This overrides the value of C<Trace>
  for this class if it is given.
  
  The frames included in the trace can be controlled by the C<ignore_class> and
  C<ignore_package> parameters. These are passed directly to Devel::Stacktrace's
  constructor. See C<Devel::Stacktrace> for more details. This class B<always>
  passes C<__PACKAGE__> for C<ignore_class> and C<'Exception::Class'> for
  C<ignore_package>, in addition to any arguments you provide.
  
  If only a single value is given to the constructor it is assumed to be the
  message parameter.
  
  Additional keys corresponding to the fields defined for the particular
  exception subclass will also be accepted.
  
  =head2 MyException->new(...)
  
  This method takes the same parameters as C<throw>, but instead of dying simply
  returns a new exception object.
  
  This method is always called when constructing a new exception object via the
  C<throw> method.
  
  =head2 MyException->description
  
  Returns the description for the given C<Exception::Class::Base> subclass. The
  C<Exception::Class::Base> class's description is "Generic exception" (this may
  change in the future). This is also an object method.
  
  =head2 $exception->rethrow
  
  Simply dies with the object as its sole argument. It's just syntactic
  sugar. This does not change any of the object's attribute values.  However, it
  will cause C<caller> to report the die as coming from within the
  C<Exception::Class::Base> class rather than where rethrow was called.
  
  Of course, you always have access to the original stacktrace for the exception
  object.
  
  =head2 $exception->message
  
  =head2 $exception->error
  
  Returns the error/message associated with the exception.
  
  =head2 $exception->pid
  
  Returns the pid at the time the exception was thrown.
  
  =head2 $exception->uid
  
  Returns the real user id at the time the exception was thrown.
  
  =head2 $exception->gid
  
  Returns the real group id at the time the exception was thrown.
  
  =head2 $exception->euid
  
  Returns the effective user id at the time the exception was thrown.
  
  =head2 $exception->egid
  
  Returns the effective group id at the time the exception was thrown.
  
  =head2 $exception->time
  
  Returns the time in seconds since the epoch at the time the exception was
  thrown.
  
  =head2 $exception->package
  
  Returns the package from which the exception was thrown.
  
  =head2 $exception->file
  
  Returns the file within which the exception was thrown.
  
  =head2 $exception->line
  
  Returns the line where the exception was thrown.
  
  =head2 $exception->context_hash
  
  Returns a hash reference with the following keys:
  
  =over 4
  
  =item * time
  
  =item * pid
  
  =item * uid
  
  =item * euid
  
  =item * gid
  
  =item * egid
  
  =back
  
  =head2 $exception->field_hash
  
  Returns a hash reference where the keys are any fields defined for the
  exception class and the values are the values associated with the field in the
  given object.
  
  =head2 $exception->trace
  
  Returns the trace object associated with the object.
  
  =head2 $exception->show_trace($boolean)
  
  This method can be used to set whether or not a stack trace is included when
  the as_string method is called or the object is stringified.
  
  =head2 $exception->as_string
  
  Returns a string form of the error message (something like what you'd expect
  from die). If the class or object is set to show traces then then the full
  trace is also included. The result looks like C<Carp::confess>.
  
  =head2 $exception->full_message
  
  Called by the C<as_string> method to get the message. By default, this is the
  same as calling the C<message> method, but may be overridden by a
  subclass. See below for details.
  
  =head1 LIGHTWEIGHT EXCEPTIONS
  
  A lightweight exception is one which records no information about its context
  when it is created. This can be achieved by setting C<< $class->NoContextInfo
  >> to a true value.
  
  You can make this the default for a class of exceptions by setting it after
  creating the class:
  
    use Exception::Class (
        'LightWeight',
        'HeavyWeight',
    );
  
    LightWeight->NoContextInfo(1);
  
  A lightweight exception does have a stack trace object, nor does it record the
  time, pid, uid, euid, gid, or egid. It only has a message.
  
  =head1 OVERLOADING
  
  C<Exception::Class::Base> objects are overloaded so that stringification
  produces a normal error message. This just calls the C<< $exception->as_string
  >> method described above. This means that you can just C<print $@> after an
  C<eval> and not worry about whether or not its an actual object. It also means
  an application or module could do this:
  
    $SIG{__DIE__} = sub { Exception::Class::Base->throw( error => join '', @_ ); };
  
  and this would probably not break anything (unless someone was expecting a
  different type of exception object from C<die>).
  
  =head1 OVERRIDING THE as_string METHOD
  
  By default, the C<as_string> method simply returns the value C<message> or
  C<error> param plus a stack trace, if the class's C<Trace> method returns a
  true value or C<show_trace> was set when creating the exception.
  
  However, once you add new fields to a subclass, you may want to include those
  fields in the stringified error.
  
  Inside the C<as_string> method, the message (non-stack trace) portion of the
  error is generated by calling the C<full_message> method. This can be easily
  overridden. For example:
  
    sub full_message {
        my $self = shift;
  
        my $msg = $self->message;
  
        $msg .= " and foo was " . $self->foo;
  
        return $msg;
    }
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Exception-Class/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Exception-Class can be found at L<https://github.com/houseabsolute/Exception-Class>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
EXCEPTION_CLASS_BASE

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as} ? $globals->{as}->($name) :
  		ref    $value->{-as}  ? $value->{-as}->($name) :
  		exists $value->{-as}  ? $value->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	unless (ref($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)         if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"IO/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRING';
  package IO::String;
  
  # Copyright 1998-2005 Gisle Aas.
  #
  # This library is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  require 5.005_03;
  use strict;
  use vars qw($VERSION $DEBUG $IO_CONSTANTS);
  $VERSION = "1.08";  # $Date: 2005/12/05 12:00:47 $
  
  use Symbol ();
  
  sub new
  {
      my $class = shift;
      my $self = bless Symbol::gensym(), ref($class) || $class;
      tie *$self, $self;
      $self->open(@_);
      return $self;
  }
  
  sub open
  {
      my $self = shift;
      return $self->new(@_) unless ref($self);
  
      if (@_) {
  	my $bufref = ref($_[0]) ? $_[0] : \$_[0];
  	$$bufref = "" unless defined $$bufref;
  	*$self->{buf} = $bufref;
      }
      else {
  	my $buf = "";
  	*$self->{buf} = \$buf;
      }
      *$self->{pos} = 0;
      *$self->{lno} = 0;
      return $self;
  }
  
  sub pad
  {
      my $self = shift;
      my $old = *$self->{pad};
      *$self->{pad} = substr($_[0], 0, 1) if @_;
      return "\0" unless defined($old) && length($old);
      return $old;
  }
  
  sub dump
  {
      require Data::Dumper;
      my $self = shift;
      print Data::Dumper->Dump([$self], ['*self']);
      print Data::Dumper->Dump([*$self{HASH}], ['$self{HASH}']);
      return;
  }
  
  sub TIEHANDLE
  {
      print "TIEHANDLE @_\n" if $DEBUG;
      return $_[0] if ref($_[0]);
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->open(@_);
      return $self;
  }
  
  sub DESTROY
  {
      print "DESTROY @_\n" if $DEBUG;
  }
  
  sub close
  {
      my $self = shift;
      delete *$self->{buf};
      delete *$self->{pos};
      delete *$self->{lno};
      undef *$self if $] eq "5.008";  # workaround for some bug
      return 1;
  }
  
  sub opened
  {
      my $self = shift;
      return defined *$self->{buf};
  }
  
  sub binmode
  {
      my $self = shift;
      return 1 unless @_;
      # XXX don't know much about layers yet :-(
      return 0;
  }
  
  sub getc
  {
      my $self = shift;
      my $buf;
      return $buf if $self->read($buf, 1);
      return undef;
  }
  
  sub ungetc
  {
      my $self = shift;
      $self->setpos($self->getpos() - 1);
      return 1;
  }
  
  sub eof
  {
      my $self = shift;
      return length(${*$self->{buf}}) <= *$self->{pos};
  }
  
  sub print
  {
      my $self = shift;
      if (defined $\) {
  	if (defined $,) {
  	    $self->write(join($,, @_).$\);
  	}
  	else {
  	    $self->write(join("",@_).$\);
  	}
      }
      else {
  	if (defined $,) {
  	    $self->write(join($,, @_));
  	}
  	else {
  	    $self->write(join("",@_));
  	}
      }
      return 1;
  }
  *printflush = \*print;
  
  sub printf
  {
      my $self = shift;
      print "PRINTF(@_)\n" if $DEBUG;
      my $fmt = shift;
      $self->write(sprintf($fmt, @_));
      return 1;
  }
  
  
  my($SEEK_SET, $SEEK_CUR, $SEEK_END);
  
  sub _init_seek_constants
  {
      if ($IO_CONSTANTS) {
  	require IO::Handle;
  	$SEEK_SET = &IO::Handle::SEEK_SET;
  	$SEEK_CUR = &IO::Handle::SEEK_CUR;
  	$SEEK_END = &IO::Handle::SEEK_END;
      }
      else {
  	$SEEK_SET = 0;
  	$SEEK_CUR = 1;
  	$SEEK_END = 2;
      }
  }
  
  
  sub seek
  {
      my($self,$off,$whence) = @_;
      my $buf = *$self->{buf} || return 0;
      my $len = length($$buf);
      my $pos = *$self->{pos};
  
      _init_seek_constants() unless defined $SEEK_SET;
  
      if    ($whence == $SEEK_SET) { $pos = $off }
      elsif ($whence == $SEEK_CUR) { $pos += $off }
      elsif ($whence == $SEEK_END) { $pos = $len + $off }
      else                         { die "Bad whence ($whence)" }
      print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if $DEBUG;
  
      $pos = 0 if $pos < 0;
      $self->truncate($pos) if $pos > $len;  # extend file
      *$self->{pos} = $pos;
      return 1;
  }
  
  sub pos
  {
      my $self = shift;
      my $old = *$self->{pos};
      if (@_) {
  	my $pos = shift || 0;
  	my $buf = *$self->{buf};
  	my $len = $buf ? length($$buf) : 0;
  	$pos = $len if $pos > $len;
  	*$self->{pos} = $pos;
      }
      return $old;
  }
  
  sub getpos { shift->pos; }
  
  *sysseek = \&seek;
  *setpos  = \&pos;
  *tell    = \&getpos;
  
  
  
  sub getline
  {
      my $self = shift;
      my $buf  = *$self->{buf} || return;
      my $len  = length($$buf);
      my $pos  = *$self->{pos};
      return if $pos >= $len;
  
      unless (defined $/) {  # slurp
  	*$self->{pos} = $len;
  	return substr($$buf, $pos);
      }
  
      unless (length $/) {  # paragraph mode
  	# XXX slow&lazy implementation using getc()
  	my $para = "";
  	my $eol = 0;
  	my $c;
  	while (defined($c = $self->getc)) {
  	    if ($c eq "\n") {
  		$eol++;
  		next if $eol > 2;
  	    }
  	    elsif ($eol > 1) {
  		$self->ungetc($c);
  		last;
  	    }
  	    else {
  		$eol = 0;
  	    }
  	    $para .= $c;
  	}
  	return $para;   # XXX wantarray
      }
  
      my $idx = index($$buf,$/,$pos);
      if ($idx < 0) {
  	# return rest of it
  	*$self->{pos} = $len;
  	$. = ++ *$self->{lno};
  	return substr($$buf, $pos);
      }
      $len = $idx - $pos + length($/);
      *$self->{pos} += $len;
      $. = ++ *$self->{lno};
      return substr($$buf, $pos, $len);
  }
  
  sub getlines
  {
      die "getlines() called in scalar context\n" unless wantarray;
      my $self = shift;
      my($line, @lines);
      push(@lines, $line) while defined($line = $self->getline);
      return @lines;
  }
  
  sub READLINE
  {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub input_line_number
  {
      my $self = shift;
      my $old = *$self->{lno};
      *$self->{lno} = shift if @_;
      return $old;
  }
  
  sub truncate
  {
      my $self = shift;
      my $len = shift || 0;
      my $buf = *$self->{buf};
      if (length($$buf) >= $len) {
  	substr($$buf, $len) = '';
  	*$self->{pos} = $len if $len < *$self->{pos};
      }
      else {
  	$$buf .= ($self->pad x ($len - length($$buf)));
      }
      return 1;
  }
  
  sub read
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return undef unless $buf;
  
      my $pos = *$self->{pos};
      my $rem = length($$buf) - $pos;
      my $len = $_[1];
      $len = $rem if $len > $rem;
      return undef if $len < 0;
      if (@_ > 2) { # read offset
  	substr($_[0],$_[2]) = substr($$buf, $pos, $len);
      }
      else {
  	$_[0] = substr($$buf, $pos, $len);
      }
      *$self->{pos} += $len;
      return $len;
  }
  
  sub write
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return unless $buf;
  
      my $pos = *$self->{pos};
      my $slen = length($_[0]);
      my $len = $slen;
      my $off = 0;
      if (@_ > 1) {
  	$len = $_[1] if $_[1] < $len;
  	if (@_ > 2) {
  	    $off = $_[2] || 0;
  	    die "Offset outside string" if $off > $slen;
  	    if ($off < 0) {
  		$off += $slen;
  		die "Offset outside string" if $off < 0;
  	    }
  	    my $rem = $slen - $off;
  	    $len = $rem if $rem < $len;
  	}
      }
      substr($$buf, $pos, $len) = substr($_[0], $off, $len);
      *$self->{pos} += $len;
      return $len;
  }
  
  *sysread = \&read;
  *syswrite = \&write;
  
  sub stat
  {
      my $self = shift;
      return unless $self->opened;
      return 1 unless wantarray;
      my $len = length ${*$self->{buf}};
  
      return (
       undef, undef,  # dev, ino
       0666,          # filemode
       1,             # links
       $>,            # user id
       $),            # group id
       undef,         # device id
       $len,          # size
       undef,         # atime
       undef,         # mtime
       undef,         # ctime
       512,           # blksize
       int(($len+511)/512)  # blocks
      );
  }
  
  sub FILENO {
      return undef;   # XXX perlfunc says this means the file is closed
  }
  
  sub blocking {
      my $self = shift;
      my $old = *$self->{blocking} || 0;
      *$self->{blocking} = shift if @_;
      return $old;
  }
  
  my $notmuch = sub { return };
  
  *fileno    = $notmuch;
  *error     = $notmuch;
  *clearerr  = $notmuch; 
  *sync      = $notmuch;
  *flush     = $notmuch;
  *setbuf    = $notmuch;
  *setvbuf   = $notmuch;
  
  *untaint   = $notmuch;
  *autoflush = $notmuch;
  *fcntl     = $notmuch;
  *ioctl     = $notmuch;
  
  *GETC   = \&getc;
  *PRINT  = \&print;
  *PRINTF = \&printf;
  *READ   = \&read;
  *WRITE  = \&write;
  *SEEK   = \&seek;
  *TELL   = \&getpos;
  *EOF    = \&eof;
  *CLOSE  = \&close;
  *BINMODE = \&binmode;
  
  
  sub string_ref
  {
      my $self = shift;
      return *$self->{buf};
  }
  *sref = \&string_ref;
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::String - Emulate file interface for in-core strings
  
  =head1 SYNOPSIS
  
   use IO::String;
   $io = IO::String->new;
   $io = IO::String->new($var);
   tie *IO, 'IO::String';
  
   # read data
   <$io>;
   $io->getline;
   read($io, $buf, 100);
  
   # write data
   print $io "string\n";
   $io->print(@data);
   syswrite($io, $buf, 100);
  
   select $io;
   printf "Some text %s\n", $str;
  
   # seek
   $pos = $io->getpos;
   $io->setpos(0);        # rewind
   $io->seek(-30, -1);
   seek($io, 0, 0);
  
  =head1 DESCRIPTION
  
  The C<IO::String> module provides the C<IO::File> interface for in-core
  strings.  An C<IO::String> object can be attached to a string, and
  makes it possible to use the normal file operations for reading or
  writing data, as well as for seeking to various locations of the string.
  This is useful when you want to use a library module that only
  provides an interface to file handles on data that you have in a string
  variable.
  
  Note that perl-5.8 and better has built-in support for "in memory"
  files, which are set up by passing a reference instead of a filename
  to the open() call. The reason for using this module is that it
  makes the code backwards compatible with older versions of Perl.
  
  The C<IO::String> module provides an interface compatible with
  C<IO::File> as distributed with F<IO-1.20>, but the following methods
  are not available: new_from_fd, fdopen, format_write,
  format_page_number, format_lines_per_page, format_lines_left,
  format_name, format_top_name.
  
  The following methods are specific to the C<IO::String> class:
  
  =over 4
  
  =item $io = IO::String->new
  
  =item $io = IO::String->new( $string )
  
  The constructor returns a newly-created C<IO::String> object.  It
  takes an optional argument, which is the string to read from or write
  into.  If no $string argument is given, then an internal buffer
  (initially empty) is allocated.
  
  The C<IO::String> object returned is tied to itself.  This means
  that you can use most Perl I/O built-ins on it too: readline, <>, getc,
  print, printf, syswrite, sysread, close.
  
  =item $io->open
  
  =item $io->open( $string )
  
  Attaches an existing IO::String object to some other $string, or
  allocates a new internal buffer (if no argument is given).  The
  position is reset to 0.
  
  =item $io->string_ref
  
  Returns a reference to the string that is attached to
  the C<IO::String> object.  Most useful when you let the C<IO::String>
  create an internal buffer to write into.
  
  =item $io->pad
  
  =item $io->pad( $char )
  
  Specifies the padding to use if
  the string is extended by either the seek() or truncate() methods.  It
  is a single character and defaults to "\0".
  
  =item $io->pos
  
  =item $io->pos( $newpos )
  
  Yet another interface for reading and setting the current read/write
  position within the string (the normal getpos/setpos/tell/seek
  methods are also available).  The pos() method always returns the
  old position, and if you pass it an argument it sets the new
  position.
  
  There is (deliberately) a difference between the setpos() and seek()
  methods in that seek() extends the string (with the specified
  padding) if you go to a location past the end, whereas setpos()
  just snaps back to the end.  If truncate() is used to extend the string,
  then it works as seek().
  
  =back
  
  =head1 BUGS
  
  In Perl versions < 5.6, the TIEHANDLE interface was incomplete.
  If you use such a Perl, then seek(), tell(), eof(), fileno(), binmode() will
  not do anything on an C<IO::String> handle.  See L<perltie> for
  details.
  
  =head1 SEE ALSO
  
  L<IO::File>, L<IO::Stringy>, L<perlfunc/open>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
IO_STRING

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  my $have_xs;
  our $VERSION = '0.428';
  
  BEGIN
  {
      unless (defined($have_xs))
      {
          eval { require List::MoreUtils::XS; } unless $ENV{LIST_MOREUTILS_PP};
          die $@ if $@ && defined $ENV{LIST_MOREUTILS_PP} && $ENV{LIST_MOREUTILS_PP} == 0;
          $have_xs = 0+defined( $INC{'List/MoreUtils/XS.pm'});
      }
  
      use List::MoreUtils::PP qw();
  }
  
  use Exporter::Tiny qw();
  
  my @junctions = qw(any all none notall);
  my @v0_22     = qw(
    true false
    firstidx lastidx
    insert_after insert_after_string
    apply indexes
    after after_incl before before_incl
    firstval lastval
    each_array each_arrayref
    pairwise natatime
    mesh uniq
    minmax part
    _XScompiled
  );
  my @v0_24  = qw(bsearch);
  my @v0_33  = qw(sort_by nsort_by);
  my @v0_400 = qw(one any_u all_u none_u notall_u one_u
    firstres onlyidx onlyval onlyres lastres
    singleton bsearchidx
  );
  my @v0_420 = qw(arrayify duplicates minmaxstr samples zip6 reduce_0 reduce_1 reduce_u
    listcmp frequency occurrences mode
    binsert bremove equal_range lower_bound upper_bound qsort);
  
  my @all_functions = (@junctions, @v0_22, @v0_24, @v0_33, @v0_400, @v0_420);
  
  no strict "refs";
  if ($have_xs)
  {
      my $x;
      for (@all_functions)
      {
          List::MoreUtils->can($_) or *$_ = $x if ($x = List::MoreUtils::XS->can($_));
      }
  }
  List::MoreUtils->can($_) or *$_ = List::MoreUtils::PP->can($_) for (@all_functions);
  use strict;
  
  my %alias_list = (
      v0_22 => {
          first_index => "firstidx",
          last_index  => "lastidx",
          first_value => "firstval",
          last_value  => "lastval",
          zip         => "mesh",
      },
      v0_33 => {
          distinct => "uniq",
      },
      v0_400 => {
          first_result  => "firstres",
          only_index    => "onlyidx",
          only_value    => "onlyval",
          only_result   => "onlyres",
          last_result   => "lastres",
          bsearch_index => "bsearchidx",
      },
      v0_420 => {
  	bsearch_insert => "binsert",
  	bsearch_remove => "bremove",
  	zip_unflatten  => "zip6",
      },
  );
  
  our @ISA         = qw(Exporter::Tiny);
  our @EXPORT_OK   = (@all_functions, map { keys %$_ } values %alias_list);
  our %EXPORT_TAGS = (
      all         => \@EXPORT_OK,
      'like_0.22' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          none_u   => {-as => 'none'},
          notall_u => {-as => 'notall'},
          @v0_22,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.24' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          notall_u => {-as => 'notall'},
          'none',
          @v0_22,
          @v0_24,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.33' => [
          @junctions,
          @v0_22,
          # v0_24 functions were omitted
          @v0_33,
          keys %{$alias_list{v0_22}},
          keys %{$alias_list{v0_33}},
      ],
  );
  
  for my $set (values %alias_list)
  {
      for my $alias (keys %$set)
      {
          no strict qw(refs);
          *$alias = __PACKAGE__->can($set->{$alias});
      }
  }
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      # import specific functions
  
      use List::MoreUtils qw(any uniq);
  
      if ( any { /foo/ } uniq @has_duplicates ) {
          # do stuff
      }
  
      # import everything
  
      use List::MoreUtils ':all';
  
      # import by API
  
      # has "original" any/all/none/notall behavior
      use List::MoreUtils ':like_0.22';
      # 0.22 + bsearch
      use List::MoreUtils ':like_0.24';
      # has "simplified" any/all/none/notall behavior + (n)sort_by
      use List::MoreUtils ':like_0.33';
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =head1 EXPORTS
  
  =head2 Default behavior
  
  Nothing by default. To import all of this module's symbols use the C<:all> tag.
  Otherwise functions can be imported by name as usual:
  
      use List::MoreUtils ':all';
  
      use List::MoreUtils qw{ any firstidx };
  
  Because historical changes to the API might make upgrading List::MoreUtils
  difficult for some projects, the legacy API is available via special import
  tags.
  
  =head2 Like version 0.22 (last release with original API)
  
  This API was available from 2006 to 2009, returning undef for empty lists on
  C<all>/C<any>/C<none>/C<notall>:
  
      use List::MoreUtils ':like_0.22';
  
  This import tag will import all functions available as of version 0.22.
  However, it will import C<any_u> as C<any>, C<all_u> as C<all>, C<none_u> as
  C<none>, and C<notall_u> as C<notall>.
  
  =head2 Like version 0.24 (first incompatible change)
  
  This API was available from 2010 to 2011.  It changed the return value of C<none>
  and added the C<bsearch> function.
  
      use List::MoreUtils ':like_0.24';
  
  This import tag will import all functions available as of version 0.24.
  However it will import C<any_u> as C<any>, C<all_u> as C<all>, and
  C<notall_u> as C<notall>.  It will import C<none> as described in
  the documentation below (true for empty list).
  
  =head2 Like version 0.33 (second incompatible change)
  
  This API was available from 2011 to 2014. It is widely used in several CPAN
  modules and thus it's closest to the current API.  It changed the return values
  of C<any>, C<all>, and C<notall>.  It added the C<sort_by> and C<nsort_by> functions
  and the C<distinct> alias for C<uniq>.  It omitted C<bsearch>.
  
      use List::MoreUtils ':like_0.33';
  
  This import tag will import all functions available as of version 0.33.  Note:
  it will not import C<bsearch> for consistency with the 0.33 API.
  
  =head1 FUNCTIONS
  
  =head2 Junctions
  
  =head3 I<Treatment of an empty list>
  
  There are two schools of thought for how to evaluate a junction on an
  empty list:
  
  =over
  
  =item *
  
  Reduction to an identity (boolean)
  
  =item *
  
  Result is undefined (three-valued)
  
  =back
  
  In the first case, the result of the junction applied to the empty list is
  determined by a mathematical reduction to an identity depending on whether
  the underlying comparison is "or" or "and".  Conceptually:
  
                      "any are true"      "all are true"
                      --------------      --------------
      2 elements:     A || B || 0         A && B && 1
      1 element:      A || 0              A && 1
      0 elements:     0                   1
  
  In the second case, three-value logic is desired, in which a junction
  applied to an empty list returns C<undef> rather than true or false 
  
  Junctions with a C<_u> suffix implement three-valued logic.  Those
  without are boolean.
  
  =head3 all BLOCK LIST
  
  =head3 all_u BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "All values are non-negative"
      if all { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<all> returns true (i.e. no values failed the condition)
  and C<all_u> returns C<undef>.
  
  Thus, C<< all_u(@list) >> is equivalent to C<< @list ? all(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<all_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 any BLOCK LIST
  
  =head3 any_u BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "At least one non-negative value"
      if any { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<any> returns false and C<any_u> returns C<undef>.
  
  Thus, C<< any_u(@list) >> is equivalent to C<< @list ? any(@list) : undef >>.
  
  =head3 none BLOCK LIST
  
  =head3 none_u BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "No non-negative values"
      if none { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<none> returns true (i.e. no values failed the condition)
  and C<none_u> returns C<undef>.
  
  Thus, C<< none_u(@list) >> is equivalent to C<< @list ? none(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<none_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 notall BLOCK LIST
  
  =head3 notall_u BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
    print "Not all values are non-negative"
      if notall { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<notall> returns false and C<notall_u> returns C<undef>.
  
  Thus, C<< notall_u(@list) >> is equivalent to C<< @list ? notall(@list) : undef >>.
  
  =head3 one BLOCK LIST
  
  =head3 one_u BLOCK LIST
  
  Returns a true value if precisely one item in LIST meets the criterion
  given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "Precisely one value defined"
          if one { defined($_) } @list;
  
  Returns false otherwise.
  
  For an empty LIST, C<one> returns false and C<one_u> returns C<undef>.
  
  The expression C<one BLOCK LIST> is almost equivalent to
  C<1 == true BLOCK LIST>, except for short-cutting.
  Evaluation of BLOCK will immediately stop at the second true value.
  
  =head2 Transformation
  
  =head3 apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
    my @list = (1 .. 4);
    my @mult = apply { $_ *= 2 } @list;
    print "\@list = @list\n";
    print "\@mult = @mult\n";
    __END__
    @list = 1 2 3 4
    @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
    for (my @mult = @list) { $_ *= 2 }
  
  =head3 insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
    my @list = qw/This is a list/;
    insert_after { $_ eq "a" } "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
    my @list = qw/This is a list/;
    insert_after_string "a", "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
    @a = (1 .. 5);
    @b = (11 .. 15);
    @x = pairwise { $a + $b } @a, @b;     # returns 12, 14, 16, 18, 20
  
    # mesh with pairwise
    @a = qw/a b c/;
    @b = qw/1 2 3/;
    @x = pairwise { ($a, $b) } @a, @b;    # returns a, 1, b, 2, c, 3
  
  =head3 mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =head3 zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = mesh @x, @y;         # returns a, 1, b, 2, c, 3, d, 4
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =head3 zip6
  
  =head3 zip_unflatten
  
  Returns a list of arrays consisting of the first elements of each array,
  then the second, then the third, etc, until all arrays are exhausted.
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = zip6 @x, @y;         # returns [a, 1], [b, 2], [c, 3], [d, 4]
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = zip6 @a, @b, @c;     # [x, 1, zip], [undef, 2, zap], [undef, undef, zot]
  
  C<zip_unflatten> is an alias for C<zip6>.
  
  =head3 listcmp ARRAY0 ARRAY1 [ ARRAY2 ... ]
  
  Returns an associative list of elements and every I<id> of the list it
  was found in. Allowes easy implementation of @a & @b, @a | @b, @a ^ @b and
  so on.
  Undefined entries in any given array are skipped.
  
    my @a = qw(one two three four five six seven eight nine ten eleven twelve thirteen);
    my @b = qw(two three five seven eleven thirteen seventeen);
    my @c = qw(one one two three five eight thirteen twentyone);
    my %cmp = listcmp @a, @b, @c; # returns (one => [0, 2], two => [0, 1, 2], three => [0, 1, 2], four => [0], ...)
  
    my @seq = (1, 2, 3);
    my @prim = (undef, 2, 3, 5);
    my @fib = (1, 1, 2);
    my $cmp = listcmp @seq, @prim, @fib;
    # returns { 1 => [0, 2], 2 => [0, 1, 2], 3 => [0, 1], 5 => [1] }
  
  =head3 arrayify LIST[,LIST[,LIST...]]
  
  Returns a list costisting of each element of given arrays. Recursive arrays
  are flattened, too.
  
    @a = (1, [[2], 3], 4, [5], 6, [7], 8, 9);
    @l = arrayify @a;         # returns 1, 2, 3, 4, 5, 6, 7, 8, 9
  
  =head3 uniq LIST
  
  =head3 distinct LIST
  
  Returns a new list by stripping duplicate values in LIST by comparing
  the values as hash keys, except that undef is considered separate from ''.
  The order of elements in the returned list is the same as in LIST. In
  scalar context, returns the number of unique elements in LIST.
  
    my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
    my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
    # returns "Mike", "Michael", "Richard", "Rick"
    my @n = distinct "Mike", "Michael", "Richard", "Rick", "Michael", "Rick"
    # returns "A8", "", undef, "A5", "S1"
    my @s = distinct "A8", "", undef, "A5", "S1", "A5", "A8"
    # returns "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C"
    my @w = uniq "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C", "Giulietta", "Giulia"
  
  C<distinct> is an alias for C<uniq>.
  
  B<RT#49800> can be used to give feedback about this behavior.
  
  =head3 singleton LIST
  
  Returns a new list by stripping values in LIST occurring more than once by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @x = singleton 1,1,2,2,3,4,5 # returns 3 4 5
  
  =head3 duplicates LIST
  
  Returns a new list by stripping values in LIST occuring less than twice by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @y = duplicates 1,1,2,4,7,2,3,4,6,9; #returns 1,2,4
  
  =head3 frequency LIST
  
  Returns an associative list of distinct values and the corresponding frequency.
  
    my @f = frequency values %radio_nrw; # returns (
    #  'Deutschlandfunk (DLF)' => 9, 'WDR 3' => 10,
    #  'WDR 4' => 11, 'WDR 5' => 14, 'WDR Eins Live' => 14,
    #  'Deutschlandradio Kultur' => 8,...)
  
  =head3 occurrences LIST
  
  Returns a new list of frequencies and the corresponding values from LIST.
  
    my @o = occurrences ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4);
    #  @o = (undef, undef, [3, 5], [1], [2, 6], undef, undef, [4]);
  
  =head3 mode LIST
  
  Returns the modal value of LIST. In scalar context, just the modal value
  is returned, in list context all probes occuring I<modal> times are returned,
  too.
  
    my @m = mode ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4, (7) x 3, (8) x 7);
    #  @m = (7, 4, 8) - bimodal LIST
  
  =head2 Partitioning
  
  =head3 after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
    @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =head3 after_incl BLOCK LIST
  
  Same as C<after> but also includes the element for which BLOCK is true.
  
  =head3 before BLOCK LIST
  
  Returns a list of values of LIST up to (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =head3 before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =head3 part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
    my $i = 0;
    my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
    my @part = part { 2 } 1 .. 10;            # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
    my @part = part { -1 } 1 .. 10;
    __END__
    Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
    my @idx  = ( 0, 1, -1 );
    my $i    = 0;
    my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =head3 samples COUNT LIST
  
  Returns a new list containing COUNT random samples from LIST. Is similar to
  L<List::Util/shuffle>, but stops after COUNT.
  
    @r  = samples 10, 1..10; # same as shuffle
    @r2 = samples 5, 1..10; # gives 5 values from 1..10;
  
  =head2 Iteration
  
  =head3 each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
    my $ea = each_array(@a, @b, @c);
    while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it returns
  the index of the last fetched set of values, as a scalar.
  
  =head3 each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =head3 natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
    my @x = ('a' .. 'g');
    my $it = natatime 3, @x;
    while (my @vals = $it->())
    {
      print "@vals\n";
    }
  
  This prints
  
    a b c
    d e f
    g
  
  =head2 Searching
  
  =head3 firstval BLOCK LIST
  
  =head3 first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_value> is an alias for C<firstval>.
  
  =head3 onlyval BLOCK LIST
  
  =head3 only_value BLOCK LIST
  
  Returns the only element in LIST for which BLOCK evaluates to true. Sets
  C<$_> for each item in LIST in turn. Returns C<undef> if no such element
  has been found.
  
  C<only_value> is an alias for C<onlyval>.
  
  =head3 lastval BLOCK LIST
  
  =head3 last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_value> is an alias for C<lastval>.
  
  =head3 firstres BLOCK LIST
  
  =head3 first_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<first_result> is an alias for C<firstres>.
  
  =head3 onlyres BLOCK LIST
  
  =head3 only_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Sets C<$_> for each item in LIST in turn. Returns
  C<undef> if no such element has been found.
  
  C<only_result> is an alias for C<onlyres>.
  
  =head3 lastres BLOCK LIST
  
  =head3 last_result BLOCK LIST
  
  Returns the result of BLOCK for the last element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<last_result> is an alias for C<lastres>.
  
  =head3 indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
    @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =head3 firstidx BLOCK LIST
  
  =head3 first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
    __END__
    item with index 1 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =head3 onlyidx BLOCK LIST
  
  =head3 only_index BLOCK LIST
  
  Returns the index of the only element in LIST for which the criterion
  in BLOCK is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 3, 4, 3, 2, 4);
      printf "uniqe index of item 2 in list is %i", onlyidx { $_ == 2 } @list;
      __END__
      unique index of item 2 in list is 4
  
  Returns C<-1> if either no such item or more than one of these
  has been found.
  
  C<only_index> is an alias for C<onlyidx>.
  
  =head3 lastidx BLOCK LIST
  
  =head3 last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
    __END__
    item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =head2 Sorting
  
  =head3 sort_by BLOCK LIST
  
  Returns the list of values sorted according to the string values returned by the
  KEYFUNC block or function. A typical use of this may be to sort objects according
  to the string value of some accessor, such as
  
    sort_by { $_->name } @people
  
  The key function is called in scalar context, being passed each value in turn as
  both $_ and the only argument in the parameters, @_. The values are then sorted
  according to string comparisons on the values returned.
  This is equivalent to
  
    sort { $a->name cmp $b->name } @people
  
  except that it guarantees the name accessor will be executed only once per value.
  One interesting use-case is to sort strings which may have numbers embedded in them
  "naturally", rather than lexically.
  
    sort_by { s/(\d+)/sprintf "%09d", $1/eg; $_ } @strings
  
  This sorts strings by generating sort keys which zero-pad the embedded numbers to
  some level (9 digits in this case), helping to ensure the lexical sort puts them
  in the correct order.
  
  =head3 nsort_by BLOCK LIST
  
  Similar to sort_by but compares its key values numerically.
  
  =head3 qsort BLOCK ARRAY
  
  This sorts the given array B<in place> using the given compare code. Except for
  tiny compare code like C<< $a <=> $b >>, qsort is much faster than Perl's C<sort>
  depending on the version.
  
  Compared 5.8 and 5.26:
  
    my @rl;
    for(my $i = 0; $i < 1E6; ++$i) { push @rl, rand(1E5) }
    my $idx;
  
    sub ext_cmp { $_[0] <=> $_[1] }
  
    cmpthese( -60, {
        'qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($a, $b) } @qrl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @qrl
        },
        'reverse qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($b, $a) } @qrl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @qrl
        },
        'sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($a, $b) } @srl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @srl
        },
        'reverse sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($b, $a) } @srl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @srl
        },
    });
  
  5.8 results
  
  		  s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    6.21            --           -0%           -8%          -10%
    sort            6.19            0%            --           -7%          -10%
    reverse qsort   5.73            8%            8%            --           -2%
    qsort           5.60           11%           11%            2%            --
  
  5.26 results
  
  		s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    4.54            --           -0%          -96%          -96%
    sort            4.52            0%            --          -96%          -96%
    reverse qsort  0.203         2139%         2131%            --          -19%
    qsort          0.164         2666%         2656%           24%            --
  
  Use it where external data sources might have to be compared (think of L<Unix::Statgrab>
  "tables").
  
  C<qsort> is available from List::MoreUtils::XS only. It's insane to maintain
  a wrapper around Perl's sort nor having a pure Perl implementation. One could
  create a flip-book in same speed as PP runs a qsort.
  
  =head2 Searching in sorted Lists
  
  =head3 bsearch BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns a boolean value in scalar context. In list context, it returns the element
  if it was found, otherwise the empty list.
  
  =head3 bsearchidx BLOCK LIST
  
  =head3 bsearch_index BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns the index of found element, otherwise C<-1>.
  
  C<bsearch_index> is an alias for C<bsearchidx>.
  
  =head3 lower_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<less than val>. Technically it's the first element in LIST which does
  not return a value below zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = lower_bound { $_ <=> 2 } @ids; # returns 2
    $lb = lower_bound { $_ <=> 4 } @ids; # returns 10
  
  lower_bound has a complexity of O(log n).
  
  =head3 upper_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<greater than val>. Technically it's the first element in LIST which does
  not return a value below or equal to zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = upper_bound { $_ <=> 2 } @ids; # returns 4
    $lb = upper_bound { $_ <=> 4 } @ids; # returns 14
  
  upper_bound has a complexity of O(log n).
  
  =head3 equal_range BLOCK LIST
  
  Returns a pair of indices containing the lower_bound and the upper_bound.
  
  =head2 Operations on sorted Lists
  
  =head3 binsert BLOCK ITEM LIST
  
  =head3 bsearch_insert BLOCK ITEM LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  ITEM is inserted at the index where the ITEM should be placed (based on above
  search). That means, it's inserted before the next bigger element.
  
    @l = (2,3,5,7);
    binsert { $_ <=> 4 }  4, @l; # @l = (2,3,4,5,7)
    binsert { $_ <=> 6 } 42, @l; # @l = (2,3,4,42,7)
  
  You take care that the inserted element matches the compare result.
  
  =head3 bremove BLOCK LIST
  
  =head3 bsearch_remove BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  The item at the found position is removed and returned.
  
    @l = (2,3,4,5,7);
    bremove { $_ <=> 4 }, @l; # @l = (2,3,5,7);
  
  =head2 Counting and calculation
  
  =head3 true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
    printf "%i item(s) are defined", true { defined($_) } @list;
  
  =head3 false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
    printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =head3 reduce_0 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 0.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_0 is B<summation> (addition of a sequence of numbers).
  
  =head3 reduce_1 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_1 is product of a sequence of numbers.
  
  =head3 reduce_u BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  This function has been added if one might need the extra of the index
  value but need an individual initialization.
  
  B<Use with caution>: In most cases L<List::Util/reduce> will do the
  job better.
  
  =head3 minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =head3 minmaxstr LIST
  
  Computes the minimum and maximum of LIST using string compare and returns a
  two element list with the first element being the minimum and the second the
  maximum. Returns the empty list if LIST was empty.
  
  The implementation is similar to C<minmax>.
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 MAINTENANCE
  
  The maintenance goal is to preserve the documented semantics of the API;
  bug fixes that bring actual behavior in line with semantics are allowed.
  New API functions may be added over time.  If a backwards incompatible
  change is unavoidable, we will attempt to provide support for the legacy
  API using the same export tag mechanism currently in place.
  
  This module attempts to use few non-core dependencies. Non-core
  configuration and testing modules will be bundled when reasonable;
  run-time dependencies will be added only if they deliver substantial
  benefit.
  
  =head1 CONTRIBUTING
  
  While contributions are appreciated, a contribution should not cause more
  effort for the maintainer than the contribution itself saves (see
  L<Open Source Contribution Etiquette|http://tirania.org/blog/archive/2010/Dec-31.html>).
  
  To get more familiar where help could be needed - see L<List::MoreUtils::Contributing>.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  You can find documentation for this module with the perldoc command.
  
      perldoc List::MoreUtils
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<https://rt.cpan.org/Dist/Display.html?Name=List-MoreUtils>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/List-MoreUtils>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/dist/List-MoreUtils>
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/List-MoreUtils>
  
  =item * CPAN Search
  
  L<http://search.cpan.org/dist/List-MoreUtils/>
  
  =item * Git Repository
  
  L<https://github.com/perl5-utils/List-MoreUtils>
  
  =back
  
  =head2 Where can I go for help?
  
  If you have a bug report, a patch or a suggestion, please open a new
  report ticket at CPAN (but please check previous reports first in case
  your issue has already been addressed) or open an issue on GitHub.
  
  Report tickets should contain a detailed description of the bug or
  enhancement request and at least an easily verifiable way of
  reproducing the issue or fix. Patches are always welcome, too - and
  it's cheap to send pull-requests on GitHub. Please keep in mind that
  code changes are more likely accepted when they're bundled with an
  approving test.
  
  If you think you've found a bug then please read
  "How to Report Bugs Effectively" by Simon Tatham:
  L<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
  
  =head2 Where can I go for help with a concrete version?
  
  Bugs and feature requests are accepted against the latest version
  only. To get patches for earlier versions, you need to get an
  agreement with a developer of your choice - who may or not report the
  issue and a suggested fix upstream (depends on the license you have
  chosen).
  
  =head2 Business support and maintenance
  
  Generally, in volunteered projects, there is no right for support.
  While every maintainer is happy to improve the provided software,
  spare time is limited.
  
  For those who have a use case which requires guaranteed support, one of
  the maintainers should be hired or contracted.  For business support you
  can contact Jens via his CPAN email address rehsackATcpan.org. Please
  keep in mind that business support is neither available for free nor
  are you eligible to receive any support based on the license distributed
  with this package.
  
  =head1 THANKS
  
  =head2 Tassilo von Parseval
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete.
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head2 Jens Rehsack
  
  Credits goes to all people contributing feedback during the v0.400
  development releases.
  
  Special thanks goes to David Golden who spent a lot of effort to develop
  a design to support current state of CPAN as well as ancient software
  somewhere in the dark. He also contributed a lot of patches to refactor
  the API frontend to welcome any user of List::MoreUtils - from ancient
  past to recently last used.
  
  Toby Inkster provided a lot of useful feedback for sane importer code
  and was a nice sounding board for API discussions.
  
  Peter Rabbitson provided a sane git repository setup containing entire
  package history.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>, L<List::AllUtils>, L<List::UtilsBy>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  our $VERSION = '0.428';
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils::PP - Provide List::MoreUtils pure Perl implementation
  
  =head1 SYNOPSIS
  
    BEGIN { $ENV{LIST_MOREUTILS_PP} = 1; }
    use List::MoreUtils qw(:all);
  
  =cut
  
  sub any (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 if $f->();
      }
      return 0;
  }
  
  sub all (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 unless $f->();
      }
      return 1;
  }
  
  sub none (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 if $f->();
      }
      return 1;
  }
  
  sub notall (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 unless $f->();
      }
      return 0;
  }
  
  sub one (&@)
  {
      my $f     = shift;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub any_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 1 foreach (@_);
      return 0;
  }
  
  sub all_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 0 foreach (@_);
      return 1;
  }
  
  sub none_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 0 foreach (@_);
      return 1;
  }
  
  sub notall_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 1 foreach (@_);
      return 0;
  }
  
  sub one_u (&@)
  {
      my $f = shift;
      return if !@_;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub reduce_u(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \();
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_0(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \0;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_1(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \1;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub true (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() and ++$count foreach (@_);
      return $count;
  }
  
  sub false (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() or ++$count foreach (@_);
      return $count;
  }
  
  sub firstidx (&@)
  {
      my $f = shift;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub firstval (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub firstres (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          my $testval = $test->();
          $testval and return $testval;
      }
      return undef;
  }
  
  sub onlyidx (&@)
  {
      my $f = shift;
      my $found;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          $f->() or next;
          defined $found and return -1;
          $found = $i;
      }
      return defined $found ? $found : -1;
  }
  
  sub onlyval (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          $test->() or next;
          $result = $_;
          $found++ and return undef;
      }
      return $result;
  }
  
  sub onlyres (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          my $rv = $test->() or next;
          $result = $rv;
          $found++ and return undef;
      }
      return $found ? $result : undef;
  }
  
  sub lastidx (&@)
  {
      my $f = shift;
      foreach my $i (reverse 0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastval (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub lastres (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $testval if $testval;
      }
      return undef;
  }
  
  sub insert_after (&$\@)
  {
      my ($f, $val, $list) = @_;
      my $c = &firstidx($f, @$list);
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@)
  {
      my ($string, $val, $list) = @_;
      my $c = firstidx { defined $_ and $string eq $_ } @$list;
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@)
  {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@)
  {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do
      {
          my $x = $lag;
          $lag = $test->();
          $x;
      }, @_;
  }
  
  sub after_incl (&@)
  {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@)
  {
      my $test = shift;
      my $more = 1;
      grep $more &&= !$test->(), @_;
  }
  
  sub before_incl (&@)
  {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do
      {
          my $x = $lag;
          $lag = !$test->();
          $x;
      }, @_;
  }
  
  sub indexes (&@)
  {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub pairwise (&\@\@)
  {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local (*A, *B) = @_;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B ? $#A : $#B;
  
      # This map expression is also the return value
      local (*$caller_a, *$caller_b);
      map {
          # Assign to $a, $b as refs to caller's array elements
          (*$caller_a, *$caller_b) = \($#A < $_ ? undef : $A[$_], $#B < $_ ? undef : $B[$_]);
  
          # Perform the transformation
          $op->();
      } 0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      return each_arrayref(@_);
  }
  
  sub each_arrayref
  {
      my @list  = @_;    # The list of references to the arrays
      my $index = 0;     # Which one the caller will get next
      my $max   = 0;     # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach (@list)
      {
          unless (ref $_ eq 'ARRAY')
          {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if (@_)
          {
              my $method = shift;
              unless ($method eq 'index')
              {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0 || $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list;
        }
  }
  
  sub natatime ($@)
  {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
        }
  }
  
  # "leaks" when lexically hidden in arrayify
  my $flatten;
  $flatten = sub {
      map { (ref $_ and ("ARRAY" eq ref $_ or overload::Method($_, '@{}'))) ? ($flatten->(@{$_})) : ($_) } @_;
  };
  
  sub arrayify
  {
      map { $flatten->($_) } @_;
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max;
  }
  
  sub zip6 (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          [map $_->[$ix], @_];
      } 0 .. $max;
  }
  
  sub listcmp (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my %ret;
      for (my $i = 0; $i < scalar @_; ++$i)
      {
          my %seen;
          my $k;
          foreach my $w (grep { defined $_ and not $seen{$k = $_}++ } @{$_[$i]})
          {
              $ret{$w} ||= [];
              push @{$ret{$w}}, $i;
          }
      }
      %ret;
  }
  
  sub uniq (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub singleton (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 == (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub duplicates (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 < (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub frequency (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my %h = map { defined $_ ? ($_ => $seen{$k = $_}) : () }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
      wantarray or return (scalar keys %h) + ($seen_undef ? 1 : 0);
      undef $k;
      (%h, $seen_undef ? (\$k => $seen_undef) : ());
  }
  
  sub occurrences (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my @ret;
      foreach my $l (map { $_ } grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_)
      {
          my $n = defined $l ? $seen{$l} : $seen_undef;
          defined $ret[$n] or $ret[$n] = [];
          push @{$ret[$n]}, $l;
      }
      @ret;
  }
  
  sub mode (@)
  {
      my %seen = ();
      my ($max, $k, $seen_undef) = (1);
  
      foreach (@_) { defined $_ ? ($max < ++$seen{$k = $_} and ++$max) : ($max < ++$seen_undef and ++$max) }
      wantarray or return $max;
  
      my @ret = ($max);
      foreach my $l (grep { $seen{$_} == $max } keys %seen)
      {
          push @ret, $l;
      }
      $seen_undef and $seen_undef == $max and push @ret, undef;
      @ret;
  }
  
  sub samples ($@)
  {
      my $n = shift;
      if ($n > @_)
      {
          require Carp;
          Carp::croak(sprintf("Cannot get %d samples from %d elements", $n, scalar @_));
      }
  
      for (my $i = @_; @_ - $i > $n;)
      {
          my $idx  = @_ - $i;
          my $swp  = $idx + int(rand(--$i));
          my $xchg = $_[$swp];
          $_[$swp] = $_[$idx];
          $_[$idx] = $xchg;
      }
  
      return splice @_, 0, $n;
  }
  
  sub minmax (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub minmaxstr (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@)
  {
      my ($code, @list) = @_;
      my @parts;
      push @{$parts[$code->($_)]}, $_ foreach @list;
      return @parts;
  }
  
  sub bsearch(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0
            and return wantarray ? $_ : 1;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return;
  }
  
  sub bsearchidx(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return -1;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0 and return $k;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return -1;
  }
  
  sub lower_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() < 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub upper_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() <= 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub equal_range(&@)
  {
      my $lb = &lower_bound(@_);
      my $ub = &upper_bound(@_);
      ($lb, $ub);
  }
  
  sub binsert (&$\@)
  {
      my $lb = &lower_bound($_[0], @{$_[2]});
      splice @{$_[2]}, $lb, 0, $_[1];
      $lb;
  }
  
  sub bremove (&\@)
  {
      my $lb = &lower_bound($_[0], @{$_[1]});
      splice @{$_[1]}, $lb, 1;
  }
  
  sub qsort(&\@)
  {
      require Carp;
      Carp::croak("It's insane to use a pure-perl qsort");
  }
  
  sub sort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] cmp $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub nsort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] <=> $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub _XScompiled { 0 }
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS_PP

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;
  
  # See POD at end for documentation
  
  use 5.006;
  use strict;
  
  # Set the version for CPAN
  use vars qw{$VERSION $XS_COMPATIBLE @XS_EXCLUDE};
  BEGIN {
  	$VERSION       = '1.236';
  	$XS_COMPATIBLE = '0.845';
  	@XS_EXCLUDE    = ();
  }
  
  # Load everything
  use PPI::Util                 ();
  use PPI::Exception            ();
  use PPI::Element              ();
  use PPI::Token                ();
  use PPI::Statement            ();
  use PPI::Structure            ();
  use PPI::Document             ();
  use PPI::Document::File       ();
  use PPI::Document::Fragment   ();
  use PPI::Document::Normalized ();
  use PPI::Normal               ();
  use PPI::Tokenizer            ();
  use PPI::Lexer                ();
  
  # If it is installed, load in PPI::XS
  die
    if !$PPI::XS_DISABLE
    and !eval { require PPI::XS; 1 }
    and $@ !~ /^Can't locate .*? at /;    # ignore failure to load if not installed
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  PPI - Parse, Analyze and Manipulate Perl (without perl)
  
  =head1 SYNOPSIS
  
    use PPI;
    
    # Create a new empty document
    my $Document = PPI::Document->new;
    
    # Create a document from source
    $Document = PPI::Document->new(\'print "Hello World!\n"');
    
    # Load a Document from a file
    $Document = PPI::Document->new('Module.pm');
    
    # Does it contain any POD?
    if ( $Document->find_any('PPI::Token::Pod') ) {
        print "Module contains POD\n";
    }
    
    # Get the name of the main package
    $pkg = $Document->find_first('PPI::Statement::Package')->namespace;
    
    # Remove all that nasty documentation
    $Document->prune('PPI::Token::Pod');
    $Document->prune('PPI::Token::Comment');
    
    # Save the file
    $Document->save('Module.pm.stripped');
  
  =head1 DESCRIPTION
  
  =head2 About this Document
  
  This is the PPI manual. It describes its reason for existing, its general
  structure, its use, an overview of the API, and provides a few
  implementation samples.
  
  =head2 Background
  
  The ability to read, and manipulate Perl (the language) programmatically
  other than with perl (the application) was one that caused difficulty
  for a long time.
  
  The cause of this problem was Perl's complex and dynamic grammar.
  Although there is typically not a huge diversity in the grammar of most
  Perl code, certain issues cause large problems when it comes to parsing.
  
  Indeed, quite early in Perl's history Tom Christiansen introduced the Perl
  community to the quote I<"Nothing but perl can parse Perl">, or as it is
  more often stated now as a truism:
  
  B<"Only perl can parse Perl">
  
  One example of the sorts of things the prevent Perl being easily parsed are
  function signatures, as demonstrated by the following.
  
    @result = (dothis $foo, $bar);
    
    # Which of the following is it equivalent to?
    @result = (dothis($foo), $bar);
    @result = dothis($foo, $bar);
  
  The first line above can be interpreted in two different ways, depending
  on whether the C<&dothis> function is expecting one argument, or two,
  or several.
  
  A "code parser" (something that parses for the purpose of execution) such
  as perl needs information that is not found in the immediate vicinity of
  the statement being parsed.
  
  The information might not just be elsewhere in the file, it might not even be
  in the same file at all. It might also not be able to determine this
  information without the prior execution of a C<BEGIN {}> block, or the
  loading and execution of one or more external modules. Or worse the &dothis
  function may not even have been written yet.
  
  B<When parsing Perl as code, you must also execute it>
  
  Even perl itself never really fully understands the structure of the source
  code after and indeed B<as> it processes it, and in that sense doesn't
  "parse" Perl source into anything remotely like a structured document.
  This makes it of no real use for any task that needs to treat the source
  code as a document, and do so reliably and robustly.
  
  For more information on why it is impossible to parse perl, see Randal
  Schwartz's seminal response to the question of "Why can't you parse Perl".
  
  L<http://www.perlmonks.org/index.pl?node_id=44722>
  
  The purpose of PPI is B<not> to parse Perl I<Code>, but to parse Perl
  I<Documents>. By treating the problem this way, we are able to parse a
  single file containing Perl source code "isolated" from any other
  resources, such as libraries upon which the code may depend, and
  without needing to run an instance of perl alongside or inside the parser.
  
  Historically, using an embedded perl parser was widely considered to be
  the most likely avenue for finding a solution to parsing Perl. It has been
  investigated from time to time, but attempts have generally failed or
  suffered from sufficiently bad corner cases that they were abandoned.
  
  =head2 What Does PPI Stand For?
  
  C<PPI> is an acronym for the longer original module name
  C<Parse::Perl::Isolated>. And in the spirit or the silly acronym games
  played by certain unnamed Open Source projects you may have I<hurd> of,
  it also a reverse backronym of "I Parse Perl".
  
  Of course, I could just be lying and have just made that second bit up
  10 minutes before the release of PPI 1.000. Besides, B<all> the cool
  Perl packages have TLAs (Three Letter Acronyms). It's a rule or something.
  
  Why don't you just think of it as the B<Perl Parsing Interface> for simplicity.
  
  The original name was shortened to prevent the author (and you the users)
  from contracting RSI by having to type crazy things like
  C<Parse::Perl::Isolated::Token::QuoteLike::Backtick> 100 times a day.
  
  In acknowledgment that someone may some day come up with a valid solution
  for the grammar problem it was decided at the commencement of the project
  to leave the C<Parse::Perl> namespace free for any such effort.
  
  Since that time I've been able to prove to my own satisfaction that it
  B<is> truly impossible to accurately parse Perl as both code and document
  at once. For the academics, parsing Perl suffers from the "Halting Problem".
  
  =head2 Why Parse Perl?
  
  Once you can accept that we will never be able to parse Perl well enough
  to meet the standards of things that treat Perl as code, it is worth
  re-examining C<why> we want to "parse" Perl at all.
  
  What are the things that people might want a "Perl parser" for.
  
  =over 4
  
  =item Documentation
  
  Analyzing the contents of a Perl document to automatically generate
  documentation, in parallel to, or as a replacement for, POD documentation.
  
  Allow an indexer to locate and process all the comments and
  documentation from code for "full text search" applications.
  
  =item Structural and Quality Analysis
  
  Determine quality or other metrics across a body of code, and identify
  situations relating to particular phrases, techniques or locations.
  
  Index functions, variables and packages within Perl code, and doing search
  and graph (in the node/edge sense) analysis of large code bases.
  
  L<Perl::Critic>, based on PPI, is a large, thriving tool for bug detection
  and style analysis of Perl code.
  
  =item Refactoring
  
  Make structural, syntax, or other changes to code in an automated manner,
  either independently or in assistance to an editor. This sort of task list
  includes backporting, forward porting, partial evaluation, "improving" code,
  or whatever. All the sort of things you'd want from a L<Perl::Editor>.
  
  =item Layout
  
  Change the layout of code without changing its meaning. This includes
  techniques such as tidying (like L<perltidy>), obfuscation, compressing and
  "squishing", or to implement formatting preferences or policies.
  
  =item Presentation
  
  This includes methods of improving the presentation of code, without changing
  the content of the code. Modify, improve, syntax colour etc the presentation
  of a Perl document. Generating "IntelliText"-like functions.
  
  =back
  
  If we treat this as a baseline for the sort of things we are going to have
  to build on top of Perl, then it becomes possible to identify a standard
  for how good a Perl parser needs to be.
  
  =head2 How good is Good Enough(TM)
  
  PPI seeks to be good enough to achieve all of the above tasks, or to provide
  a sufficiently good API on which to allow others to implement modules in
  these and related areas.
  
  However, there are going to be limits to this process. Because PPI cannot
  adapt to changing grammars, any code written using source filters should not
  be assumed to be parsable.
  
  At one extreme, this includes anything munged by L<Acme::Bleach>, as well
  as (arguably) more common cases like L<Switch>. We do not pretend to be
  able to always parse code using these modules, although as long as it still
  follows a format that looks like Perl syntax, it may be possible to extend
  the lexer to handle them.
  
  The ability to extend PPI to handle lexical additions to the language is on
  the drawing board to be done some time post-1.0
  
  The goal for success was originally to be able to successfully parse 99% of
  all Perl documents contained in CPAN. This means the entire file in each
  case.
  
  PPI has succeeded in this goal far beyond the expectations of even the
  author. At time of writing there are only 28 non-Acme Perl modules in CPAN
  that PPI is incapable of parsing. Most of these are so badly broken they
  do not compile as Perl code anyway.
  
  So unless you are actively going out of your way to break PPI, you should
  expect that it will handle your code just fine.
  
  =head2 Internationalisation
  
  PPI provides partial support for internationalisation and localisation.
  
  Specifically, it allows the use characters from the Latin-1 character
  set to be used in quotes, comments, and POD. Primarily, this covers
  languages from Europe and South America.
  
  PPI does B<not> currently provide support for Unicode.
  If you need Unicode support and would like to help,
  contact the author. (contact details below)
  
  =head2 Round Trip Safe
  
  When PPI parses a file it builds B<everything> into the model, including
  whitespace. This is needed in order to make the Document fully "Round Trip"
  safe.
  
  The general concept behind a "Round Trip" parser is that it knows what it
  is parsing is somewhat uncertain, and so B<expects> to get things wrong
  from time to time. In the cases where it parses code wrongly the tree
  will serialize back out to the same string of code that was read in,
  repairing the parser's mistake as it heads back out to the file.
  
  The end result is that if you parse in a file and serialize it back out
  without changing the tree, you are guaranteed to get the same file you
  started with. PPI does this correctly and reliably for 100% of all known
  cases.
  
  B<What goes in, will come out. Every time.>
  
  The one minor exception at this time is that if the newlines for your file
  are wrong (meaning not matching the platform newline format), PPI will
  localise them for you. (It isn't to be convenient, supporting
  arbitrary newlines would make some of the code more complicated)
  
  Better control of the newline type is on the wish list though, and
  anyone wanting to help out is encouraged to contact the author.
  
  =head1 IMPLEMENTATION
  
  =head2 General Layout
  
  PPI is built upon two primary "parsing" components, L<PPI::Tokenizer>
  and L<PPI::Lexer>, and a large tree of about 50 classes which implement
  the various the I<Perl Document Object Model> (PDOM).
  
  The PDOM is conceptually similar in style and intent to the regular DOM or
  other code Abstract Syntax Trees (ASTs), but contains some differences
  to handle perl-specific cases, and to assist in treating the code as a
  document. Please note that it is B<not> an implementation of the official
  Document Object Model specification, only somewhat similar to it.
  
  On top of the Tokenizer, Lexer and the classes of the PDOM, sit a number
  of classes intended to make life a little easier when dealing with PDOM
  trees.
  
  Both the major parsing components were hand-coded from scratch with only
  plain Perl code and a few small utility modules. There are no grammar or
  patterns mini-languages, no YACC or LEX style tools and only a small number
  of regular expressions.
  
  This is primarily because of the sheer volume of accumulated cruft that
  exists in Perl. Not even perl itself is capable of parsing Perl documents
  (remember, it just parses and executes it as code).
  
  As a result, PPI needed to be cruftier than perl itself. Feel free to
  shudder at this point, and hope you never have to understand the Tokenizer
  codebase. Speaking of which...
  
  =head2 The Tokenizer
  
  The Tokenizer takes source code and converts it into a series of tokens. It
  does this using a slow but thorough character by character manual process,
  rather than using a pattern system or complex regexes.
  
  Or at least it does so conceptually. If you were to actually trace the code
  you would find it's not truly character by character due to a number of
  regexps and optimisations throughout the code. This lets the Tokenizer
  "skip ahead" when it can find shortcuts, so it tends to jump around a line
  a bit wildly at times.
  
  In practice, the number of times the Tokenizer will B<actually> move the
  character cursor itself is only about 5% - 10% higher than the number of
  tokens contained in the file. This makes it about as optimal as it can be
  made without implementing it in something other than Perl.
  
  In 2001 when PPI was started, this structure made PPI quite slow, and not
  really suitable for interactive tasks. This situation has improved greatly
  with multi-gigahertz processors, but can still be painful when working with
  very large files.
  
  The target parsing rate for PPI is about 5000 lines per gigacycle. It is
  currently believed to be at about 1500, and main avenue for making it to
  the target speed has now become L<PPI::XS>, a drop-in XS accelerator for
  PPI.
  
  Since L<PPI::XS> has only just gotten off the ground and is currently only
  at proof-of-concept stage, this may take a little while. Anyone interested
  in helping out with L<PPI::XS> is B<highly> encouraged to contact the
  author. In fact, the design of L<PPI::XS> means it's possible to port
  one function at a time safely and reliably. So every little bit will help.
  
  =head2 The Lexer
  
  The Lexer takes a token stream, and converts it to a lexical tree. Because
  we are parsing Perl B<documents> this includes whitespace, comments, and
  all number of weird things that have no relevance when code is actually
  executed.
  
  An instantiated L<PPI::Lexer> consumes L<PPI::Tokenizer> objects and
  produces L<PPI::Document> objects. However you should probably never be
  working with the Lexer directly. You should just be able to create
  L<PPI::Document> objects and work with them directly.
  
  =head2 The Perl Document Object Model
  
  The PDOM is a structured collection of data classes that together provide
  a correct and scalable model for documents that follow the standard Perl
  syntax.
  
  =head2 The PDOM Class Tree
  
  The following lists all of the 67 current PDOM classes, listing with indentation
  based on inheritance.
  
     PPI::Element
        PPI::Node
           PPI::Document
              PPI::Document::Fragment
           PPI::Statement
              PPI::Statement::Package
              PPI::Statement::Include
              PPI::Statement::Sub
                 PPI::Statement::Scheduled
              PPI::Statement::Compound
              PPI::Statement::Break
              PPI::Statement::Given
              PPI::Statement::When
              PPI::Statement::Data
              PPI::Statement::End
              PPI::Statement::Expression
                 PPI::Statement::Variable
              PPI::Statement::Null
              PPI::Statement::UnmatchedBrace
              PPI::Statement::Unknown
           PPI::Structure
              PPI::Structure::Block
              PPI::Structure::Subscript
              PPI::Structure::Constructor
              PPI::Structure::Condition
              PPI::Structure::List
              PPI::Structure::For
              PPI::Structure::Given
              PPI::Structure::When
              PPI::Structure::Unknown
        PPI::Token
           PPI::Token::Whitespace
           PPI::Token::Comment
           PPI::Token::Pod
           PPI::Token::Number
              PPI::Token::Number::Binary
              PPI::Token::Number::Octal
              PPI::Token::Number::Hex
              PPI::Token::Number::Float
                 PPI::Token::Number::Exp
              PPI::Token::Number::Version
           PPI::Token::Word
           PPI::Token::DashedWord
           PPI::Token::Symbol
              PPI::Token::Magic
           PPI::Token::ArrayIndex
           PPI::Token::Operator
           PPI::Token::Quote
              PPI::Token::Quote::Single
              PPI::Token::Quote::Double
              PPI::Token::Quote::Literal
              PPI::Token::Quote::Interpolate
           PPI::Token::QuoteLike
              PPI::Token::QuoteLike::Backtick
              PPI::Token::QuoteLike::Command
              PPI::Token::QuoteLike::Regexp
              PPI::Token::QuoteLike::Words
              PPI::Token::QuoteLike::Readline
           PPI::Token::Regexp
              PPI::Token::Regexp::Match
              PPI::Token::Regexp::Substitute
              PPI::Token::Regexp::Transliterate
           PPI::Token::HereDoc
           PPI::Token::Cast
           PPI::Token::Structure
           PPI::Token::Label
           PPI::Token::Separator
           PPI::Token::Data
           PPI::Token::End
           PPI::Token::Prototype
           PPI::Token::Attribute
           PPI::Token::Unknown
  
  To summarize the above layout, all PDOM objects inherit from the
  L<PPI::Element> class.
  
  Under this are L<PPI::Token>, strings of content with a known type,
  and L<PPI::Node>, syntactically significant containers that hold other
  Elements.
  
  The three most important of these are the L<PPI::Document>, the
  L<PPI::Statement> and the L<PPI::Structure> classes.
  
  =head2 The Document, Statement and Structure
  
  At the top of all complete PDOM trees is a L<PPI::Document> object. It
  represents a complete file of Perl source code as you might find it on
  disk.
  
  There are some specialised types of document, such as L<PPI::Document::File>
  and L<PPI::Document::Normalized> but for the purposes of the PDOM they are
  all just considered to be the same thing.
  
  Each Document will contain a number of B<Statements>, B<Structures> and
  B<Tokens>.
  
  A L<PPI::Statement> is any series of Tokens and Structures that are treated
  as a single contiguous statement by perl itself. You should note that a
  Statement is as close as PPI can get to "parsing" the code in the sense that
  perl-itself parses Perl code when it is building the op-tree.
  
  Because of the isolation and Perl's syntax, it is provably impossible for
  PPI to accurately determine precedence of operators or which tokens are
  implicit arguments to a sub call.
  
  So rather than lead you on with a bad guess that has a strong chance of
  being wrong, PPI does not attempt to determine precedence or sub parameters
  at all.
  
  At a fundamental level, it only knows that this series of elements
  represents a single Statement as perl sees it, but it can do so with
  enough certainty that it can be trusted.
  
  However, for specific Statement types the PDOM is able to derive additional
  useful information about their meaning. For the best, most useful, and most
  heavily used example, see L<PPI::Statement::Include>.
  
  A L<PPI::Structure> is any series of tokens contained within matching braces.
  This includes code blocks, conditions, function argument braces, anonymous
  array and hash constructors, lists, scoping braces and all other syntactic
  structures represented by a matching pair of braces, including (although it
  may not seem obvious at first) C<E<lt>READLINEE<gt>> braces.
  
  Each Structure contains none, one, or many Tokens and Structures (the rules
  for which vary for the different Structure subclasses)
  
  Under the PDOM structure rules, a Statement can B<never> directly contain
  another child Statement, a Structure can B<never> directly contain another
  child Structure, and a Document can B<never> contain another Document
  anywhere in the tree.
  
  Aside from these three rules, the PDOM tree is extremely flexible.
  
  =head2 The PDOM at Work
  
  To demonstrate the PDOM in use lets start with an example showing how the
  tree might look for the following chunk of simple Perl code.
  
    #!/usr/bin/perl
  
    print( "Hello World!" );
  
    exit();
  
  Translated into a PDOM tree it would have the following structure (as shown
  via the included L<PPI::Dumper>).
  
    PPI::Document
      PPI::Token::Comment                '#!/usr/bin/perl\n'
      PPI::Token::Whitespace             '\n'
      PPI::Statement
        PPI::Token::Word                 'print'
        PPI::Structure::List             ( ... )
          PPI::Token::Whitespace         ' '
          PPI::Statement::Expression
            PPI::Token::Quote::Double    '"Hello World!"'
          PPI::Token::Whitespace         ' '
        PPI::Token::Structure            ';'
      PPI::Token::Whitespace             '\n'
      PPI::Token::Whitespace             '\n'
      PPI::Statement
        PPI::Token::Word                 'exit'
        PPI::Structure::List             ( ... )
        PPI::Token::Structure            ';'
      PPI::Token::Whitespace             '\n'
  
  Please note that in this example, strings are only listed for the
  B<actual> L<PPI::Token> that contains that string. Structures are listed
  with the type of brace characters it represents noted.
  
  The L<PPI::Dumper> module can be used to generate similar trees yourself.
  
  We can make that PDOM dump a little easier to read if we strip out all the
  whitespace. Here it is again, sans the distracting whitespace tokens.
  
    PPI::Document
      PPI::Token::Comment                '#!/usr/bin/perl\n'
      PPI::Statement
        PPI::Token::Word                 'print'
        PPI::Structure::List             ( ... )
          PPI::Statement::Expression
            PPI::Token::Quote::Double    '"Hello World!"'
        PPI::Token::Structure            ';'
      PPI::Statement
        PPI::Token::Word                 'exit'
        PPI::Structure::List             ( ... )
        PPI::Token::Structure            ';'
  
  As you can see, the tree can get fairly deep at time, especially when every
  isolated token in a bracket becomes its own statement. This is needed to
  allow anything inside the tree the ability to grow. It also makes the
  search and analysis algorithms much more flexible.
  
  Because of the depth and complexity of PDOM trees, a vast number of very easy
  to use methods have been added wherever possible to help people working with
  PDOM trees do normal tasks relatively quickly and efficiently.
  
  =head2 Overview of the Primary Classes
  
  The main PPI classes, and links to their own documentation, are listed
  here in alphabetical order.
  
  =over 4
  
  =item L<PPI::Document>
  
  The Document object, the root of the PDOM.
  
  =item L<PPI::Document::Fragment>
  
  A cohesive fragment of a larger Document. Although not of any real current
  use, it is needed for use in certain internal tree manipulation
  algorithms.
  
  For example, doing things like cut/copy/paste etc. Very similar to a
  L<PPI::Document>, but has some additional methods and does not represent
  a lexical scope boundary.
  
  A document fragment is also non-serializable, and so cannot be written out
  to a file.
  
  =item L<PPI::Dumper>
  
  A simple class for dumping readable debugging versions of PDOM structures,
  such as in the demonstration above.
  
  =item L<PPI::Element>
  
  The Element class is the abstract base class for all objects within the PDOM
  
  =item L<PPI::Find>
  
  Implements an instantiable object form of a PDOM tree search.
  
  =item L<PPI::Lexer>
  
  The PPI Lexer. Converts Token streams into PDOM trees.
  
  =item L<PPI::Node>
  
  The Node object, the abstract base class for all PDOM objects that can
  contain other Elements, such as the Document, Statement and Structure
  objects.
  
  =item L<PPI::Statement>
  
  The base class for all Perl statements. Generic "evaluate for side-effects"
  statements are of this actual type. Other more interesting statement types
  belong to one of its children.
  
  See its own documentation for a longer description and list of all of the
  different statement types and sub-classes.
  
  =item L<PPI::Structure>
  
  The abstract base class for all structures. A Structure is a language
  construct consisting of matching braces containing a set of other elements.
  
  See the L<PPI::Structure> documentation for a description and
  list of all of the different structure types and sub-classes.
  
  =item L<PPI::Token>
  
  A token is the basic unit of content. At its most basic, a Token is just
  a string tagged with metadata (its class, and some additional flags in
  some cases).
  
  =item L<PPI::Token::_QuoteEngine>
  
  The L<PPI::Token::Quote> and L<PPI::Token::QuoteLike> classes provide
  abstract base classes for the many and varied types of quote and
  quote-like things in Perl. However, much of the actual quote login is
  implemented in a separate quote engine, based at
  L<PPI::Token::_QuoteEngine>.
  
  Classes that inherit from L<PPI::Token::Quote>, L<PPI::Token::QuoteLike>
  and L<PPI::Token::Regexp> are generally parsed only by the Quote Engine.
  
  =item L<PPI::Tokenizer>
  
  The PPI Tokenizer. One Tokenizer consumes a chunk of text and provides
  access to a stream of L<PPI::Token> objects.
  
  The Tokenizer is very very complicated, to the point where even the author
  treads carefully when working with it.
  
  Most of the complication is the result of optimizations which have tripled
  the tokenization speed, at the expense of maintainability. We cope with the
  spaghetti by heavily commenting everything.
  
  =item L<PPI::Transform>
  
  The Perl Document Transformation API. Provides a standard interface and
  abstract base class for objects and classes that manipulate Documents.
  
  =back
  
  =head1 INSTALLING
  
  The core PPI distribution is pure Perl and has been kept as tight as
  possible and with as few dependencies as possible.
  
  It should download and install normally on any platform from within
  the CPAN and CPANPLUS applications, or directly using the distribution
  tarball. If installing by hand, you may need to install a few small
  utility modules first. The exact ones will depend on your version of
  perl.
  
  There are no special install instructions for PPI, and the normal
  C<Perl Makefile.PL>, C<make>, C<make test>, C<make install> instructions
  apply.
  
  =head1 EXTENDING
  
  The PPI namespace itself is reserved for use by PPI itself.
  You are recommended to use the PPIx:: namespace for PPI-specific
  modifications or prototypes thereof, or Perl:: for modules which provide
  a general Perl language-related functions.
  
  If what you wish to implement looks like it fits into the PPIx:: namespace,
  you should consider contacting the PPI maintainers on GitHub first, as what
  you want may already be in progress, or you may wish to consider contributing
  to PPI itself.
  
  =head1 TO DO
  
  - Many more analysis and utility methods for PDOM classes
  
  - Creation of a PPI::Tutorial document
  
  - Add many more key functions to PPI::XS
  
  - We can B<always> write more and better unit tests
  
  - Complete the full implementation of -E<gt>literal (1.200)
  
  - Full understanding of scoping (due 1.300)
  
  =head1 SUPPORT
  
  The most recent version of PPI is available at the following address.
  
  L<http://search.cpan.org/~mithaldu/PPI/>
  
  PPI source is maintained in a GitHub repository at the following address.
  
  L<https://github.com/adamkennedy/PPI>
  
  Contributions via GitHub pull request are welcome.
  
  Bug fixes in the form of pull requests or bug reports with
  new (failing) unit tests have the best chance of being addressed
  by busy maintainers, and are B<strongly> encouraged.
  
  If you cannot provide a test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the
  GitHub bug tracker.
  
  L<https://github.com/adamkennedy/PPI/issues>
  
  The C<ppidump> utility that is part of the L<Perl::Critic> distribution
  is a useful tool for demonstrating how PPI is parsing (or misparsing)
  small code snippets, and for providing information for bug reports.
  
  For other issues, questions, or commercial or media-related enquiries,
  contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 ACKNOWLEDGMENTS
  
  A huge thank you to Phase N Australia (L<http://phase-n.com/>) for
  permitting the original open sourcing and release of this distribution
  from what was originally several thousand hours of commercial work.
  
  Another big thank you to The Perl Foundation
  (L<http://www.perlfoundation.org/>) for funding for the final big
  refactoring and completion run.
  
  Also, to the various co-maintainers that have contributed both large and
  small with tests and patches and especially to those rare few who have
  deep-dived into the guts to (gasp) add a feature.
  
    - Dan Brook       : PPIx::XPath, Acme::PerlML
    - Audrey Tang     : "Line Noise" Testing
    - Arjen Laarhoven : Three-element ->location support
    - Elliot Shank    : Perl 5.10 support, five-element ->location
  
  And finally, thanks to those brave ( and foolish :) ) souls willing to dive
  in and use, test drive and provide feedback on PPI before version 1.000,
  in some cases before it made it to beta quality, and still did extremely
  distasteful things (like eating 50 meg of RAM a second).
  
  I owe you all a beer. Corner me somewhere and collect at your convenience.
  If I missed someone who wasn't in my email history, thank you too :)
  
    # In approximate order of appearance
    - Claes Jacobsson
    - Michael Schwern
    - Jeff T. Parsons
    - CPAN Author "CHOCOLATEBOY"
    - Robert Rotherberg
    - CPAN Author "PODMASTER"
    - Richard Soderberg
    - Nadim ibn Hamouda el Khemir
    - Graciliano M. P.
    - Leon Brocard
    - Jody Belka
    - Curtis Ovid
    - Yuval Kogman
    - Michael Schilli
    - Slaven Rezic
    - Lars Thegler
    - Tony Stubblebine
    - Tatsuhiko Miyagawa
    - CPAN Author "CHROMATIC"
    - Matisse Enzer
    - Roy Fulbright
    - Dan Brook
    - Johnny Lee
    - Johan Lindstrom
  
  And to single one person out, thanks go to Randal Schwartz who
  spent a great number of hours in IRC over a critical 6 month period
  explaining why Perl is impossibly unparsable and constantly shoving evil
  and ugly corner cases in my face. He remained a tireless devil's advocate,
  and without his support this project genuinely could never have been
  completed.
  
  So for my schooling in the Deep Magiks, you have my deepest gratitude Randal.
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;
  
  =pod
  
  =head1 NAME
  
  PPI::Cache - The PPI Document Caching Layer
  
  =head1 SYNOPSIS
  
    # Set the cache
    use PPI::Cache path => '/var/cache/ppi-cache';
    
    # Manually create a cache
    my $Cache = PPI::Cache->new(
        path     => '/var/cache/perl/class-PPI',
        readonly => 1,
    );
  
  =head1 DESCRIPTION
  
  C<PPI::Cache> provides the default caching functionality for L<PPI>.
  
  It integrates automatically with L<PPI> itself. Once enabled, any attempt
  to load a document from the filesystem will be cached via cache.
  
  Please note that creating a L<PPI::Document> from raw source or something
  other object will B<not> be cached.
  
  =head2 Using PPI::Cache
  
  The most common way of using C<PPI::Cache> is to provide parameters to
  the C<use> statement at the beginning of your program.
  
    # Load the class but do not set a cache
    use PPI::Cache;
    
    # Use a fairly normal cache location
    use PPI::Cache path => '/var/cache/ppi-cache';
  
  Any of the arguments that can be provided to the C<new> constructor can
  also be provided to C<use>.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp          ();
  use File::Spec    ();
  use File::Path    ();
  use Storable      ();
  use Digest::MD5   ();
  use Params::Util  qw{_INSTANCE _SCALAR};
  use PPI::Document ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  use constant VMS => !! ( $^O eq 'VMS' );
  
  sub import {
  	my $class = ref $_[0] ? ref shift : shift;
  	return 1 unless @_;
  
  	# Create a cache from the params provided
  	my $cache = $class->new(@_);
  
  	# Make PPI::Document use it
  	unless ( PPI::Document->set_cache( $cache ) ) {
  		Carp::croak("Failed to set cache in PPI::Document");
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new param => $value, ...
  
  The C<new> constructor creates a new standalone cache object.
  
  It takes a number of parameters to control the cache.
  
  =over
  
  =item path
  
  The C<path> param sets the base directory for the cache. It must already
  exist, and must be writable.
  
  =item readonly
  
  The C<readonly> param is a true/false flag that allows the use of an
  existing cache by a less-privileged user (such as the web user).
  
  Existing documents will be retrieved from the cache, but new documents
  will not be written to it.
  
  =back
  
  Returns a new C<PPI::Cache> object, or dies on error.
  
  =cut
  
  sub new {
  	my $class  = shift;
  	my %params = @_;
  
  	# Path should exist and be usable
  	my $path = $params{path}
  		or Carp::croak("Cannot create PPI::Cache, no path provided");
  	unless ( -d $path ) {
  		Carp::croak("Cannot create PPI::Cache, path does not exist");
  	}
  	unless ( -r $path and -x $path ) {
  		Carp::croak("Cannot create PPI::Cache, no read permissions for path");
  	}
  	if ( ! $params{readonly} and ! -w $path ) {
  		Carp::croak("Cannot create PPI::Cache, no write permissions for path");
  	}
  
  	# Create the basic object
  	my $self = bless {
  		path     => $path,
  		readonly => !! $params{readonly},
  	}, $class;
  
  	$self;
  }
  
  =pod
  
  =head2 path
  
  The C<path> accessor returns the path on the local filesystem that is the
  root of the cache.
  
  =cut
  
  sub path { $_[0]->{path} }
  
  =pod
  
  =head2 readonly
  
  The C<readonly> accessor returns true if documents should not be written
  to the cache.
  
  =cut
  
  sub readonly { $_[0]->{readonly} }
  
  
  
  
  
  #####################################################################
  # PPI::Cache Methods
  
  =pod
  
  =head2 get_document $md5sum | \$source
  
  The C<get_document> method checks to see if a Document is stored in the
  cache and retrieves it if so.
  
  =cut
  
  sub get_document {
  	my $self = ref $_[0]
  		? shift
  		: Carp::croak('PPI::Cache::get_document called as static method');
  	my $md5hex = $self->_md5hex(shift) or return undef;
  	$self->_load($md5hex);
  }
  
  =pod
  
  =head2 store_document $Document
  
  The C<store_document> method takes a L<PPI::Document> as argument and
  explicitly adds it to the cache.
  
  Returns true if saved, or C<undef> (or dies) on error.
  
  FIXME (make this return either one or the other, not both)
  
  =cut
  
  sub store_document {
  	my $self     = shift;
  	my $Document = _INSTANCE(shift, 'PPI::Document') or return undef;
  
  	# Shortcut if we are readonly
  	return 1 if $self->readonly;
  
  	# Find the filename to save to
  	my $md5hex = $Document->hex_id or return undef;
  
  	# Store the file
  	$self->_store( $md5hex, $Document );
  }
  
  
  
  
  
  #####################################################################
  # Support Methods
  
  # Store an arbitrary PPI::Document object (using Storable) to a particular
  # path within the cache filesystem.
  sub _store {
  	my ($self, $md5hex, $object) = @_;
  	my ($dir, $file) = $self->_paths($md5hex);
  
  	# Save the file
  	File::Path::mkpath( $dir, 0, 0755 ) unless -d $dir;
  	if ( VMS ) {
  		Storable::lock_nstore( $object, $file );
  	} else {
  		Storable::nstore( $object, $file );
  	}
  }
  
  # Load an arbitrary object (using Storable) from a particular
  # path within the cache filesystem.
  sub _load {
  	my ($self, $md5hex) = @_;
  	my (undef, $file) = $self->_paths($md5hex);
  
  	# Load the file
  	return '' unless -f $file;
  	my $object = VMS
  		? Storable::retrieve( $file )
  		: Storable::lock_retrieve( $file );
  
  	# Security check
  	unless ( _INSTANCE($object, 'PPI::Document') ) {
  		Carp::croak("Security Violation: Object in '$file' is not a PPI::Document");
  	}
  
  	$object;
  }
  
  # Convert a md5 to a dir and file name
  sub _paths {
  	my $self   = shift;
  	my $md5hex = lc shift;
  	my $dir    = File::Spec->catdir( $self->path, substr($md5hex, 0, 1), substr($md5hex, 0, 2) );
  	my $file   = File::Spec->catfile( $dir, $md5hex . '.ppi' );
  	return ($dir, $file);
  }
  
  # Check a md5hex param
  sub _md5hex {
  	my $either = shift;
  	my $it     = _SCALAR($_[0])
  		? PPI::Util::md5hex(${$_[0]})
  		: $_[0];
  	return (defined $it and ! ref $it and $it =~ /^[[:xdigit:]]{32}\z/s)
  		? lc $it
  		: undef;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Finish the basic functionality
  
  - Add support for use PPI::Cache auto-setting $PPI::Document::CACHE
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;
  
  =pod
  
  =head1 NAME
  
  PPI::Document - Object representation of a Perl document
  
  =head1 INHERITANCE
  
    PPI::Document
    isa PPI::Node
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    use PPI;
    
    # Load a document from a file
    my $Document = PPI::Document->new('My/Module.pm');
    
    # Strip out comments
    $Document->prune('PPI::Token::Comment');
    
    # Find all the named subroutines
    my $sub_nodes = $Document->find( 
    	sub { $_[1]->isa('PPI::Statement::Sub') and $_[1]->name }
    );
    my @sub_names = map { $_->name } @$sub_nodes;
    
    # Save the file
    $Document->save('My/Module.pm.stripped');
  
  =head1 DESCRIPTION
  
  The C<PPI::Document> class represents a single Perl "document". A
  C<PPI::Document> object acts as a root L<PPI::Node>, with some
  additional methods for loading and saving, and working with
  the line/column locations of Elements within a file.
  
  The exemption to its L<PPI::Node>-like behavior this is that a
  C<PPI::Document> object can NEVER have a parent node, and is always
  the root node in a tree.
  
  =head2 Storable Support
  
  C<PPI::Document> implements the necessary C<STORABLE_freeze> and
  C<STORABLE_thaw> hooks to provide native support for L<Storable>,
  if you have it installed.
  
  However if you want to clone a Document, you are highly recommended
  to use the C<$Document-E<gt>clone> method rather than Storable's
  C<dclone> function (although C<dclone> should still work).
  
  =head1 METHODS
  
  Most of the things you are likely to want to do with a Document are
  probably going to involve the methods from L<PPI::Node> class, of which
  this is a subclass.
  
  The methods listed here are the remaining few methods that are truly
  Document-specific.
  
  =cut
  
  use strict;
  use Carp                          ();
  use List::Util 1.33               ();
  use Params::Util                  qw{_SCALAR0 _ARRAY0 _INSTANCE};
  use Digest::MD5                   ();
  use PPI::Util                     ();
  use PPI                           ();
  use PPI::Node                     ();
  
  use overload 'bool' => \&PPI::Util::TRUE;
  use overload '""'   => 'content';
  
  use vars qw{$VERSION @ISA $errstr};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Node';
  	$errstr  = '';
  }
  
  use PPI::Document::Fragment ();
  
  # Document cache
  my $CACHE;
  
  # Convenience constants related to constants
  use constant LOCATION_LINE         => 0;
  use constant LOCATION_CHARACTER    => 1;
  use constant LOCATION_COLUMN       => 2;
  use constant LOCATION_LOGICAL_LINE => 3;
  use constant LOCATION_LOGICAL_FILE => 4;
  
  
  
  
  
  #####################################################################
  # Constructor and Static Methods
  
  =pod
  
  =head2 new
  
    # Simple construction
    $doc = PPI::Document->new( $filename );
    $doc = PPI::Document->new( \$source  );
    
    # With the readonly attribute set
    $doc = PPI::Document->new( $filename,
            readonly => 1,
    );
  
  The C<new> constructor takes as argument a variety of different sources of
  Perl code, and creates a single cohesive Perl C<PPI::Document>
  for it.
  
  If passed a file name as a normal string, it will attempt to load the
  document from the file.
  
  If passed a reference to a C<SCALAR>, this is taken to be source code and
  parsed directly to create the document.
  
  If passed zero arguments, a "blank" document will be created that contains
  no content at all.
  
  In all cases, the document is considered to be "anonymous" and not tied back
  to where it was created from. Specifically, if you create a PPI::Document from
  a filename, the document will B<not> remember where it was created from.
  
  The constructor also takes attribute flags.
  
  At this time, the only available attribute is the C<readonly> flag.
  
  Setting C<readonly> to true will allow various systems to provide
  additional optimisations and caching. Note that because C<readonly> is an
  optimisation flag, it is off by default and you will need to explicitly
  enable it.
  
  Returns a C<PPI::Document> object, or C<undef> if parsing fails.
  L<PPI::Exception> objects can also be thrown if there are parsing problems.
  
  =cut
  
  sub new {
  	local $_; # An extra one, just in case
  	my $class = ref $_[0] ? ref shift : shift;
  
  	unless ( @_ ) {
  		my $self = $class->SUPER::new;
  		$self->{readonly}  = ! 1;
  		$self->{tab_width} = 1;
  		return $self;
  	}
  
  	# Check constructor attributes
  	my $source  = shift;
  	my %attr    = @_;
  
  	# Check the data source
  	if ( ! defined $source ) {
  		$class->_error("An undefined value was passed to PPI::Document::new");
  
  	} elsif ( ! ref $source ) {
  		# Catch people using the old API
  		if ( $source =~ /(?:\012|\015)/ ) {
  			Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference");
  		}
  
  		# When loading from a filename, use the caching layer if it exists.
  		if ( $CACHE ) {
  			my $file_contents = PPI::Util::_slurp( $source );
  
  			# Errors returned as plain string
  			return $class->_error($file_contents) if !ref $file_contents;
  
  			# Retrieve the document from the cache
  			my $document = $CACHE->get_document($file_contents);
  			return $class->_setattr( $document, %attr ) if $document;
  
  			$document = PPI::Lexer->lex_source( $$file_contents );
  			if ( $document ) {
  				# Save in the cache
  				$CACHE->store_document( $document );
  				return $class->_setattr( $document, %attr );
  			}
  		} else {
  			my $document = PPI::Lexer->lex_file( $source );
  			return $class->_setattr( $document, %attr ) if $document;
  		}
  
  	} elsif ( _SCALAR0($source) ) {
  		my $document = PPI::Lexer->lex_source( $$source );
  		return $class->_setattr( $document, %attr ) if $document;
  
  	} elsif ( _ARRAY0($source) ) {
  		$source = join '', map { "$_\n" } @$source;
  		my $document = PPI::Lexer->lex_source( $source );
  		return $class->_setattr( $document, %attr ) if $document;
  
  	} else {
  		$class->_error("Unknown object or reference was passed to PPI::Document::new");
  	}
  
  	# Pull and store the error from the lexer
  	my $errstr;
  	if ( _INSTANCE($@, 'PPI::Exception') ) {
  		$errstr = $@->message;
  	} elsif ( $@ ) {
  		$errstr = $@;
  		$errstr =~ s/\sat line\s.+$//;
  	} elsif ( PPI::Lexer->errstr ) {
  		$errstr = PPI::Lexer->errstr;
  	} else {
  		$errstr = "Unknown error parsing Perl document";
  	}
  	PPI::Lexer->_clear;
  	$class->_error( $errstr );
  }
  
  sub load {
  	Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file");
  }
  
  sub _setattr {
  	my ($class, $document, %attr) = @_;
  	$document->{readonly} = !! $attr{readonly};
  	return $document;
  }
  
  =pod
  
  =head2 set_cache $cache
  
  As of L<PPI> 1.100, C<PPI::Document> supports parser caching.
  
  The default cache class L<PPI::Cache> provides a L<Storable>-based
  caching or the parsed document based on the MD5 hash of the document as
  a string.
  
  The static C<set_cache> method is used to set the cache object for
  C<PPI::Document> to use when loading documents. It takes as argument
  a L<PPI::Cache> object (or something that C<isa> the same).
  
  If passed C<undef>, this method will stop using the current cache, if any.
  
  For more information on caching, see L<PPI::Cache>.
  
  Returns true on success, or C<undef> if not passed a valid param.
  
  =cut
  
  sub set_cache {
  	my $class  = ref $_[0] ? ref shift : shift;
  
  	if ( defined $_[0] ) {
  		# Enable the cache
  		my $object = _INSTANCE(shift, 'PPI::Cache') or return undef;
  		$CACHE = $object;
  	} else {
  		# Disable the cache
  		$CACHE = undef;
  	}
  
  	1;
  }
  
  =pod
  
  =head2 get_cache
  
  If a document cache is currently set, the C<get_cache> method will
  return it.
  
  Returns a L<PPI::Cache> object, or C<undef> if there is no cache
  currently set for C<PPI::Document>.
  
  =cut
  
  sub get_cache {
  	$CACHE;	
  }
  
  
  
  
  
  #####################################################################
  # PPI::Document Instance Methods
  
  =pod
  
  =head2 readonly
  
  The C<readonly> attribute indicates if the document is intended to be
  read-only, and will never be modified. This is an advisory flag, that
  writers of L<PPI>-related systems may or may not use to enable
  optimisations and caches for your document.
  
  Returns true if the document is read-only or false if not.
  
  =cut
  
  sub readonly {
  	$_[0]->{readonly};
  }
  
  =pod
  
  =head2 tab_width [ $width ]
  
  In order to handle support for C<location> correctly, C<Documents>
  need to understand the concept of tabs and tab width. The C<tab_width>
  method is used to get and set the size of the tab width.
  
  At the present time, PPI only supports "naive" (width 1) tabs, but we do
  plan on supporting arbitrary, default and auto-sensing tab widths later.
  
  Returns the tab width as an integer, or C<die>s if you attempt to set the
  tab width.
  
  =cut
  
  sub tab_width {
  	my $self = shift;
  	return $self->{tab_width} unless @_;
  	$self->{tab_width} = shift;
  }
  
  =pod
  
  =head2 save
  
    $document->save( $file )
   
  The C<save> method serializes the C<PPI::Document> object and saves the
  resulting Perl document to a file. Returns C<undef> on failure to open
  or write to the file.
  
  =cut
  
  sub save {
  	my $self = shift;
  	local *FILE;
  	open( FILE, '>', $_[0] )    or return undef;
  	binmode FILE;
  	print FILE $self->serialize or return undef;
  	close FILE                  or return undef;
  	return 1;
  }
  
  =pod
  
  =head2 serialize
  
  Unlike the C<content> method, which shows only the immediate content
  within an element, Document objects also have to be able to be written
  out to a file again.
  
  When doing this we need to take into account some additional factors.
  
  Primarily, we need to handle here-docs correctly, so that are written
  to the file in the expected place.
  
  The C<serialize> method generates the actual file content for a given
  Document object. The resulting string can be written straight to a file.
  
  Returns the serialized document as a string.
  
  =cut
  
  sub serialize {
  	my $self   = shift;
  	my @tokens = $self->tokens;
  
  	# The here-doc content buffer
  	my $heredoc = '';
  
  	# Start the main loop
  	my $output = '';
  	foreach my $i ( 0 .. $#tokens ) {
  		my $Token = $tokens[$i];
  
  		# Handle normal tokens
  		unless ( $Token->isa('PPI::Token::HereDoc') ) {
  			my $content = $Token->content;
  
  			# Handle the trivial cases
  			unless ( $heredoc ne '' and $content =~ /\n/ ) {
  				$output .= $content;
  				next;
  			}
  
  			# We have pending here-doc content that needs to be
  			# inserted just after the first newline in the content.
  			if ( $content eq "\n" ) {
  				# Shortcut the most common case for speed
  				$output .= $content . $heredoc;
  			} else {
  				# Slower and more general version
  				$content =~ s/\n/\n$heredoc/;
  				$output .= $content;
  			}
  
  			$heredoc = '';
  			next;
  		}
  
  		# This token is a HereDoc.
  		# First, add the token content as normal, which in this
  		# case will definitely not contain a newline.
  		$output .= $Token->content;
  
  		# Now add all of the here-doc content to the heredoc buffer.
  		foreach my $line ( $Token->heredoc ) {
  			$heredoc .= $line;
  		}
  
  		if ( $Token->{_damaged} ) {
  			# Special Case:
  			# There are a couple of warning/bug situations
  			# that can occur when a HereDoc content was read in
  			# from the end of a file that we silently allow.
  			#
  			# When writing back out to the file we have to
  			# auto-repair these problems if we aren't going back
  			# on to the end of the file.
  
  			# When calculating $last_line, ignore the final token if
  			# and only if it has a single newline at the end.
  			my $last_index = $#tokens;
  			if ( $tokens[$last_index]->{content} =~ /^[^\n]*\n$/ ) {
  				$last_index--;
  			}
  
  			# This is a two part test.
  			# First, are we on the last line of the
  			# content part of the file
  			my $last_line = List::Util::none {
  				$tokens[$_] and $tokens[$_]->{content} =~ /\n/
  				} (($i + 1) .. $last_index);
  			if ( ! defined $last_line ) {
  				# Handles the null list case
  				$last_line = 1;
  			}
  
  			# Secondly, are their any more here-docs after us,
  			# (with content or a terminator)
  			my $any_after = List::Util::any {
  				$tokens[$_]->isa('PPI::Token::HereDoc')
  				and (
  					scalar(@{$tokens[$_]->{_heredoc}})
  					or
  					defined $tokens[$_]->{_terminator_line}
  					)
  				} (($i + 1) .. $#tokens);
  			if ( ! defined $any_after ) {
  				# Handles the null list case
  				$any_after = '';
  			}
  
  			# We don't need to repair the last here-doc on the
  			# last line. But we do need to repair anything else.
  			unless ( $last_line and ! $any_after ) {
  				# Add a terminating string if it didn't have one
  				unless ( defined $Token->{_terminator_line} ) {
  					$Token->{_terminator_line} = $Token->{_terminator};
  				}
  
  				# Add a trailing newline to the terminating
  				# string if it didn't have one.
  				unless ( $Token->{_terminator_line} =~ /\n$/ ) {
  					$Token->{_terminator_line} .= "\n";
  				}
  			}
  		}
  
  		# Now add the termination line to the heredoc buffer
  		if ( defined $Token->{_terminator_line} ) {
  			$heredoc .= $Token->{_terminator_line};
  		}
  	}
  
  	# End of tokens
  
  	if ( $heredoc ne '' ) {
  		# If the file doesn't end in a newline, we need to add one
  		# so that the here-doc content starts on the next line.
  		unless ( $output =~ /\n$/ ) {
  			$output .= "\n";
  		}
  
  		# Now we add the remaining here-doc content
  		# to the end of the file.
  		$output .= $heredoc;
  	}
  
  	$output;
  }
  
  =pod
  
  =head2 hex_id
  
  The C<hex_id> method generates an unique identifier for the Perl document.
  
  This identifier is basically just the serialized document, with
  Unix-specific newlines, passed through MD5 to produce a hexadecimal string.
  
  This identifier is used by a variety of systems (such as L<PPI::Cache>
  and L<Perl::Metrics>) as a unique key against which to store or cache
  information about a document (or indeed, to cache the document itself).
  
  Returns a 32 character hexadecimal string.
  
  =cut
  
  sub hex_id {
  	PPI::Util::md5hex($_[0]->serialize);
  }
  
  =pod
  
  =head2 index_locations
  
  Within a document, all L<PPI::Element> objects can be considered to have a
  "location", a line/column position within the document when considered as a
  file. This position is primarily useful for debugging type activities.
  
  The method for finding the position of a single Element is a bit laborious,
  and very slow if you need to do it a lot. So the C<index_locations> method
  will index and save the locations of every Element within the Document in
  advance, making future calls to <PPI::Element::location> virtually free.
  
  Please note that this index should always be cleared using C<flush_locations>
  once you are finished with the locations. If content is added to or removed
  from the file, these indexed locations will be B<wrong>.
  
  =cut
  
  sub index_locations {
  	my $self   = shift;
  	my @tokens = $self->tokens;
  
  	# Whenever we hit a heredoc we will need to increment by
  	# the number of lines in it's content section when we
  	# encounter the next token with a newline in it.
  	my $heredoc = 0;
  
  	# Find the first Token without a location
  	my ($first, $location) = ();
  	foreach ( 0 .. $#tokens ) {
  		my $Token = $tokens[$_];
  		next if $Token->{_location};
  
  		# Found the first Token without a location
  		# Calculate the new location if needed.
  		if ($_) {
  			$location =
  				$self->_add_location( $location, $tokens[$_ - 1], \$heredoc );
  		} else {
  			my $logical_file =
  				$self->can('filename') ? $self->filename : undef;
  			$location = [ 1, 1, 1, 1, $logical_file ];
  		}
  		$first = $_;
  		last;
  	}
  
  	# Calculate locations for the rest
  	if ( defined $first ) {
  		foreach ( $first .. $#tokens ) {
  			my $Token = $tokens[$_];
  			$Token->{_location} = $location;
  			$location = $self->_add_location( $location, $Token, \$heredoc );
  
  			# Add any here-doc lines to the counter
  			if ( $Token->isa('PPI::Token::HereDoc') ) {
  				$heredoc += $Token->heredoc + 1;
  			}
  		}
  	}
  
  	1;
  }
  
  sub _add_location {
  	my ($self, $start, $Token, $heredoc) = @_;
  	my $content = $Token->{content};
  
  	# Does the content contain any newlines
  	my $newlines =()= $content =~ /\n/g;
  	my ($logical_line, $logical_file) =
  		$self->_logical_line_and_file($start, $Token, $newlines);
  
  	unless ( $newlines ) {
  		# Handle the simple case
  		return [
  			$start->[LOCATION_LINE],
  			$start->[LOCATION_CHARACTER] + length($content),
  			$start->[LOCATION_COLUMN]
  				+ $self->_visual_length(
  					$content,
  					$start->[LOCATION_COLUMN]
  				),
  			$logical_line,
  			$logical_file,
  		];
  	}
  
  	# This is the more complex case where we hit or
  	# span a newline boundary.
  	my $physical_line = $start->[LOCATION_LINE] + $newlines;
  	my $location = [ $physical_line, 1, 1, $logical_line, $logical_file ];
  	if ( $heredoc and $$heredoc ) {
  		$location->[LOCATION_LINE]         += $$heredoc;
  		$location->[LOCATION_LOGICAL_LINE] += $$heredoc;
  		$$heredoc = 0;
  	}
  
  	# Does the token have additional characters
  	# after their last newline.
  	if ( $content =~ /\n([^\n]+?)\z/ ) {
  		$location->[LOCATION_CHARACTER] += length($1);
  		$location->[LOCATION_COLUMN] +=
  			$self->_visual_length(
  				$1, $location->[LOCATION_COLUMN],
  			);
  	}
  
  	$location;
  }
  
  sub _logical_line_and_file {
  	my ($self, $start, $Token, $newlines) = @_;
  
  	# Regex taken from perlsyn, with the correction that there's no space
  	# required between the line number and the file name.
  	if ($start->[LOCATION_CHARACTER] == 1) {
  		if ( $Token->isa('PPI::Token::Comment') ) {
  			if (
  				$Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms
  			) {
  				return $1, ($3 || $start->[LOCATION_LOGICAL_FILE]);
  			}
  		}
  		elsif ( $Token->isa('PPI::Token::Pod') ) {
  			my $content = $Token->content;
  			my $line;
  			my $file = $start->[LOCATION_LOGICAL_FILE];
  			my $end_of_directive;
  			while (
  				$content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg
  			) {
  				($line, $file) = ($1, ( $3 || $file ) );
  				$end_of_directive = pos $content;
  			}
  
  			if (defined $line) {
  				pos $content = $end_of_directive;
  				my $post_directive_newlines =()= $content =~ m< \G [^\n]* \n >xmsg;
  				return $line + $post_directive_newlines - 1, $file;
  			}
  		}
  	}
  
  	return
  		$start->[LOCATION_LOGICAL_LINE] + $newlines,
  		$start->[LOCATION_LOGICAL_FILE];
  }
  
  sub _visual_length {
  	my ($self, $content, $pos) = @_;
  
  	my $tab_width = $self->tab_width;
  	my ($length, $vis_inc);
  
  	return length $content if $content !~ /\t/;
  
  	# Split the content in tab and non-tab parts and calculate the
  	# "visual increase" of each part.
  	for my $part ( split(/(\t)/, $content) ) {
  		if ($part eq "\t") {
  			$vis_inc = $tab_width - ($pos-1) % $tab_width;
  		}
  		else {
  			$vis_inc = length $part;
  		}
  		$length += $vis_inc;
  		$pos    += $vis_inc;
  	}
  
  	$length;
  }
  
  =pod
  
  =head2 flush_locations
  
  When no longer needed, the C<flush_locations> method clears all location data
  from the tokens.
  
  =cut
  
  sub flush_locations {
  	shift->_flush_locations(@_);
  }
  
  =pod
  
  =head2 normalized
  
  The C<normalized> method is used to generate a "Layer 1"
  L<PPI::Document::Normalized> object for the current Document.
  
  A "normalized" Perl Document is an arbitrary structure that removes any
  irrelevant parts of the document and refactors out variations in style,
  to attempt to approach something that is closer to the "true meaning"
  of the Document.
  
  See L<PPI::Normal> for more information on document normalization and
  the tasks for which it is useful.
  
  Returns a L<PPI::Document::Normalized> object, or C<undef> on error.
  
  =cut
  
  sub normalized {
  	# The normalization process will utterly destroy and mangle
  	# anything passed to it, so we are going to only give it a
  	# clone of ourselves.
  	PPI::Normal->process( $_[0]->clone );
  }
  
  =pod
  
  =head1 complete
  
  The C<complete> method is used to determine if a document is cleanly
  structured, all braces are closed, the final statement is
  fully terminated and all heredocs are fully entered.
  
  Returns true if the document is complete or false if not.
  
  =cut
  
  sub complete {
  	my $self = shift;
  
  	# Every structure has to be complete
  	$self->find_any( sub {
  		$_[1]->isa('PPI::Structure')
  		and
  		! $_[1]->complete
  	} )
  	and return '';
  
  	# Strip anything that isn't a statement off the end
  	my @child = $self->children;
  	while ( @child and not $child[-1]->isa('PPI::Statement') ) {
  		pop @child;
  	}
  
  	# We must have at least one statement
  	return '' unless @child;
  
  	# Check the completeness of the last statement
  	return $child[-1]->_complete;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  # We are a scope boundary
  ### XS -> PPI/XS.xs:_PPI_Document__scope 0.903+
  sub scope() { 1 }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  sub insert_before {
  	return undef;
  	# die "Cannot insert_before a PPI::Document";
  }
  
  sub insert_after {
  	return undef;
  	# die "Cannot insert_after a PPI::Document";
  }
  
  sub replace {
  	return undef;
  	# die "Cannot replace a PPI::Document";
  }
  
  
  
  
  
  #####################################################################
  # Error Handling
  
  # Set the error message
  sub _error {
  	$errstr = $_[1];
  	undef;
  }
  
  # Clear the error message.
  # Returns the object as a convenience.
  sub _clear {
  	$errstr = '';
  	$_[0];
  }
  
  =pod
  
  =head2 errstr
  
  For error that occur when loading and saving documents, you can use
  C<errstr>, as either a static or object method, to access the error message.
  
  If a Document loads or saves without error, C<errstr> will return false.
  
  =cut
  
  sub errstr {
  	$errstr;
  }
  
  
  
  
  
  #####################################################################
  # Native Storable Support
  
  sub STORABLE_freeze {
  	my $self  = shift;
  	my $class = ref $self;
  	my %hash  = %$self;
  	return ($class, \%hash);
  }
  
  sub STORABLE_thaw {
  	my ($self, undef, $class, $hash) = @_;
  	bless $self, $class;
  	foreach ( keys %$hash ) {
  		$self->{$_} = delete $hash->{$_};
  	}
  	$self->__link_children;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - May need to overload some methods to forcefully prevent Document
  objects becoming children of another Node.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<PPI>, L<http://ali.as/>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;
  
  =pod
  
  =head1 NAME
  
  PPI::Document::File - A Perl Document located in a specific file
  
  =head1 DESCRIPTION
  
  B<WARNING: This class is experimental, and may change without notice>
  
  B<PPI::Document::File> provides a L<PPI::Document> subclass that represents
  a Perl document stored in a specific named file.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp          ();
  use Params::Util  qw{_STRING _INSTANCE};
  use PPI::Document ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Document';
  }
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $file = PPI::Document::File->new( 'Module.pm' );
  
  The C<new> constructor works the same as for the regular one, except
  that the only params allowed is a file name. You cannot create an
  "anonymous" PPI::Document::File object, not can you create an empty one.
  
  Returns a new PPI::Document::File object, or C<undef> on error.
  
  =cut
  
  sub new {
  	my $class    = shift;
  	my $filename = _STRING(shift);
  	unless ( defined $filename ) {
  		# Perl::Critic got a complaint about not handling a file
  		# named "0".
  		return $class->_error("Did not provide a file name to load");
  	}
  
  	# Load the Document
  	my $self = $class->SUPER::new( $filename, @_ ) or return undef;
  
  	# Unlike a normal inheritance situation, due to our need to stay
  	# compatible with caching magic, this actually returns a regular
  	# anonymous document. We need to rebless if
  	if ( _INSTANCE($self, 'PPI::Document') ) {
  		bless $self, 'PPI::Document::File';
  	} else {
  		die "PPI::Document::File SUPER call returned an object of the wrong type";
  	}
  
  	# Save the filename
  	$self->{filename} = $filename;
  
  	$self;
  }
  
  =head2 filename
  
  The C<filename> accessor returns the name of the file in which the document
  is stored.
  
  =cut
  
  sub filename {
  	$_[0]->{filename};
  }
  
  =pod
  
  =head2 save
  
    # Save to the file we were loaded from
    $file->save;
    
    # Save a copy to somewhere else
    $file->save( 'Module2.pm' );
  
  The C<save> method works similarly to the one in the parent L<PPI::Document>
  class, saving a copy of the document to a file.
  
  The difference with this subclass is that if C<save> is not passed any
  filename, it will save it back to the file it was loaded from.
  
  Note: When saving to a different file, it is considered to be saving a
  B<copy> and so the value returned by the C<filename> accessor will stay
  the same, and not change to the new filename.
  
  =cut
  
  sub save {
  	my $self = shift;
  
  	# Save to where?
  	my $filename = shift;
  	unless ( defined $filename ) {
  		$filename = $self->filename;
  	}
  
  	# Hand off to main save method
  	$self->SUPER::save( $filename, @_ );
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - May need to overload some methods to forcefully prevent Document
  objects becoming children of another Node.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;
  
  =pod
  
  =head1 NAME
  
  PPI::Document::Fragment - A fragment of a Perl Document
  
  =head1 DESCRIPTION
  
  In some situations you might want to work with a fragment of a larger
  document. C<PPI::Document::Fragment> is a class intended for this purpose.
  It is functionally almost identical to a normal L<PPI::Document>, except
  that it is not possible to get line/column positions for the elements
  within it, and it does not represent a scope.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Document ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Document';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Document Methods
  
  =pod
  
  =head2 index_locations
  
  Unlike when called on a PPI::Document object, you should not be attempting
  to find locations of things within a PPI::Document::Fragment, and thus any
  call to the C<index_locations> will print a warning and return C<undef>
  instead of attempting to index the locations of the Elements.
  
  =cut
  
  # There's no point indexing a fragment
  sub index_locations {
  	warn "Useless attempt to index the locations of a document fragment";
  	undef;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # We are not a scope boundary
  ### XS -> PPI/XS.xs:_PPI_Document_Fragment__scope 0.903+
  sub scope() { '' }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  Integrate this into the rest of PPI so it has actual practical uses. The most
  obvious would be to implement arbitrary cut/copy/paste more easily.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;
  
  =pod
  
  =head1 NAME
  
  PPI::Document::Normalized - A normalized Perl Document
  
  =head1 DESCRIPTION
  
  A C<Normalized Document> object is the result of the normalization process
  contained in the L<PPI::Normal> class. See the documentation for
  L<PPI::Normal> for more information.
  
  The object contains a version stamp and function list for the version
  of L<PPI::Normal> used to create it, and a processed and delinked
  L<PPI::Document> object.
  
  Typically, the Document object will have been mangled by the normalization
  process in a way that would make it fatal to try to actually DO anything
  with it.
  
  Put simply, B<never> use the Document object after normalization.
  B<YOU HAVE BEEN WARNED!>
  
  The object is designed the way it is to provide a bias towards false
  negatives. A comparison between two ::Normalized object will only return
  true if they were produced by the same version of PPI::Normal, with the
  same set of normalization functions (in the same order).
  
  You may get false negatives if you are caching objects across an upgrade.
  
  Please note that this is done for security purposes, as there are many
  cases in which low layer normalization is likely to be done as part of
  a code security process, and false positives could be highly dangerous.
  
  =head1 METHODS
  
  =cut
  
  # For convenience (and since this isn't really a public class), import
  # the methods we will need from Scalar::Util.
  use strict;
  use Scalar::Util qw{refaddr reftype blessed};
  use Params::Util qw{_INSTANCE _ARRAY};
  use PPI::Util    ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  use overload 'bool' => \&PPI::Util::TRUE;
  use overload '=='   => 'equal';
  
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
  The C<new> method is intended for use only by the L<PPI::Normal> class,
  and to get ::Normalized objects, you are highly recommended to use
  either that module, or the C<normalized> method of the L<PPI::Document>
  object itself.
  
  =cut
  
  sub new {
  	my $class = shift;
  	my %args  = @_;
  
  	# Check the required params
  	my $Document  = _INSTANCE($args{Document}, 'PPI::Document') or return undef;
  	my $version   = $args{version} or return undef;
  	my $functions = _ARRAY($args{functions}) or return undef;
  
  	# Create the object
  	my $self = bless {
  		Document  => $Document,
  		version   => $version,
  		functions => $functions,
  		}, $class;
  
  	$self;
  }
  
  sub _Document { $_[0]->{Document}  }
  
  =pod
  
  =head2 version
  
  The C<version> accessor returns the L<PPI::Normal> version used to create
  the object.
  
  =cut
  
  sub version   { $_[0]->{version}   }
  
  =pod
  
  =head2 functions
  
  The C<functions> accessor returns a reference to an array of the
  normalization functions (in order) that were called when creating
  the object.
  
  =cut
  
  sub functions { $_[0]->{functions} }
  
  
  
  
  
  #####################################################################
  # Comparison Methods
  
  =pod
  
  =head2 equal $Normalized
  
  The C<equal> method is the primary comparison method, taking another
  PPI::Document::Normalized object, and checking for equivalence to it.
  
  The C<==> operator is also overload to this method, so that you can
  do something like the following:
  
    my $first  = PPI::Document->load('first.pl');
    my $second = PPI::Document->load('second.pl');
    
    if ( $first->normalized == $second->normalized ) {
    	print "The two documents are equivalent";
    }
  
  Returns true if the normalized documents are equivalent, false if not,
  or C<undef> if there is an error.
  
  =cut
  
  sub equal {
  	my $self  = shift;
  	my $other = _INSTANCE(shift, 'PPI::Document::Normalized') or return undef;
  
  	# Prevent multiple concurrent runs
  	return undef if $self->{processing};
  
  	# Check the version and function list first
  	return '' unless $self->version eq $other->version;
  	$self->_equal_ARRAY( $self->functions, $other->functions ) or return '';
  
  	# Do the main comparison run
  	$self->{seen} = {};
  	my $rv = $self->_equal_blessed( $self->_Document, $other->_Document );
  	delete $self->{seen};
  
  	$rv;
  }
  
  # Check that two objects are matched
  sub _equal_blessed {
  	my ($self, $this, $that) = @_;
  	my ($bthis, $bthat) = (blessed $this, blessed $that);
  	$bthis and $bthat and $bthis eq $bthat or return '';
  
  	# Check the object as a reference
  	$self->_equal_reference( $this, $that );
  }
  
  # Check that two references match their types
  sub _equal_reference {
  	my ($self, $this, $that) = @_;
  	my ($rthis, $rthat) = (refaddr $this, refaddr $that);
  	$rthis and $rthat or return undef;
  
  	# If we have seen this before, are the pointing
  	# is it the same one we saw in both sides
  	my $seen = $self->{seen}->{$rthis};
  	if ( $seen and $seen ne $rthat ) {
  		return '';
  	}
  
  	# Check the reference types
  	my ($tthis, $tthat) = (reftype $this, reftype $that);
  	$tthis and $tthat and $tthis eq $tthat or return undef;
  
  	# Check the children of the reference type
  	$self->{seen}->{$rthis} = $rthat;
  	my $method = "_equal_$tthat";
  	my $rv = $self->$method( $this, $that );
  	delete $self->{seen}->{$rthis};
  	$rv;
  }
  
  # Compare the children of two SCALAR references
  sub _equal_SCALAR {
  	my ($self, $this, $that) = @_;
  	my ($cthis, $cthat) = ($$this, $$that);
  	return $self->_equal_blessed( $cthis, $cthat )   if blessed $cthis;
  	return $self->_equal_reference( $cthis, $cthat ) if ref $cthis;
  	return (defined $cthat and $cthis eq $cthat)     if defined $cthis;
  	! defined $cthat;
  }
  
  # For completeness sake, lets just treat REF as a specialist SCALAR case
  sub _equal_REF { shift->_equal_SCALAR(@_) }
  
  # Compare the children of two ARRAY references
  sub _equal_ARRAY {
  	my ($self, $this, $that) = @_;
  
  	# Compare the number of elements
  	scalar(@$this) == scalar(@$that) or return '';
  
  	# Check each element in the array.
  	# Descend depth-first.
  	foreach my $i ( 0 .. scalar(@$this) ) {
  		my ($cthis, $cthat) = ($this->[$i], $that->[$i]);
  		if ( blessed $cthis ) {
  			return '' unless $self->_equal_blessed( $cthis, $cthat );
  		} elsif ( ref $cthis ) {
  			return '' unless $self->_equal_reference( $cthis, $cthat );
  		} elsif ( defined $cthis ) {
  			return '' unless (defined $cthat and $cthis eq $cthat);
  		} else {
  			return '' if defined $cthat;
  		}
  	}
  
  	1;
  }
  
  # Compare the children of a HASH reference
  sub _equal_HASH {
  	my ($self, $this, $that) = @_;
  
  	# Compare the number of keys
  	return '' unless scalar(keys %$this) == scalar(keys %$that);
  
  	# Compare each key, descending depth-first.
  	foreach my $k ( keys %$this ) {
  		return '' unless exists $that->{$k};
  		my ($cthis, $cthat) = ($this->{$k}, $that->{$k});
  		if ( blessed $cthis ) {
  			return '' unless $self->_equal_blessed( $cthis, $cthat );
  		} elsif ( ref $cthis ) {
  			return '' unless $self->_equal_reference( $cthis, $cthat );
  		} elsif ( defined $cthis ) {
  			return '' unless (defined $cthat and $cthis eq $cthat);
  		} else {
  			return '' if defined $cthat;
  		}
  	}
  
  	1;
  }		
  
  # We do not support GLOB comparisons
  sub _equal_GLOB {
  	my ($self, $this, $that) = @_;
  	warn('GLOB comparisons are not supported');
  	'';
  }
  
  # We do not support CODE comparisons
  sub _equal_CODE {
  	my ($self, $this, $that) = @_;
  	refaddr $this == refaddr $that;
  }
  
  # We don't support IO comparisons
  sub _equal_IO {
  	my ($self, $this, $that) = @_;
  	warn('IO comparisons are not supported');
  	'';
  }
  
  sub DESTROY {
  	# Take the screw up Document with us
  	if ( $_[0]->{Document} ) {
  		$_[0]->{Document}->DESTROY;
  		delete $_[0]->{Document};
  	}
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
  	
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;
  
  =pod
  
  =head1 NAME
  
  PPI::Dumper - Dumping of PDOM trees
  
  =head1 SYNOPSIS
  
    # Load a document
    my $Module = PPI::Document->new( 'MyModule.pm' );
    
    # Create the dumper
    my $Dumper = PPI::Dumper->new( $Module );
    
    # Dump the document
    $Dumper->print;
  
  =head1 DESCRIPTION
  
  The PDOM trees in PPI are quite complex, and getting a dump of their
  structure for development and debugging purposes is important.
  
  This module provides that functionality.
  
  The process is relatively simple. Create a dumper object with a
  particular set of options, and then call one of the dump methods to
  generate the dump content itself.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new $Element, param => value, ...
  
  The C<new> constructor creates a dumper, and takes as argument a single
  L<PPI::Element> object of any type to serve as the root of the tree to
  be dumped, and a number of key-E<gt>value parameters to control the output
  format of the Dumper. Details of the parameters are listed below.
  
  Returns a new C<PPI::Dumper> object, or C<undef> if the constructor
  is not passed a correct L<PPI::Element> root object.
  
  =over
  
  =item memaddr
  
  Should the dumper print the memory addresses of each PDOM element.
  True/false value, off by default.
  
  =item indent
  
  Should the structures being dumped be indented. This value is numeric,
  with the number representing the number of spaces to use when indenting
  the dumper output. Set to '2' by default.
  
  =item class
  
  Should the dumper print the full class for each element.
  True/false value, on by default.
  
  =item content
  
  Should the dumper show the content of each element. True/false value,
  on by default.
  
  =item whitespace
  
  Should the dumper show whitespace tokens. By not showing the copious
  numbers of whitespace tokens the structure of the code can often be
  made much clearer. True/false value, on by default.
  
  =item comments
  
  Should the dumper show comment tokens. In situations where you have
  a lot of comments, the code can often be made clearer by ignoring
  comment tokens. True/false value, on by default.
  
  =item locations
  
  Should the dumper show the location of each token. The values shown are
  [ line, rowchar, column ]. See L<PPI::Element/"location"> for a description of
  what these values really are. True/false value, off by default.
  
  =back
  
  =cut
  
  sub new {
  	my $class   = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  
  	# Create the object
  	my $self = bless {
  		root    => $Element,
  		display => {
  			memaddr    => '', # Show the refaddr of the item
  			indent     => 2,  # Indent the structures
  			class      => 1,  # Show the object class
  			content    => 1,  # Show the object contents
  			whitespace => 1,  # Show whitespace tokens
  			comments   => 1,  # Show comment tokens
  			locations  => 0,  # Show token locations
  			},
  		}, $class;
  
  	# Handle the options
  	my @options = map { lc $_ } @_; # strict hashpairs # https://github.com/adamkennedy/PPI/issues/201
  	my %options = @options;
  	foreach ( keys %{$self->{display}} ) {
  		if ( exists $options{$_} ) {
  			if ( $_ eq 'indent' ) {
  				$self->{display}->{indent} = $options{$_};
  			} else {
  				$self->{display}->{$_} = !! $options{$_};
  			}
  		}
  	}
  
  	$self->{indent_string} = join '', (' ' x $self->{display}->{indent});
  
  	$self;
  }
  
  
  
  
  
  #####################################################################
  # Main Interface Methods
  
  =pod
  
  =head2 print
  
  The C<print> method generates the dump and prints it to STDOUT.
  
  Returns as for the internal print function.
  
  =cut
  
  sub print {
  	CORE::print(shift->string);
  }
  
  =pod
  
  =head2 string
  
  The C<string> method generates the dump and provides it as a
  single string.
  
  Returns a string or undef if there is an error while generating the dump. 
  
  =cut
  
  sub string {
  	my $array_ref = shift->_dump or return undef;
  	join '', map { "$_\n" } @$array_ref;
  }
  
  =pod
  
  =head2 list
  
  The C<list> method generates the dump and provides it as a raw
  list, without trailing newlines.
  
  Returns a list or the null list if there is an error while generating
  the dump.
  
  =cut
  
  sub list {
  	my $array_ref = shift->_dump or return ();
  	@$array_ref;
  }
  
  
  
  
  
  #####################################################################
  # Generation Support Methods
  
  sub _dump {
  	my $self    = ref $_[0] ? shift : shift->new(shift);
  	my $Element = _INSTANCE($_[0], 'PPI::Element') ? shift : $self->{root};
  	my $indent  = shift || '';
  	my $output  = shift || [];
  
  	# Print the element if needed
  	my $show = 1;
  	if ( $Element->isa('PPI::Token::Whitespace') ) {
  		$show = 0 unless $self->{display}->{whitespace};
  	} elsif ( $Element->isa('PPI::Token::Comment') ) {
  		$show = 0 unless $self->{display}->{comments};
  	}
  	push @$output, $self->_element_string( $Element, $indent ) if $show;
  
  	# Recurse into our children
  	if ( $Element->isa('PPI::Node') ) {
  		my $child_indent = $indent . $self->{indent_string};
  		foreach my $child ( @{$Element->{children}} ) {
  			$self->_dump( $child, $child_indent, $output );
  		}
  	}
  
  	$output;
  }
  
  sub _element_string {
  	my $self    = ref $_[0] ? shift : shift->new(shift);
  	my $Element = _INSTANCE($_[0], 'PPI::Element') ? shift : $self->{root};
  	my $indent  = shift || '';
  	my $string  = '';
  
  	# Add the memory location
  	if ( $self->{display}->{memaddr} ) {
  		$string .= $Element->refaddr . '  ';
  	}
          
          # Add the location if such exists
  	if ( $self->{display}->{locations} ) {
  		my $loc_string;
  		if ( $Element->isa('PPI::Token') ) {
  			my $location = $Element->location;
  			if ($location) {
  				$loc_string = sprintf("[ % 4d, % 3d, % 3d ] ", @$location);
  			}
  		}
  		# Output location or pad with 20 spaces
  		$string .= $loc_string || " " x 20;
  	}
          
  	# Add the indent
  	if ( $self->{display}->{indent} ) {
  		$string .= $indent;
  	}
  
  	# Add the class name
  	if ( $self->{display}->{class} ) {
  		$string .= ref $Element;
  	}
  
  	if ( $Element->isa('PPI::Token') ) {
  		# Add the content
  		if ( $self->{display}->{content} ) {
  			my $content = $Element->content;
  			$content =~ s/\n/\\n/g;
  			$content =~ s/\t/\\t/g;
  			$content =~ s/\f/\\f/g;
  			$string .= "  \t'$content'";
  		}
  
  	} elsif ( $Element->isa('PPI::Structure') ) {
  		# Add the content
  		if ( $self->{display}->{content} ) {
  			my $start = $Element->start
  				? $Element->start->content
  				: '???';
  			my $finish = $Element->finish
  				? $Element->finish->content
  				: '???';
  			$string .= "  \t$start ... $finish";
  		}
  	}
  	
  	$string;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;
  
  =pod
  
  =head1 NAME
  
  PPI::Element - The abstract Element class, a base for all source objects
  
  =head1 INHERITANCE
  
    PPI::Element is the root of the PDOM tree
  
  =head1 DESCRIPTION
  
  The abstract C<PPI::Element> serves as a base class for all source-related
  objects, from a single whitespace token to an entire document. It provides
  a basic set of methods to provide a common interface and basic
  implementations.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Clone           ();
  use Scalar::Util    qw{refaddr};
  use Params::Util    qw{_INSTANCE _ARRAY};
  use List::MoreUtils ();
  use PPI::Util       ();
  use PPI::Node       ();
  
  use vars qw{$VERSION $errstr %_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	$errstr  = '';
  
  	# Master Child -> Parent index
  	%_PARENT = ();
  }
  
  use overload 'bool' => \&PPI::Util::TRUE;
  use overload '""'   => 'content';
  use overload '=='   => '__equals';
  use overload '!='   => '__nequals';
  use overload 'eq'   => '__eq';
  use overload 'ne'   => '__ne';
  
  
  
  
  
  #####################################################################
  # General Properties
  
  =pod
  
  =head2 significant
  
  Because we treat whitespace and other non-code items as Tokens (in order to
  be able to "round trip" the L<PPI::Document> back to a file) the
  C<significant> method allows us to distinguish between tokens that form a
  part of the code, and tokens that aren't significant, such as whitespace,
  POD, or the portion of a file after (and including) the C<__END__> token.
  
  Returns true if the Element is significant, or false it not.
  
  =cut
  
  ### XS -> PPI/XS.xs:_PPI_Element__significant 0.845+
  sub significant() { 1 }
  
  =pod
  
  =head2 class
  
  The C<class> method is provided as a convenience, and really does nothing
  more than returning C<ref($self)>. However, some people have found that
  they appreciate the laziness of C<$Foo-E<gt>class eq 'whatever'>, so I
  have caved to popular demand and included it.
  
  Returns the class of the Element as a string
  
  =cut
  
  sub class { ref($_[0]) }
  
  =pod
  
  =head2 tokens
  
  The C<tokens> method returns a list of L<PPI::Token> objects for the
  Element, essentially getting back that part of the document as if it had
  not been lexed.
  
  This also means there are no Statements and no Structures in the list,
  just the Token classes.
  
  =cut
  
  sub tokens { $_[0] }
  
  =pod
  
  =head2 content
  
  For B<any> C<PPI::Element>, the C<content> method will reconstitute the
  base code for it as a single string. This method is also the method used
  for overloading stringification. When an Element is used in a double-quoted
  string for example, this is the method that is called.
  
  B<WARNING:>
  
  You should be aware that because of the way that here-docs are handled, any
  here-doc content is not included in C<content>, and as such you should
  B<not> eval or execute the result if it contains any L<PPI::Token::HereDoc>.
  
  The L<PPI::Document> method C<serialize> should be used to stringify a PDOM
  document into something that can be executed as expected.
  
  Returns the basic code as a string (excluding here-doc content).
  
  =cut
  
  ### XS -> PPI/XS.xs:_PPI_Element__content 0.900+
  sub content() { '' }
  
  
  
  
  
  #####################################################################
  # Navigation Methods
  
  =pod
  
  =head2 parent
  
  Elements themselves are not intended to contain other Elements, that is
  left to the L<PPI::Node> abstract class, a subclass of C<PPI::Element>.
  However, all Elements can be contained B<within> a parent Node.
  
  If an Element is within a parent Node, the C<parent> method returns the
  Node.
  
  =cut
  
  sub parent { $_PARENT{refaddr $_[0]} }
  
  =pod
  
  =head2 descendant_of $element
  
  Answers whether a C<PPI::Element> is contained within another one.
  
  C<PPI::Element>s are considered to be descendants of themselves.
  
  =cut
  
  sub descendant_of {
  	my $cursor = shift;
  	my $parent = shift or return undef;
  	while ( refaddr $cursor != refaddr $parent ) {
  		$cursor = $_PARENT{refaddr $cursor} or return '';
  	}
  	return 1;
  }
  
  =pod
  
  =head2 ancestor_of $element
  
  Answers whether a C<PPI::Element> is contains another one.
  
  C<PPI::Element>s are considered to be ancestors of themselves.
  
  =cut
  
  sub ancestor_of {
  	my $self   = shift;
  	my $cursor = shift or return undef;
  	while ( refaddr $cursor != refaddr $self ) {
  		$cursor = $_PARENT{refaddr $cursor} or return '';
  	}
  	return 1;
  }
  
  =pod
  
  =head2 statement
  
  For a C<PPI::Element> that is contained (at some depth) within a
  L<PPI::Statement>, the C<statement> method will return the first parent
  Statement object lexically 'above' the Element.
  
  Returns a L<PPI::Statement> object, which may be the same Element if the
  Element is itself a L<PPI::Statement> object.
  
  Returns false if the Element is not within a Statement and is not itself
  a Statement.
  
  =cut
  
  sub statement {
  	my $cursor = shift;
  	while ( ! _INSTANCE($cursor, 'PPI::Statement') ) {
  		$cursor = $_PARENT{refaddr $cursor} or return '';
  	}
  	$cursor;
  }
  
  =pod
  
  =head2 top
  
  For a C<PPI::Element> that is contained within a PDOM tree, the C<top> method
  will return the top-level Node in the tree. Most of the time this should be
  a L<PPI::Document> object, however this will not always be so. For example,
  if a subroutine has been removed from its Document, to be moved to another
  Document.
  
  Returns the top-most PDOM object, which may be the same Element, if it is
  not within any parent PDOM object.
  
  =cut
  
  sub top {
  	my $cursor = shift;
  	while ( my $parent = $_PARENT{refaddr $cursor} ) {
  		$cursor = $parent;
  	}
  	$cursor;
  }
  
  =pod
  
  =head2 document
  
  For an Element that is contained within a L<PPI::Document> object,
  the C<document> method will return the top-level Document for the Element.
  
  Returns the L<PPI::Document> for this Element, or false if the Element is not
  contained within a Document.
  
  =cut
  
  sub document {
  	my $top = shift->top;
  	_INSTANCE($top, 'PPI::Document') and $top;
  }
  
  =pod
  
  =head2 next_sibling
  
  All L<PPI::Node> objects (specifically, our parent Node) contain a number of
  C<PPI::Element> objects. The C<next_sibling> method returns the C<PPI::Element>
  immediately after the current one, or false if there is no next sibling.
  
  =cut
  
  sub next_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	$elements->[$position + 1] || '';
  }
  
  =pod
  
  =head2 snext_sibling
  
  As per the other 's' methods, the C<snext_sibling> method returns the next
  B<significant> sibling of the C<PPI::Element> object.
  
  Returns a C<PPI::Element> object, or false if there is no 'next' significant
  sibling.
  
  =cut
  
  sub snext_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	while ( defined(my $it = $elements->[++$position]) ) {
  		return $it if $it->significant;
  	}
  	'';
  }
  
  =pod
  
  =head2 previous_sibling
  
  All L<PPI::Node> objects (specifically, our parent Node) contain a number of
  C<PPI::Element> objects. The C<previous_sibling> method returns the Element
  immediately before the current one, or false if there is no 'previous'
  C<PPI::Element> object.
  
  =cut
  
  sub previous_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	$position and $elements->[$position - 1] or '';
  }
  
  =pod
  
  =head2 sprevious_sibling
  
  As per the other 's' methods, the C<sprevious_sibling> method returns
  the previous B<significant> sibling of the C<PPI::Element> object.
  
  Returns a C<PPI::Element> object, or false if there is no 'previous' significant
  sibling.
  
  =cut
  
  sub sprevious_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	while ( $position-- and defined(my $it = $elements->[$position]) ) {
  		return $it if $it->significant;
  	}
  	'';
  }
  
  =pod
  
  =head2 first_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<first_token> method finds the first
  PPI::Token object within or equal to this one.
  
  That is, if called on a L<PPI::Node> subclass, it will descend until it
  finds a L<PPI::Token>. If called on a L<PPI::Token> object, it will return
  the same object.
  
  Returns a L<PPI::Token> object, or dies on error (which should be extremely
  rare and only occur if an illegal empty L<PPI::Statement> exists below the
  current Element somewhere.)
  
  =cut
  
  sub first_token {
  	my $cursor = shift;
  	while ( $cursor->isa('PPI::Node') ) {
  		$cursor = $cursor->first_element
  		or die "Found empty PPI::Node while getting first token";
  	}
  	$cursor;
  }
  
  
  =pod
  
  =head2 last_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<last_token> method finds the last
  PPI::Token object within or equal to this one.
  
  That is, if called on a L<PPI::Node> subclass, it will descend until it
  finds a L<PPI::Token>. If called on a L<PPI::Token> object, it will return
  the itself.
  
  Returns a L<PPI::Token> object, or dies on error (which should be extremely
  rare and only occur if an illegal empty L<PPI::Statement> exists below the
  current Element somewhere.)
  
  =cut
  
  sub last_token {
  	my $cursor = shift;
  	while ( $cursor->isa('PPI::Node') ) {
  		$cursor = $cursor->last_element
  		or die "Found empty PPI::Node while getting first token";
  	}
  	$cursor;
  }
  
  =pod
  
  =head2 next_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<next_token> method finds the
  L<PPI::Token> object that is immediately after the current Element, even if
  it is not within the same parent L<PPI::Node> as the one for which the
  method is being called.
  
  Note that this is B<not> defined as a L<PPI::Token>-specific method,
  because it can be useful to find the next token that is after, say, a
  L<PPI::Statement>, although obviously it would be useless to want the
  next token after a L<PPI::Document>.
  
  Returns a L<PPI::Token> object, or false if there are no more tokens after
  the Element.
  
  =cut
  
  sub next_token {
  	my $cursor = shift;
  
  	# Find the next element, going upwards as needed
  	while ( 1 ) {
  		my $element = $cursor->next_sibling;
  		if ( $element ) {
  			return $element if $element->isa('PPI::Token');
  			return $element->first_token;
  		}
  		$cursor = $cursor->parent or return '';
  		if ( $cursor->isa('PPI::Structure') and $cursor->finish ) {
  			return $cursor->finish;
  		}
  	}
  }
  
  =pod
  
  =head2 previous_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<previous_token> method finds the
  L<PPI::Token> object that is immediately before the current Element, even
  if it is not within the same parent L<PPI::Node> as this one.
  
  Note that this is not defined as a L<PPI::Token>-only method, because it can
  be useful to find the token is before, say, a L<PPI::Statement>, although
  obviously it would be useless to want the next token before a
  L<PPI::Document>.
  
  Returns a L<PPI::Token> object, or false if there are no more tokens before
  the C<Element>.
  
  =cut
  
  sub previous_token {
  	my $cursor = shift;
  
  	# Find the previous element, going upwards as needed
  	while ( 1 ) {
  		my $element = $cursor->previous_sibling;
  		if ( $element ) {
  			return $element if $element->isa('PPI::Token');
  			return $element->last_token;
  		}
  		$cursor = $cursor->parent or return '';
  		if ( $cursor->isa('PPI::Structure') and $cursor->start ) {
  			return $cursor->start;
  		}
  	}
  }
  
  
  
  
  
  #####################################################################
  # Manipulation
  
  =pod
  
  =head2 clone
  
  As per the L<Clone> module, the C<clone> method makes a perfect copy of
  an Element object. In the generic case, the implementation is done using
  the L<Clone> module's mechanism itself. In higher-order cases, such as for
  Nodes, there is more work involved to keep the parent-child links intact.
  
  =cut
  
  sub clone {
  	Clone::clone(shift);
  }
  
  =pod
  
  =head2 insert_before @Elements
  
  The C<insert_before> method allows you to insert lexical perl content, in
  the form of C<PPI::Element> objects, before the calling C<Element>. You
  need to be very careful when modifying perl code, as it's easy to break
  things.
  
  In its initial incarnation, this method allows you to insert a single
  Element, and will perform some basic checking to prevent you inserting
  something that would be structurally wrong (in PDOM terms).
  
  In future, this method may be enhanced to allow the insertion of multiple
  Elements, inline-parsed code strings or L<PPI::Document::Fragment> objects.
  
  Returns true if the Element was inserted, false if it can not be inserted,
  or C<undef> if you do not provide a C<PPI::Element> object as a parameter.
  
  =cut
  
  sub __insert_before {
  	my $self = shift;
  	$self->parent->__insert_before_child( $self, @_ );
  }
  
  =pod
  
  =head2 insert_after @Elements
  
  The C<insert_after> method allows you to insert lexical perl content, in
  the form of C<PPI::Element> objects, after the calling C<Element>. You need
  to be very careful when modifying perl code, as it's easy to break things.
  
  In its initial incarnation, this method allows you to insert a single
  Element, and will perform some basic checking to prevent you inserting
  something that would be structurally wrong (in PDOM terms).
  
  In future, this method may be enhanced to allow the insertion of multiple
  Elements, inline-parsed code strings or L<PPI::Document::Fragment> objects.
  
  Returns true if the Element was inserted, false if it can not be inserted,
  or C<undef> if you do not provide a C<PPI::Element> object as a parameter.
  
  =cut
  
  sub __insert_after {
  	my $self = shift;
  	$self->parent->__insert_after_child( $self, @_ );
  }
  
  =pod
  
  =head2 remove
  
  For a given C<PPI::Element>, the C<remove> method will remove it from its
  parent B<intact>, along with all of its children.
  
  Returns the C<Element> itself as a convenience, or C<undef> if an error
  occurs while trying to remove the C<Element>.
  
  =cut
  
  sub remove {
  	my $self   = shift;
  	my $parent = $self->parent or return $self;
  	$parent->remove_child( $self );
  }
  
  =pod
  
  =head2 delete
  
  For a given C<PPI::Element>, the C<delete> method will remove it from its
  parent, immediately deleting the C<Element> and all of its children (if it
  has any).
  
  Returns true if the C<Element> was successfully deleted, or C<undef> if
  an error occurs while trying to remove the C<Element>.
  
  =cut
  
  sub delete {
  	$_[0]->remove or return undef;
  	$_[0]->DESTROY;
  	1;
  }
  
  =pod
  
  =head2 replace $Element
  
  Although some higher level class support more exotic forms of replace,
  at the basic level the C<replace> method takes a single C<Element> as
  an argument and replaces the current C<Element> with it.
  
  To prevent accidental damage to code, in this initial implementation the
  replacement element B<must> be of the same class (or a subclass) as the
  one being replaced.
  
  =cut
  
  sub replace {
  	my $self    = ref $_[0] ? shift : return undef;
  	_INSTANCE(shift, ref $self) or return undef;
  	die "The ->replace method has not yet been implemented";
  }
  
  =pod
  
  =head2 location
  
  If the Element exists within a L<PPI::Document> that has
  indexed the Element locations using C<PPI::Document::index_locations>, the
  C<location> method will return the location of the first character of the
  Element within the Document.
  
  Returns the location as a reference to a five-element array in the form C<[
  $line, $rowchar, $col, $logical_line, $logical_file_name ]>. The values are in
  a human format, with the first character of the file located at C<[ 1, 1, 1, ?,
  'something' ]>.
  
  The second and third numbers are similar, except that the second is the
  literal horizontal character, and the third is the visual column, taking
  into account tabbing (see L<PPI::Document/"tab_width [ $width ]">).
  
  The fourth number is the line number, taking into account any C<#line>
  directives.  The fifth element is the name of the file that the element was
  found in, if available, taking into account any C<#line> directives.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub location {
  	my $self = shift;
  
  	$self->_ensure_location_present or return undef;
  
  	# Return a copy, not the original
  	return [ @{$self->{_location}} ];
  }
  
  =pod
  
  =head2 line_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<line_number> method
  will return the line number of the first character of the Element within the
  Document.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub line_number {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[0];
  }
  
  =pod
  
  =head2 column_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<column_number> method
  will return the column number of the first character of the Element within the
  Document.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub column_number {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[1];
  }
  
  =pod
  
  =head2 visual_column_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<visual_column_number>
  method will return the visual column number of the first character of the
  Element within the Document, according to the value of
  L<PPI::Document/"tab_width [ $width ]">.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub visual_column_number {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[2];
  }
  
  =pod
  
  =head2 logical_line_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<logical_line_number>
  method will return the line number of the first character of the Element within
  the Document, taking into account any C<#line> directives.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub logical_line_number {
  	my $self = shift;
  
  	return $self->location()->[3];
  }
  
  =pod
  
  =head2 logical_filename
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<logical_filename>
  method will return the logical file name containing the first character of the
  Element within the Document, taking into account any C<#line> directives.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub logical_filename {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[4];
  }
  
  sub _ensure_location_present {
  	my $self = shift;
  
  	unless ( exists $self->{_location} ) {
  		# Are we inside a normal document?
  		my $Document = $self->document or return undef;
  		if ( $Document->isa('PPI::Document::Fragment') ) {
  			# Because they can't be serialized, document fragments
  			# do not support the concept of location.
  			return undef;
  		}
  
  		# Generate the locations. If they need one location, then
  		# the chances are they'll want more, and it's better that
  		# everything is already pre-generated.
  		$Document->index_locations or return undef;
  		unless ( exists $self->{_location} ) {
  			# erm... something went very wrong here
  			return undef;
  		}
  	}
  
  	return 1;
  }
  
  # Although flush_locations is only publically a Document-level method,
  # we are able to implement it at an Element level, allowing us to
  # selectively flush only the part of the document that occurs after the
  # element for which the flush is called.
  sub _flush_locations {
  	my $self  = shift;
  	unless ( $self == $self->top ) {
  		return $self->top->_flush_locations( $self );
  	}
  
  	# Get the full list of all Tokens
  	my @Tokens = $self->tokens;
  
  	# Optionally allow starting from an arbitrary element (or rather,
  	# the first Token equal-to-or-within an arbitrary element)
  	if ( _INSTANCE($_[0], 'PPI::Element') ) {
  		my $start = shift->first_token;
  		while ( my $Token = shift @Tokens ) {
  			return 1 unless $Token->{_location};
  			next unless refaddr($Token) == refaddr($start);
  
  			# Found the start. Flush it's location
  			delete $$Token->{_location};
  			last;
  		}
  	}
  
  	# Iterate over any remaining Tokens and flush their location
  	foreach my $Token ( @Tokens ) {
  		delete $Token->{_location};
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # XML Compatibility Methods
  
  sub _xml_name {
  	my $class = ref $_[0] || $_[0];
  	my $name  = lc join( '_', split /::/, $class );
  	substr($name, 4);
  }
  
  sub _xml_attr {
  	return {};
  }
  
  sub _xml_content {
  	defined $_[0]->{content} ? $_[0]->{content} : '';
  }
  
  
  
  
  
  #####################################################################
  # Internals
  
  # Set the error string
  sub _error {
  	$errstr = $_[1];
  	undef;
  }
  
  # Clear the error string
  sub _clear {
  	$errstr = '';
  	$_[0];
  }
  
  # Being DESTROYed in this manner, rather than by an explicit
  # ->delete means our reference count has probably fallen to zero.
  # Therefore we don't need to remove ourselves from our parent,
  # just the index ( just in case ).
  ### XS -> PPI/XS.xs:_PPI_Element__DESTROY 0.900+
  sub DESTROY { delete $_PARENT{refaddr $_[0]} }
  
  # Operator overloads
  sub __equals  { ref $_[1] and refaddr($_[0]) == refaddr($_[1]) }
  sub __nequals { !__equals(@_) }
  sub __eq {
  	my $self  = _INSTANCE($_[0], 'PPI::Element') ? $_[0]->content : $_[0];
  	my $other = _INSTANCE($_[1], 'PPI::Element') ? $_[1]->content : $_[1];
  	$self eq $other;
  }
  sub __ne { !__eq(@_) }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  It would be nice if C<location> could be used in an ad-hoc manner. That is,
  if called on an Element within a Document that has not been indexed, it will
  do a one-off calculation to find the location. It might be very painful if
  someone started using it a lot, without remembering to index the document,
  but it would be handy for things that are only likely to use it once, such
  as error handlers.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;
  
  =head1 NAME
  
  PPI::Exception - The PPI exception base class
  
  =head1 SYNOPSIS
  
    use PPI::Exception;
    
    my $e = PPI::Exception->new( 'something happened' );
    $e->throw;
  
    PPI::Exception->new( message => 'something happened' )->throw;
    PPI::Exception->throw( message => 'something happened' );
  
  =head1 DESCRIPTION
  
  All exceptions thrown from within PPI will be instances or derivations
  of this class.
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  =head1 METHODS
  
  =head2 new $message | message => $message, ...
  
  Constructs and returns a new C<PPI::Exception> object.
  
  A message for the exception can be passed, either as a string
  or as C<< message => $message >>. The message is available via the
  C<message> method.
  
  =cut
  
  sub new {
  	my $class = shift;
  	return bless { @_ }, $class if @_ > 1;
  	return bless { message => $_[0] }, $class if @_;
  	return bless { message => 'Unknown Exception' }, $class;
  }
  
  
  =head2 throw
  
  If called on a C<PPI::Exception> object, throws the object.
  If called on the class name, uses the arguments to construct a
  C<PPI::Exception> and then throw it.
  
  Each time the object is thrown, information from the Perl <caller(0)>
  call is saved and made available via the C<callers> method.
  
  This method never returns.
  
  =cut
  
  sub throw {
  	my $it = shift;
  	if ( _INSTANCE($it, 'PPI::Exception') ) {
  		if ( $it->{callers} ) {
  			push @{ $it->{callers} }, [ caller(0) ];
  		} else {
  			$it->{callers} ||= [];
  		}
  	} else {
  		my $message = $_[0] || 'Unknown Exception';
  		$it = $it->new(
  			message => $message,
  			callers => [
  				[ caller(0) ],
  			],
  		);
  	}
  	die $it;
  }
  
  
  =head2 message
  
  Returns the exception message passed to the object's constructor,
  or a default message.
  
  =cut
  
  sub message {
  	$_[0]->{message};
  }
  
  
  =head2 callers
  
  Returns a listref, each element of which is a listref of C<caller(0)>
  information.  The returned listref can be empty.
  
  =cut
  
  sub callers {
  	@{ $_[0]->{callers} || [] };
  }
  
  
  1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;
  
  use strict;
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Exception';
  }
  
  1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;
  
  =pod
  
  =head1 NAME
  
  PPI::Find - Object version of the Element->find method
  
  =head1 SYNOPSIS
  
    # Create the Find object
    my $Find = PPI::Find->new( \&wanted );
    
    # Return all matching Elements as a list
    my @found = $Find->in( $Document );
    
    # Can we find any matching Elements
    if ( $Find->any_matches($Document) ) {
    	print "Found at least one matching Element";
    }
    
    # Use the object as an iterator
    $Find->start($Document) or die "Failed to execute search";
    while ( my $token = $Find->match ) {
    	...
    }
  
  =head1 DESCRIPTION
  
  PPI::Find is the primary PDOM searching class in the core PPI package.
  
  =head2 History
  
  It became quite obvious during the development of PPI that many of the
  modules that would be built on top of it were going to need large numbers
  of saved, storable or easily creatable search objects that could be
  reused a number of times.
  
  Although the internal ->find method provides a basic ability to search,
  it is by no means thorough. PPI::Find attempts to resolve this problem.
  
  =head2 Structure and Style
  
  PPI::Find provides a similar API to the popular L<File::Find::Rule>
  module for file searching, but without the ability to assemble queries.
  
  The implementation of a separate PPI::Find::Rule sub-class that does
  provide this ability is left as an exercise for the reader.
  
  =head2 The &wanted function
  
  At the core of each PPI::Find object is a "wanted" function that is
  passed a number of arguments and returns a value which controls the
  flow of the search.
  
  As the search executes, each Element will be passed to the wanted function
  in depth-first order.
  
  It will be provided with two arguments. The current Element to test as $_[0],
  and the top-level Element of the search as $_[1].
  
  The &wanted function is expected to return 1 (positive) if the Element
  matches the condition, 0 (false) if it does not, and undef (undefined) if
  the condition does not match, and the Find search should not descend to
  any of the current Element's children.
  
  Errors should be reported from the &wanted function via die, which will be
  caught by the Find object and returned as an error.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new &wanted
  
  The C<new> constructor takes a single argument of the &wanted function,
  as described above and creates a new search.
  
  Returns a new PPI::Find object, or C<undef> if not passed a CODE reference.
  
  =cut
  
  sub new {
  	my $class  = ref $_[0] ? ref shift : shift;
  	my $wanted = ref $_[0] eq 'CODE' ? shift : return undef;
  
  	# Create the object
  	my $self = bless {
  		wanted => $wanted,
  	}, $class;
  
  	$self;
  }
  
  =pod
  
  =head2 clone
  
  The C<clone> method creates another instance of the same Find object.
  
  The cloning is done safely, so if your existing Find object is in the
  middle of an iteration, the cloned Find object will not also be in the
  iteration and can be safely used independently.
  
  Returns a duplicate PPI::Find object.
  
  =cut
  
  sub clone {
  	my $self = ref $_[0] ? shift
  		: die "->clone can only be called as an object method";
  	my $class = ref $self;
  
  	# Create the object
  	my $clone = bless {
  		wanted => $self->{wanted},
  	}, $class;
  
  	$clone;
  }
  
  
  
  
  
  ####################################################################
  # Search Execution Methods
  
  =pod
  
  =head2 in $Document [, array_ref => 1 ]
  
  The C<in> method starts and completes a full run of the search.
  
  It takes as argument a single L<PPI::Element> object which will
  serve as the top of the search process.
  
  Returns a list of PPI::Element objects that match the condition
  described by the &wanted function, or the null list on error.
  
  You should check the ->errstr method for any errors if you are
  returned the null list, which may also mean simply that no Elements
  were found that matched the condition.
  
  Because of this need to explicitly check for errors, an alternative
  return value mechanism is provide. If you pass the C<< array_ref => 1 >>
  parameter to the method, it will return the list of matched Elements
  as a reference to an ARRAY. The method will return false if no elements
  were matched, or C<undef> on error.
  
  The ->errstr method can still be used to get the error message as normal.
  
  =cut
  
  sub in {
  	my $self    = shift;
  	my $Element = shift;
  	my %params  = @_;
  	delete $self->{errstr};
   
  	# Are we already acting as an iterator
  	if ( $self->{in} ) {
  		return $self->_error('->in called while another search is in progress', %params);
  	}
  
  	# Get the root element for the search
  	unless ( _INSTANCE($Element, 'PPI::Element') ) {
  		return $self->_error('->in was not passed a PPI::Element object', %params);
  	}
  
  	# Prepare the search
  	$self->{in}      = $Element;
  	$self->{matches} = [];
  
  	# Execute the search
  	if ( !eval { $self->_execute; 1 } ) {
  		my $errstr = $@;
  		$errstr =~ s/\s+at\s+line\s+.+$//;
  		return $self->_error("Error while searching: $errstr", %params);
  	}
  
  	# Clean up and return
  	delete $self->{in};
  	if ( $params{array_ref} ) {
  		if ( @{$self->{matches}} ) {
  			return delete $self->{matches};
  		}
  		delete $self->{matches};
  		return '';
  	}
  
  	# Return as a list
  	my $matches = delete $self->{matches};
  	@$matches;
  }
  
  =pod
  
  =head2 start $Element
  
  The C<start> method lets the Find object act as an iterator. The method
  is passed the parent PPI::Element object as for the C<in> method, but does
  not accept any parameters.
  
  To simplify error handling, the entire search is done at once, with the
  results cached and provided as-requested.
  
  Returns true if the search completes, and false on error.
  
  =cut
  
  sub start {
  	my $self    = shift;
  	my $Element = shift;
  	delete $self->{errstr};
  
  	# Are we already acting as an iterator
  	if ( $self->{in} ) {
  		return $self->_error('->in called while another search is in progress');
  	}
  
  	# Get the root element for the search
  	unless ( _INSTANCE($Element, 'PPI::Element') ) {
  		return $self->_error('->in was not passed a PPI::Element object');
  	}
  
  	# Prepare the search
  	$self->{in}      = $Element;
  	$self->{matches} = [];
  
  	# Execute the search
  	if ( !eval { $self->_execute; 1 } ) {
  		my $errstr = $@;
  		$errstr =~ s/\s+at\s+line\s+.+$//;
  		$self->_error("Error while searching: $errstr");
  		return undef;
  	}
  
  	1;
  }
  
  =pod
  
  =head2 match
  
  The C<match> method returns the next matching Element in the iteration.
  
  Returns a PPI::Element object, or C<undef> if there are no remaining
  Elements to be returned.
  
  =cut
  
  sub match {
  	my $self = shift;
  	return undef unless $self->{matches};
  
  	# Fetch and return the next match
  	my $match = shift @{$self->{matches}};
  	return $match if $match;
  
  	$self->finish;
  	undef;
  }
  
  =pod
  
  =head2 finish
  
  The C<finish> method provides a mechanism to end iteration if you wish to
  stop the iteration prematurely. It resets the Find object and allows it to
  be safely reused.
  
  A Find object will be automatically finished when C<match> returns false.
  This means you should only need to call C<finish> when you stop
  iterating early.
  
  You may safely call this method even when not iterating and it will return
  without failure.
  
  Always returns true
  
  =cut
  
  sub finish {
  	my $self = shift;
  	delete $self->{in};
  	delete $self->{matches};
  	delete $self->{errstr};
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Support Methods and Error Handling
  
  sub _execute {
  	my $self   = shift;
  	my $wanted = $self->{wanted};
  	my @queue  = ( $self->{in} );
  
  	# Pull entries off the queue and hand them off to the wanted function
  	while ( my $Element = shift @queue ) {
  		my $rv = &$wanted( $Element, $self->{in} );
  
  		# Add to the matches if returns true
  		push @{$self->{matches}}, $Element if $rv;
  
  		# Continue and don't descend if it returned undef
  		# or if it doesn't have children
  		next unless defined $rv;
  		next unless $Element->isa('PPI::Node');
  
  		# Add the children to the head of the queue
  		if ( $Element->isa('PPI::Structure') ) {
  			unshift @queue, $Element->finish if $Element->finish;
  			unshift @queue, $Element->children;
  			unshift @queue, $Element->start if $Element->start;
  		} else {
  			unshift @queue, $Element->children;
  		}
  	}
  
  	1;
  }
  
  =pod
  
  =head2 errstr
  
  The C<errstr> method returns the error messages when a given PPI::Find
  object fails any action.
  
  Returns a string, or C<undef> if there is no error.
  
  =cut
  
  sub errstr {
  	shift->{errstr};
  }
  
  sub _error {
  	my $self = shift;
  	$self->{errstr} = shift;
  	my %params = @_;
  	$params{array_ref} ? undef : ();
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Implement the L<PPI::Find::Rule> class
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;
  
  =pod
  
  =head1 NAME
  
  PPI::Lexer - The PPI Lexer
  
  =head1 SYNOPSIS
  
    use PPI;
    
    # Create a new Lexer
    my $Lexer = PPI::Lexer->new;
    
    # Build a PPI::Document object from a Token stream
    my $Tokenizer = PPI::Tokenizer->load('My/Module.pm');
    my $Document = $Lexer->lex_tokenizer($Tokenizer);
    
    # Build a PPI::Document object for some raw source
    my $source = "print 'Hello World!'; kill(Humans->all);";
    $Document = $Lexer->lex_source($source);
    
    # Build a PPI::Document object for a particular file name
    $Document = $Lexer->lex_file('My/Module.pm');
  
  =head1 DESCRIPTION
  
  The is the L<PPI> Lexer. In the larger scheme of things, its job is to take
  token streams, in a variety of forms, and "lex" them into nested structures.
  
  Pretty much everything in this module happens behind the scenes at this
  point. In fact, at the moment you don't really need to instantiate the lexer
  at all, the three main methods will auto-instantiate themselves a
  C<PPI::Lexer> object as needed.
  
  All methods do a one-shot "lex this and give me a L<PPI::Document> object".
  
  In fact, if you are reading this, what you B<probably> want to do is to
  just "load a document", in which case you can do this in a much more
  direct and concise manner with one of the following.
  
    use PPI;
    
    $Document = PPI::Document->load( $filename );
    $Document = PPI::Document->new( $string );
  
  See L<PPI::Document> for more details.
  
  For more unusual tasks, by all means forge onwards.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Scalar::Util    ();
  use Params::Util    qw{_STRING _INSTANCE};
  use List::MoreUtils ();
  use PPI             ();
  use PPI::Exception  ();
  
  use vars qw{$VERSION $errstr *_PARENT %ROUND %RESOLVE};
  BEGIN {
  	$VERSION = '1.236';
  	$errstr  = '';
  
  	# Faster than having another method call just
  	# to set the structure finish token.
  	*_PARENT = *PPI::Element::_PARENT;
  
  	# Keyword -> Structure class maps
  	%ROUND = (
  		# Conditions
  		'if'     => 'PPI::Structure::Condition',
  		'elsif'  => 'PPI::Structure::Condition',
  		'unless' => 'PPI::Structure::Condition',
  		'while'  => 'PPI::Structure::Condition',
  		'until'  => 'PPI::Structure::Condition',
  
  		# For(each)
  		'for'     => 'PPI::Structure::For',
  		'foreach' => 'PPI::Structure::For',
  	);
  
  	# Opening brace to refining method
  	%RESOLVE = (
  		'(' => '_round',
  		'[' => '_square',
  		'{' => '_curly',
  	);
  
  }
  
  # Allows for experimental overriding of the tokenizer
  use vars qw{ $X_TOKENIZER };
  BEGIN {
  	$X_TOKENIZER ||= 'PPI::Tokenizer';
  }
  use constant X_TOKENIZER => $X_TOKENIZER;
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new
  
  The C<new> constructor creates a new C<PPI::Lexer> object. The object itself
  is merely used to hold various buffers and state data during the lexing
  process, and holds no significant data between -E<gt>lex_xxxxx calls.
  
  Returns a new C<PPI::Lexer> object
  
  =cut
  
  sub new {
  	my $class = shift->_clear;
  	bless {
  		Tokenizer => undef, # Where we store the tokenizer for a run
  		buffer    => [],    # The input token buffer
  		delayed   => [],    # The "delayed insignificant tokens" buffer
  	}, $class;
  }
  
  
  
  
  
  #####################################################################
  # Main Lexing Methods
  
  =pod
  
  =head2 lex_file $filename
  
  The C<lex_file> method takes a filename as argument. It then loads the file,
  creates a L<PPI::Tokenizer> for the content and lexes the token stream
  produced by the tokenizer. Basically, a sort of all-in-one method for
  getting a L<PPI::Document> object from a file name.
  
  Returns a L<PPI::Document> object, or C<undef> on error.
  
  =cut
  
  sub lex_file {
  	my $self = ref $_[0] ? shift : shift->new;
  	my $file = _STRING(shift);
  	unless ( defined $file ) {
  		return $self->_error("Did not pass a filename to PPI::Lexer::lex_file");
  	}
  
  	# Create the Tokenizer
  	my $Tokenizer = eval {
  		X_TOKENIZER->new($file);
  	};
  	if ( _INSTANCE($@, 'PPI::Exception') ) {
  		return $self->_error( $@->message );
  	} elsif ( $@ ) {
  		return $self->_error( $errstr );
  	}
  
  	$self->lex_tokenizer( $Tokenizer );
  }
  
  =pod
  
  =head2 lex_source $string
  
  The C<lex_source> method takes a normal scalar string as argument. It
  creates a L<PPI::Tokenizer> object for the string, and then lexes the
  resulting token stream.
  
  Returns a L<PPI::Document> object, or C<undef> on error.
  
  =cut
  
  sub lex_source {
  	my $self   = ref $_[0] ? shift : shift->new;
  	my $source = shift;
  	unless ( defined $source and not ref $source ) {
  		return $self->_error("Did not pass a string to PPI::Lexer::lex_source");
  	}
  
  	# Create the Tokenizer and hand off to the next method
  	my $Tokenizer = eval {
  		X_TOKENIZER->new(\$source);
  	};
  	if ( _INSTANCE($@, 'PPI::Exception') ) {
  		return $self->_error( $@->message );
  	} elsif ( $@ ) {
  		return $self->_error( $errstr );
  	}
  
  	$self->lex_tokenizer( $Tokenizer );
  }
  
  =pod
  
  =head2 lex_tokenizer $Tokenizer
  
  The C<lex_tokenizer> takes as argument a L<PPI::Tokenizer> object. It
  lexes the token stream from the tokenizer into a L<PPI::Document> object.
  
  Returns a L<PPI::Document> object, or C<undef> on error.
  
  =cut
  
  sub lex_tokenizer {
  	my $self      = ref $_[0] ? shift : shift->new;
  	my $Tokenizer = _INSTANCE(shift, 'PPI::Tokenizer');
  	return $self->_error(
  		"Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer"
  	) unless $Tokenizer;
  
  	# Create the empty document
  	my $Document = PPI::Document->new;
  
  	# Lex the token stream into the document
  	$self->{Tokenizer} = $Tokenizer;
  	if ( !eval { $self->_lex_document($Document); 1 } ) {
  		# If an error occurs DESTROY the partially built document.
  		undef $Document;
  		if ( _INSTANCE($@, 'PPI::Exception') ) {
  			return $self->_error( $@->message );
  		} else {
  			return $self->_error( $errstr );
  		}
  	}
  
  	return $Document;
  }
  
  
  
  
  
  #####################################################################
  # Lex Methods - Document Object
  
  sub _lex_document {
  	my ($self, $Document) = @_;
  	# my $self     = shift;
  	# my $Document = _INSTANCE(shift, 'PPI::Document') or return undef;
  
  	# Start the processing loop
  	my $Token;
  	while ( ref($Token = $self->_get_token) ) {
  		# Add insignificant tokens directly beneath us
  		unless ( $Token->significant ) {
  			$self->_add_element( $Document, $Token );
  			next;
  		}
  
  		if ( $Token->content eq ';' ) {
  			# It's a semi-colon on it's own.
  			# We call this a null statement.
  			$self->_add_element(
  				$Document,
  				PPI::Statement::Null->new($Token),
  			);
  			next;
  		}
  
  		# Handle anything other than a structural element
  		unless ( ref $Token eq 'PPI::Token::Structure' ) {
  			# Determine the class for the Statement, and create it
  			my $Statement = $self->_statement($Document, $Token)->new($Token);
  
  			# Move the lexing down into the statement
  			$self->_add_delayed( $Document );
  			$self->_add_element( $Document, $Statement );
  			$self->_lex_statement( $Statement );
  
  			next;
  		}
  
  		# Is this the opening of a structure?
  		if ( $Token->__LEXER__opens ) {
  			# This should actually have a Statement instead
  			$self->_rollback( $Token );
  			my $Statement = PPI::Statement->new;
  			$self->_add_element( $Document, $Statement );
  			$self->_lex_statement( $Statement );
  			next;
  		}
  
  		# Is this the close of a structure.
  		if ( $Token->__LEXER__closes ) {
  			# Because we are at the top of the tree, this is an error.
  			# This means either a mis-parsing, or a mistake in the code.
  			# To handle this, we create a "Naked Close" statement
  			$self->_add_element( $Document,
  				PPI::Statement::UnmatchedBrace->new($Token)
  			);
  			next;
  		}
  
  		# Shouldn't be able to get here
  		PPI::Exception->throw('Lexer reached an illegal state');
  	}
  
  	# Did we leave the main loop because of a Tokenizer error?
  	unless ( defined $Token ) {
  		my $errstr = $self->{Tokenizer} ? $self->{Tokenizer}->errstr : '';
  		$errstr ||= 'Unknown Tokenizer Error';
  		PPI::Exception->throw($errstr);
  	}
  
  	# No error, it's just the end of file.
  	# Add any insignificant trailing tokens.
  	$self->_add_delayed( $Document );
  
  	# If the Tokenizer has any v6 blocks to attach, do so now.
  	# Checking once at the end is faster than adding a special
  	# case check for every statement parsed.
  	my $perl6 = $self->{Tokenizer}->{'perl6'};
  	if ( @$perl6 ) {
  		my $includes = $Document->find( 'PPI::Statement::Include::Perl6' );
  		foreach my $include ( @$includes ) {
  			unless ( @$perl6 ) {
  				PPI::Exception->throw('Failed to find a perl6 section');
  			}
  			$include->{perl6} = shift @$perl6;
  		}
  	}
  
  	return 1;
  }
  
  
  
  
  
  #####################################################################
  # Lex Methods - Statement Object
  
  use vars qw{%STATEMENT_CLASSES};
  BEGIN {
  	# Keyword -> Statement Subclass
  	%STATEMENT_CLASSES = (
  		# Things that affect the timing of execution
  		'BEGIN'     => 'PPI::Statement::Scheduled',
  		'CHECK'     => 'PPI::Statement::Scheduled',
  		'UNITCHECK' => 'PPI::Statement::Scheduled',
  		'INIT'      => 'PPI::Statement::Scheduled',
  		'END'       => 'PPI::Statement::Scheduled',
  
  		# Special subroutines for which 'sub' is optional
  		'AUTOLOAD'  => 'PPI::Statement::Sub',
  		'DESTROY'   => 'PPI::Statement::Sub',
  
  		# Loading and context statement
  		'package'   => 'PPI::Statement::Package',
  		# 'use'       => 'PPI::Statement::Include',
  		'no'        => 'PPI::Statement::Include',
  		'require'   => 'PPI::Statement::Include',
  
  		# Various declarations
  		'my'        => 'PPI::Statement::Variable',
  		'local'     => 'PPI::Statement::Variable',
  		'our'       => 'PPI::Statement::Variable',
  		'state'     => 'PPI::Statement::Variable',
  		# Statements starting with 'sub' could be any one of...
  		# 'sub'     => 'PPI::Statement::Sub',
  		# 'sub'     => 'PPI::Statement::Scheduled',
  		# 'sub'     => 'PPI::Statement',
  
  		# Compound statement
  		'if'        => 'PPI::Statement::Compound',
  		'unless'    => 'PPI::Statement::Compound',
  		'for'       => 'PPI::Statement::Compound',
  		'foreach'   => 'PPI::Statement::Compound',
  		'while'     => 'PPI::Statement::Compound',
  		'until'     => 'PPI::Statement::Compound',
  
  		# Switch statement
  		'given'     => 'PPI::Statement::Given',
  		'when'      => 'PPI::Statement::When',
  		'default'   => 'PPI::Statement::When',
  
  		# Various ways of breaking out of scope
  		'redo'      => 'PPI::Statement::Break',
  		'next'      => 'PPI::Statement::Break',
  		'last'      => 'PPI::Statement::Break',
  		'return'    => 'PPI::Statement::Break',
  		'goto'      => 'PPI::Statement::Break',
  
  		# Special sections of the file
  		'__DATA__'  => 'PPI::Statement::Data',
  		'__END__'   => 'PPI::Statement::End',
  	);
  }
  
  sub _statement {
  	my ($self, $Parent, $Token) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node')  or die "Bad param 1";
  	# my $Token  = _INSTANCE(shift, 'PPI::Token') or die "Bad param 2";
  
  	# Check for things like ( parent => ... )
  	if (
  		$Parent->isa('PPI::Structure::List')
  		or
  		$Parent->isa('PPI::Structure::Constructor')
  	) {
  		if ( $Token->isa('PPI::Token::Word') ) {
  			# Is the next significant token a =>
  			# Read ahead to the next significant token
  			my $Next;
  			while ( $Next = $self->_get_token ) {
  				unless ( $Next->significant ) {
  					push @{$self->{delayed}}, $Next;
  					# $self->_delay_element( $Next );
  					next;
  				}
  
  				# Got the next token
  				if (
  					$Next->isa('PPI::Token::Operator')
  					and
  					$Next->content eq '=>'
  				) {
  					# Is an ordinary expression
  					$self->_rollback( $Next );
  					return 'PPI::Statement::Expression';
  				} else {
  					last;
  				}
  			}
  
  			# Rollback and continue
  			$self->_rollback( $Next );
  		}
  	}
  
  	# Is it a token in our known classes list
  	my $class = $STATEMENT_CLASSES{$Token->content};
  	if ( $class ) {
  		# Is the next significant token a =>
  		# Read ahead to the next significant token
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			if ( !$Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				next;
  			}
  
  			last if
  				!$Next->isa( 'PPI::Token::Operator' ) or $Next->content ne '=>';
  
  			# Got the next token
  			# Is an ordinary expression
  			$self->_rollback( $Next );
  			return 'PPI::Statement';
  		}
  
  		# Rollback and continue
  		$self->_rollback( $Next );
  	}
  
  	# Handle potential barewords for subscripts
  	if ( $Parent->isa('PPI::Structure::Subscript') ) {
  		# Fast obvious case, just an expression
  		unless ( $class and $class->isa('PPI::Statement::Expression') ) {
  			return 'PPI::Statement::Expression';
  		}
  
  		# This is something like "my" or "our" etc... more subtle.
  		# Check if the next token is a closing curly brace.
  		# This means we are something like $h{my}
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			unless ( $Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				# $self->_delay_element( $Next );
  				next;
  			}
  
  			# Found the next significant token.
  			# Is it a closing curly brace?
  			if ( $Next->content eq '}' ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Expression';
  			} else {
  				$self->_rollback( $Next );
  				return $class;
  			}
  		}
  
  		# End of file... this means it is something like $h{our
  		# which is probably going to be $h{our} ... I think
  		$self->_rollback( $Next );
  		return 'PPI::Statement::Expression';
  	}
  
  	# If it's a token in our list, use that class
  	return $class if $class;
  
  	# Handle the more in-depth sub detection
  	if ( $Token->content eq 'sub' ) {
  		# Read ahead to the next significant token
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			unless ( $Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				# $self->_delay_element( $Next );
  				next;
  			}
  
  			# Got the next significant token
  			my $sclass = $STATEMENT_CLASSES{$Next->content};
  			if ( $sclass and $sclass eq 'PPI::Statement::Scheduled' ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Scheduled';
  			}
  			if ( $Next->isa('PPI::Token::Word') ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Sub';
  			}
  
  			### Comment out these two, as they would return PPI::Statement anyway
  			# if ( $content eq '{' ) {
  			#	Anonymous sub at start of statement
  			#	return 'PPI::Statement';
  			# }
  			#
  			# if ( $Next->isa('PPI::Token::Prototype') ) {
  			#	Anonymous sub at start of statement
  			#	return 'PPI::Statement';
  			# }
  
  			# PPI::Statement is the safest fall-through
  			$self->_rollback( $Next );
  			return 'PPI::Statement';
  		}
  
  		# End of file... PPI::Statement::Sub is the most likely
  		$self->_rollback( $Next );
  		return 'PPI::Statement::Sub';
  	}
  
  	if ( $Token->content eq 'use' ) {
  		# Add a special case for "use v6" lines.
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			unless ( $Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				# $self->_delay_element( $Next );
  				next;
  			}
  
  			# Found the next significant token.
  			if (
  				$Next->isa('PPI::Token::Operator')
  				and
  				$Next->content eq '=>'
  			) {
  				# Is an ordinary expression
  				$self->_rollback( $Next );
  				return 'PPI::Statement';
  			# Is it a v6 use?
  			} elsif ( $Next->content eq 'v6' ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Include::Perl6';
  			} else {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Include';
  			}
  		}
  
  		# End of file... this means it is an incomplete use
  		# line, just treat it as a normal include.
  		$self->_rollback( $Next );
  		return 'PPI::Statement::Include';
  	}
  
  	# If our parent is a Condition, we are an Expression
  	if ( $Parent->isa('PPI::Structure::Condition') ) {
  		return 'PPI::Statement::Expression';
  	}
  
  	# If our parent is a List, we are also an expression
  	if ( $Parent->isa('PPI::Structure::List') ) {
  		return 'PPI::Statement::Expression';
  	}
  
  	# Switch statements use expressions, as well.
  	if (
  		$Parent->isa('PPI::Structure::Given')
  		or
  		$Parent->isa('PPI::Structure::When')
  	) {
  		return 'PPI::Statement::Expression';
  	}
  
  	if ( _INSTANCE($Token, 'PPI::Token::Label') ) {
  		return 'PPI::Statement::Compound';
  	}
  
  	# Beyond that, I have no idea for the moment.
  	# Just keep adding more conditions above this.
  	return 'PPI::Statement';
  }
  
  sub _lex_statement {
  	my ($self, $Statement) = @_;
  	# my $self      = shift;
  	# my $Statement = _INSTANCE(shift, 'PPI::Statement') or die "Bad param 1";
  
  	# Handle some special statements
  	if ( $Statement->isa('PPI::Statement::End') ) {
  		return $self->_lex_end( $Statement );
  	}
  
  	# Begin processing tokens
  	my $Token;
  	while ( ref( $Token = $self->_get_token ) ) {
  		# Delay whitespace and comment tokens
  		unless ( $Token->significant ) {
  			push @{$self->{delayed}}, $Token;
  			# $self->_delay_element( $Token );
  			next;
  		}
  
  		# Structual closes, and __DATA__ and __END__ tags implicitly
  		# end every type of statement
  		if (
  			$Token->__LEXER__closes
  			or
  			$Token->isa('PPI::Token::Separator')
  		) {
  			# Rollback and end the statement
  			return $self->_rollback( $Token );
  		}
  
  		# Normal statements never implicitly end
  		unless ( $Statement->__LEXER__normal ) {
  			# Have we hit an implicit end to the statement
  			unless ( $self->_continues( $Statement, $Token ) ) {
  				# Rollback and finish the statement
  				return $self->_rollback( $Token );
  			}
  		}
  
  		# Any normal character just gets added
  		unless ( $Token->isa('PPI::Token::Structure') ) {
  			$self->_add_element( $Statement, $Token );
  			next;
  		}
  
  		# Handle normal statement terminators
  		if ( $Token->content eq ';' ) {
  			$self->_add_element( $Statement, $Token );
  			return 1;
  		}
  
  		# Which leaves us with a new structure
  
  		# Determine the class for the structure and create it
  		my $method    = $RESOLVE{$Token->content};
  		my $Structure = $self->$method($Statement)->new($Token);
  
  		# Move the lexing down into the Structure
  		$self->_add_delayed( $Statement );
  		$self->_add_element( $Statement, $Structure );
  		$self->_lex_structure( $Structure );
  	}
  
  	# Was it an error in the tokenizer?
  	unless ( defined $Token ) {
  		PPI::Exception->throw;
  	}
  
  	# No, it's just the end of the file...
  	# Roll back any insignificant tokens, they'll get added at the Document level
  	$self->_rollback;
  }
  
  sub _lex_end {
  	my ($self, $Statement) = @_;
  	# my $self      = shift;
  	# my $Statement = _INSTANCE(shift, 'PPI::Statement::End') or die "Bad param 1";
  
  	# End of the file, EVERYTHING is ours
  	my $Token;
  	while ( $Token = $self->_get_token ) {
  		# Inlined $Statement->__add_element($Token);
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $Token} = $Statement
  		);
  		push @{$Statement->{children}}, $Token;
  	}
  
  	# Was it an error in the tokenizer?
  	unless ( defined $Token ) {
  		PPI::Exception->throw;
  	}
  
  	# No, it's just the end of the file...
  	# Roll back any insignificant tokens, they get added at the Document level
  	$self->_rollback;
  }
  
  # For many statements, it can be difficult to determine the end-point.
  # This method takes a statement and the next significant token, and attempts
  # to determine if the there is a statement boundary between the two, or if
  # the statement can continue with the token.
  sub _continues {
  	my ($self, $Statement, $Token) = @_;
  	# my $self      = shift;
  	# my $Statement = _INSTANCE(shift, 'PPI::Statement') or die "Bad param 1";
  	# my $Token     = _INSTANCE(shift, 'PPI::Token')     or die "Bad param 2";
  
  	# Handle the simple block case
  	# { print 1; }
  	if (
  		$Statement->schildren == 1
  		and
  		$Statement->schild(0)->isa('PPI::Structure::Block')
  	) {
  		return '';
  	}
  
  	# Alrighty then, there are six implied-end statement types:
  	# ::Scheduled blocks, ::Sub declarations, ::Compound, ::Given, ::When,
  	# and ::Package statements.
  	return 1
  		if ref $Statement !~ /\b(?:Scheduled|Sub|Compound|Given|When|Package)$/;
  
  	# Of these six, ::Scheduled, ::Sub, ::Given, and ::When follow the same
  	# simple rule and can be handled first.  The block form of ::Package
  	# follows the rule, too.  (The non-block form of ::Package
  	# requires a statement terminator, and thus doesn't need to have
  	# an implied end detected.)
  	my @part      = $Statement->schildren;
  	my $LastChild = $part[-1];
  	# If the last significant element of the statement is a block,
  	# then an implied-end statement is done, no questions asked.
  	return !$LastChild->isa('PPI::Structure::Block')
  		if !$Statement->isa('PPI::Statement::Compound');
  
  	# Now we get to compound statements, which kind of suck (to lex).
  	# However, of them all, the 'if' type, which includes unless, are
  	# relatively easy to handle compared to the others.
  	my $type = $Statement->type;
  	if ( $type eq 'if' ) {
  		# This should be one of the following
  		# if (EXPR) BLOCK
  		# if (EXPR) BLOCK else BLOCK
  		# if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
  
  		# We only implicitly end on a block
  		unless ( $LastChild->isa('PPI::Structure::Block') ) {
  			# if (EXPR) ...
  			# if (EXPR) BLOCK else ...
  			# if (EXPR) BLOCK elsif (EXPR) BLOCK ...
  			return 1;
  		}
  
  		# If the token before the block is an 'else',
  		# it's over, no matter what.
  		my $NextLast = $Statement->schild(-2);
  		if (
  			$NextLast
  			and
  			$NextLast->isa('PPI::Token')
  			and
  			$NextLast->isa('PPI::Token::Word')
  			and
  			$NextLast->content eq 'else'
  		) {
  			return '';
  		}
  
  		# Otherwise, we continue for 'elsif' or 'else' only.
  		if (
  			$Token->isa('PPI::Token::Word')
  			and (
  				$Token->content eq 'else'
  				or
  				$Token->content eq 'elsif'
  			)
  		) {
  			return 1;
  		}
  
  		return '';
  	}
  
  	if ( $type eq 'label' ) {
  		# We only have the label so far, could be any of
  		# LABEL while (EXPR) BLOCK
  		# LABEL while (EXPR) BLOCK continue BLOCK
  		# LABEL for (EXPR; EXPR; EXPR) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK continue BLOCK
  		# LABEL BLOCK continue BLOCK
  
  		# Handle cases with a word after the label
  		if (
  			$Token->isa('PPI::Token::Word')
  			and
  			$Token->content =~ /^(?:while|until|for|foreach)$/
  		) {
  			return 1;
  		}
  
  		# Handle labelled blocks
  		if ( $Token->isa('PPI::Token::Structure') && $Token->content eq '{' ) {
  			return 1;
  		}
  
  		return '';
  	}
  
  	# Handle the common "after round braces" case
  	if ( $LastChild->isa('PPI::Structure') and $LastChild->braces eq '()' ) {
  		# LABEL while (EXPR) ...
  		# LABEL while (EXPR) ...
  		# LABEL for (EXPR; EXPR; EXPR) ...
  		# LABEL for VAR (LIST) ...
  		# LABEL foreach VAR (LIST) ...
  		# Only a block will do
  		return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  	}
  
  	if ( $type eq 'for' ) {
  		# LABEL for (EXPR; EXPR; EXPR) BLOCK
  		if (
  			$LastChild->isa('PPI::Token::Word')
  			and
  			$LastChild->content =~ /^for(?:each)?\z/
  		) {
  			# LABEL for ...
  			if (
  				(
  					$Token->isa('PPI::Token::Structure')
  					and
  					$Token->content eq '('
  				)
  				or
  				$Token->isa('PPI::Token::QuoteLike::Words')
  			) {
  				return 1;
  			}
  
  			if ( $LastChild->isa('PPI::Token::QuoteLike::Words') ) {
  				# LABEL for VAR QW{} ...
  				# LABEL foreach VAR QW{} ...
  				# Only a block will do
  				return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  			}
  
  			# In this case, we can also behave like a foreach
  			$type = 'foreach';
  
  		} elsif ( $LastChild->isa('PPI::Structure::Block') ) {
  			# LABEL for (EXPR; EXPR; EXPR) BLOCK
  			# That's it, nothing can continue
  			return '';
  
  		} elsif ( $LastChild->isa('PPI::Token::QuoteLike::Words') ) {
  			# LABEL for VAR QW{} ...
  			# LABEL foreach VAR QW{} ...
  			# Only a block will do
  			return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  		}
  	}
  
  	# Handle the common continue case
  	if ( $LastChild->isa('PPI::Token::Word') and $LastChild->content eq 'continue' ) {
  		# LABEL while (EXPR) BLOCK continue ...
  		# LABEL foreach VAR (LIST) BLOCK continue ...
  		# LABEL BLOCK continue ...
  		# Only a block will do
  		return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  	}
  
  	# Handle the common continuable block case
  	if ( $LastChild->isa('PPI::Structure::Block') ) {
  		# LABEL while (EXPR) BLOCK
  		# LABEL while (EXPR) BLOCK ...
  		# LABEL for (EXPR; EXPR; EXPR) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK ...
  		# LABEL BLOCK ...
  		# Is this the block for a continue?
  		if ( _INSTANCE($part[-2], 'PPI::Token::Word') and $part[-2]->content eq 'continue' ) {
  			# LABEL while (EXPR) BLOCK continue BLOCK
  			# LABEL foreach VAR (LIST) BLOCK continue BLOCK
  			# LABEL BLOCK continue BLOCK
  			# That's it, nothing can continue this
  			return '';
  		}
  
  		# Only a continue will do
  		return $Token->isa('PPI::Token::Word') && $Token->content eq 'continue';
  	}
  
  	if ( $type eq 'block' ) {
  		# LABEL BLOCK continue BLOCK
  		# Every possible case is covered in the common cases above
  	}
  
  	if ( $type eq 'while' ) {
  		# LABEL while (EXPR) BLOCK
  		# LABEL while (EXPR) BLOCK continue BLOCK
  		# LABEL until (EXPR) BLOCK
  		# LABEL until (EXPR) BLOCK continue BLOCK
  		# The only case not covered is the while ...
  		if (
  			$LastChild->isa('PPI::Token::Word')
  			and (
  				$LastChild->content eq 'while'
  				or
  				$LastChild->content eq 'until'
  			)
  		) {
  			# LABEL while ...
  			# LABEL until ...
  			# Only a condition structure will do
  			return $Token->isa('PPI::Token::Structure') && $Token->content eq '(';
  		}
  	}
  
  	if ( $type eq 'foreach' ) {
  		# LABEL foreach VAR (LIST) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK continue BLOCK
  		# The only two cases that have not been covered already are
  		# 'foreach ...' and 'foreach VAR ...'
  
  		if ( $LastChild->isa('PPI::Token::Symbol') ) {
  			# LABEL foreach my $scalar ...
  			# Open round brace, or a quotewords
  			return 1 if $Token->isa('PPI::Token::Structure') && $Token->content eq '(';
  			return 1 if $Token->isa('PPI::Token::QuoteLike::Words');
  			return '';
  		}
  
  		if ( $LastChild->content eq 'foreach' or $LastChild->content eq 'for' ) {
  			# There are three possibilities here
  			if (
  				$Token->isa('PPI::Token::Word')
  				and (
  					($STATEMENT_CLASSES{ $Token->content } || '')
  					eq
  					'PPI::Statement::Variable'
  				)
  			) {
  				# VAR == 'my ...'
  				return 1;
  			} elsif ( $Token->content =~ /^\$/ ) {
  				# VAR == '$scalar'
  				return 1;
  			} elsif ( $Token->isa('PPI::Token::Structure') and $Token->content eq '(' ) {
  				return 1;
  			} elsif ( $Token->isa('PPI::Token::QuoteLike::Words') ) {
  				return 1;
  			} else {
  				return '';
  			}
  		}
  
  		if (
  			($STATEMENT_CLASSES{ $LastChild->content } || '')
  			eq
  			'PPI::Statement::Variable'
  		) {
  			# LABEL foreach my ...
  			# Only a scalar will do
  			return $Token->content =~ /^\$/;
  		}
  
  		# Handle the rare for my $foo qw{bar} ... case
  		if ( $LastChild->isa('PPI::Token::QuoteLike::Words') ) {
  			# LABEL for VAR QW ...
  			# LABEL foreach VAR QW ...
  			# Only a block will do
  			return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  		}
  	}
  
  	# Something we don't know about... what could it be
  	PPI::Exception->throw("Illegal state in '$type' compound statement");
  }
  
  
  
  
  
  #####################################################################
  # Lex Methods - Structure Object
  
  # Given a parent element, and a ( token to open a structure, determine
  # the class that the structure should be.
  sub _round {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Get the last significant element in the parent
  	my $Element = $Parent->schild(-1);
  	if ( _INSTANCE($Element, 'PPI::Token::Word') ) {
  		# Can it be determined because it is a keyword?
  		my $rclass = $ROUND{$Element->content};
  		return $rclass if $rclass;
  	}
  
  	# If we are part of a for or foreach statement, we are a ForLoop
  	if ( $Parent->isa('PPI::Statement::Compound') ) {
  		if ( $Parent->type =~ /^for(?:each)?$/ ) {
  			return 'PPI::Structure::For';
  		}
  	} elsif ( $Parent->isa('PPI::Statement::Given') ) {
  		return 'PPI::Structure::Given';
  	} elsif ( $Parent->isa('PPI::Statement::When') ) {
  		return 'PPI::Structure::When';
  	}
  
  	# Otherwise, it must be a list
  
  	# If the previous element is -> then we mark it as a dereference
  	if ( _INSTANCE($Element, 'PPI::Token::Operator') and $Element->content eq '->' ) {
  		$Element->{_dereference} = 1;
  	}
  
  	'PPI::Structure::List'
  }
  
  # Given a parent element, and a [ token to open a structure, determine
  # the class that the structure should be.
  sub _square {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Get the last significant element in the parent
  	my $Element = $Parent->schild(-1);
  
  	# Is this a subscript, like $foo[1] or $foo{expr}
  	
  	if ( $Element ) {
  		if ( $Element->isa('PPI::Token::Operator') and $Element->content eq '->' ) {
  			# $foo->[]
  			$Element->{_dereference} = 1;
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Structure::Subscript') ) {
  			# $foo{}[]
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Token::Symbol') and $Element->content =~ /^(?:\$|\@)/ ) {
  			# $foo[], @foo[]
  			return 'PPI::Structure::Subscript';
  		}
  		# FIXME - More cases to catch
  	}
  
  	# Otherwise, we assume that it's an anonymous arrayref constructor
  	'PPI::Structure::Constructor';
  }
  
  use vars qw{%CURLY_CLASSES @CURLY_LOOKAHEAD_CLASSES};
  BEGIN {
  	# Keyword -> Structure class maps
  	%CURLY_CLASSES = (
  		# Blocks
  		'sub'  => 'PPI::Structure::Block',
  		'grep' => 'PPI::Structure::Block',
  		'map'  => 'PPI::Structure::Block',
  		'sort' => 'PPI::Structure::Block',
  		'do'   => 'PPI::Structure::Block',
  		# rely on 'continue' + block being handled elsewhere
  		# rely on 'eval' + block being handled elsewhere
  
  		# Hash constructors
  		'scalar' => 'PPI::Structure::Constructor',
  		'='      => 'PPI::Structure::Constructor',
  		'||='    => 'PPI::Structure::Constructor',
  		'&&='    => 'PPI::Structure::Constructor',
  		'//='    => 'PPI::Structure::Constructor',
  		'||'     => 'PPI::Structure::Constructor',
  		'&&'     => 'PPI::Structure::Constructor',
  		'//'     => 'PPI::Structure::Constructor',
  		'?'      => 'PPI::Structure::Constructor',
  		':'      => 'PPI::Structure::Constructor',
  		','      => 'PPI::Structure::Constructor',
  		'=>'     => 'PPI::Structure::Constructor',
  		'+'      => 'PPI::Structure::Constructor', # per perlref
  		'return' => 'PPI::Structure::Constructor', # per perlref
  		'bless'  => 'PPI::Structure::Constructor', # pragmatic --
  		            # perlfunc says first arg is a reference, and
  			    # bless {; ... } fails to compile.
  	);
  
  	@CURLY_LOOKAHEAD_CLASSES = (
  	    {},	# not used
  	    {
  		';'    => 'PPI::Structure::Block', # per perlref
  		'}'    => 'PPI::Structure::Constructor',
  	    },
  	    {
  		'=>'   => 'PPI::Structure::Constructor',
  	    },
  	);
  }
  
  
  # Given a parent element, and a { token to open a structure, determine
  # the class that the structure should be.
  sub _curly {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Get the last significant element in the parent
  	my $Element = $Parent->schild(-1);
  	my $content = $Element ? $Element->content : '';
  
  	# Is this a subscript, like $foo[1] or $foo{expr}
  	if ( $Element ) {
  		if ( $content eq '->' and $Element->isa('PPI::Token::Operator') ) {
  			# $foo->{}
  			$Element->{_dereference} = 1;
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Structure::Subscript') ) {
  			# $foo[]{}
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol') ) {
  			# $foo{}, @foo{}
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Structure::Block') ) {
  			# deference - ${$hash_ref}{foo}
  			#     or even ${burfle}{foo}
  			# hash slice - @{$hash_ref}{'foo', 'bar'}
  			if ( my $prior = $Parent->schild(-2) ) {
  				my $prior_content = $prior->content();
  				$prior->isa( 'PPI::Token::Cast' )
  					and ( $prior_content eq '@' ||
  						$prior_content eq '$' )
  					and return 'PPI::Structure::Subscript';
  			}
  		}
  
  		# Are we the last argument of sub?
  		# E.g.: 'sub foo {}', 'sub foo ($) {}'
  		return 'PPI::Structure::Block' if $Parent->isa('PPI::Statement::Sub');
  
  		# Are we the second or third argument of package?
  		# E.g.: 'package Foo {}' or 'package Foo v1.2.3 {}'
  		return 'PPI::Structure::Block'
  			if $Parent->isa('PPI::Statement::Package');
  
  		if ( $CURLY_CLASSES{$content} ) {
  			# Known type
  			return $CURLY_CLASSES{$content};
  		}
  	}
  
  	# Are we in a compound statement
  	if ( $Parent->isa('PPI::Statement::Compound') ) {
  		# We will only encounter blocks in compound statements
  		return 'PPI::Structure::Block';
  	}
  
  	# Are we the second or third argument of use
  	if ( $Parent->isa('PPI::Statement::Include') ) {
  		if ( $Parent->schildren == 2 ||
  		    $Parent->schildren == 3 &&
  			$Parent->schild(2)->isa('PPI::Token::Number')
  		) {
  			# This is something like use constant { ... };
  			return 'PPI::Structure::Constructor';
  		}
  	}
  
  	# Unless we are at the start of the statement, everything else should be a block
  	### FIXME This is possibly a bad choice, but will have to do for now.
  	return 'PPI::Structure::Block' if $Element;
  
  	# Special case: Are we the param of a core function
  	# i.e. map({ $_ => 1 } @foo)
  	if (
  		$Parent->isa('PPI::Statement')
  		and
  		_INSTANCE($Parent->parent, 'PPI::Structure::List')
  	) {
  		my $function = $Parent->parent->parent->schild(-2);
  		if ( $function and $function->content =~ /^(?:map|grep|sort)$/ ) {
  			return 'PPI::Structure::Block';
  		}
  	}
  
  	# We need to scan ahead.
  	my $Next;
  	my $position = 0;
  	my @delayed;
  	while ( $Next = $self->_get_token ) {
  		unless ( $Next->significant ) {
  			push @delayed, $Next;
  			next;
  		}
  
  		# If we are off the end of the lookahead array,
  		if ( ++$position >= @CURLY_LOOKAHEAD_CLASSES ) {
  			# default to block.
  			$self->_buffer( splice(@delayed), $Next );
  			last;
  		# If the content at this position is known
  		} elsif ( my $class = $CURLY_LOOKAHEAD_CLASSES[$position]
  			{$Next->content} ) {
  			# return the associated class.
  			$self->_buffer( splice(@delayed), $Next );
  			return $class;
  		}
  
  		# Delay and continue
  		push @delayed, $Next;
  	}
  
  	# Hit the end of the document, or bailed out, go with block
  	$self->_buffer( splice(@delayed) );
  	if ( ref $Parent eq 'PPI::Statement' ) {
  		bless $Parent, 'PPI::Statement::Compound';
  	}
  	return 'PPI::Structure::Block';
  }
  
  
  sub _lex_structure {
  	my ($self, $Structure) = @_;
  	# my $self      = shift;
  	# my $Structure = _INSTANCE(shift, 'PPI::Structure') or die "Bad param 1";
  
  	# Start the processing loop
  	my $Token;
  	while ( ref($Token = $self->_get_token) ) {
  		# Is this a direct type token
  		unless ( $Token->significant ) {
  			push @{$self->{delayed}}, $Token;
  			# $self->_delay_element( $Token );
  			next;
  		}
  
  		# Anything other than a Structure starts a Statement
  		unless ( $Token->isa('PPI::Token::Structure') ) {
  			# Because _statement may well delay and rollback itself,
  			# we need to add the delayed tokens early
  			$self->_add_delayed( $Structure );
  
  			# Determine the class for the Statement and create it
  			my $Statement = $self->_statement($Structure, $Token)->new($Token);
  
  			# Move the lexing down into the Statement
  			$self->_add_element( $Structure, $Statement );
  			$self->_lex_statement( $Statement );
  
  			next;
  		}
  
  		# Is this the opening of another structure directly inside us?
  		if ( $Token->__LEXER__opens ) {
  			# Rollback the Token, and recurse into the statement
  			$self->_rollback( $Token );
  			my $Statement = PPI::Statement->new;
  			$self->_add_element( $Structure, $Statement );
  			$self->_lex_statement( $Statement );
  			next;
  		}
  
  		# Is this the close of a structure ( which would be an error )
  		if ( $Token->__LEXER__closes ) {
  			# Is this OUR closing structure
  			if ( $Token->content eq $Structure->start->__LEXER__opposite ) {
  				# Add any delayed tokens, and the finishing token (the ugly way)
  				$self->_add_delayed( $Structure );
  				$Structure->{finish} = $Token;
  				Scalar::Util::weaken(
  					$_PARENT{Scalar::Util::refaddr $Token} = $Structure
  				);
  
  				# Confirm that ForLoop structures are actually so, and
  				# aren't really a list.
  				if ( $Structure->isa('PPI::Structure::For') ) {
  					if ( 2 > scalar grep {
  						$_->isa('PPI::Statement')
  					} $Structure->children ) {
  						bless($Structure, 'PPI::Structure::List');
  					}
  				}
  				return 1;
  			}
  
  			# Unmatched closing brace.
  			# Either they typed the wrong thing, or haven't put
  			# one at all. Either way it's an error we need to
  			# somehow handle gracefully. For now, we'll treat it
  			# as implicitly ending the structure. This causes the
  			# least damage across the various reasons why this
  			# might have happened.
  			return $self->_rollback( $Token );
  		}
  
  		# It's a semi-colon on it's own, just inside the block.
  		# This is a null statement.
  		$self->_add_element(
  			$Structure,
  			PPI::Statement::Null->new($Token),
  		);
  	}
  
  	# Is this an error
  	unless ( defined $Token ) {
  		PPI::Exception->throw;
  	}
  
  	# No, it's just the end of file.
  	# Add any insignificant trailing tokens.
  	$self->_add_delayed( $Structure );
  }
  
  
  
  
  
  #####################################################################
  # Support Methods
  
  # Get the next token for processing, handling buffering
  sub _get_token {
  	shift(@{$_[0]->{buffer}}) or $_[0]->{Tokenizer}->get_token;
  }
  
  # Old long version of the above
  # my $self = shift;
  #     # First from the buffer
  #     if ( @{$self->{buffer}} ) {
  #         return shift @{$self->{buffer}};
  #     }
  #
  #     # Then from the Tokenizer
  #     $self->{Tokenizer}->get_token;
  # }
  
  # Delay the addition of insignificant elements.
  # This ended up being inlined.
  # sub _delay_element {
  #     my $self    = shift;
  #     my $Element = _INSTANCE(shift, 'PPI::Element') or die "Bad param 1";
  #     push @{ $_[0]->{delayed} }, $_[1];
  # }
  
  # Add an Element to a Node, including any delayed Elements
  sub _add_element {
  	my ($self, $Parent, $Element) = @_;
  	# my $self    = shift;
  	# my $Parent  = _INSTANCE(shift, 'PPI::Node')    or die "Bad param 1";
  	# my $Element = _INSTANCE(shift, 'PPI::Element') or die "Bad param 2";
  
  	# Handle a special case, where a statement is not fully resolved
  	if ( ref $Parent eq 'PPI::Statement'
  		   and my $first = $Parent->schild(0) ) {
  		if ( $first->isa('PPI::Token::Label')
  			   and !(my $second = $Parent->schild(1)) ) {
  			my $new_class = $STATEMENT_CLASSES{$second->content};
  			# It's a labelled statement
  			bless $Parent, $new_class if $new_class;
  		}
  	}
  
  	# Add first the delayed, from the front, then the passed element
  	foreach my $el ( @{$self->{delayed}} ) {
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $el} = $Parent
  		);
  		# Inlined $Parent->__add_element($el);
  	}
  	Scalar::Util::weaken(
  		$_PARENT{Scalar::Util::refaddr $Element} = $Parent
  	);
  	push @{$Parent->{children}}, @{$self->{delayed}}, $Element;
  
  	# Clear the delayed elements
  	$self->{delayed} = [];
  }
  
  # Specifically just add any delayed tokens, if any.
  sub _add_delayed {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Add any delayed
  	foreach my $el ( @{$self->{delayed}} ) {
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $el} = $Parent
  		);
  		# Inlined $Parent->__add_element($el);
  	}
  	push @{$Parent->{children}}, @{$self->{delayed}};
  
  	# Clear the delayed elements
  	$self->{delayed} = [];
  }
  
  # Rollback the delayed tokens, plus any passed. Once all the tokens
  # have been moved back on to the buffer, the order should be.
  # <--- @{$self->{delayed}}, @_, @{$self->{buffer}} <----
  sub _rollback {
  	my $self = shift;
  
  	# First, put any passed objects back
  	if ( @_ ) {
  		unshift @{$self->{buffer}}, splice @_;
  	}
  
  	# Then, put back anything delayed
  	if ( @{$self->{delayed}} ) {
  		unshift @{$self->{buffer}}, splice @{$self->{delayed}};
  	}
  
  	1;
  }
  
  # Partial rollback, just return a single list to the buffer
  sub _buffer {
  	my $self = shift;
  
  	# Put any passed objects back
  	if ( @_ ) {
  		unshift @{$self->{buffer}}, splice @_;
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Error Handling
  
  # Set the error message
  sub _error {
  	$errstr = $_[1];
  	undef;
  }
  
  # Clear the error message.
  # Returns the object as a convenience.
  sub _clear {
  	$errstr = '';
  	$_[0];
  }
  
  =pod
  
  =head2 errstr
  
  For any error that occurs, you can use the C<errstr>, as either
  a static or object method, to access the error message.
  
  If no error occurs for any particular action, C<errstr> will return false.
  
  =cut
  
  sub errstr {
  	$errstr;
  }
  
  
  
  
  
  #####################################################################
  # PDOM Extensions
  #
  # This is something of a future expansion... ignore it for now :)
  #
  # use PPI::Statement::Sub ();
  #
  # sub PPI::Statement::Sub::__LEXER__normal { '' }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add optional support for some of the more common source filters
  
  - Some additional checks for blessing things into various Statement
  and Structure subclasses.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;
  
  =pod
  
  =head1 NAME
  
  PPI::Node - Abstract PPI Node class, an Element that can contain other Elements
  
  =head1 INHERITANCE
  
    PPI::Node
    isa PPI::Element
  
  =head1 SYNOPSIS
  
    # Create a typical node (a Document in this case)
    my $Node = PPI::Document->new;
    
    # Add an element to the node( in this case, a token )
    my $Token = PPI::Token::Word->new('my');
    $Node->add_element( $Token );
    
    # Get the elements for the Node
    my @elements = $Node->children;
    
    # Find all the barewords within a Node
    my $barewords = $Node->find( 'PPI::Token::Word' );
    
    # Find by more complex criteria
    my $my_tokens = $Node->find( sub { $_[1]->content eq 'my' } );
    
    # Remove all the whitespace
    $Node->prune( 'PPI::Token::Whitespace' );
    
    # Remove by more complex criteria
    $Node->prune( sub { $_[1]->content eq 'my' } );
  
  =head1 DESCRIPTION
  
  The C<PPI::Node> class provides an abstract base class for the Element
  classes that are able to contain other elements L<PPI::Document>,
  L<PPI::Statement>, and L<PPI::Structure>.
  
  As well as those listed below, all of the methods that apply to
  L<PPI::Element> objects also apply to C<PPI::Node> objects.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp            ();
  use Scalar::Util    qw{refaddr};
  use List::MoreUtils ();
  use Params::Util    qw{_INSTANCE _CLASS _CODELIKE _NUMBER};
  use PPI::Element    ();
  
  use vars qw{$VERSION @ISA *_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Element';
  	*_PARENT = *PPI::Element::_PARENT;
  }
  
  
  
  
  
  #####################################################################
  # The basic constructor
  
  sub new {
  	my $class = ref $_[0] || $_[0];
  	bless { children => [] }, $class;
  }
  
  
  
  
  
  #####################################################################
  # PDOM Methods
  
  =pod
  
  =head2 scope
  
  The C<scope> method returns true if the node represents a lexical scope
  boundary, or false if it does not.
  
  =cut
  
  ### XS -> PPI/XS.xs:_PPI_Node__scope 0.903+
  sub scope() { '' }
  
  =pod
  
  =head2 add_element $Element
  
  The C<add_element> method adds a L<PPI::Element> object to the end of a
  C<PPI::Node>. Because Elements maintain links to their parent, an
  Element can only be added to a single Node.
  
  Returns true if the L<PPI::Element> was added. Returns C<undef> if the
  Element was already within another Node, or the method is not passed 
  a L<PPI::Element> object.
  
  =cut
  
  sub add_element {
  	my $self = shift;
  
  	# Check the element
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	$_PARENT{refaddr $Element} and return undef;
  
  	# Add the argument to the elements
  	push @{$self->{children}}, $Element;
  	Scalar::Util::weaken(
  		$_PARENT{refaddr $Element} = $self
  	);
  
  	1;
  }
  
  # In a typical run profile, add_element is the number 1 resource drain.
  # This is a highly optimised unsafe version, for internal use only.
  sub __add_element {
  	Scalar::Util::weaken(
  		$_PARENT{refaddr $_[1]} = $_[0]
  	);
  	push @{$_[0]->{children}}, $_[1];
  }
  
  =pod
  
  =head2 elements
  
  The C<elements> method accesses all child elements B<structurally> within
  the C<PPI::Node> object. Note that in the base of the L<PPI::Structure>
  classes, this C<DOES> include the brace tokens at either end of the
  structure.
  
  Returns a list of zero or more L<PPI::Element> objects.
  
  Alternatively, if called in the scalar context, the C<elements> method
  returns a count of the number of elements.
  
  =cut
  
  sub elements {
  	if ( wantarray ) {
  		return @{$_[0]->{children}};
  	} else {
  		return scalar @{$_[0]->{children}};
  	}
  }
  
  =pod
  
  =head2 first_element
  
  The C<first_element> method accesses the first element structurally within
  the C<PPI::Node> object. As for the C<elements> method, this does include
  the brace tokens for L<PPI::Structure> objects.
  
  Returns a L<PPI::Element> object, or C<undef> if for some reason the
  C<PPI::Node> object does not contain any elements.
  
  =cut
  
  # Normally the first element is also the first child
  sub first_element {
  	$_[0]->{children}->[0];
  }
  
  =pod
  
  =head2 last_element
  
  The C<last_element> method accesses the last element structurally within
  the C<PPI::Node> object. As for the C<elements> method, this does include
  the brace tokens for L<PPI::Structure> objects.
  
  Returns a L<PPI::Element> object, or C<undef> if for some reason the
  C<PPI::Node> object does not contain any elements.
  
  =cut
  
  # Normally the last element is also the last child
  sub last_element {
  	$_[0]->{children}->[-1];
  }
  
  =pod
  
  =head2 children
  
  The C<children> method accesses all child elements lexically within the
  C<PPI::Node> object. Note that in the case of the L<PPI::Structure>
  classes, this does B<NOT> include the brace tokens at either end of the
  structure.
  
  Returns a list of zero of more L<PPI::Element> objects.
  
  Alternatively, if called in the scalar context, the C<children> method
  returns a count of the number of lexical children.
  
  =cut
  
  # In the default case, this is the same as for the elements method
  sub children {
  	wantarray ? @{$_[0]->{children}} : scalar @{$_[0]->{children}};
  }
  
  =pod
  
  =head2 schildren
  
  The C<schildren> method is really just a convenience, the significant-only
  variation of the normal C<children> method.
  
  In list context, returns a list of significant children. In scalar context,
  returns the number of significant children.
  
  =cut
  
  sub schildren {
  	return grep { $_->significant } @{$_[0]->{children}} if wantarray;
  	my $count = 0;
  	foreach ( @{$_[0]->{children}} ) {
  		$count++ if $_->significant;
  	}
  	return $count;
  }
  
  =pod
  
  =head2 child $index
  
  The C<child> method accesses a child L<PPI::Element> object by its
  position within the Node.
  
  Returns a L<PPI::Element> object, or C<undef> if there is no child
  element at that node.
  
  =cut
  
  sub child {
  	my ( $self, $index ) = @_;
  	PPI::Exception->throw( "method child() needs an index" )
  	  if not defined _NUMBER $index;
  	$self->{children}->[$index];
  }
  
  =pod
  
  =head2 schild $index
  
  The lexical structure of the Perl language ignores 'insignificant' items,
  such as whitespace and comments, while L<PPI> treats these items as valid
  tokens so that it can reassemble the file at any time. Because of this,
  in many situations there is a need to find an Element within a Node by
  index, only counting lexically significant Elements.
  
  The C<schild> method returns a child Element by index, ignoring
  insignificant Elements. The index of a child Element is specified in the
  same way as for a normal array, with the first Element at index 0, and
  negative indexes used to identify a "from the end" position.
  
  =cut
  
  sub schild {
  	my $self = shift;
  	my $idx  = 0 + shift;
  	my $el   = $self->{children};
  	if ( $idx < 0 ) {
  		my $cursor = 0;
  		while ( exists $el->[--$cursor] ) {
  			return $el->[$cursor] if $el->[$cursor]->significant and ++$idx >= 0;
  		}
  	} else {
  		my $cursor = -1;
  		while ( exists $el->[++$cursor] ) {
  			return $el->[$cursor] if $el->[$cursor]->significant and --$idx < 0;
  		}
  	}
  	undef;
  }
  
  =pod
  
  =head2 contains $Element
  
  The C<contains> method is used to determine if another L<PPI::Element>
  object is logically "within" a C<PPI::Node>. For the special case of the
  brace tokens at either side of a L<PPI::Structure> object, they are
  generally considered "within" a L<PPI::Structure> object, even if they are
  not actually in the elements for the L<PPI::Structure>.
  
  Returns true if the L<PPI::Element> is within us, false if not, or C<undef>
  on error.
  
  =cut
  
  sub contains {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  
  	# Iterate up the Element's parent chain until we either run out
  	# of parents, or get to ourself.
  	while ( $Element = $Element->parent ) {
  		return 1 if refaddr($self) == refaddr($Element);
  	}
  
  	'';
  }
  
  =pod
  
  =head2 find $class | \&wanted
  
  The C<find> method is used to search within a code tree for
  L<PPI::Element> objects that meet a particular condition.
  
  To specify the condition, the method can be provided with either a simple
  class name (full or shortened), or a C<CODE>/function reference.
  
    # Find all single quotes in a Document (which is a Node)
    $Document->find('PPI::Quote::Single');
    
    # The same thing with a shortened class name
    $Document->find('Quote::Single');
    
    # Anything more elaborate, we go with the sub
    $Document->find( sub {
    	# At the top level of the file...
    	$_[1]->parent == $_[0]
    	and (
    		# ...find all comments and POD
    		$_[1]->isa('PPI::Token::Pod')
    		or
    		$_[1]->isa('PPI::Token::Comment')
    	)
    } );
  
  The function will be passed two arguments, the top-level C<PPI::Node>
  you are searching in and the current L<PPI::Element> that the condition
  is testing.
  
  The anonymous function should return one of three values. Returning true
  indicates a condition match, defined-false (C<0> or C<''>) indicates
  no-match, and C<undef> indicates no-match and no-descend.
  
  In the last case, the tree walker will skip over anything below the
  C<undef>-returning element and move on to the next element at the same
  level.
  
  To halt the entire search and return C<undef> immediately, a condition
  function should throw an exception (i.e. C<die>).
  
  Note that this same wanted logic is used for all methods documented to
  have a C<\&wanted> parameter, as this one does.
  
  The C<find> method returns a reference to an array of L<PPI::Element>
  objects that match the condition, false (but defined) if no Elements match
  the condition, or C<undef> if you provide a bad condition, or an error
  occurs during the search process.
  
  In the case of a bad condition, a warning will be emitted as well.
  
  =cut
  
  sub find {
  	my $self   = shift;
  	my $wanted = $self->_wanted(shift) or return undef;
  
  	# Use a queue based search, rather than a recursive one
  	my @found;
  	my @queue = @{$self->{children}};
  	my $ok = eval {
  		while ( @queue ) {
  			my $Element = shift @queue;
  			my $rv      = &$wanted( $self, $Element );
  			push @found, $Element if $rv;
  
  			# Support "don't descend on undef return"
  			next unless defined $rv;
  
  			# Skip if the Element doesn't have any children
  			next unless $Element->isa('PPI::Node');
  
  			# Depth-first keeps the queue size down and provides a
  			# better logical order.
  			if ( $Element->isa('PPI::Structure') ) {
  				unshift @queue, $Element->finish if $Element->finish;
  				unshift @queue, @{$Element->{children}};
  				unshift @queue, $Element->start if $Element->start;
  			} else {
  				unshift @queue, @{$Element->{children}};
  			}
  		}
  		1;
  	};
  	if ( !$ok ) {
  		# Caught exception thrown from the wanted function
  		return undef;
  	}
  
  	@found ? \@found : '';
  }
  
  =pod
  
  =head2 find_first $class | \&wanted
  
  If the normal C<find> method is like a grep, then C<find_first> is
  equivalent to the L<List::Util> C<first> function.
  
  Given an element class or a wanted function, it will search depth-first
  through a tree until it finds something that matches the condition,
  returning the first Element that it encounters.
  
  See the C<find> method for details on the format of the search condition.
  
  Returns the first L<PPI::Element> object that matches the condition, false
  if nothing matches the condition, or C<undef> if given an invalid condition,
  or an error occurs.
  
  =cut
  
  sub find_first {
  	my $self   = shift;
  	my $wanted = $self->_wanted(shift) or return undef;
  
  	# Use the same queue-based search as for ->find
  	my @queue = @{$self->{children}};
  	my $rv;
  	my $ok = eval {
  		# The defined() here prevents a ton of calls to PPI::Util::TRUE
  		while ( @queue ) {
  			my $Element = shift @queue;
  			my $element_rv = $wanted->( $self, $Element );
  			if ( $element_rv ) {
  				$rv = $Element;
  				last;
  			}
  
  			# Support "don't descend on undef return"
  			next if !defined $element_rv;
  
  			# Skip if the Element doesn't have any children
  			next if !$Element->isa('PPI::Node');
  
  			# Depth-first keeps the queue size down and provides a
  			# better logical order.
  			if ( $Element->isa('PPI::Structure') ) {
  				unshift @queue, $Element->finish if defined($Element->finish);
  				unshift @queue, @{$Element->{children}};
  				unshift @queue, $Element->start  if defined($Element->start);
  			} else {
  				unshift @queue, @{$Element->{children}};
  			}
  		}
  		1;
  	};
  	if ( !$ok ) {
  		# Caught exception thrown from the wanted function
  		return undef;
  	}
  
  	$rv or '';
  }
  
  =pod
  
  =head2 find_any $class | \&wanted
  
  The C<find_any> method is a short-circuiting true/false method that behaves
  like the normal C<find> method, but returns true as soon as it finds any
  Elements that match the search condition.
  
  See the C<find> method for details on the format of the search condition.
  
  Returns true if any Elements that match the condition can be found, false if
  not, or C<undef> if given an invalid condition, or an error occurs.
  
  =cut
  
  sub find_any {
  	my $self = shift;
  	my $rv   = $self->find_first(@_);
  	$rv ? 1 : $rv; # false or undef
  }
  
  =pod
  
  =head2 remove_child $Element
  
  If passed a L<PPI::Element> object that is a direct child of the Node,
  the C<remove_element> method will remove the C<Element> intact, along
  with any of its children. As such, this method acts essentially as a
  'cut' function.
  
  If successful, returns the removed element.  Otherwise, returns C<undef>.
  
  =cut
  
  sub remove_child {
  	my $self  = shift;
  	my $child = _INSTANCE(shift, 'PPI::Element') or return undef;
  
  	# Find the position of the child
  	my $key = refaddr $child;
  	my $p   = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  	} @{$self->{children}};
  	return undef if $p == -1;
  
  	# Splice it out, and remove the child's parent entry
  	splice( @{$self->{children}}, $p, 1 );
  	delete $_PARENT{refaddr $child};
  
  	$child;
  }
  
  =pod
  
  =head2 prune $class | \&wanted
  
  The C<prune> method is used to strip L<PPI::Element> objects out of a code
  tree. The argument is the same as for the C<find> method, either a class
  name, or an anonymous subroutine which returns true/false. Any Element
  that matches the class|wanted will be deleted from the code tree, along
  with any of its children.
  
  The C<prune> method returns the number of C<Element> objects that matched
  and were removed, B<non-recursively>. This might also be zero, so avoid a
  simple true/false test on the return false of the C<prune> method. It
  returns C<undef> on error, which you probably B<should> test for.
  
  =cut
  
  sub prune {
  	my $self   = shift;
  	my $wanted = $self->_wanted(shift) or return undef;
  
  	# Use a depth-first queue search
  	my $pruned = 0;
  	my @queue  = $self->children;
  	my $ok = eval {
  		while ( my $element = shift @queue ) {
  			my $rv = &$wanted( $self, $element );
  			if ( $rv ) {
  				# Delete the child
  				$element->delete or return undef;
  				$pruned++;
  				next;
  			}
  
  			# Support the undef == "don't descend"
  			next unless defined $rv;
  
  			if ( _INSTANCE($element, 'PPI::Node') ) {
  				# Depth-first keeps the queue size down
  				unshift @queue, $element->children;
  			}
  		}
  		1;
  	};
  	if ( !$ok ) {
  		# Caught exception thrown from the wanted function
  		return undef;		
  	}
  
  	$pruned;
  }
  
  # This method is likely to be very heavily used, so take
  # it slowly and carefully.
  ### NOTE: Renaming this function or changing either to self will probably
  ###       break File::Find::Rule::PPI
  sub _wanted {
  	my $either = shift;
  	my $it     = defined($_[0]) ? shift : do {
  		Carp::carp('Undefined value passed as search condition') if $^W;
  		return undef;
  	};
  
  	# Has the caller provided a wanted function directly
  	return $it if _CODELIKE($it);
  	if ( ref $it ) {
  		# No other ref types are supported
  		Carp::carp('Illegal non-CODE reference passed as search condition') if $^W;
  		return undef;
  	}
  
  	# The first argument should be an Element class, possibly in shorthand
  	$it = "PPI::$it" unless substr($it, 0, 5) eq 'PPI::';
  	unless ( _CLASS($it) and $it->isa('PPI::Element') ) {
  		# We got something, but it isn't an element
  		Carp::carp("Cannot create search condition for '$it': Not a PPI::Element") if $^W;
  		return undef;
  	}
  
  	# Create the class part of the wanted function
  	my $wanted_class = "\n\treturn '' unless \$_[1]->isa('$it');";
  
  	# Have we been given a second argument to check the content
  	my $wanted_content = '';
  	if ( defined $_[0] ) {
  		my $content = shift;
  		if ( ref $content eq 'Regexp' ) {
  			$content = "$content";
  		} elsif ( ref $content ) {
  			# No other ref types are supported
  			Carp::carp("Cannot create search condition for '$it': Not a PPI::Element") if $^W;
  			return undef;
  		} else {
  			$content = quotemeta $content;
  		}
  
  		# Complete the content part of the wanted function
  		$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";
  		$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;";
  	}
  
  	# Create the complete wanted function
  	my $code = "sub {"
  		. $wanted_class
  		. $wanted_content
  		. "\n\t1;"
  		. "\n}";
  
  	# Compile the wanted function
  	$code = eval $code;
  	(ref $code eq 'CODE') ? $code : undef;
  }
  
  
  
  
  
  ####################################################################
  # PPI::Element overloaded methods
  
  sub tokens {
  	map { $_->tokens } @{$_[0]->{children}};
  }
  
  ### XS -> PPI/XS.xs:_PPI_Element__content 0.900+
  sub content {
  	join '', map { $_->content } @{$_[0]->{children}};
  }
  
  # Clone as normal, but then go down and relink all the _PARENT entries
  sub clone {
  	my $self  = shift;
  	my $clone = $self->SUPER::clone;
  	$clone->__link_children;
  	$clone;
  }
  
  sub location {
  	my $self  = shift;
  	my $first = $self->{children}->[0] or return undef;
  	$first->location;
  }
  
  
  
  
  
  #####################################################################
  # Internal Methods
  
  sub DESTROY {
  	local $_;
  	if ( $_[0]->{children} ) {
  		my @queue = $_[0];
  		while ( defined($_ = shift @queue) ) {
  			unshift @queue, @{delete $_->{children}} if $_->{children};
  
  			# Remove all internal/private weird crosslinking so that
  			# the cascading DESTROY calls will get called properly.
  			%$_ = ();
  		}
  	}
  
  	# Remove us from our parent node as normal
  	delete $_PARENT{refaddr $_[0]};
  }
  
  # Find the position of a child
  sub __position {
  	my $key = refaddr $_[1];
  	List::MoreUtils::firstidx { refaddr $_ == $key } @{$_[0]->{children}};
  }
  
  # Insert one or more elements before a child
  sub __insert_before_child {
  	my $self = shift;
  	my $key  = refaddr shift;
  	my $p    = List::MoreUtils::firstidx {
  	         refaddr $_ == $key
  	         } @{$self->{children}};
  	foreach ( @_ ) {
  		Scalar::Util::weaken(
  			$_PARENT{refaddr $_} = $self
  			);
  	}
  	splice( @{$self->{children}}, $p, 0, @_ );
  	1;
  }
  
  # Insert one or more elements after a child
  sub __insert_after_child {
  	my $self = shift;
  	my $key  = refaddr shift;
  	my $p    = List::MoreUtils::firstidx {
  	         refaddr $_ == $key
  	         } @{$self->{children}};
  	foreach ( @_ ) {
  		Scalar::Util::weaken(
  			$_PARENT{refaddr $_} = $self
  			);
  	}
  	splice( @{$self->{children}}, $p + 1, 0, @_ );
  	1;
  }
  
  # Replace a child
  sub __replace_child {
  	my $self = shift;
  	my $key  = refaddr shift;
  	my $p    = List::MoreUtils::firstidx {
  	         refaddr $_ == $key
  	         } @{$self->{children}};
  	foreach ( @_ ) {
  		Scalar::Util::weaken(
  			$_PARENT{refaddr $_} = $self
  			);
  	}
  	splice( @{$self->{children}}, $p, 1, @_ );
  	1;
  }
  
  # Create PARENT links for an entire tree.
  # Used when cloning or thawing.
  sub __link_children {
  	my $self = shift;
  
  	# Relink all our children ( depth first )
  	my @queue = ( $self );
  	while ( my $Node = shift @queue ) {
  		# Link our immediate children
  		foreach my $Element ( @{$Node->{children}} ) {
  			Scalar::Util::weaken(
  				$_PARENT{refaddr($Element)} = $Node
  				);
  			unshift @queue, $Element if $Element->isa('PPI::Node');
  		}
  
  		# If it's a structure, relink the open/close braces
  		next unless $Node->isa('PPI::Structure');
  		Scalar::Util::weaken(
  			$_PARENT{refaddr($Node->start)}  = $Node
  			) if $Node->start;
  		Scalar::Util::weaken(
  			$_PARENT{refaddr($Node->finish)} = $Node
  			) if $Node->finish;
  	}
  
  	1;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Move as much as possible to L<PPI::XS>
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;
  
  =pod
  
  =head1 NAME
  
  PPI::Normal - Normalize Perl Documents
  
  =head2 DESCRIPTION
  
  Perl Documents, as created by PPI, are typically filled with all sorts of
  mess such as whitespace and comments and other things that don't effect
  the actual meaning of the code.
  
  In addition, because there is more than one way to do most things, and the
  syntax of Perl itself is quite flexible, there are many ways in which the
  "same" code can look quite different.
  
  PPI::Normal attempts to resolve this by providing a variety of mechanisms
  and algorithms to "normalize" Perl Documents, and determine a sort of base
  form for them (although this base form will be a memory structure, and
  not something that can be turned back into Perl source code).
  
  The process itself is quite complex, and so for convenience and
  extensibility it has been separated into a number of layers. At a later
  point, it will be possible to write Plugin classes to insert additional
  normalization steps into the various different layers.
  
  In addition, you can choose to do the normalization only as deep as a
  particular layer, depending on aggressively you want the normalization
  process to be.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp                      ();
  use List::Util 1.33           ();
  use PPI::Util                 '_Document';
  use PPI::Document::Normalized ();
  
  use vars qw{$VERSION %LAYER};
  BEGIN {
  	$VERSION = '1.236';
  
  	# Registered function store
  	%LAYER = (
  		1 => [],
  		2 => [],
  	);
  }
  
  
  
  
  
  #####################################################################
  # Configuration
  
  =pod
  
  =head2 register $function => $layer, ...
  
  The C<register> method is used by normalization method providers to
  tell the normalization engines which functions need to be run, and
  in which layer they apply.
  
  Provide a set of key/value pairs, where the key is the full name of the
  function (in string form), and the value is the layer (see description
  of the layers above) in which it should be run.
  
  Returns true if all functions are registered, or C<undef> on error.
  
  =cut
  
  sub register {
  	my $class = shift;
  	while ( @_ ) {
  		# Check the function
  		my $function = shift;
  		SCOPE: {
  			no strict 'refs';
  			defined $function and defined &{"$function"}
  				or Carp::croak("Bad function name provided to PPI::Normal");
  		}
  
  		# Has it already been added?
  		if ( List::Util::any { $_ eq $function } map @{$_}, values %LAYER ) {
  			return 1;
  		}
  
  		# Check the layer to add it to
  		my $layer = shift;
  		defined $layer and $layer =~ /^(?:1|2)$/
  			or Carp::croak("Bad layer provided to PPI::Normal");
  
  		# Add to the layer data store
  		push @{ $LAYER{$layer} }, $function;
  	}
  
  	1;
  }
  
  # With the registration mechanism in place, load in the main set of
  # normalization methods to initialize the store.
  use PPI::Normal::Standard;
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $level_1 = PPI::Normal->new;
    my $level_2 = PPI::Normal->new(2);
  
  Creates a new normalization object, to which Document objects
  can be passed to be normalized.
  
  Of course, what you probably REALLY want is just to call
  L<PPI::Document>'s C<normalize> method.
  
  Takes an optional single parameter of the normalisation layer
  to use, which at this time can be either "1" or "2".
  
  Returns a new C<PPI::Normal> object, or C<undef> on error.
  
  =cut
  
  sub new {
  	my $class = shift;
  	my $layer = @_ ?
  		(defined $_[0] and ! ref $_[0] and $_[0] =~ /^[12]$/) ? shift : return undef
  		: 1;
  
  	# Create the object
  	my $object = bless {
  		layer => $layer,
  		}, $class;
  
  	$object;
  }
  
  =pod
  
  =head1 layer
  
  The C<layer> accessor returns the normalisation layer of the object.
  
  =cut
  
  sub layer { $_[0]->{layer} }
  
  
  
  
  
  #####################################################################
  # Main Methods
  
  =pod
  
  =head2 process
  
  The C<process> method takes anything that can be converted to a
  L<PPI::Document> (object, SCALAR ref, filename), loads it and
  applies the normalisation process to the document.
  
  Returns a L<PPI::Document::Normalized> object, or C<undef> on error.
  
  =cut
  
  sub process {
  	my $self = ref $_[0] ? shift : shift->new;
  
  	# PPI::Normal objects are reusable, but not re-entrant
  	return undef if $self->{Document};
  
  	# Get or create the document
  	$self->{Document} = _Document(shift) or return undef;
  
  	# Work out what functions we need to call
  	my @functions = map { @{ $LAYER{$_} } } ( 1 .. $self->layer );
  
  	# Execute each function
  	foreach my $function ( @functions ) {
  		no strict 'refs';
  		&{"$function"}( $self->{Document} );
  	}
  
  	# Create the normalized Document object
  	my $Normalized = PPI::Document::Normalized->new(
  		Document  => $self->{Document},
  		version   => $VERSION,
  		functions => \@functions,
  	) or return undef;
  
  	# Done, clean up
  	delete $self->{Document};
  	return $Normalized;
  }
  
  1;
  
  =pod
  
  =head1 NOTES
  
  The following normalisation layers are implemented. When writing
  plugins, you should register each transformation function with the
  appropriate layer.
  
  =head2 Layer 1 - Insignificant Data Removal
  
  The basic step common to all normalization, layer 1 scans through the
  Document and removes all whitespace, comments, POD, and anything else
  that returns false for its C<significant> method.
  
  It also checks each Element and removes known-useless sub-element
  metadata such as the Element's physical position in the file.
  
  =head2 Layer 2 - Significant Element Removal
  
  After the removal of the insignificant data, Layer 2 removed larger, more
  complex, and superficially "significant" elements, that can be removed
  for the purposes of normalisation.
  
  Examples from this layer include pragmas, now-useless statement
  separators (since the PDOM tree is holding statement elements), and
  several other minor bits and pieces.
  
  =head2 Layer 3 - TO BE COMPLETED
  
  This version of the forward-port of the Perl::Compare functionality
  to the 0.900+ API of PPI only implements Layer 1 and 2 at this time.
  
  =head1 TO DO
  
  - Write the other 4-5 layers :)
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;
  
  =pod
  
  =head1 NAME
  
  PPI::Normal::Standard - Provides standard document normalization functions
  
  =head1 DESCRIPTION
  
  This module provides the default normalization methods for L<PPI::Normal>.
  
  There is no reason for you to need to load this yourself.
  
  B<Move along, nothing to see here>.
  
  =cut
  
  use strict;
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Configuration and Registration
  
  my @METHODS = (
  	remove_insignificant_elements => 1,
  	remove_useless_attributes     => 1,
  	remove_useless_pragma         => 2,
  	remove_statement_separator    => 2,
  	remove_useless_return         => 2,
  );
  
  sub import {
  	PPI::Normal->register(
  		map { /\D/ ? "PPI::Normal::Standard::$_" : $_ } @METHODS
  	) or die "Failed to register PPI::Normal::Standard transforms";
  }
  
  
  
  
  
  #####################################################################
  # Level 1 Transforms
  
  # Remove all insignificant elements
  sub remove_insignificant_elements {
  	my $Document = shift;
  	$Document->prune( sub { ! $_[1]->significant } );
  }
  
  # Remove custom attributes that are not relevant to normalization
  sub remove_useless_attributes {
  	my $Document = shift;
  	delete $Document->{tab_width};
  
  	### FIXME - Add support for more things
  }
  
  
  
  
  
  #####################################################################
  # Level 2 Transforms
  
  # Remove version dependencies and pragma
  my $remove_pragma = map { $_ => 1 } qw{
  	strict warnings diagnostics	less
  	};
  sub remove_useless_pragma {
  	my $Document = shift;
  	$Document->prune( sub {
  		return '' unless $_[1]->isa('PPI::Statement::Include');
  		return 1  if     $_[1]->version;
  		return 1  if     $remove_pragma->{$_[1]->pragma};
  		'';
  	} );
  }
  
  # Remove all semi-colons at the end of statements
  sub remove_statement_separator {
  	my $Document = shift;
  	$Document->prune( sub {
  		$_[1]->isa('PPI::Token::Structure') or return '';
  		$_[1]->content eq ';'               or return '';
  		my $stmt = $_[1]->parent            or return '';
  		$stmt->isa('PPI::Statement')        or return '';
  		$_[1]->next_sibling                and return '';
  		1;
  	} );
  }
  
  # In any block, the "return" in the last statement is not
  # needed if there is only one and only one thing after the
  # return.
  sub remove_useless_return {
  	my $Document = shift;
  	$Document->prune( sub {
  		$_[1]->isa('PPI::Token::Word')       or return '';
  		$_[1]->content eq 'return'           or return '';
  		my $stmt = $_[1]->parent             or return '';
  		$stmt->isa('PPI::Statement::Break')  or return '';
  		$stmt->children == 2                 or return '';
  		$stmt->next_sibling                 and return '';
  		my $block = $stmt->parent            or return '';
  		$block->isa('PPI::Structure::Block') or return '';
  		1;
  	} );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement - The base class for Perl statements
  
  =head1 INHERITANCE
  
    PPI::Statement
    isa PPI::Node
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  PPI::Statement is the root class for all Perl statements. This includes (from
  L<perlsyn>) "Declarations", "Simple Statements" and "Compound Statements".
  
  The class PPI::Statement itself represents a "Simple Statement" as defined
  in the L<perlsyn> manpage.
  
  =head1 STATEMENT CLASSES
  
  Please note that unless documented themselves, these classes are yet to be
  frozen/finalised. Names may change slightly or be added or removed.
  
  =head2 L<PPI::Statement::Scheduled>
  
  This covers all "scheduled" blocks, chunks of code that are executed separately
  from the main body of the code, at a particular time. This includes all
  C<BEGIN>, C<CHECK>, C<UNITCHECK>, C<INIT> and C<END> blocks.
  
  =head2 L<PPI::Statement::Package>
  
  A package declaration, as defined in L<perlfunc|perlfunc/package>.
  
  =head2 L<PPI::Statement::Include>
  
  A statement that loads or unloads another module.
  
  This includes 'use', 'no', and 'require' statements.
  
  =head2 L<PPI::Statement::Sub>
  
  A named subroutine declaration, or forward declaration
  
  =head2 L<PPI::Statement::Variable>
  
  A variable declaration statement. This could be either a straight
  declaration or also be an expression.
  
  This includes all 'my', 'state', 'local' and 'our' statements.
  
  =head2 L<PPI::Statement::Compound>
  
  This covers the whole family of 'compound' statements, as described in
  L<perlsyn|perlsyn>.
  
  This includes all statements starting with 'if', 'unless', 'for', 'foreach'
  and 'while'. Note that this does NOT include 'do', as it is treated
  differently.
  
  All compound statements have implicit ends. That is, they do not end with
  a ';' statement terminator.
  
  =head2 L<PPI::Statement::Break>
  
  A statement that breaks out of a structure.
  
  This includes all of 'redo', 'goto', 'next', 'last' and 'return' statements.
  
  =head2 L<PPI::Statement::Given>
  
  The kind of statement introduced in Perl 5.10 that starts with 'given'.  This
  has an implicit end.
  
  =head2 L<PPI::Statement::When>
  
  The kind of statement introduced in Perl 5.10 that starts with 'when' or
  'default'.  This also has an implicit end.
  
  =head2 L<PPI::Statement::Data>
  
  A special statement which encompasses an entire C<__DATA__> block, including
  the initial C<'__DATA__'> token itself and the entire contents.
  
  =head2 L<PPI::Statement::End>
  
  A special statement which encompasses an entire __END__ block, including
  the initial '__END__' token itself and the entire contents, including any
  parsed PPI::Token::POD that may occur in it.
  
  =head2 L<PPI::Statement::Expression>
  
  L<PPI::Statement::Expression> is a little more speculative, and is intended
  to help represent the special rules relating to "expressions" such as in:
  
    # Several examples of expression statements
    
    # Boolean conditions
    if ( expression ) { ... }
    
    # Lists, such as for arguments
    Foo->bar( expression )
  
  =head2 L<PPI::Statement::Null>
  
  A null statement is a special case for where we encounter two consecutive
  statement terminators. ( ;; )
  
  The second terminator is given an entire statement of its own, but one
  that serves no purpose. Hence a 'null' statement.
  
  Theoretically, assuming a correct parsing of a perl file, all null statements
  are superfluous and should be able to be removed without damage to the file.
  
  But don't do that, in case PPI has parsed something wrong.
  
  =head2 L<PPI::Statement::UnmatchedBrace>
  
  Because L<PPI> is intended for use when parsing incorrect or incomplete code,
  the problem arises of what to do with a stray closing brace.
  
  Rather than die, it is allocated its own "unmatched brace" statement,
  which really means "unmatched closing brace". An unmatched open brace at the
  end of a file would become a structure with no contents and no closing brace.
  
  If the document loaded is intended to be correct and valid, finding a
  L<PPI::Statement::UnmatchedBrace> in the PDOM is generally indicative of a
  misparse.
  
  =head2 L<PPI::Statement::Unknown>
  
  This is used temporarily mid-parsing to hold statements for which the lexer
  cannot yet determine what class it should be, usually because there are
  insufficient clues, or it might be more than one thing.
  
  You should never encounter these in a fully parsed PDOM tree.
  
  =head1 METHODS
  
  C<PPI::Statement> itself has very few methods. Most of the time, you will be
  working with the more generic L<PPI::Element> or L<PPI::Node> methods, or one
  of the methods that are subclass-specific.
  
  =cut
  
  use strict;
  use Scalar::Util   ();
  use Params::Util   qw{_INSTANCE};
  use PPI::Node      ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA *_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Node';
  	*_PARENT = *PPI::Element::_PARENT;
  }
  
  use PPI::Statement::Break          ();
  use PPI::Statement::Compound       ();
  use PPI::Statement::Data           ();
  use PPI::Statement::End            ();
  use PPI::Statement::Expression     ();
  use PPI::Statement::Include        ();
  use PPI::Statement::Null           ();
  use PPI::Statement::Package        ();
  use PPI::Statement::Scheduled      ();
  use PPI::Statement::Sub            ();
  use PPI::Statement::Given         ();
  use PPI::Statement::UnmatchedBrace ();
  use PPI::Statement::Unknown        ();
  use PPI::Statement::Variable       ();
  use PPI::Statement::When           ();
  
  # "Normal" statements end at a statement terminator ;
  # Some are not, and need the more rigorous _continues to see
  # if we are at an implicit statement boundary.
  sub __LEXER__normal() { 1 }
  
  
  
  
  
  #####################################################################
  # Constructor
  
  sub new {
  	my $class = shift;
  	if ( ref $class ) {
  		PPI::Exception->throw;
  	}
  
  	# Create the object
  	my $self = bless { 
  		children => [],
  	}, $class;
  
  	# If we have been passed what should be an initial token, add it
  	my $token = shift;
  	if ( _INSTANCE($token, 'PPI::Token') ) {
  		# Inlined $self->__add_element(shift);
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $token} = $self
  		);
  		push @{$self->{children}}, $token;
  	}
  
  	$self;
  }
  
  =pod
  
  =head2 label
  
  One factor common to most statements is their ability to be labeled.
  
  The C<label> method returns the label for a statement, if one has been
  defined, but without the trailing colon. Take the following example
  
    MYLABEL: while ( 1 .. 10 ) { last MYLABEL if $_ > 5 }
  
  For the above statement, the C<label> method would return 'MYLABEL'.
  
  Returns false if the statement does not have a label.
  
  =cut
  
  sub label {
  	my $first = shift->schild(1) or return '';
  	$first->isa('PPI::Token::Label')
  		? substr($first, 0, length($first) - 1)
  		: '';
  }
  
  =pod
  
  =head2 specialized
  
  Answer whether this is a plain statement or one that has more
  significance.
  
  Returns true if the statement is a subclass of this one, false
  otherwise.
  
  =cut
  
  # Yes, this is doing precisely what it's intending to prevent
  # client code from doing.  However, since it's here, if the
  # implementation changes, code outside PPI doesn't care.
  sub specialized {
  	__PACKAGE__ ne ref $_[0];
  }
  
  =pod
  
  =head2 stable
  
  Much like the L<PPI::Document> method of the same name, the ->stable
  method converts a statement to source and back again, to determine if
  a modified statement is still legal, and won't be interpreted in a
  different way.
  
  Returns true if the statement is stable, false if not, or C<undef> on
  error.
  
  =cut
  
  sub stable {
  	die "The ->stable method has not yet been implemented";	
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # Is the statement complete.
  # By default for a statement, we need a semi-colon at the end.
  sub _complete {
  	my $self = shift;
  	my $semi = $self->schild(-1);
  	return !! (
  		defined $semi
  		and
  		$semi->isa('PPI::Token::Structure')
  		and
  		$semi->content eq ';'
  	);
  }
  
  # You can insert either a statement or a non-significant token.
  sub insert_before {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Statement') ) {
  		return $self->__insert_before($Element);
  	} elsif ( $Element->isa('PPI::Token') and ! $Element->significant ) {
  		return $self->__insert_before($Element);
  	}
  	'';
  }
  
  # As above, you can insert a statement, or a non-significant token
  sub insert_after {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Statement') ) {
  		return $self->__insert_after($Element);
  	} elsif ( $Element->isa('PPI::Token') and ! $Element->significant ) {
  		return $self->__insert_after($Element);
  	}
  	'';
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Complete, freeze and document the remaining classes
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Break - Statements which break out of normal statement flow
  
  =head1 SYNOPSIS
  
    last;
    goto FOO;
    next if condition();
    return $foo;
    redo;
  
  =head1 INHERITANCE
  
    PPI::Statement::Break
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Break> is intended to represent statements that break
  out of the normal statement flow control. This covers the basic
  types C<'redo'>, C<'goto'>, C<'next'>, C<'last'> and C<'return'>.
  
  =head1 METHODS
  
  C<PPI::Statement::Break> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  However, it is expected to gain methods for identifying the line to break
  to, or the structure to break out of.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add the methods to identify the break target
  
  - Add some proper unit testing
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Compound - Describes all compound statements
  
  =head1 SYNOPSIS
  
    # A compound if statement
    if ( foo ) {
        bar();
    } else {
        baz();
    }
  
    # A compound loop statement
    foreach ( @list ) {
        bar($_);
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::Compound
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Compound> objects are used to describe all current forms
  of compound statements, as described in L<perlsyn>.
  
  This covers blocks using C<if>, C<unless>, C<for>, C<foreach>, C<while>,
  and C<continue>. Please note this does B<not> cover "simple" statements
  with trailing conditions. Please note also that "do" is also not part of
  a compound statement.
  
    # This is NOT a compound statement
    my $foo = 1 if $condition;
  
    # This is also not a compound statement
    do { ... } until $condition;
  
  =head1 METHODS
  
  C<PPI::Statement::Compound> has a number of methods in addition to the
  standard L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA %TYPES};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  
  	# Keyword type map
  	%TYPES = (
  		'if'      => 'if',
  		'unless'  => 'if',
  		'while'   => 'while',
  		'until'   => 'while',
  		'for'     => 'for',
  		'foreach' => 'foreach',
  	);
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  
  
  
  
  #####################################################################
  # PPI::Statement::Compound analysis methods
  
  =pod
  
  =head2 type
  
  The C<type> method returns the syntactic type of the compound statement.
  
  There are four basic compound statement types.
  
  The C<'if'> type includes all variations of the if and unless statements,
  including any C<'elsif'> or C<'else'> parts of the compound statement.
  
  The C<'while'> type describes the standard while and until statements, but
  again does B<not> describes simple statements with a trailing while.
  
  The C<'for'> type covers the C-style for loops, regardless of whether they
  were declared using C<'for'> or C<'foreach'>.
  
  The C<'foreach'> type covers loops that iterate over collections,
  regardless of whether they were declared using C<'for'> or C<'foreach'>.
  
  All of the compounds are a variation on one of these four.
  
  Returns the simple string C<'if'>, C<'for'>, C<'foreach'> or C<'while'>,
  or C<undef> if the type cannot be determined.
  
  =cut
  
  sub type {
  	my $self    = shift;
  	my $p       = 0; # Child position
  	my $Element = $self->schild($p) or return undef;
  
  	# A labelled statement
  	if ( $Element->isa('PPI::Token::Label') ) {
  		$Element = $self->schild(++$p) or return 'label';
  	}
  
  	# Most simple cases
  	my $content = $Element->content;
  	if ( $content =~ /^for(?:each)?\z/ ) {
  		$Element = $self->schild(++$p) or return $content;
  		if ( $Element->isa('PPI::Token') ) {
  			return 'foreach' if $Element->content =~ /^my|our|state\z/;
  			return 'foreach' if $Element->isa('PPI::Token::Symbol');
  			return 'foreach' if $Element->isa('PPI::Token::QuoteLike::Words');
  		}
  		if ( $Element->isa('PPI::Structure::List') ) {
  			return 'foreach';
  		}
  		return 'for';
  	}
  	return $TYPES{$content} if $Element->isa('PPI::Token::Word');
  	return 'continue'       if $Element->isa('PPI::Structure::Block');
  
  	# Unknown (shouldn't exist?)
  	undef;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  sub scope() { 1 }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  sub _complete {
  	my $self = shift;
  	my $type = $self->type or die "Illegal compound statement type";
  
  	# Check the different types of compound statements
  	if ( $type eq 'if' ) {
  		# Unless the last significant child is a complete
  		# block, it must be incomplete.
  		my $child = $self->schild(-1) or return '';
  		$child->isa('PPI::Structure') or return '';
  		$child->braces eq '{}'        or return '';
  		$child->_complete             or return '';
  
  		# It can STILL be
  	} elsif ( $type eq 'while' ) {
  		die "CODE INCOMPLETE";
  	} else {
  		die "CODE INCOMPLETE";
  	}
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Data - The __DATA__ section of a file
  
  =head1 SYNOPSIS
  
    # Normal content
    
    __DATA__
    This: data
    is: part
    of: the
    PPI::Statement::Data: object
  
  =head1 INHERITANCE
  
    PPI::Statement::Compound
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Data> is a utility class designed to hold content in
  the __DATA__ section of a file. It provides a single statement to hold
  B<all> of the data.
  
  =head1 METHODS
  
  C<PPI::Statement::Data> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  However, it is expected to gain methods for accessing the data directly,
  (as a filehandle for example) just as you would access the data in the
  Perl code itself.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Data is never complete
  sub _complete () { '' }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add the methods to read in the data
  
  - Add some proper unit testing
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::End - Content after the __END__ of a module
  
  =head1 SYNOPSIS
  
    # This is normal content
    
    __END__
    
    This is part of a PPI::Statement::End statement
    
    =pod
    
    This is not part of the ::End statement, it's POD
    
    =cut
    
    This is another PPI::Statement::End statement
  
  =head1 INHERITANCE
  
    PPI::Statement::End
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::End> is a utility class designed to serve as a contained
  for all of the content after the __END__ tag in a file.
  
  It doesn't cover the ENTIRE of the __END__ section, and can be interspersed
  with L<PPI::Token::Pod> tokens.
  
  =head1 METHODS
  
  C<PPI::Statement::End> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Once we have an __END__ we're done
  sub _complete () { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Expression - A generic and non-specialised statement
  
  =head1 SYNOPSIS
  
    $foo = bar;
    ("Hello World!");
    do_this();
  
  =head1 INHERITANCE
  
    PPI::Statement::Expression
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Statement::Expression> is a normal statement that is evaluated,
  may or may not assign, may or may not have side effects, and has no special
  or redeeming features whatsoever.
  
  It provides a default for all statements that don't fit into any other
  classes.
  
  =head1 METHODS
  
  C<PPI::Statement::Expression> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Given - A given-when statement
  
  =head1 SYNOPSIS
  
    given ( foo ) {
        say $_;
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::Given
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Given> objects are used to describe switch statements, as
  described in L<perlsyn>.
  
  =head1 METHODS
  
  C<PPI::Statement::Given> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  sub scope() { 1 }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Include - Statements that include other code
  
  =head1 SYNOPSIS
  
    # The following are all includes
    use 5.006;
    use strict;
    use My::Module;
    use constant FOO => 'Foo';
    require Foo::Bar;
    require "Foo/Bar.pm";
    require $foo if 1;
    no strict 'refs';
  
  =head1 INHERITANCE
  
    PPI::Statement::Include
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Despite its name, the C<PPI::Statement::Include> class covers a number
  of different types of statement that cover all statements starting with
  C<use>, C<no> and C<require>.
  
  But basically, they cover three situations.
  
  Firstly, a dependency on a particular version of perl (for which the
  C<version> method returns true), a pragma (for which the C<pragma> method
  returns true), or the loading (and unloading via no) of modules.
  
  =head1 METHODS
  
  C<PPI::Statement::Include> has a number of methods in addition to the standard
  L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement                 ();
  use PPI::Statement::Include::Perl6 ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  =pod
  
  =head2 type
  
  The C<type> method returns the general type of statement (C<'use'>, C<'no'>
  or C<'require'>).
  
  Returns the type as a string, or C<undef> if the type cannot be detected.
  
  =cut
  
  sub type {
  	my $self    = shift;
  	my $keyword = $self->schild(0) or return undef;
  	$keyword->isa('PPI::Token::Word') and $keyword->content;
  }
  
  =pod
  
  =head2 module
  
  The C<module> method returns the module name specified in any include
  statement. This C<includes> pragma names, because pragma are implemented
  as modules. (And lets face it, the definition of a pragma can be fuzzy
  at the best of times in any case)
  
  This covers all of these...
  
    use strict;
    use My::Module;
    no strict;
    require My::Module;
  
  ...but does not cover any of these...
  
    use 5.006;
    require 5.005;
    require "explicit/file/name.pl";
  
  Returns the module name as a string, or C<undef> if the include does
  not specify a module name.
  
  =cut
  
  sub module {
  	my $self = shift;
  	my $module = $self->schild(1) or return undef;
  	$module->isa('PPI::Token::Word') and $module->content;
  }
  
  =pod
  
  =head2 module_version
  
  The C<module_version> method returns the minimum version of the module
  required by the statement, if there is one.
  
  =cut
  
  sub module_version {
  	my $self     = shift;
  	my $argument = $self->schild(3);
  	if ( $argument and $argument->isa('PPI::Token::Operator') ) {
  		return undef;
  	}
  
  	my $version = $self->schild(2) or return undef;
  	return undef unless $version->isa('PPI::Token::Number');
  
  	return $version;
  }
  
  =pod
  
  =head2 pragma
  
  The C<pragma> method checks for an include statement's use as a
  pragma, and returns it if so.
  
  Or at least, it claims to. In practice it's a lot harder to say exactly
  what is or isn't a pragma, because the definition is fuzzy.
  
  The C<intent> of a pragma is to modify the way in which the parser works.
  This is done though the use of modules that do various types of internals
  magic.
  
  For now, PPI assumes that any "module name" that is only a set of
  lowercase letters (and perhaps numbers, like C<use utf8;>). This
  behaviour is expected to change, most likely to something that knows
  the specific names of the various "pragmas".
  
  Returns the name of the pragma, or false ('') if the include is not a
  pragma.
  
  =cut
  
  sub pragma {
  	my $self   = shift;
  	my $module = $self->module or return '';
  	$module =~ /^[a-z][a-z\d]*$/ ? $module : '';
  }
  
  =pod
  
  =head2 version
  
  The C<version> method checks for an include statement that introduces a
  dependency on the version of C<perl> the code is compatible with.
  
  This covers two specific statements.
  
    use 5.006;
    require 5.006;
  
  Currently the version is returned as a string, although in future the version
  may be returned as a L<version> object.  If you want a numeric representation,
  use C<version_literal()>.  Returns false if the statement is not a version
  dependency.
  
  =cut
  
  sub version {
  	my $self    = shift;
  	my $version = $self->schild(1) or return undef;
  	$version->isa('PPI::Token::Number') ? $version->content : '';
  }
  
  =pod
  
  =head2 version_literal
  
  The C<version_literal> method has the same behavior as C<version()>, but the
  version is returned as a numeric literal.  Returns false if the statement is
  not a version dependency.
  
  =cut
  
  sub version_literal {
  	my $self    = shift;
  	my $version = $self->schild(1) or return undef;
  	$version->isa('PPI::Token::Number') ? $version->literal : '';
  }
  
  =pod
  
  =head2 arguments
  
  The C<arguments> method gives you the rest of the statement after the
  module/pragma and module version, i.e. the stuff that will be used to
  construct what gets passed to the module's C<import()> subroutine.  This does
  include the comma, etc. operators, but doesn't include non-significant direct
  children or any final semicolon.
  
  =cut
  
  sub arguments {
  	my $self = shift;
  	my @args = $self->schildren;
  
  	# Remove the "use", "no" or "require"
  	shift @args;
  
  	# Remove the statement terminator
  	if (
  		$args[-1]->isa('PPI::Token::Structure')
  		and
  		$args[-1]->content eq ';'
  	) {
  		pop @args;
  	}
  
  	# Remove the module or perl version.
  	shift @args;  
  
  	return unless @args;
  
  	if ( $args[0]->isa('PPI::Token::Number') ) {
  		my $after = $args[1] or return;
  		$after->isa('PPI::Token::Operator') or shift @args;
  	}
  
  	return @args;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write specific unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Include::Perl6 - Inline Perl 6 file section
  
  =head1 SYNOPSIS
  
    use v6-alpha;
    
    grammar My::Grammar {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::Include::Perl6
    isa PPI::Statement::Include
        isa PPI::Statement
            isa PPI::Node
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Statement::Include::Perl6> is a special include statement that
  indicates the start of a section of Perl 6 code inlined into a regular
  Perl 5 code file.
  
  The primary purpose of the class is to allow L<PPI> to provide at least
  basic support for "6 in 5" modules like v6.pm;
  
  Currently, PPI only supports starting a Perl 6 block. It does not
  currently support changing back to Perl 5 again. Additionally all POD
  and __DATA__ blocks and __END__ blocks will be included in the Perl 6
  string and will not be parsed by PPI.
  
  =cut
  
  use strict;
  use PPI::Statement::Include ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement::Include';
  }
  
  =pod
  
  =head2 perl6
  
  The C<perl6> method returns the block of Perl 6 code that is attached to
  the "use v6...;" command.
  
  =cut
  
  sub perl6 {
  	$_[0]->{perl6};
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write specific unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Null - A useless null statement
  
  =head1 SYNOPSIS
  
    my $foo = 1;
    
    ; # <-- Null statement
    
    my $bar = 1;
  
  =head1 INHERITANCE
  
    PPI::Statement::Null
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Null> is a utility class designed to handle situations
  where PPI encounters a naked statement separator.
  
  Although strictly speaking, the semicolon is a statement B<separator>
  and not a statement B<terminator>, PPI considers a semicolon to be a
  statement terminator under most circumstances.
  
  In any case, the null statement has no purpose, and can be safely deleted
  with no ill effect.
  
  =head1 METHODS
  
  C<PPI::Statement::Null> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # A null statement is not significant
  sub significant() { '' }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Package - A package statement
  
  =head1 INHERITANCE
  
    PPI::Statement::Package
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Most L<PPI::Statement> subclasses are assigned based on the value of the
  first token or word found in the statement. When PPI encounters a statement
  starting with 'package', it converts it to a C<PPI::Statement::Package>
  object.
  
  When working with package statements, please remember that packages only
  exist within their scope, and proper support for scoping has yet to be
  completed in PPI.
  
  However, if the immediate parent of the package statement is the
  top level L<PPI::Document> object, then it can be considered to define
  everything found until the next top-level "file scoped" package statement.
  
  A file may, however, contain nested temporary package, in which case you
  are mostly on your own :)
  
  =head1 METHODS
  
  C<PPI::Statement::Package> has a number of methods in addition to the standard
  L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  =pod
  
  =head2 namespace
  
  Most package declarations are simple, and just look something like
  
    package Foo::Bar;
  
  The C<namespace> method returns the name of the declared package, in the
  above case 'Foo::Bar'. It returns this exactly as written and does not
  attempt to clean up or resolve things like ::Foo to main::Foo.
  
  If the package statement is done any different way, it returns false.
  
  =cut
  
  sub namespace {
  	my $self = shift;
  	my $namespace = $self->schild(1) or return '';
  	$namespace->isa('PPI::Token::Word')
  		? $namespace->content
  		: '';
  }
  
  =pod
  
  =head2 version
  
  Some package declarations may include a version:
  
    package Foo::Bar 1.23;
    package Baz v1.23;
  
  The C<version> method returns the stringified version as seen in the
  document (if any), otherwise the empty string.
  
  =cut
  
  sub version {
  	my $self = shift;
  	my $version = $self->schild(2) or return '';
  	$version->isa('PPI::Token::Structure')
  		? ''
  		: $version->content;
  }
  
  =pod
  
  =head2 file_scoped
  
  Regardless of whether it is named or not, the C<file_scoped> method will
  test to see if the package declaration is a top level "file scoped"
  statement or not, based on its location.
  
  In general, returns true if it is a "file scoped" package declaration with
  an immediate parent of the top level Document, or false if not.
  
  Note that if the PPI DOM tree B<does not> have a PPI::Document object at
  as the root element, this will return false. Likewise, it will also return
  false if the root element is a L<PPI::Document::Fragment>, as a fragment of
  a file does not represent a scope.
  
  =cut
  
  sub file_scoped {
  	my $self     = shift;
  	my ($Parent, $Document) = ($self->parent, $self->top);
  	$Parent and $Document and $Parent == $Document
  	and $Document->isa('PPI::Document')
  	and ! $Document->isa('PPI::Document::Fragment');
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Scheduled - A scheduled code block
  
  =head1 INHERITANCE
  
    PPI::Statement::Scheduled
    isa PPI::Statement::Sub
        isa PPI::Statement
            isa PPI::Node
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  A scheduled code block is one that is intended to be run at a specific
  time during the loading process.
  
  There are five types of scheduled block:
  
    BEGIN {
    	# Executes as soon as this block is fully defined
    	...
    }
  
    CHECK {
    	# Executes after overall compile-phase in reverse order
    	...
    }
  
    UNITCHECK {
    	# Executes after compile-phase of individual module in reverse order
    	...
    }
  
    INIT {
    	# Executes just before run-time
    	...
    }
  
    END {
    	# Executes as late as possible in reverse order
    	...
    }
  
  Technically these scheduled blocks are actually subroutines, and in fact
  may have 'sub' in front of them.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Statement::Sub ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement::Sub';
  }
  
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  =pod
  
  =head2 type
  
  The C<type> method returns the type of scheduled block, which should always be
  one of C<'BEGIN'>, C<'CHECK'>, C<'UNITCHECK'>, C<'INIT'> or C<'END'>.
  
  =cut
  
  sub type {
  	my $self     = shift;
  	my @children = $self->schildren or return undef;
  	$children[0]->content eq 'sub'
  		? $children[1]->content
  		: $children[0]->content;
  }
  
  # This is actually the same as Sub->name
  sub name {
  	shift->type(@_);
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Sub - Subroutine declaration
  
  =head1 INHERITANCE
  
    PPI::Statement::Sub
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Except for the special BEGIN, CHECK, UNITCHECK, INIT, and END subroutines
  (which are part of L<PPI::Statement::Scheduled>) all subroutine declarations
  are lexed as a PPI::Statement::Sub object.
  
  Primarily, this means all of the various C<sub foo {}> statements, but also
  forward declarations such as C<sub foo;> or C<sub foo($);>. It B<does not>
  include anonymous subroutines, as these are merely part of a normal statement.
  
  =head1 METHODS
  
  C<PPI::Statement::Sub> has a number of methods in addition to the standard
  L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use List::Util     ();
  use Params::Util   qw{_INSTANCE};
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clue
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  
  
  
  
  #####################################################################
  # PPI::Statement::Sub Methods
  
  =pod
  
  =head2 name
  
  The C<name> method returns the name of the subroutine being declared.
  
  In some rare cases such as a naked C<sub> at the end of the file, this may return
  false.
  
  =cut
  
  sub name {
  	my ($self) = @_;
  
  	# Usually the second token is the name.
  	my $token = $self->schild(1);
  	return $token->content
  	  if defined $token and $token->isa('PPI::Token::Word');
  
  	# In the case of special subs whose 'sub' can be omitted (AUTOLOAD
  	# or DESTROY), the name will be the first token.
  	$token = $self->schild(0);
  	return $token->content
  	  if defined $token and $token->isa('PPI::Token::Word');
  	return '';
  }
  
  =pod
  
  =head2 prototype
  
  If it has one, the C<prototype> method returns the subroutine's prototype.
  It is returned in the same format as L<PPI::Token::Prototype/prototype>,
  cleaned and removed from its brackets.
  
  Returns the subroutine's prototype, or undef if the subroutine does not
  define one. Note that when the sub has an empty prototype (C<()>) the
  return is an empty string.
  
  =cut
  
  sub prototype {
  	my $self      = shift;
  	my $Prototype = List::Util::first {
  		_INSTANCE($_, 'PPI::Token::Prototype')
  	} $self->children;
  	defined($Prototype) ? $Prototype->prototype : undef;
  }
  
  =pod
  
  =head2 block
  
  With its name and implementation shared with L<PPI::Statement::Scheduled>,
  the C<block> method finds and returns the actual Structure object of the
  code block for this subroutine.
  
  Returns false if this is a forward declaration, or otherwise does not have a
  code block.
  
  =cut
  
  sub block {
  	my $self = shift;
  	my $lastchild = $self->schild(-1) or return '';
  	$lastchild->isa('PPI::Structure::Block') and $lastchild;
  }
  
  =pod
  
  =head2 forward
  
  The C<forward> method returns true if the subroutine declaration is a
  forward declaration.
  
  That is, it returns false if the subroutine has a code block, or true
  if it does not.
  
  =cut
  
  sub forward {
  	! shift->block;
  }
  
  =pod
  
  =head2 reserved
  
  The C<reserved> method provides a convenience method for checking to see
  if this is a special reserved subroutine. It does not check against any
  particular list of reserved sub names, but just returns true if the name
  is all uppercase, as defined in L<perlsub>.
  
  Note that in the case of BEGIN, CHECK, UNITCHECK, INIT and END, these will be
  defined as L<PPI::Statement::Scheduled> objects, not subroutines.
  
  Returns true if it is a special reserved subroutine, or false if not.
  
  =cut
  
  sub reserved {
  	my $self = shift;
  	my $name = $self->name or return '';
  	# perlsub is silent on whether reserveds can contain:
  	# - underscores;
  	# we allow them due to existing practice like CLONE_SKIP and __SUB__.
  	# - numbers; we allow them by PPI tradition.
  	$name eq uc $name;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Unknown - An unknown or transient statement
  
  =head1 INHERITANCE
  
    PPI::Statement::Unknown
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Statement::Unknown> class is used primarily during the lexing
  process to hold elements that are known to be statement, but for which
  the exact C<type> of statement is as yet unknown, and requires further
  tokens in order to resolve the correct type.
  
  They should not exist in a fully parse B<valid> document, and if any
  exists they indicate either a problem in Document, or possibly (by
  allowing it to get through unresolved) a bug in L<PPI::Lexer>.
  
  =head1 METHODS
  
  C<PPI::Statement::Unknown> has no additional methods beyond the
  default ones provided by L<PPI::Statement>, L<PPI::Node> and
  L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # If one of these ends up in the final document,
  # we're pretty much screwed. Just call it a day.
  sub _complete () { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::UnmatchedBrace - Isolated unmatched brace
  
  =head1 SYNOPSIS
  
    sub foo {
        1;
    }
    
    } # <--- This is an unmatched brace
  
  =head1 INHERITANCE
  
    PPI::Statement::UnmatchedBrace
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Statement::UnmatchedBrace> class is a miscellaneous utility
  class. Objects of this type should be rare, or not exist at all in normal
  valid L<PPI::Document> objects.
  
  It can be either a round ')', square ']' or curly '}' brace, this class
  does not distinguish. Objects of this type are only allocated at a
  structural level, not a lexical level (as they are lexically invalid
  anyway).
  
  The presence of a C<PPI::Statement::UnmatchedBrace> indicated a broken
  or invalid document. Or maybe a bug in PPI, but B<far> more likely a
  broken Document. :)
  
  =head1 METHODS
  
  C<PPI::Statement::UnmatchedBrace> has no additional methods beyond the
  default ones provided by L<PPI::Statement>, L<PPI::Node> and
  L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Once we've hit a naked unmatched brace we can never truly be complete.
  # So instead we always just call it a day...
  sub _complete () { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Variable - Variable declaration statements
  
  =head1 SYNOPSIS
  
    # All of the following are variable declarations
    my $foo = 1;
    my ($foo, $bar) = (1, 2);
    our $foo = 1;
    local $foo;
    local $foo = 1;
    LABEL: my $foo = 1;
  
  =head1 INHERITANCE
  
    PPI::Statement::Variable
    isa PPI::Statement::Expression
        isa PPI::Statement
            isa PPI::Node
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  The main intent of the C<PPI::Statement::Variable> class is to describe
  simple statements that explicitly declare new local or global variables.
  
  Note that this does not make it exclusively the only place where variables
  are defined, and later on you should expect that the C<variables> method
  will migrate deeper down the tree to either L<PPI::Statement> or
  L<PPI::Node> to recognise this fact, but for now it stays here.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util               qw{_INSTANCE};
  use PPI::Statement::Expression ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement::Expression';
  }
  
  =pod
  
  =head2 type
  
  The C<type> method checks and returns the declaration type of the statement,
  which will be one of 'my', 'local', 'our', or 'state'.
  
  Returns a string of the type, or C<undef> if the type cannot be detected
  (which is probably a bug).
  
  =cut
  
  sub type {
  	my $self = shift;
  
  	# Get the first significant child
  	my @schild = grep { $_->significant } $self->children;
  
  	# Ignore labels
  	shift @schild if _INSTANCE($schild[0], 'PPI::Token::Label');
  
  	# Get the type
  	(_INSTANCE($schild[0], 'PPI::Token::Word') and $schild[0]->content =~ /^(my|local|our|state)$/)
  		? $schild[0]->content
  		: undef;
  }
  
  =pod
  
  =head2 variables
  
  As for several other PDOM Element types that can declare variables, the
  C<variables> method returns a list of the canonical forms of the variables
  defined by the statement.
  
  Returns a list of the canonical string forms of variables, or the null list
  if it is unable to find any variables.
  
  =cut
  
  sub variables {
  	map { $_->canonical } $_[0]->symbols;
  }
  
  =pod
  
  =head2 symbols
  
  Returns a list of the variables defined by the statement, as
  L<PPI::Token::Symbol>s.
  
  =cut
  
  sub symbols {
  	my $self = shift;
  
  	# Get the children we care about
  	my @schild = grep { $_->significant } $self->children;
  	shift @schild if _INSTANCE($schild[0], 'PPI::Token::Label');
  
  	# If the second child is a symbol, return its name
  	if ( _INSTANCE($schild[1], 'PPI::Token::Symbol') ) {
  		return $schild[1];
  	}
  
  	# If it's a list, return as a list
  	if ( _INSTANCE($schild[1], 'PPI::Structure::List') ) {
  		my $Expression = $schild[1]->schild(0);
  		$Expression and
  		$Expression->isa('PPI::Statement::Expression') or return ();
  
  		# my and our are simpler than local
  		if (
  			$self->type eq 'my'
  			or
  			$self->type eq 'our'
  			or
  			$self->type eq 'state'
  		) {
  			return grep {
  				$_->isa('PPI::Token::Symbol')
  			} $Expression->schildren;
  		}
  
  		# Local is much more icky (potentially).
  		# Not that we are actually going to deal with it now,
  		# but having this separate is likely going to be needed
  		# for future bug reports about local() things.
  
  		# This is a slightly better way to check.
  		return grep {
  			$self->_local_variable($_)
  		} grep {
  			$_->isa('PPI::Token::Symbol')
  		} $Expression->schildren;
  	}
  
  	# erm... this is unexpected
  	();
  }
  
  sub _local_variable {
  	my ($self, $el) = @_;
  
  	# The last symbol should be a variable
  	my $n = $el->snext_sibling or return 1;
  	my $p = $el->sprevious_sibling;
  	if ( ! $p or $p eq ',' ) {
  		# In the middle of a list
  		return 1 if $n eq ',';
  
  		# The first half of an assignment
  		return 1 if $n eq '=';
  	}
  
  	# Lets say no for know... additional work
  	# should go here.
  	return '';
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::When - A when statement
  
  =head1 SYNOPSIS
  
    foreach ( qw/ foo bar baz / ) {
        when ( m/b/ ) {
            boing($_);
        }
        when ( m/f/ ) {
            boom($_);
        }
        default {
            tchak($_);
        }
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::When
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::When> objects are used to describe when and default
  statements, as described in L<perlsyn>.
  
  =head1 METHODS
  
  C<PPI::Structure::When> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  sub scope() {
  	1;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure - The base class for Perl braced structures
  
  =head1 INHERITANCE
  
    PPI::Structure
    isa PPI::Node
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  PPI::Structure is the root class for all Perl bracing structures. This
  covers all forms of C< [ ... ] >, C< { ... } >, and C< ( ... ) > brace
  types, and includes cases where only one half of the pair exist.
  
  The class PPI::Structure itself is full abstract and no objects of that
  type should actually exist in the tree.
  
  =head2 Elements vs Children
  
  A B<PPI::Structure> has an unusual existence. Unlike a L<PPI::Document>
  or L<PPI::Statement>, which both simply contain other elements, a
  structure B<both> contains and consists of content.
  
  That is, the brace tokens are B<not> considered to be "children" of the
  structure, but are part of it.
  
  In practice, this will mean that while the -E<gt>elements and -E<gt>tokens
  methods (and related) B<will> return a list with the brace tokens at either
  end, the -E<gt>children method explicitly will B<not> return the brace.
  
  =head1 STRUCTURE CLASSES
  
  Excluding the transient L<PPI::Structure::Unknown> that exists briefly
  inside the parser, there are eight types of structure.
  
  =head2 L<PPI::Structure::List>
  
  This covers all round braces used for function arguments, in C<foreach>
  loops, literal lists, and braces used for precedence-ordering purposes.
  
  =head2 L<PPI::Structure::For>
  
  Although B<not> used for the C<foreach> loop list, this B<is> used for
  the special case of the round-brace three-part semicolon-separated C<for>
  loop expression (the traditional C style for loop).
  
  =head2 L<PPI::Structure::Given>
  
  This is for the expression being matched in switch statements.
  
  =head2 L<PPI::Structure::When>
  
  This is for the matching expression in "when" statements.
  
  =head2 L<PPI::Structure::Condition>
  
  This round-brace structure covers boolean conditional braces, such as
  for C<if> and C<while> blocks.
  
  =head2 L<PPI::Structure::Block>
  
  This curly-brace and common structure is used for all form of code
  blocks. This includes those for C<if>, C<do> and similar, as well
  as C<grep>, C<map>, C<sort>, C<sub> and (labelled or anonymous) 
  scoping blocks.
  
  =head2 L<PPI::Structure::Constructor>
  
  This class covers brace structures used for the construction of
  anonymous C<ARRAY> and C<HASH> references.
  
  =head2 L<PPI::Structure::Subscript>
  
  This class covers square-braces and curly-braces used after a
  -E<gt> pointer to access the subscript of an C<ARRAY> or C<HASH>.
  
  =head1 METHODS
  
  C<PPI::Structure> itself has very few methods. Most of the time, you will be
  working with the more generic L<PPI::Element> or L<PPI::Node> methods, or one
  of the methods that are subclass-specific.
  
  =cut
  
  use strict;
  use Scalar::Util   ();
  use Params::Util   qw{_INSTANCE};
  use PPI::Node      ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA *_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Node';
  	*_PARENT = *PPI::Element::_PARENT;
  }
  
  use PPI::Structure::Block       ();
  use PPI::Structure::Condition   ();
  use PPI::Structure::Constructor ();
  use PPI::Structure::For         ();
  use PPI::Structure::Given       ();
  use PPI::Structure::List        ();
  use PPI::Structure::Subscript   ();
  use PPI::Structure::Unknown     ();
  use PPI::Structure::When        ();
  
  
  
  
  
  #####################################################################
  # Constructor
  
  sub new {
  	my $class = shift;
  	my $Token = PPI::Token::__LEXER__opens($_[0]) ? shift : return undef;
  
  	# Create the object
  	my $self = bless {
  		children => [],
  		start    => $Token,
  		}, $class;
  
  	# Set the start braces parent link
  	Scalar::Util::weaken(
  		$_PARENT{Scalar::Util::refaddr $Token} = $self
  	);
  
  	$self;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Structure API methods
  
  =pod
  
  =head2 start
  
  For lack of better terminology (like "open" and "close") that has not
  already in use for some other more important purpose, the two individual
  braces for the structure are known within PPI as the "start" and "finish"
  braces (at least for method purposes).
  
  The C<start> method returns the start brace for the structure (i.e. the
  opening brace).
  
  Returns the brace as a L<PPI::Token::Structure> or C<undef> if the
  structure does not have a starting brace.
  
  Under normal parsing circumstances this should never occur, but may happen
  due to manipulation of the PDOM tree.
  
  =cut
  
  sub start  { $_[0]->{start}  }
  
  =pod
  
  =head2 finish
  
  The C<finish> method returns the finish brace for the structure (i.e. the
  closing brace).
  
  Returns the brace as a L<PPI::Token::Structure> or C<undef> if the
  structure does not have a finishing brace. This can be quite common if
  the document is not complete (for example, from an editor where the user
  may be halfway through typeing a subroutine).
  
  =cut
  
  sub finish { $_[0]->{finish} }
  
  =pod
  
  =head2 braces
  
  The C<braces> method is a utility method which returns the brace type,
  regardless of whether both or just one of the braces is defined.
  
  Returns one of the three strings C<'[]'>, C<'{}'>, or C<'()'>, or C<undef>
  on error (primarily not having a start brace, as mentioned above).
  
  =cut
  
  sub braces {
  	my $self = $_[0]->{start} ? shift : return undef;
  	return {
  		'[' => '[]',
  		'(' => '()',
  		'{' => '{}',
  	}->{ $self->{start}->{content} };
  }
  
  =pod
  
  =head1 complete
  
  The C<complete> method is a convenience method that returns true if
  the both braces are defined for the structure, or false if only one
  brace is defined.
  
  Unlike the top level C<complete> method which checks for completeness
  in depth, the structure complete method ONLY confirms completeness
  for the braces, and does not recurse downwards.
  
  =cut
  
  sub complete {
  	!! ($_[0]->{start} and $_[0]->{finish});
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node overloaded methods
  
  # For us, the "elements" concept includes the brace tokens
  sub elements {
  	my $self = shift;
  
  	if ( wantarray ) {
  		# Return a list in array context
  		return ( $self->{start} || (), @{$self->{children}}, $self->{finish} || () );
  	} else {
  		# Return the number of elements in scalar context.
  		# This is memory-cheaper than creating another big array
  		return scalar(@{$self->{children}})
  			+ ($self->{start}  ? 1 : 0)
  			+ ($self->{finish} ? 1 : 0);
  	}
  }
  
  # For us, the first element is probably the opening brace
  sub first_element {
  	# Technically, if we have no children and no opening brace,
  	# then the first element is the closing brace.
  	$_[0]->{start} or $_[0]->{children}->[0] or $_[0]->{finish};
  }
  
  # For us, the last element is probably the closing brace
  sub last_element {
  	# Technically, if we have no children and no closing brace,
  	# then the last element is the opening brace
  	$_[0]->{finish} or $_[0]->{children}->[-1] or $_[0]->{start};
  }
  
  # Location is same as the start token, if any
  sub location {
  	my $self  = shift;
  	my $first = $self->first_element or return undef;
  	$first->location;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element overloaded methods
  
  # Get the full set of tokens, including start and finish
  sub tokens {
  	my $self = shift;
  	my @tokens = (
  		$self->{start}  || (),
  		$self->SUPER::tokens(@_),
  		$self->{finish} || (),
  		);
  	@tokens;
  }
  
  # Like the token method ->content, get our merged contents.
  # This will recurse downwards through everything
  ### Reimplement this using List::Utils stuff
  sub content {
  	my $self = shift;
  	my $content = $self->{start} ? $self->{start}->content : '';
  	foreach my $child ( @{$self->{children}} ) {
  		$content .= $child->content;
  	}
  	$content .= $self->{finish}->content if $self->{finish};
  	$content;
  }
  
  # Is the structure completed
  sub _complete {
  	!! ( defined $_[0]->{finish} );
  }
  
  # You can insert either another structure, or a token
  sub insert_before {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_before($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_before($Element);
  	}
  	'';
  }
  
  # As above, you can insert either another structure, or a token
  sub insert_after {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_after($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_after($Element);
  	}
  	'';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Block - Curly braces representing a code block
  
  =head1 SYNOPSIS
  
    sub foo { ... }
    
    grep { ... } @list;
    
    if ( condition ) {
        ...
    }
    
    LABEL: {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::Block
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Block> is the class used for all curly braces that
  represent code blocks. This includes subroutines, compound statements
  and any other block braces.
  
  =head1 METHODS
  
  C<PPI::Structure::Block> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # This is a scope boundary
  sub scope() { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Condition - Round braces for boolean context conditions
  
  =head1 SYNOPSIS
  
    if ( condition ) {
        ...
    }
    
    while ( condition ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::Condition
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Condition> is the class used for all round braces
  that represent boolean contexts used in various conditions.
  
  =head1 METHODS
  
  C<PPI::Structure::Condition> has no methods beyond those provided by
  the standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Constructor - Anonymous hash or array constructor
  
  =head1 SYNOPSIS
  
    my $array = [ 'foo', 'bar' ];
    my $hash  = { foo => 'bar' };
  
  =head1 INHERITANCE
  
    PPI::Structure::Constructor
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Constructor> is the class used for anonymous C<ARRAY>
  reference of C<HASH> reference constructors.
  
  =head1 METHODS
  
  C<PPI::Structure::Constructor> has no methods beyond those provided by
  the standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::For - Circular braces for a for expression
  
  =head1 SYNOPSIS
  
    for ( var $i = 0; $i < $max; $i++ ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::For
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::For> is the class used for circular braces that
  contain the three part C<for> expression.
  
  =head1 METHODS
  
  C<PPI::Structure::For> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  # Highly special custom isa method that will continue to respond
  # positively to ->isa('PPI::Structure::ForLoop') but warns.
  my $has_warned = 0;
  sub isa {
  	if ( $_[1] and $_[1] eq 'PPI::Structure::ForLoop' ) {
  		unless ( $has_warned ) {
  			warn("PPI::Structure::ForLoop has been deprecated");
  			$has_warned = 1;
  		}
  		return 1;
  	}
  	return shift->SUPER::isa(@_);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Given - Circular braces for a switch statement
  
  =head1 SYNOPSIS
  
    given ( something ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::Given
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Given> is the class used for circular braces that
  contain the thing to be matched in a switch statement.
  
  =head1 METHODS
  
  C<PPI::Structure::Given> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::List - Explicit list or precedence ordering braces
  
  =head1 SYNOPSIS
  
    # A list used for params
    function( 'param', 'param' );
    
    # Explicit list
    return ( 'foo', 'bar' );
  
  =head1 INHERITANCE
  
    PPI::Structure::List
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::List> is the class used for circular braces that
  represent lists, and related.
  
  =head1 METHODS
  
  C<PPI::Structure::List> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use Carp           ();
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  # Highly special custom isa method that will continue to respond
  # positively to ->isa('PPI::Structure::ForLoop') but warns.
  my $has_warned = 0;
  sub isa {
  	if ( $_[1] and $_[1] eq 'PPI::Structure::ForLoop' ) {
  		if (
  			$_[0]->parent->isa('PPI::Statement::Compound')
  			and
  			$_[0]->parent->type =~ /^for/
  		) {
  			unless ( $has_warned ) {
  				local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  				Carp::carp("PPI::Structure::ForLoop has been deprecated");
  				$has_warned = 1;
  			}
  			return 1;
  		}
  	}
  	return shift->SUPER::isa(@_);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Subscript - Braces that represent an array or hash subscript
  
  =head1 SYNOPSIS
  
    # The end braces for all of the following are subscripts
    $foo->[...]
    $foo[...]
    $foo{...}[...]
    $foo->{...}
    $foo{...}
    $foo[]{...}
  
  =head1 INHERITANCE
  
    PPI::Structure::Subscript
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Subscript> is the class used for square and curly
  braces that specify one element of an array or hash (or a slice/subset
  of an array or hash)
  
  =head1 METHODS
  
  C<PPI::Structure::Subscript> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Unknown - An unknown or unresolved brace structure
  
  =head1 INHERITANCE
  
    PPI::Structure::Unknown
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Unknown> is class for braces whose type is unknown, or
  temporarily unknown.
  
  It primarily exists temporarily inside the lexer. Although some types of
  braces can be determined immediately at opening, there are a number of
  different brace types that can only be correctly identified after the
  braces are closed.
  
  A structure is typed as unknown during this period it is indeterminate.
  
  A C<PPI::Structure::Unknown> object should not B<ever> make it out of the
  lexer without being converted to it's final type. Any time you encounter
  this class in a PDOM tree it should be considered a bug and reported
  accordingly.
  
  =head1 METHODS
  
  C<PPI::Structure::Unknown> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::When - Circular braces for a when statement
  
  =head1 SYNOPSIS
  
    when ( something ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::When
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::When> is the class used for circular braces that
  contain the thing to be matched in a when statement.
  
  =head1 METHODS
  
  C<PPI::Structure::When> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;
  
  =pod
  
  =head1 NAME
  
  PPI::Token - A single token of Perl source code
  
  =head1 INHERITANCE
  
    PPI::Token
    isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Token> is the abstract base class for all Tokens. In PPI terms, a "Token" is
  a L<PPI::Element> that directly represents bytes of source code.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util   qw{_INSTANCE};
  use PPI::Element   ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Element';
  }
  
  # We don't load the abstracts, they are loaded
  # as part of the inheritance process.
  
  # Load the token classes
  use PPI::Token::BOM                   ();
  use PPI::Token::Whitespace            ();
  use PPI::Token::Comment               ();
  use PPI::Token::Pod                   ();
  use PPI::Token::Number                ();
  use PPI::Token::Number::Binary        ();
  use PPI::Token::Number::Octal         ();
  use PPI::Token::Number::Hex           ();
  use PPI::Token::Number::Float         ();
  use PPI::Token::Number::Exp           ();
  use PPI::Token::Number::Version       ();
  use PPI::Token::Word                  ();
  use PPI::Token::DashedWord            ();
  use PPI::Token::Symbol                ();
  use PPI::Token::ArrayIndex            ();
  use PPI::Token::Magic                 ();
  use PPI::Token::Quote::Single         ();
  use PPI::Token::Quote::Double         ();
  use PPI::Token::Quote::Literal        ();
  use PPI::Token::Quote::Interpolate    ();
  use PPI::Token::QuoteLike::Backtick   ();
  use PPI::Token::QuoteLike::Command    ();
  use PPI::Token::QuoteLike::Regexp     ();
  use PPI::Token::QuoteLike::Words      ();
  use PPI::Token::QuoteLike::Readline   ();
  use PPI::Token::Regexp::Match         ();
  use PPI::Token::Regexp::Substitute    ();
  use PPI::Token::Regexp::Transliterate ();
  use PPI::Token::Operator              ();
  use PPI::Token::Cast                  ();
  use PPI::Token::Structure             ();
  use PPI::Token::Label                 ();
  use PPI::Token::HereDoc               ();
  use PPI::Token::Separator             ();
  use PPI::Token::Data                  ();
  use PPI::Token::End                   ();
  use PPI::Token::Prototype             ();
  use PPI::Token::Attribute             ();
  use PPI::Token::Unknown               ();
  
  
  
  
  
  #####################################################################
  # Constructor and Related
  
  sub new {
  	bless { content => (defined $_[1] ? "$_[1]" : '') }, $_[0];
  }
  
  sub set_class {
  	my $self  = shift;
  	# @_ or throw Exception("No arguments to set_class");
  	my $class = substr( $_[0], 0, 12 ) eq 'PPI::Token::' ? shift : 'PPI::Token::' . shift;
  
  	# Find out if the current and new classes are complex
  	my $old_quote = (ref($self) =~ /\b(?:Quote|Regex)\b/o) ? 1 : 0;
  	my $new_quote = ($class =~ /\b(?:Quote|Regex)\b/o)     ? 1 : 0;
  
  	# No matter what happens, we will have to rebless
  	bless $self, $class;
  
  	# If we are changing to or from a Quote style token, we
  	# can't just rebless and need to do some extra thing
  	# Otherwise, we have done enough
  	return $class if ($old_quote - $new_quote) == 0;
  
  	# Make a new token from the old content, and overwrite the current
  	# token's attributes with the new token's attributes.
  	my $token = $class->new( $self->{content} );
  	%$self = %$token;
  
  	# Return the class as a convenience
  	return $class;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token Methods
  
  =pod
  
  =head2 set_content $string
  
  The C<set_content> method allows you to set/change the string that the
  C<PPI::Token> object represents.
  
  Returns the string you set the Token to
  
  =cut
  
  sub set_content {
  	$_[0]->{content} = $_[1];
  }
  
  =pod
  
  =head2 add_content $string
  
  The C<add_content> method allows you to add additional bytes of code
  to the end of the Token.
  
  Returns the new full string after the bytes have been added.
  
  =cut
  
  sub add_content { $_[0]->{content} .= $_[1] }
  
  =pod
  
  =head2 length
  
  The C<length> method returns the length of the string in a Token.
  
  =cut
  
  sub length { CORE::length($_[0]->{content}) }
  
  
  
  
  
  #####################################################################
  # Overloaded PPI::Element methods
  
  sub content {
  	$_[0]->{content};
  }
  
  # You can insert either a statement, or a non-significant token.
  sub insert_before {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element')  or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_before($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_before($Element);
  	}
  	'';
  }
  
  # As above, you can insert a statement, or a non-significant token
  sub insert_after {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_after($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_after($Element);
  	}
  	'';
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_line_start() { 1 }
  sub __TOKENIZER__on_line_end()   { 1 }
  sub __TOKENIZER__on_char()       { 'Unknown' }
  
  
  
  
  
  #####################################################################
  # Lexer Methods
  
  sub __LEXER__opens {
  	ref($_[0]) eq 'PPI::Token::Structure'
  	and
  	$_[0]->{content} =~ /(?:\(|\[|\{)/
  }
  
  sub __LEXER__closes {
  	ref($_[0]) eq 'PPI::Token::Structure'
  	and
  	$_[0]->{content} =~ /(?:\)|\]|\})/
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::ArrayIndex - Token getting the last index for an array
  
  =head1 INHERITANCE
  
    PPI::Token::ArrayIndex
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::ArrayIndex> token represents an attempt to get the
  last index of an array, such as C<$#array>.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Suck in till the end of the arrayindex
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G([\w:']+)/gc ) {
  		$t->{token}->{content} .= $1;
  		$t->{line_cursor} += length $1;
  	}
  
  	# End of token
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Attribute - A token for a subroutine attribute
  
  =head1 INHERITANCE
  
    PPI::Token::Attribute
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  In Perl, attributes are a relatively recent addition to the language.
  
  Given the code C< sub foo : bar(something) {} >, the C<bar(something)>
  part is the attribute.
  
  A C<PPI::Token::Attribute> token represents the entire of the attribute,
  as the braces and its contents are not parsed into the tree, and are
  treated by Perl (and thus by us) as a single string.
  
  =head1 METHODS
  
  This class provides some additional methods beyond those provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  #####################################################################
  # PPI::Token::Attribute Methods
  
  =pod
  
  =head2 identifier
  
  The C<identifier> attribute returns the identifier part of the attribute.
  
  That is, for the attribute C<foo(bar)>, the C<identifier> method would
  return C<"foo">.
  
  =cut
  
  sub identifier {
  	my $self = shift;
  	$self->{content} =~ /^(.+?)\(/ ? $1 : $self->{content};
  }
  
  =pod
  
  =head2 parameters
  
  The C<parameters> method returns the parameter string for the attribute.
  
  That is, for the attribute C<foo(bar)>, the C<parameters> method would
  return C<"bar">.
  
  Returns the parameters as a string (including the null string C<''> for
  the case of an attribute such as C<foo()>.)
  
  Returns C<undef> if the attribute does not have parameters.
  
  =cut
  
  sub parameters {
  	my $self = shift;
  	$self->{content} =~ /\((.*)\)$/ ? $1 : undef;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Unless this is a '(', we are finished.
  	unless ( $char eq '(' ) {
  		# Finalise and recheck
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# This is a bar(...) style attribute.
  	# We are currently on the ( so scan in until the end.
  	# We finish on the character AFTER our end
  	my $string = $class->__TOKENIZER__scan_for_end( $t );
  	if ( ref $string ) {
  		# EOF
  		$t->{token}->{content} .= $$string;
  		$t->_finalize_token;
  		return 0;
  	}
  
  	# Found the end of the attribute
  	$t->{token}->{content} .= $string;
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  # Scan for a close braced, and take into account both escaping,
  # and open close bracket pairs in the string. When complete, the
  # method leaves the line cursor on the LAST character found.
  sub __TOKENIZER__scan_for_end {
  	my $t = $_[1];
  
  	# Loop as long as we can get new lines
  	my $string = '';
  	my $depth = 0;
  	while ( exists $t->{line} ) {
  		# Get the search area
  		pos $t->{line} = $t->{line_cursor};
  
  		# Look for a match
  		unless ( $t->{line} =~ /\G((?:\\.|[^()])*?[()])/gc ) {
  			# Load in the next line and push to first character
  			$string .= substr( $t->{line}, $t->{line_cursor} );
  			$t->_fill_line(1) or return \$string;
  			$t->{line_cursor} = 0;
  			next;
  		}
  
  		# Add to the string
  		$string .= $1;
  		$t->{line_cursor} += length $1;
  
  		# Alter the depth and continue if we aren't at the end
  		$depth += ($1 =~ /\($/) ? 1 : -1 and next;
  
  		# Found the end
  		return $string;
  	}
  
  	# Returning the string as a reference indicates EOF
  	\$string;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::BOM - Tokens representing Unicode byte order marks
  
  =head1 INHERITANCE
  
    PPI::Token::BOM
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  This is a special token in that it can only occur at the beginning of
  documents.  If a BOM byte mark occurs elsewhere in a file, it should
  be treated as L<PPI::Token::Whitespace>.  We recognize the byte order
  marks identified at this URL:
  L<http://www.unicode.org/faq/utf_bom.html#BOM>
  
      UTF-32, big-endian     00 00 FE FF
      UTF-32, little-endian  FF FE 00 00
      UTF-16, big-endian     FE FF
      UTF-16, little-endian  FF FE
      UTF-8                  EF BB BF
  
  Note that as of this writing, PPI only has support for UTF-8
  (namely, in POD and strings) and no support for UTF-16 or UTF-32.  We
  support the BOMs of the latter two for completeness only.
  
  The BOM is considered non-significant, like white space.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  sub significant() { '' }
  
  
  
  
  
  #####################################################################
  # Parsing Methods
  
  my %bom_types = (
     "\x00\x00\xfe\xff" => 'UTF-32',
     "\xff\xfe\x00\x00" => 'UTF-32',
     "\xfe\xff"         => 'UTF-16',
     "\xff\xfe"         => 'UTF-16',
     "\xef\xbb\xbf"     => 'UTF-8',
  );
  
  sub __TOKENIZER__on_line_start {
  	my $t = $_[1];
  	$_ = $t->{line};
  
  	if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs) {
  	   my $bom = $1;
  
  	   if ($bom_types{$bom} ne 'UTF-8') {
  	      return $t->_error("$bom_types{$bom} is not supported");
  	   }
  
  	   $t->_new_token('BOM', $bom) or return undef;
  	   $t->{line_cursor} += length $bom;
  	}
  
  	# Continue just as if there was no BOM
  	$t->{class} = 'PPI::Token::Whitespace';
  	return $t->{class}->__TOKENIZER__on_line_start($t);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Cast - A prefix which forces a value into a different context
  
  =head1 INHERITANCE
  
    PPI::Token::Cast
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A "cast" in PPI terms is one of more characters used as a prefix which force
  a value into a different class or context.
  
  This includes referencing, dereferencing, and a few other minor cases.
  
  For expressions such as C<@$foo> or C<@{ $foo{bar} }> the C<@> in both cases
  represents a cast. In this case, an array dereference.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  # A cast is either % @ $ or $#
  sub __TOKENIZER__on_char {
  	$_[1]->_finalize_token->__TOKENIZER__on_char( $_[1] );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Comment - A comment in Perl source code
  
  =head1 INHERITANCE
  
    PPI::Token::Comment
    isa PPI::Token
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    # This is a PPI::Token::Comment
    
    print "Hello World!"; # So it this
    
    $string =~ s/ foo  # This, unfortunately, is not :(
          bar
    	/w;
  
  =head1 DESCRIPTION
  
  In PPI, comments are represented by C<PPI::Token::Comment> objects.
  
  These come in two flavours, line comment and inline comments.
  
  A C<line comment> is a comment that stands on its own line. These comments
  hold their own newline and whitespace (both leading and trailing) as part
  of the one C<PPI::Token::Comment> object.
  
  An inline comment is a comment that appears after some code, and
  continues to the end of the line. This does B<not> include whitespace,
  and the terminating newlines is considered a separate
  L<PPI::Token::Whitespace> token.
  
  This is largely a convenience, simplifying a lot of normal code relating
  to the common things people do with comments.
  
  Most commonly, it means when you C<prune> or C<delete> a comment, a line
  comment disappears taking the entire line with it, and an inline comment
  is removed from the inside of the line, allowing the newline to drop
  back onto the end of the code, as you would expect.
  
  It also means you can move comments around in blocks much more easily.
  
  For now, this is a suitably handy way to do things. However, I do reserve
  the right to change my mind on this one if it gets dangerously
  anachronistic somewhere down the line.
  
  =head1 METHODS
  
  Only very limited methods are available, beyond those provided by our
  parent L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  ### XS -> PPI/XS.xs:_PPI_Token_Comment__significant 0.900+
  sub significant() { '' }
  
  # Most stuff goes through __TOKENIZER__commit.
  # This is such a rare case, do char at a time to keep the code small
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Make sure not to include the trailing newline
  	if ( substr( $t->{line}, $t->{line_cursor}, 1 ) eq "\n" ) {
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	1;
  }
  
  sub __TOKENIZER__commit {
  	my $t = $_[1];
  
  	# Get the rest of the line
  	my $rest = substr( $t->{line}, $t->{line_cursor} );
  	if ( chomp $rest ) { # Include the newline separately
  		# Add the current token, and the newline
  		$t->_new_token('Comment', $rest);
  		$t->_new_token('Whitespace', "\n");
  	} else {
  		# Add this token only
  		$t->_new_token('Comment', $rest);
  	}
  
  	# Advance the line cursor to the end
  	$t->{line_cursor} = $t->{line_length} - 1;
  
  	0;
  }
  
  # Comments end at the end of the line
  sub __TOKENIZER__on_line_end {
  	$_[1]->_finalize_token if $_[1]->{token};
  	1;
  }
  
  =pod
  
  =head2 line
  
  The C<line> accessor returns true if the C<PPI::Token::Comment> is a
  line comment, or false if it is an inline comment.
  
  =cut
  
  sub line {
  	# Entire line comments have a newline at the end
  	$_[0]->{content} =~ /\n$/ ? 1 : 0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::DashedWord - A dashed bareword token
  
  =head1 INHERITANCE
  
    PPI::Token::DashedWord
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The "dashed bareword" token represents literal values like C<-foo>.
  
  NOTE: this class is currently unused.  All tokens that should be
  PPI::Token::DashedWords are just normal PPI::Token::Word instead.
  That actually makes sense, since there really is nothing special about
  this class except that dashed words cannot be subroutine names or
  keywords.  As such, this class may be removed from PPI in the future.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  =pod
  
  =head2 literal
  
  Returns the value of the dashed word as a string.  This differs from
  C<content> because C<-Foo'Bar> expands to C<-Foo::Bar>.
  
  =cut
  
  *literal = *PPI::Token::Word::literal;
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Suck to the end of the dashed bareword
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G(\w+)/gc ) {
  		$t->{token}->{content} .= $1;
  		$t->{line_cursor} += length $1;
  	}
  
  	# Are we a file test operator?
  	if ( $t->{token}->{content} =~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/ ) {
  		# File test operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  	} else {
  		# No, normal dashed bareword
  		$t->{class} = $t->{token}->set_class( 'Word' );
  	}
  
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Data - The actual data in the __DATA__ section of a file
  
  =head1 INHERITANCE
  
    PPI::Token::Data
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Data> class is used to represent the actual data inside
  a file's C<__DATA__> section.
  
  One C<PPI::Token::Data> object is used to represent the entire of the data,
  primarily so that it can provide a convenient handle directly to the data.
  
  =head1 METHODS
  
  C<PPI::Token::Data> provides one method in addition to those provided by
  our parent L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use IO::String ();
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # Methods
  
  =pod
  
  =head2 handle
  
  The C<handle> method returns a L<IO::String> handle that allows you
  to do all the normal handle-y things to the contents of the __DATA__
  section of the file.
  
  Unlike in perl itself, this means you can also do things like C<print>
  new data onto the end of the __DATA__ section, or modify it with
  any other process that can accept an L<IO::Handle> as input or output.
  
  Returns an L<IO::String> object.
  
  =cut
  
  sub handle {
  	my $self = shift;
  	IO::String->new( \$self->{content} );
  }
  
  sub __TOKENIZER__on_line_start {
  	my ( $self, $t ) = @_;
  
  	# Add the line
  	if ( defined $t->{token} ) {
  		$t->{token}->{content} .= $t->{line};
  	}
  	else {
  		defined( $t->{token} = $t->{class}->new( $t->{line} ) ) or return undef;
  	}
  
  	return 0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::End - Completely useless content after the __END__ tag
  
  =head1 INHERITANCE
  
    PPI::Token::End
    isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  If you've read L<PPI::Token::Whitespace>, you should understand by now
  the concept of documents "floating in a sea of PPI::Token::Whitespace".
  
  Well it doesn't after the __END__ tag.
  
  Once you __END__, it's all over. Anything after that tag isn't even fit
  to be called whitespace. It just simply doesn't exist as far as perl
  (the interpreter) is concerned.
  
  That's not to say there isn't useful content. Most often people use
  the __END__ tag to hide POD content, so that perl never has to see it,
  and presumably providing some small speed up.
  
  That's fine. PPI likes POD. Any POD after the __END__ tag is parsed
  into valid L<PPI::Token::Pod> tags as normal. B<This> class, on the
  other hand, is for "what's after __END__ when it isn't POD". 
  
  Basically, the completely worthless bits of the file :)
  
  =head1 METHODS
  
  This class has no method beyond what is provided by its L<PPI::Token> and
  L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  ### XS -> PPI/XS.xs:_PPI_Token_End__significant 0.900+
  sub significant() { '' }
  
  sub __TOKENIZER__on_char() { 1 }
  
  sub __TOKENIZER__on_line_start {
  	my $t = $_[1];
  
  	# Can we classify the entire line in one go
  	if ( $t->{line} =~ /^=(\w+)/ ) {
  		# A Pod tag... change to pod mode
  		$t->_new_token( 'Pod', $t->{line} );
  		unless ( $1 eq 'cut' ) {
  			# Normal start to pod
  			$t->{class} = 'PPI::Token::Pod';
  		}
  
  		# This is an error, but one we'll ignore
  		# Don't go into Pod mode, since =cut normally
  		# signals the end of Pod mode
  	} else {
  		if ( defined $t->{token} ) {
  			# Add to existing token
  			$t->{token}->{content} .= $t->{line};
  		} else {
  			$t->_new_token( 'End', $t->{line} );
  		}
  	}
  
  	0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::HereDoc - Token class for the here-doc
  
  =head1 INHERITANCE
  
    PPI::Token::HereDoc
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  Here-docs are incredibly handy when writing Perl, but incredibly tricky
  when parsing it, primarily because they don't follow the general flow of
  input.
  
  They jump ahead and nab lines directly off the input buffer. Whitespace
  and newlines may not matter in most Perl code, but they matter in here-docs.
  
  They are also tricky to store as an object. They look sort of like an
  operator and a string, but they don't act like it. And they have a second
  section that should be something like a separate token, but isn't because a
  string can span from above the here-doc content to below it.
  
  So when parsing, this is what we do.
  
  Firstly, the PPI::Token::HereDoc object, does not represent the C<<< << >>>
  operator, or the "END_FLAG", or the content, or even the terminator.
  
  It represents all of them at once.
  
  The token itself has only the declaration part as its "content".
  
    # This is what the content of a HereDoc token is
    <<FOO
    
    # Or this
    <<"FOO"
    
    # Or even this
    <<      'FOO'
  
  That is, the "operator", any whitespace separator, and the quoted or bare
  terminator. So when you call the C<content> method on a HereDoc token, you
  get '<< "FOO"'.
  
  As for the content and the terminator, when treated purely in "content" terms
  they do not exist.
  
  The content is made available with the C<heredoc> method, and the name of
  the terminator with the C<terminator> method.
  
  To make things work in the way you expect, PPI has to play some games
  when doing line/column location calculation for tokens, and also during
  the content parsing and generation processes.
  
  Documents cannot simply by recreated by stitching together the token
  contents, and involve a somewhat more expensive procedure, but the extra
  expense should be relatively negligible unless you are doing huge
  quantities of them.
  
  Please note that due to the immature nature of PPI in general, we expect
  C<HereDocs> to be a rich (bad) source of corner-case bugs for quite a while,
  but for the most part they should more or less DWYM.
  
  =head2 Comparison to other string types
  
  Although technically it can be considered a quote, for the time being
  C<HereDocs> are being treated as a completely separate C<Token> subclass,
  and will not be found in a search for L<PPI::Token::Quote> or
  L<PPI::Token::QuoteLike objects>.
  
  This may change in the future, with it most likely to end up under
  QuoteLike.
  
  =head1 METHODS
  
  Although it has the standard set of C<Token> methods, C<HereDoc> objects
  have a relatively large number of unique methods all of their own.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::HereDoc Methods
  
  =pod
  
  =head2 heredoc
  
  The C<heredoc> method is the authoritative method for accessing the contents
  of the C<HereDoc> object.
  
  It returns the contents of the here-doc as a list of newline-terminated
  strings. If called in scalar context, it returns the number of lines in
  the here-doc, B<excluding> the terminator line.
  
  =cut
  
  sub heredoc {
  	wantarray
  		? @{shift->{_heredoc}}
  		: scalar @{shift->{_heredoc}};
  }
  
  =pod
  
  =head2 terminator
  
  The C<terminator> method returns the name of the terminating string for the
  here-doc.
  
  Returns the terminating string as an unescaped string (in the rare case
  the terminator has an escaped quote in it).
  
  =cut
  
  sub terminator {
  	shift->{_terminator};
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  # Parse in the entire here-doc in one call
  sub __TOKENIZER__on_char {
  	my $t     = $_[1];
  
  	# We are currently located on the first char after the <<
  
  	# Handle the most common form first for simplicity and speed reasons
  	### FIXME - This regex, and this method in general, do not yet allow
  	### for the null here-doc, which terminates at the first
  	### empty line.
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} !~ m/\G( \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx ) {
  		# Degenerate to a left-shift operation
  		$t->{token}->set_class('Operator');
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# Add the rest of the token, work out what type it is,
  	# and suck in the content until the end.
  	my $token = $t->{token};
  	$token->{content} .= $1;
  	$t->{line_cursor} += length $1;
  
  	# Find the terminator, clean it up and determine
  	# the type of here-doc we are dealing with.
  	my $content = $token->{content};
  	if ( $content =~ /^\<\<(\w+)$/ ) {
  		# Bareword
  		$token->{_mode}       = 'interpolate';
  		$token->{_terminator} = $1;
  
  	} elsif ( $content =~ /^\<\<\s*\'(.*)\'$/ ) {
  		# ''-quoted literal
  		$token->{_mode}       = 'literal';
  		$token->{_terminator} = $1;
  		$token->{_terminator} =~ s/\\'/'/g;
  
  	} elsif ( $content =~ /^\<\<\s*\"(.*)\"$/ ) {
  		# ""-quoted literal
  		$token->{_mode}       = 'interpolate';
  		$token->{_terminator} = $1;
  		$token->{_terminator} =~ s/\\"/"/g;
  
  	} elsif ( $content =~ /^\<\<\s*\`(.*)\`$/ ) {
  		# ``-quoted command
  		$token->{_mode}       = 'command';
  		$token->{_terminator} = $1;
  		$token->{_terminator} =~ s/\\`/`/g;
  
  	} elsif ( $content =~ /^\<\<\\(\w+)$/ ) {
  		# Legacy forward-slashed bareword
  		$token->{_mode}       = 'literal';
  		$token->{_terminator} = $1;
  
  	} else {
  		# WTF?
  		return undef;
  	}
  
  	# Suck in the HEREDOC
  	$token->{_heredoc} = \my @heredoc;
  	my $terminator = $token->{_terminator} . "\n";
  	while ( defined( my $line = $t->_get_line ) ) {
  		if ( $line eq $terminator ) {
  			# Keep the actual termination line for consistency
  			# when we are re-assembling the file
  			$token->{_terminator_line} = $line;
  
  			# The HereDoc is now fully parsed
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		# Add the line
  		push @heredoc, $line;
  	}
  
  	# End of file.
  	# Error: Didn't reach end of here-doc before end of file.
  
  	# If the here-doc block is not empty, look at the last line to determine if
  	# the here-doc terminator is missing a newline (which Perl would fail to
  	# compile but is easy to detect) or if the here-doc block was just not
  	# terminated at all (which Perl would fail to compile as well).
  	$token->{_terminator_line} = undef;
  	if ( @heredoc and defined $heredoc[-1] ) {
  		# See PPI::Tokenizer, the algorithm there adds a space at the end of the
  		# document that we need to make sure we remove.
  		if ( $t->{source_eof_chop} ) {
  			chop $heredoc[-1];
  			$t->{source_eof_chop} = '';
  		}
  
  		# Check if the last line of the file matches the terminator without
  		# newline at the end. If so, remove it from the content and set it as
  		# the terminator line.
  		$token->{_terminator_line} = pop @heredoc
  		  if $heredoc[-1] eq $token->{_terminator};
  	}
  
  	# Set a hint for PPI::Document->serialize so it can
  	# inexpensively repair it if needed when writing back out.
  	$token->{_damaged} = 1;
  
  	# The HereDoc is not fully parsed
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Implement PPI::Token::Quote interface compatibility
  
  - Check CPAN for any use of the null here-doc or here-doc-in-s///e
  
  - Add support for the null here-doc
  
  - Add support for here-doc in s///e
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Label - Token class for a statement label
  
  =head1 INHERITANCE
  
    PPI::Token::Label
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A label is an identifier attached to a line or statements, to allow for
  various types of flow control. For example, a loop might have a label
  attached so that a C<last> or C<next> flow control statement can be used
  from multiple levels below to reference the loop directly.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Magic - Tokens representing magic variables
  
  =head1 INHERITANCE
  
    PPI::Token::Magic
    isa PPI::Token::Symbol
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    # When we say magic variables, we mean these...
    $1   $2   $3   $4   $5   $6   $7   $8   $9
    $_   $&   $`   $'   $+   @+   %+   $*   $.    $/    $|
    $\   $"   $;   $%   $=   $-   @-   %-   $)    $#
    $~   $^   $:   $?   $!   %!   $@   $$   $<    $>
    $(   $0   $[   $]   @_   @*   $}   $,   $#+   $#-
    $^L  $^A  $^E  $^C  $^D  $^F  $^H
    $^I  $^M  $^N  $^O  $^P  $^R  $^S
    $^T  $^V  $^W  $^X  %^H
  
  =head1 DESCRIPTION
  
  C<PPI::Token::Magic> is a sub-class of L<PPI::Token::Symbol> which
  identifies the token as "magic variable", one of the strange and
  unusual variables that are connected to "things" behind the scenes.
  
  Some are extremely common, like C<$_>, and others you will quite
  probably never encounter in your Perl career.
  
  =head1 METHODS
  
  The class provides no additional methods, beyond those provided by
  L<PPI::Token::Symbol>, L<PPI::Token> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Token::Symbol ();
  use PPI::Token::Unknown ();
  
  use vars qw{$VERSION @ISA %magic};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Symbol';
  
  	# Magic variables taken from perlvar.
  	# Several things added separately to avoid warnings.
  	foreach ( qw{
  		$1 $2 $3 $4 $5 $6 $7 $8 $9
  		$_ $& $` $' $+ @+ %+ $* $. $/ $|
  		$\\ $" $; $% $= $- @- %- $)
  		$~ $^ $: $? $! %! $@ $$ $< $>
  		$( $0 $[ $] @_ @*
  
  		$^L $^A $^E $^C $^D $^F $^H
  		$^I $^M $^N $^O $^P $^R $^S
  		$^T $^V $^W $^X %^H
  
  		$::|
  	}, '$}', '$,', '$#', '$#+', '$#-' ) {
  		$magic{$_} = 1;
  	}
  }
  
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# $c is the candidate new content
  	my $c = $t->{token}->{content} . substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Do a quick first test so we don't have to do more than this one.
  	# All of the tests below match this one, so it should provide a
  	# small speed up. This regex should be updated to match the inside
  	# tests if they are changed.
  	if ( $c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x ) {
  
  		if ( $c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/ ) {
  			# If and only if we have $'\d, it is not a
  			# symbol. (this was apparently a conscious choice)
  			# Note that $::0 on the other hand is legal
  			if ( $c =~ /^\$\'\d$/ ) {
  				# In this case, we have a magic plus a digit.
  				# Save the CURRENT token, and rerun the on_char
  				return $t->_finalize_token->__TOKENIZER__on_char( $t );
  			}
  
  			# A symbol in the style $_foo or $::foo or $'foo.
  			# Overwrite the current token
  			$t->{class} = $t->{token}->set_class('Symbol');
  			return PPI::Token::Symbol->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $c =~ /^\$\$\w/ ) {
  			# This is really a scalar dereference. ( $$foo )
  			# Add the current token as the cast...
  			$t->{token} = PPI::Token::Cast->new( '$' );
  			$t->_finalize_token;
  
  			# ... and create a new token for the symbol
  			return $t->_new_token( 'Symbol', '$' );
  		}
  
  		if ( $c eq '$${' ) {
  			# This _might_ be a dereference of one of the
  			# control-character symbols.
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$PPI::Token::Unknown::CURLY_SYMBOL/gc ) {
  				# This is really a dereference. ( $${^_foo} )
  				# Add the current token as the cast...
  				$t->{token} = PPI::Token::Cast->new( '$' );
  				$t->_finalize_token;
  
  				# ... and create a new token for the symbol
  				return $t->_new_token( 'Magic', '$' );
  			}
  		}
  
  		if ( $c eq '$#$' or $c eq '$#{' ) {
  			# This is really an index dereferencing cast, although
  			# it has the same two chars as the magic variable $#.
  			$t->{class} = $t->{token}->set_class('Cast');
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $c =~ /^(\$\#)\w/ ) {
  			# This is really an array index thingy ( $#array )
  			$t->{token} = PPI::Token::ArrayIndex->new( "$1" );
  			return PPI::Token::ArrayIndex->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $c =~ /^\$\^\w+$/o ) {
  			# It's an escaped char magic... maybe ( like $^M )
  			my $next = substr( $t->{line}, $t->{line_cursor}+1, 1 ); # Peek ahead
  			if ($magic{$c} && (!$next || $next !~ /\w/)) {
  				$t->{token}->{content} = $c;
  				$t->{line_cursor}++;
  			} else {
  				# Maybe it's a long magic variable like $^WIDE_SYSTEM_CALLS
  				return 1;
  			}
  		}
  
  		if ( $c =~ /^\$\#\{/ ) {
  			# The $# is actually a cast, and { is its block
  			# Add the current token as the cast...
  			$t->{token} = PPI::Token::Cast->new( '$#' );
  			$t->_finalize_token;
  
  			# ... and create a new token for the block
  			return $t->_new_token( 'Structure', '{' );
  		}
  	} elsif ($c =~ /^%\^/) {
  		return 1 if $c eq '%^';
  		# It's an escaped char magic... maybe ( like %^H )
  		if ($magic{$c}) {
  			$t->{token}->{content} = $c;
  			$t->{line_cursor}++;
  		} else {
  			# Back off, treat '%' as an operator
  			chop $t->{token}->{content};
  			bless $t->{token}, $t->{class} = 'PPI::Token::Operator';
  			$t->{line_cursor}--;
  		}
  	}
  
  	if ( $magic{$c} ) {
  		# $#+ and $#-
  		$t->{line_cursor} += length( $c ) - length( $t->{token}->{content} );
  		$t->{token}->{content} = $c;
  	} else {
  		pos $t->{line} = $t->{line_cursor};
  		if ( $t->{line} =~ m/($PPI::Token::Unknown::CURLY_SYMBOL)/gc ) {
  			# control character symbol (e.g. ${^MATCH})
  			$t->{token}->{content} .= $1;
  			$t->{line_cursor}      += length $1;
  		} elsif ( $c =~ /^\$\d+$/ and $t->{line} =~ /\G(\d+)/gc ) {
  			# Grab trailing digits of regex capture variables.
  			$t->{token}{content} .= $1;
  			$t->{line_cursor} += length $1;
  		}
  	}
  
  	# End the current magic token, and recheck
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  # Our version of canonical is plain simple
  sub canonical { $_[0]->content }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number - Token class for a number
  
  =head1 SYNOPSIS
  
    $n = 1234;       # decimal integer
    $n = 0b1110011;  # binary integer
    $n = 01234;      # octal integer
    $n = 0x1234;     # hexadecimal integer
    $n = 12.34e-56;  # exponential notation ( currently not working )
  
  =head1 INHERITANCE
  
    PPI::Token::Number
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number> class is used for tokens that represent numbers,
  in the various types that Perl supports.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  =pod
  
  =head2 base
  
  The C<base> method is provided by all of the ::Number subclasses.
  This is 10 for decimal, 16 for hexadecimal, 2 for binary, etc.
  
  =cut
  
  sub base() { 10 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	return 0 + $_[0]->_literal;
  }
  
  sub _literal {
  	# De-sugar the string representation
  	my $self   = shift;
  	my $string = $self->content;
  	$string =~ s/^\+//;
  	$string =~ s/_//g;
  	return $string;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	# Handle the conversion from an unknown to known type.
  	# The regex covers "potential" hex/bin/octal number.
  	my $token = $t->{token};
  	if ( $token->{content} =~ /^-?0_*$/ ) {
  		# This could be special
  		if ( $char eq 'x' || $char eq 'X' ) {
  			$t->{class} = $t->{token}->set_class( 'Number::Hex' );
  			return 1;
  		} elsif ( $char eq 'b' || $char eq 'B' ) {
  			$t->{class} = $t->{token}->set_class( 'Number::Binary' );
  			return 1;
  		} elsif ( $char =~ /\d/ ) {
  			# You cannot have 8s and 9s on octals
  			if ( $char eq '8' or $char eq '9' ) {
  				$token->{_error} = "Illegal character in octal number '$char'";
  			}
  			$t->{class} = $t->{token}->set_class( 'Number::Octal' );
  			return 1;
  		}
  	}
  
  	# Handle the easy case, integer or real.
  	return 1 if $char =~ /\d/o;
  
  	if ( $char eq '.' ) {
  		$t->{class} = $t->{token}->set_class( 'Number::Float' );
  		return 1;
  	}
  	if ( $char eq 'e' || $char eq 'E' ) {
  		$t->{class} = $t->{token}->set_class( 'Number::Exp' );
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 CAVEATS
  
  Compared to Perl, the number tokenizer is too liberal about allowing
  underscores anywhere.  For example, the following is a syntax error in
  Perl, but is allowed in PPI:
  
     0_b10
  
  =head1 TO DO
  
  - Treat v-strings as binary strings or barewords, not as "base-256"
    numbers
  
  - Break out decimal integers into their own subclass?
  
  - Implement literal()
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Binary - Token class for a binary number
  
  =head1 SYNOPSIS
  
    $n = 0b1110011;  # binary integer
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Binary
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Binary> class is used for tokens that
  represent base-2 numbers.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 2.
  
  =cut
  
  sub base() { 2 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	return if $self->{_error};
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	$str =~ s/^0[bB]//;
  	my $val = 0;
  	for my $bit ( $str =~ m/(.)/g ) {
  		$val = $val * 2 + $bit;
  	}
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	if ( $char =~ /[\w\d]/ ) {
  		unless ( $char eq '1' or $char eq '0' ) {
  			# Add a warning if it contains non-binary chars
  			$t->{token}->{_error} = "Illegal character in binary number '$char'";
  		}
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Exp - Token class for an exponential notation number
  
  =head1 SYNOPSIS
  
    $n = 1.0e-2;
    $n = 1e+2;
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Exp
    isa PPI::Token::Number::Float
        isa PPI::Token::Number
            isa PPI::Token
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Exp> class is used for tokens that
  represent floating point numbers with exponential notation.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number::Float ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number::Float';
  }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	return if $self->{_error};
  	my ($mantissa, $exponent) = split m/e/i, $self->_literal;
  	my $neg = $mantissa =~ s/^\-//;
  	$mantissa =~ s/^\./0./;
  	$exponent =~ s/^\+//;
  
  	# This algorithm is reasonably close to the S_mulexp10()
  	# algorithm from the Perl source code, so it should arrive
  	# at the same answer as Perl most of the time.
  	my $negpow = 0;
  	if ($exponent < 0) {
  		$negpow = 1;
  		$exponent *= -1;
  	}
  
  	my $result = 1;
  	my $power = 10;
  	for (my $bit = 1; $exponent; $bit = $bit << 1) {
  		if ($exponent & $bit) {
  			$exponent = $exponent ^ $bit;
  			$result *= $power;
  		}
  		$power *= $power;
  	}
  
  	my $val = $neg ? 0 - $mantissa : $mantissa;
  	return $negpow ? $val / $result : $val * $result;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
          # To get here, the token must have already encountered an 'E'
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	# Allow digits
  	return 1 if $char =~ /\d/o;
  
  	# Start of exponent is special
  	if ( $t->{token}->{content} =~ /e$/i ) {
  		# Allow leading +/- in exponent
  		return 1 if $char eq '-' || $char eq '+';
  
  		# Invalid character in exponent.  Recover
  		if ( $t->{token}->{content} =~ s/\.(e)$//i ) {
  			my $word = $1;
  			$t->{class} = $t->{token}->set_class('Number');
  			$t->_new_token('Operator', '.');
  			$t->_new_token('Word', $word);
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  		else {
  			$t->{token}->{_error} = "Illegal character in exponent '$char'";
  		}
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Float - Token class for a floating-point number
  
  =head1 SYNOPSIS
  
    $n = 1.234;
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Float
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Float> class is used for tokens that
  represent floating point numbers.  A float is identified by n decimal
  point.  Exponential notation (the C<e> or C<E>) is handled by the
  PPI::Token::Number::Exp class.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 10.
  
  =cut
  
  sub base() { 10 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	$str =~ s/^\./0./;
  	my $val = 0+$str;
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	# Allow digits
  	return 1 if $char =~ /\d/o;
  
  	# Is there a second decimal point?  Then version string or '..' operator
  	if ( $char eq '.' ) {
  		if ( $t->{token}->{content} =~ /\.$/ ) {
  			# We have a .., which is an operator.
  			# Take the . off the end of the token..
  			# and finish it, then make the .. operator.
  			chop $t->{token}->{content};
                          $t->{class} = $t->{token}->set_class( 'Number' );
  			$t->_new_token('Operator', '..');
  			return 0;
  		} elsif ( $t->{token}->{content} !~ /_/ ) {
  			# Underscore means not a Version, fall through to end token
  			$t->{class} = $t->{token}->set_class( 'Number::Version' );
  			return 1;
  		}
  	}
  
  	# perl seems to regard pretty much anything that's not strictly an exp num
  	# as float + stuff
  	my $char2 = substr $t->{line}, $t->{line_cursor}+1, 1;
  	if ("$char$char2" =~ /[eE][0-9+-]/) {
  		$t->{class} = $t->{token}->set_class( 'Number::Exp' );
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Hex - Token class for a binary number
  
  =head1 SYNOPSIS
  
    $n = 0x1234;     # hexadecimal integer
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Hex
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Hex> class is used for tokens that
  represent base-16 numbers.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 16.
  
  =cut
  
  sub base() { 16 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	my $val = hex lc( $str ); # lc for compatibility with perls before 5.14
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	if ( $char =~ /[[:xdigit:]]/ ) {
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Octal - Token class for a binary number
  
  =head1 SYNOPSIS
  
    $n = 0777;      # octal integer
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Octal
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Octal> class is used for tokens that
  represent base-8 numbers.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 8.
  
  =cut
  
  sub base() { 8 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	return if $self->{_error};
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	my $val = oct $str;
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	if ( $char =~ /\d/ ) {
  		# You cannot have 8s and 9s on octals
  		if ( $char eq '8' or $char eq '9' ) {
  			$t->{token}->{_error} = "Illegal character in octal number '$char'";
  		}
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Version - Token class for a byte-packed number
  
  =head1 SYNOPSIS
  
    $n = 1.1.0;
    $n = 127.0.0.1;
    $n = 10_000.10_000.10_000;
    $n = v1.2.3.4
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Version
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Version> class is used for tokens that have
  multiple decimal points.  In truth, these aren't treated like numbers
  at all by Perl, but they look like numbers to a parser.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 256.
  
  =cut
  
  sub base() { 256 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self    = shift;
  	my $content = $self->{content};
  	$content =~ s/^v//;
  	return join '', map { chr $_ } ( split /\./, $content );
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow digits
  	return 1 if $char =~ /\d/o;
  
  	# Is this a second decimal point in a row?  Then the '..' operator
  	if ( $char eq '.' ) {
  		if ( $t->{token}->{content} =~ /\.$/ ) {
  			# We have a .., which is an operator.
  			# Take the . off the end of the token..
  			# and finish it, then make the .. operator.
  			chop $t->{token}->{content};
  			$t->{class} = $t->{token}->set_class( 'Number::Float' );
  			$t->_new_token('Operator', '..');
  			return 0;
  		} else {
  			return 1;
  		}
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  sub __TOKENIZER__commit {
  	my $t = $_[1];
  
  	# Capture the rest of the token
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} !~ m/\G(v\d+(?:\.\d+)+|v\d+\b)/gc ) {
  		# This was not a v-string after all (it's a word)
  		return PPI::Token::Word->__TOKENIZER__commit($t);
  	}
  
  	my $content = $1;
  
  	# If there are no periods this could be a word starting with v\d
  	# Forced to be a word. Done.
  	return PPI::Token::Word->__TOKENIZER__commit($t)
  		if $content !~ /\./ and $t->__current_token_is_forced_word($content);
  
  	# This is a v-string
  	$t->{line_cursor} += length $content;
  	$t->_new_token( 'Number::Version', $content );
  	$t->_finalize_token->__TOKENIZER__on_char($t);
  }
  
  1;
  
  =pod
  
  =head1 BUGS
  
  - Does not handle leading minus sign correctly. Should translate to a DashedWord.
  See L<http://perlmonks.org/?node_id=574573>
  
    -95.0.1.0  --> "-_\000\cA\000"
    -96.0.1.0  --> Argument "`\0^A\0" isn't numeric in negation (-)
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Operator - Token class for operators
  
  =head1 INHERITANCE
  
    PPI::Token::Operator
    isa PPI::Token
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    # This is the list of valid operators
    ++   --   **   !    ~    +    -
    =~   !~   *    /    %    x
    <<   >>   lt   gt   le   ge   cmp  ~~
    ==   !=   <=>  .    ..   ...  ,
    &    |    ^    &&   ||   //
    ?    :    **=  +=   -=   .=   *=   /=
    %=   x=   &=   |=   ^=   <<=  >>=  &&=
    ||=  //=  <    >    <=   >=   <>   =>   ->
    and  or   xor  not  eq   ne
  
  
  =head1 DESCRIPTION
  
  All operators in PPI are created as C<PPI::Token::Operator> objects,
  including the ones that may superficially look like a L<PPI::Token::Word>
  object.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA %OPERATOR};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  
  	# Build the operator index
  	### NOTE - This is accessed several times explicitly
  	###        in PPI::Token::Word. Do not rename this
  	###        without also correcting them.
  	%OPERATOR = map { $_ => 1 } (
  		qw{
  		-> ++ -- ** ! ~ + -
  		=~ !~ * / % x . << >>
  		< > <= >= lt gt le ge
  		== != <=> eq ne cmp ~~
  		& | ^ && || // .. ...
  		? :
  		= **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //=
  		=> <>
  		and or xor not
  		}, ',' 	# Avoids "comma in qw{}" warning
  		);
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t    = $_[1];
  	my $char = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Are we still an operator if we add the next character
  	my $content = $t->{token}->{content};
  	return 1 if $OPERATOR{ $content . $char };
  
  	# Handle the special case of a .1234 decimal number
  	if ( $content eq '.' ) {
  		if ( $char =~ /^[0-9]$/ ) {
  			# This is a decimal number
  			$t->{class} = $t->{token}->set_class('Number::Float');
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  	}
  
  	# Handle the special case if we might be a here-doc
  	if ( $content eq '<<' ) {
  		pos $t->{line} = $t->{line_cursor};
  		# Either <<FOO or << 'FOO' or <<\FOO
  		### Is the zero-width look-ahead assertion really
  		### supposed to be there?
  		if ( $t->{line} =~ m/\G(?: (?!\d)\w | \s*['"`] | \\\w ) /gcx ) {
  			# This is a here-doc.
  			# Change the class and move to the HereDoc's own __TOKENIZER__on_char method.
  			$t->{class} = $t->{token}->set_class('HereDoc');
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  	}
  
  	# Handle the special case of the null Readline
  	if ( $content eq '<>' ) {
  		$t->{class} = $t->{token}->set_class('QuoteLike::Readline');
  	}
  
  	# Finalize normally
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Pod - Sections of POD in Perl documents
  
  =head1 INHERITANCE
  
    PPI::Token::Pod
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A single C<PPI::Token::Pod> object represents a complete section of POD
  documentation within a Perl document.
  
  =head1 METHODS
  
  This class provides some additional methods beyond those provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  use PPI::Token   ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Pod Methods
  
  =pod
  
  =head2 merge @podtokens
  
  The C<merge> constructor takes a number of C<PPI::Token::Pod> objects,
  and returns a new object that represents one combined POD block with
  the content of all of them.
  
  Returns a new C<PPI::Token::Pod> object, or C<undef> on error.
  
  =cut
  
  sub merge {
  	my $class = (! ref $_[0]) ? shift : return undef;
  
  	# Check there are no bad arguments
  	if ( grep { ! _INSTANCE($_, 'PPI::Token::Pod') } @_ ) {
  		return undef;
  	}
  
  	# Get the tokens, and extract the lines
  	my @content = ( map { [ $_->lines ] } @_ ) or return undef;
  
  	# Remove the leading =pod tags, trailing =cut tags, and any empty lines
  	# between them and the pod contents.
  	foreach my $pod ( @content ) {
  		# Leading =pod tag
  		if ( @$pod and $pod->[0] =~ /^=pod\b/o ) {
  			shift @$pod;
  		}
  
  		# Trailing =cut tag
  		if ( @$pod and $pod->[-1] =~ /^=cut\b/o ) {
  			pop @$pod;
  		}
  
  		# Leading and trailing empty lines
  		while ( @$pod and $pod->[0]  eq '' ) { shift @$pod }
  		while ( @$pod and $pod->[-1] eq '' ) { pop @$pod   }
  	}
  
  	# Remove any empty pod sections, and add the =pod and =cut tags
  	# for the merged pod back to it.
  	@content = ( [ '=pod' ], grep { @$_ } @content, [ '=cut' ] );
  
  	# Create the new object
  	$class->new( join "\n", map { join( "\n", @$_ ) . "\n" } @content );
  }
  
  =pod
  
  =head2 lines
  
  The C<lines> method takes the string of POD and breaks it into lines,
  returning them as a list.
  
  =cut
  
  sub lines {
  	split /(?:\015{1,2}\012|\015|\012)/, $_[0]->{content};
  }
  
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  ### XS -> PPI/XS.xs:_PPI_Token_Pod__significant 0.900+
  sub significant() { '' }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_line_start {
  	my $t = $_[1];
  
  	# Add the line to the token first
  	$t->{token}->{content} .= $t->{line};
  
  	# Check the line to see if it is a =cut line
  	if ( $t->{line} =~ /^=(\w+)/ ) {
  		# End of the token
  		$t->_finalize_token if $1 eq 'cut';
  	}
  
  	0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Prototype - A subroutine prototype descriptor
  
  =head1 INHERITANCE
  
    PPI::Token::End
    isa PPI::Token
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    sub ($@) prototype;
  
  =head1 DESCRIPTION
  
  Although it sort of looks like a list or condition, a subroutine
  prototype is a lot more like a string. Its job is to provide hints
  to the perl compiler on what type of arguments a particular subroutine
  expects, which the compiler uses to validate parameters at compile-time,
  and allows programmers to use the functions without explicit parameter
  parens.
  
  Due to the rise of OO Perl coding, which ignores these prototypes, they
  are most often used to allow for constant-like things, and to "extend"
  the language and create things that act like keywords and core functions.
  
    # Create something that acts like a constant
    sub MYCONSTANT () { 10 }
    
    # Create the "any" core-looking function
    sub any (&@) { ... }
    
    if ( any { $_->cute } @babies ) {
    	...
    }
  
  =head1 METHODS
  
  This class provides one additional method beyond those defined by the
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  
  	# Suck in until we find the closing paren (or the end of line)
  	pos $t->{line} = $t->{line_cursor};
  	die "regex should always match" if $t->{line} !~ m/\G(.*?(?:\)|$))/gc;
  	$t->{token}->{content} .= $1;
  	$t->{line_cursor} += length $1;
  
  	# Shortcut if end of line
  	return 0 unless $1 =~ /\)$/;
  
  	# Found the closing paren
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  =pod
  
  =head2 prototype
  
  The C<prototype> accessor returns the actual prototype pattern, stripped
  of flanking parens and of all whitespace. This mirrors the behavior of
  the Perl C<prototype> builtin function.
  
  Note that stripping parens and whitespace means that the return of
  C<prototype> can be an empty string.
  
  =cut
  
  sub prototype {
  	my $self  = shift;
  	my $proto = $self->content;
  	$proto =~ s/(^\(|\)$|\s+)//g;
  	$proto;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote - String quote abstract base class
  
  =head1 INHERITANCE
  
    PPI::Token::Quote
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Quote> class is never instantiated, and simply
  provides a common abstract base class for the four quote classes.
  In PPI, a "quote" is limited to only the quote-like things that
  themselves directly represent a string. (although this includes
  double quotes with interpolated elements inside them).
  
  The subclasses of C<PPI::Token::Quote> are:
  
  =over 2
  
  =item C<''> - L<PPI::Token::Quote::Single>
  
  =item C<q{}> - L<PPI::Token::Quote::Literal>
  
  =item C<""> - L<PPI::Token::Quote::Double>
  
  =item C<qq{}> - L<PPI::Token::Quote::Interpolate>
  
  =back
  
  The names are hopefully obvious enough not to have to explain what
  each class is here. See their respective pages for more details.
  
  Please note that although the here-doc B<does> represent a literal
  string, it is such a nasty piece of work that in L<PPI> it is given the
  honor of its own token class (L<PPI::Token::HereDoc>).
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  =pod
  
  =head2 string
  
  The C<string> method is provided by all four ::Quote classes. It won't
  get you the actual literal Perl value, but it will strip off the wrapping
  of the quotes.
  
    # The following all return foo from the ->string method
    'foo'
    "foo"
    q{foo}
    qq <foo>
  
  =cut
  
  #sub string {
  #	my $class = ref $_[0] || $_[0];
  #	die "$class does not implement method ->string";
  #}
  
  =pod
  
  =head2 literal
  
  The C<literal> method is provided by ::Quote::Literal and
  ::Quote::Single.  This returns the value of the string as Perl sees
  it: without the quote marks and with C<\\> and C<\'> resolved to C<\>
  and C<'>.
  
  The C<literal> method is not implemented by ::Quote::Double or
  ::Quote::Interpolate yet.
  
  =cut
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Double - A standard "double quote" token
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Double
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Double> object represents a double-quoted
  interpolating string.
  
  The string is treated as a single entity, L<PPI> will not try to
  understand what is in the string during the parsing process.
  
  =head1 METHODS
  
  There are several methods available for C<PPI::Token::Quote::Double>, beyond
  those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use Params::Util                     qw{_INSTANCE};
  use PPI::Token::Quote                ();
  use PPI::Token::_QuoteEngine::Simple ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Simple
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote::Double Methods
  
  =pod
  
  =head2 interpolations
  
  The interpolations method checks to see if the double quote actually
  contains any interpolated variables.
  
  Returns true if the string contains interpolations, or false if not.
  
  =cut
  
  # Upgrade: Return the interpolated substrings.
  # Upgrade: Returns parsed expressions.
  sub interpolations {
  	# Are there any unescaped $things in the string
  	!! ($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/);
  }
  
  =pod
  
  =head2 simplify
  
  For various reasons, some people find themselves compelled to have
  their code in the simplest form possible.
  
  The C<simplify> method will, if possible, modify a simple double-quoted
  string token in place, turning it into the equivalent single-quoted
  string. If the token is modified, it is reblessed into the
  L<PPI::Token::Quote::Single> package.
  
  Because the length of the content is not changed, there is no need
  to call the document's C<flush_locations> method.
  
  The object itself is returned as a convenience.
  
  =cut
  
  sub simplify {
  	# This only works on EXACTLY this class
  	my $self = _INSTANCE(shift, 'PPI::Token::Quote::Double') or return undef;
  
  	# Don't bother if there are characters that could complicate things
  	my $content = $self->content;
  	my $value   = substr($content, 1, length($content) - 2);
  	return $self if $value =~ /[\\\$@\'\"]/;
  
  	# Change the token to a single string
  	$self->{content} = "'$value'";
  	bless $self, 'PPI::Token::Quote::Single';
  }
  
  
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $str = $_[0]->{content};
  	substr( $str, 1, length($str) - 2 );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Interpolate - The interpolation quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Interpolate
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Interpolate> object represents a single
  interpolation quote-like operator, such as C<qq{$foo bar $baz}>.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Quote::Interpolate>
  beyond those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Quote ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $self     = shift;
  	my @sections = $self->_sections;
  	my $str      = $sections[0];
  	substr( $self->{content}, $str->{position}, $str->{size} );	
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Literal - The literal quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Literal
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Literal> object represents a single literal
  quote-like operator, such as C<q{foo bar}>.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Quote::Literal> beyond
  those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Quote              ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $self     = shift;
  	my @sections = $self->_sections;
  	my $str      = $sections[0];
  	substr( $self->{content}, $str->{position}, $str->{size} );	
  }
  
  
  # Use the same implementation as another module
  *literal = *PPI::Token::Quote::Single::literal;
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Single - A 'single quote' token
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Single
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    'This is a single quote'
    
    q{This is a literal, but NOT a single quote}
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Single> object represents a single quoted string
  literal. 
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Quote::Single> beyond
  those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Quote ();
  use PPI::Token::_QuoteEngine::Simple ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Simple
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $str = $_[0]->{content};
  	substr( $str, 1, length($str) - 2 );
  }
  
  
  my %UNESCAPE = (
  	"\\'"  => "'",
  	"\\\\" => "\\",
  );
  
  sub literal {
  	# Unescape \\ and \' ONLY
  	my $str = $_[0]->string;
  	$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;
  	return $str;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike - Quote-like operator abstract base class
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::QuoteLike> class is never instantiated, and simply
  provides a common abstract base class for the five quote-like operator
  classes. In PPI, a "quote-like" is the set of quote-like things that
  exclude the string quotes and regular expressions.
  
  The subclasses of C<PPI::Token::QuoteLike> are:
  
  =over 2
  
  =item qw{} - L<PPI::Token::QuoteLike::Words>
  
  =item `` - L<PPI::Token::QuoteLike::Backtick>
  
  =item qx{} - L<PPI::Token::QuoteLike::Command>
  
  =item qr// - L<PPI::Token::QuoteLike::Regexp>
  
  =item <FOO> - L<PPI::Token::QuoteLike::Readline>
  
  =back
  
  The names are hopefully obvious enough not to have to explain what
  each class is. See their pages for more details.
  
  You may note that the backtick and command quote-like are treated
  separately, even though they do the same thing. This is intentional,
  as the inherit from and are processed by two different parts of the
  PPI's quote engine.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Backtick - A `backticks` command token
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Backtick
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Backtick> object represents a command output
  capturing quote.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::QuoteLike::Backtick>
  beyond those provided by the parent L<PPI::Token::QuoteLike>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike            ();
  use PPI::Token::_QuoteEngine::Simple ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Simple
  		PPI::Token::QuoteLike
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Command - The command quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Command
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Command> object represents a command output
  capturing quote-like operator.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::QuoteLike::Command>
  beyond those provided by the parent L<PPI::Token::QuoteLike>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Readline - The readline quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Readline
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<readline> quote-like operator is used to read either a single
  line from a file, or all the lines from a file, as follows.
  
    # Read in a single line
    $line = <FILE>;
    
    # From a scalar handle
    $line = <$filehandle>;
    
    # Read all the lines
    @lines = <FILE>;
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::QuoteLike::Readline>
  beyond those provided by the parent L<PPI::Token::QuoteLike>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Regexp - Regexp constructor quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Regexp
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Regexp> object represents the quote-like
  operator used to construct anonymous L<Regexp> objects, as follows.
  
    # Create a Regexp object for a module filename
    my $module = qr/\.pm$/;
  
  =head1 METHODS
  
  The following methods are provided by this class,
  beyond those provided by the parent L<PPI::Token::QuoteLike>,
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::QuoteLike::Regexp Methods
  
  =pod
  
  =head2 get_match_string
  
  The C<get_match_string> method returns the portion of the string that
  will be compiled into the match portion of the regexp.
  
  =cut
  
  sub get_match_string {
  	return $_[0]->_section_content( 0 );
  }
  
  =pod
  
  =head2 get_substitute_string
  
  The C<get_substitute_string> method always returns C<undef>, since
  the C<qr{}> construction provides no substitution string. This method
  is provided for orthogonality with C<PPI::Token::Regexp>.
  
  =cut
  
  sub get_substitute_string {
  	return undef;
  }
  
  =pod
  
  =head2 get_modifiers
  
  The C<get_modifiers> method returns the modifiers that will be
  compiled into the regexp.
  
  =cut
  
  sub get_modifiers {
  	return $_[0]->_modifiers();
  }
  
  =pod
  
  =head2 get_delimiters
  
  The C<get_delimiters> method returns the delimiters of the string as an
  array. The first and only element is the delimiters of the string to be
  compiled into a match string.
  
  =cut
  
  sub get_delimiters {
  	return $_[0]->_delimiters();
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Words - Word list constructor quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Words
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Words> object represents a quote-like operator
  that acts as a constructor for a list of words.
  
    # Create a list for a significant chunk of the alphabet
    my @list = qw{a b c d e f g h i j k l};
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  =pod
  
  =head2 literal
  
  Returns the words contained as a list.  Note that this method does not check the
  context that the token is in; it always returns the list and not merely
  the last element if the token is in scalar context.
  
  =cut
  
  sub literal {
  	my ( $self ) = @_;
  
  	my $content = $self->_section_content(0);
  	return if !defined $content;
  
  	# Undo backslash escaping of '\', the left delimiter,
  	# and the right delimiter.  The right delimiter will
  	# only exist with paired delimiters: qw() qw[] qw<> qw{}.
  	my ( $left, $right ) = ( $self->_delimiters, '', '' );
  	$content =~ s/\\([\Q$left$right\\\E])/$1/g;
  
  	my @words = split ' ', $content;
  
  	return @words;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp - Regular expression abstract base class
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Regexp> class is never instantiated, and simply
  provides a common abstract base class for the three regular expression
  classes. These being:
  
  =over 2
  
  =item m// - L<PPI::Token::Regexp::Match>
  
  =item s/// - L<PPI::Token::Regexp::Substitute>
  
  =item tr/// - L<PPI::Token::Regexp::Transliterate>
  
  =back
  
  The names are hopefully obvious enough not to have to explain what
  each class is. See their pages for more details.
  
  To save some confusion, it's worth pointing out here that C<qr//> is
  B<not> a regular expression (which PPI takes to mean something that
  will actually examine or modify a string), but rather a quote-like
  operator that acts as a constructor for compiled L<Regexp> objects. 
  
  =head1 METHODS
  
  The following methods are inherited by this class' offspring:
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Regexp Methods
  
  =pod
  
  =head2 get_match_string
  
  The C<get_match_string> method returns the portion of the regexp that
  performs the match.
  
  =cut
  
  sub get_match_string {
  	return $_[0]->_section_content( 0 );
  }
  
  =pod
  
  =head2 get_substitute_string
  
  The C<get_substitute_string> method returns the portion of the regexp
  that is substituted for the match, if any.  If the regexp does not
  substitute, C<undef> is returned.
  
  =cut
  
  sub get_substitute_string {
  	return $_[0]->_section_content( 1 );
  }
  
  =pod
  
  =head2 get_modifiers
  
  The C<get_modifiers> method returns the modifiers of the regexp.
  
  =cut
  
  sub get_modifiers {
  	return $_[0]->_modifiers();
  }
  
  =pod
  
  =head2 get_delimiters
  
  The C<get_delimiters> method returns the delimiters of the regexp as
  an array. The first element is the delimiters of the match string, and
  the second element (if any) is the delimiters of the substitute string
  (if any).
  
  =cut
  
  sub get_delimiters {
  	return $_[0]->_delimiters();
  }
  
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp::Match - A standard pattern match regex
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp::Match
    isa PPI::Token::Regexp
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    $text =~ m/match regexp/;
    $text =~ /match regexp/;
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Regexp::Match> object represents a single match regular
  expression. Just to be doubly clear, here are things that are and
  B<aren't> considered a match regexp.
  
    # Is a match regexp
    /This is a match regexp/;
    m/Old McDonald had a farm/eieio;
    
    # These are NOT match regexp
    qr/This is a regexp quote-like operator/;
    s/This is a/replace regexp/;
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Regexp::Match> beyond
  those provided by the parent L<PPI::Token::Regexp>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Regexp             ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Regexp
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp::Substitute - A match and replace regular expression token
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp::Substitute
    isa PPI::Token::Regexp
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    $text =~ s/find/$replace/;
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Regexp::Substitute> object represents a single substitution
  regular expression.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Regexp::Substitute>
  beyond those provided by the parent L<PPI::Token::Regexp>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Regexp             ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Regexp
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp::Transliterate - A transliteration regular expression token
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp::Transliterate
    isa PPI::Token::Regexp
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    $text =~ tr/abc/xyz/;
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Regexp::Transliterate> object represents a single
  transliteration regular expression.
  
  I'm afraid you'll have to excuse the ridiculously long class name, but
  when push came to shove I ended up going for pedantically correct
  names for things (practically cut and paste from the various docs).
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Regexp::Transliterate>
  beyond those provided by the parent L<PPI::Token::Regexp>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Regexp             ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Regexp
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Separator - The __DATA__ and __END__ tags
  
  =head1 INHERITANCE
  
    PPI::Token::Separator
    isa PPI::Token::Word
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Although superficially looking like a normal L<PPI::Token::Word> object,
  when the C<__DATA__> and C<__END__> compiler tags appear at the beginning of
  a line (on supposedly) their own line, these tags become file section
  separators.
  
  The indicate that the time for Perl code is over, and the rest of the
  file is dedicated to something else (data in the case of C<__DATA__>) or
  to nothing at all (in the case of C<__END__>).
  
  =head1 METHODS
  
  This class has no methods beyond what is provided by its
  L<PPI::Token::Word>, L<PPI::Token> and L<PPI::Element>
  parent classes.
  
  =cut
  
  use strict;
  use PPI::Token::Word ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Word';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Structure - Token class for characters that define code structure
  
  =head1 INHERITANCE
  
    PPI::Token::Structure
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Structure> class is used for tokens that control the
  general tree structure or code.
  
  This consists of seven characters. These are the six brace characters from
  the "round", "curly" and "square" pairs, plus the semi-colon statement
  separator C<;>.
  
  =head1 METHODS
  
  This class has no methods beyond what is provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  # Set the matching braces, done as an array
  # for slightly faster lookups.
  use vars qw{@MATCH @OPENS @CLOSES};
  BEGIN {
  	$MATCH[ord '{']  = '}';
  	$MATCH[ord '}']  = '{';
  	$MATCH[ord '[']  = ']';
  	$MATCH[ord ']']  = '[';
  	$MATCH[ord '(']  = ')';
  	$MATCH[ord ')']  = '(';
  
  	$OPENS[ord '{']  = 1;
  	$OPENS[ord '[']  = 1;
  	$OPENS[ord '(']  = 1;
  
  	$CLOSES[ord '}'] = 1;
  	$CLOSES[ord ']'] = 1;
  	$CLOSES[ord ')'] = 1;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	# Structures are one character long, always.
  	# Finalize and process again.
  	$_[1]->_finalize_token->__TOKENIZER__on_char( $_[1] );
  }
  
  sub __TOKENIZER__commit {
  	my $t = $_[1];
  	$t->_new_token( 'Structure', substr( $t->{line}, $t->{line_cursor}, 1 ) );
  	$t->_finalize_token;
  	0;
  }
  
  
  
  
  
  #####################################################################
  # Lexer Methods
  
  # For a given brace, find its opposing pair
  sub __LEXER__opposite {
  	$MATCH[ord $_[0]->{content} ];
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # There is a unusual situation in regards to "siblings".
  #
  # As an Element, braces sit outside the normal tree structure, and in
  # this context they NEVER have siblings.
  #
  # However, as tokens they DO have siblings.
  #
  # As such, we need special versions of _all_ of the sibling methods to
  # handle this.
  #
  # Statement terminators do not have these problems, and for them sibling
  # calls work as normal, and so they can just be passed upwards.
  
  sub next_sibling {
  	return $_[0]->SUPER::next_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub snext_sibling {
  	return $_[0]->SUPER::snext_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub previous_sibling {
  	return $_[0]->SUPER::previous_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub sprevious_sibling {
  	return $_[0]->SUPER::sprevious_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub next_token {
  	my $self = shift;
  	return $self->SUPER::next_token if $self->{content} eq ';';
  	my $structure = $self->parent or return '';
  
  	# If this is an opening brace, descend down into our parent
  	# structure, if it has children.
  	if ( $OPENS[ ord $self->{content} ] ) {
  		my $child = $structure->child(0);
  		if ( $child ) {
  			# Decend deeper, or return if it is a token
  			return $child->isa('PPI::Token') ? $child : $child->first_token;
  		} elsif ( $structure->finish ) {
  			# Empty structure, so next is closing brace
  			return $structure->finish;
  		}
  
  		# Anything that slips through to here is a structure
  		# with an opening brace, but no closing brace, so we
  		# just have to go with it, and continue as we would
  		# if we started with a closing brace.
  	}
  
  	# We can use the default implement, if we call it from the
  	# parent structure of the closing brace.
  	$structure->next_token;
  }
  
  sub previous_token {
  	my $self = shift;
  	return $self->SUPER::previous_token if $self->{content} eq ';';
  	my $structure = $self->parent or return '';
  
  	# If this is a closing brace, descend down into our parent
  	# structure, if it has children.
  	if ( $CLOSES[ ord $self->{content} ] ) {
  		my $child = $structure->child(-1);
  		if ( $child ) {
  			# Decend deeper, or return if it is a token
  			return $child->isa('PPI::Token') ? $child : $child->last_token;
  		} elsif ( $structure->start ) {
  			# Empty structure, so next is closing brace
  			return $structure->start;
  		}
  
  		# Anything that slips through to here is a structure
  		# with a closing brace, but no opening brace, so we
  		# just have to go with it, and continue as we would
  		# if we started with an opening brace.
  	}
  
  	# We can use the default implement, if we call it from the
  	# parent structure of the closing brace.
  	$structure->previous_token;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Symbol - A token class for variables and other symbols
  
  =head1 INHERITANCE
  
    PPI::Token::Symbol
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Symbol> class is used to cover all tokens that represent
  variables and other things that start with a sigil.
  
  =head1 METHODS
  
  This class has several methods beyond what is provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  Most methods are provided to help work out what the object is actually
  pointing at, rather than what it might appear to be pointing at.
  
  =cut
   
  use strict;
  use Params::Util qw{_INSTANCE};
  use PPI::Token   ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Symbol Methods
  
  =pod
  
  =head2 canonical
  
  The C<canonical> method returns a normalized, canonical version of the
  symbol.
  
  For example, it converts C<$ ::foo'bar::baz> to C<$main::foo::bar::baz>.
  
  This does not fully resolve the symbol, but merely removes syntax
  variations.
  
  =cut
  
  sub canonical {
  	my $symbol = shift->content;
  	$symbol =~ s/\s+//;
  	$symbol =~ s/\'/::/g;
  	$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;
  	$symbol;
  }
  
  =pod
  
  =head2 symbol
  
  The C<symbol> method returns the ACTUAL symbol this token refers to.
  
  A token of C<$foo> might actually be referring to C<@foo>, if it is found
  in the form C<$foo[1]>.
  
  This method attempts to resolve these issues to determine the actual
  symbol.
  
  Returns the symbol as a string.
  
  =cut
  
  my %cast_which_trumps_braces = map { $_ => 1 } qw{ $ @ };
  
  sub symbol {
  	my $self   = shift;
  	my $symbol = $self->canonical;
  
  	# Immediately return the cases where it can't be anything else
  	my $type = substr( $symbol, 0, 1 );
  	return $symbol if $type eq '%';
  	return $symbol if $type eq '&';
  
  	# Unless the next significant Element is a structure, it's correct.
  	my $after  = $self->snext_sibling;
  	return $symbol unless _INSTANCE($after, 'PPI::Structure');
  
  	# Process the rest for cases where it might actually be something else
  	my $braces = $after->braces;
  	return $symbol unless defined $braces;
  	if ( $type eq '$' ) {
  
  		# If it is cast to '$' or '@', that trumps any braces
  		my $before = $self->sprevious_sibling;
  		return $symbol if $before &&
  			$before->isa( 'PPI::Token::Cast' ) &&
  			$cast_which_trumps_braces{ $before->content };
  
  		# Otherwise the braces rule
  		substr( $symbol, 0, 1, '@' ) if $braces eq '[]';
  		substr( $symbol, 0, 1, '%' ) if $braces eq '{}';
  
  	} elsif ( $type eq '@' ) {
  		substr( $symbol, 0, 1, '%' ) if $braces eq '{}';
  
  	}
  
  	$symbol;
  }
  
  =pod
  
  =head2 raw_type
  
  The C<raw_type> method returns the B<apparent> type of the symbol in the
  form of its sigil.
  
  Returns the sigil as a string.
  
  =cut
  
  sub raw_type {
  	substr( $_[0]->content, 0, 1 );
  }
  
  =pod
  
  =head2 symbol_type
  
  The C<symbol_type> method returns the B<actual> type of the symbol in the
  form of its sigil.
  
  Returns the sigil as a string.
  
  =cut
  
  sub symbol_type {
  	substr( $_[0]->symbol, 0, 1 );
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Suck in till the end of the symbol
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G([\w:\']+)/gc ) {
  		$t->{token}->{content} .= $1;
  		$t->{line_cursor}      += length $1;
  	}
  
  	# Handle magic things
  	my $content = $t->{token}->{content};	
  	if ( $content eq '@_' or $content eq '$_' ) {
  		$t->{class} = $t->{token}->set_class( 'Magic' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# Shortcut for most of the X:: symbols
  	if ( $content eq '$::' ) {
  		# May well be an alternate form of a Magic
  		my $nextchar = substr( $t->{line}, $t->{line_cursor}, 1 );
  		if ( $nextchar eq '|' ) {
  			$t->{token}->{content} .= $nextchar;
  			$t->{line_cursor}++;
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  		}
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  	if ( $content =~ /^[\$%*@&]::(?:[^\w]|$)/ ) {
  		my $current = substr( $content, 0, 3, '' );
  		$t->{token}->{content} = $current;
  		$t->{line_cursor} -= length( $content );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  	if ( $content =~ /^(?:\$|\@)\d+/ ) {
  		$t->{class} = $t->{token}->set_class( 'Magic' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# Trim off anything we oversucked...
  	$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic vars
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;
  	unless ( length $1 eq length $content ) {
  		$t->{line_cursor} += length($1) - length($content);
  		$t->{token}->{content} = $1;
  	}
  
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Unknown - Token of unknown or as-yet undetermined type
  
  =head1 INHERITANCE
  
    PPI::Token::Unknown
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  Object of the type C<PPI::Token::Unknown> exist primarily inside the
  tokenizer, where they are temporarily brought into existing for a very
  short time to represent a token that could be one of a number of types.
  
  Generally, they only exist for a character or two, after which they are
  resolved and converted into the correct type. For an object of this type
  to survive the parsing process is considered a major bug.
  
  Please report any C<PPI::Token::Unknown> you encounter in a L<PPI::Document>
  object as a bug.
  
  =cut
  
  use strict;
  use PPI::Token     ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA $CURLY_SYMBOL};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  	$CURLY_SYMBOL = qr{\G\^[[:upper:]_]\w+\}};
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my ( $self, $t ) = @_;                                 # Self and Tokenizer
  	my $c    = $t->{token}->{content};                     # Current token
  	my $char = substr( $t->{line}, $t->{line_cursor}, 1 ); # Current character
  
  	# Now, we split on the different values of the current content
  	if ( $c eq '*' ) {
  		# Is it a number?
  		if ( $char =~ /\d/ ) {
  			# bitwise operator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol (unless the thing before it is a number
  			my ( $prev ) = $t->_previous_significant_tokens(1);
  			if ( not $prev or not $prev->isa('PPI::Token::Number') ) {
  				$t->{class} = $t->{token}->set_class( 'Symbol' );
  				return 1;
  			}
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. *{^_Foo})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		if ( $char eq '*' || $char eq '=' ) {
  			# Power operator '**' or mult-assign '*='
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return 1;
  		}
  
  		return $self->_as_cast_or_op($t) if $self->_is_cast_or_op($char);
  
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '$' ) {
  		if ( $char =~ /[a-z_]/i ) {
  			# Symbol
  			$t->{class} = $t->{token}->set_class( 'Symbol' );
  			return 1;
  		}
  
  		if ( $PPI::Token::Magic::magic{ $c . $char } ) {
  			# Magic variable
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  			return 1;
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. ${^MATCH})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		# Must be a cast
  		$t->{class} = $t->{token}->set_class( 'Cast' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '@' ) {
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol
  			$t->{class} = $t->{token}->set_class( 'Symbol' );
  			return 1;
  		}
  
  		if ( $PPI::Token::Magic::magic{ $c . $char } ) {
  			# Magic variable
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  			return 1;
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. @{^_Foo})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		# Must be a cast
  		$t->{class} = $t->{token}->set_class( 'Cast' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '%' ) {
  		# Is it a number?
  		if ( $char =~ /\d/ ) {
  			# bitwise operator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		# Is it a magic variable?
  		if ( $char eq '^' || $PPI::Token::Magic::magic{ $c . $char } ) {
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  			return 1;
  		}
  
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol (unless the thing before it is a number
  			my ( $prev ) = $t->_previous_significant_tokens(1);
  			if ( not $prev or not $prev->isa('PPI::Token::Number') ) {
  				$t->{class} = $t->{token}->set_class( 'Symbol' );
  				return 1;
  			}
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. %{^_Foo})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		return $self->_as_cast_or_op($t) if $self->_is_cast_or_op($char);
  
  		# Probably the mod operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '&' ) {
  		# Is it a number?
  		if ( $char =~ /\d/ ) {
  			# bitwise operator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol (unless the thing before it is a number
  			my ( $prev ) = $t->_previous_significant_tokens(1);
  			if ( not $prev or not $prev->isa('PPI::Token::Number') ) {
  				$t->{class} = $t->{token}->set_class( 'Symbol' );
  				return 1;
  			}
  		}
  
  		return $self->_as_cast_or_op($t) if $self->_is_cast_or_op($char);
  
  		# Probably the binary and operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '-' ) {
  		if ( $char =~ /\d/o ) {
  			# Number
  			$t->{class} = $t->{token}->set_class( 'Number' );
  			return 1;
  		}
  
  		if ( $char eq '.' ) {
  			# Number::Float
  			$t->{class} = $t->{token}->set_class( 'Number::Float' );
  			return 1;
  		}
  
  		if ( $char =~ /[a-zA-Z]/ ) {
  			$t->{class} = $t->{token}->set_class( 'DashedWord' );
  			return 1;
  		}
  
  		# The numeric negative operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq ':' ) {
  		if ( $char eq ':' ) {
  			# ::foo style bareword
  			$t->{class} = $t->{token}->set_class( 'Word' );
  			return 1;
  		}
  
  		# Now, : acts very very differently in different contexts.
  		# Mainly, we need to find out if this is a subroutine attribute.
  		# We'll leave a hint in the token to indicate that, if it is.
  		if ( $self->__TOKENIZER__is_an_attribute( $t ) ) {
  			# This : is an attribute indicator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			$t->{token}->{_attribute} = 1;
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		# It MIGHT be a label, but it's probably the ?: trinary operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  	}
  
  	# erm...
  	PPI::Exception->throw('Unknown value in PPI::Token::Unknown token');
  }
  
  sub _is_cast_or_op {
  	my ( $self, $char ) = @_;
  	return 1 if $char eq '$';
  	return 1 if $char eq '@';
  	return 1 if $char eq '%';
  	return 1 if $char eq '*';
  	return 1 if $char eq '{';
  	return;
  }
  
  sub _as_cast_or_op {
  	my ( $self, $t ) = @_;
  	my $class = _cast_or_op( $t );
  	$t->{class} = $t->{token}->set_class( $class );
  	return $t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  sub _prev_significant_w_cursor {
  	my ( $tokens, $cursor, $extra_check ) = @_;
  	while ( $cursor >= 0 ) {
  		my $token = $tokens->[ $cursor-- ];
  		next if !$token->significant;
  		next if $extra_check and !$extra_check->($token);
  		return ( $token, $cursor );
  	}
  	return ( undef, $cursor );
  }
  
  # Operator/operand-sensitive, multiple or GLOB cast
  sub _cast_or_op {
  	my ( $t ) = @_;
  
  	my $tokens = $t->{tokens};
  	my $cursor = scalar( @$tokens ) - 1;
  	my $token;
  
  	( $token, $cursor ) = _prev_significant_w_cursor( $tokens, $cursor );
  	return 'Cast' if !$token;    # token was first in the document
  
  	if ( $token->isa( 'PPI::Token::Structure' ) and $token->content eq '}' ) {
  
  		# Scan the token stream backwards an arbitrarily long way,
  		# looking for the matching opening curly brace.
  		my $structure_depth = 1;
  		( $token, $cursor ) = _prev_significant_w_cursor(
  			$tokens, $cursor,
  			sub {
  				my ( $token ) = @_;
  				return if !$token->isa( 'PPI::Token::Structure' );
  				if ( $token eq '}' ) {
  					$structure_depth++;
  					return;
  				}
  				if ( $token eq '{' ) {
  					$structure_depth--;
  					return if $structure_depth;
  				}
  				return 1;
  			}
  		);
  		return 'Operator' if !$token;    # no matching '{', probably an unbalanced '}'
  
  		# Scan past any whitespace
  		( $token, $cursor ) = _prev_significant_w_cursor( $tokens, $cursor );
  		return 'Operator' if !$token;                             # Document began with what must be a hash constructor.
  		return 'Operator' if $token->isa( 'PPI::Token::Symbol' ); # subscript
  
  		my %meth_or_subscript_end = map { $_ => 1 } qw@ -> } ] @;
  		return 'Operator' if $meth_or_subscript_end{ $token->content };    # subscript
  
  		my $content = $token->content;
  		my $produces_or_wants_value =
  		  ( $token->isa( 'PPI::Token::Word' ) and ( $content eq 'do' or $content eq 'eval' ) );
  		return $produces_or_wants_value ? 'Operator' : 'Cast';
  	}
  
  	my %list_start_or_term_end = map { $_ => 1 } qw@ ; ( { [ @;
  	return 'Cast'
  	  if $token->isa( 'PPI::Token::Structure' ) and $list_start_or_term_end{ $token->content }
  	  or $token->isa( 'PPI::Token::Cast' )
  	  or $token->isa( 'PPI::Token::Operator' )
  	  or $token->isa( 'PPI::Token::Label' );
  
  	return 'Operator' if !$token->isa( 'PPI::Token::Word' );
  
  	( $token, $cursor ) = _prev_significant_w_cursor( $tokens, $cursor );
  	return 'Cast' if !$token || $token->content ne '->';
  
  	return 'Operator';
  }
  
  # Are we at a location where a ':' would indicate a subroutine attribute
  sub __TOKENIZER__is_an_attribute {
  	my $t      = $_[1]; # Tokenizer object
  	my @tokens = $t->_previous_significant_tokens(3);
  	my $p0     = $tokens[0];
  	return '' if not $p0;
  
  	# If we just had another attribute, we are also an attribute
  	return 1 if $p0->isa('PPI::Token::Attribute');
  
  	# If we just had a prototype, then we are an attribute
  	return 1 if $p0->isa('PPI::Token::Prototype');
  
  	# Other than that, we would need to have had a bareword
  	return '' unless $p0->isa('PPI::Token::Word');
  
  	# We could be an anonymous subroutine
  	if ( $p0->isa('PPI::Token::Word') and $p0->content eq 'sub' ) {
  		return 1;
  	}
  
  	# Or, we could be a named subroutine
  	my $p1 = $tokens[1];
  	my $p2 = $tokens[2];
  	if (
  		$p1
  		and
  		$p1->isa('PPI::Token::Word')
  		and
  		$p1->content eq 'sub'
  		and (
  			not $p2
  			or
  			$p2->isa('PPI::Token::Structure')
  			or (
  				$p2->isa('PPI::Token::Whitespace')
  				and
  				$p2->content eq ''
  			)
  		)
  	) {
  		return 1;
  	}
  
  	# We aren't an attribute
  	'';	
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Whitespace - Tokens representing ordinary white space
  
  =head1 INHERITANCE
  
    PPI::Token::Whitespace
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  As a full "round-trip" parser, PPI records every last byte in a
  file and ensure that it is included in the L<PPI::Document> object.
  
  This even includes whitespace. In fact, Perl documents are seen
  as "floating in a sea of whitespace", and thus any document will
  contain vast quantities of C<PPI::Token::Whitespace> objects.
  
  For the most part, you shouldn't notice them. Or at least, you
  shouldn't B<have> to notice them.
  
  This means doing things like consistently using the "S for significant"
  series of L<PPI::Node> and L<PPI::Element> methods to do things.
  
  If you want the nth child element, you should be using C<schild> rather
  than C<child>, and likewise C<snext_sibling>, C<sprevious_sibling>, and
  so on and so forth.
  
  =head1 METHODS
  
  Again, for the most part you should really B<not> need to do anything
  very significant with whitespace.
  
  But there are a couple of convenience methods provided, beyond those
  provided by the parent L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use Clone      ();
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  =pod
  
  =head2 null
  
  Because L<PPI> sees documents as sitting on a sort of substrate made of
  whitespace, there are a couple of corner cases that get particularly
  nasty if they don't find whitespace in certain places.
  
  Imagine walking down the beach to go into the ocean, and then quite
  unexpectedly falling off the side of the planet. Well it's somewhat
  equivalent to that, including the whole screaming death bit.
  
  The C<null> method is a convenience provided to get some internals
  out of some of these corner cases.
  
  Specifically it create a whitespace token that represents nothing,
  or at least the null string C<''>. It's a handy way to have some
  "whitespace" right where you need it, without having to have any
  actual characters.
  
  =cut
  
  my $null;
  
  sub null {
  	$null ||= $_[0]->new('');
  	Clone::clone($null);
  }
  
  ### XS -> PPI/XS.xs:_PPI_Token_Whitespace__significant 0.900+
  sub significant() { '' }
  
  =pod
  
  =head2 tidy
  
  C<tidy> is a convenience method for removing unneeded whitespace.
  
  Specifically, it removes any whitespace from the end of a line.
  
  Note that this B<doesn't> include POD, where you may well need
  to keep certain types of whitespace. The entire POD chunk lives
  in its own L<PPI::Token::Pod> object.
  
  =cut
  
  sub tidy {
  	$_[0]->{content} =~ s/^\s+?(?>\n)//;
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Parsing Methods
  
  # Build the class and commit maps
  use vars qw{ @CLASSMAP @COMMITMAP %MATCHWORD };
  BEGIN {
  	@CLASSMAP  = ();
  	@COMMITMAP = ();
  	foreach (
  		'a' .. 'u', 'w', 'y', 'z', 'A' .. 'Z', '_'
  	) {
  		$COMMITMAP[ord $_] = 'PPI::Token::Word';
  	}
  	foreach ( qw!; [ ] { } )! )       { $COMMITMAP[ord $_] = 'PPI::Token::Structure' }
  	foreach ( 0 .. 9 )                { $CLASSMAP[ord $_]  = 'Number'   }
  	foreach ( qw{= ? | + > . ! ~ ^} ) { $CLASSMAP[ord $_]  = 'Operator' }
  	foreach ( qw{* $ @ & : %} )       { $CLASSMAP[ord $_]  = 'Unknown'  }
  
  	# Miscellaneous remainder
  	$COMMITMAP[ord '#'] = 'PPI::Token::Comment';
  	$COMMITMAP[ord 'v'] = 'PPI::Token::Number::Version';
  	$CLASSMAP[ord ',']  = 'PPI::Token::Operator';
  	$CLASSMAP[ord "'"]  = 'Quote::Single';
  	$CLASSMAP[ord '"']  = 'Quote::Double';
  	$CLASSMAP[ord '`']  = 'QuoteLike::Backtick';
  	$CLASSMAP[ord '\\'] = 'Cast';
  	$CLASSMAP[ord '_']  = 'Word';
  	$CLASSMAP[9]        = 'Whitespace'; # A horizontal tab
  	$CLASSMAP[10]       = 'Whitespace'; # A newline
  	$CLASSMAP[12]       = 'Whitespace'; # A form feed
  	$CLASSMAP[13]       = 'Whitespace'; # A carriage return
  	$CLASSMAP[32]       = 'Whitespace'; # A normal space
  
  	# Words (functions and keywords) after which a following / is
  	# almost certainly going to be a regex
  	%MATCHWORD = map { $_ => 1 } qw{
  		return
  		split
  		if
  		unless
  		grep
  		map
  	};
  }
  
  
  sub __TOKENIZER__on_line_start {
  	my $t    = $_[1];
  	my $line = $t->{line};
  
  	# Can we classify the entire line in one go
  	if ( $line =~ /^\s*$/ ) {
  		# A whitespace line
  		$t->_new_token( 'Whitespace', $line );
  		return 0;
  
  	} elsif ( $line =~ /^\s*#/ ) {
  		# A comment line
  		$t->_new_token( 'Comment', $line );
  		$t->_finalize_token;
  		return 0;
  
  	} elsif ( $line =~ /^=(\w+)/ ) {
  		# A Pod tag... change to pod mode
  		$t->_new_token( 'Pod', $line );
  		if ( $1 eq 'cut' ) {
  			# This is an error, but one we'll ignore
  			# Don't go into Pod mode, since =cut normally
  			# signals the end of Pod mode
  		} else {
  			$t->{class} = 'PPI::Token::Pod';
  		}
  		return 0;
  
  	} elsif ( $line =~ /^use v6\-alpha\;/ ) {
  		# Indicates a Perl 6 block. Make the initial
  		# implementation just suck in the entire rest of the
  		# file.
  		my @perl6;
  		while ( 1 ) {
  			my $line6 = $t->_get_line;
  			last unless defined $line6;
  			push @perl6, $line6;
  		}
  		push @{ $t->{perl6} }, join '', @perl6;
  
  		# We only sucked in the block, we don't actually do
  		# anything to the "use v6..." line. So return as if
  		# we didn't find anything at all.
  		return 1;
  	}
  
  	1;
  }
  
  sub __TOKENIZER__on_char {
  	my $t    = $_[1];
  	my $c = substr $t->{line}, $t->{line_cursor}, 1;
  	my $char = ord $c;
  
  	# Do we definitely know what something is?
  	return $COMMITMAP[$char]->__TOKENIZER__commit($t) if $COMMITMAP[$char];
  
  	# Handle the simple option first
  	return $CLASSMAP[$char] if $CLASSMAP[$char];
  
  	if ( $char == 40 ) {  # $char eq '('
  		# Finalise any whitespace token...
  		$t->_finalize_token if $t->{token};
  
  		# Is this the beginning of a sub prototype?
  		# We are a sub prototype IF
  		# 1. The previous significant token is a bareword.
  		# 2. The one before that is the word 'sub'.
  		# 3. The one before that is a 'structure'
  
  		# Get the three previous significant tokens
  		my @tokens = $t->_previous_significant_tokens(3);
  
  		# A normal subroutine declaration
  		my $p1 = $tokens[1];
  		my $p2 = $tokens[2];
  		if (
  			$tokens[0]
  			and
  			$tokens[0]->isa('PPI::Token::Word')
  			and
  			$p1
  			and
  			$p1->isa('PPI::Token::Word')
  			and
  			$p1->content eq 'sub'
  			and (
  				not $p2
  				or
  				$p2->isa('PPI::Token::Structure')
  				or (
  					$p2->isa('PPI::Token::Whitespace')
  					and
  					$p2->content eq ''
  				)
  			)
  		) {
  			# This is a sub prototype
  			return 'Prototype';
  		}
  
  		# A prototyped anonymous subroutine
  		my $p0 = $tokens[0];
  		if ( $p0 and $p0->isa('PPI::Token::Word') and $p0->content eq 'sub'
  			# Maybe it's invoking a method named 'sub'
  			and not ( $p1 and $p1->isa('PPI::Token::Operator') and $p1->content eq '->')
  		) {
  			return 'Prototype';
  		}
  
  		# This is a normal open bracket
  		return 'Structure';
  
  	} elsif ( $char == 60 ) { # $char eq '<'
  		# Finalise any whitespace token...
  		$t->_finalize_token if $t->{token};
  
  		# This is either "less than" or "readline quote-like"
  		# Do some context stuff to guess which.
  		my $prev = $t->_last_significant_token;
  
  		# The most common group of less-thans are used like
  		# $foo < $bar
  		# 1 < $bar
  		# $#foo < $bar
  		return 'Operator' if $prev and $prev->isa('PPI::Token::Symbol');
  		return 'Operator' if $prev and $prev->isa('PPI::Token::Magic');
  		return 'Operator' if $prev and $prev->isa('PPI::Token::Number');
  		return 'Operator' if $prev and $prev->isa('PPI::Token::ArrayIndex');
  
  		# If it is <<... it's a here-doc instead
  		my $next_char = substr( $t->{line}, $t->{line_cursor} + 1, 1 );
  		if ( $next_char eq '<' ) {
  			return 'Operator';
  		}
  
  		return 'Operator' if not $prev;
  
  		# The most common group of readlines are used like
  		# while ( <...> )
  		# while <>;
  		my $prec = $prev->content;
  		if ( $prev->isa('PPI::Token::Structure') and $prec eq '(' ) {
  			return 'QuoteLike::Readline';
  		}
  		if ( $prev->isa('PPI::Token::Word') and $prec eq 'while' ) {
  			return 'QuoteLike::Readline';
  		}
  		if ( $prev->isa('PPI::Token::Operator') and $prec eq '=' ) {
  			return 'QuoteLike::Readline';
  		}
  		if ( $prev->isa('PPI::Token::Operator') and $prec eq ',' ) {
  			return 'QuoteLike::Readline';
  		}
  
  		if ( $prev->isa('PPI::Token::Structure') and $prec eq '}' ) {
  			# Could go either way... do a regex check
  			# $foo->{bar} < 2;
  			# grep { .. } <foo>;
  			pos $t->{line} = $t->{line_cursor};
  			if ( $t->{line} =~ m/\G<(?!\d)\w+>/gc ) {
  				# Almost definitely readline
  				return 'QuoteLike::Readline';
  			}
  		}
  
  		# Otherwise, we guess operator, which has been the default up
  		# until this more comprehensive section was created.
  		return 'Operator';
  
  	} elsif ( $char == 47 ) { #  $char eq '/'
  		# Finalise any whitespace token...
  		$t->_finalize_token if $t->{token};
  
  		# This is either a "divided by" or a "start regex"
  		# Do some context stuff to guess ( ack ) which.
  		# Hopefully the guess will be good enough.
  		my $prev = $t->_last_significant_token;
  
  		# Or as the very first thing in a file
  		return 'Regexp::Match' if not $prev;
  
  		my $prec = $prev->content;
  
  		# Most times following an operator, we are a regex.
  		# This includes cases such as:
  		# ,  - As an argument in a list 
  		# .. - The second condition in a flip flop
  		# =~ - A bound regex
  		# !~ - Ditto
  		return 'Regexp::Match' if $prev->isa('PPI::Token::Operator');
  
  		# After a symbol
  		return 'Operator' if $prev->isa('PPI::Token::Symbol');
  		if ( $prec eq ']' and $prev->isa('PPI::Token::Structure') ) {
  			return 'Operator';
  		}
  
  		# After another number
  		return 'Operator' if $prev->isa('PPI::Token::Number');
  
  		# After going into scope/brackets
  		if (
  			$prev->isa('PPI::Token::Structure')
  			and (
  				$prec eq '('
  				or
  				$prec eq '{'
  				or
  				$prec eq ';'
  			)
  		) {
  			return 'Regexp::Match';
  		}
  
  		# Functions and keywords
  		if (
  			$MATCHWORD{$prec}
  			and
  			$prev->isa('PPI::Token::Word')
  		) {
  			return 'Regexp::Match';
  		}
  
  		# What about the char after the slash? There's some things
  		# that would be highly illogical to see if it's an operator.
  		my $next_char = substr $t->{line}, $t->{line_cursor} + 1, 1;
  		if ( defined $next_char and length $next_char ) {
  			if ( $next_char =~ /(?:\^|\[|\\)/ ) {
  				return 'Regexp::Match';
  			}
  		}
  
  		# Otherwise... erm... assume operator?
  		# Add more tests here as potential cases come to light
  		return 'Operator';
  
  	} elsif ( $char == 120 ) { # $char eq 'x'
  		# Could be a word, the x= operator, the x operator
  		# followed by whitespace, or the x operator without any
  		# space between itself and its operand, e.g.: '$a x3',
  		# which is the same as '$a x 3'.  _current_x_is_operator
  		# assumes we have a complete 'x' token, but we don't
  		# yet.  We may need to split this x character apart from
  		# what follows it.
  		if ( $t->_current_x_is_operator ) {
  			pos $t->{line} = $t->{line_cursor} + 1;
  			return 'Operator' if $t->{line} =~ m/\G(?:
  				\d  # x op with no whitespace e.g. 'x3'
  				|
  				(?!(  # negative lookahead
  					=>  # not on left of fat comma
  					|
  					\w  # not a word like "xyzzy"
  					|
  					\s  # not x op plus whitespace
  				))
  			)/gcx;
  		}
  
  		# Otherwise, commit like a normal bareword, including x
  		# operator followed by whitespace.
  		return PPI::Token::Word->__TOKENIZER__commit($t);
  
  	} elsif ( $char == 45 ) { # $char eq '-'
  		# Look for an obvious operator operand context
  		my $context = $t->_opcontext;
  		if ( $context eq 'operator' ) {
  			return 'Operator';
  		} else {
  			# More logic needed
  			return 'Unknown';
  		}
  
  	} elsif ( $char >= 128 ) { # Outside ASCII
  		return 'PPI::Token::Word'->__TOKENIZER__commit($t) if $c =~ /\w/;
  		return 'Whitespace' if $c =~ /\s/;
  	}
  
  
  	# All the whitespaces are covered, so what to do
  	### For now, die
  	PPI::Exception->throw("Encountered unexpected character '$char'");
  }
  
  sub __TOKENIZER__on_line_end {
  	$_[1]->_finalize_token if $_[1]->{token};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Word - The generic "word" Token
  
  =head1 INHERITANCE
  
    PPI::Token::Word
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Word> object is a PPI-specific representation of several
  different types of word-like things, and is one of the most common Token
  classes found in typical documents.
  
  Specifically, it includes not only barewords, but also any other valid
  Perl identifier including non-operator keywords and core functions, and
  any include C<::> separators inside it, as long as it fits the
  format of a class, function, etc.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Word> beyond those
  provided by its L<PPI::Token> and L<PPI::Element> parent
  classes.
  
  We expect to add additional methods to help further resolve a Word as
  a function, method, etc over time.  If you need such a thing right
  now, look at L<Perl::Critic::Utils>.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA %OPERATOR %QUOTELIKE %KEYWORDS};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  
  	# Copy in OPERATOR from PPI::Token::Operator
  	*OPERATOR  = *PPI::Token::Operator::OPERATOR;
  
  	%QUOTELIKE = (
  		'q'  => 'Quote::Literal',
  		'qq' => 'Quote::Interpolate',
  		'qx' => 'QuoteLike::Command',
  		'qw' => 'QuoteLike::Words',
  		'qr' => 'QuoteLike::Regexp',
  		'm'  => 'Regexp::Match',
  		's'  => 'Regexp::Substitute',
  		'tr' => 'Regexp::Transliterate',
  		'y'  => 'Regexp::Transliterate',
  	);
  
  	# List of keywords is from regen/keywords.pl in the perl source.
  	%KEYWORDS = map { $_ => 1 } qw{
  		abs accept alarm and atan2 bind binmode bless break caller chdir chmod
  		chomp chop chown chr chroot close closedir cmp connect continue cos
  		crypt dbmclose dbmopen default defined delete die do dump each else
  		elsif endgrent endhostent endnetent endprotoent endpwent endservent
  		eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for
  		foreach fork format formline ge getc getgrent getgrgid getgrnam
  		gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr
  		getnetbyname getnetent getpeername getpgrp getppid getpriority
  		getprotobyname getprotobynumber getprotoent getpwent getpwnam
  		getpwuid getservbyname getservbyport getservent getsockname
  		getsockopt given glob gmtime goto grep gt hex if index int ioctl join
  		keys kill last lc lcfirst le length link listen local localtime lock
  		log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no
  		not oct open opendir or ord our pack package pipe pop pos print
  		printf prototype push q qq qr quotemeta qw qx rand read readdir
  		readline readlink readpipe recv redo ref rename require reset return
  		reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl
  		semget semop send setgrent sethostent setnetent setpgrp
  		setpriority setprotoent setpwent setservent setsockopt shift shmctl
  		shmget shmread shmwrite shutdown sin sleep socket socketpair sort
  		splice split sprintf sqrt srand stat state study sub substr symlink
  		syscall sysopen sysread sysseek system syswrite tell telldir tie tied
  		time times tr truncate uc ucfirst umask undef unless unlink unpack
  		unshift untie until use utime values vec wait waitpid wantarray warn
  		when while write x xor y
  	};
  }
  
  =pod
  
  =head2 literal
  
  Returns the value of the Word as a string.  This assumes (often
  incorrectly) that the Word is a bareword and not a function, method,
  keyword, etc.  This differs from C<content> because C<Foo'Bar> expands
  to C<Foo::Bar>.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	my $word = $self->content;
  
  	# Expand Foo'Bar to Foo::Bar
  	$word =~ s/\'/::/g;
  
  	return $word;
  }
  
  =pod
  
  =head2 method_call
  
  Answers whether this is the name of a method in a method call. Returns true if
  yes, false if no, and nothing if unknown.
  
  =cut
  
  sub method_call {
  	my $self = shift;
  
  	my $previous = $self->sprevious_sibling;
  	if (
  		$previous
  		and
  		$previous->isa('PPI::Token::Operator')
  		and
  		$previous->content eq '->'
  	) {
  		return 1;
  	}
  
  	my $snext = $self->snext_sibling;
  	return 0 unless $snext;
  
  	if (
  		$snext->isa('PPI::Structure::List')
  		or
  		$snext->isa('PPI::Token::Structure')
  		or
  		$snext->isa('PPI::Token::Operator')
  		and (
  			$snext->content eq ','
  			or
  			$snext->content eq '=>'
  		)
  	) {
  		return 0;
  	}
  
  	if (
  		$snext->isa('PPI::Token::Word')
  		and
  		$snext->content =~ m< \w :: \z >xms
  	) {
  		return 1;
  	}
  
  	return;
  }
  
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  
  	# Suck in till the end of the bareword
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc ) {
  		my $word = $1;
  		# Special Case: If we accidentally treat eq'foo' like
  		# the word "eq'foo", then just make 'eq' (or whatever
  		# else is in the %KEYWORDS hash.
  		if ( $word =~ /^(\w+)'/ && $KEYWORDS{$1} ) {
  		    $word = $1;
  		}
  		$t->{token}->{content} .= $word;
  		$t->{line_cursor} += length $word;
  
  	}
  
  	# We might be a subroutine attribute.
  	if ( __current_token_is_attribute($t) ) {
  		$t->{class} = $t->{token}->set_class( 'Attribute' );
  		return $t->{class}->__TOKENIZER__commit( $t );
  	}
  
  	my $word = $t->{token}->{content};
  	if ( $KEYWORDS{$word} ) {
  		# Check for a Perl keyword that is forced to be a normal word instead
  		if ( $t->__current_token_is_forced_word ) {
  			$t->{class} = $t->{token}->set_class( 'Word' );
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  
  		# Check for a quote like operator. %QUOTELIKE must be subset of %KEYWORDS
  		if ( $QUOTELIKE{$word} ) {
  			$t->{class} = $t->{token}->set_class( $QUOTELIKE{$word} );
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  
  		# Or one of the word operators. %OPERATOR must be subset of %KEYWORDS
  		if ( $OPERATOR{$word} ) {
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  	}
  
  	# Unless this is a simple identifier, at this point
  	# it has to be a normal bareword
  	if ( $word =~ /\:/ ) {
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# If the NEXT character in the line is a colon, this
  	# is a label.
  	my $char = substr( $t->{line}, $t->{line_cursor}, 1 );
  	if ( $char eq ':' ) {
  		$t->{token}->{content} .= ':';
  		$t->{line_cursor}++;
  		$t->{class} = $t->{token}->set_class( 'Label' );
  
  	# If not a label, '_' on its own is the magic filehandle
  	} elsif ( $word eq '_' ) {
  		$t->{class} = $t->{token}->set_class( 'Magic' );
  
  	}
  
  	# Finalise and process the character again
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  
  
  # We are committed to being a bareword.
  # Or so we would like to believe.
  sub __TOKENIZER__commit {
  	my ($class, $t) = @_;
  
  	# Our current position is the first character of the bareword.
  	# Capture the bareword.
  	pos $t->{line} = $t->{line_cursor};
  	unless ( $t->{line} =~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc ) {
  		# Programmer error
  		die sprintf "Fatal error... regex failed to match in '%s' when expected", substr $t->{line}, $t->{line_cursor};
  	}
  
  	# Special Case: If we accidentally treat eq'foo' like the word "eq'foo",
  	# then unwind it and just make it 'eq' (or the other stringy comparitors)
  	my $word = $1;
  	if ( $word =~ /^(\w+)'/ && $KEYWORDS{$1} ) {
  	    $word = $1;
  	}
  
  	# Advance the position one after the end of the bareword
  	$t->{line_cursor} += length $word;
  
  	# We might be a subroutine attribute.
  	if ( __current_token_is_attribute($t) ) {
  		$t->_new_token( 'Attribute', $word );
  		return ($t->{line_cursor} >= $t->{line_length}) ? 0
  			: $t->{class}->__TOKENIZER__on_char($t);
  	}
  
  	# Check for the end of the file
  	if ( $word eq '__END__' ) {
  		# Create the token for the __END__ itself
  		$t->_new_token( 'Separator', $1 );
  		$t->_finalize_token;
  
  		# Move into the End zone (heh)
  		$t->{zone} = 'PPI::Token::End';
  
  		# Add the rest of the line as a comment, and a whitespace newline
  		# Anything after the __END__ on the line is "ignored". So we must
  		# also ignore it, by turning it into a comment.
  		my $end_rest = substr( $t->{line}, $t->{line_cursor} );
  		$t->{line_cursor} = length $t->{line};
  		if ( $end_rest =~ /\n$/ ) {
  			chomp $end_rest;
  			$t->_new_token( 'Comment', $end_rest ) if length $end_rest;
  			$t->_new_token( 'Whitespace', "\n" );
  		} else {
  			$t->_new_token( 'Comment', $end_rest ) if length $end_rest;
  		}
  		$t->_finalize_token;
  
  		return 0;
  	}
  
  	# Check for the data section
  	if ( $word eq '__DATA__' ) {
  		# Create the token for the __DATA__ itself
  		$t->_new_token( 'Separator', "$1" );
  		$t->_finalize_token;
  
  		# Move into the Data zone
  		$t->{zone} = 'PPI::Token::Data';
  
  		# Add the rest of the line as the Data token
  		my $data_rest = substr( $t->{line}, $t->{line_cursor} );
  		$t->{line_cursor} = length $t->{line};
  		if ( $data_rest =~ /\n$/ ) {
  			chomp $data_rest;
  			$t->_new_token( 'Comment', $data_rest ) if length $data_rest;
  			$t->_new_token( 'Whitespace', "\n" );
  		} else {
  			$t->_new_token( 'Comment', $data_rest ) if length $data_rest;
  		}
  		$t->_finalize_token;
  
  		return 0;
  	}
  
  	my $token_class;
  	if ( $word =~ /\:/ ) {
  		# Since it's not a simple identifier...
  		$token_class = 'Word';
  
  	} elsif ( $KEYWORDS{$word} and $t->__current_token_is_forced_word ) {
  		$token_class = 'Word';
  
  	} elsif ( $QUOTELIKE{$word} ) {
  		# Special Case: A Quote-like operator
  		$t->_new_token( $QUOTELIKE{$word}, $word );
  		return ($t->{line_cursor} >= $t->{line_length}) ? 0
  			: $t->{class}->__TOKENIZER__on_char( $t );
  
  	} elsif ( $OPERATOR{$word} && ($word ne 'x' || $t->_current_x_is_operator) ) {
  		# Word operator
  		$token_class = 'Operator';
  
  	} else {
  		# Get tokens early to be sure to not disturb state set up by pos and m//gc.
  		my @tokens = $t->_previous_significant_tokens(1);
  
  		# If the next character is a ':' then it's a label...
  		pos $t->{line} = $t->{line_cursor};
  		if ( $t->{line} =~ m/\G(\s*:)(?!:)/gc ) {
  			if ( $tokens[0] and $tokens[0]->{content} eq 'sub' ) {
  				# ... UNLESS it's after 'sub' in which
  				# case it is a sub name and an attribute
  				# operator.
  				# We COULD have checked this at the top
  				# level of checks, but this would impose
  				# an additional performance per-word
  				# penalty, and every other case where the
  				# attribute operator doesn't directly
  				# touch the object name already works.
  				$token_class = 'Word';
  			} else {
  				$word .= $1;
  				$t->{line_cursor} += length($1);
  				$token_class = 'Label';
  			}
  		} elsif ( $word eq '_' ) {
  			$token_class = 'Magic';
  		} else {
  			$token_class = 'Word';
  		}
  	}
  
  	# Create the new token and finalise
  	$t->_new_token( $token_class, $word );
  	if ( $t->{line_cursor} >= $t->{line_length} ) {
  		# End of the line
  		$t->_finalize_token;
  		return 0;
  	}
  	$t->_finalize_token->__TOKENIZER__on_char($t);
  }
  
  
  
  # Is the current Word really a subroutine attribute?
  sub __current_token_is_attribute {
  	my ( $t ) = @_;
  	my @tokens = $t->_previous_significant_tokens(1);
  	return (
  		$tokens[0]
  		and (
  			# hint from tokenizer
  			$tokens[0]->{_attribute}
  			# nothing between attribute and us except whitespace
  			or $tokens[0]->isa('PPI::Token::Attribute')
  		)
  	);
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add C<function>, C<method> etc detector methods
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::_QuoteEngine - The PPI Quote Engine
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::_QuoteEngine> package is designed hold functionality
  for processing quotes and quote like operators, including regexes.
  These have special requirements in parsing.
  
  The C<PPI::Token::_QuoteEngine> package itself provides various parsing
  methods, which the L<PPI::Token::Quote>, L<PPI::Token::QuoteLike> and
  L<PPI::Token::Regexp> can inherit from. In this sense, it serves
  as a base class.
  
  =head2 Using this class
  
  I<(Refers only to internal uses. This class does not provide a
  public interface)>
  
  To use these, you should initialize them as normal C<'$Class-E<gt>new'>,
  and then call the 'fill' method, which will cause the specialised
  parser to scan forwards and parse the quote to its end point.
  
  If -E<gt>fill returns true, finalise the token.
  
  =cut
  
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  # Hook for the __TOKENIZER__on_char token call
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = $_[0]->{token} ? shift : return undef;
  
  	# Call the fill method to process the quote
  	my $rv = $t->{token}->_fill( $t );
  	return undef unless defined $rv;
  
  	## Doesn't support "end of file" indicator
  
  	# Finalize the token and return 0 to tell the tokenizer
  	# to go to the next character.
  	$t->_finalize_token;
  
  	0;
  }
  
  
  
  
  
  #####################################################################
  # Optimised character processors, used for quotes
  # and quote like stuff, and accessible to the child classes
  
  # An outright scan, raw and fast.
  # Searches for a particular character, not escaped, loading in new
  # lines as needed.
  # When called, we start at the current position.
  # When leaving, the position should be set to the position
  # of the character, NOT the one after it.
  sub _scan_for_unescaped_character {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = (length $_[0] == 1) ? quotemeta shift : return undef;
  
  	# Create the search regex.
  	# Same as above but with a negative look-behind assertion.
  	my $search = qr/(.*?(?<!\\)(?:\\\\)*$char)/;
  
  	my $string = '';
  	while ( exists $t->{line} ) {
  		# Get the search area for the current line
  		pos $t->{line} = $t->{line_cursor};
  
  		# Can we find a match on this line
  		if ( $t->{line} =~ m/\G$search/gc ) {
  			# Found the character on this line
  			$t->{line_cursor} += length($1) - 1;
  			return $string . $1;
  		}
  
  		# Load in the next line
  		$string .= substr $t->{line}, $t->{line_cursor};
  		my $rv = $t->_fill_line('inscan');
  		if ( $rv ) {
  			# Push to first character
  			$t->{line_cursor} = 0;
  		} elsif ( defined $rv ) {
  			# We hit the End of File
  			return \$string;
  		} else {
  			# Unexpected error
  			return undef;
  		}
  	}
  
  	# We shouldn't be able to get here
  	return undef;
  }
  
  # Scan for a close braced, and take into account both escaping,
  # and open close bracket pairs in the string. When complete, the
  # method leaves the line cursor on the LAST character found.
  sub _scan_for_brace_character {
  	my $class       = shift;
  	my $t           = shift;
  	my $close_brace = $_[0] =~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess(''); # return undef;
  	my $open_brace  = $close_brace;
  	$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;
  
  	# Create the search string
  	$close_brace = quotemeta $close_brace;
  	$open_brace = quotemeta $open_brace;
  	my $search = qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;
  
  	# Loop as long as we can get new lines
  	my $string = '';
  	my $depth = 1;
  	while ( exists $t->{line} ) {
  		# Get the search area
  		pos $t->{line} = $t->{line_cursor};
  
  		# Look for a match
  		unless ( $t->{line} =~ /$search/gc ) {
  			# Load in the next line
  			$string .= substr( $t->{line}, $t->{line_cursor} );
  			my $rv = $t->_fill_line('inscan');
  			if ( $rv ) {
  				# Push to first character
  				$t->{line_cursor} = 0;
  				next;
  			}
  			if ( defined $rv ) {
  				# We hit the End of File
  				return \$string;
  			}
  
  			# Unexpected error
  			return undef;
  		}
  
  		# Add to the string
  		$string .= $1;
  		$t->{line_cursor} += length $1;
  
  		# Alter the depth and continue if we aren't at the end
  		$depth += ($1 =~ /$open_brace$/) ? 1 : -1 and next;
  
  		# Rewind the cursor by one character ( cludgy hack )
  		$t->{line_cursor} -= 1;
  		return $string;
  	}
  
  	# Returning the string as a reference indicates EOF
  	\$string;
  }
  
  # Find all spaces and comments, up to, but not including
  # the first non-whitespace character.
  #
  # Although it doesn't return it, it leaves the cursor
  # on the character following the gap
  sub _scan_quote_like_operator_gap {
  	my $t = $_[1];
  
  	my $string = '';
  	while ( exists $t->{line} ) {
  		# Get the search area for the current line
  		pos $t->{line} = $t->{line_cursor};
  
  		# Since this regex can match zero characters, it should always match
  		$t->{line} =~ /\G(\s*(?:\#.*)?)/gc or return undef;
  
  		# Add the chars found to the string
  		$string .= $1;
  
  		# Did we match the entire line?
  		unless ( $t->{line_cursor} + length $1 == length $t->{line} ) {
  			# Partial line match, which means we are at
  			# the end of the gap. Fix the cursor and return
  			# the string.
  			$t->{line_cursor} += length $1;
  			return $string;
  		}
  
  		# Load in the next line.
  		# If we reach the EOF, $t->{line} gets deleted,
  		# which is caught by the while.
  		my $rv = $t->_fill_line('inscan');
  		if ( $rv ) {
  			# Set the cursor to the first character
  			$t->{line_cursor} = 0;
  		} elsif ( defined $rv ) {
  			# Returning the string as a reference indicates EOF
  			return \$string;
  		} else {
  			return undef;
  		}
  	}
  
  	# Shouldn't be able to get here
  	return undef;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;
  
  # Full quote engine
  
  use strict;
  use Clone                    ();
  use Carp                     ();
  use PPI::Token::_QuoteEngine ();
  
  use vars qw{$VERSION @ISA %quotes %sections};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::_QuoteEngine';
  
  	# Prototypes for the different braced sections
  	%sections = (
  		'(' => { type => '()', _close => ')' },
  		'<' => { type => '<>', _close => '>' },
  		'[' => { type => '[]', _close => ']' },
  		'{' => { type => '{}', _close => '}' },
  	);
  
  	# For each quote type, the extra fields that should be set.
  	# This should give us faster initialization.
  	%quotes = (
  		'q'   => { operator => 'q',   braced => undef, separator => undef, _sections => 1 },
  		'qq'  => { operator => 'qq',  braced => undef, separator => undef, _sections => 1 },
  		'qx'  => { operator => 'qx',  braced => undef, separator => undef, _sections => 1 },
  		'qw'  => { operator => 'qw',  braced => undef, separator => undef, _sections => 1 },
  		'qr'  => { operator => 'qr',  braced => undef, separator => undef, _sections => 1, modifiers => 1 },
  		'm'   => { operator => 'm',   braced => undef, separator => undef, _sections => 1, modifiers => 1 },
  		's'   => { operator => 's',   braced => undef, separator => undef, _sections => 2, modifiers => 1 },
  		'tr'  => { operator => 'tr',  braced => undef, separator => undef, _sections => 2, modifiers => 1 },
  
  		# Y is the little-used variant of tr
  		'y'   => { operator => 'y',   braced => undef, separator => undef, _sections => 2, modifiers => 1 },
  
  		'/'   => { operator => undef, braced => 0,     separator => '/',   _sections => 1, modifiers => 1 },
  
  		# Angle brackets quotes mean "readline(*FILEHANDLE)"
  		'<'   => { operator => undef, braced => 1,     separator => undef, _sections => 1, },
  
  		# The final ( and kind of depreciated ) "first match only" one is not
  		# used yet, since I'm not sure on the context differences between
  		# this and the trinary operator, but it's here for completeness.
  		'?'   => { operator => undef, braced => 0,     separator => '?',   _sections => 1, modifiers => 1 },
  	);
  }
  
  
  sub new {
  	my $class = shift;
  	my $init  = defined $_[0]
  		? shift
  		: Carp::croak("::Full->new called without init string");
  
  	# Create the token
  	### This manual SUPER'ing ONLY works because none of
  	### Token::Quote, Token::QuoteLike and Token::Regexp
  	### implement a new function of their own.
  	my $self = PPI::Token::new( $class, $init ) or return undef;
  
  	# Do we have a prototype for the initializer? If so, add the extra fields
  	my $options = $quotes{$init} or return $self->_error(
  		"Unknown quote type '$init'"
  	);
  	foreach ( keys %$options ) {
  		$self->{$_} = $options->{$_};
  	}
  
  	# Set up the modifiers hash if needed
  	$self->{modifiers} = {} if $self->{modifiers};
  
  	# Handle the special < base
  	if ( $init eq '<' ) {
  		$self->{sections}->[0] = Clone::clone( $sections{'<'} );
  	}
  
  	$self;
  }
  
  sub _fill {
  	my $class = shift;
  	my $t     = shift;
  	my $self  = $t->{token}
  		or Carp::croak("::Full->_fill called without current token");
  
  	# Load in the operator stuff if needed
  	if ( $self->{operator} ) {
  		# In an operator based quote-like, handle the gap between the
  		# operator and the opening separator.
  		if ( substr( $t->{line}, $t->{line_cursor}, 1 ) =~ /\s/ ) {
  			# Go past the gap
  			my $gap = $self->_scan_quote_like_operator_gap( $t );
  			return undef unless defined $gap;
  			if ( ref $gap ) {
  				# End of file
  				$self->{content} .= $$gap;
  				return 0;
  			}
  			$self->{content} .= $gap;
  		}
  
  		# The character we are now on is the separator. Capture,
  		# and advance into the first section.
  		my $sep = substr( $t->{line}, $t->{line_cursor}++, 1 );
  		$self->{content} .= $sep;
  
  		# Determine if these are normal or braced type sections
  		if ( my $section = $sections{$sep} ) {
  			$self->{braced}        = 1;
  			$self->{sections}->[0] = Clone::clone($section);
  		} else {
  			$self->{braced}        = 0;
  			$self->{separator}     = $sep;
  		}
  	}
  
  	# Parse different based on whether we are normal or braced
  	my $rv = $self->{braced}
  		? $self->_fill_braced($t)
   		: $self->_fill_normal($t);
  	return $rv if !$rv;
  
  	# Return now unless it has modifiers ( i.e. s/foo//eieio )
  	return 1 unless $self->{modifiers};
  
  	# Check for modifiers
  	my $char;
  	my $len = 0;
  	while ( ($char = substr( $t->{line}, $t->{line_cursor} + 1, 1 )) =~ /[^\W\d_]/ ) {
  		$len++;
  		$self->{content} .= $char;
  		$self->{modifiers}->{lc $char} = 1;
  		$t->{line_cursor}++;
  	}
  }
  
  # Handle the content parsing path for normally separated
  sub _fill_normal {
  	my $self = shift;
  	my $t    = shift;
  
  	# Get the content up to the next separator
  	my $string = $self->_scan_for_unescaped_character( $t, $self->{separator} );
  	return undef unless defined $string;
  	if ( ref $string ) {
  		# End of file
  		if ( length($$string) > 1 )  {
  			# Complete the properties for the first section
  			my $str = $$string;
  			chop $str;
  			$self->{sections}->[0] = {
  				position => length($self->{content}),
  				size     => length($$string) - 1,
  				type     => "$self->{separator}$self->{separator}",
  			};
  			$self->{_sections} = 1;
  		} else {
  			# No sections at all
  			$self->{sections}  = [ ];
  			$self->{_sections} = 0;
  		}
  		$self->{content} .= $$string;
  		return 0;
  	}
  
  	# Complete the properties of the first section
  	$self->{sections}->[0] = {
  		position => length $self->{content},
  		size     => length($string) - 1,
  		type     => "$self->{separator}$self->{separator}",
  	};
  	$self->{content} .= $string;
  
  	# We are done if there is only one section
  	return 1 if $self->{_sections} == 1;
  
  	# There are two sections.
  
  	# Advance into the next section
  	$t->{line_cursor}++;
  
  	# Get the content up to the end separator
  	$string = $self->_scan_for_unescaped_character( $t, $self->{separator} );
  	return undef unless defined $string;
  	if ( ref $string ) {
  		# End of file
  		if ( length($$string) > 1 )  {
  			# Complete the properties for the second section
  			my $str = $$string;
  			chop $str;
  			$self->{sections}->[1] = {
  				position => length($self->{content}),
  				size     => length($$string) - 1,
  				type     => "$self->{separator}$self->{separator}",
  			};
  		} else {
  			# No sections at all
  			$self->{_sections} = 1;
  		}
  		$self->{content} .= $$string;
  		return 0;
  	}
  
  	# Complete the properties of the second section
  	$self->{sections}->[1] = {
  		position => length($self->{content}),
  		size     => length($string) - 1
  	};
  	$self->{content} .= $string;
  
  	1;
  }
  
  # Handle content parsing for matching brace separated
  sub _fill_braced {
  	my $self = shift;
  	my $t    = shift;
  
  	# Get the content up to the close character
  	my $section   = $self->{sections}->[0];
  	my $brace_str = $self->_scan_for_brace_character( $t, $section->{_close} );
  	return undef unless defined $brace_str;
  	if ( ref $brace_str ) {
  		# End of file
  		if ( length($$brace_str) > 1 )  {
  			# Complete the properties for the first section
  			my $str = $$brace_str;
  			chop $str;
  			$self->{sections}->[0] = {
  				position => length($self->{content}),
  				size     => length($$brace_str) - 1,
  				type     => $section->{type},
  			};
  			$self->{_sections} = 1;
  		} else {
  			# No sections at all
  			$self->{sections}  = [ ];
  			$self->{_sections} = 0;
  		}
  		$self->{content} .= $$brace_str;
  		return 0;
  	}
  
  	# Complete the properties of the first section
  	$section->{position} = length $self->{content};
  	$section->{size}     = length($brace_str) - 1;
  	$self->{content} .= $brace_str;
  	delete $section->{_close};
  
  	# We are done if there is only one section
  	return 1 if $self->{_sections} == 1;
  
  	# There are two sections.
  
  	# Is there a gap between the sections.
  	my $char = substr( $t->{line}, ++$t->{line_cursor}, 1 );
  	if ( $char =~ /\s/ ) {
  		# Go past the gap
  		my $gap_str = $self->_scan_quote_like_operator_gap( $t );
  		return undef unless defined $gap_str;
  		if ( ref $gap_str ) {
  			# End of file
  			$self->{content} .= $$gap_str;
  			return 0;
  		}
  		$self->{content} .= $gap_str;
  		$char = substr( $t->{line}, $t->{line_cursor}, 1 );
  	}
  
  	$section = $sections{$char};
  
  	if ( $section ) {
  		# It's a brace
  
  		# Initialize the second section
  		$self->{content} .= $char;
  		$section = { %$section };
  
  		# Advance into the second section
  		$t->{line_cursor}++;
  
  		# Get the content up to the close character
  		$brace_str = $self->_scan_for_brace_character( $t, $section->{_close} );
  		return undef unless defined $brace_str;
  		if ( ref $brace_str ) {
  			# End of file
  			if ( length($$brace_str) > 1 )  {
  				# Complete the properties for the second section
  				my $str = $$brace_str;
  				chop $str;
  				$self->{sections}->[1] = {
  					position => length($self->{content}),
  					size     => length($$brace_str) - 1,
  					type     => $section->{type},
  				};
  				$self->{_sections} = 2;
  			} else {
  				# No sections at all
  				$self->{_sections} = 1;
  			}
  			$self->{content} .= $$brace_str;
  			return 0;
  		} else {
  			# Complete the properties for the second section
  			$self->{sections}->[1] = {
  				position => length($self->{content}),
  				size     => length($brace_str) - 1,
  				type     => $section->{type},
  			};
  			$self->{content} .= $brace_str;
  		}
  	} elsif ( $char =~ m/ \A [^\w\s] \z /smx ) {
  		# It is some other delimiter (weird, but possible)
  
  		# Add the delimiter to the content.
  		$self->{content} .= $char;
  
  		# Advance into the next section
  		$t->{line_cursor}++;
  
  		# Get the content up to the end separator
  		my $string = $self->_scan_for_unescaped_character( $t, $char );
  		return undef unless defined $string;
  		if ( ref $string ) {
  			# End of file
  			if ( length($$string) > 1 )  {
  				# Complete the properties for the second section
  				my $str = $$string;
  				chop $str;
  				$self->{sections}->[1] = {
  					position => length($self->{content}),
  					size     => length($$string) - 1,
  					type     => "$char$char",
  				};
  			} else {
  				# Only the one section
  				$self->{_sections} = 1;
  			}
  			$self->{content} .= $$string;
  			return 0;
  		}
  
  		# Complete the properties of the second section
  		$self->{sections}->[1] = {
  			position => length($self->{content}),
  			size     => length($string) - 1,
  			type     => "$char$char", 
  		};
  		$self->{content} .= $string;
  
  	} else {
  
  		# Error, it has to be a delimiter of some sort.
  		# Although this will result in a REALLY illegal regexp,
  		# we allow it anyway.
  
  		# Create a null second section
  		$self->{sections}->[1] = {
  			position => length($self->{content}),
  			size     => 0,
  			type     => '',
  		};
  
  		# Attach an error to the token and move on
  		$self->{_error} = "No second section of regexp, or does not start with a balanced character";
  
  		# Roll back the cursor one char and return signalling end of regexp
  		$t->{line_cursor}--;
  		return 0;
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Additional methods to find out about the quote
  
  # In a scalar context, get the number of sections
  # In an array context, get the section information
  sub _sections {
  	wantarray ? @{$_[0]->{sections}} : scalar @{$_[0]->{sections}}
  }
  
  # Get a section's content
  sub _section_content {
  	my $self = shift;
  	my $i    = shift;
  	$self->{sections} or return;
  	my $section = $self->{sections}->[$i] or return;
  	return substr( $self->content, $section->{position}, $section->{size} );
  }
  
  # Get the modifiers if any.
  # In list context, return the modifier hash.
  # In scalar context, clone the hash and return a reference to it.
  # If there are no modifiers, simply return.
  sub _modifiers {
  	my $self = shift;
  	$self->{modifiers} or return;
  	wantarray and return %{ $self->{modifiers} };
  	return +{ %{ $self->{modifiers} } };
  }
  
  # Get the delimiters, or at least give it a good try to get them.
  sub _delimiters {
  	my $self = shift;
  	$self->{sections} or return;
  	my @delims;
  	foreach my $sect ( @{ $self->{sections} } ) {
  		if ( exists $sect->{type} ) {
  			push @delims, $sect->{type};
  		} else {
  			my $content = $self->content;
  			push @delims,
  			substr( $content, $sect->{position} - 1, 1 ) .
  			substr( $content, $sect->{position} + $sect->{size}, 1 );
  		}
  	}
  	return @delims;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;
  
  # Simple quote engine
  
  use strict;
  use PPI::Token::_QuoteEngine ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::_QuoteEngine';
  }
  
  sub new {
  	my $class     = shift;
  	my $separator = shift or return undef;
  
  	# Create a new token containing the separator
  	### This manual SUPER'ing ONLY works because none of
  	### Token::Quote, Token::QuoteLike and Token::Regexp
  	### implement a new function of their own.
  	my $self = PPI::Token::new( $class, $separator ) or return undef;
  	$self->{separator} = $separator;
  
  	$self;
  }
  
  sub _fill {
  	my $class = shift;
  	my $t     = shift;
  	my $self  = $t->{token} or return undef;
  
  	# Scan for the end separator
  	my $string = $self->_scan_for_unescaped_character( $t, $self->{separator} );
  	return undef unless defined $string;
  	if ( ref $string ) {
  		# End of file
  		$self->{content} .= $$string;
  		return 0;
  	} else {
  		# End of string
  		$self->{content} .= $string;
  		return $self;
  	}
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;
  
  =pod
  
  =head1 NAME
  
  PPI::Tokenizer - The Perl Document Tokenizer
  
  =head1 SYNOPSIS
  
    # Create a tokenizer for a file, array or string
    $Tokenizer = PPI::Tokenizer->new( 'filename.pl' );
    $Tokenizer = PPI::Tokenizer->new( \@lines       );
    $Tokenizer = PPI::Tokenizer->new( \$source      );
    
    # Return all the tokens for the document
    my $tokens = $Tokenizer->all_tokens;
    
    # Or we can use it as an iterator
    while ( my $Token = $Tokenizer->get_token ) {
    	print "Found token '$Token'\n";
    }
    
    # If we REALLY need to manually nudge the cursor, you
    # can do that to (The lexer needs this ability to do rollbacks)
    $is_incremented = $Tokenizer->increment_cursor;
    $is_decremented = $Tokenizer->decrement_cursor;
  
  =head1 DESCRIPTION
  
  PPI::Tokenizer is the class that provides Tokenizer objects for use in
  breaking strings of Perl source code into Tokens.
  
  By the time you are reading this, you probably need to know a little
  about the difference between how perl parses Perl "code" and how PPI
  parsers Perl "documents".
  
  "perl" itself (the interpreter) uses a heavily modified lex specification
  to specify its parsing logic, maintains several types of state as it
  goes, and incrementally tokenizes, lexes AND EXECUTES at the same time.
  
  In fact, it is provably impossible to use perl's parsing method without
  simultaneously executing code. A formal mathematical proof has been
  published demonstrating the method.
  
  This is where the truism "Only perl can parse Perl" comes from.
  
  PPI uses a completely different approach by abandoning the (impossible)
  ability to parse Perl the same way that the interpreter does, and instead
  parsing the source as a document, using a document structure independently
  derived from the Perl documentation and approximating the perl interpreter
  interpretation as closely as possible.
  
  It was touch and go for a long time whether we could get it close enough,
  but in the end it turned out that it could be done.
  
  In this approach, the tokenizer C<PPI::Tokenizer> is implemented separately
  from the lexer L<PPI::Lexer>.
  
  The job of C<PPI::Tokenizer> is to take pure source as a string and break it
  up into a stream/set of tokens, and contains most of the "black magic" used
  in PPI. By comparison, the lexer implements a relatively straight forward
  tree structure, and has an implementation that is uncomplicated (compared
  to the insanity in the tokenizer at least).
  
  The Tokenizer uses an immense amount of heuristics, guessing and cruft,
  supported by a very B<VERY> flexible internal API, but fortunately it was
  possible to largely encapsulate the black magic, so there is not a lot that
  gets exposed to people using the C<PPI::Tokenizer> itself.
  
  =head1 METHODS
  
  Despite the incredible complexity, the Tokenizer itself only exposes a
  relatively small number of methods, with most of the complexity implemented
  in private methods.
  
  =cut
  
  # Make sure everything we need is loaded so
  # we don't have to go and load all of PPI.
  use strict;
  use Params::Util    qw{_INSTANCE _SCALAR0 _ARRAY0};
  use List::Util 1.33 ();
  use PPI::Util       ();
  use PPI::Element    ();
  use PPI::Token      ();
  use PPI::Exception  ();
  use PPI::Exception::ParserRejection ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  # The x operator cannot follow most Perl operators, implying that
  # anything beginning with x following an operator is a word.
  # These are the exceptions.
  my %X_CAN_FOLLOW_OPERATOR = map { $_ => 1 } qw( -- ++ );
  
  # The x operator cannot follow most structure elements, implying that
  # anything beginning with x following a structure element is a word.
  # These are the exceptions.
  my %X_CAN_FOLLOW_STRUCTURE = map { $_ => 1 } qw( } ] \) );
  
  # Something that looks like the x operator but follows a word
  # is usually that word's argument.
  # These are the exceptions.
  # chop, chomp, dump are ambiguous because they can have either parms
  # or no parms.
  my %X_CAN_FOLLOW_WORD = map { $_ => 1 } qw(
  		endgrent
  		endhostent
  		endnetent
  		endprotoent
  		endpwent
  		endservent
  		fork
  		getgrent
  		gethostent
  		getlogin
  		getnetent
  		getppid
  		getprotoent
  		getpwent
  		getservent
  		setgrent
  		setpwent
  		time
  		times
  		wait
  		wantarray
  		__SUB__
  );
  
  
  
  #####################################################################
  # Creation and Initialization
  
  =pod
  
  =head2 new $file | \@lines | \$source
  
  The main C<new> constructor creates a new Tokenizer object. These
  objects have no configuration parameters, and can only be used once,
  to tokenize a single perl source file.
  
  It takes as argument either a normal scalar containing source code,
  a reference to a scalar containing source code, or a reference to an
  ARRAY containing newline-terminated lines of source code.
  
  Returns a new C<PPI::Tokenizer> object on success, or throws a
  L<PPI::Exception> exception on error.
  
  =cut
  
  sub new {
  	my $class = ref($_[0]) || $_[0];
  
  	# Create the empty tokenizer struct
  	my $self = bless {
  		# Source code
  		source       => undef,
  		source_bytes => undef,
  
  		# Line buffer
  		line         => undef,
  		line_length  => undef,
  		line_cursor  => undef,
  		line_count   => 0,
  
  		# Parse state
  		token        => undef,
  		class        => 'PPI::Token::BOM',
  		zone         => 'PPI::Token::Whitespace',
  
  		# Output token buffer
  		tokens       => [],
  		token_cursor => 0,
  		token_eof    => 0,
  
  		# Perl 6 blocks
  		perl6        => [],
  	}, $class;
  
  	if ( ! defined $_[1] ) {
  		# We weren't given anything
  		PPI::Exception->throw("No source provided to Tokenizer");
  
  	} elsif ( ! ref $_[1] ) {
  		my $source = PPI::Util::_slurp($_[1]);
  		if ( ref $source ) {
  			# Content returned by reference
  			$self->{source} = $$source;
  		} else {
  			# Errors returned as a string
  			return( $source );
  		}
  
  	} elsif ( _SCALAR0($_[1]) ) {
  		$self->{source} = ${$_[1]};
  
  	} elsif ( _ARRAY0($_[1]) ) {
  		$self->{source} = join '', map { "\n" } @{$_[1]};
  
  	} else {
  		# We don't support whatever this is
  		PPI::Exception->throw(ref($_[1]) . " is not supported as a source provider");
  	}
  
  	# We can't handle a null string
  	$self->{source_bytes} = length $self->{source};
  	if ( $self->{source_bytes} ) {
  		# Split on local newlines
  		$self->{source} =~ s/(?:\015{1,2}\012|\015|\012)/\n/g;
  		$self->{source} = [ split /(?<=\n)/, $self->{source} ];
  
  	} else {
  		$self->{source} = [ ];
  	}
  
  	### EVIL
  	# I'm explaining this earlier than I should so you can understand
  	# why I'm about to do something that looks very strange. There's
  	# a problem with the Tokenizer, in that tokens tend to change
  	# classes as each letter is added, but they don't get allocated
  	# their definite final class until the "end" of the token, the
  	# detection of which occurs in about a hundred different places,
  	# all through various crufty code (that triples the speed).
  	#
  	# However, in general, this does not apply to tokens in which a
  	# whitespace character is valid, such as comments, whitespace and
  	# big strings.
  	#
  	# So what we do is add a space to the end of the source. This
  	# triggers normal "end of token" functionality for all cases. Then,
  	# once the tokenizer hits end of file, it examines the last token to
  	# manually either remove the ' ' token, or chop it off the end of
  	# a longer one in which the space would be valid.
  	if ( List::Util::any { /^__(?:DATA|END)__\s*$/ } @{$self->{source}} ) {
  		$self->{source_eof_chop} = '';
  	} elsif ( ! defined $self->{source}->[0] ) {
  		$self->{source_eof_chop} = '';
  	} elsif ( $self->{source}->[-1] =~ /\s$/ ) {
  		$self->{source_eof_chop} = '';
  	} else {
  		$self->{source_eof_chop} = 1;
  		$self->{source}->[-1] .= ' ';
  	}
  
  	$self;
  }
  
  
  
  
  
  #####################################################################
  # Main Public Methods
  
  =pod
  
  =head2 get_token
  
  When using the PPI::Tokenizer object as an iterator, the C<get_token>
  method is the primary method that is used. It increments the cursor
  and returns the next Token in the output array.
  
  The actual parsing of the file is done only as-needed, and a line at
  a time. When C<get_token> hits the end of the token array, it will
  cause the parser to pull in the next line and parse it, continuing
  as needed until there are more tokens on the output array that
  get_token can then return.
  
  This means that a number of Tokenizer objects can be created, and
  won't consume significant CPU until you actually begin to pull tokens
  from it.
  
  Return a L<PPI::Token> object on success, C<0> if the Tokenizer had
  reached the end of the file, or C<undef> on error.
  
  =cut
  
  sub get_token {
  	my $self = shift;
  
  	# Shortcut for EOF
  	if ( $self->{token_eof}
  	 and $self->{token_cursor} > scalar @{$self->{tokens}}
  	) {
  		return 0;
  	}
  
  	# Return the next token if we can
  	if ( my $token = $self->{tokens}->[ $self->{token_cursor} ] ) {
  		$self->{token_cursor}++;
  		return $token;
  	}
  
  	my $line_rv;
  
  	# Catch exceptions and return undef, so that we
  	# can start to convert code to exception-based code.
  	my $rv = eval {
  		# No token, we need to get some more
  		while ( $line_rv = $self->_process_next_line ) {
  			# If there is something in the buffer, return it
  			# The defined() prevents a ton of calls to PPI::Util::TRUE
  			if ( defined( my $token = $self->{tokens}->[ $self->{token_cursor} ] ) ) {
  				$self->{token_cursor}++;
  				return $token;
  			}
  		}
  		return undef;
  	};
  	if ( $@ ) {
  		if ( _INSTANCE($@, 'PPI::Exception') ) {
  			$@->throw;
  		} else {
  			my $errstr = $@;
  			$errstr =~ s/^(.*) at line .+$/$1/;
  			PPI::Exception->throw( $errstr );
  		}
  	} elsif ( $rv ) {
  		return $rv;
  	}
  
  	if ( defined $line_rv ) {
  		# End of file, but we can still return things from the buffer
  		if ( my $token = $self->{tokens}->[ $self->{token_cursor} ] ) {
  			$self->{token_cursor}++;
  			return $token;
  		}
  
  		# Set our token end of file flag
  		$self->{token_eof} = 1;
  		return 0;
  	}
  
  	# Error, pass it up to our caller
  	undef;
  }
  
  =pod
  
  =head2 all_tokens
  
  When not being used as an iterator, the C<all_tokens> method tells
  the Tokenizer to parse the entire file and return all of the tokens
  in a single ARRAY reference.
  
  It should be noted that C<all_tokens> does B<NOT> interfere with the
  use of the Tokenizer object as an iterator (does not modify the token
  cursor) and use of the two different mechanisms can be mixed safely.
  
  Returns a reference to an ARRAY of L<PPI::Token> objects on success
  or throws an exception on error.
  
  =cut
  
  sub all_tokens {
  	my $self = shift;
  
  	# Catch exceptions and return undef, so that we
  	# can start to convert code to exception-based code.
  	my $ok = eval {
  		# Process lines until we get EOF
  		unless ( $self->{token_eof} ) {
  			my $rv;
  			while ( $rv = $self->_process_next_line ) {}
  			unless ( defined $rv ) {
  				PPI::Exception->throw("Error while processing source");
  			}
  
  			# Clean up the end of the tokenizer
  			$self->_clean_eof;
  		}
  		1;
  	};
  	if ( !$ok ) {
  		my $errstr = $@;
  		$errstr =~ s/^(.*) at line .+$/$1/;
  		PPI::Exception->throw( $errstr );
  	}
  
  	# End of file, return a copy of the token array.
  	return [ @{$self->{tokens}} ];
  }
  
  =pod
  
  =head2 increment_cursor
  
  Although exposed as a public method, C<increment_cursor> is implemented
  for expert use only, when writing lexers or other components that work
  directly on token streams.
  
  It manually increments the token cursor forward through the file, in effect
  "skipping" the next token.
  
  Return true if the cursor is incremented, C<0> if already at the end of
  the file, or C<undef> on error.
  
  =cut
  
  sub increment_cursor {
  	# Do this via the get_token method, which makes sure there
  	# is actually a token there to move to.
  	$_[0]->get_token and 1;
  }
  
  =pod
  
  =head2 decrement_cursor
  
  Although exposed as a public method, C<decrement_cursor> is implemented
  for expert use only, when writing lexers or other components that work
  directly on token streams.
  
  It manually decrements the token cursor backwards through the file, in
  effect "rolling back" the token stream. And indeed that is what it is
  primarily intended for, when the component that is consuming the token
  stream needs to implement some sort of "roll back" feature in its use
  of the token stream.
  
  Return true if the cursor is decremented, C<0> if already at the
  beginning of the file, or C<undef> on error.
  
  =cut
  
  sub decrement_cursor {
  	my $self = shift;
  
  	# Check for the beginning of the file
  	return 0 unless $self->{token_cursor};
  
  	# Decrement the token cursor
  	$self->{token_eof} = 0;
  	--$self->{token_cursor};
  }
  
  
  
  
  
  #####################################################################
  # Working With Source
  
  # Fetches the next line from the input line buffer
  # Returns undef at EOF.
  sub _get_line {
  	my $self = shift;
  	return undef unless $self->{source}; # EOF hit previously
  
  	# Pull off the next line
  	my $line = shift @{$self->{source}};
  
  	# Flag EOF if we hit it
  	$self->{source} = undef unless defined $line;
  
  	# Return the line (or EOF flag)
  	return $line; # string or undef
  }
  
  # Fetches the next line, ready to process
  # Returns 1 on success
  # Returns 0 on EOF
  sub _fill_line {
  	my $self   = shift;
  	my $inscan = shift;
  
  	# Get the next line
  	my $line = $self->_get_line;
  	unless ( defined $line ) {
  		# End of file
  		unless ( $inscan ) {
  			delete $self->{line};
  			delete $self->{line_cursor};
  			delete $self->{line_length};
  			return 0;
  		}
  
  		# In the scan version, just set the cursor to the end
  		# of the line, and the rest should just cascade out.
  		$self->{line_cursor} = $self->{line_length};
  		return 0;
  	}
  
  	# Populate the appropriate variables
  	$self->{line}        = $line;
  	$self->{line_cursor} = -1;
  	$self->{line_length} = length $line;
  	$self->{line_count}++;
  
  	1;
  }
  
  # Get the current character
  sub _char {
  	my $self = shift;
  	substr( $self->{line}, $self->{line_cursor}, 1 );
  }
  
  
  
  
  
  ####################################################################
  # Per line processing methods
  
  # Processes the next line
  # Returns 1 on success completion
  # Returns 0 if EOF
  # Returns undef on error
  sub _process_next_line {
  	my $self = shift;
  
  	# Fill the line buffer
  	my $rv;
  	unless ( $rv = $self->_fill_line ) {
  		return undef unless defined $rv;
  
  		# End of file, finalize last token
  		$self->_finalize_token;
  		return 0;
  	}
  
  	# Run the __TOKENIZER__on_line_start
  	$rv = $self->{class}->__TOKENIZER__on_line_start( $self );
  	unless ( $rv ) {
  		# If there are no more source lines, then clean up
  		if ( ref $self->{source} eq 'ARRAY' and ! @{$self->{source}} ) {
  			$self->_clean_eof;
  		}
  
  		# Defined but false means next line
  		return 1 if defined $rv;
  		PPI::Exception->throw("Error at line $self->{line_count}");
  	}
  
  	# If we can't deal with the entire line, process char by char
  	while ( $rv = $self->_process_next_char ) {}
  	unless ( defined $rv ) {
  		PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}");
  	}
  
  	# Trigger any action that needs to happen at the end of a line
  	$self->{class}->__TOKENIZER__on_line_end( $self );
  
  	# If there are no more source lines, then clean up
  	unless ( ref($self->{source}) eq 'ARRAY' and @{$self->{source}} ) {
  		return $self->_clean_eof;
  	}
  
  	return 1;
  }
  
  
  
  
  
  #####################################################################
  # Per-character processing methods
  
  # Process on a per-character basis.
  # Note that due the high number of times this gets
  # called, it has been fairly heavily in-lined, so the code
  # might look a bit ugly and duplicated.
  sub _process_next_char {
  	my $self = shift;
  
  	### FIXME - This checks for a screwed up condition that triggers
  	###         several warnings, amongst other things.
  	if ( ! defined $self->{line_cursor} or ! defined $self->{line_length} ) {
  		# $DB::single = 1;
  		return undef;
  	}
  
  	# Increment the counter and check for end of line
  	return 0 if ++$self->{line_cursor} >= $self->{line_length};
  
  	# Pass control to the token class
  	my $result;
  	unless ( $result = $self->{class}->__TOKENIZER__on_char( $self ) ) {
  		# undef is error. 0 is "Did stuff ourself, you don't have to do anything"
  		return defined $result ? 1 : undef;
  	}
  
  	# We will need the value of the current character
  	my $char = substr( $self->{line}, $self->{line_cursor}, 1 );
  	if ( $result eq '1' ) {
  		# If __TOKENIZER__on_char returns 1, it is signaling that it thinks that
  		# the character is part of it.
  
  		# Add the character
  		if ( defined $self->{token} ) {
  			$self->{token}->{content} .= $char;
  		} else {
  			defined($self->{token} = $self->{class}->new($char)) or return undef;
  		}
  
  		return 1;
  	}
  
  	# We have been provided with the name of a class
  	if ( $self->{class} ne "PPI::Token::$result" ) {
  		# New class
  		$self->_new_token( $result, $char );
  	} elsif ( defined $self->{token} ) {
  		# Same class as current
  		$self->{token}->{content} .= $char;
  	} else {
  		# Same class, but no current
  		defined($self->{token} = $self->{class}->new($char)) or return undef;
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Altering Tokens in Tokenizer
  
  # Finish the end of a token.
  # Returns the resulting parse class as a convenience.
  sub _finalize_token {
  	my $self = shift;
  	return $self->{class} unless defined $self->{token};
  
  	# Add the token to the token buffer
  	push @{ $self->{tokens} }, $self->{token};
  	$self->{token} = undef;
  
  	# Return the parse class to that of the zone we are in
  	$self->{class} = $self->{zone};
  }
  
  # Creates a new token and sets it in the tokenizer
  # The defined() in here prevent a ton of calls to PPI::Util::TRUE
  sub _new_token {
  	my $self = shift;
  	# throw PPI::Exception() unless @_;
  	my $class = substr( $_[0], 0, 12 ) eq 'PPI::Token::'
  		? shift : 'PPI::Token::' . shift;
  
  	# Finalize any existing token
  	$self->_finalize_token if defined $self->{token};
  
  	# Create the new token and update the parse class
  	defined($self->{token} = $class->new($_[0])) or PPI::Exception->throw;
  	$self->{class} = $class;
  
  	1;
  }
  
  # At the end of the file, we need to clean up the results of the erroneous
  # space that we inserted at the beginning of the process.
  sub _clean_eof {
  	my $self = shift;
  
  	# Finish any partially completed token
  	$self->_finalize_token if $self->{token};
  
  	# Find the last token, and if it has no content, kill it.
  	# There appears to be some evidence that such "null tokens" are
  	# somehow getting created accidentally.
  	my $last_token = $self->{tokens}->[ -1 ];
  	unless ( length $last_token->{content} ) {
  		pop @{$self->{tokens}};
  	}
  
  	# Now, if the last character of the last token is a space we added,
  	# chop it off, deleting the token if there's nothing else left.
  	if ( $self->{source_eof_chop} ) {
  		$last_token = $self->{tokens}->[ -1 ];
  		$last_token->{content} =~ s/ $//;
  		unless ( length $last_token->{content} ) {
  			# Popping token
  			pop @{$self->{tokens}};
  		}
  
  		# The hack involving adding an extra space is now reversed, and
  		# now nobody will ever know. The perfect crime!
  		$self->{source_eof_chop} = '';
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Utility Methods
  
  # Context
  sub _last_token {
  	$_[0]->{tokens}->[-1];
  }
  
  sub _last_significant_token {
  	my $self   = shift;
  	my $cursor = $#{ $self->{tokens} };
  	while ( $cursor >= 0 ) {
  		my $token = $self->{tokens}->[$cursor--];
  		return $token if $token->significant;
  	}
  	return;
  }
  
  # Get an array ref of previous significant tokens.
  # Like _last_significant_token except it gets more than just one token
  # Returns array with 0 to x entries
  sub _previous_significant_tokens {
  	my $self   = shift;
  	my $count  = shift || 1;
  	my $cursor = $#{ $self->{tokens} };
  
  	my @tokens;
  	while ( $cursor >= 0 ) {
  		my $token = $self->{tokens}->[$cursor--];
  		next if not $token->significant;
  		push @tokens, $token;
  		last if @tokens >= $count;
  	}
  
  	return @tokens;
  }
  
  my %OBVIOUS_CLASS = (
  	'PPI::Token::Symbol'              => 'operator',
  	'PPI::Token::Magic'               => 'operator',
  	'PPI::Token::Number'              => 'operator',
  	'PPI::Token::ArrayIndex'          => 'operator',
  	'PPI::Token::Quote::Double'       => 'operator',
  	'PPI::Token::Quote::Interpolate'  => 'operator',
  	'PPI::Token::Quote::Literal'      => 'operator',
  	'PPI::Token::Quote::Single'       => 'operator',
  	'PPI::Token::QuoteLike::Backtick' => 'operator',
  	'PPI::Token::QuoteLike::Command'  => 'operator',
  	'PPI::Token::QuoteLike::Readline' => 'operator',
  	'PPI::Token::QuoteLike::Regexp'   => 'operator',
  	'PPI::Token::QuoteLike::Words'    => 'operator',
  );
  
  my %OBVIOUS_CONTENT = (
  	'(' => 'operand',
  	'{' => 'operand',
  	'[' => 'operand',
  	';' => 'operand',
  	'}' => 'operator',
  );
  
  
  my %USUALLY_FORCES = map { $_ => 1 } qw( sub package use no );
  
  # Try to determine operator/operand context, if possible.
  # Returns "operator", "operand", or "" if unknown.
  sub _opcontext {
  	my $self   = shift;
  	my @tokens = $self->_previous_significant_tokens(1);
  	my $p0     = $tokens[0];
  	return '' if not $p0;
  	my $c0     = ref $p0;
  
  	# Map the obvious cases
  	return $OBVIOUS_CLASS{$c0}   if defined $OBVIOUS_CLASS{$c0};
  	return $OBVIOUS_CONTENT{$p0} if defined $OBVIOUS_CONTENT{$p0};
  
  	# Most of the time after an operator, we are an operand
  	return 'operand' if $p0->isa('PPI::Token::Operator');
  
  	# If there's NOTHING, it's operand
  	return 'operand' if $p0->content eq '';
  
  	# Otherwise, we don't know
  	return ''
  }
  
  # Assuming we are currently parsing the word 'x', return true
  # if previous tokens imply the x is an operator, false otherwise.
  sub _current_x_is_operator {
  	my ( $self ) = @_;
  	return if !@{$self->{tokens}};
  
  	my ($prev, $prevprev) = $self->_previous_significant_tokens(2);
  	return if !$prev;
  
  	return !$self->__current_token_is_forced_word if $prev->isa('PPI::Token::Word');
  
  	return (!$prev->isa('PPI::Token::Operator') || $X_CAN_FOLLOW_OPERATOR{$prev})
  		&& (!$prev->isa('PPI::Token::Structure') || $X_CAN_FOLLOW_STRUCTURE{$prev})
  		&& !$prev->isa('PPI::Token::Label')
  	;
  }
  
  
  # Assuming we are at the end of parsing the current token that could be a word,
  # a wordlike operator, or a version string, try to determine whether context
  # before or after it forces it to be a bareword. This method is only useful
  # during tokenization.
  sub __current_token_is_forced_word {
  	my ( $t, $word ) = @_;
  
  	# Check if forced by preceding tokens.
  
  	my ( $prev, $prevprev ) = $t->_previous_significant_tokens(2);
  	if ( !$prev ) {
  		pos $t->{line} = $t->{line_cursor};
  	}
  	else {
  		my $content = $prev->{content};
  
  		# We are forced if we are a method name.
  		# '->' will always be an operator, so we don't check its type.
  		return 1 if $content eq '->';
  
  		# If we are contained in a pair of curly braces, we are probably a
  		# forced bareword hash key. '{' is never a word or operator, so we
  		# don't check its type.
  		pos $t->{line} = $t->{line_cursor};
  		return 1 if $content eq '{' and $t->{line} =~ /\G\s*\}/gc;
  
  		# sub, package, use, and no all indicate that what immediately follows
  		# is a word not an operator or (in the case of sub and package) a
  		# version string.  However, we don't want to be fooled by 'package
  		# package v10' or 'use no v10'. We're a forced package unless we're
  		# preceded by 'package sub', in which case we're a version string.
  		# We also have to make sure that the sub/package/etc doing the forcing
  		# is not a method call.
  		if( $USUALLY_FORCES{$content}) {
  			return if defined $word and $word =~ /^v[0-9]+$/ and ( $content eq "use" or $content eq "no" );
  			return 1 if not $prevprev;
  			return 1 if not $USUALLY_FORCES{$prevprev->content} and $prevprev->content ne '->';
  			return;
  		}
  	}
  	# pos on $t->{line} is guaranteed to be set at this point.
  
  	# Check if forced by following tokens.
  
  	# If the word is followed by => it is probably a word, not a regex.
  	return 1 if $t->{line} =~ /\G\s*=>/gc;
  
  	# Otherwise we probably aren't forced
  	return '';
  }
  
  1;
  
  =pod
  
  =head1 NOTES
  
  =head2 How the Tokenizer Works
  
  Understanding the Tokenizer is not for the faint-hearted. It is by far
  the most complex and twisty piece of perl I've ever written that is actually
  still built properly and isn't a terrible spaghetti-like mess. In fact, you
  probably want to skip this section.
  
  But if you really want to understand, well then here goes.
  
  =head2 Source Input and Clean Up
  
  The Tokenizer starts by taking source in a variety of forms, sucking it
  all in and merging into one big string, and doing our own internal line
  split, using a "universal line separator" which allows the Tokenizer to
  take source for any platform (and even supports a few known types of
  broken newlines caused by mixed mac/pc/*nix editor screw ups).
  
  The resulting array of lines is used to feed the tokenizer, and is also
  accessed directly by the heredoc-logic to do the line-oriented part of
  here-doc support.
  
  =head2 Doing Things the Old Fashioned Way
  
  Due to the complexity of perl, and after 2 previously aborted parser
  attempts, in the end the tokenizer was fashioned around a line-buffered
  character-by-character method.
  
  That is, the Tokenizer pulls and holds a line at a time into a line buffer,
  and then iterates a cursor along it. At each cursor position, a method is
  called in whatever token class we are currently in, which will examine the
  character at the current position, and handle it.
  
  As the handler methods in the various token classes are called, they
  build up an output token array for the source code.
  
  Various parts of the Tokenizer use look-ahead, arbitrary-distance
  look-behind (although currently the maximum is three significant tokens),
  or both, and various other heuristic guesses.
  
  I've been told it is officially termed a I<"backtracking parser
  with infinite lookaheads">.
  
  =head2 State Variables
  
  Aside from the current line and the character cursor, the Tokenizer
  maintains a number of different state variables.
  
  =over
  
  =item Current Class
  
  The Tokenizer maintains the current token class at all times. Much of the
  time is just going to be the "Whitespace" class, which is what the base of
  a document is. As the tokenizer executes the various character handlers,
  the class changes a lot as it moves a long. In fact, in some instances,
  the character handler may not handle the character directly itself, but
  rather change the "current class" and then hand off to the character
  handler for the new class.
  
  Because of this, and some other things I'll deal with later, the number of
  times the character handlers are called does not in fact have a direct
  relationship to the number of actual characters in the document.
  
  =item Current Zone
  
  Rather than create a class stack to allow for infinitely nested layers of
  classes, the Tokenizer recognises just a single layer.
  
  To put it a different way, in various parts of the file, the Tokenizer will
  recognise different "base" or "substrate" classes. When a Token such as a
  comment or a number is finalised by the tokenizer, it "falls back" to the
  base state.
  
  This allows proper tokenization of special areas such as __DATA__
  and __END__ blocks, which also contain things like comments and POD,
  without allowing the creation of any significant Tokens inside these areas.
  
  For the main part of a document we use L<PPI::Token::Whitespace> for this,
  with the idea being that code is "floating in a sea of whitespace".
  
  =item Current Token
  
  The final main state variable is the "current token". This is the Token
  that is currently being built by the Tokenizer. For certain types, it
  can be manipulated and morphed and change class quite a bit while being
  assembled, as the Tokenizer's understanding of the token content changes.
  
  When the Tokenizer is confident that it has seen the end of the Token, it
  will be "finalized", which adds it to the output token array and resets
  the current class to that of the zone that we are currently in.
  
  I should also note at this point that the "current token" variable is
  optional. The Tokenizer is capable of knowing what class it is currently
  set to, without actually having accumulated any characters in the Token.
  
  =back
  
  =head2 Making It Faster
  
  As I'm sure you can imagine, calling several different methods for each
  character and running regexes and other complex heuristics made the first
  fully working version of the tokenizer extremely slow.
  
  During testing, I created a metric to measure parsing speed called
  LPGC, or "lines per gigacycle" . A gigacycle is simple a billion CPU
  cycles on a typical single-core CPU, and so a Tokenizer running at
  "1000 lines per gigacycle" should generate around 1200 lines of tokenized
  code when running on a 1200 MHz processor.
  
  The first working version of the tokenizer ran at only 350 LPGC, so to
  tokenize a typical large module such as L<ExtUtils::MakeMaker> took
  10-15 seconds. This sluggishness made it unpractical for many uses.
  
  So in the current parser, there are multiple layers of optimisation
  very carefully built in to the basic. This has brought the tokenizer
  up to a more reasonable 1000 LPGC, at the expense of making the code
  quite a bit twistier.
  
  =head2 Making It Faster - Whole Line Classification
  
  The first step in the optimisation process was to add a hew handler to
  enable several of the more basic classes (whitespace, comments) to be
  able to be parsed a line at a time. At the start of each line, a
  special optional handler (only supported by a few classes) is called to
  check and see if the entire line can be parsed in one go.
  
  This is used mainly to handle things like POD, comments, empty lines,
  and a few other minor special cases.
  
  =head2 Making It Faster - Inlining
  
  The second stage of the optimisation involved inlining a small
  number of critical methods that were repeated an extremely high number
  of times. Profiling suggested that there were about 1,000,000 individual
  method calls per gigacycle, and by cutting these by two thirds a significant
  speed improvement was gained, in the order of about 50%.
  
  You may notice that many methods in the C<PPI::Tokenizer> code look
  very nested and long hand. This is primarily due to this inlining.
  
  At around this time, some statistics code that existed in the early
  versions of the parser was also removed, as it was determined that
  it was consuming around 15% of the CPU for the entire parser, while
  making the core more complicated.
  
  A judgment call was made that with the difficulties likely to be
  encountered with future planned enhancements, and given the relatively
  high cost involved, the statistics features would be removed from the
  Tokenizer.
  
  =head2 Making It Faster - Quote Engine
  
  Once inlining had reached diminishing returns, it became obvious from
  the profiling results that a huge amount of time was being spent
  stepping a char at a time though long, simple and "syntactically boring"
  code such as comments and strings.
  
  The existing regex engine was expanded to also encompass quotes and
  other quote-like things, and a special abstract base class was added
  that provided a number of specialised parsing methods that would "scan
  ahead", looking out ahead to find the end of a string, and updating
  the cursor to leave it in a valid position for the next call.
  
  This is also the point at which the number of character handler calls began
  to greatly differ from the number of characters. But it has been done
  in a way that allows the parser to retain the power of the original
  version at the critical points, while skipping through the "boring bits"
  as needed for additional speed.
  
  The addition of this feature allowed the tokenizer to exceed 1000 LPGC
  for the first time.
  
  =head2 Making It Faster - The "Complete" Mechanism
  
  As it became evident that great speed increases were available by using
  this "skipping ahead" mechanism, a new handler method was added that
  explicitly handles the parsing of an entire token, where the structure
  of the token is relatively simple. Tokens such as symbols fit this case,
  as once we are passed the initial sigil and word char, we know that we
  can skip ahead and "complete" the rest of the token much more easily.
  
  A number of these have been added for most or possibly all of the common
  cases, with most of these "complete" handlers implemented using regular
  expressions.
  
  In fact, so many have been added that at this point, you could arguably
  reclassify the tokenizer as a "hybrid regex, char-by=char heuristic
  tokenizer". More tokens are now consumed in "complete" methods in a
  typical program than are handled by the normal char-by-char methods.
  
  Many of the these complete-handlers were implemented during the writing
  of the Lexer, and this has allowed the full parser to maintain around
  1000 LPGC despite the increasing weight of the Lexer.
  
  =head2 Making It Faster - Porting To C (In Progress)
  
  While it would be extraordinarily difficult to port all of the Tokenizer
  to C, work has started on a L<PPI::XS> "accelerator" package which acts as
  a separate and automatically-detected add-on to the main PPI package.
  
  L<PPI::XS> implements faster versions of a variety of functions scattered
  over the entire PPI codebase, from the Tokenizer Core, Quote Engine, and
  various other places, and implements them identically in XS/C.
  
  In particular, the skip-ahead methods from the Quote Engine would appear
  to be extremely amenable to being done in C, and a number of other
  functions could be cherry-picked one at a time and implemented in C.
  
  Each method is heavily tested to ensure that the functionality is
  identical, and a versioning mechanism is included to ensure that if a
  function gets out of sync, L<PPI::XS> will degrade gracefully and just
  not replace that single method.
  
  =head1 TO DO
  
  - Add an option to reset or seek the token stream...
  
  - Implement more Tokenizer functions in L<PPI::XS>
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;
  
  =pod
  
  =head1 NAME
  
  PPI::Transform - Abstract base class for document transformation classes
  
  =head1 DESCRIPTION
  
  C<PPI::Transform> provides an API for the creation of classes and objects
  that modify or transform PPI documents.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp          ();
  use List::Util    ();
  use PPI::Document ();
  use Params::Util  qw{_INSTANCE _CLASS _CODE _SCALAR0};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Apply Handler Registration
  
  my %HANDLER;
  my @ORDER;
  
  # Yes, you can use this yourself.
  # I'm just leaving it undocumented for now.
  sub register_apply_handler {
  	my $class   = shift;
  	my $handler = _CLASS(shift) or Carp::croak("Invalid PPI::Transform->register_apply_handler param");
  	my $get     = _CODE(shift)  or Carp::croak("Invalid PPI::Transform->register_apply_handler param");
  	my $set     = _CODE(shift)  or Carp::croak("Invalid PPI::Transform->register_apply_handler param");
  	if ( $HANDLER{$handler} ) {
  		Carp::croak("PPI::Transform->apply handler '$handler' already exists");
  	}
  
  	# Register the handler
  	$HANDLER{$handler} = [ $get, $set ];
  	unshift @ORDER, $handler;
  }
  
  # Register the default handlers
  __PACKAGE__->register_apply_handler( 'SCALAR', \&_SCALAR_get, \&_SCALAR_set );
  __PACKAGE__->register_apply_handler( 'PPI::Document', sub { $_[0] }, sub() { 1 } );
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new
  
    my $transform = PPI::Transform->new(
        param1 => 'value1',
        param2 => 'value2',
    );
  
  The C<new> constructor creates a new object for your C<PPI::Transform>
  subclass. A default constructor is provided for you which takes no params
  and creates a basic, empty, object.
  
  If you wish to have your transform constructor take params, these B<must>
  be in the form of a list of key/value pairs.
  
  Returns a new C<PPI::Transform>-compatible object, or returns
  C<undef> on error.
  
  =cut
  
  sub new {
  	my $class = shift;
  	bless { @_ }, $class;
  }
  
  =pod
  
  =head2 document
  
  The C<document> method should be implemented by each subclass, and
  takes a single argument of a L<PPI::Document> object, modifying it
  B<in place> as appropriate for the particular transform class.
  
  That's right, this method B<will not clone> and B<should not clone>
  the document object. If you do not want the original to be modified,
  you need to clone it yourself before passing it in.
  
  Returns the numbers of changes made to the document. If the transform
  is unable to track the quantity (including the situation where it cannot
  tell B<IF> it made a change) it should return 1. Returns zero if no
  changes were made to the document, or C<undef> if an error occurs.
  
  By default this error is likely to only mean that you passed in something
  that wasn't a L<PPI::Document>, but may include additional errors
  depending on the subclass.
  
  =cut
  
  sub document {
  	my $class = shift;
  	die "$class does not implement the required ->document method";
  }
  
  =pod
  
  =head2 apply
  
  The C<apply> method is used to apply the transform to something. The
  argument must be a L<PPI::Document>, or something which can be turned
  into one and then be written back to again.
  
  Currently, this list is limited to a C<SCALAR> reference, although a
  handler registration process is available for you to add support for
  additional types of object should you wish (see the source for this module).
  
  Returns true if the transform was applied, false if there is an error in the
  transform process, or may die if there is a critical error in the apply
  handler.
  
  =cut
  
  sub apply {
  	my $self = _SELF(shift);
  	my $it   = defined $_[0] ? shift : return undef;
  
  	# Try to find an apply handler
  	my $class = _SCALAR0($it) ? 'SCALAR'
  		: List::Util::first { _INSTANCE($it, $_) } @ORDER
  		or return undef;
  	my $handler = $HANDLER{$class}
  		or die("->apply handler for $class missing! Panic");
  
  	# Get, change, set
  	my $Document = _INSTANCE($handler->[0]->($it), 'PPI::Document')
  		or Carp::croak("->apply handler for $class failed to get a PPI::Document");
  	$self->document( $Document ) or return undef;
  	$handler->[1]->($it, $Document)
  		or Carp::croak("->apply handler for $class failed to save the changed document");
  	1;		
  }
  
  =pod
  
  =head2 file
  
    # Read from one file and write to another
    $transform->file( 'Input.pm' => 'Output.pm' );
    
    # Change a file in place
    $transform->file( 'Change.pm' );
  
  The C<file> method modifies a Perl document by filename. If passed a single
  parameter, it modifies the file in-place. If provided a second parameter,
  it will attempt to save the modified file to the alternative filename.
  
  Returns true on success, or C<undef> on error.
  
  =cut
  
  sub file {
  	my $self = _SELF(shift);
  
  	# Where do we read from and write to
  	my $input  = defined $_[0] ? shift : return undef;
  	my $output = @_ ? defined $_[0] ? "$_[0]" : undef : $input or return undef;
  
  	# Process the file
  	my $Document = PPI::Document->new( "$input" ) or return undef;
  	$self->document( $Document )                  or return undef;
  	$Document->save( $output );
  }
  
  
  
  
  
  #####################################################################
  # Apply Hander Methods
  
  sub _SCALAR_get {
  	PPI::Document->new( $_[0] );
  }
  
  sub _SCALAR_set {
  	my $it = shift;
  	$$it = $_[0]->serialize;
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Support Functions
  
  sub _SELF {
  	return shift if ref $_[0];
  	my $self = $_[0]->new or Carp::croak(
  		"Failed to auto-instantiate new $_[0] object"
  	);
  	$self;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;
  
  =pod
  
  =head1 NAME
  
  PPI::Transform::UpdateCopyright - Demonstration PPI::Transform class
  
  =head1 SYNOPSIS
  
    my $transform = PPI::Transform::UpdateCopyright->new(
        name => 'Adam Kennedy'
    );
    
    $transform->file('Module.pm');
  
  =head1 DESCRIPTION
  
  B<PPI::Transform::UpdateCopyright> provides a demonstration of a typical
  L<PPI::Transform> class.
  
  This class implements a document transform that will take the name of an
  author and update the copyright statement to refer to the current year,
  if it does not already do so.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util   qw{_STRING};
  use PPI::Transform ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $transform = PPI::Transform::UpdateCopyright->new(
        name => 'Adam Kennedy'
    );
  
  The C<new> constructor creates a new transform object for a specific
  author. It takes a single C<name> parameter that should be the name
  (or longer string) for the author.
  
  Specifying the name is required to allow the changing of a subset of
  copyright statements that refer to you from a larger set in a file.
  
  =cut
  
  sub new {
  	my $self = shift->SUPER::new(@_);
  
  	# Must provide a name
  	unless ( defined _STRING($self->name) ) {
  		PPI::Exception->throw("Did not provide a valid name param");
  	}
  
  	return $self;
  }
  
  =pod
  
  =head2 name
  
  The C<name> accessor returns the author name that the transform will be
  searching for copyright statements of.
  
  =cut
  
  sub name {
  	$_[0]->{name};
  }
  
  
  
  
  
  #####################################################################
  # Transform
  
  sub document {
  	my $self     = shift;
  	my $document = _INSTANCE(shift, 'PPI::Document') or return undef;
  
  	# Find things to transform
  	my $name     = quotemeta $self->name;
  	my $regexp   = qr/\bcopyright\b.*$name/m;
  	my $elements = $document->find( sub {
  		$_[1]->isa('PPI::Token::Pod') or return '';
  		$_[1]->content =~ $regexp     or return '';
  		return 1;
  	} );
  	return undef unless defined $elements;
  	return 0 unless $elements;
  
  	# Try to transform any elements
  	my $changes = 0;
  	my $change  = sub {
  		my $copyright = shift;
  		my $thisyear  = (localtime time)[5] + 1900;
  		my @year      = $copyright =~ m/(\d{4})/g;
  
  		if ( @year == 1 ) {
  			# Handle the single year format
  			if ( $year[0] == $thisyear ) {
  				# No change
  				return $copyright;
  			} else {
  				# Convert from single year to multiple year
  				$changes++;
  				$copyright =~ s/(\d{4})/$1 - $thisyear/;
  				return $copyright;
  			}
  		}
  
  		if ( @year == 2 ) {
  			# Handle the range format
  			if ( $year[1] == $thisyear ) {
  				# No change
  				return $copyright;
  			} else {
  				# Change the second year to the current one
  				$changes++;
  				$copyright =~ s/$year[1]/$thisyear/;
  				return $copyright;
  			}
  		}
  
  		# huh?
  		die "Invalid or unknown copyright line '$copyright'";
  	};
  
  	# Attempt to transform each element
  	my $pattern = qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;
  	foreach my $element ( @$elements ) {
  		$element =~ s/$pattern/$1 . $change->($2) . $2/eg;
  	}
  
  	return $changes;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - May need to overload some methods to forcefully prevent Document
  objects becoming children of another Node.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;
  
  # Provides some common utility functions that can be imported
  
  use strict;
  use Exporter     ();
  use Digest::MD5  ();
  use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};
  
  use vars qw{$VERSION @ISA @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.236';
  	@ISA       = 'Exporter';
  	@EXPORT_OK = qw{_Document _slurp};
  }
  
  # 5.8.7 was the first version to resolve the notorious
  # "unicode length caching" bug.
  use constant HAVE_UNICODE => !! ( $] >= 5.008007 );
  
  # Common reusable true and false functions
  # This makes it easy to upgrade many places in PPI::XS
  sub TRUE  () { 1  }
  sub FALSE () { '' }
  
  
  
  
  
  #####################################################################
  # Functions
  
  # Allows a sub that takes a L<PPI::Document> to handle the full range
  # of different things, including file names, SCALAR source, etc.
  sub _Document {
  	shift if @_ > 1;
  	return undef unless defined $_[0];
  	require PPI::Document;
  	return PPI::Document->new(shift) unless ref $_[0];
  	return PPI::Document->new(shift) if _SCALAR0($_[0]);
  	return PPI::Document->new(shift) if _ARRAY0($_[0]);
  	return shift if _INSTANCE($_[0], 'PPI::Document');
  	return undef;
  }
  
  # Provide a simple _slurp implementation
  sub _slurp {
  	my $file = shift;
  	local $/ = undef;
  	local *FILE;
  	open( FILE, '<', $file ) or return "open($file) failed: $!";
  	my $source = <FILE>;
  	close( FILE ) or return "close($file) failed: $!";
  	return \$source;
  }
  
  # Provides a version of Digest::MD5's md5hex that explicitly
  # works on the unix-newlined version of the content.
  sub md5hex {
  	my $string = shift;
  	$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;
  	Digest::MD5::md5_hex($string);
  }
  
  # As above but slurps and calculates the id for a file by name
  sub md5hex_file {
  	my $file    = shift;
  	my $content = _slurp($file);
  	return undef unless ref $content;
  	$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;
  	md5hex($$content);
  }
  
  1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;
  
  # This is an experimental prototype, use at your own risk.
  # Provides optional enhancement of PPI with Class::XSAccessor (if installed)
  
  use 5.006;
  use strict;
  use PPI ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  ######################################################################
  # Replacement Methods
  
  # Packages are implemented here in alphabetical order
  
  package #hide from indexer
  	PPI::Document;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		readonly => 'readonly',
  	},
  	true    => [
  		'scope'
  	];
  
  package #hide from indexer
  	PPI::Document::File;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		filename => 'filename',
  	};
  
  package #hide from indexer
  	PPI::Document::Fragment;
  
  use Class::XSAccessor
  	replace => 1,
  	false   => [
  		'scope',
  	];
  
  package #hide from indexer
  	PPI::Document::Normalized;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		'_Document' => 'Document',
  		'version'   => 'version',
  		'functions' => 'functions',
  	};
  
  package #hide from indexer
  	PPI::Element;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'significant',
  	];
  
  package #hide from indexer
  	PPI::Exception;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		message => 'message',
  	};
  
  package #hide from indexer
  	PPI::Node;
  
  use Class::XSAccessor
  	replace => 1,
  	false   => [
  		'scope',
  	];
  
  package #hide from indexer
  	PPI::Normal;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		'layer' => 'layer',
  	};
  
  package #hide from indexer
  	PPI::Statement;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'__LEXER__normal',
  	];
  
  package #hide from indexer
  	PPI::Statement::Compound;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'scope',
  	],
  	false   => [
  		'__LEXER__normal',
  	];
  
  package #hide from indexer
  	PPI::Statement::Data;
  
  use Class::XSAccessor
  	replace => 1,
  	false   => [
  		'_complete',
  	];
  
  package #hide from indexer
  	PPI::Statement::End;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'_complete',
  	];
  
  package #hide from indexer
  	PPI::Statement::Given;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'scope',
  	],
  	false   => [
  		'__LEXER__normal',
  	];
  
  package #hide from indexer
  	PPI::Token;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		content => 'content',
  	},
  	setters => {
  		set_content => 'content',
  	},
  	true => [
  		'__TOKENIZER__on_line_start',
  		'__TOKENIZER__on_line_end',
  	];
  
  1;
PPI_XSACCESSOR

$fatpacked{"Perl/Critic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC';
  package Perl::Critic;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use Exporter 'import';
  
  use File::Spec;
  use List::MoreUtils qw< firstidx >;
  use Scalar::Util qw< blessed >;
  
  use Perl::Critic::Exception::Configuration::Generic;
  use Perl::Critic::Config;
  use Perl::Critic::Violation;
  use Perl::Critic::Document;
  use Perl::Critic::Statistics;
  use Perl::Critic::Utils qw< :characters hashify shebang_line >;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  Readonly::Array our @EXPORT_OK => qw(critique);
  
  #=============================================================================
  # PUBLIC methods
  
  sub new {
      my ( $class, %args ) = @_;
      my $self = bless {}, $class;
      $self->{_config} = $args{-config} || Perl::Critic::Config->new( %args );
      $self->{_stats} = Perl::Critic::Statistics->new();
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub config {
      my $self = shift;
      return $self->{_config};
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_policy {
      my ( $self, @args ) = @_;
      #Delegate to Perl::Critic::Config
      return $self->config()->add_policy( @args );
  }
  
  #-----------------------------------------------------------------------------
  
  sub policies {
      my $self = shift;
  
      #Delegate to Perl::Critic::Config
      return $self->config()->policies();
  }
  
  #-----------------------------------------------------------------------------
  
  sub statistics {
      my $self = shift;
      return $self->{_stats};
  }
  
  #-----------------------------------------------------------------------------
  
  sub critique {  ## no critic (ArgUnpacking)
  
      #-------------------------------------------------------------------
      # This subroutine can be called as an object method or as a static
      # function.  In the latter case, the first argument can be a
      # hashref of configuration parameters that shall be used to create
      # an object behind the scenes.  Note that this object does not
      # persist.  In other words, it is not a singleton.  Here are some
      # of the ways this subroutine might get called:
      #
      # #Object style...
      # $critic->critique( $code );
      #
      # #Functional style...
      # critique( $code );
      # critique( {}, $code );
      # critique( {-foo => bar}, $code );
      #------------------------------------------------------------------
  
      my ( $self, $source_code ) = @_ >= 2 ? @_ : ( {}, $_[0] );
      $self = ref $self eq 'HASH' ? __PACKAGE__->new(%{ $self }) : $self;
      return if not defined $source_code;  # If no code, then nothing to do.
  
      my $config = $self->config();
      my $doc =
          blessed($source_code) && $source_code->isa('Perl::Critic::Document')
              ? $source_code
              : Perl::Critic::Document->new(
                  '-source' => $source_code,
                  '-program-extensions' => [$config->program_extensions_as_regexes()],
              );
  
      if ( 0 == $self->policies() ) {
          Perl::Critic::Exception::Configuration::Generic->throw(
              message => 'There are no enabled policies.',
          )
      }
  
      return $self->_gather_violations($doc);
  }
  
  #=============================================================================
  # PRIVATE methods
  
  sub _gather_violations {
      my ($self, $doc) = @_;
  
      # Disable exempt code lines, if desired
      if ( not $self->config->force() ) {
          $doc->process_annotations();
      }
  
      # Evaluate each policy
      my @policies = $self->config->policies();
      my @ordered_policies = _futz_with_policy_order(@policies);
      my @violations = map { _critique($_, $doc) } @ordered_policies;
  
      # Accumulate statistics
      $self->statistics->accumulate( $doc, \@violations );
  
      # If requested, rank violations by their severity and return the top N.
      if ( @violations && (my $top = $self->config->top()) ) {
          my $limit = @violations < $top ? $#violations : $top-1;
          @violations = Perl::Critic::Violation::sort_by_severity(@violations);
          @violations = ( reverse @violations )[ 0 .. $limit ];  #Slicing...
      }
  
      # Always return violations sorted by location
      return Perl::Critic::Violation->sort_by_location(@violations);
  }
  
  #=============================================================================
  # PRIVATE functions
  
  sub _critique {
      my ($policy, $doc) = @_;
  
      return if not $policy->prepare_to_scan_document($doc);
  
      my $maximum_violations = $policy->get_maximum_violations_per_document();
      return if defined $maximum_violations && $maximum_violations == 0;
  
      my @violations = ();
  
    TYPE:
      for my $type ( $policy->applies_to() ) {
          my @elements;
          if ($type eq 'PPI::Document') {
              @elements = ($doc);
          }
          else {
              @elements = @{ $doc->find($type) || [] };
          }
  
        ELEMENT:
          for my $element (@elements) {
  
              # Evaluate the policy on this $element.  A policy may
              # return zero or more violations.  We only want the
              # violations that occur on lines that have not been
              # disabled.
  
            VIOLATION:
              for my $violation ( $policy->violates( $element, $doc ) ) {
  
                  my $line = $violation->location()->[0];
                  if ( $doc->line_is_disabled_for_policy($line, $policy) ) {
                      $doc->add_suppressed_violation($violation);
                      next VIOLATION;
                  }
  
                  push @violations, $violation;
                  last TYPE if defined $maximum_violations and @violations >= $maximum_violations;
              }
          }
      }
  
      return @violations;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _futz_with_policy_order {
      # The ProhibitUselessNoCritic policy is another special policy.  It
      # deals with the violations that *other* Policies produce.  Therefore
      # it needs to be run *after* all the other Policies.  TODO: find
      # a way for Policies to express an ordering preference somehow.
  
      my @policy_objects = @_;
      my $magical_policy_name = 'Perl::Critic::Policy::Miscellanea::ProhibitUselessNoCritic';
      my $idx = firstidx {ref $_ eq $magical_policy_name} @policy_objects;
      push @policy_objects, splice @policy_objects, $idx, 1;
      return @policy_objects;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  
  
  __END__
  
  =pod
  
  =for stopwords DGR INI-style API -params pbp refactored ActivePerl ben Jore
  Dolan's Twitter Alexandr Ciornii Ciornii's downloadable
  
  =head1 NAME
  
  Perl::Critic - Critique Perl source code for best-practices.
  
  
  =head1 SYNOPSIS
  
      use Perl::Critic;
      my $file = shift;
      my $critic = Perl::Critic->new();
      my @violations = $critic->critique($file);
      print @violations;
  
  
  =head1 DESCRIPTION
  
  Perl::Critic is an extensible framework for creating and applying coding
  standards to Perl source code.  Essentially, it is a static source code
  analysis engine.  Perl::Critic is distributed with a number of
  L<Perl::Critic::Policy> modules that attempt to enforce various coding
  guidelines.  Most Policy modules are based on Damian Conway's book B<Perl Best
  Practices>.  However, Perl::Critic is B<not> limited to PBP and will even
  support Policies that contradict Conway.  You can enable, disable, and
  customize those Polices through the Perl::Critic interface.  You can also
  create new Policy modules that suit your own tastes.
  
  For a command-line interface to Perl::Critic, see the documentation for
  L<perlcritic>.  If you want to integrate Perl::Critic with your build process,
  L<Test::Perl::Critic> provides an interface that is suitable for test
  programs.  Also, L<Test::Perl::Critic::Progressive> is useful for gradually
  applying coding standards to legacy code.  For the ultimate convenience (at
  the expense of some flexibility) see the L<criticism> pragma.
  
  If you'd like to try L<Perl::Critic> without installing anything, there is a
  web-service available at L<http://perlcritic.com>.  The web-service does not
  yet support all the configuration features that are available in the native
  Perl::Critic API, but it should give you a good idea of what it does.
  
  Also, ActivePerl includes a very slick graphical interface to Perl-Critic
  called C<perlcritic-gui>.  You can get a free community edition of ActivePerl
  from L<http://www.activestate.com>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface will go
  through a deprecation cycle.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new( [ -profile => $FILE, -severity => $N, -theme => $string, -include => \@PATTERNS, -exclude => \@PATTERNS, -top => $N, -only => $B, -profile-strictness => $PROFILE_STRICTNESS_{WARN|FATAL|QUIET}, -force => $B, -verbose => $N ], -color => $B, -pager => $string, -allow-unsafe => $B, -criticism-fatal => $B) >>
  
  =item C<< new() >>
  
  Returns a reference to a new Perl::Critic object.  Most arguments are just
  passed directly into L<Perl::Critic::Config>, but I have described them here
  as well.  The default value for all arguments can be defined in your
  F<.perlcriticrc> file.  See the L<"CONFIGURATION"> section for more
  information about that.  All arguments are optional key-value pairs as
  follows:
  
  B<-profile> is a path to a configuration file. If C<$FILE> is not defined,
  Perl::Critic::Config attempts to find a F<.perlcriticrc> configuration file in
  the current directory, and then in your home directory.  Alternatively, you
  can set the C<PERLCRITIC> environment variable to point to a file in another
  location.  If a configuration file can't be found, or if C<$FILE> is an empty
  string, then all Policies will be loaded with their default configuration.
  See L<"CONFIGURATION"> for more information.
  
  B<-severity> is the minimum severity level.  Only Policy modules that have a
  severity greater than C<$N> will be applied.  Severity values are integers
  ranging from 1 (least severe violations) to 5 (most severe violations).  The
  default is 5.  For a given C<-profile>, decreasing the C<-severity> will
  usually reveal more Policy violations. You can set the default value for this
  option in your F<.perlcriticrc> file.  Users can redefine the severity level
  for any Policy in their F<.perlcriticrc> file.  See L<"CONFIGURATION"> for
  more information.
  
  If it is difficult for you to remember whether severity "5" is the most or
  least restrictive level, then you can use one of these named values:
  
      SEVERITY NAME   ...is equivalent to...   SEVERITY NUMBER
      --------------------------------------------------------
      -severity => 'gentle'                     -severity => 5
      -severity => 'stern'                      -severity => 4
      -severity => 'harsh'                      -severity => 3
      -severity => 'cruel'                      -severity => 2
      -severity => 'brutal'                     -severity => 1
  
  The names reflect how severely the code is criticized: a C<gentle> criticism
  reports only the most severe violations, and so on down to a C<brutal>
  criticism which reports even the most minor violations.
  
  B<-theme> is special expression that determines which Policies to apply based
  on their respective themes.  For example, the following would load only
  Policies that have a 'bugs' AND 'pbp' theme:
  
    my $critic = Perl::Critic->new( -theme => 'bugs && pbp' );
  
  Unless the C<-severity> option is explicitly given, setting C<-theme> silently
  causes the C<-severity> to be set to 1.  You can set the default value for
  this option in your F<.perlcriticrc> file.  See the L<"POLICY THEMES"> section
  for more information about themes.
  
  
  B<-include> is a reference to a list of string C<@PATTERNS>.  Policy modules
  that match at least one C<m/$PATTERN/ixms> will always be loaded, irrespective
  of all other settings.  For example:
  
      my $critic = Perl::Critic->new(-include => ['layout'], -severity => 4);
  
  This would cause Perl::Critic to apply all the C<CodeLayout::*> Policy modules
  even though they have a severity level that is less than 4. You can set the
  default value for this option in your F<.perlcriticrc> file.  You can also use
  C<-include> in conjunction with the C<-exclude> option.  Note that C<-exclude>
  takes precedence over C<-include> when a Policy matches both patterns.
  
  B<-exclude> is a reference to a list of string C<@PATTERNS>.  Policy modules
  that match at least one C<m/$PATTERN/ixms> will not be loaded, irrespective of
  all other settings.  For example:
  
      my $critic = Perl::Critic->new(-exclude => ['strict'], -severity => 1);
  
  This would cause Perl::Critic to not apply the C<RequireUseStrict> and
  C<ProhibitNoStrict> Policy modules even though they have a severity level that
  is greater than 1.  You can set the default value for this option in your
  F<.perlcriticrc> file.  You can also use C<-exclude> in conjunction with the
  C<-include> option.  Note that C<-exclude> takes precedence over C<-include>
  when a Policy matches both patterns.
  
  B<-single-policy> is a string C<PATTERN>.  Only one policy that matches
  C<m/$PATTERN/ixms> will be used.  Policies that do not match will be excluded.
  This option has precedence over the C<-severity>, C<-theme>, C<-include>,
  C<-exclude>, and C<-only> options.  You can set the default value for this
  option in your F<.perlcriticrc> file.
  
  B<-top> is the maximum number of Violations to return when ranked by their
  severity levels.  This must be a positive integer.  Violations are still
  returned in the order that they occur within the file. Unless the C<-severity>
  option is explicitly given, setting C<-top> silently causes the C<-severity>
  to be set to 1.  You can set the default value for this option in your
  F<.perlcriticrc> file.
  
  B<-only> is a boolean value.  If set to a true value, Perl::Critic will only
  choose from Policies that are mentioned in the user's profile.  If set to a
  false value (which is the default), then Perl::Critic chooses from all the
  Policies that it finds at your site. You can set the default value for this
  option in your F<.perlcriticrc> file.
  
  B<-profile-strictness> is an enumerated value, one of
  L<Perl::Critic::Utils::Constants/"$PROFILE_STRICTNESS_WARN"> (the default),
  L<Perl::Critic::Utils::Constants/"$PROFILE_STRICTNESS_FATAL">, and
  L<Perl::Critic::Utils::Constants/"$PROFILE_STRICTNESS_QUIET">.  If set to
  L<Perl::Critic::Utils::Constants/"$PROFILE_STRICTNESS_FATAL">, Perl::Critic
  will make certain warnings about problems found in a F<.perlcriticrc> or file
  specified via the B<-profile> option fatal. For example, Perl::Critic normally
  only C<warn>s about profiles referring to non-existent Policies, but this
  value makes this situation fatal.  Correspondingly,
  L<Perl::Critic::Utils::Constants/"$PROFILE_STRICTNESS_QUIET"> makes
  Perl::Critic shut up about these things.
  
  B<-force> is a boolean value that controls whether Perl::Critic observes the
  magical C<"## no critic"> annotations in your code. If set to a true value,
  Perl::Critic will analyze all code.  If set to a false value (which is the
  default) Perl::Critic will ignore code that is tagged with these annotations.
  See L<"BENDING THE RULES"> for more information.  You can set the default
  value for this option in your F<.perlcriticrc> file.
  
  B<-verbose> can be a positive integer (from 1 to 11), or a literal format
  specification.  See L<Perl::Critic::Violation|Perl::Critic::Violation> for an
  explanation of format specifications.  You can set the default value for this
  option in your F<.perlcriticrc> file.
  
  B<-unsafe> directs Perl::Critic to allow the use of Policies that are marked
  as "unsafe" by the author.  Such policies may compile untrusted code or do
  other nefarious things.
  
  B<-color> and B<-pager> are not used by Perl::Critic but is provided for the
  benefit of L<perlcritic|perlcritic>.
  
  B<-criticism-fatal> is not used by Perl::Critic but is provided for the
  benefit of L<criticism|criticism>.
  
  B<-color-severity-highest>, B<-color-severity-high>, B<-color-severity-
  medium>, B<-color-severity-low>, and B<-color-severity-lowest> are not used by
  Perl::Critic, but are provided for the benefit of L<perlcritic|perlcritic>.
  Each is set to the Term::ANSIColor color specification to be used to display
  violations of the corresponding severity.
  
  B<-files-with-violations> and B<-files-without-violations> are not used by
  Perl::Critic, but are provided for the benefit of L<perlcritic|perlcritic>, to
  cause only the relevant filenames to be displayed.
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<critique( $source_code )>
  
  Runs the C<$source_code> through the Perl::Critic engine using all the
  Policies that have been loaded into this engine.  If C<$source_code> is a
  scalar reference, then it is treated as a string of actual Perl code.  If
  C<$source_code> is a reference to an instance of L<PPI::Document>, then that
  instance is used directly. Otherwise, it is treated as a path to a local file
  containing Perl code.  This method returns a list of
  L<Perl::Critic::Violation> objects for each violation of the loaded Policies.
  The list is sorted in the order that the Violations appear in the code.  If
  there are no violations, this method returns an empty list.
  
  =item C<< add_policy( -policy => $policy_name, -params => \%param_hash ) >>
  
  Creates a Policy object and loads it into this Critic.  If the object cannot
  be instantiated, it will throw a fatal exception.  Otherwise, it returns a
  reference to this Critic.
  
  B<-policy> is the name of a L<Perl::Critic::Policy> subclass module.  The
  C<'Perl::Critic::Policy'> portion of the name can be omitted for brevity.
  This argument is required.
  
  B<-params> is an optional reference to a hash of Policy parameters. The
  contents of this hash reference will be passed into to the constructor of the
  Policy module.  See the documentation in the relevant Policy module for a
  description of the arguments it supports.
  
  =item C< policies() >
  
  Returns a list containing references to all the Policy objects that have been
  loaded into this engine.  Objects will be in the order that they were loaded.
  
  =item C< config() >
  
  Returns the L<Perl::Critic::Config> object that was created for or given to
  this Critic.
  
  =item C< statistics() >
  
  Returns the L<Perl::Critic::Statistics> object that was created for this
  Critic.  The Statistics object accumulates data for all files that are
  analyzed by this Critic.
  
  =back
  
  
  =head1 FUNCTIONAL INTERFACE
  
  For those folks who prefer to have a functional interface, The C<critique>
  method can be exported on request and called as a static function.  If the
  first argument is a hashref, its contents are used to construct a new
  Perl::Critic object internally.  The keys of that hash should be the same as
  those supported by the C<Perl::Critic::new()> method.  Here are some examples:
  
      use Perl::Critic qw(critique);
  
      # Use default parameters...
      @violations = critique( $some_file );
  
      # Use custom parameters...
      @violations = critique( {-severity => 2}, $some_file );
  
      # As a one-liner
      %> perl -MPerl::Critic=critique -e 'print critique(shift)' some_file.pm
  
  None of the other object-methods are currently supported as static
  functions.  Sorry.
  
  
  =head1 CONFIGURATION
  
  Most of the settings for Perl::Critic and each of the Policy modules can be
  controlled by a configuration file.  The default configuration file is called
  F<.perlcriticrc>.  Perl::Critic will look for this file in the current
  directory first, and then in your home directory. Alternatively, you can set
  the C<PERLCRITIC> environment variable to explicitly point to a different file
  in another location.  If none of these files exist, and the C<-profile> option
  is not given to the constructor, then all the modules that are found in the
  Perl::Critic::Policy namespace will be loaded with their default
  configuration.
  
  The format of the configuration file is a series of INI-style blocks that
  contain key-value pairs separated by '='. Comments should start with '#' and
  can be placed on a separate line or after the name-value pairs if you desire.
  
  Default settings for Perl::Critic itself can be set B<before the first named
  block.> For example, putting any or all of these at the top of your
  configuration file will set the default value for the corresponding
  constructor argument.
  
      severity  = 3                                     #Integer or named level
      only      = 1                                     #Zero or One
      force     = 0                                     #Zero or One
      verbose   = 4                                     #Integer or format spec
      top       = 50                                    #A positive integer
      theme     = (pbp || security) && bugs             #A theme expression
      include   = NamingConventions ClassHierarchies    #Space-delimited list
      exclude   = Variables  Modules::RequirePackage    #Space-delimited list
      criticism-fatal = 1                               #Zero or One
      color     = 1                                     #Zero or One
      allow-unsafe = 1                                  #Zero or One
      pager     = less                                  #pager to pipe output to
  
  The remainder of the configuration file is a series of blocks like this:
  
      [Perl::Critic::Policy::Category::PolicyName]
      severity = 1
      set_themes = foo bar
      add_themes = baz
      maximum_violations_per_document = 57
      arg1 = value1
      arg2 = value2
  
  C<Perl::Critic::Policy::Category::PolicyName> is the full name of a module
  that implements the policy.  The Policy modules distributed with Perl::Critic
  have been grouped into categories according to the table of contents in Damian
  Conway's book B<Perl Best Practices>. For brevity, you can omit the
  C<'Perl::Critic::Policy'> part of the module name.
  
  C<severity> is the level of importance you wish to assign to the Policy.  All
  Policy modules are defined with a default severity value ranging from 1 (least
  severe) to 5 (most severe).  However, you may disagree with the default
  severity and choose to give it a higher or lower severity, based on your own
  coding philosophy.  You can set the C<severity> to an integer from 1 to 5, or
  use one of the equivalent names:
  
      SEVERITY NAME ...is equivalent to... SEVERITY NUMBER
      ----------------------------------------------------
      gentle                                             5
      stern                                              4
      harsh                                              3
      cruel                                              2
      brutal                                             1
  
  The names reflect how severely the code is criticized: a C<gentle> criticism
  reports only the most severe violations, and so on down to a C<brutal>
  criticism which reports even the most minor violations.
  
  C<set_themes> sets the theme for the Policy and overrides its default theme.
  The argument is a string of one or more whitespace-delimited alphanumeric
  words.  Themes are case-insensitive.  See L<"POLICY THEMES"> for more
  information.
  
  C<add_themes> appends to the default themes for this Policy.  The argument is
  a string of one or more whitespace-delimited words. Themes are case-
  insensitive.  See L<"POLICY THEMES"> for more information.
  
  C<maximum_violations_per_document> limits the number of Violations the Policy
  will return for a given document.  Some Policies have a default limit; see the
  documentation for the individual Policies to see whether there is one.  To
  force a Policy to not have a limit, specify "no_limit" or the empty string for
  the value of this parameter.
  
  The remaining key-value pairs are configuration parameters that will be passed
  into the constructor for that Policy.  The constructors for most Policy
  objects do not support arguments, and those that do should have reasonable
  defaults.  See the documentation on the appropriate Policy module for more
  details.
  
  Instead of redefining the severity for a given Policy, you can completely
  disable a Policy by prepending a '-' to the name of the module in your
  configuration file.  In this manner, the Policy will never be loaded,
  regardless of the C<-severity> given to the Perl::Critic constructor.
  
  A simple configuration might look like this:
  
      #--------------------------------------------------------------
      # I think these are really important, so always load them
  
      [TestingAndDebugging::RequireUseStrict]
      severity = 5
  
      [TestingAndDebugging::RequireUseWarnings]
      severity = 5
  
      #--------------------------------------------------------------
      # I think these are less important, so only load when asked
  
      [Variables::ProhibitPackageVars]
      severity = 2
  
      [ControlStructures::ProhibitPostfixControls]
      allow = if unless  # My custom configuration
      severity = cruel   # Same as "severity = 2"
  
      #--------------------------------------------------------------
      # Give these policies a custom theme.  I can activate just
      # these policies by saying `perlcritic -theme larry`
  
      [Modules::RequireFilenameMatchesPackage]
      add_themes = larry
  
      [TestingAndDebugging::RequireTestLables]
      add_themes = larry curly moe
  
      #--------------------------------------------------------------
      # I do not agree with these at all, so never load them
  
      [-NamingConventions::Capitalization]
      [-ValuesAndExpressions::ProhibitMagicNumbers]
  
      #--------------------------------------------------------------
      # For all other Policies, I accept the default severity,
      # so no additional configuration is required for them.
  
  For additional configuration examples, see the F<perlcriticrc> file that is
  included in this F<examples> directory of this distribution.
  
  Damian Conway's own Perl::Critic configuration is also included in this
  distribution as F<examples/perlcriticrc-conway>.
  
  
  =head1 THE POLICIES
  
  A large number of Policy modules are distributed with Perl::Critic. They are
  described briefly in the companion document L<Perl::Critic::PolicySummary> and
  in more detail in the individual modules themselves.  Say C<"perlcritic -doc
  PATTERN"> to see the perldoc for all Policy modules that match the regex
  C<m/PATTERN/ixms>
  
  There are a number of distributions of additional policies on CPAN. If
  L<Perl::Critic> doesn't contain a policy that you want, some one may have
  already written it.  See the L</"SEE ALSO"> section below for a list of some
  of these distributions.
  
  
  =head1 POLICY THEMES
  
  Each Policy is defined with one or more "themes".  Themes can be used to
  create arbitrary groups of Policies.  They are intended to provide an
  alternative mechanism for selecting your preferred set of Policies. For
  example, you may wish disable a certain subset of Policies when analyzing test
  programs.  Conversely, you may wish to enable only a specific subset of
  Policies when analyzing modules.
  
  The Policies that ship with Perl::Critic have been broken into the following
  themes.  This is just our attempt to provide some basic logical groupings.
  You are free to invent new themes that suit your needs.
  
      THEME             DESCRIPTION
      --------------------------------------------------------------------------
      core              All policies that ship with Perl::Critic
      pbp               Policies that come directly from "Perl Best Practices"
      bugs              Policies that that prevent or reveal bugs
      certrec           Policies that CERT recommends
      certrule          Policies that CERT considers rules
      maintenance       Policies that affect the long-term health of the code
      cosmetic          Policies that only have a superficial effect
      complexity        Policies that specifically relate to code complexity
      security          Policies that relate to security issues
      tests             Policies that are specific to test programs
  
  
  Any Policy may fit into multiple themes.  Say C<"perlcritic -list"> to get a
  listing of all available Policies and the themes that are associated with each
  one.  You can also change the theme for any Policy in your F<.perlcriticrc>
  file.  See the L<"CONFIGURATION"> section for more information about that.
  
  Using the C<-theme> option, you can create an arbitrarily complex rule that
  determines which Policies will be loaded.  Precedence is the same as regular
  Perl code, and you can use parentheses to enforce precedence as well.
  Supported operators are:
  
      Operator    Alternative    Example
      -----------------------------------------------------------------
      &&          and            'pbp && core'
      ||          or             'pbp || (bugs && security)'
      !           not            'pbp && ! (portability || complexity)'
  
  Theme names are case-insensitive.  If the C<-theme> is set to an empty string,
  then it evaluates as true all Policies.
  
  
  =head1 BENDING THE RULES
  
  Perl::Critic takes a hard-line approach to your code: either you comply or you
  don't.  In the real world, it is not always practical (nor even possible) to
  fully comply with coding standards.  In such cases, it is wise to show that
  you are knowingly violating the standards and that you have a Damn Good Reason
  (DGR) for doing so.
  
  To help with those situations, you can direct Perl::Critic to ignore certain
  lines or blocks of code by using annotations:
  
      require 'LegacyLibaray1.pl';  ## no critic
      require 'LegacyLibrary2.pl';  ## no critic
  
      for my $element (@list) {
  
          ## no critic
  
          $foo = "";               #Violates 'ProhibitEmptyQuotes'
          $barf = bar() if $foo;   #Violates 'ProhibitPostfixControls'
          #Some more evil code...
  
          ## use critic
  
          #Some good code...
          do_something($_);
      }
  
  The C<"## no critic"> annotations direct Perl::Critic to ignore the remaining
  lines of code until a C<"## use critic"> annotation is found. If the C<"## no
  critic"> annotation is on the same line as a code statement, then only that
  line of code is overlooked.  To direct perlcritic to ignore the C<"## no
  critic"> annotations, use the C<--force> option.
  
  A bare C<"## no critic"> annotation disables all the active Policies.  If you
  wish to disable only specific Policies, add a list of Policy names as
  arguments, just as you would for the C<"no strict"> or C<"no warnings">
  pragmas.  For example, this would disable the C<ProhibitEmptyQuotes> and
  C<ProhibitPostfixControls> policies until the end of the block or until the
  next C<"## use critic"> annotation (whichever comes first):
  
      ## no critic (EmptyQuotes, PostfixControls)
  
      # Now exempt from ValuesAndExpressions::ProhibitEmptyQuotes
      $foo = "";
  
      # Now exempt ControlStructures::ProhibitPostfixControls
      $barf = bar() if $foo;
  
      # Still subjected to ValuesAndExpression::RequireNumberSeparators
      $long_int = 10000000000;
  
  Since the Policy names are matched against the C<"## no critic"> arguments as
  regular expressions, you can abbreviate the Policy names or disable an entire
  family of Policies in one shot like this:
  
      ## no critic (NamingConventions)
  
      # Now exempt from NamingConventions::Capitalization
      my $camelHumpVar = 'foo';
  
      # Now exempt from NamingConventions::Capitalization
      sub camelHumpSub {}
  
  The argument list must be enclosed in parentheses or brackets and must contain
  one or more comma-separated barewords (e.g. don't use quotes).
  The C<"## no critic"> annotations can be nested, and Policies named by an inner
  annotation will be disabled along with those already disabled an outer
  annotation.
  
  Some Policies like C<Subroutines::ProhibitExcessComplexity> apply to an entire
  block of code.  In those cases, the C<"## no critic"> annotation must appear
  on the line where the violation is reported.  For example:
  
      sub complicated_function {  ## no critic (ProhibitExcessComplexity)
          # Your code here...
      }
  
  Policies such as C<Documentation::RequirePodSections> apply to the entire
  document, in which case violations are reported at line 1.
  
  Use this feature wisely.  C<"## no critic"> annotations should be used in the
  smallest possible scope, or only on individual lines of code. And you should
  always be as specific as possible about which Policies you want to disable
  (i.e. never use a bare C<"## no critic">).  If Perl::Critic complains about
  your code, try and find a compliant solution before resorting to this feature.
  
  
  =head1 THE L<Perl::Critic> PHILOSOPHY
  
  Coding standards are deeply personal and highly subjective.  The goal of
  Perl::Critic is to help you write code that conforms with a set of best
  practices.  Our primary goal is not to dictate what those practices are, but
  rather, to implement the practices discovered by others.  Ultimately, you make
  the rules -- Perl::Critic is merely a tool for encouraging consistency.  If
  there is a policy that you think is important or that we have overlooked, we
  would be very grateful for contributions, or you can simply load your own
  private set of policies into Perl::Critic.
  
  
  =head1 EXTENDING THE CRITIC
  
  The modular design of Perl::Critic is intended to facilitate the addition of
  new Policies.  You'll need to have some understanding of L<PPI>, but most
  Policy modules are pretty straightforward and only require about 20 lines of
  code.  Please see the L<Perl::Critic::DEVELOPER> file included in this
  distribution for a step-by-step demonstration of how to create new Policy
  modules.
  
  If you develop any new Policy modules, feel free to send them to C<<
  <team@perlcritic.com> >> and I'll be happy to consider putting them into the
  Perl::Critic distribution.  Or if you would like to work on the Perl::Critic
  project directly, you can fork our repository at
  L<https://github.com/Perl-Critic/Perl-Critic.git>.
  
  The Perl::Critic team is also available for hire.  If your organization has
  its own coding standards, we can create custom Policies to enforce your local
  guidelines.  Or if your code base is prone to a particular defect pattern, we
  can design Policies that will help you catch those costly defects B<before>
  they go into production. To discuss your needs with the Perl::Critic team,
  just contact C<< <team@perlcritic.com> >>.
  
  
  =head1 PREREQUISITES
  
  Perl::Critic requires the following modules:
  
  L<B::Keywords>
  
  L<Config::Tiny>
  
  L<Exception::Class>
  
  L<File::HomeDir>
  
  L<File::Spec>
  
  L<File::Spec::Unix>
  
  L<File::Which>
  
  L<IO::String>
  
  L<List::MoreUtils>
  
  L<List::Util>
  
  L<Module::Pluggable>
  
  L<Perl::Tidy>
  
  L<Pod::Spell>
  
  L<PPI|PPI>
  
  L<Pod::PlainText>
  
  L<Pod::Select>
  
  L<Pod::Usage>
  
  L<Readonly>
  
  L<Scalar::Util>
  
  L<String::Format>
  
  L<Task::Weaken>
  
  L<Term::ANSIColor>
  
  L<Text::ParseWords>
  
  L<version|version>
  
  
  =head1 CONTACTING THE DEVELOPMENT TEAM
  
  You are encouraged to subscribe to the public mailing list at
  L<https://groups.google.com/d/forum/perl-critic>.
  At least one member of the development team is usually hanging around
  in L<irc://irc.perl.org/#perlcritic> and you can follow Perl::Critic on
  Twitter, at L<https://twitter.com/perlcritic>.
  
  
  =head1 SEE ALSO
  
  There are a number of distributions of additional Policies available. A few
  are listed here:
  
  L<Perl::Critic::More>
  
  L<Perl::Critic::Bangs>
  
  L<Perl::Critic::Lax>
  
  L<Perl::Critic::StricterSubs>
  
  L<Perl::Critic::Swift>
  
  L<Perl::Critic::Tics>
  
  These distributions enable you to use Perl::Critic in your unit tests:
  
  L<Test::Perl::Critic>
  
  L<Test::Perl::Critic::Progressive>
  
  There is also a distribution that will install all the Perl::Critic related
  modules known to the development team:
  
  L<Task::Perl::Critic>
  
  
  =head1 BUGS
  
  Scrutinizing Perl code is hard for humans, let alone machines.  If you find
  any bugs, particularly false-positives or false-negatives from a
  Perl::Critic::Policy, please submit them at
  L<https://github.com/Perl-Critic/Perl-Critic/issues>.  Thanks.
  
  =head1 CREDITS
  
  Adam Kennedy - For creating L<PPI>, the heart and soul of L<Perl::Critic>.
  
  Damian Conway - For writing B<Perl Best Practices>, finally :)
  
  Chris Dolan - For contributing the best features and Policy modules.
  
  Andy Lester - Wise sage and master of all-things-testing.
  
  Elliot Shank - The self-proclaimed quality freak.
  
  Giuseppe Maxia - For all the great ideas and positive encouragement.
  
  and Sharon, my wife - For putting up with my all-night code sessions.
  
  Thanks also to the Perl Foundation for providing a grant to support Chris
  Dolan's project to implement twenty PBP policies.
  L<http://www.perlfoundation.org/april_1_2007_new_grant_awards>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2018 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  The full text of this license can be found in
  the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC

$fatpacked{"Perl/Critic/Annotation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_ANNOTATION';
  package Perl::Critic::Annotation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp qw(confess);
  use English qw(-no_match_vars);
  
  use Perl::Critic::PolicyFactory;
  use Perl::Critic::Utils qw(:characters hashify);
  use Readonly;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  Readonly::Scalar my $LAST_ELEMENT => -1;
  
  #=============================================================================
  # CLASS methods
  
  sub create_annotations {
      my ($class, $doc) = @_;
  
      my @annotations = ();
      my $comment_elements_ref  = $doc->find('PPI::Token::Comment') || return;
      my $annotation_rx  = qr{\A (?: [#]! .*? )? \s* [#][#] \s* no  \s+ critic}xms;
      for my $annotation_element ( grep { $_ =~ $annotation_rx } @{$comment_elements_ref} ) {
          push @annotations, Perl::Critic::Annotation->new( -element => $annotation_element);
      }
  
      return @annotations;
  }
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, @args) = @_;
      my $self = bless {}, $class;
      $self->_init(@args);
      return $self;
  }
  
  #=============================================================================
  # OBJECT methods
  
  sub _init {
      my ($self, %args) = @_;
      my $annotation_element = $args{-element} || confess '-element argument is required';
      $self->{_element} = $annotation_element;
  
      my %disabled_policies = _parse_annotation( $annotation_element );
      $self->{_disables_all_policies} = %disabled_policies ? 0 : 1;
      $self->{_disabled_policies} = \%disabled_policies;
  
      # Grab surrounding nodes to determine the context.
      # This determines whether the annotation applies to
      # the current line or the block that follows.
      my $annotation_line = $annotation_element->logical_line_number();
      my $parent = $annotation_element->parent();
      my $grandparent = $parent ? $parent->parent() : undef;
  
      # Handle case when it appears on the shebang line.  In this
      # situation, it only affects the first line, not the whole doc
      if ( $annotation_element =~ m{\A [#]!}xms) {
          $self->{_effective_range} = [$annotation_line, $annotation_line];
          return $self;
      }
  
      # Handle single-line usage on simple statements.  In this
      # situation, it only affects the line that it appears on.
      if ( _is_single_line_annotation_on_simple_statement( $annotation_element )
      ) {
          $self->{_effective_range} = [$annotation_line, $annotation_line];
          return $self;
      }
  
      # Handle single-line usage on compound statements.  In this
      # situation -- um -- I'm not sure how this works, but it does.
      if ( ref $parent eq 'PPI::Structure::Block' ) {
          if ( ref $grandparent eq 'PPI::Statement::Compound'
              || ref $grandparent eq 'PPI::Statement::Sub' ) {
              if ( $parent->logical_line_number() == $annotation_line ) {
                  my $grandparent_line = $grandparent->logical_line_number();
                  $self->{_effective_range} = [$grandparent_line, $grandparent_line];
                  return $self;
              }
          }
      }
  
  
      # Handle multi-line usage.  This is either a "no critic" ..
      # "use critic" region or a block where "no critic" is in effect
      # until the end of the scope.  The start is the always the "no
      # critic" which we already found.  So now we have to search for the end.
      my $end = $annotation_element;
      my $use_critic = qr{\A \s* [#][#] \s* use \s+ critic}xms;
  
    SIB:
      while ( my $esib = $end->next_sibling() ) {
          $end = $esib; # keep track of last sibling encountered in this scope
          last SIB if $esib->isa('PPI::Token::Comment') && $esib =~ $use_critic;
      }
  
      # PPI parses __END__ as a PPI::Statement::End, and everything following is
      # a child of that statement. That means if we encounter an __END__, we
      # need to descend into it and continue the analysis.
      if ( $end->isa( 'PPI::Statement::End' ) and my $kid = $end->child( 0 ) ) {
          $end = $kid;
        SIB:
          while ( my $esib = $end->next_sibling() ) {
              $end = $esib;
              last SIB if $esib->isa( 'PPI::Token::Comment' ) &&
                  $esib->content() =~ $use_critic;
          }
      }
  
      # We either found an end or hit the end of the scope.
      my $ending_line = $end->logical_line_number();
      $self->{_effective_range} = [$annotation_line, $ending_line];
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub element {
      my ($self) = @_;
      return $self->{_element};
  }
  
  #-----------------------------------------------------------------------------
  
  sub effective_range {
      my $self = shift;
      return @{ $self->{_effective_range} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub disabled_policies {
      my $self = shift;
      return keys %{ $self->{_disabled_policies} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub disables_policy {
      my ($self, $policy_name) = @_;
      return 1 if $self->{_disabled_policies}->{$policy_name};
      return 1 if $self->disables_all_policies();
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub disables_all_policies {
      my ($self) = @_;
      return $self->{_disables_all_policies};
  }
  
  #-----------------------------------------------------------------------------
  
  sub disables_line {
      my ($self, $line_number) = @_;
      my $effective_range = $self->{_effective_range};
      return 1 if $line_number >= $effective_range->[0]
          and $line_number <= $effective_range->[$LAST_ELEMENT];
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  # Recognize a single-line annotation on a simple statement.
  sub _is_single_line_annotation_on_simple_statement {
      my ( $annotation_element ) = @_;
      my $annotation_line = $annotation_element->logical_line_number();
  
      # If there is no sibling, we are clearly not a single-line annotation of
      # any sort.
      my $sib = $annotation_element->sprevious_sibling()
          or return 0;
  
      # The easy case: the sibling (whatever it is) is on the same line as the
      # annotation.
      $sib->logical_line_number() == $annotation_line
          and return 1;
  
      # If the sibling is a node, we may have an annotation on one line of a
      # statement that was split over multiple lines. So we descend through the
      # children, keeping the last significant child of each, until we bottom
      # out. If the ultimate significant descendant is on the same line as the
      # annotation, we accept the annotation as a single-line annotation.
      if ( $sib->isa( 'PPI::Node' ) &&
          $sib->logical_line_number() < $annotation_line
      ) {
          my $neighbor = $sib;
          while ( $neighbor->isa( 'PPI::Node' )
                  and my $kid = $neighbor->schild( $LAST_ELEMENT ) ) {
              $neighbor = $kid;
          }
          if ( $neighbor &&
              $neighbor->logical_line_number() == $annotation_line
          ) {
              return 1;
          }
      }
  
      # We do not understand any other sort of single-line annotation. Accepting
      # the annotation as such (if it is) is Someone Else's Problem.
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_annotation {
  
      my ($annotation_element) = @_;
  
      #############################################################################
      # This regex captures the list of Policy name patterns that are to be
      # disabled.  It is generally assumed that the element has already been
      # verified as a no-critic annotation.  So if this regex does not match,
      # then it implies that all Policies are to be disabled.
      #
      my $no_critic = qr{\#\# \s* no \s+ critic \s* (?:qw)? [(["'] ([\s\w:,]+) }xms;
      #                  -------------------------- ------- ----- -----------
      #                                 |              |      |        |
      #   "## no critic" with optional spaces          |      |        |
      #                                                |      |        |
      #             Policy list may be prefixed with "qw"     |        |
      #                                                       |        |
      #         Optional Policy list must begin with one of these      |
      #                                                                |
      #                 Capture entire Policy list (with delimiters) here
      #
      #############################################################################
  
      my @disabled_policy_names = ();
      if ( my ($patterns_string) = $annotation_element =~ $no_critic ) {
  
          # Compose the specified modules into a regex alternation.  Wrap each
          # in a no-capturing group to permit "|" in the modules specification.
  
          my @policy_name_patterns = grep { $_ ne $EMPTY }
              split m{\s *[,\s] \s*}xms, $patterns_string;
          my $re = join $PIPE, map {"(?:$_)"} @policy_name_patterns;
          my @site_policy_names = Perl::Critic::PolicyFactory::site_policy_names();
          @disabled_policy_names = grep {m/$re/ixms} @site_policy_names;
  
          # It is possible that the Policy patterns listed in the annotation do not
          # match any of the site policy names.  This could happen when running
          # on a machine that does not have the same set of Policies as the author.
          # So we must return something here, otherwise all Policies will be
          # disabled.  We probably need to add a mechanism to (optionally) warn
          # about this, just to help the author avoid writing invalid Policy names.
  
          if (not @disabled_policy_names) {
              @disabled_policy_names = @policy_name_patterns;
          }
      }
  
      return hashify(@disabled_policy_names);
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Annotation - A "## no critic" annotation in a document.
  
  
  =head1 SYNOPSIS
  
    use Perl::Critic::Annotation;
    $annotation = Perl::Critic::Annotation->new( -element => $no_critic_ppi_element );
  
    $bool = $annotation->disables_line( $number );
    $bool = $annotation->disables_policy( $policy_object );
    $bool = $annotation->disables_all_policies();
  
    ($start, $end) = $annotation->effective_range();
    @disabled_policy_names = $annotation->disabled_policies();
  
  
  =head1 DESCRIPTION
  
  C<Perl::Critic::Annotation> represents a single C<"## no critic">
  annotation in a L<PPI::Document>.  The Annotation takes care of parsing
  the annotation and keeps track of which lines and Policies it affects.
  It is intended to encapsulate the details of the no-critic
  annotations, and to provide a way for Policy objects to interact with
  the annotations (via a L<Perl::Critic::Document|Perl::Critic::Document>).
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item create_annotations( -doc => $doc )
  
  Given a L<Perl::Critic::Document|Perl::Critic::Document>, finds all the C<"## no critic">
  annotations and constructs a new C<Perl::Critic::Annotation> for each
  one and returns them.  The order of the returned objects is not
  defined.  It is generally expected that clients will use this
  interface rather than calling the C<Perl::Critic::Annotation>
  constructor directly.
  
  
  =back
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new( -element => $ppi_annotation_element ) >>
  
  Returns a reference to a new Annotation object.  The B<-element>
  argument is required and should be a C<PPI::Token::Comment> that
  conforms to the C<"## no critic"> syntax.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<< disables_line( $line ) >>
  
  Returns true if this Annotation disables C<$line> for any (or all)
  Policies.
  
  
  =item C<< disables_policy( $policy_object ) >>
  
  =item C<< disables_policy( $policy_name ) >>
  
  Returns true if this Annotation disables C<$polciy_object> or
  C<$policy_name> at any (or all) lines.
  
  
  =item C<< disables_all_policies() >>
  
  Returns true if this Annotation disables all Policies at any (or all)
  lines.  If this method returns true, C<disabled_policies> will return
  an empty list.
  
  
  =item C<< effective_range() >>
  
  Returns a two-element list, representing the first and last line
  numbers where this Annotation has effect.
  
  
  =item C<< disabled_policies() >>
  
  Returns a list of the names of the Policies that are affected by this
  Annotation.  If this list is empty, then it means that all Policies
  are affected by this Annotation, and C<disables_all_policies()> should
  return true.
  
  
  =item C<< element() >>
  
  Returns the L<PPI::Element|PPI::Element> where this annotation started.  This is
  typically an instance of L<PPI::Token::Comment|PPI::Token::Comment>.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_ANNOTATION

$fatpacked{"Perl/Critic/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_COMMAND';
  package Perl::Critic::Command;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw< -no_match_vars >;
  use Readonly;
  
  use Getopt::Long qw< GetOptions >;
  use List::Util qw< first max >;
  use Pod::Usage qw< pod2usage >;
  
  use Perl::Critic::Exception::Parse ();
  use Perl::Critic::Utils qw<
      :characters :severities policy_short_name
      $DEFAULT_VERBOSITY $DEFAULT_VERBOSITY_WITH_FILE_NAME
  >;
  use Perl::Critic::Utils::Constants qw< $_MODULE_VERSION_TERM_ANSICOLOR >;
  use Perl::Critic::Violation qw<>;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exporter 'import';
  
  Readonly::Array our @EXPORT_OK => qw< run >;
  
  Readonly::Hash our %EXPORT_TAGS => (
      all             => [ @EXPORT_OK ],
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DEFAULT_VIOLATIONS_FOR_TOP => 20;
  
  Readonly::Scalar my $EXIT_SUCCESS           => 0;
  Readonly::Scalar my $EXIT_NO_FILES          => 1;
  Readonly::Scalar my $EXIT_HAD_VIOLATIONS    => 2;
  Readonly::Scalar my $EXIT_HAD_FILE_PROBLEMS => 3;
  
  #-----------------------------------------------------------------------------
  
  my @files = ();
  my $critic = undef;
  my $output = \*STDOUT;
  
  #-----------------------------------------------------------------------------
  
  sub _out {
      my @lines = @_;
      return print {$output} @lines;
  }
  
  #-----------------------------------------------------------------------------
  
  sub run {
      my %options    = _get_options();
      @files         = _get_input(@ARGV);
  
      my ($violations, $had_error_in_file) = _critique(\%options, @files);
  
      return $EXIT_HAD_FILE_PROBLEMS  if $had_error_in_file;
      return $EXIT_NO_FILES           if not defined $violations;
      return $EXIT_HAD_VIOLATIONS     if $violations;
  
      return $EXIT_SUCCESS;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_options {
  
      my %opts = _parse_command_line();
      _dispatch_special_requests( %opts );
      _validate_options( %opts );
  
      # Convert severity shortcut options.  If multiple shortcuts
      # are given, the lowest one wins.  If an explicit --severity
      # option has been given, then the shortcuts are ignored. The
      # @SEVERITY_NAMES variable is exported by Perl::Critic::Utils.
      $opts{-severity} ||= first { exists $opts{"-$_"} } @SEVERITY_NAMES;
      $opts{-severity} ||= first { exists $opts{"-$_"} } ($SEVERITY_LOWEST ..  $SEVERITY_HIGHEST);
  
  
      # If --top is specified, default the severity level to 1, unless an
      # explicit severity is defined.  This provides us flexibility to
      # report top-offenders across just some or all of the severity levels.
      # We also default the --top count to twenty if none is given
      if ( exists $opts{-top} ) {
          $opts{-severity} ||= 1;
          $opts{-top} ||= $DEFAULT_VIOLATIONS_FOR_TOP;
      }
  
      #Override profile, if --noprofile is specified
      if ( exists $opts{-noprofile} ) {
          $opts{-profile} = $EMPTY;
      }
  
      return %opts;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_command_line {
      my %opts;
      my @opt_specs = _get_option_specification();
      Getopt::Long::Configure('no_ignore_case');
      GetOptions( \%opts, @opt_specs ) || pod2usage();           #Exits
  
      # I've adopted the convention of using key-value pairs for
      # arguments to most functions.  And to increase legibility,
      # I have also adopted the familiar command-line practice
      # of denoting argument names with a leading dash (-).
      my %dashed_opts = map { ( "-$_" => $opts{$_} ) } keys %opts;
      return %dashed_opts;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _dispatch_special_requests {
      my (%opts) = @_;
      if ( $opts{-help}            ) { pod2usage( -verbose => 0 )    }  # Exits
      if ( $opts{-options}         ) { pod2usage( -verbose => 1 )    }  # Exits
      if ( $opts{-man}             ) { pod2usage( -verbose => 2 )    }  # Exits
      if ( $opts{-version}         ) { _display_version()            }  # Exits
      if ( $opts{-list}            ) { _render_all_policy_listing()  }  # Exits
      if ( $opts{'-list-enabled'}  ) { _render_policy_listing(%opts) }  # Exits
      if ( $opts{'-list-themes'}   ) { _render_theme_listing()       }  # Exits
      if ( $opts{'-profile-proto'} ) { _render_profile_prototype()   }  # Exits
      if ( $opts{-doc}             ) { _render_policy_docs( %opts )  }  # Exits
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_options {
      my (%opts) = @_;
      my $msg = $EMPTY;
  
  
      if ( $opts{-noprofile} && $opts{-profile} ) {
          $msg .= qq{Warning: Cannot use -noprofile with -profile option.\n};
      }
  
      if ( $opts{-verbose} && $opts{-verbose} !~ m{(?: \d+ | %[mfFlcCedrpPs] )}xms) {
          $msg .= qq<Warning: --verbose arg "$opts{-verbose}" looks odd.  >;
          $msg .= qq<Perhaps you meant to say "--verbose 3 $opts{-verbose}."\n>;
      }
  
      if ( exists $opts{-top} && $opts{-top} < 0 ) {
          $msg .= qq<Warning: --top argument "$opts{-top}" is negative.  >;
          $msg .= qq<Perhaps you meant to say "$opts{-top} --top".\n>;
      }
  
      if (
              exists $opts{-severity}
          &&  (
                      $opts{-severity} < $SEVERITY_LOWEST
                  ||  $opts{-severity} > $SEVERITY_HIGHEST
              )
      ) {
          $msg .= qq<Warning: --severity arg "$opts{-severity}" out of range.  >;
          $msg .= qq<Severities range from "$SEVERITY_LOWEST" (lowest) to >;
          $msg .= qq<"$SEVERITY_HIGHEST" (highest).\n>;
      }
  
  
      if ( $msg ) {
          pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0); #Exits
      }
  
  
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_input {
  
      my @args = @_;
  
      if ( !@args || (@args == 1 && $args[0] eq q{-}) )  {
  
          # Reading code from STDIN.  All the code is slurped into
          # a string.  PPI will barf if the string is just whitespace.
          my $code_string = do { local $RS = undef; <STDIN> };
  
          # Notice if STDIN was closed (pipe error, etc)
          if ( ! defined $code_string ) {
              $code_string = $EMPTY;
          }
  
          $code_string =~ m{ \S+ }xms || die qq{Nothing to critique.\n};
          return \$code_string;    #Convert to SCALAR ref for PPI
      }
      else {
  
          # Test to make sure all the specified files or directories
          # actually exist.  If any one of them is bogus, then die.
          if ( my $nonexistent = first { ! -e } @args ) {
              my $msg = qq{No such file or directory: '$nonexistent'};
              pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0);
          }
  
          # Reading code from files or dirs.  If argument is a file,
          # then we process it as-is (even though it may not actually
          # be Perl code).  If argument is a directory, recursively
          # search the directory for files that look like Perl code.
          return map { (-d) ? Perl::Critic::Utils::all_perl_files($_) : $_ } @args;
      }
  }
  
  #------------------------------------------------------------------------------
  
  sub _critique {
  
      my ( $opts_ref, @files_to_critique ) = @_;
      @files_to_critique || die "No perl files were found.\n";
  
      # Perl::Critic has lots of dependencies, so loading is delayed
      # until it is really needed.  This hack reduces startup time for
      # doing other things like getting the version number or dumping
      # the man page. Arguably, those things are pretty rare, but hey,
      # why not save a few seconds if you can.
  
      require Perl::Critic;
      $critic = Perl::Critic->new( %{$opts_ref} );
      $critic->policies() || die "No policies selected.\n";
  
      _set_up_pager($critic->config()->pager());
  
      my $number_of_violations = undef;
      my $had_error_in_file = 0;
  
      for my $file (@files_to_critique) {
  
          eval {
              my @violations = $critic->critique($file);
              $number_of_violations += scalar @violations;
  
              if (not $opts_ref->{'-statistics-only'}) {
                  _render_report( $file, $opts_ref, @violations )
              }
              1;
          }
          or do {
              if ( my $exception = Perl::Critic::Exception::Parse->caught() ) {
                  $had_error_in_file = 1;
                  warn qq<Problem while critiquing "$file": $EVAL_ERROR\n>;
              }
              elsif ($EVAL_ERROR) {
                  # P::C::Exception::Fatal includes the stack trace in its
                  # stringification.
                  die qq<Fatal error while critiquing "$file": $EVAL_ERROR\n>;
              }
              else {
                  die qq<Fatal error while critiquing "$file". Unfortunately, >,
                      q<$@/$EVAL_ERROR >, ## no critic (RequireInterpolationOfMetachars)
                      qq<is empty, so the reason can't be shown.\n>;
              }
          }
      }
  
      if ( $opts_ref->{-statistics} or $opts_ref->{'-statistics-only'} ) {
          my $stats = $critic->statistics();
          _report_statistics( $opts_ref, $stats );
      }
  
      return $number_of_violations, $had_error_in_file;
  }
  
  #------------------------------------------------------------------------------
  
  sub _render_report {
      my ( $file, $opts_ref, @violations ) = @_;
  
      # Only report the files, if asked.
      my $number_of_violations = scalar @violations;
      if ( $opts_ref->{'-files-with-violations'} ||
          $opts_ref->{'-files-without-violations'} ) {
          not ref $file
              and $opts_ref->{$number_of_violations ? '-files-with-violations' :
              '-files-without-violations'}
              and _out "$file\n";
          return $number_of_violations;
      }
  
      # Only report the number of violations, if asked.
      if( $opts_ref->{-count} ){
          ref $file || _out "$file: ";
          _out "$number_of_violations\n";
          return $number_of_violations;
      }
  
      # Hail all-clear unless we should shut up.
      if( !@violations && !$opts_ref->{-quiet} ) {
          ref $file || _out "$file ";
          _out "source OK\n";
          return 0;
      }
  
      # Otherwise, format and print violations
      my $verbosity = $critic->config->verbose();
      # $verbosity can be numeric or string, so use "eq" for comparison;
      $verbosity =
          ($verbosity eq $DEFAULT_VERBOSITY && @files > 1)
              ? $DEFAULT_VERBOSITY_WITH_FILE_NAME
              : $verbosity;
      my $fmt = Perl::Critic::Utils::verbosity_to_format( $verbosity );
      if (not -f $file) { $fmt =~ s< \%[fF] ><STDIN>xms; } #HACK!
      Perl::Critic::Violation::set_format( $fmt );
  
      my $color = $critic->config->color();
      _out $color ? _colorize_by_severity(@violations) : @violations;
  
      return $number_of_violations;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _set_up_pager {
      my ($pager_command) = @_;
      return if not $pager_command;
      return if not _at_tty();
  
      open my $pager, q<|->, $pager_command  ## no critic (InputOutput::RequireBriefOpen)
          or die qq<Unable to pipe to pager "$pager_command": $ERRNO\n>;
  
      $output = $pager;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _report_statistics {
      my ($opts_ref, $statistics) = @_;
  
      if (
              not $opts_ref->{'-statistics-only'}
          and (
                  $statistics->total_violations()
              or  not $opts_ref->{-quiet} and $statistics->modules()
          )
      ) {
          _out "\n"; # There's prior output that we want to separate from.
      }
  
      my $files = _commaify($statistics->modules());
      my $subroutines = _commaify($statistics->subs());
      my $statements = _commaify($statistics->statements_other_than_subs());
      my $lines = _commaify($statistics->lines());
      my $width = max map { length } $files, $subroutines, $statements;
  
      _out sprintf "%*s %s.\n", $width, $files, 'files';
      _out sprintf "%*s %s.\n", $width, $subroutines, 'subroutines/methods';
      _out sprintf "%*s %s.\n", $width, $statements, 'statements';
  
      my $lines_of_blank = _commaify( $statistics->lines_of_blank() );
      my $lines_of_comment = _commaify( $statistics->lines_of_comment() );
      my $lines_of_data = _commaify( $statistics->lines_of_data() );
      my $lines_of_perl = _commaify( $statistics->lines_of_perl() );
      my $lines_of_pod = _commaify( $statistics->lines_of_pod() );
  
      $width =
          max map { length }
              $lines_of_blank, $lines_of_comment, $lines_of_data,
              $lines_of_perl,  $lines_of_pod;
      _out sprintf "\n%s %s:\n",            $lines, 'lines, consisting of';
      _out sprintf "    %*s %s.\n", $width, $lines_of_blank, 'blank lines';
      _out sprintf "    %*s %s.\n", $width, $lines_of_comment, 'comment lines';
      _out sprintf "    %*s %s.\n", $width, $lines_of_data, 'data lines';
      _out sprintf "    %*s %s.\n", $width, $lines_of_perl, 'lines of Perl code';
      _out sprintf "    %*s %s.\n", $width, $lines_of_pod, 'lines of POD';
  
      my $average_sub_mccabe = $statistics->average_sub_mccabe();
      if (defined $average_sub_mccabe) {
          _out
              sprintf
                  "\nAverage McCabe score of subroutines was %.2f.\n",
                  $average_sub_mccabe;
          }
  
      _out "\n";
  
      _out _commaify($statistics->total_violations()), " violations.\n";
  
      my $violations_per_file = $statistics->violations_per_file();
      if (defined $violations_per_file) {
          _out
              sprintf
                  "Violations per file was %.3f.\n",
                  $violations_per_file;
      }
      my $violations_per_statement = $statistics->violations_per_statement();
      if (defined $violations_per_statement) {
          _out
              sprintf
                  "Violations per statement was %.3f.\n",
                  $violations_per_statement;
      }
      my $violations_per_line = $statistics->violations_per_line_of_code();
      if (defined $violations_per_line) {
          _out
              sprintf
                  "Violations per line of code was %.3f.\n",
                  $violations_per_line;
      }
  
      if ( $statistics->total_violations() ) {
          _out "\n";
  
          my %severity_violations = %{ $statistics->violations_by_severity() };
          my @severities = reverse sort keys %severity_violations;
          $width =
              max
                  map { length _commaify( $severity_violations{$_} ) }
                      @severities;
          foreach my $severity (@severities) {
              _out
                  sprintf
                      "%*s severity %d violations.\n",
                      $width,
                      _commaify( $severity_violations{$severity} ),
                      $severity;
          }
  
          _out "\n";
  
          my %policy_violations = %{ $statistics->violations_by_policy() };
          my @policies = sort keys %policy_violations;
          $width =
              max
                  map { length _commaify( $policy_violations{$_} ) }
                      @policies;
          foreach my $policy (@policies) {
              _out
                  sprintf
                      "%*s violations of %s.\n",
                      $width,
                      _commaify($policy_violations{$policy}),
                      policy_short_name($policy);
          }
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # Only works for integers.
  sub _commaify {
      my ( $number ) = @_;
  
      while ($number =~ s/ \A ( [-+]? \d+ ) ( \d{3} ) /$1,$2/xms) {
          # nothing
      }
  
      return $number;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_option_specification {
  
      return qw<
          5 4 3 2 1
          version
          brutal
          count|C
          cruel
          doc=s
          exclude=s@
          force!
          gentle
          harsh
          help|?|H
          include=s@
          list
          list-enabled
          list-themes
          man
          color|colour!
          noprofile
          only!
          options
          pager=s
          profile|p=s
          profile-proto
          quiet
          severity=i
          single-policy|s=s
          stern
          statistics!
          statistics-only!
          profile-strictness=s
          theme=s
          top:i
          allow-unsafe
          verbose=s
          color-severity-highest|colour-severity-highest|color-severity-5|colour-severity-5=s
          color-severity-high|colour-severity-high|color-severity-4|colour-severity-4=s
          color-severity-medium|colour-severity-medium|color-severity-3|colour-severity-3=s
          color-severity-low|colour-severity-low|color-severity-2|colour-severity-2=s
          color-severity-lowest|colour-severity-lowest|color-severity-1|colour-severity-1=s
          files-with-violations|l
          files-without-violations|L
          program-extensions=s@
      >;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _colorize_by_severity {
      my @violations = @_;
      return @violations if _this_is_windows() && !eval 'require Win32::Console::ANSI; 1';
      return @violations if not eval {
          require Term::ANSIColor;
          Term::ANSIColor->VERSION( $_MODULE_VERSION_TERM_ANSICOLOR );
          1;
      };
  
      my $config = $critic->config();
      my %color_of = (
          $SEVERITY_HIGHEST   => $config->color_severity_highest(),
          $SEVERITY_HIGH      => $config->color_severity_high(),
          $SEVERITY_MEDIUM    => $config->color_severity_medium(),
          $SEVERITY_LOW       => $config->color_severity_low(),
          $SEVERITY_LOWEST    => $config->color_severity_lowest(),
      );
  
      return map { _colorize( "$_", $color_of{$_->severity()} ) } @violations;
  
  }
  
  #-----------------------------------------------------------------------------
  
  sub _colorize {
      my ($string, $color) = @_;
      return $string if not defined $color;
      return $string if $color eq $EMPTY;
      # $terminator is a purely cosmetic change to make the color end at the end
      # of the line rather than right before the next line. It is here because
      # if you use background colors, some console windows display a little
      # fragment of colored background before the next uncolored (or
      # differently-colored) line.
      my $terminator = chomp $string ? "\n" : $EMPTY;
      return  Term::ANSIColor::colored( $string, $color ) . $terminator;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _this_is_windows {
      return 1 if $OSNAME =~ m/MSWin32/xms;
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _at_tty {
      return -t STDOUT; ## no critic (ProhibitInteractiveTest);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _render_all_policy_listing {
      # Force P-C parameters, to catch all Policies on this site
      my %pc_params = (-profile => $EMPTY, -severity => $SEVERITY_LOWEST);
      return _render_policy_listing( %pc_params );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _render_policy_listing {
      my %pc_params = @_;
  
      require Perl::Critic::PolicyListing;
      require Perl::Critic;
  
      my @policies = Perl::Critic->new( %pc_params )->policies();
      my $listing = Perl::Critic::PolicyListing->new( -policies => \@policies );
      _out $listing;
  
      exit $EXIT_SUCCESS;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _render_theme_listing {
  
      require Perl::Critic::ThemeListing;
      require Perl::Critic;
  
      my %pc_params = (-profile => $EMPTY, -severity => $SEVERITY_LOWEST);
      my @policies = Perl::Critic->new( %pc_params )->policies();
      my $listing = Perl::Critic::ThemeListing->new( -policies => \@policies );
      _out $listing;
  
      exit $EXIT_SUCCESS;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _render_profile_prototype {
  
      require Perl::Critic::ProfilePrototype;
      require Perl::Critic;
  
      my %pc_params = (-profile => $EMPTY, -severity => $SEVERITY_LOWEST);
      my @policies = Perl::Critic->new( %pc_params )->policies();
      my $prototype = Perl::Critic::ProfilePrototype->new( -policies => \@policies );
      _out $prototype;
  
      exit $EXIT_SUCCESS;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _render_policy_docs {
  
      my (%opts) = @_;
      my $pattern = delete $opts{-doc};
  
      require Perl::Critic;
      $critic = Perl::Critic->new(%opts);
      _set_up_pager($critic->config()->pager());
  
      require Perl::Critic::PolicyFactory;
      my @site_policies  = Perl::Critic::PolicyFactory->site_policy_names();
      my @matching_policies  = grep { /$pattern/ixms } @site_policies;
  
      # "-T" means don't send to pager
      my @perldoc_output = map {`perldoc -T $_`} @matching_policies;  ## no critic (ProhibitBacktick)
      _out @perldoc_output;
  
      exit $EXIT_SUCCESS;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _display_version {
      _out "$VERSION\n";
      exit $EXIT_SUCCESS;
  }
  
  #-----------------------------------------------------------------------------
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  Twitter
  
  =head1 NAME
  
  Perl::Critic::Command - Guts of L<perlcritic|perlcritic>.
  
  
  =head1 SYNOPSIS
  
      use Perl::Critic::Command qw< run >;
  
      local @ARGV = qw< --statistics-only lib bin >;
      run();
  
  
  =head1 DESCRIPTION
  
  This is the implementation of the L<perlcritic|perlcritic> command.  You can use
  this to run the command without going through a command interpreter.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  However, its interface is
  experimental, and will likely change.
  
  
  =head1 IMPORTABLE SUBROUTINES
  
  =over
  
  =item C<run()>
  
  Does the equivalent of the L<perlcritic|perlcritic> command.  Unfortunately, at
  present, this doesn't take any parameters but uses C<@ARGV> to get its
  input instead.  Count on this changing; don't count on the current
  interface.
  
  
  =back
  
  
  =head1 TO DO
  
  Make C<run()> take parameters.  The equivalent of C<@ARGV> should be
  passed as a reference.
  
  Turn this into an object.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_COMMAND

$fatpacked{"Perl/Critic/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_CONFIG';
  package Perl::Critic::Config;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use List::MoreUtils qw(any none apply);
  use Scalar::Util qw(blessed);
  
  use Perl::Critic::Exception::AggregateConfiguration;
  use Perl::Critic::Exception::Configuration;
  use Perl::Critic::Exception::Configuration::Option::Global::ParameterValue;
  use Perl::Critic::Exception::Fatal::Internal qw{ throw_internal };
  use Perl::Critic::PolicyFactory;
  use Perl::Critic::Theme qw( $RULE_INVALID_CHARACTER_REGEX cook_rule );
  use Perl::Critic::UserProfile qw();
  use Perl::Critic::Utils qw{
      :booleans :characters :severities :internal_lookup :classification
      :data_conversion
  };
  use Perl::Critic::Utils::Constants qw<
      :profile_strictness
      $_MODULE_VERSION_TERM_ANSICOLOR
  >;
  use Perl::Critic::Utils::DataConversion qw< boolean_to_number dor >;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $SINGLE_POLICY_CONFIG_KEY => 'single-policy';
  
  #-----------------------------------------------------------------------------
  # Constructor
  
  sub new {
  
      my ( $class, %args ) = @_;
      my $self = bless {}, $class;
      $self->_init( %args );
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init {
      my ( $self, %args ) = @_;
  
      # -top or -theme imply that -severity is 1, unless it is already defined
      if ( defined $args{-top} || defined $args{-theme} ) {
          $args{-severity} ||= $SEVERITY_LOWEST;
      }
  
      my $errors = Perl::Critic::Exception::AggregateConfiguration->new();
  
      # Construct the UserProfile to get default options.
      my $profile_source = $args{-profile}; # Can be file path or data struct
      my $profile = Perl::Critic::UserProfile->new( -profile => $profile_source );
      my $options_processor = $profile->options_processor();
      $self->{_profile} = $profile;
  
      $self->_validate_and_save_profile_strictness(
          $args{'-profile-strictness'},
          $errors,
      );
  
      # If given, these options should always have a true value.
      $self->_validate_and_save_regex(
          'include', $args{-include}, $options_processor->include(), $errors
      );
      $self->_validate_and_save_regex(
          'exclude', $args{-exclude}, $options_processor->exclude(), $errors
      );
      $self->_validate_and_save_regex(
          $SINGLE_POLICY_CONFIG_KEY,
          $args{ qq/-$SINGLE_POLICY_CONFIG_KEY/ },
          $options_processor->single_policy(),
          $errors,
      );
      $self->_validate_and_save_color_severity(
          'color_severity_highest', $args{'-color-severity-highest'},
          $options_processor->color_severity_highest(), $errors
      );
      $self->_validate_and_save_color_severity(
          'color_severity_high', $args{'-color-severity-high'},
          $options_processor->color_severity_high(), $errors
      );
      $self->_validate_and_save_color_severity(
          'color_severity_medium', $args{'-color-severity-medium'},
          $options_processor->color_severity_medium(), $errors
      );
      $self->_validate_and_save_color_severity(
          'color_severity_low', $args{'-color-severity-low'},
          $options_processor->color_severity_low(), $errors
      );
      $self->_validate_and_save_color_severity(
          'color_severity_lowest', $args{'-color-severity-lowest'},
          $options_processor->color_severity_lowest(), $errors
      );
  
      $self->_validate_and_save_verbosity($args{-verbose}, $errors);
      $self->_validate_and_save_severity($args{-severity}, $errors);
      $self->_validate_and_save_top($args{-top}, $errors);
      $self->_validate_and_save_theme($args{-theme}, $errors);
      $self->_validate_and_save_pager($args{-pager}, $errors);
      $self->_validate_and_save_program_extensions(
          $args{'-program-extensions'}, $errors);
  
      # If given, these options can be true or false (but defined)
      # We normalize these to numeric values by multiplying them by 1;
      $self->{_force} = boolean_to_number( dor( $args{-force}, $options_processor->force() ) );
      $self->{_only}  = boolean_to_number( dor( $args{-only},  $options_processor->only()  ) );
      $self->{_color} = boolean_to_number( dor( $args{-color}, $options_processor->color() ) );
      $self->{_unsafe_allowed} =
          boolean_to_number(
              dor( $args{'-allow-unsafe'}, $options_processor->allow_unsafe()
          ) );
      $self->{_criticism_fatal} =
          boolean_to_number(
              dor( $args{'-criticism-fatal'}, $options_processor->criticism_fatal() )
          );
  
  
      # Construct a Factory with the Profile
      my $factory =
          Perl::Critic::PolicyFactory->new(
              -profile              => $profile,
              -errors               => $errors,
              '-profile-strictness' => $self->profile_strictness(),
          );
      $self->{_factory} = $factory;
  
      # Initialize internal storage for Policies
      $self->{_all_policies_enabled_or_not} = [];
      $self->{_policies} = [];
  
      # "NONE" means don't load any policies
      if ( not defined $profile_source or $profile_source ne 'NONE' ) {
          # Heavy lifting here...
          $self->_load_policies($errors);
      }
  
      if ( $errors->has_exceptions() ) {
          $errors->rethrow();
      }
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_policy {
  
      my ( $self, %args ) = @_;
  
      if ( not $args{-policy} ) {
          throw_internal q{The -policy argument is required};
      }
  
      my $policy  = $args{-policy};
  
      # If the -policy is already a blessed object, then just add it directly.
      if ( blessed $policy ) {
          $self->_add_policy_if_enabled($policy);
          return $self;
      }
  
      # NOTE: The "-config" option is supported for backward compatibility.
      my $params = $args{-params} || $args{-config};
  
      my $factory       = $self->{_factory};
      my $policy_object =
          $factory->create_policy(-name=>$policy, -params=>$params);
      $self->_add_policy_if_enabled($policy_object);
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _add_policy_if_enabled {
      my ( $self, $policy_object ) = @_;
  
      my $config = $policy_object->__get_config()
          or throw_internal
              q{Policy was not set up properly because it does not have }
                  . q{a value for its config attribute.};
  
      push @{ $self->{_all_policies_enabled_or_not} }, $policy_object;
      if ( $policy_object->initialize_if_enabled( $config ) ) {
          $policy_object->__set_enabled($TRUE);
          push @{ $self->{_policies} }, $policy_object;
      }
      else {
          $policy_object->__set_enabled($FALSE);
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _load_policies {
  
      my ( $self, $errors ) = @_;
      my $factory  = $self->{_factory};
      my @policies = $factory->create_all_policies( $errors );
  
      return if $errors->has_exceptions();
  
      for my $policy ( @policies ) {
  
          # If -single-policy is true, only load policies that match it
          if ( $self->single_policy() ) {
              if ( $self->_policy_is_single_policy( $policy ) ) {
                  $self->add_policy( -policy => $policy );
              }
              next;
          }
  
          # Always exclude unsafe policies, unless instructed not to
          next if not ( $policy->is_safe() or $self->unsafe_allowed() );
  
          # To load, or not to load -- that is the question.
          my $load_me = $self->only() ? $FALSE : $TRUE;
  
          ## no critic (ProhibitPostfixControls)
          $load_me = $FALSE if     $self->_policy_is_disabled( $policy );
          $load_me = $TRUE  if     $self->_policy_is_enabled( $policy );
          $load_me = $FALSE if     $self->_policy_is_unimportant( $policy );
          $load_me = $FALSE if not $self->_policy_is_thematic( $policy );
          $load_me = $TRUE  if     $self->_policy_is_included( $policy );
          $load_me = $FALSE if     $self->_policy_is_excluded( $policy );
  
  
          next if not $load_me;
          $self->add_policy( -policy => $policy );
      }
  
      # When using -single-policy, only one policy should ever be loaded.
      if ($self->single_policy() && scalar $self->policies() != 1) {
          $self->_add_single_policy_exception_to($errors);
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_disabled {
      my ($self, $policy) = @_;
      my $profile = $self->_profile();
      return $profile->policy_is_disabled( $policy );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_enabled {
      my ($self, $policy) = @_;
      my $profile = $self->_profile();
      return $profile->policy_is_enabled( $policy );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_thematic {
      my ($self, $policy) = @_;
      my $theme = $self->theme();
      return $theme->policy_is_thematic( -policy => $policy );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_unimportant {
      my ($self, $policy) = @_;
      my $policy_severity = $policy->get_severity();
      my $min_severity    = $self->{_severity};
      return $policy_severity < $min_severity;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_included {
      my ($self, $policy) = @_;
      my $policy_long_name = ref $policy;
      my @inclusions  = $self->include();
      return any { $policy_long_name =~ m/$_/ixms } @inclusions;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_excluded {
      my ($self, $policy) = @_;
      my $policy_long_name = ref $policy;
      my @exclusions  = $self->exclude();
      return any { $policy_long_name =~ m/$_/ixms } @exclusions;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _policy_is_single_policy {
      my ($self, $policy) = @_;
  
      my @patterns = $self->single_policy();
      return if not @patterns;
  
      my $policy_long_name = ref $policy;
      return any { $policy_long_name =~ m/$_/ixms } @patterns;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _new_global_value_exception {
      my ($self, @args) = @_;
  
      return
          Perl::Critic::Exception::Configuration::Option::Global::ParameterValue
              ->new(@args);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _add_single_policy_exception_to {
      my ($self, $errors) = @_;
  
      my $message_suffix = $EMPTY;
      my $patterns = join q{", "}, $self->single_policy();
  
      if (scalar $self->policies() == 0) {
          $message_suffix =
              q{did not match any policies (in combination with }
                  . q{other policy restrictions).};
      }
      else {
          $message_suffix  = qq{matched multiple policies:\n\t};
          $message_suffix .= join qq{,\n\t}, apply { chomp } sort $self->policies();
      }
  
      $errors->add_exception(
          $self->_new_global_value_exception(
              option_name     => $SINGLE_POLICY_CONFIG_KEY,
              option_value    => $patterns,
              message_suffix  => $message_suffix,
          )
      );
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_regex {
      my ($self, $option_name, $args_value, $default_value, $errors) = @_;
  
      my $full_option_name;
      my $source;
      my @regexes;
  
      if ($args_value) {
          $full_option_name = "-$option_name";
  
          if (ref $args_value) {
              @regexes = @{ $args_value };
          }
          else {
              @regexes = ( $args_value );
          }
      }
  
      if (not @regexes) {
          $full_option_name = $option_name;
          $source = $self->_profile()->source();
  
          if (ref $default_value) {
              @regexes = @{ $default_value };
          }
          elsif ($default_value) {
              @regexes = ( $default_value );
          }
      }
  
      my $found_errors;
      foreach my $regex (@regexes) {
          eval { qr/$regex/ixms }
              or do {
                  my $cleaned_error = $EVAL_ERROR || '<unknown reason>';
                  $cleaned_error =~
                      s/ [ ] at [ ] .* Config [.] pm [ ] line [ ] \d+ [.] \n? \z/./xms;
  
                  $errors->add_exception(
                      $self->_new_global_value_exception(
                          option_name     => $option_name,
                          option_value    => $regex,
                          source          => $source,
                          message_suffix  => qq{is not valid: $cleaned_error},
                      )
                  );
  
                  $found_errors = 1;
              }
      }
  
      if (not $found_errors) {
          my $option_key = $option_name;
          $option_key =~ s/ - /_/xmsg;
  
          $self->{"_$option_key"} = \@regexes;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_profile_strictness {
      my ($self, $args_value, $errors) = @_;
  
      my $option_name;
      my $source;
      my $profile_strictness;
  
      if ($args_value) {
          $option_name = '-profile-strictness';
          $profile_strictness = $args_value;
      }
      else {
          $option_name = 'profile-strictness';
  
          my $profile = $self->_profile();
          $source = $profile->source();
          $profile_strictness = $profile->options_processor()->profile_strictness();
      }
  
      if ( not $PROFILE_STRICTNESSES{$profile_strictness} ) {
          $errors->add_exception(
              $self->_new_global_value_exception(
                  option_name     => $option_name,
                  option_value    => $profile_strictness,
                  source          => $source,
                  message_suffix  => q{is not one of "}
                      . join ( q{", "}, (sort keys %PROFILE_STRICTNESSES) )
                      . q{".},
              )
          );
  
          $profile_strictness = $PROFILE_STRICTNESS_FATAL;
      }
  
      $self->{_profile_strictness} = $profile_strictness;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_verbosity {
      my ($self, $args_value, $errors) = @_;
  
      my $option_name;
      my $source;
      my $verbosity;
  
      if ($args_value) {
          $option_name = '-verbose';
          $verbosity = $args_value;
      }
      else {
          $option_name = 'verbose';
  
          my $profile = $self->_profile();
          $source = $profile->source();
          $verbosity = $profile->options_processor()->verbose();
      }
  
      if (
              is_integer($verbosity)
          and not is_valid_numeric_verbosity($verbosity)
      ) {
          $errors->add_exception(
              $self->_new_global_value_exception(
                  option_name     => $option_name,
                  option_value    => $verbosity,
                  source          => $source,
                  message_suffix  =>
                      'is not the number of one of the pre-defined verbosity formats.',
              )
          );
      }
      else {
          $self->{_verbose} = $verbosity;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_severity {
      my ($self, $args_value, $errors) = @_;
  
      my $option_name;
      my $source;
      my $severity;
  
      if ($args_value) {
          $option_name = '-severity';
          $severity = $args_value;
      }
      else {
          $option_name = 'severity';
  
          my $profile = $self->_profile();
          $source = $profile->source();
          $severity = $profile->options_processor()->severity();
      }
  
      if ( is_integer($severity) ) {
          if (
              $severity >= $SEVERITY_LOWEST and $severity <= $SEVERITY_HIGHEST
          ) {
              $self->{_severity} = $severity;
          }
          else {
              $errors->add_exception(
                  $self->_new_global_value_exception(
                      option_name     => $option_name,
                      option_value    => $severity,
                      source          => $source,
                      message_suffix  =>
                          "is not between $SEVERITY_LOWEST (low) and $SEVERITY_HIGHEST (high).",
                  )
              );
          }
      }
      elsif ( not any { $_ eq lc $severity } @SEVERITY_NAMES ) {
          $errors->add_exception(
              $self->_new_global_value_exception(
                  option_name     => $option_name,
                  option_value    => $severity,
                  source          => $source,
                  message_suffix  =>
                      q{is not one of the valid severity names: "}
                          . join (q{", "}, @SEVERITY_NAMES)
                          . q{".},
              )
          );
      }
      else {
          $self->{_severity} = severity_to_number($severity);
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_top {
      my ($self, $args_value, $errors) = @_;
  
      my $option_name;
      my $source;
      my $top;
  
      if (defined $args_value and $args_value ne q{}) {
          $option_name = '-top';
          $top = $args_value;
      }
      else {
          $option_name = 'top';
  
          my $profile = $self->_profile();
          $source = $profile->source();
          $top = $profile->options_processor()->top();
      }
  
      if ( is_integer($top) and $top >= 0 ) {
          $self->{_top} = $top;
      }
      else {
          $errors->add_exception(
              $self->_new_global_value_exception(
                  option_name     => $option_name,
                  option_value    => $top,
                  source          => $source,
                  message_suffix  => q{is not a non-negative integer.},
              )
          );
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_theme {
      my ($self, $args_value, $errors) = @_;
  
      my $option_name;
      my $source;
      my $theme_rule;
  
      if ($args_value) {
          $option_name = '-theme';
          $theme_rule = $args_value;
      }
      else {
          $option_name = 'theme';
  
          my $profile = $self->_profile();
          $source = $profile->source();
          $theme_rule = $profile->options_processor()->theme();
      }
  
      if ( $theme_rule =~ m/$RULE_INVALID_CHARACTER_REGEX/xms ) {
          my $bad_character = $1;
  
          $errors->add_exception(
              $self->_new_global_value_exception(
                  option_name     => $option_name,
                  option_value    => $theme_rule,
                  source          => $source,
                  message_suffix  =>
                      qq{contains an illegal character ("$bad_character").},
              )
          );
      }
      else {
          my $rule_as_code = cook_rule($theme_rule);
          $rule_as_code =~ s/ [\w\d]+ / 1 /gxms;
  
          # eval of an empty string does not reset $@ in Perl 5.6.
          local $EVAL_ERROR = $EMPTY;
          eval $rule_as_code; ## no critic (ProhibitStringyEval, RequireCheckingReturnValueOfEval)
  
          if ($EVAL_ERROR) {
              $errors->add_exception(
                  $self->_new_global_value_exception(
                      option_name     => $option_name,
                      option_value    => $theme_rule,
                      source          => $source,
                      message_suffix  => q{is not syntactically valid.},
                  )
              );
          }
          else {
              eval {
                  $self->{_theme} =
                      Perl::Critic::Theme->new( -rule => $theme_rule );
              }
                  or do {
                      $errors->add_exception_or_rethrow( $EVAL_ERROR );
                  };
          }
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_pager {
      my ($self, $args_value, $errors) = @_;
  
      my $pager;
      if ( $args_value ) {
          $pager = defined $args_value ? $args_value : $EMPTY;
      }
      elsif ( $ENV{PERLCRITIC_PAGER} ) {
          $pager = $ENV{PERLCRITIC_PAGER};
      }
      else {
          my $profile = $self->_profile();
          $pager = $profile->options_processor()->pager();
      }
  
      if ($pager eq '$PAGER') {   ## no critic (RequireInterpolationOfMetachars)
          $pager = $ENV{PAGER};
      }
      $pager ||= $EMPTY;
  
      $self->{_pager} = $pager;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_color_severity {
      my ($self, $option_name, $args_value, $default_value, $errors) = @_;
  
      my $source;
      my $color_severity;
      my $full_option_name;
  
      if (defined $args_value) {
          $full_option_name = "-$option_name";
          $color_severity = lc $args_value;
      }
      else {
          $full_option_name = $option_name;
          $source = $self->_profile()->source();
          $color_severity = lc $default_value;
      }
      $color_severity =~ s/ \s+ / /xmsg;
      $color_severity =~ s/ \A\s+ //xms;
      $color_severity =~ s/ \s+\z //xms;
      $full_option_name =~ s/ _ /-/xmsg;
  
      # Should we really be validating this?
      my $found_errors;
      if (
          eval {
              require Term::ANSIColor;
              Term::ANSIColor->VERSION( $_MODULE_VERSION_TERM_ANSICOLOR );
              1;
          }
      ) {
          $found_errors =
              not Term::ANSIColor::colorvalid( words_from_string($color_severity) );
      }
  
      # If we do not have Term::ANSIColor we can not validate, but we store the
      # values anyway for the benefit of Perl::Critic::ProfilePrototype.
  
      if ($found_errors) {
          $errors->add_exception(
              $self->_new_global_value_exception(
                  option_name     => $full_option_name,
                  option_value    => $color_severity,
                  source          => $source,
                  message_suffix  => 'is not valid.',
              )
          );
      }
      else {
          my $option_key = $option_name;
          $option_key =~ s/ - /_/xmsg;
  
          $self->{"_$option_key"} = $color_severity;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_and_save_program_extensions {
      my ($self, $args_value, $errors) = @_;
  
      delete $self->{_program_extensions_as_regexes};
  
      my $extension_list = q{ARRAY} eq ref $args_value ?
          [map {words_from_string($_)} @{ $args_value }] :
          $self->_profile()->options_processor()->program_extensions();
  
      my %program_extensions = hashify( @{ $extension_list } );
  
      $self->{_program_extensions} = [keys %program_extensions];
  
      return;
  
  }
  
  #-----------------------------------------------------------------------------
  # Begin ACCESSSOR methods
  
  sub _profile {
      my ($self) = @_;
      return $self->{_profile};
  }
  
  #-----------------------------------------------------------------------------
  
  sub all_policies_enabled_or_not {
      my ($self) = @_;
      return @{ $self->{_all_policies_enabled_or_not} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub policies {
      my ($self) = @_;
      return @{ $self->{_policies} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub exclude {
      my ($self) = @_;
      return @{ $self->{_exclude} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub force {
      my ($self) = @_;
      return $self->{_force};
  }
  
  #-----------------------------------------------------------------------------
  
  sub include {
      my ($self) = @_;
      return @{ $self->{_include} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub only {
      my ($self) = @_;
      return $self->{_only};
  }
  
  #-----------------------------------------------------------------------------
  
  sub profile_strictness {
      my ($self) = @_;
      return $self->{_profile_strictness};
  }
  
  #-----------------------------------------------------------------------------
  
  sub severity {
      my ($self) = @_;
      return $self->{_severity};
  }
  
  #-----------------------------------------------------------------------------
  
  sub single_policy {
      my ($self) = @_;
      return @{ $self->{_single_policy} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub theme {
      my ($self) = @_;
      return $self->{_theme};
  }
  
  #-----------------------------------------------------------------------------
  
  sub top {
      my ($self) = @_;
      return $self->{_top};
  }
  
  #-----------------------------------------------------------------------------
  
  sub verbose {
      my ($self) = @_;
      return $self->{_verbose};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color {
      my ($self) = @_;
      return $self->{_color};
  }
  
  #-----------------------------------------------------------------------------
  
  sub pager  {
      my ($self) = @_;
      return $self->{_pager};
  }
  
  #-----------------------------------------------------------------------------
  
  sub unsafe_allowed {
      my ($self) = @_;
      return $self->{_unsafe_allowed};
  }
  
  #-----------------------------------------------------------------------------
  
  sub criticism_fatal {
      my ($self) = @_;
      return $self->{_criticism_fatal};
  }
  
  #-----------------------------------------------------------------------------
  
  sub site_policy_names {
      return Perl::Critic::PolicyFactory::site_policy_names();
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_highest {
      my ($self) = @_;
      return $self->{_color_severity_highest};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_high {
      my ($self) = @_;
      return $self->{_color_severity_high};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_medium {
      my ($self) = @_;
      return $self->{_color_severity_medium};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_low {
      my ($self) = @_;
      return $self->{_color_severity_low};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_lowest {
      my ($self) = @_;
      return $self->{_color_severity_lowest};
  }
  
  #-----------------------------------------------------------------------------
  
  sub program_extensions {
      my ($self) = @_;
      return @{ $self->{_program_extensions} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub program_extensions_as_regexes {
      my ($self) = @_;
  
      return @{ $self->{_program_extensions_as_regexes} }
          if $self->{_program_extensions_as_regexes};
  
      my %program_extensions = hashify( $self->program_extensions() );
      $program_extensions{'.PL'} = 1;
      return @{
          $self->{_program_extensions_as_regexes} = [
              map { qr< @{[quotemeta $_]} \z >smx } sort keys %program_extensions
          ]
      };
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords colour INI-style -params
  
  =head1 NAME
  
  Perl::Critic::Config - The final derived Perl::Critic configuration, combined from any profile file and command-line parameters.
  
  
  =head1 DESCRIPTION
  
  Perl::Critic::Config takes care of finding and processing
  user-preferences for L<Perl::Critic|Perl::Critic>.  The Config object
  defines which Policy modules will be loaded into the Perl::Critic
  engine and how they should be configured.  You should never really
  need to instantiate Perl::Critic::Config directly because the
  Perl::Critic constructor will do it for you.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new(...) >>
  
  Not properly documented because you shouldn't be using this.
  
  
  =back
  
  =head1 METHODS
  
  =over
  
  =item C<< add_policy( -policy => $policy_name, -params => \%param_hash ) >>
  
  Creates a Policy object and loads it into this Config.  If the object
  cannot be instantiated, it will throw a fatal exception.  Otherwise,
  it returns a reference to this Critic.
  
  B<-policy> is the name of a
  L<Perl::Critic::Policy|Perl::Critic::Policy> subclass module.  The
  C<'Perl::Critic::Policy'> portion of the name can be omitted for
  brevity.  This argument is required.
  
  B<-params> is an optional reference to a hash of Policy parameters.
  The contents of this hash reference will be passed into to the
  constructor of the Policy module.  See the documentation in the
  relevant Policy module for a description of the arguments it supports.
  
  
  =item C< all_policies_enabled_or_not() >
  
  Returns a list containing references to all the Policy objects that
  have been seen.  Note that the state of these objects is not
  trustworthy.  In particular, it is likely that some of them are not
  prepared to examine any documents.
  
  
  =item C< policies() >
  
  Returns a list containing references to all the Policy objects that
  have been enabled and loaded into this Config.
  
  
  =item C< exclude() >
  
  Returns the value of the C<-exclude> attribute for this Config.
  
  
  =item C< include() >
  
  Returns the value of the C<-include> attribute for this Config.
  
  
  =item C< force() >
  
  Returns the value of the C<-force> attribute for this Config.
  
  
  =item C< only() >
  
  Returns the value of the C<-only> attribute for this Config.
  
  
  =item C< profile_strictness() >
  
  Returns the value of the C<-profile-strictness> attribute for this
  Config.
  
  
  =item C< severity() >
  
  Returns the value of the C<-severity> attribute for this Config.
  
  
  =item C< single_policy() >
  
  Returns the value of the C<-single-policy> attribute for this Config.
  
  
  =item C< theme() >
  
  Returns the L<Perl::Critic::Theme|Perl::Critic::Theme> object that was
  created for this Config.
  
  
  =item C< top() >
  
  Returns the value of the C<-top> attribute for this Config.
  
  
  =item C< verbose() >
  
  Returns the value of the C<-verbose> attribute for this Config.
  
  
  =item C< color() >
  
  Returns the value of the C<-color> attribute for this Config.
  
  
  =item C< pager() >
  
  Returns the value of the C<-pager> attribute for this Config.
  
  
  =item C< unsafe_allowed() >
  
  Returns the value of the C<-allow-unsafe> attribute for this Config.
  
  
  =item C< criticism_fatal() >
  
  Returns the value of the C<-criticism-fatal> attribute for this Config.
  
  
  =item C< color_severity_highest() >
  
  Returns the value of the C<-color-severity-highest> attribute for this
  Config.
  
  
  =item C< color_severity_high() >
  
  Returns the value of the C<-color-severity-high> attribute for this
  Config.
  
  
  =item C< color_severity_medium() >
  
  Returns the value of the C<-color-severity-medium> attribute for this
  Config.
  
  
  =item C< color_severity_low() >
  
  Returns the value of the C<-color-severity-low> attribute for this
  Config.
  
  
  =item C< color_severity_lowest() >
  
  Returns the value of the C<-color-severity-lowest> attribute for this
  Config.
  
  =item C< program_extensions() >
  
  Returns the value of the C<-program_extensions> attribute for this Config.
  This is an array of the file name extensions that represent program files.
  
  =item C< program_extensions_as_regexes() >
  
  Returns the value of the C<-program_extensions> attribute for this Config, as
  an array of case-sensitive regexes matching the ends of the file names that
  represent program files.
  
  =back
  
  
  =head1 SUBROUTINES
  
  Perl::Critic::Config has a few static subroutines that are used
  internally, but may be useful to you in some way.
  
  
  =over
  
  =item C<site_policy_names()>
  
  Returns a list of all the Policy modules that are currently installed
  in the Perl::Critic:Policy namespace.  These will include modules that
  are distributed with Perl::Critic plus any third-party modules that
  have been installed.
  
  
  =back
  
  
  =head1 CONFIGURATION
  
  Most of the settings for Perl::Critic and each of the Policy modules
  can be controlled by a configuration file.  The default configuration
  file is called F<.perlcriticrc>.
  L<Perl::Critic::Config|Perl::Critic::Config> will look for this file
  in the current directory first, and then in your home directory.
  Alternatively, you can set the C<PERLCRITIC> environment variable to
  explicitly point to a different file in another location.  If none of
  these files exist, and the C<-profile> option is not given to the
  constructor, then all Policies will be loaded with their default
  configuration.
  
  The format of the configuration file is a series of INI-style blocks
  that contain key-value pairs separated by '='. Comments should start
  with '#' and can be placed on a separate line or after the name-value
  pairs if you desire.
  
  Default settings for Perl::Critic itself can be set B<before the first
  named block.>  For example, putting any or all of these at the top of
  your configuration file will set the default value for the
  corresponding Perl::Critic constructor argument.
  
      severity  = 3                                     #Integer from 1 to 5
      only      = 1                                     #Zero or One
      force     = 0                                     #Zero or One
      verbose   = 4                                     #Integer or format spec
      top       = 50                                    #A positive integer
      theme     = risky + (pbp * security) - cosmetic   #A theme expression
      include   = NamingConventions ClassHierarchies    #Space-delimited list
      exclude   = Variables  Modules::RequirePackage    #Space-delimited list
      color     = 1                                     #Zero or One
      allow_unsafe = 1                                  #Zero or One
      color-severity-highest = bold red                 #Term::ANSIColor
      color-severity-high = magenta                     #Term::ANSIColor
      color-severity-medium =                           #no coloring
      color-severity-low =                              #no coloring
      color-severity-lowest =                           #no coloring
      program-extensions =                              #Space-delimited list
  
  The remainder of the configuration file is a series of blocks like
  this:
  
      [Perl::Critic::Policy::Category::PolicyName]
      severity = 1
      set_themes = foo bar
      add_themes = baz
      arg1 = value1
      arg2 = value2
  
  C<Perl::Critic::Policy::Category::PolicyName> is the full name of a
  module that implements the policy.  The Policy modules distributed
  with Perl::Critic have been grouped into categories according to the
  table of contents in Damian Conway's book B<Perl Best Practices>. For
  brevity, you can omit the C<'Perl::Critic::Policy'> part of the module
  name.
  
  C<severity> is the level of importance you wish to assign to the
  Policy.  All Policy modules are defined with a default severity value
  ranging from 1 (least severe) to 5 (most severe).  However, you may
  disagree with the default severity and choose to give it a higher or
  lower severity, based on your own coding philosophy.
  
  The remaining key-value pairs are configuration parameters that will
  be passed into the constructor of that Policy.  The constructors for
  most Policy modules do not support arguments, and those that do should
  have reasonable defaults.  See the documentation on the appropriate
  Policy module for more details.
  
  Instead of redefining the severity for a given Policy, you can
  completely disable a Policy by prepending a '-' to the name of the
  module in your configuration file.  In this manner, the Policy will
  never be loaded, regardless of the C<-severity> given to the
  Perl::Critic::Config constructor.
  
  A simple configuration might look like this:
  
      #--------------------------------------------------------------
      # I think these are really important, so always load them
  
      [TestingAndDebugging::RequireUseStrict]
      severity = 5
  
      [TestingAndDebugging::RequireUseWarnings]
      severity = 5
  
      #--------------------------------------------------------------
      # I think these are less important, so only load when asked
  
      [Variables::ProhibitPackageVars]
      severity = 2
  
      [ControlStructures::ProhibitPostfixControls]
      allow = if unless  #My custom configuration
      severity = 2
  
      #--------------------------------------------------------------
      # Give these policies a custom theme.  I can activate just
      # these policies by saying (-theme => 'larry + curly')
  
      [Modules::RequireFilenameMatchesPackage]
      add_themes = larry
  
      [TestingAndDebugging::RequireTestLables]
      add_themes = curly moe
  
      #--------------------------------------------------------------
      # I do not agree with these at all, so never load them
  
      [-NamingConventions::Capitalization]
      [-ValuesAndExpressions::ProhibitMagicNumbers]
  
      #--------------------------------------------------------------
      # For all other Policies, I accept the default severity, theme
      # and other parameters, so no additional configuration is
      # required for them.
  
  For additional configuration examples, see the F<perlcriticrc> file
  that is included in this F<t/examples> directory of this distribution.
  
  
  =head1 THE POLICIES
  
  A large number of Policy modules are distributed with Perl::Critic.
  They are described briefly in the companion document
  L<Perl::Critic::PolicySummary|Perl::Critic::PolicySummary> and in more
  detail in the individual modules themselves.
  
  
  =head1 POLICY THEMES
  
  Each Policy is defined with one or more "themes".  Themes can be used
  to create arbitrary groups of Policies.  They are intended to provide
  an alternative mechanism for selecting your preferred set of Policies.
  For example, you may wish disable a certain subset of Policies when
  analyzing test programs.  Conversely, you may wish to enable only a
  specific subset of Policies when analyzing modules.
  
  The Policies that ship with Perl::Critic are have been broken into the
  following themes.  This is just our attempt to provide some basic
  logical groupings.  You are free to invent new themes that suit your
  needs.
  
      THEME             DESCRIPTION
      --------------------------------------------------------------------------
      core              All policies that ship with Perl::Critic
      pbp               Policies that come directly from "Perl Best Practices"
      bugs              Policies that prevent or reveal bugs
      maintenance       Policies that affect the long-term health of the code
      cosmetic          Policies that only have a superficial effect
      complexity        Policies that specificaly relate to code complexity
      security          Policies that relate to security issues
      tests             Policies that are specific to test programs
  
  Say C<`perlcritic -list`> to get a listing of all available policies
  and the themes that are associated with each one.  You can also change
  the theme for any Policy in your F<.perlcriticrc> file.  See the
  L<"CONFIGURATION"> section for more information about that.
  
  Using the C<-theme> option, you can combine theme names with
  mathematical and boolean operators to create an arbitrarily complex
  expression that represents a custom "set" of Policies.  The following
  operators are supported
  
     Operator       Alternative         Meaning
     ----------------------------------------------------------------------------
     *              and                 Intersection
     -              not                 Difference
     +              or                  Union
  
  Operator precedence is the same as that of normal mathematics.  You
  can also use parenthesis to enforce precedence.  Here are some
  examples:
  
     Expression                  Meaning
     ----------------------------------------------------------------------------
     pbp * bugs                  All policies that are "pbp" AND "bugs"
     pbp and bugs                Ditto
  
     bugs + cosmetic             All policies that are "bugs" OR "cosmetic"
     bugs or cosmetic            Ditto
  
     pbp - cosmetic              All policies that are "pbp" BUT NOT "cosmetic"
     pbp not cosmetic            Ditto
  
     -maintenance                All policies that are NOT "maintenance"
     not maintenance             Ditto
  
     (pbp - bugs) * complexity     All policies that are "pbp" BUT NOT "bugs",
                                      AND "complexity"
     (pbp not bugs) and complexity  Ditto
  
  Theme names are case-insensitive.  If C<-theme> is set to an empty
  string, then it is equivalent to the set of all Policies.  A theme
  name that doesn't exist is equivalent to an empty set.  Please See
  L<http://en.wikipedia.org/wiki/Set> for a discussion on set theory.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::OptionsProcessor|Perl::Critic::OptionsProcessor>,
  L<Perl::Critic::UserProfile|Perl::Critic::UserProfile>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_CONFIG

$fatpacked{"Perl/Critic/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_DOCUMENT';
  package Perl::Critic::Document;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp qw< confess >;
  
  use List::Util qw< reduce >;
  use Scalar::Util qw< blessed refaddr weaken >;
  use version;
  
  use PPI::Document;
  use PPI::Document::File;
  use PPIx::Utilities::Node qw< split_ppi_node_by_namespace >;
  
  use Perl::Critic::Annotation;
  use Perl::Critic::Exception::Parse qw< throw_parse >;
  use Perl::Critic::Utils qw< :booleans :characters shebang_line >;
  
  use PPIx::Regexp 0.010 qw< >;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  our $AUTOLOAD;
  sub AUTOLOAD {  ## no critic (ProhibitAutoloading,ArgUnpacking)
      my ( $function_name ) = $AUTOLOAD =~ m/ ([^:\']+) \z /xms;
      return if $function_name eq 'DESTROY';
      my $self = shift;
      return $self->{_doc}->$function_name(@_);
  }
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, @args) = @_;
  
      my $self = bless {}, $class;
  
      $self->_init_common();
      $self->_init_from_external_source(@args);
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _new_for_parent_document {
      my ($class, $ppi_document, $parent_document) = @_;
  
      my $self = bless {}, $class;
  
      $self->_init_common();
  
      $self->{_doc}       = $ppi_document;
      $self->{_is_module} = $parent_document->is_module();
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init_common {
      my ($self) = @_;
  
      $self->{_annotations} = [];
      $self->{_suppressed_violations} = [];
      $self->{_disabled_line_map} = {};
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init_from_external_source { ## no critic (Subroutines::RequireArgUnpacking)
      my $self = shift;
      my %args;
  
      if (@_ == 1) {
          warnings::warnif(
              'deprecated',
              'Perl::Critic::Document->new($source) deprecated, use Perl::Critic::Document->new(-source => $source) instead.' ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
          );
          %args = ('-source' => shift);
      } else {
          %args = @_;
      }
  
      my $source_code = $args{'-source'};
  
      # $source_code can be a file name, or a reference to a
      # PPI::Document, or a reference to a scalar containing source
      # code.  In the last case, PPI handles the translation for us.
  
      my $ppi_document =
          _is_ppi_doc($source_code)
              ? $source_code
              : ref $source_code
                  ? PPI::Document->new($source_code)
                  : PPI::Document::File->new($source_code);
  
      # Bail on error
      if (not defined $ppi_document) {
          my $errstr   = PPI::Document::errstr();
          my $file     = ref $source_code ? undef : $source_code;
          throw_parse
              message     => qq<Can't parse code: $errstr>,
              file_name   => $file;
      }
  
      $self->{_doc} = $ppi_document;
      $self->index_locations();
      $self->_disable_shebang_fix();
      $self->{_filename_override} = $args{'-filename-override'};
      $self->{_is_module} = $self->_determine_is_module(\%args);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_ppi_doc {
      my ($ref) = @_;
      return blessed($ref) && $ref->isa('PPI::Document');
  }
  
  #-----------------------------------------------------------------------------
  
  sub ppi_document {
      my ($self) = @_;
      return $self->{_doc};
  }
  
  #-----------------------------------------------------------------------------
  
  sub isa {
      my ($self, @args) = @_;
      return $self->SUPER::isa(@args)
          || ( (ref $self) && $self->{_doc} && $self->{_doc}->isa(@args) );
  }
  
  #-----------------------------------------------------------------------------
  
  sub find {
      my ($self, $wanted, @more_args) = @_;
  
      # This method can only find elements by their class names.  For
      # other types of searches, delegate to the PPI::Document
      if ( ( ref $wanted ) || !$wanted || $wanted !~ m/ \A PPI:: /xms ) {
          return $self->{_doc}->find($wanted, @more_args);
      }
  
      # Build the class cache if it doesn't exist.  This happens at most
      # once per Perl::Critic::Document instance.  %elements of will be
      # populated as a side-effect of calling the $finder_sub coderef
      # that is produced by the caching_finder() closure.
      if ( !$self->{_elements_of} ) {
  
          my %cache = ( 'PPI::Document' => [ $self ] );
  
          # The cache refers to $self, and $self refers to the cache.  This
          # creates a circular reference that leaks memory (i.e.  $self is not
          # destroyed until execution is complete).  By weakening the reference,
          # we allow perl to collect the garbage properly.
          weaken( $cache{'PPI::Document'}->[0] );
  
          my $finder_coderef = _caching_finder( \%cache );
          $self->{_doc}->find( $finder_coderef );
          $self->{_elements_of} = \%cache;
      }
  
      # find() must return false-but-defined on fail
      return $self->{_elements_of}->{$wanted} || q{};
  }
  
  #-----------------------------------------------------------------------------
  
  sub find_first {
      my ($self, $wanted, @more_args) = @_;
  
      # This method can only find elements by their class names.  For
      # other types of searches, delegate to the PPI::Document
      if ( ( ref $wanted ) || !$wanted || $wanted !~ m/ \A PPI:: /xms ) {
          return $self->{_doc}->find_first($wanted, @more_args);
      }
  
      my $result = $self->find($wanted);
      return $result ? $result->[0] : $result;
  }
  
  #-----------------------------------------------------------------------------
  
  sub find_any {
      my ($self, $wanted, @more_args) = @_;
  
      # This method can only find elements by their class names.  For
      # other types of searches, delegate to the PPI::Document
      if ( ( ref $wanted ) || !$wanted || $wanted !~ m/ \A PPI:: /xms ) {
          return $self->{_doc}->find_any($wanted, @more_args);
      }
  
      my $result = $self->find($wanted);
      return $result ? 1 : $result;
  }
  
  #-----------------------------------------------------------------------------
  
  sub namespaces {
      my ($self) = @_;
  
      return keys %{ $self->_nodes_by_namespace() };
  }
  
  #-----------------------------------------------------------------------------
  
  sub subdocuments_for_namespace {
      my ($self, $namespace) = @_;
  
      my $subdocuments = $self->_nodes_by_namespace()->{$namespace};
  
      return $subdocuments ? @{$subdocuments} : ();
  }
  
  #-----------------------------------------------------------------------------
  
  sub ppix_regexp_from_element {
      my ( $self, $element ) = @_;
  
      if ( blessed( $element ) && $element->isa( 'PPI::Element' ) ) {
          my $addr = refaddr( $element );
          return $self->{_ppix_regexp_from_element}{$addr}
              if exists $self->{_ppix_regexp_from_element}{$addr};
          return ( $self->{_ppix_regexp_from_element}{$addr} =
              PPIx::Regexp->new( $element,
                  default_modifiers =>
                  $self->_find_use_re_modifiers_in_scope_from_element(
                      $element ),
              ) );
      } else {
          return PPIx::Regexp->new( $element );
      }
  }
  
  sub _find_use_re_modifiers_in_scope_from_element {
      my ( $self, $elem ) = @_;
      my @found;
      foreach my $use_re ( @{ $self->find( 'PPI::Statement::Include' ) || [] } )
      {
          're' eq $use_re->module()
              or next;
          $self->element_is_in_lexical_scope_after_statement_containing(
              $elem, $use_re )
              or next;
          my $prefix = 'no' eq $use_re->type() ? q{-} : $EMPTY;
          push @found,
              map { "$prefix$_" }
              grep { m{ \A / }smx }
              map {
                  $_->isa( 'PPI::Token::Quote' ) ? $_->string() :
                  $_->isa( 'PPI::Token::QuoteLike::Words' ) ?  $_->literal() :
                  $_->content() }
              $use_re->schildren();
      }
      return \@found;
  }
  
  #-----------------------------------------------------------------------------
  
  # This got hung on the Perl::Critic::Document, rather than living in
  # Perl::Critic::Utils::PPI, because of the possibility that caching of scope
  # objects would turn out to be desirable.
  
  sub element_is_in_lexical_scope_after_statement_containing {
      my ( $self, $inner_elem, $outer_elem ) = @_;
  
      # If the outer element defines a scope, we're true if and only if
      # the outer element contains the inner element.
      $outer_elem->scope()
          and return $inner_elem->descendant_of( $outer_elem );
  
      # In the more general case:
  
      # The last element of the statement containing the outer element
      # must be before the inner element. If not, we know we're false,
      # without walking the parse tree.
  
      my $stmt = $outer_elem->statement()
          or return;
      my $last_elem = $stmt->last_element()
          or return;
  
      my $stmt_loc = $last_elem->location()
          or return;
  
      my $inner_loc = $inner_elem->location()
          or return;
  
      $stmt_loc->[0] > $inner_loc->[0]
          and return;
      $stmt_loc->[0] == $inner_loc->[0]
          and $stmt_loc->[1] > $inner_loc->[1]
          and return;
  
      # Since we know the inner element is after the outer element, find
      # the element that defines the scope of the statement that contains
      # the outer element.
  
      my $parent = $stmt;
      while ( ! $parent->scope() ) {
          $parent = $parent->parent()
              or return;
      }
  
      # We're true if and only if the scope of the outer element contains
      # the inner element.
  
      return $inner_elem->descendant_of( $parent );
  
  }
  
  #-----------------------------------------------------------------------------
  
  sub filename {
      my ($self) = @_;
  
      if (defined $self->{_filename_override}) {
          return $self->{_filename_override};
      }
      else {
          my $doc = $self->{_doc};
          return $doc->can('filename') ? $doc->filename() : undef;
      }
  }
  
  #-----------------------------------------------------------------------------
  
  sub highest_explicit_perl_version {
      my ($self) = @_;
  
      my $highest_explicit_perl_version =
          $self->{_highest_explicit_perl_version};
  
      if ( not exists $self->{_highest_explicit_perl_version} ) {
          my $includes = $self->find( \&_is_a_version_statement );
  
          if ($includes) {
              # Note: this doesn't use List::Util::max() because that function
              # doesn't use the overloaded ">=" etc of a version object.  The
              # reduce() style lets version.pm take care of all comparing.
              #
              # For reference, max() ends up looking at the string converted to
              # an NV, or something like that.  An underscore like "5.005_04"
              # provokes a warning and is chopped off at "5.005" thus losing the
              # minor part from the comparison.
              #
              # An underscore "5.005_04" is supposed to mean an alpha release
              # and shouldn't be used in a perl version.  But it's shown in
              # perlfunc under "use" (as a number separator), and appears in
              # several modules supplied with perl 5.10.0 (like version.pm
              # itself!).  At any rate if version.pm can understand it then
              # that's enough for here.
              $highest_explicit_perl_version =
                  reduce { $a >= $b ? $a : $b }
                  map    { version->new( $_->version() ) }
                         @{$includes};
          }
          else {
              $highest_explicit_perl_version = undef;
          }
  
          $self->{_highest_explicit_perl_version} =
              $highest_explicit_perl_version;
      }
  
      return $highest_explicit_perl_version if $highest_explicit_perl_version;
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub uses_module {
      my ($self, $module_name) = @_;
  
      return exists $self->_modules_used()->{$module_name};
  }
  
  #-----------------------------------------------------------------------------
  
  sub process_annotations {
      my ($self) = @_;
  
      my @annotations = Perl::Critic::Annotation->create_annotations($self);
      $self->add_annotation(@annotations);
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub line_is_disabled_for_policy {
      my ($self, $line, $policy) = @_;
      my $policy_name = ref $policy || $policy;
  
      # HACK: This Policy is special.  If it is active, it cannot be
      # disabled by a "## no critic" annotation.  Rather than create a general
      # hook in Policy.pm for enabling this behavior, we chose to hack
      # it here, since this isn't the kind of thing that most policies do
  
      return 0 if $policy_name eq
          'Perl::Critic::Policy::Miscellanea::ProhibitUnrestrictedNoCritic';
  
      return 1 if $self->{_disabled_line_map}->{$line}->{$policy_name};
      return 1 if $self->{_disabled_line_map}->{$line}->{ALL};
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_annotation {
      my ($self, @annotations) = @_;
  
      # Add annotation to our private map for quick lookup
      for my $annotation (@annotations) {
  
          my ($start, $end) = $annotation->effective_range();
          my @affected_policies = $annotation->disables_all_policies ?
              qw(ALL) : $annotation->disabled_policies();
  
          # TODO: Find clever way to do this with hash slices
          for my $line ($start .. $end) {
              for my $policy (@affected_policies) {
                  $self->{_disabled_line_map}->{$line}->{$policy} = 1;
              }
          }
      }
  
      push @{ $self->{_annotations} }, @annotations;
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub annotations {
      my ($self) = @_;
      return @{ $self->{_annotations} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_suppressed_violation {
      my ($self, $violation) = @_;
      push @{$self->{_suppressed_violations}}, $violation;
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub suppressed_violations {
      my ($self) = @_;
      return @{ $self->{_suppressed_violations} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_program {
      my ($self) = @_;
  
      return not $self->is_module();
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_module {
      my ($self) = @_;
  
      return $self->{_is_module};
  }
  
  #-----------------------------------------------------------------------------
  # PRIVATE functions & methods
  
  sub _is_a_version_statement {
      my (undef, $element) = @_;
  
      return 0 if not $element->isa('PPI::Statement::Include');
      return 1 if $element->version();
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _caching_finder {
      my $cache_ref = shift;  # These vars will persist for the life
      my %isa_cache = ();     # of the code ref that this sub returns
  
  
      # Gather up all the PPI elements and sort by @ISA.  Note: if any
      # instances used multiple inheritance, this implementation would
      # lead to multiple copies of $element in the $elements_of lists.
      # However, PPI::* doesn't do multiple inheritance, so we are safe
  
      return sub {
          my (undef, $element) = @_;
          my $classes = $isa_cache{ref $element};
          if ( !$classes ) {
              $classes = [ ref $element ];
              # Use a C-style loop because we append to the classes array inside
              for ( my $i = 0; $i < @{$classes}; $i++ ) { ## no critic(ProhibitCStyleForLoops)
                  no strict 'refs';                       ## no critic(ProhibitNoStrict)
                  push @{$classes}, @{"$classes->[$i]::ISA"};
                  $cache_ref->{$classes->[$i]} ||= [];
              }
              $isa_cache{$classes->[0]} = $classes;
          }
  
          for my $class ( @{$classes} ) {
              push @{$cache_ref->{$class}}, $element;
          }
  
          return 0; # 0 tells find() to keep traversing, but not to store this $element
      };
  }
  
  #-----------------------------------------------------------------------------
  
  sub _disable_shebang_fix {
      my ($self) = @_;
  
      # When you install a program using ExtUtils::MakeMaker or Module::Build, it
      # inserts some magical code into the top of the file (just after the
      # shebang).  This code allows people to call your program using a shell,
      # like `sh my_script`.  Unfortunately, this code causes several Policy
      # violations, so we disable them as if they had "## no critic" annotations.
  
      my $first_stmnt = $self->schild(0) || return;
  
      # Different versions of MakeMaker and Build use slightly different shebang
      # fixing strings.  This matches most of the ones I've found in my own Perl
      # distribution, but it may not be bullet-proof.
  
      my $fixin_rx = qr<^eval 'exec .* \$0 \$[{]1[+]"\$@"}'\s*[\r\n]\s*if.+;>ms; ## no critic (ExtendedFormatting)
      if ( $first_stmnt =~ $fixin_rx ) {
          my $line = $first_stmnt->location->[0];
          $self->{_disabled_line_map}->{$line}->{ALL} = 1;
          $self->{_disabled_line_map}->{$line + 1}->{ALL} = 1;
      }
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _determine_is_module {
      my ($self, $args) = @_;
  
      my $file_name = $self->filename();
      if (
              defined $file_name
          and ref $args->{'-program-extensions'} eq 'ARRAY'
      ) {
          foreach my $ext ( @{ $args->{'-program-extensions'} } ) {
              my $regex =
                  ref $ext eq 'Regexp'
                      ? $ext
                      : qr< @{ [ quotemeta $ext ] } \z >xms;
  
              return $FALSE if $file_name =~ m/$regex/smx;
          }
      }
  
      return $FALSE if shebang_line($self);
      return $FALSE if defined $file_name && $file_name =~ m/ [.] PL \z /smx;
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _nodes_by_namespace {
      my ($self) = @_;
  
      my $nodes = $self->{_nodes_by_namespace};
  
      return $nodes if $nodes;
  
      my $ppi_document = $self->ppi_document();
      if (not $ppi_document) {
          return $self->{_nodes_by_namespace} = {};
      }
  
      my $raw_nodes_map = split_ppi_node_by_namespace($ppi_document);
  
      my %wrapped_nodes;
      while ( my ($namespace, $raw_nodes) = each %{$raw_nodes_map} ) {
          $wrapped_nodes{$namespace} = [
              map { __PACKAGE__->_new_for_parent_document($_, $self) }
                  @{$raw_nodes}
          ];
      }
  
      return $self->{_nodes_by_namespace} = \%wrapped_nodes;
  }
  
  #-----------------------------------------------------------------------------
  
  # Note: must use exists on return value to determine membership because all
  # the values are false, unlike the result of hashify().
  sub _modules_used {
      my ($self) = @_;
  
      my $mapping = $self->{_modules_used};
  
      return $mapping if $mapping;
  
      my $includes = $self->find('PPI::Statement::Include');
      if (not $includes) {
          return $self->{_modules_used} = {};
      }
  
      my %mapping;
      for my $module (
          grep { $_ } map  { $_->module() || $_->pragma() } @{$includes}
      ) {
          # Significanly ess memory than $h{$k} => 1.  Thanks Mr. Lembark.
          $mapping{$module} = ();
      }
  
      return $self->{_modules_used} = \%mapping;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords pre-caches
  
  =head1 NAME
  
  Perl::Critic::Document - Caching wrapper around a PPI::Document.
  
  
  =head1 SYNOPSIS
  
      use PPI::Document;
      use Perl::Critic::Document;
      my $doc = PPI::Document->new('Foo.pm');
      $doc = Perl::Critic::Document->new(-source => $doc);
      ## Then use the instance just like a PPI::Document
  
  
  =head1 DESCRIPTION
  
  Perl::Critic does a lot of iterations over the PPI document tree via
  the C<PPI::Document::find()> method.  To save some time, this class
  pre-caches a lot of the common C<find()> calls in a single traversal.
  Then, on subsequent requests we return the cached data.
  
  This is implemented as a facade, where method calls are handed to the
  stored C<PPI::Document> instance.
  
  
  =head1 CAVEATS
  
  This facade does not implement the overloaded operators from
  L<PPI::Document|PPI::Document> (that is, the C<use overload ...>
  work). Therefore, users of this facade must not rely on that syntactic
  sugar.  So, for example, instead of C<my $source = "$doc";> you should
  write C<< my $source = $doc->content(); >>
  
  Perhaps there is a CPAN module out there which implements a facade
  better than we do here?
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new(-source => $source_code, '-filename-override' => $filename, '-program-extensions' => [program_extensions]) >>
  
  Create a new instance referencing a PPI::Document instance.  The
  C<$source_code> can be the name of a file, a reference to a scalar
  containing actual source code, or a L<PPI::Document|PPI::Document> or
  L<PPI::Document::File|PPI::Document::File>.
  
  In the event that C<$source_code> is a reference to a scalar containing actual
  source code or a L<PPI::Document|PPI::Document>, the resulting
  L<Perl::Critic::Document|Perl::Critic::Document> will not have a filename.
  This may cause L<Perl::Critic::Document|Perl::Critic::Document> to incorrectly
  classify the source code as a module or script.  To avoid this problem, you
  can optionally set the C<-filename-override> to force the
  L<Perl::Critic::Document|Perl::Critic::Document> to have a particular
  C<$filename>.  Do not use this option if C<$source_code> is already the name
  of a file, or is a reference to a L<PPI::Document::File|PPI::Document::File>.
  
  The '-program-extensions' argument is optional, and is a reference to a list
  of strings and/or regular expressions. The strings will be made into regular
  expressions matching the end of a file name, and any document whose file name
  matches one of the regular expressions will be considered a program.
  
  If -program-extensions is not specified, or if it does not determine the
  document type, the document will be considered to be a program if the source
  has a shebang line or its file name (if any) matches C<< m/ [.] PL \z /smx >>.
  
  =back
  
  =head1 METHODS
  
  =over
  
  =item C<< ppi_document() >>
  
  Accessor for the wrapped PPI::Document instance.  Note that altering
  this instance in any way can cause unpredictable failures in
  Perl::Critic's subsequent analysis because some caches may fall out of
  date.
  
  
  =item C<< find($wanted) >>
  
  =item C<< find_first($wanted) >>
  
  =item C<< find_any($wanted) >>
  
  Caching wrappers around the PPI methods.  If C<$wanted> is a simple PPI class
  name, then the cache is employed. Otherwise we forward the call to the
  corresponding method of the C<PPI::Document> instance.
  
  
  =item C<< namespaces() >>
  
  Returns a list of the namespaces (package names) in the document.
  
  
  =item C<< subdocuments_for_namespace($namespace) >>
  
  Returns a list of sub-documents containing the elements in the given
  namespace.  For example, given that the current document is for the source
  
      foo();
      package Foo;
      package Bar;
      package Foo;
  
  this method will return two L<Perl::Critic::Document|Perl::Critic::Document>s
  for a parameter of C<"Foo">.  For more, see
  L<PPIx::Utilities::Node/split_ppi_node_by_namespace>.
  
  
  =item C<< ppix_regexp_from_element($element) >>
  
  Caching wrapper around C<< PPIx::Regexp->new($element) >>.  If
  C<$element> is a C<PPI::Element> the cache is employed, otherwise it
  just returns the results of C<< PPIx::Regexp->new() >>.  In either case,
  it returns C<undef> unless the argument is something that
  L<PPIx::Regexp|PPIx::Regexp> actually understands.
  
  =item C<< element_is_in_lexical_scope_after_statement_containing( $inner, $outer ) >>
  
  Is the C<$inner> element in lexical scope after the statement containing
  the C<$outer> element?
  
  In the case where C<$outer> is itself a scope-defining element, returns true
  if C<$outer> contains C<$inner>. In any other case, C<$inner> must be
  after the last element of the statement containing C<$outer>, and the
  innermost scope for C<$outer> also contains C<$inner>.
  
  This is not the same as asking whether C<$inner> is visible from
  C<$outer>.
  
  
  =item C<< filename() >>
  
  Returns the filename for the source code if applicable
  (PPI::Document::File) or C<undef> otherwise (PPI::Document).
  
  
  =item C<< isa( $classname ) >>
  
  To be compatible with other modules that expect to get a
  PPI::Document, the Perl::Critic::Document class masquerades as the
  PPI::Document class.
  
  
  =item C<< highest_explicit_perl_version() >>
  
  Returns a L<version|version> object for the highest Perl version
  requirement declared in the document via a C<use> or C<require>
  statement.  Returns nothing if there is no version statement.
  
  
  =item C<< uses_module($module_or_pragma_name) >>
  
  Answers whether there is a C<use>, C<require>, or C<no> of the given name in
  this document.  Note that there is no differentiation of modules vs. pragmata
  here.
  
  
  =item C<< process_annotations() >>
  
  Causes this Document to scan itself and mark which lines &
  policies are disabled by the C<"## no critic"> annotations.
  
  
  =item C<< line_is_disabled_for_policy($line, $policy_object) >>
  
  Returns true if the given C<$policy_object> or C<$policy_name> has
  been disabled for at C<$line> in this Document.  Otherwise, returns false.
  
  
  =item C<< add_annotation( $annotation ) >>
  
  Adds an C<$annotation> object to this Document.
  
  
  =item C<< annotations() >>
  
  Returns a list containing all the
  L<Perl::Critic::Annotation|Perl::Critic::Annotation>s that
  were found in this Document.
  
  
  =item C<< add_suppressed_violation($violation) >>
  
  Informs this Document that a C<$violation> was found but not reported
  because it fell on a line that had been suppressed by a C<"## no critic">
  annotation. Returns C<$self>.
  
  
  =item C<< suppressed_violations() >>
  
  Returns a list of references to all the
  L<Perl::Critic::Violation|Perl::Critic::Violation>s
  that were found in this Document but were suppressed.
  
  
  =item C<< is_program() >>
  
  Returns whether this document is considered to be a program.
  
  
  =item C<< is_module() >>
  
  Returns whether this document is considered to be a Perl module.
  
  =back
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_DOCUMENT

$fatpacked{"Perl/Critic/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION';
  package Perl::Critic::Exception;
  
  use 5.006001;
  use strict;
  use warnings;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception' => {
          isa         => 'Exception::Class::Base',
          description => 'A problem discovered by Perl::Critic.',
      },
  );
  
  use Exporter 'import';
  
  #-----------------------------------------------------------------------------
  
  sub short_class_name {
      my ( $self ) = @_;
  
      return substr ref $self, (length 'Perl::Critic') + 2;
  }
  
  #-----------------------------------------------------------------------------
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception - A problem identified by L<Perl::Critic|Perl::Critic>.
  
  =head1 DESCRIPTION
  
  A base class for all problems discovered by
  L<Perl::Critic|Perl::Critic>.  This exists to enable differentiating
  exceptions from L<Perl::Critic|Perl::Critic> code from those
  originating in other modules.
  
  This is an abstract class.  It should never be instantiated.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<short_class_name()>
  
  Retrieve the name of the class of this object with C<'Perl::Critic::'>
  stripped off.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION

$fatpacked{"Perl/Critic/Exception/AggregateConfiguration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_AGGREGATECONFIGURATION';
  package Perl::Critic::Exception::AggregateConfiguration;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp qw{ confess };
  use English qw(-no_match_vars);
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::AggregateConfiguration' => {
          isa         => 'Perl::Critic::Exception',
          description => 'A collected set of configuration exceptions.',
          fields      => [ qw{ exceptions } ],
          alias       => 'throw_aggregate',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_aggregate >;
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %options) = @_;
  
      my $exceptions = $options{exceptions};
      if (not $exceptions) {
          $options{exceptions} = [];
      }
  
      return $class->SUPER::new(%options);
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_exception {
      my ( $self, $exception ) = @_;
  
      push @{ $self->exceptions() }, $exception;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_exceptions_from {
      my ( $self, $aggregate ) = @_;
  
      push @{ $self->exceptions() }, @{ $aggregate->exceptions() };
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_exception_or_rethrow {
      my ( $self, $eval_error ) = @_;
  
      return if not $eval_error;
      confess $eval_error if not ref $eval_error;
  
      if ( $eval_error->isa('Perl::Critic::Exception::Configuration') ) {
          $self->add_exception($eval_error);
      }
      elsif (
          $eval_error->isa('Perl::Critic::Exception::AggregateConfiguration')
      ) {
          $self->add_exceptions_from($eval_error);
      }
      else {
          die $eval_error; ## no critic (RequireCarping)
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub has_exceptions {
      my ( $self ) = @_;
  
      return @{ $self->exceptions() } ? 1 : 0;
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $MESSAGE_PREFIX => $EMPTY;
  Readonly::Scalar my $MESSAGE_SUFFIX => "\n";
  Readonly::Scalar my $MESSAGE_SEPARATOR => $MESSAGE_SUFFIX . $MESSAGE_PREFIX;
  
  sub full_message {
      my ( $self ) = @_;
  
      my $message = $MESSAGE_PREFIX;
      $message .= join $MESSAGE_SEPARATOR, @{ $self->exceptions() };
      $message .= $MESSAGE_SUFFIX;
  
      return $message;
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::AggregateConfiguration - A collection of a set of problems found in the configuration and/or command-line options.
  
  =head1 DESCRIPTION
  
  A set of configuration settings can have multiple problems.  This is
  an object for collecting all the problems found so that the user can
  see them in one run.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<add_exception( $exception )>
  
  Accumulate the parameter with rest of the exceptions.
  
  
  =item C<add_exceptions_from( $aggregate )>
  
  Accumulate the exceptions from another instance of this class.
  
  
  =item C<exceptions()>
  
  Returns a reference to an array of the collected exceptions.
  
  
  =item C<add_exception_or_rethrow( $eval_error )>
  
  If the parameter is an instance of
  L<Perl::Critic::Exception::Configuration|Perl::Critic::Exception::Configuration>
  or
  L<Perl::Critic::Exception::AggregateConfiguration|Perl::Critic::Exception::AggregateConfiguration>,
  add it.  Otherwise, C<die> with the parameter, if it is a reference,
  or C<confess> with it.  If the parameter is false, simply returns.
  
  
  =item C<has_exceptions()>
  
  Answer whether any configuration problems have been found.
  
  
  =item C<full_message()>
  
  Concatenate the exception messages.  See
  L<Exception::Class/"full_message">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_AGGREGATECONFIGURATION

$fatpacked{"Perl/Critic/Exception/Configuration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION';
  package Perl::Critic::Exception::Configuration;
  
  use 5.006001;
  use strict;
  use warnings;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration' => {
          isa         => 'Perl::Critic::Exception',
          description => 'A problem with Perl::Critic configuration, whether from a file or a command line or some other source.',
          fields      => [ qw{ source } ],
      },
  );
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration - A problem with L<Perl::Critic|Perl::Critic> configuration.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with the configuration of
  L<Perl::Critic|Perl::Critic>, whether from a F<.perlcriticrc>, another profile
  file, or command line.
  
  This is an abstract class.  It should never be instantiated.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<source()>
  
  Where the configuration information came from, if it could be determined.
  
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Exception::Configuration::Generic|Perl::Critic::Exception::Configuration::Generic>
  L<Perl::Critic::Exception::Configuration::Option|Perl::Critic::Exception::Configuration::Option>
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION

$fatpacked{"Perl/Critic/Exception/Configuration/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_GENERIC';
  package Perl::Critic::Exception::Configuration::Generic;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Generic' => {
          isa         => 'Perl::Critic::Exception::Configuration',
          description =>
              q{A problem with Perl::Critic configuration that isn't related to an option.},
          alias       => 'throw_generic',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_generic >;
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Generic - A problem with L<Perl::Critic|Perl::Critic> configuration that doesn't involve an option.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with the configuration of
  L<Perl::Critic|Perl::Critic>, whether from a F<.perlcriticrc>, another
  profile file, or command line.
  
  This covers things like file reading and parsing errors.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item C<< throw( message => $message, source => $source ) >>
  
  See L<Exception::Class/"throw">.
  
  
  =item C<< new( message => $message, source => $source ) >>
  
  See L<Exception::Class/"new">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_GENERIC

$fatpacked{"Perl/Critic/Exception/Configuration/NonExistentPolicy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_NONEXISTENTPOLICY';
  package Perl::Critic::Exception::Configuration::NonExistentPolicy;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::NonExistentPolicy' => {
          isa         => 'Perl::Critic::Exception::Configuration',
          description => 'The configuration referred to a non-existant policy.',
          fields      => [ qw{ policy } ],
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_extra_parameter >;
  
  #-----------------------------------------------------------------------------
  
  sub full_message {
      my ( $self ) = @_;
  
      my $policy = $self->policy();
  
      return qq<There is no $policy policy installed.>;
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::NonExistentPolicy - The configuration referred to a non-existent policy.
  
  =head1 DESCRIPTION
  
  A representation of the configuration attempting to specify a
  L<Perl::Critic::Policy|Perl::Critic::Policy> that is not known, whether from a
  F<.perlcriticrc>, another profile file, or command line.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item C<< throw( policy => $policy ) >>
  
  See L<Exception::Class/"throw">.
  
  
  =item C<< new( policy => $policy ) >>
  
  See L<Exception::Class/"new">.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<full_message()>
  
  Provide a standard message.  See L<Exception::Class/"full_message">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_NONEXISTENTPOLICY

$fatpacked{"Perl/Critic/Exception/Configuration/Option.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION';
  package Perl::Critic::Exception::Configuration::Option;
  
  use 5.006001;
  use strict;
  use warnings;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Perl::Critic::Exception::Fatal::Internal;
  
  use Exception::Class (   # this must come after "use P::C::Exception::*"
      'Perl::Critic::Exception::Configuration::Option' => {
          isa         => 'Perl::Critic::Exception::Configuration',
          description => 'A problem with an option in the Perl::Critic configuration, whether from a file or a command line or some other source.',
          fields      => [ qw{ option_name option_value message_suffix } ],
      },
  );
  
  #-----------------------------------------------------------------------------
  
  sub message {
      my $self = shift;
  
      return $self->full_message();
  }
  
  #-----------------------------------------------------------------------------
  
  sub error {
      my $self = shift;
  
      return $self->full_message();
  }
  
  #-----------------------------------------------------------------------------
  
  ## no critic (Subroutines::RequireFinalReturn)
  sub full_message {
      Perl::Critic::Exception::Fatal::Internal->throw(
          'Subclass failed to override abstract method.'
      );
  }
  ## use critic
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option - A problem with an option in the L<Perl::Critic|Perl::Critic> configuration.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with an option in the
  configuration of L<Perl::Critic|Perl::Critic>, whether from a
  F<.perlcriticrc>, another profile file, or command line.
  
  This is an abstract class.  It should never be instantiated.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<option_name()>
  
  The name of the option that was found to be in error.
  
  
  =item C<option_value()>
  
  The value of the option that was found to be in error.
  
  
  =item C<message_suffix()>
  
  Any text that should be applied to end of the standard message for
  this kind of exception.
  
  
  =item C<message()>
  
  =item C<error()>
  
  Overridden to call C<full_message()>.  I.e. any message string in the
  superclass is ignored.
  
  
  =item C<full_message()>
  
  Overridden to turn it into an abstract method to force subclasses to
  implement it.
  
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Exception::Configuration::Option::Global|Perl::Critic::Exception::Configuration::Option::Global>
  L<Perl::Critic::Exception::Configuration::Option::Policy|Perl::Critic::Exception::Configuration::Option::Policy>
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Global.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL';
  package Perl::Critic::Exception::Configuration::Option::Global;
  
  use 5.006001;
  use strict;
  use warnings;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Option::Global' => {
          isa         => 'Perl::Critic::Exception::Configuration::Option',
          description => 'A problem with global Perl::Critic configuration.',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option::Global - A problem with L<Perl::Critic|Perl::Critic> global configuration.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with the global configuration of
  L<Perl::Critic|Perl::Critic>, whether from a F<.perlcriticrc>, another
  profile file, or command line.
  
  This is an abstract class.  It should never be instantiated.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Global/ExtraParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_EXTRAPARAMETER';
  package Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter' => {
          isa         => 'Perl::Critic::Exception::Configuration::Option::Global',
          description => 'The configuration referred to a non-existant global option.',
          alias       => 'throw_extra_global',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_extra_global >;
  
  #-----------------------------------------------------------------------------
  
  sub full_message {
      my ( $self ) = @_;
  
      my $source = $self->source();
      if ($source) {
          $source = qq{ (found in "$source")};
      }
      else {
          $source = q{};
      }
  
      my $option_name = $self->option_name();
  
      return qq{"$option_name" is not a supported option$source.};
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter - The configuration referred to a non-existent global option.
  
  =head1 DESCRIPTION
  
  A representation of the configuration attempting to specify a value
  for an option that L<Perl::Critic|Perl::Critic> doesn't have, whether
  from a F<.perlcriticrc>, another profile file, or command line.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item C<< throw( option_name => $option_name, source => $source ) >>
  
  See L<Exception::Class/"throw">.
  
  
  =item C<< new( option_name => $option_name, source => $source ) >>
  
  See L<Exception::Class/"new">.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<full_message()>
  
  Provide a standard message for values for non-existent parameters for
  policies.  See L<Exception::Class/"full_message">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_EXTRAPARAMETER

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Global/ParameterValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_PARAMETERVALUE';
  package Perl::Critic::Exception::Configuration::Option::Global::ParameterValue;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Option::Global::ParameterValue' => {
          isa         => 'Perl::Critic::Exception::Configuration::Option::Global',
          description => 'A problem with the value of a global parameter.',
          alias       => 'throw_global_value',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_global_value >;
  
  #-----------------------------------------------------------------------------
  
  sub full_message {
      my ( $self ) = @_;
  
      my $source = $self->source();
      if ($source) {
          $source = qq{ found in "$source"};
      }
      else {
          $source = $EMPTY;
      }
  
      my $option_name = $self->option_name();
      my $option_value =
          defined $self->option_value()
              ? $DQUOTE . $self->option_value() . $DQUOTE
              : '<undef>';
      my $message_suffix = $self->message_suffix() || $EMPTY;
  
      return
              qq{The value for the global "$option_name" option }
          .   qq{($option_value)$source $message_suffix};
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option::Global::ParameterValue - A problem with the value of a global parameter.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with the value of a global
  parameter, whether from a F<.perlcriticrc>, another profile file, or
  command line.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item C<< throw( option_name => $option_name, option_value => $option_value, source => $source, message_suffix => $message_suffix ) >>
  
  See L<Exception::Class/"throw">.
  
  
  =item C<< new( option_name => $option_name, option_value => $option_value, source => $source, message_suffix => $message_suffix ) >>
  
  See L<Exception::Class/"new">.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<full_message()>
  
  Provide a standard message for global configuration problems.  See
  L<Exception::Class/"full_message">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_GLOBAL_PARAMETERVALUE

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Policy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY';
  package Perl::Critic::Exception::Configuration::Option::Policy;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Perl::Critic::Utils qw{ &policy_short_name };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Option::Policy' => {
          isa         => 'Perl::Critic::Exception::Configuration::Option',
          description => 'A problem with the configuration of a policy.',
          fields      => [ qw{ policy } ],
      },
  );
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %options) = @_;
  
      my $policy = $options{policy};
      if ($policy) {
          $options{policy} = policy_short_name($policy);
      }
  
      return $class->SUPER::new(%options);
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option::Policy - A problem with configuration of a policy.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with the configuration of a
  L<Perl::Critic::Policy|Perl::Critic::Policy>, whether from a
  F<.perlcriticrc>, another profile file, or command line.
  
  This is an abstract class.  It should never be instantiated.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<policy()>
  
  The short name of the policy that had configuration problems.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Policy/ExtraParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_EXTRAPARAMETER';
  package Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter' => {
          isa         => 'Perl::Critic::Exception::Configuration::Option::Policy',
          description => 'The configuration of a policy referred to a non-existant parameter.',
          alias       => 'throw_extra_parameter',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_extra_parameter >;
  
  #-----------------------------------------------------------------------------
  
  sub full_message {
      my ( $self ) = @_;
  
      my $source = $self->source();
      if ($source) {
          $source = qq{ (found in "$source")};
      }
      else {
          $source = q{};
      }
  
      my $policy = $self->policy();
      my $option_name = $self->option_name();
  
      return
          qq{The $policy policy doesn't take a "$option_name" option$source.};
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter - The configuration referred to a non-existent parameter for a policy.
  
  =head1 DESCRIPTION
  
  A representation of the configuration attempting to specify a value
  for a parameter that a L<Perl::Critic::Policy|Perl::Critic::Policy>
  doesn't have, whether from a F<.perlcriticrc>, another profile file,
  or command line.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item C<< throw( policy => $policy, option_name => $option_name, source => $source ) >>
  
  See L<Exception::Class/"throw">.
  
  
  =item C<< new( policy => $policy, option_name => $option_name, source => $source ) >>
  
  See L<Exception::Class/"new">.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<full_message()>
  
  Provide a standard message for values for non-existent parameters for
  policies.  See L<Exception::Class/"full_message">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_EXTRAPARAMETER

$fatpacked{"Perl/Critic/Exception/Configuration/Option/Policy/ParameterValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_PARAMETERVALUE';
  package Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue' => {
          isa         => 'Perl::Critic::Exception::Configuration::Option::Policy',
          description => 'A problem with the value of a parameter for a policy.',
          alias       => 'throw_policy_value',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_policy_value >;
  
  #-----------------------------------------------------------------------------
  
  sub full_message {
      my ( $self ) = @_;
  
      my $source = $self->source();
      if ($source) {
          $source = qq{ found in "$source"};
      }
      else {
          $source = $EMPTY;
      }
  
      my $policy = $self->policy();
      my $option_name = $self->option_name();
      my $option_value =
          defined $self->option_value()
              ? $DQUOTE . $self->option_value() . $DQUOTE
              : '<undef>';
      my $message_suffix = $self->message_suffix() || $EMPTY;
  
      return
              qq{The value for the $policy "$option_name" option }
          .   qq{($option_value)$source $message_suffix};
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue - A problem with the value of a parameter for a policy.
  
  =head1 DESCRIPTION
  
  A representation of a problem found with the value of a parameter for
  a L<Perl::Critic::Policy|Perl::Critic::Policy>, whether from a
  F<.perlcriticrc>, another profile file, or command line.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CLASS METHODS
  
  =over
  
  =item C<< throw( policy => $policy, option_name => $option_name, option_value => $option_value, source => $source, message_suffix => $message_suffix ) >>
  
  See L<Exception::Class/"throw">.
  
  
  =item C<< new( policy => $policy, option_name => $option_name, option_value => $option_value, source => $source, message_suffix => $message_suffix ) >>
  
  See L<Exception::Class/"new">.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<full_message()>
  
  Provide a standard message for policy parameter value problems.  See
  L<Exception::Class/"full_message">.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_CONFIGURATION_OPTION_POLICY_PARAMETERVALUE

$fatpacked{"Perl/Critic/Exception/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL';
  package Perl::Critic::Exception::Fatal;
  
  use 5.006001;
  use strict;
  use warnings;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Fatal' => {
          isa         => 'Perl::Critic::Exception',
          description =>
              'A problem that should cause Perl::Critic to stop running.',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, @args) = @_;
      my $self = $class->SUPER::new(@args);
  
      $self->show_trace(1);
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub full_message {
      my ( $self ) = @_;
  
      return
            $self->short_class_name()
          . q{: }
          . $self->description()
          . "\n\n"
          . $self->message()
          . "\n\n"
          . gmtime $self->time()
          . "\n\n";
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Fatal - A problem that should cause L<Perl::Critic|Perl::Critic> to stop running.
  
  =head1 DESCRIPTION
  
  Something went wrong and processing should not continue.  You should
  never specifically look for this exception or one of its subclasses.
  
  Note: the constructor invokes L<Exception::Class/"show_trace"> to
  force stack-traces to be included in the standard stringification.
  
  This is an abstract class.  It should never be instantiated.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<full_message()>
  
  Overrides L<Exception::Class/"full_message"> to include extra
  information.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_FATAL

$fatpacked{"Perl/Critic/Exception/Fatal/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL_GENERIC';
  package Perl::Critic::Exception::Fatal::Generic;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Fatal::Generic' => {
          isa         => 'Perl::Critic::Exception::Fatal',
          description => 'A general problem was found.',
          alias       => 'throw_generic',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_generic >;
  
  #-----------------------------------------------------------------------------
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Fatal::Generic - A problem for which there is no specialized information.
  
  =head1 DESCRIPTION
  
  A general problem, e.g. I/O errors and problems that may or not be bugs.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  Only inherited ones.
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_FATAL_GENERIC

$fatpacked{"Perl/Critic/Exception/Fatal/Internal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL_INTERNAL';
  package Perl::Critic::Exception::Fatal::Internal;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Fatal::Internal' => {
          isa         => 'Perl::Critic::Exception::Fatal',
          description => 'A problem with the Perl::Critic code was found, a.k.a. a bug.',
          alias       => 'throw_internal',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_internal >;
  
  #-----------------------------------------------------------------------------
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Fatal::Internal - A problem with the L<Perl::Critic|Perl::Critic> implementation, i.e. a bug.
  
  =head1 DESCRIPTION
  
  A representation of a bug found in the code of
  L<Perl::Critic|Perl::Critic>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  Only inherited ones.
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_FATAL_INTERNAL

$fatpacked{"Perl/Critic/Exception/Fatal/PolicyDefinition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_FATAL_POLICYDEFINITION';
  package Perl::Critic::Exception::Fatal::PolicyDefinition;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Fatal::PolicyDefinition' => {
          isa         => 'Perl::Critic::Exception::Fatal',
          description => 'A bug in a policy was found.',
          alias       => 'throw_policy_definition',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_policy_definition >;
  
  #-----------------------------------------------------------------------------
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Fatal::PolicyDefinition - A bug in a policy.
  
  =head1 DESCRIPTION
  
  A bug in a policy was found, e.g. it didn't implement a method that it should
  have.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  Only inherited ones.
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_FATAL_POLICYDEFINITION

$fatpacked{"Perl/Critic/Exception/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_IO';
  package Perl::Critic::Exception::IO;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp qw{ confess };
  use English qw(-no_match_vars);
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::IO' => {
          isa         => 'Perl::Critic::Exception',
          description => 'An input/output problem.',
          fields      => [ qw< file_name errno > ],
          alias       => 'throw_io',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_io >;
  
  #-----------------------------------------------------------------------------
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::IO - A problem with input or output.
  
  =head1 DESCRIPTION
  
  The outside world can do nasty things to your poor, innocent code.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<file_name()>
  
  Returns the name of the file that the problem was found with, if available.
  
  
  =item C<errno()>
  
  The value of C<$ERRNO>/C<$!> at the time the problem was found.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_IO

$fatpacked{"Perl/Critic/Exception/Parse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_EXCEPTION_PARSE';
  package Perl::Critic::Exception::Parse;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw< -no_match_vars >;
  use Carp qw< confess >;
  use Readonly;
  
  use Perl::Critic::Utils qw< :characters >;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exception::Class (
      'Perl::Critic::Exception::Parse' => {
          isa         => 'Perl::Critic::Exception',
          description => 'A problem parsing source code.',
          fields      => [ qw< file_name > ],
          alias       => 'throw_parse',
      },
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw< throw_parse >;
  
  #-----------------------------------------------------------------------------
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Exception::Parse - The code doesn't look like code.
  
  =head1 DESCRIPTION
  
  There was a problem with PPI parsing source code.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<file_name()>
  
  Returns the name of the file that the problem was found with, if available.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_EXCEPTION_PARSE

$fatpacked{"Perl/Critic/OptionsProcessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_OPTIONSPROCESSOR';
  package Perl::Critic::OptionsProcessor;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  
  use Perl::Critic::Exception::AggregateConfiguration;
  use Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter;
  use Perl::Critic::Utils qw<
      :booleans :characters :severities :data_conversion $DEFAULT_VERBOSITY
  >;
  use Perl::Critic::Utils::Constants qw<
      $PROFILE_STRICTNESS_DEFAULT
      :color_severity
      >;
  use Perl::Critic::Utils::DataConversion qw< dor >;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {}, $class;
      $self->_init( %args );
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init {
      my ( $self, %args ) = @_;
  
      # Multi-value defaults
      my $exclude = dor(delete $args{exclude}, $EMPTY);
      $self->{_exclude}    = [ words_from_string( $exclude ) ];
  
      my $include = dor(delete $args{include}, $EMPTY);
      $self->{_include}    = [ words_from_string( $include ) ];
  
      my $program_extensions = dor(delete $args{'program-extensions'}, $EMPTY);
      $self->{_program_extensions} = [ words_from_string( $program_extensions) ];
  
      # Single-value defaults
      $self->{_force}           = dor(delete $args{force},              $FALSE);
      $self->{_only}            = dor(delete $args{only},               $FALSE);
      $self->{_profile_strictness} =
          dor(delete $args{'profile-strictness'}, $PROFILE_STRICTNESS_DEFAULT);
      $self->{_single_policy}   = dor(delete $args{'single-policy'},    $EMPTY);
      $self->{_severity}        = dor(delete $args{severity},           $SEVERITY_HIGHEST);
      $self->{_theme}           = dor(delete $args{theme},              $EMPTY);
      $self->{_top}             = dor(delete $args{top},                $FALSE);
      $self->{_verbose}         = dor(delete $args{verbose},            $DEFAULT_VERBOSITY);
      $self->{_criticism_fatal} = dor(delete $args{'criticism-fatal'},  $FALSE);
      $self->{_pager}           = dor(delete $args{pager},              $EMPTY);
      $self->{_allow_unsafe}    = dor(delete $args{'allow-unsafe'},     $FALSE);
  
      $self->{_color_severity_highest} = dor(
          delete $args{'color-severity-highest'},
          delete $args{'colour-severity-highest'},
          delete $args{'color-severity-5'},
          delete $args{'colour-severity-5'},
          $PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT,
      );
      $self->{_color_severity_high} = dor(
          delete $args{'color-severity-high'},
          delete $args{'colour-severity-high'},
          delete $args{'color-severity-4'},
          delete $args{'colour-severity-4'},
          $PROFILE_COLOR_SEVERITY_HIGH_DEFAULT,
      );
      $self->{_color_severity_medium} = dor(
          delete $args{'color-severity-medium'},
          delete $args{'colour-severity-medium'},
          delete $args{'color-severity-3'},
          delete $args{'colour-severity-3'},
          $PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT,
      );
      $self->{_color_severity_low} = dor(
          delete $args{'color-severity-low'},
          delete $args{'colour-severity-low'},
          delete $args{'color-severity-2'},
          delete $args{'colour-severity-2'},
          $PROFILE_COLOR_SEVERITY_LOW_DEFAULT,
      );
      $self->{_color_severity_lowest} = dor(
          delete $args{'color-severity-lowest'},
          delete $args{'colour-severity-lowest'},
          delete $args{'color-severity-1'},
          delete $args{'colour-severity-1'},
          $PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT,
      );
  
      # If we're using a pager or not outputing to a tty don't use colors.
      # Can't use IO::Interactive here because we /don't/ want to check STDIN.
      my $default_color = ($self->pager() or not -t *STDOUT) ? $FALSE : $TRUE; ## no critic (ProhibitInteractiveTest)
      $self->{_color} = dor(delete $args{color}, delete $args{colour}, $default_color);
  
      # If there's anything left, complain.
      _check_for_extra_options(%args);
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _check_for_extra_options {
      my %args = @_;
  
      if ( my @remaining = sort keys %args ){
          my $errors = Perl::Critic::Exception::AggregateConfiguration->new();
  
          foreach my $option_name (@remaining) {
              $errors->add_exception(
                  Perl::Critic::Exception::Configuration::Option::Global::ExtraParameter->new(
                      option_name     => $option_name,
                  )
              )
          }
  
          $errors->rethrow();
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  # Public ACCESSOR methods
  
  sub severity {
      my ($self) = @_;
      return $self->{_severity};
  }
  
  #-----------------------------------------------------------------------------
  
  sub theme {
      my ($self) = @_;
      return $self->{_theme};
  }
  
  #-----------------------------------------------------------------------------
  
  sub exclude {
      my ($self) = @_;
      return $self->{_exclude};
  }
  
  #-----------------------------------------------------------------------------
  
  sub include {
      my ($self) = @_;
      return $self->{_include};
  }
  
  #-----------------------------------------------------------------------------
  
  sub only {
      my ($self) = @_;
      return $self->{_only};
  }
  
  #-----------------------------------------------------------------------------
  
  sub profile_strictness {
      my ($self) = @_;
      return $self->{_profile_strictness};
  }
  
  #-----------------------------------------------------------------------------
  
  sub single_policy {
      my ($self) = @_;
      return $self->{_single_policy};
  }
  
  #-----------------------------------------------------------------------------
  
  sub verbose {
      my ($self) = @_;
      return $self->{_verbose};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color {
      my ($self) = @_;
      return $self->{_color};
  }
  
  #-----------------------------------------------------------------------------
  
  sub pager {
      my ($self) = @_;
      return $self->{_pager};
  }
  
  #-----------------------------------------------------------------------------
  
  sub allow_unsafe {
      my ($self) = @_;
      return $self->{_allow_unsafe};
  }
  
  #-----------------------------------------------------------------------------
  
  sub criticism_fatal {
      my ($self) = @_;
      return $self->{_criticism_fatal};
  }
  
  #-----------------------------------------------------------------------------
  
  sub force {
      my ($self) = @_;
      return $self->{_force};
  }
  
  #-----------------------------------------------------------------------------
  
  sub top {
      my ($self) = @_;
      return $self->{_top};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_highest {
      my ($self) = @_;
      return $self->{_color_severity_highest};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_high {
      my ($self) = @_;
      return $self->{_color_severity_high};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_medium {
      my ($self) = @_;
      return $self->{_color_severity_medium};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_low {
      my ($self) = @_;
      return $self->{_color_severity_low};
  }
  
  #-----------------------------------------------------------------------------
  
  sub color_severity_lowest {
      my ($self) = @_;
      return $self->{_color_severity_lowest};
  }
  
  #-----------------------------------------------------------------------------
  
  sub program_extensions {
      my ($self) = @_;
      return $self->{_program_extensions};
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::OptionsProcessor - The global configuration default values, combined with command-line values.
  
  
  =head1 DESCRIPTION
  
  This is a helper class that encapsulates the default parameters for
  constructing a L<Perl::Critic::Config|Perl::Critic::Config> object.
  There are no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C< new( %DEFAULT_PARAMS ) >
  
  Returns a reference to a new C<Perl::Critic::OptionsProcessor> object.
  You can override the coded defaults by passing in name-value pairs
  that correspond to the methods listed below.
  
  This is usually only invoked by
  L<Perl::Critic::UserProfile|Perl::Critic::UserProfile>, which passes
  in the global values from a F<.perlcriticrc> file.  This object
  contains no information for individual Policies.
  
  =back
  
  =head1 METHODS
  
  =over
  
  =item C< exclude() >
  
  Returns a reference to a list of the default exclusion patterns.  If
  onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.  there
  are no default exclusion patterns, then the list will be empty.
  
  
  =item C< force() >
  
  Returns the default value of the C<force> flag (Either 1 or 0).
  
  
  =item C< include() >
  
  Returns a reference to a list of the default inclusion patterns.  If
  there are no default exclusion patterns, then the list will be empty.
  
  
  =item C< only() >
  
  Returns the default value of the C<only> flag (Either 1 or 0).
  
  
  =item C< profile_strictness() >
  
  Returns the default value of C<profile_strictness> as an unvalidated
  string.
  
  
  =item C< single_policy() >
  
  Returns the default C<single-policy> pattern.  (As a string.)
  
  
  =item C< severity() >
  
  Returns the default C<severity> setting. (1..5).
  
  
  =item C< theme() >
  
  Returns the default C<theme> setting. (As a string).
  
  
  =item C< top() >
  
  Returns the default C<top> setting. (Either 0 or a positive integer).
  
  
  =item C< verbose() >
  
  Returns the default C<verbose> setting. (Either a number or format
  string).
  
  
  =item C< color() >
  
  Returns the default C<color> setting. (Either 1 or 0).
  
  
  =item C< pager() >
  
  Returns the default C<pager> setting. (Either empty string or the pager
  command string).
  
  
  =item C< allow_unsafe() >
  
  Returns the default C<allow-unsafe> setting. (Either 1 or 0).
  
  
  =item C< criticism_fatal() >
  
  Returns the default C<criticism-fatal> setting (Either 1 or 0).
  
  =item C< color_severity_highest() >
  
  Returns the color to be used for coloring highest severity violations.
  
  =item C< color_severity_high() >
  
  Returns the color to be used for coloring high severity violations.
  
  =item C< color_severity_medium() >
  
  Returns the color to be used for coloring medium severity violations.
  
  =item C< color_severity_low() >
  
  Returns the color to be used for coloring low severity violations.
  
  =item C< color_severity_lowest() >
  
  Returns the color to be used for coloring lowest severity violations.
  
  =item C< program_extensions() >
  
  Returns a reference to the array of file name extensions to be interpreted as
  representing Perl programs.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Config|Perl::Critic::Config>,
  L<Perl::Critic::UserProfile|Perl::Critic::UserProfile>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_OPTIONSPROCESSOR

$fatpacked{"Perl/Critic/Policy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY';
  package Perl::Critic::Policy;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw< -no_match_vars >;
  use Readonly;
  
  use File::Spec ();
  use String::Format qw< stringf >;
  
  use overload ( q<""> => 'to_string', cmp => '_compare' );
  
  use Perl::Critic::Utils qw<
      :characters
      :booleans
      :severities
      :data_conversion
      interpolate
      is_integer
      policy_long_name
      policy_short_name
      severity_to_number
  >;
  use Perl::Critic::Utils::DataConversion qw< dor >;
  use Perl::Critic::Utils::POD qw<
      get_module_abstract_for_module
      get_raw_module_abstract_for_module
  >;
  use Perl::Critic::Exception::AggregateConfiguration;
  use Perl::Critic::Exception::Configuration;
  use Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter;
  use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;
  use Perl::Critic::Exception::Fatal::PolicyDefinition
      qw< throw_policy_definition >;
  use Perl::Critic::PolicyConfig qw<>;
  use Perl::Critic::PolicyParameter qw<>;
  use Perl::Critic::Violation qw<>;
  
  use Exception::Class;   # this must come after "use P::C::Exception::*"
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $NO_LIMIT => 'no_limit';
  
  #-----------------------------------------------------------------------------
  
  my $format = '%p'; #Default stringy format
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %config) = @_;
  
      my $self = bless {}, $class;
  
      my $config_object;
      if ($config{_config_object}) {
          $config_object = $config{_config_object};
      }
      else {
          $config_object =
              Perl::Critic::PolicyConfig->new(
                  $self->get_short_name(),
                  \%config,
              );
      }
  
      $self->__set_config( $config_object );
  
      my @parameters;
      my $parameter_metadata_available = 0;
  
      if ( $class->can('supported_parameters') ) {
          $parameter_metadata_available = 1;
          @parameters =
              map
                  { Perl::Critic::PolicyParameter->new($_) }
                  $class->supported_parameters();
      }
      $self->{_parameter_metadata_available} = $parameter_metadata_available;
      $self->{_parameters} = \@parameters;
  
      my $errors = Perl::Critic::Exception::AggregateConfiguration->new();
      foreach my $parameter ( @parameters ) {
          eval {
              $parameter->parse_and_validate_config_value( $self, $config_object );
          }
              or do {
                  $errors->add_exception_or_rethrow($EVAL_ERROR);
              };
  
          $config_object->remove( $parameter->get_name() );
      }
  
      if ($parameter_metadata_available) {
          $config_object->handle_extra_parameters( $self, $errors );
      }
  
      if ( $errors->has_exceptions() ) {
          $errors->rethrow();
      }
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_safe {
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub __get_parameter_name {
      my ( $self, $parameter ) = @_;
  
      return '_' . $parameter->get_name();
  }
  
  #-----------------------------------------------------------------------------
  
  sub __set_parameter_value {
      my ( $self, $parameter, $value ) = @_;
  
      $self->{ $self->__get_parameter_name($parameter) } = $value;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub __set_base_parameters {
      my ($self) = @_;
  
      my $config = $self->__get_config();
      my $errors = Perl::Critic::Exception::AggregateConfiguration->new();
  
      $self->_set_maximum_violations_per_document($errors);
  
      my $user_severity = $config->get_severity();
      if ( defined $user_severity ) {
          my $normalized_severity = severity_to_number( $user_severity );
          $self->set_severity( $normalized_severity );
      }
  
      my $user_set_themes = $config->get_set_themes();
      if ( defined $user_set_themes ) {
          my @set_themes = words_from_string( $user_set_themes );
          $self->set_themes( @set_themes );
      }
  
      my $user_add_themes = $config->get_add_themes();
      if ( defined $user_add_themes ) {
          my @add_themes = words_from_string( $user_add_themes );
          $self->add_themes( @add_themes );
      }
  
      if ( $errors->has_exceptions() ) {
          $errors->rethrow();
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _set_maximum_violations_per_document {
      my ($self, $errors) = @_;
  
      my $config = $self->__get_config();
  
      if ( $config->is_maximum_violations_per_document_unlimited() ) {
          return;
      }
  
      my $user_maximum_violations =
          $config->get_maximum_violations_per_document();
  
      if ( not is_integer($user_maximum_violations) ) {
          $errors->add_exception(
              new_parameter_value_exception(
                  'maximum_violations_per_document',
                  $user_maximum_violations,
                  undef,
                  "does not look like an integer.\n"
              )
          );
  
          return;
      }
      elsif ( $user_maximum_violations < 0 ) {
          $errors->add_exception(
              new_parameter_value_exception(
                  'maximum_violations_per_document',
                  $user_maximum_violations,
                  undef,
                  "is not greater than or equal to zero.\n"
              )
          );
  
          return;
      }
  
      $self->set_maximum_violations_per_document(
          $user_maximum_violations
      );
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # Unparsed configuration, P::C::PolicyConfig.  Compare with get_parameters().
  sub __get_config {
      my ($self) = @_;
  
      return $self->{_config};
  }
  
  sub __set_config {
      my ($self, $config) = @_;
  
      $self->{_config} = $config;
  
      return;
  }
  
   #-----------------------------------------------------------------------------
  
  sub get_long_name {
      my ($self) = @_;
  
      return policy_long_name(ref $self);
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_short_name {
      my ($self) = @_;
  
      return policy_short_name(ref $self);
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_enabled {
      my ($self) = @_;
  
      return $self->{_enabled};
  }
  
  #-----------------------------------------------------------------------------
  
  sub __set_enabled {
      my ($self, $new_value) = @_;
  
      $self->{_enabled} = $new_value;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub applies_to {
      return qw(PPI::Element);
  }
  
  #-----------------------------------------------------------------------------
  
  sub set_maximum_violations_per_document {
      my ($self, $maximum_violations_per_document) = @_;
  
      $self->{_maximum_violations_per_document} =
          $maximum_violations_per_document;
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_maximum_violations_per_document {
      my ($self) = @_;
  
      return
          exists $self->{_maximum_violations_per_document}
              ? $self->{_maximum_violations_per_document}
              : $self->default_maximum_violations_per_document();
  }
  
  #-----------------------------------------------------------------------------
  
  sub default_maximum_violations_per_document {
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub set_severity {
      my ($self, $severity) = @_;
      $self->{_severity} = $severity;
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_severity {
      my ($self) = @_;
      return $self->{_severity} || $self->default_severity();
  }
  
  #-----------------------------------------------------------------------------
  
  sub default_severity {
      return $SEVERITY_LOWEST;
  }
  
  #-----------------------------------------------------------------------------
  
  sub set_themes {
      my ($self, @themes) = @_;
      $self->{_themes} = [ sort @themes ];
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_themes {
      my ($self) = @_;
      my @themes = defined $self->{_themes} ? @{ $self->{_themes} } : $self->default_themes();
      my @sorted_themes = sort @themes;
      return @sorted_themes;
  }
  
  #-----------------------------------------------------------------------------
  
  sub add_themes {
      my ($self, @additional_themes) = @_;
      #By hashifying the themes, we squish duplicates
      my %merged = hashify( $self->get_themes(), @additional_themes);
      $self->{_themes} = [ keys %merged];
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub default_themes {
      return ();
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_abstract {
      my ($self) = @_;
  
      return get_module_abstract_for_module( ref $self );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_abstract {
      my ($self) = @_;
  
      return get_raw_module_abstract_for_module( ref $self );
  }
  
  #-----------------------------------------------------------------------------
  
  sub parameter_metadata_available {
      my ($self) = @_;
  
      return $self->{_parameter_metadata_available};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_parameters {
      my ($self) = @_;
  
      return $self->{_parameters};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self) = @_;
  
      return throw_policy_definition
          $self->get_short_name() . q/ does not implement violates()./;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violation {  ## no critic (ArgUnpacking)
      my ( $self, $desc, $expl, $elem ) = @_;
      # HACK!! Use goto instead of an explicit call because P::C::V::new() uses caller()
      my $sev = $self->get_severity();
      @_ = ('Perl::Critic::Violation', $desc, $expl, $elem, $sev );
      goto &Perl::Critic::Violation::new;
  }
  
  #-----------------------------------------------------------------------------
  
  sub new_parameter_value_exception {
      my ( $self, $option_name, $option_value, $source, $message_suffix ) = @_;
  
      return Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(
          policy          => $self->get_short_name(),
          option_name     => $option_name,
          option_value    => $option_value,
          source          => $source,
          message_suffix  => $message_suffix
      );
  }
  
  #-----------------------------------------------------------------------------
  
  ## no critic (Subroutines::RequireFinalReturn)
  sub throw_parameter_value_exception {
      my ( $self, $option_name, $option_value, $source, $message_suffix ) = @_;
  
      $self->new_parameter_value_exception(
          $option_name, $option_value, $source, $message_suffix
      )
          ->throw();
  }
  ## use critic
  
  
  #-----------------------------------------------------------------------------
  
  # Static methods.
  
  sub set_format { return $format = $_[0] }  ## no critic(ArgUnpacking)
  sub get_format { return $format         }
  
  #-----------------------------------------------------------------------------
  
  sub to_string {
      my ($self, @args) = @_;
  
      # Wrap the more expensive ones in sub{} to postpone evaluation
      my %fspec = (
           'P' => sub { $self->get_long_name() },
           'p' => sub { $self->get_short_name() },
           'a' => sub { dor($self->get_abstract(), $EMPTY) },
           'O' => sub { $self->_format_parameters(@_) },
           'U' => sub { $self->_format_lack_of_parameter_metadata(@_) },
           'S' => sub { $self->default_severity() },
           's' => sub { $self->get_severity() },
           'T' => sub { join $SPACE, $self->default_themes() },
           't' => sub { join $SPACE, $self->get_themes() },
           'V' => sub { dor( $self->default_maximum_violations_per_document(), $NO_LIMIT ) },
           'v' => sub { dor( $self->get_maximum_violations_per_document(), $NO_LIMIT ) },
      );
      return stringf(get_format(), %fspec);
  }
  
  sub _format_parameters {
      my ($self, $parameter_format) = @_;
  
      return $EMPTY if not $self->parameter_metadata_available();
  
      my $separator;
      if ($parameter_format) {
          $separator = $EMPTY;
      } else {
          $separator = $SPACE;
          $parameter_format = '%n';
      }
  
      return
          join
              $separator,
              map { $_->to_formatted_string($parameter_format) } @{ $self->get_parameters() };
  }
  
  sub _format_lack_of_parameter_metadata {
      my ($self, $message) = @_;
  
      return $EMPTY if $self->parameter_metadata_available();
      return interpolate($message) if $message;
  
      return
          'Cannot programmatically discover what parameters this policy takes.';
  }
  
  #-----------------------------------------------------------------------------
  # Apparently, some perls do not implicitly stringify overloading
  # objects before doing a comparison.  This causes a couple of our
  # sorting tests to fail.  To work around this, we overload C<cmp> to
  # do it explicitly.
  #
  # 20060503 - More information:  This problem has been traced to
  # Test::Simple versions <= 0.60, not perl itself.  Upgrading to
  # Test::Simple v0.62 will fix the problem.  But rather than forcing
  # everyone to upgrade, I have decided to leave this workaround in
  # place.
  
  sub _compare { return "$_[0]" cmp "$_[1]" }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy - Base class for all Policy modules.
  
  
  =head1 DESCRIPTION
  
  Perl::Critic::Policy is the abstract base class for all Policy
  objects.  If you're developing your own Policies, your job is to
  implement and override its methods in a subclass.  To work with the
  L<Perl::Critic|Perl::Critic> engine, your implementation must behave
  as described below.  For a detailed explanation on how to make new
  Policy modules, please see the
  L<Perl::Critic::DEVELOPER|Perl::Critic::DEVELOPER> document included
  in this distribution.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<< new( ... ) >>
  
  Don't call this.  As a Policy author, do not implement this.  Use the
  C<initialize_if_enabled()> method for your Policy setup.  See the
  L<developer|Perl::Critic::DEVELOPER> documentation for more.
  
  
  =item C<< initialize_if_enabled( $config ) >>
  
  This receives an instance of
  L<Perl::Critic::PolicyConfig|Perl::Critic::PolicyConfig> as a
  parameter, and is only invoked if this Policy is enabled by the user.
  Thus, this is the preferred place for subclasses to do any
  initialization.
  
  Implementations of this method should return a boolean value
  indicating whether the Policy should continue to be enabled.  For most
  subclasses, this will always be C<$TRUE>.  Policies that depend upon
  external modules or other system facilities that may or may not be
  available should test for the availability of these dependencies and
  return C<$FALSE> if they are not.
  
  
  =item C<< prepare_to_scan_document( $document ) >>
  
  The parameter is about to be scanned by this Policy.  Whatever this
  Policy wants to do in terms of preparation should happen here.
  Returns a boolean value indicating whether the document should be
  scanned at all; if this is a false value, this Policy won't be applied
  to the document.  By default, does nothing but return C<$TRUE>.
  
  
  =item C< violates( $element, $document ) >
  
  Given a L<PPI::Element|PPI::Element> and a
  L<PPI::Document|PPI::Document>, returns one or more
  L<Perl::Critic::Violation|Perl::Critic::Violation> objects if the
  C<$element> violates this Policy.  If there are no violations, then it
  returns an empty list.  If the Policy encounters an exception, then it
  should C<croak> with an error message and let the caller decide how to
  handle it.
  
  C<violates()> is an abstract method and it will abort if you attempt
  to invoke it directly.  It is the heart of all Policy modules, and
  your subclass B<must> override this method.
  
  
  =item C< violation( $description, $explanation, $element ) >
  
  Returns a reference to a new C<Perl::Critic::Violation> object. The
  arguments are a description of the violation (as string), an
  explanation for the policy (as string) or a series of page numbers in
  PBP (as an ARRAY ref), a reference to the L<PPI|PPI> element that
  caused the violation.
  
  These are the same as the constructor to
  L<Perl::Critic::Violation|Perl::Critic::Violation>, but without the
  severity.  The Policy itself knows the severity.
  
  
  =item C< new_parameter_value_exception( $option_name, $option_value, $source, $message_suffix ) >
  
  Create a
  L<Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue|Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue>
  for this Policy.
  
  
  =item C< throw_parameter_value_exception( $option_name, $option_value, $source, $message_suffix ) >
  
  Create and throw a
  L<Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue|Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue>.
  Useful in parameter parser implementations.
  
  
  =item C< get_long_name() >
  
  Return the full package name of this policy.
  
  
  =item C< get_short_name() >
  
  Return the name of this policy without the "Perl::Critic::Policy::"
  prefix.
  
  
  =item C< is_enabled() >
  
  Answer whether this policy is really active or not.  Returns a true
  value if it is, a false, yet defined, value if it isn't, and an
  undefined value if it hasn't yet been decided whether it will be.
  
  
  =item C< applies_to() >
  
  Returns a list of the names of PPI classes that this Policy cares
  about.  By default, the result is C<PPI::Element>.  Overriding this
  method in Policy subclasses should lead to significant performance
  increases.
  
  
  =item C< default_maximum_violations_per_document() >
  
  Returns the default maximum number of violations for this policy to
  report per document.  By default, this not defined, but subclasses may
  override this.
  
  
  =item C< get_maximum_violations_per_document() >
  
  Returns the maximum number of violations this policy will report for a
  single document.  If this is not defined, then there is no limit.  If
  L</set_maximum_violations_per_document()> has not been invoked, then
  L</default_maximum_violations_per_document()> is returned.
  
  
  =item C< set_maximum_violations_per_document() >
  
  Specify the maximum violations that this policy should report for a
  document.
  
  
  =item C< default_severity() >
  
  Returns the default severity for violating this Policy.  See the
  C<$SEVERITY> constants in L<Perl::Critic::Utils|Perl::Critic::Utils>
  for an enumeration of possible severity values.  By default, this
  method returns C<$SEVERITY_LOWEST>.  Authors of Perl::Critic::Policy
  subclasses should override this method to return a value that they
  feel is appropriate for their Policy.  In general, Polices that are
  widely accepted or tend to prevent bugs should have a higher severity
  than those that are more subjective or cosmetic in nature.
  
  
  =item C< get_severity() >
  
  Returns the severity of violating this Policy.  If the severity has
  not been explicitly defined by calling C<set_severity>, then the
  C<default_severity> is returned.  See the C<$SEVERITY> constants in
  L<Perl::Critic::Utils|Perl::Critic::Utils> for an enumeration of
  possible severity values.
  
  
  =item C< set_severity( $N ) >
  
  Sets the severity for violating this Policy.  Clients of
  Perl::Critic::Policy objects can call this method to assign a
  different severity to the Policy if they don't agree with the
  C<default_severity>.  See the C<$SEVERITY> constants in
  L<Perl::Critic::Utils|Perl::Critic::Utils> for an enumeration of
  possible values.
  
  
  =item C< default_themes() >
  
  Returns a sorted list of the default themes associated with this
  Policy.  The default method returns an empty list.  Policy authors
  should override this method to return a list of themes that are
  appropriate for their policy.
  
  
  =item C< get_themes() >
  
  Returns a sorted list of the themes associated with this Policy.  If
  you haven't added themes or set the themes explicitly, this method
  just returns the default themes.
  
  
  =item C< set_themes( @THEME_LIST ) >
  
  Sets the themes associated with this Policy.  Any existing themes are
  overwritten.  Duplicate themes will be removed.
  
  
  =item C< add_themes( @THEME_LIST ) >
  
  Appends additional themes to this Policy.  Any existing themes are
  preserved.  Duplicate themes will be removed.
  
  
  =item C< get_abstract() >
  
  Retrieve the abstract for this policy (the part of the NAME section of
  the POD after the module name), if it is available.
  
  
  =item C< get_raw_abstract() >
  
  Retrieve the abstract for this policy (the part of the NAME section of
  the POD after the module name), if it is available, in the unparsed
  form.
  
  
  =item C< parameter_metadata_available() >
  
  Returns whether information about the parameters is available.
  
  
  =item C< get_parameters() >
  
  Returns a reference to an array containing instances of
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  Note that this will return an empty list if the parameters for this
  policy are unknown.  In order to differentiate between this
  circumstance and the one where this policy does not take any
  parameters, it is necessary to call C<parameter_metadata_available()>.
  
  
  =item C<set_format( $format )>
  
  Class method.  Sets the format for all Policy objects when they are
  evaluated in string context.  The default is C<"%p\n">.  See
  L<"OVERLOADS"> for formatting options.
  
  
  =item C<get_format()>
  
  Class method. Returns the current format for all Policy objects when
  they are evaluated in string context.
  
  
  =item C<to_string()>
  
  Returns a string representation of the policy.  The content of the
  string depends on the current value returned by C<get_format()>.
  See L<"OVERLOADS"> for the details.
  
  
  =item C<is_safe()>
  
  Answer whether this Policy can be used to analyze untrusted code, i.e. the
  Policy doesn't have any potential side effects.
  
  This method returns a true value by default.
  
  An "unsafe" policy might attempt to compile the code, which, if you have
  C<BEGIN> or C<CHECK> blocks that affect files or connect to databases, is not
  a safe thing to do.  If you are writing a such a Policy, then you should
  override this method to return false.
  
  By default L<Perl::Critic|Perl::Critic> will not run unsafe policies.
  
  
  
  =back
  
  
  =head1 DOCUMENTATION
  
  When your Policy module first C<use>s
  L<Perl::Critic::Violation|Perl::Critic::Violation>, it will try and
  extract the DESCRIPTION section of your Policy module's POD.  This
  information is displayed by Perl::Critic if the verbosity level is set
  accordingly.  Therefore, please include a DESCRIPTION section in the
  POD for any Policy modules that you author.  Thanks.
  
  
  =head1 OVERLOADS
  
  Perl::Critic::Violation overloads the C<""> operator to produce neat
  little messages when evaluated in string context.
  
  Formats are a combination of literal and escape characters similar to
  the way C<sprintf> works.  If you want to know the specific formatting
  capabilities, look at L<String::Format|String::Format>. Valid escape
  characters are:
  
  
  =over
  
  =item C<%P>
  
  Name of the Policy module.
  
  
  =item C<%p>
  
  Name of the Policy without the C<Perl::Critic::Policy::> prefix.
  
  
  =item C<%a>
  
  The policy abstract.
  
  
  =item C<%O>
  
  List of supported policy parameters.  Takes an option of a format
  string for L<Perl::Critic::PolicyParameter/"to_formatted_string">.
  For example, this can be used like C<%{%n - %d\n}O> to get a list of
  parameter names followed by their descriptions.
  
  
  =item C<%U>
  
  A message stating that the parameters for the policy are unknown if
  C<parameter_metadata_available()> returns false.  Takes an option of
  what the message should be, which defaults to "Cannot programmatically
  discover what parameters this policy takes.".  The value of this
  option is interpolated in order to expand the standard escape
  sequences (C<\n>, C<\t>, etc.).
  
  
  =item C<%S>
  
  The default severity level of the policy.
  
  
  =item C<%s>
  
  The current severity level of the policy.
  
  
  =item C<%T>
  
  The default themes for the policy.
  
  
  =item C<%t>
  
  The current themes for the policy.
  
  
  =item C<%V>
  
  The default maximum number of violations per document of the policy.
  
  
  =item C<%v>
  
  The current maximum number of violations per document of the policy.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitBooleanGrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITBOOLEANGREP';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitBooleanGrep;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification hashify };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"grep" used in boolean context};
  Readonly::Scalar my $EXPL => [71,72];
  
  Readonly::Hash my %POSTFIX_CONDITIONALS => hashify( qw(if unless while until) );
  Readonly::Hash my %BOOLEAN_OPERATORS => hashify( qw(&& || ! not or and));
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_LOW          }
  sub default_themes       { return qw( core pbp performance certrec ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'grep';
      return if not is_function_call($elem);
      return if not _is_in_boolean_context($elem);
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_in_boolean_context {
      my ($token) = @_;
  
      return _does_prev_sibling_cause_boolean($token) || _does_parent_cause_boolean($token);
  }
  
  sub _does_prev_sibling_cause_boolean {
      my ($token) = @_;
  
      my $prev = $token->sprevious_sibling;
      return if !$prev;
      return 1 if $prev->isa('PPI::Token::Word') and $POSTFIX_CONDITIONALS{$prev};
      return if not ($prev->isa('PPI::Token::Operator') and $BOOLEAN_OPERATORS{$prev});
      my $next = $token->snext_sibling;
      return 1 if not $next; # bizarre: grep with no arguments
  
      # loose heuristic: unparenthesized grep has no following non-boolean operators
      return 1 if not $next->isa('PPI::Structure::List');
  
      $next = $next->snext_sibling;
      return 1 if not $next;
      return 1 if $next->isa('PPI::Token::Operator') and $BOOLEAN_OPERATORS{$next};
      return;
  }
  
  sub _does_parent_cause_boolean {
      my ($token) = @_;
  
      my $prev = $token->sprevious_sibling;
      return if $prev;
      my $parent = $token->statement->parent;
      for (my $node = $parent; $node; $node = $node->parent) { ## no critic (CStyleForLoop)
          next if $node->isa('PPI::Structure::List');
          return 1 if $node->isa('PPI::Structure::Condition');
      }
  
      return;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitBooleanGrep - Use C<List::MoreUtils::any> instead of C<grep> in boolean context.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using C<grep> in boolean context is a common idiom for checking if any
  elements in a list match a condition.  This works because boolean
  context is a subset of scalar context, and grep returns the number of
  matches in scalar context.  A non-zero number of matches means a
  match.
  
  But consider the case of a long array where the first element is a
  match.  Boolean C<grep> still checks all of the rest of the elements
  needlessly.  Instead, a better solution is to use the C<any> function
  from L<List::MoreUtils|List::MoreUtils>, which short-circuits after
  the first successful match to save time.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CAVEATS
  
  The algorithm for detecting boolean context takes a LOT of shortcuts.
  There are lots of known false negatives.  But, I was conservative in
  writing this, so I hope there are no false positives.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITBOOLEANGREP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitComplexMappings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITCOMPLEXMAPPINGS';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitComplexMappings;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Map blocks should have a single statement};
  Readonly::Scalar my $EXPL => [ 113 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_statements',
              description     =>
                  'The maximum number of statements to allow within a map block.',
              default_string  => '1',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity  { return $SEVERITY_MEDIUM                     }
  sub default_themes    { return qw( core pbp maintenance complexity) }
  sub applies_to        { return 'PPI::Token::Word'                   }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'map';
      return if ! is_function_call($elem);
  
      my $sib = $elem->snext_sibling();
      return if !$sib;
  
      my $arg = $sib;
      if ( $arg->isa('PPI::Structure::List') ) {
          $arg = $arg->schild(0);
          # Forward looking: PPI might change in v1.200 so schild(0) is a PPI::Statement::Expression
          if ( $arg && $arg->isa('PPI::Statement::Expression') ) {
              $arg = $arg->schild(0);
          }
      }
      # If it's not a block, it's an expression-style map, which is only one statement by definition
      return if !$arg;
      return if !$arg->isa('PPI::Structure::Block');
  
      # If we get here, we found a sort with a block as the first arg
      return if $self->{_max_statements} >= $arg->schildren()
          && 0 == grep {$_->isa('PPI::Statement::Compound')} $arg->schildren();
  
      # more than one child statements
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitComplexMappings - Map blocks should have a single statement.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The map function can be confusing to novices in the best of
  circumstances.  Mappings with multiple statements are even worse.
  They're also a maintainer's nightmare because any added complexity
  decreases readability precipitously.  Why?  Because map is
  traditionally a one-liner converting one array to another.  Trying to
  cram lots of functionality into a one-liner is a bad idea in general.
  
  The best solutions to a complex mapping are: 1) write a subroutine
  that performs the manipulation and call that from map; 2) rewrite the
  map as a for loop.
  
  
  =head1 CAVEATS
  
  This policy currently misses some compound statements inside of the
  map.  For example, the following code incorrectly does not trigger a
  violation:
  
      map { do { foo(); bar() } } @list
  
  
  =head1 CONFIGURATION
  
  By default this policy flags any mappings with more than one
  statement.  While we do not recommend it, you can increase this limit
  as follows in a F<.perlcriticrc> file:
  
      [BuiltinFunctions::ProhibitComplexMappings]
      max_statements = 2
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITCOMPLEXMAPPINGS

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitLvalueSubstr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITLVALUESUBSTR';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitLvalueSubstr;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  use version 0.77 ();
  
  use Perl::Critic::Utils qw{ :severities :classification :language };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Lvalue form of "substr" used};
  Readonly::Scalar my $EXPL => [ 165 ];
  
  Readonly::Scalar my $ASSIGNMENT_PRECEDENCE => precedence_of( q{=} );
  Readonly::Scalar my $MINIMUM_PERL_VERSION => version->new( 5.005 );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance pbp ) }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      my ( $self, $document ) = @_;
      # perl5005delta says that is when the fourth argument to substr()
      # was introduced, so ... (RT #59112)
      my $version = $document->highest_explicit_perl_version();
      return ! $version || $version >= $MINIMUM_PERL_VERSION;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      return if $elem->content() ne 'substr';
      return if ! is_function_call($elem);
  
      my $sib = $elem;
      while ($sib = $sib->snext_sibling()) {
          if ( $sib->isa( 'PPI::Token::Operator' ) ) {
              my $rslt = $ASSIGNMENT_PRECEDENCE <=> precedence_of(
                  $sib->content() );
              return if $rslt < 0;
              return $self->violation( $DESC, $EXPL, $sib ) if $rslt == 0;
          }
      }
      return; #ok!
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords perlfunc substr 4th
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitLvalueSubstr - Use 4-argument C<substr> instead of writing C<substr($foo, 2, 6) = $bar>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages the use of C<substr()> as an lvalue, instead
  recommending that the 4-argument version of C<substr()> be used
  instead.
  
      substr($something, 1, 2) = $newvalue;     # not ok
      substr($something, 1, 2, $newvalue);      # ok
  
  The four-argument form of C<substr()> was introduced in Perl 5.005.
  This policy does not report violations on code which explicitly
  specifies an earlier version of Perl (e.g. C<use 5.004;>).
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<"substr" in perlfunc|perlfunc/substr> (or C<perldoc -f substr>).
  
  L<"4th argument to substr" in perl5005delta|perl5005delta/4th argument to substr>
  
  
  =head1 AUTHOR
  
  Graham TerMarsch <graham@howlingfrog.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Graham TerMarsch.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITLVALUESUBSTR

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitReverseSortBlock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITREVERSESORTBLOCK';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitReverseSortBlock;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Forbid $b before $a in sort blocks}; ## no critic (InterpolationOfMetachars)
  Readonly::Scalar my $EXPL => [ 152 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOWEST      }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return 'PPI::Token::Word'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
  
      return if $elem->content() ne 'sort';
      return if ! is_function_call($elem);
  
      my $sib = $elem->snext_sibling();
      return if !$sib;
  
      my $arg = $sib;
      if ( $arg->isa('PPI::Structure::List') ) {
          $arg = $arg->schild(0);
          # Forward looking: PPI might change in v1.200 so schild(0) is a PPI::Statement::Expression
          if ( $arg && $arg->isa('PPI::Statement::Expression') ) {
              $arg = $arg->schild(0);
          }
      }
      return if !$arg || !$arg->isa('PPI::Structure::Block');
  
      # If we get here, we found a sort with a block as the first arg
  
      # Look at each statement in the block separately.
      # $a is +1, $b is -1, sum should always be >= 0.
      # This may go badly if there are conditionals or loops or other
      # sub-statements...
      for my $statement ($arg->children) {
          my @sort_vars = $statement =~ m/\$([ab])\b/gxms;
          my $count = 0;
          for my $sort_var (@sort_vars) {
              if ($sort_var eq 'a') {
                  $count++;
              } else {
                  $count--;
                  if ($count < 0) {
                      # Found too many C<$b>s too early
                      return $self->violation( $DESC, $EXPL, $elem );
                  }
              }
          }
      }
      return; #ok
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitReverseSortBlock - Forbid $b before $a in sort blocks.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway says that it is much clearer to use C<reverse> than to flip
  C<$a> and C<$b> around in a C<sort> block.  He also suggests that, in
  newer perls, C<reverse> is specifically looked for and optimized, and
  in the case of a simple reversed string C<sort>, using C<reverse> with
  a C<sort> with no block is faster even in old perls.
  
      my @foo = sort { $b cmp $a } @bar;         #not ok
      my @foo = reverse sort @bar;               #ok
  
      my @foo = sort { $b <=> $a } @bar;         #not ok
      my @foo = reverse sort { $a <=> $b } @bar; #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITREVERSESORTBLOCK

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitSleepViaSelect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSLEEPVIASELECT';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitSleepViaSelect;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"select" used to emulate "sleep"};
  Readonly::Scalar my $EXPL => [168];
  Readonly::Scalar my $SELECT_ARGUMENT_COUNT => 4;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGHEST   }
  sub default_themes       { return qw( core pbp bugs ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      return if $elem->content() ne 'select';
      return if ! is_function_call($elem);
  
      my @arguments = parse_arg_list($elem);
      return if $SELECT_ARGUMENT_COUNT != @arguments;
  
      foreach my $argument ( @arguments[0..2] ) {
          return if $argument->[0] ne 'undef';
      }
  
      if ( $arguments[-1]->[0] ne 'undef' ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return; #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords perlfunc
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitSleepViaSelect - Use L<Time::HiRes|Time::HiRes> instead of something like C<select(undef, undef, undef, .05)>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages the use of C<select()> for performing non-integer
  sleeps.  Although documented in L<perlfunc|perlfunc>, it's something
  that generally requires the reader to read C<perldoc -f select> to
  figure out what it should be doing.  Instead, Conway recommends that
  you use the C<Time::HiRes> module when you want to sleep.
  
      select undef, undef, undef, 0.25;         # not ok
  
      use Time::HiRes;
      sleep( 0.25 );                            # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Time::HiRes|Time::HiRes>.
  
  
  =head1 AUTHOR
  
  Graham TerMarsch <graham@howlingfrog.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Graham TerMarsch.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSLEEPVIASELECT

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitStringyEval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYEVAL';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use PPI::Document;
  
  use Perl::Critic::Utils qw{ :booleans :severities :classification :ppi $SCOLON };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Expression form of "eval"};
  Readonly::Scalar my $EXPL => [ 161 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'allow_includes',
              description    => q<Allow eval of "use" and "require" strings.>,
              default_string => '0',
              behavior       => 'boolean',
          },
      );
  }
  sub default_severity     { return $SEVERITY_HIGHEST   }
  sub default_themes       { return qw( core pbp bugs certrule ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'eval';
      return if not is_function_call($elem);
  
      my $argument = first_arg($elem);
      return if not $argument;
      return if $argument->isa('PPI::Structure::Block');
      return if
          $self->{_allow_includes} and _string_eval_is_an_include($argument);
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  sub _string_eval_is_an_include {
      my ($eval_argument) = @_;
  
      return if not $eval_argument->isa('PPI::Token::Quote');
  
      my $string = $eval_argument->string();
      my $document;
  
      eval { $document = PPI::Document->new(\$string); 1 }
          or return;
  
      my @statements = $document->schildren;
  
      return if @statements > 2;
      my $include = $statements[0];
      return if not defined $include; # RT 60179
      return if not $include->isa('PPI::Statement::Include');
      return if $include->type() eq 'no';
  
      if (
              $eval_argument->isa('PPI::Token::Quote::Single')
          or  $eval_argument->isa('PPI::Token::Quote::Literal')
      ) {
          # Don't allow funky inclusion of arbitrary code (note we do allow
          # interpolated values in interpolating strings because they can't
          # entirely screw with the syntax).
          return if $include->find('PPI::Token::Symbol');
      }
  
      return $TRUE if @statements == 1;
  
      my $follow_on = $statements[1];
      return if not $follow_on->isa('PPI::Statement');
  
      my @follow_on_components = $follow_on->schildren();
  
      return if @follow_on_components > 2;
      return if not $follow_on_components[0]->isa('PPI::Token::Number');
      return $TRUE if @follow_on_components == 1;
  
      return $follow_on_components[1]->content() eq $SCOLON;
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords SIGNES
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval - Write C<eval { my $foo; bar($foo) }> instead of C<eval "my $foo; bar($foo);">.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The string form of C<eval> is recompiled every time it is executed,
  whereas the block form is only compiled once.  Also, the string form
  doesn't give compile-time warnings.
  
      eval "print $foo";        # not ok
      eval {print $foo};        # ok
  
  
  =head1 CONFIGURATION
  
  There is an C<allow_includes> boolean option for this Policy.  If set, then
  strings that look like they only include a single "use" or "require" statement
  (with the possible following statement that consists of a single number) are
  allowed.  With this option set, the following are flagged as indicated:
  
      eval 'use Foo';             # ok
      eval 'require Foo';         # ok
      eval "use $thingy;";        # ok
      eval "require $thingy;";    # ok
      eval "use $thingy; 1;";     # ok
      eval "require $thingy; 1;"; # ok
  
      eval 'use Foo; blah;';      # still not ok
      eval 'require Foo; 2; 1;';  # still not ok
      eval 'use $thingy;';        # still not ok
      eval 'no Foo';              # still not ok
  
  If you don't understand why the number is allowed, see
  L<Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval|Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval>.
  
  This option inspired by Ricardo SIGNES'
  L<Perl::Critic::Policy::Lax::ProhibitStringyEval::ExceptForRequire|Perl::Critic::Policy::Lax::ProhibitStringyEval::ExceptForRequire>.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::BuiltInFunctions::RequireBlockGrep|Perl::Critic::Policy::BuiltInFunctions::RequireBlockGrep>
  
  L<Perl::Critic::Policy::BuiltInFunctions::RequireBlockMap|Perl::Critic::Policy::BuiltInFunctions::RequireBlockMap>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYEVAL

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitStringySplit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYSPLIT';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitStringySplit;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{String delimiter used with "split"};
  Readonly::Scalar my $EXPL => q{Express it as a regex instead};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic certrule ) }
  sub applies_to           { return 'PPI::Token::Word'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'split';
      return if ! is_function_call($elem);
  
      my @args = parse_arg_list($elem);
      my $pattern = @args ? $args[0]->[0] : return;
  
      if ( $pattern->isa('PPI::Token::Quote') && $pattern->string() ne $SPACE ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return;  #ok
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitStringySplit - Write C<split /-/, $string> instead of C<split '-', $string>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The C<split> function always interprets the PATTERN argument as a
  regular expression, even if you specify it as a string.  This causes
  much confusion if the string contains regex metacharacters.  So for
  clarity, always express the PATTERN argument as a regex.
  
      $string = 'Fred|Barney';
      @names = split '|', $string; #not ok, is ('F', 'r', 'e', 'd', '|', 'B', 'a' ...)
      @names = split m/[|]/, $string; #ok, is ('Fred', Barney')
  
  When the PATTERN is a single space the C<split> function has special
  behavior, so Perl::Critic forgives that usage.  See C<"perldoc -f
  split"> for more information.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::BuiltInFunctions::RequireBlockGrep|Perl::Critic::Policy::BuiltInFunctions::RequireBlockGrep>
  
  L<Perl::Critic::Policy::BuiltInFunctions::RequireBlockMap|Perl::Critic::Policy::BuiltInFunctions::RequireBlockMap>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITSTRINGYSPLIT

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitUniversalCan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALCAN';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalCan;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{UNIVERSAL::can should not be used as a function};
  Readonly::Scalar my $EXPL => q{Use eval{$obj->can($pkg)} instead};  ## no critic (RequireInterp);
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if !($elem eq 'can' || $elem eq 'UNIVERSAL::can');
      return if ! is_function_call($elem); # this also permits 'use UNIVERSAL::can;'
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalCan - Write C<< eval { $foo->can($name) } >> instead of C<UNIVERSAL::can($foo, $name)>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
      print UNIVERSAL::can($obj, 'Foo::Bar') ? 'yes' : 'no';  #not ok
      print eval { $obj->can('Foo::Bar') } ? 'yes' : 'no';    #ok
  
  As of Perl 5.9.3, the use of UNIVERSAL::can as a function has been
  deprecated and the method form is preferred instead.  Formerly, the
  functional form was recommended because it gave valid results even
  when the object was C<undef> or an unblessed scalar.  However, the
  functional form makes it impossible for packages to override C<can()>,
  a technique which is crucial for implementing mock objects and some
  facades.
  
  See L<UNIVERSAL::can|UNIVERSAL::can> for a more thorough discussion of
  this topic.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalIsa|Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalIsa>
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALCAN

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitUniversalIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALISA';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalIsa;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{UNIVERSAL::isa should not be used as a function};
  Readonly::Scalar my $EXPL => q{Use eval{$obj->isa($pkg)} instead};  ## no critic (RequireInterp);
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if !($elem eq 'isa' || $elem eq 'UNIVERSAL::isa');
      return if ! is_function_call($elem); # this also permits 'use UNIVERSAL::isa;'
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalIsa - Write C<< eval { $foo->isa($pkg) } >> instead of C<UNIVERSAL::isa($foo, $pkg)>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
      print UNIVERSAL::isa($obj, 'Foo::Bar') ? 'yes' : 'no';  #not ok
      print eval { $obj->isa('Foo::Bar') } ? 'yes' : 'no';    #ok
  
  As of Perl 5.9.3, the use of C<UNIVERSAL::isa> as a function has been
  deprecated and the method form is preferred instead.  Formerly, the
  functional form was recommended because it gave valid results even
  when the object was C<undef> or an unblessed scalar.  However, the
  functional form makes it impossible for packages to override C<isa()>,
  a technique which is crucial for implementing mock objects and some
  facades.
  
  Another alternative to UNIVERSAL::isa is the C<_INSTANCE> method of
  Param::Util, which is faster.
  
  See the CPAN module L<UNIVERSAL::isa|UNIVERSAL::isa> for an incendiary
  discussion of this topic.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalCan|Perl::Critic::Policy::BuiltinFunctions::ProhibitUniversalCan>
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUNIVERSALISA

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitUselessTopic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUSELESSTOPIC';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitUselessTopic;
  
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  ## no critic ( ValuesAndExpressions::RequireInterpolationOfMetachars )
  ## The numerous $_ variables make false positives.
  Readonly::Scalar my $DESC                => q{Useless use of $_};
  Readonly::Scalar my $EXPL_FILETEST       => q{$_ should be omitted when using a filetest operator};
  Readonly::Scalar my $EXPL_FUNCTION       => q{$_ should be omitted when calling "%s"};
  Readonly::Scalar my $EXPL_FUNCTION_SPLIT => q{$_ should be omitted when calling "split" with two arguments};
  
  sub supported_parameters { return () }
  sub default_severity     { return $SEVERITY_LOW }
  sub default_themes       { return qw( core ) }
  sub applies_to           { return 'PPI::Token::Operator', 'PPI::Token::Word' }
  
  my @filetest_operators = qw( -r -w -x -o -R -W -X -O -e -z -s -f -d -l -p -S -b -c -u -g -k -T -B -M -A -C );
  my %filetest_operators = map { ($_ => 1) } @filetest_operators;
  
  my @topical_funcs = qw(
      abs alarm
      chomp chop chr chroot cos
      defined
      eval exp
      fc
      glob
      hex
      int
      lc lcfirst length log lstat
      mkdir
      oct ord
      pos print
      quotemeta
      readlink readpipe ref require reverse rmdir
      say sin split sqrt stat study
      uc ucfirst unlink unpack
  );
  my %topical_funcs = map { ($_ => 1) } @topical_funcs;
  
  my %applies_to = ( %topical_funcs, %filetest_operators );
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if not exists $applies_to{ $elem->content };
  
      my $content = $elem->content;
  
      # Are we looking at a filetest?
      if ( $filetest_operators{ $content } ) {
          # Is there a $_ following it?
          my $op_node = $elem->snext_sibling;
          if ( $op_node && $op_node->isa('PPI::Token::Magic') ) {
              my $op = $op_node->content;
              if ( $op eq '$_' ) {
                  return $self->violation( $DESC, $EXPL_FILETEST, $elem );
              }
          }
          return;
      }
  
      if ( $topical_funcs{ $content } && is_perl_builtin( $elem ) ) {
          my $is_split = $content eq 'split';
  
          my @args = parse_arg_list( $elem );
  
          my $nth_arg_for_topic;
          if ( $is_split ) {
              return if @args != 2; # Ignore split( /\t/ ) or split( /\t/, $_, 3 )
              $nth_arg_for_topic = 2;
          }
          else {
              $nth_arg_for_topic = 1;
          }
  
          if ( @args == $nth_arg_for_topic ) {
              my $topic_arg = $args[ $nth_arg_for_topic - 1 ];
              my @tokens = @{$topic_arg};
              if ( (@tokens == 1) && ($tokens[0]->content eq '$_') ) {
                  my $msg = $is_split ? $EXPL_FUNCTION_SPLIT : (sprintf $EXPL_FUNCTION, $content);
                  return $self->violation( $DESC, $msg, $elem );
              }
          }
          return;
      }
  
      return;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords filetest
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitUselessTopic - Don't pass $_ to built-in functions that assume it, or to most filetest operators.
  
  =head1 AFFILIATION
  
  This Policy is part of the L<Perl::Critic|Perl::Critic> distribution.
  
  =head1 DESCRIPTION
  
  There are a number of places where C<$_>, or "the topic" variable,
  is unnecessary.
  
  =head2 Topic unnecessary for certain Perl built-in functions
  
  Many Perl built-in functions will operate on C<$_> if no argument
  is passed.  For example, the C<length> function will operate on
  C<$_> by default.  This snippet:
  
      for ( @list ) {
          if ( length( $_ ) == 4 ) { ...
  
  is more idiomatically written as:
  
      for ( @list ) {
          if ( length == 4 ) { ...
  
  In the case of the C<split> function, the second argument is the
  one that defaults to C<$_>.  This snippet:
  
      for ( @list ) {
          my @args = split /\t/, $_;
  
  is better written as:
  
      for ( @list ) {
          my @args = split /\t/;
  
  There is one built-in that this policy does B<not> check for:
  C<reverse> called with C<$_>.
  
  The C<reverse> function only operates on C<$_> if called in scalar
  context.  Therefore:
  
      for ( @list ) {
          my $backwards = reverse $_;
  
  is better written as:
  
      for ( @list ) {
          my $backwards = reverse;
  
  However, the distinction for scalar vs. list context on C<reverse>
  is not yet working.  See L<KNOWN BUGS|KNOWN BUGS> below.
  
  =head2 Topic unnecessary for most filetest operators
  
  Another place that C<$_> is unnecessary is with a filetest operator.
  
      # These are identical.
      my $size = -s $_;
      my $size = -s;
  
      # These are identical.
      if ( -r $_ ) { ...
      if ( -r ) { ...
  
  The exception is after the C<-t> filetest operator, which instead of
  defaulting to C<$_> defaults to C<STDIN>.
  
      # These are NOT identical.
      if ( -t $_ ) { ...
      if ( -t ) { ...  # Checks STDIN, not $_
  
  =head1 KNOWN BUGS
  
  This policy flags a false positive on C<reverse> called in list
  context, since C<reverse> in list context does I<not> assume C<$_>.
  
      my $s = reverse( $_ ); # $_ is useless.
      my @a = reverse( $_ ); # $_ is not useless here.
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  =head1 AUTHOR
  
  Andy Lester <andy@petdance.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2013 Andy Lester <andy@petdance.com>
  
  This library is free software; you can redistribute it and/or modify it
  under the terms of the Artistic License 2.0.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITUSELESSTOPIC

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitVoidGrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDGREP';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidGrep;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification is_in_void_context };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"grep" used in void context};
  Readonly::Scalar my $EXPL => q{Use a "for" loop instead};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'grep';
      return if not is_function_call($elem);
      return if not is_in_void_context($elem);
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidGrep - Don't use C<grep> in void contexts.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  C<map> and C<grep> are intended to be pure functions, not mutators.
  If you want to iterate with side-effects, then you should use a proper
  C<for> or C<foreach> loop.
  
      grep{ print frobulate($_) } @list;           #not ok
      print map{ frobulate($_) } @list;            #ok
  
      grep{ $_ = lc $_ } @list;                    #not ok
      for( @list ){ $_ = lc $_  };                 #ok
  
      map{ push @frobbed, frobulate($_) } @list;   #not ok
      @frobbed = map { frobulate($_) } @list;      #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDGREP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/ProhibitVoidMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDMAP';
  package Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidMap;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification is_in_void_context };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"map" used in void context};
  Readonly::Scalar my $EXPL => q{Use a "for" loop instead};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'map';
      return if not is_function_call($elem);
      return if not is_in_void_context($elem);
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidMap - Don't use C<map> in void contexts.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  C<map> and C<grep> are intended to be pure functions, not mutators.
  If you want to iterate with side-effects, then you should use a proper
  C<for> or C<foreach> loop.
  
      grep{ print frobulate($_) } @list;           #not ok
      print map{ frobulate($_) } @list;            #ok
  
      grep{ $_ = lc $_ } @list;                    #not ok
      for( @list ){ $_ = lc $_  };                 #ok
  
      map{ push @frobbed, frobulate($_) } @list;   #not ok
      @frobbed = map { frobulate($_) } @list;      #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_PROHIBITVOIDMAP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireBlockGrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKGREP';
  package Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep;
  
  # DEVELOPER NOTE: this module is used as an example in DEVELOPER.pod.
  # If you make changes in here, please reflect those changes in the
  # examples.
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Expression form of "grep"};
  Readonly::Scalar my $EXPL => [ 169 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core bugs pbp ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'grep';
      return if ! is_function_call($elem);
  
      my $arg = first_arg($elem);
      return if !$arg;
      return if $arg->isa('PPI::Structure::Block');
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep - Write C<grep { /$pattern/ } @list> instead of C<grep /$pattern/, @list>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  =head1 DESCRIPTION
  
  The expression forms of C<grep> and C<map> are awkward and hard to
  read.  Use the block forms instead.
  
      @matches = grep  /pattern/,    @list;        #not ok
      @matches = grep { /pattern/ }  @list;        #ok
  
      @mapped = map  transform($_),    @list;      #not ok
      @mapped = map { transform($_) }  @list;      #ok
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval|Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval>
  
  L<Perl::Critic::Policy::BuiltinFunctions::RequireBlockMap|Perl::Critic::Policy::BuiltinFunctions::RequireBlockMap>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2013 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKGREP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireBlockMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKMAP';
  package Perl::Critic::Policy::BuiltinFunctions::RequireBlockMap;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Expression form of "map"};
  Readonly::Scalar my $EXPL => [ 169 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core bugs pbp ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem ne 'map';
      return if ! is_function_call($elem);
  
      my $arg = first_arg($elem);
      return if !$arg;
      return if $arg->isa('PPI::Structure::Block');
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::RequireBlockMap - Write C<map { /$pattern/ } @list> instead of C<map /$pattern/, @list>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  =head1 DESCRIPTION
  
  The expression forms of C<grep> and C<map> are awkward and hard to
  read.  Use the block forms instead.
  
      @matches = grep   /pattern/,   @list;        #not ok
      @matches = grep { /pattern/ }  @list;        #ok
  
      @mapped = map   transform($_),   @list;      #not ok
      @mapped = map { transform($_) }  @list;      #ok
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval|Perl::Critic::Policy::BuiltinFunctions::ProhibitStringyEval>
  
  L<Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep|Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2013 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREBLOCKMAP

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireGlobFunction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREGLOBFUNCTION';
  package Perl::Critic::Policy::BuiltinFunctions::RequireGlobFunction;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $GLOB_RX => qr< [*?] >xms;
  Readonly::Scalar my $DESC    => q{Glob written as <...>};
  Readonly::Scalar my $EXPL    => [ 167 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                                }
  sub default_severity     { return $SEVERITY_HIGHEST                 }
  sub default_themes       { return qw( core pbp bugs )               }
  sub applies_to           { return 'PPI::Token::QuoteLike::Readline' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem =~ $GLOB_RX ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::RequireGlobFunction - Use C<glob q{*}> instead of <*>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages the use of the C<< <..> >> construct for globbing, as
  it is easily confused with the angle bracket file input operator.
  Instead, he recommends the use of the C<glob()> function as it makes
  it much more obvious what you're attempting to do.
  
      @files = <*.pl>;              # not ok
      @files = glob '*.pl';         # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Graham TerMarsch <graham@howlingfrog.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Graham TerMarsch.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIREGLOBFUNCTION

$fatpacked{"Perl/Critic/Policy/BuiltinFunctions/RequireSimpleSortBlock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIRESIMPLESORTBLOCK';
  package Perl::Critic::Policy::BuiltinFunctions::RequireSimpleSortBlock;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Sort blocks should have a single statement};
  Readonly::Scalar my $EXPL => [ 149 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                                   }
  sub default_severity     { return $SEVERITY_MEDIUM                     }
  sub default_themes       { return qw( core pbp maintenance complexity) }
  sub applies_to           { return 'PPI::Token::Word'                   }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'sort';
      return if ! is_function_call($elem);
  
      my $sib = $elem->snext_sibling();
      return if !$sib;
  
      my $arg = $sib;
      if ( $arg->isa('PPI::Structure::List') ) {
          $arg = $arg->schild(0);
          # Forward looking: PPI might change in v1.200 so schild(0) is a PPI::Statement::Expression
          if ( $arg && $arg->isa('PPI::Statement::Expression') ) {
              $arg = $arg->schild(0);
          }
      }
      return if !$arg || !$arg->isa('PPI::Structure::Block');
  
      # If we get here, we found a sort with a block as the first arg
      return if ( 1 >= $arg->schildren() );
  
      # more than one child statements
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::BuiltinFunctions::RequireSimpleSortBlock - Sort blocks should have a single statement.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway advises that sort functions should be simple.  Any complicated
  operations on list elements should be computed and cached (perhaps via
  a Schwartzian Transform) before the sort, rather than computed inside
  the sort block, because the sort block is called C<N log N> times
  instead of just C<N> times.
  
  This policy prohibits the most blatant case of complicated sort
  blocks: multiple statements.  Future policies may wish to examine the
  sort block in more detail -- looking for subroutine calls or large
  numbers of operations.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_BUILTINFUNCTIONS_REQUIRESIMPLESORTBLOCK

$fatpacked{"Perl/Critic/Policy/ClassHierarchies/ProhibitAutoloading.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITAUTOLOADING';
  package Perl::Critic::Policy::ClassHierarchies::ProhibitAutoloading;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{AUTOLOAD method declared};
  Readonly::Scalar my $EXPL => [ 393 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance pbp ) }
  sub applies_to           { return 'PPI::Statement::Sub'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      if( $elem->name eq 'AUTOLOAD' ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return; #ok!
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ClassHierarchies::ProhibitAutoloading - AUTOLOAD methods should be avoided.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Declaring a subroutine with the name C<"AUTOLOAD"> will violate this
  Policy.  The C<AUTOLOAD> mechanism is an easy way to generate methods
  for your classes, but unless they are carefully written, those classes
  are difficult to inherit from.  And over time, the C<AUTOLOAD> method
  will become more and more complex as it becomes responsible for
  dispatching more and more functions.  You're better off writing
  explicit accessor methods.  Editor macros can help make this a little
  easier.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITAUTOLOADING

$fatpacked{"Perl/Critic/Policy/ClassHierarchies/ProhibitExplicitISA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITEXPLICITISA';
  package Perl::Critic::Policy::ClassHierarchies::ProhibitExplicitISA;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{@ISA used instead of "use base"}; ## no critic (RequireInterpolation)
  Readonly::Scalar my $EXPL => [ 360 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance pbp certrec ) }
  sub applies_to           { return 'PPI::Token::Symbol'       }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      if( $elem eq q{@ISA} ) {  ## no critic (RequireInterpolation)
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return; #ok!
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ClassHierarchies::ProhibitExplicitISA - Employ C<use base> instead of C<@ISA>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway recommends employing C<use base qw(Foo)> instead of the usual
  C<our @ISA = qw(Foo)> because the former happens at compile time and
  the latter at runtime.  The L<base|base> pragma also automatically loads
  C<Foo> for you so you save a line of easily-forgotten code.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTE
  
  Some people prefer L<parent|parent> over L<base|base>.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITEXPLICITISA

$fatpacked{"Perl/Critic/Policy/ClassHierarchies/ProhibitOneArgBless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITONEARGBLESS';
  package Perl::Critic::Policy::ClassHierarchies::ProhibitOneArgBless;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{One-argument "bless" used};
  Readonly::Scalar my $EXPL => [ 365 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGHEST   }
  sub default_themes       { return qw( core pbp bugs ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      return if $elem->content() ne 'bless';
      return if ! is_function_call($elem);
  
      if( scalar parse_arg_list($elem) == 1 ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return; #ok!
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ClassHierarchies::ProhibitOneArgBless - Write C<bless {}, $class;> instead of just C<bless {};>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Always use the two-argument form of C<bless> because it allows
  subclasses to inherit your constructor.
  
      sub new {
          my $class = shift;
          my $self = bless {};          # not ok
          my $self = bless {}, $class;  # ok
          return $self;
      }
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CLASSHIERARCHIES_PROHIBITONEARGBLESS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitHardTabs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITHARDTABS';
  package Perl::Critic::Policy::CodeLayout::ProhibitHardTabs;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Hard tabs used};
  Readonly::Scalar my $EXPL => [ 20 ];
  
  #-----------------------------------------------------------------------------
  
  # The following regex should probably be "qr{^ .* [^\t]+ \t}xms" but it doesn't
  # match when I expect it to.  I haven't figured out why, so I used "\S" to
  # approximately mean "not a tab", and that seemed to work.
  
  Readonly::Scalar my $NON_LEADING_TAB_REGEX => qr{^ .* \S+ \t }xms;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'allow_leading_tabs',
              description    => 'Allow hard tabs before first non-whitespace character.',
              default_string => '1',
              behavior       => 'boolean',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM    }
  sub default_themes   { return qw( core cosmetic pbp )   }
  sub applies_to       { return 'PPI::Token'        }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      $elem =~ m{ \t }xms || return;
  
      # The __DATA__ element is exempt
      return if $elem->parent->isa('PPI::Statement::Data');
  
      # If allowed, permit leading tabs in situations where whitespace s not significant.
      if ( $self->_allow_leading_tabs() ) {
  
          return if $elem->location->[1] == 1;
  
          return if _is_extended_regex($elem)
              && $elem !~ $NON_LEADING_TAB_REGEX;
  
          return if $elem->isa('PPI::Token::QuoteLike::Words')
              && $elem !~ $NON_LEADING_TAB_REGEX;
      }
  
      # If we get here, then it must be a violation...
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _allow_leading_tabs {
      my ( $self ) = @_;
      return $self->{_allow_leading_tabs};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_extended_regex {
      my ($elem) = @_;
  
      $elem->isa('PPI::Token::Regexp')
          || $elem->isa('PPI::Token::QuoteLike::Regexp')
              || return;
  
     # Look for the /x modifier near the end
     return $elem =~ m{\b [gimso]* x [gimso]* $}xms;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::ProhibitHardTabs - Use spaces instead of tabs.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Putting hard tabs in your source code (or POD) is one of the worst
  things you can do to your co-workers and colleagues, especially if
  those tabs are anywhere other than a leading position.  Because
  various applications and devices represent tabs differently, they can
  cause you code to look vastly different to other people.  Any decent
  editor can be configured to expand tabs into spaces.
  L<Perl::Tidy|Perl::Tidy> also does this for you.
  
  This Policy catches all tabs in your source code, including POD,
  quotes, and HEREDOCs.  The contents of the C<__DATA__> section are not
  examined.
  
  
  =head1 CONFIGURATION
  
  Hard tabs in a string are always forbidden (use "\t" instead).  But
  hard tabs in a leading position are allowed when they are used to indent
  code statements, C<qw()> word lists, and regular expressions with the C</x>
  modifier.  However, if you want to forbid all tabs everywhere, then add
  this to your F<.perlcriticrc> file:
  
      [CodeLayout::ProhibitHardTabs]
      allow_leading_tabs = 0
  
  
  =head1 NOTES
  
  Beware that Perl::Critic may report the location of the string that
  contains the tab, not the actual location of the tab, so you may need
  to do some hunting.  I'll try and fix this in the future.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITHARDTABS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitParensWithBuiltins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITPARENSWITHBUILTINS';
  package Perl::Critic::Policy::CodeLayout::ProhibitParensWithBuiltins;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw{any};
  
  use Perl::Critic::Utils qw{
      :booleans :severities :data_conversion :classification :language
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array my @ALLOW => qw( my our local return state );
  Readonly::Hash my %ALLOW => hashify( @ALLOW );
  
  Readonly::Scalar my $DESC  => q{Builtin function called with parentheses};
  Readonly::Scalar my $EXPL  => [ 13 ];
  
  Readonly::Scalar my $PRECENDENCE_OF_LIST => precedence_of(q{>>}) + 1;
  Readonly::Scalar my $PRECEDENCE_OF_COMMA => precedence_of(q{,});
  
  #-----------------------------------------------------------------------------
  # These are all the functions that are considered named unary
  # operators.  These frequently require parentheses because they have lower
  # precedence than ordinary function calls.
  
  Readonly::Array my @NAMED_UNARY_OPS => qw(
      alarm           glob        rand
      caller          gmtime      readlink
      chdir           hex         ref
      chroot          int         require
      cos             lc          return
      defined         lcfirst     rmdir
      delete          length      scalar
      do              localtime   sin
      eval            lock        sleep
      exists          log         sqrt
      exit            lstat       srand
      getgrp          my          stat
      gethostbyname   oct         uc
      getnetbyname    ord         ucfirst
      getprotobyname  quotemeta   umask
                                  undef
  );
  Readonly::Hash my %NAMED_UNARY_OPS => hashify( @NAMED_UNARY_OPS );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                      }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp cosmetic ) }
  sub applies_to           { return 'PPI::Token::Word'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if exists $ALLOW{$elem};
      return if not is_perl_builtin($elem);
      return if not is_function_call($elem);
  
      my $sibling = $elem->snext_sibling();
      return if not $sibling;
      if ( $sibling->isa('PPI::Structure::List') ) {
          my $elem_after_parens = $sibling->snext_sibling();
  
          return if _is_named_unary_with_operator_inside_parens_exemption($elem, $sibling);
          return if _is_named_unary_with_operator_following_parens_exemption($elem, $elem_after_parens);
          return if _is_precedence_exemption($elem_after_parens);
          return if _is_equals_exemption($sibling);
          return if _is_sort_exemption($elem, $sibling);
  
          # If we get here, it must be a violation
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  #-----------------------------------------------------------------------------
  # EXCEPTION 1: If the function is a named unary and there is an
  # operator with higher precedence right after the parentheses.
  # Example: int( 1.5 ) + 0.5;
  
  sub _is_named_unary_with_operator_following_parens_exemption {
      my ($elem, $elem_after_parens) = @_;
  
      if ( _is_named_unary( $elem ) && $elem_after_parens ){
          # Smaller numbers mean higher precedence
          my $precedence = precedence_of( $elem_after_parens );
          return $TRUE if defined $precedence && $precedence < $PRECENDENCE_OF_LIST;
      }
  
      return $FALSE;
  }
  
  sub _is_named_unary {
      my ($elem) = @_;
  
      return exists $NAMED_UNARY_OPS{$elem->content};
  }
  
  #-----------------------------------------------------------------------------
  # EXCEPTION 2, If there is an operator immediately after the
  # parentheses, and that operator has precedence greater than
  # or equal to a comma.
  # Example: join($delim, @list) . "\n";
  
  sub _is_precedence_exemption {
      my ($elem_after_parens) = @_;
  
      if ( $elem_after_parens ){
          # Smaller numbers mean higher precedence
          my $precedence = precedence_of( $elem_after_parens );
          return $TRUE if defined $precedence && $precedence <= $PRECEDENCE_OF_COMMA;
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  # EXCEPTION 3: If the first operator within the parentheses is '='
  # Example: chomp( my $foo = <STDIN> );
  
  sub _is_equals_exemption {
      my ($sibling) = @_;
  
      if ( my $first_op = $sibling->find_first('PPI::Token::Operator') ){
          return $TRUE if $first_op eq q{=};
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  # EXCEPTION 4: sort with default comparator but a function for the list data
  # Example: sort(foo(@x))
  
  sub _is_sort_exemption {
      my ($elem, $sibling) = @_;
  
      if ( $elem eq 'sort' ) {
          my $first_arg = $sibling->schild(0);
          if ( $first_arg && $first_arg->isa('PPI::Statement::Expression') ) {
              $first_arg = $first_arg->schild(0);
          }
          if ( $first_arg && $first_arg->isa('PPI::Token::Word') ) {
              my $next_arg = $first_arg->snext_sibling;
              return $TRUE if $next_arg && $next_arg->isa('PPI::Structure::List');
          }
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  # EXCEPTION 5: If the function is a named unary and there is an operator
  # inside the parentheses.
  # Example: length($foo || $bar);
  
  sub _is_named_unary_with_operator_inside_parens_exemption {
      my ($elem, $parens) = @_;
      return _is_named_unary($elem) &&  _contains_operators($parens);
  }
  
  sub _contains_operators {
      my ($parens) = @_;
      return $TRUE if $parens->find_first('PPI::Token::Operator');
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  1;
  
  __END__
  
  
  =pod
  
  =for stopwords disambiguates builtins
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::ProhibitParensWithBuiltins - Write C<open $handle, $path> instead of C<open($handle, $path)>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway suggests that all built-in functions be called without
  parentheses around the argument list.  This reduces visual clutter and
  disambiguates built-in functions from user functions.  Exceptions are
  made for C<my>, C<local>, and C<our> which require parentheses when
  called with multiple arguments.
  
      open($handle, '>', $filename); #not ok
      open $handle, '>', $filename;  #ok
  
      split(/$pattern/, @list); #not ok
      split /$pattern/, @list;  #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  Coding with parentheses can sometimes lead to verbose and awkward
  constructs, so I think the intent of Conway's guideline is to remove
  only the F<unnecessary> parentheses.  This policy makes exceptions for
  some common situations where parentheses are usually required.
  However, you may find other situations where the parentheses are
  necessary to enforce precedence, but they cause still violations.  In
  those cases, consider using the '## no critic' comments to silence
  Perl::Critic.
  
  
  =head1 BUGS
  
  Some builtin functions (particularly those that take a variable number
  of scalar arguments) should probably get parentheses.  This policy
  should be enhanced to allow the user to specify a list of builtins
  that are exempt from the policy.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITPARENSWITHBUILTINS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitQuotedWordLists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITQUOTEDWORDLISTS';
  package Perl::Critic::Policy::CodeLayout::ProhibitQuotedWordLists;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities :classification};
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{List of quoted literal words};
  Readonly::Scalar my $EXPL => q{Use 'qw()' instead};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'min_elements',
              description     => 'The minimum number of words in a list that will be complained about.',
              default_string  => '2',
              behavior        => 'integer',
              integer_minimum => 1,
          },
          {
              name            => 'strict',
              description     => 'Complain even if there are non-word characters in the values.',
              default_string  => '0',
              behavior        => 'boolean',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOW          }
  sub default_themes   { return qw( core cosmetic )    }
  sub applies_to       { return 'PPI::Structure::List' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # Don't worry about subroutine calls
      my $sibling = $elem->sprevious_sibling();
      return if not $sibling;
  
      return if $sibling->isa('PPI::Token::Symbol');
      return if $sibling->isa('PPI::Token::Operator') and $sibling eq '->';
      return if $sibling->isa('PPI::Token::Word') and not is_included_module_name($sibling);
  
      # Get the list elements
      my $expr = $elem->schild(0);
      return if not $expr;
      my @children = $expr->schildren();
      return if not @children;
  
      my $count = 0;
      for my $child ( @children ) {
          next if $child->isa('PPI::Token::Operator')  && $child eq $COMMA;
  
          # All elements must be literal strings,
          # and must contain 1 or more word characters.
  
          return if not _is_literal($child);
  
          my $string = $child->string();
          return if $string =~ m{ \s }xms;
          return if $string eq $EMPTY;
          return if not $self->{_strict} and $string !~ m{\A [\w-]+ \z}xms;
          $count++;
      }
  
      # Were there enough?
      return if $count < $self->{_min_elements};
  
      # If we get here, then all elements were literals
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  sub _is_literal {
      my $elem = shift;
      return $elem->isa('PPI::Token::Quote::Single')
          || $elem->isa('PPI::Token::Quote::Literal');
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::ProhibitQuotedWordLists - Write C<qw(foo bar baz)> instead of C<('foo', 'bar', 'baz')>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway doesn't mention this, but I think C<qw()> is an underused
  feature of Perl.  Whenever you need to declare a list of one-word
  literals, the C<qw()> operator is wonderfully concise, and makes it
  easy to add to the list in the future.
  
      @list = ('foo', 'bar', 'baz');  #not ok
      @list = qw(foo bar baz);        #ok
  
      use Foo ('foo', 'bar', 'baz');  #not ok
      use Foo qw(foo bar baz);        #ok
  
  =head1 CONFIGURATION
  
  This policy can be configured to only pay attention to word lists with
  at least a particular number of elements.  By default, this value is
  2, which means that lists containing zero or one elements are ignored.
  The minimum list size to be looked at can be specified by giving a
  value for C<min_elements> in F<.perlcriticrc> like this:
  
      [CodeLayout::ProhibitQuotedWordLists]
      min_elements = 4
  
  This would cause this policy to only complain about lists containing
  four or more words.
  
  By default, this policy won't complain if any of the values in the list
  contain non-word characters.  If you want it to, set the C<strict>
  option to a true value.
  
      [CodeLayout::ProhibitQuotedWordLists]
      strict = 1
  
  
  =head1 NOTES
  
  In the PPI parlance, a "list" is almost anything with parentheses.
  I've tried to make this Policy smart by targeting only "lists" that
  could be sensibly expressed with C<qw()>.  However, there may be some
  edge cases that I haven't covered.  If you find one, send me a note.
  
  
  =head1 IMPORTANT CHANGES
  
  This policy was formerly called C<RequireQuotedWords> which seemed a
  little counter-intuitive.  If you get lots of "Cannot load policy
  module" errors, then you probably need to change C<RequireQuotedWords>
  to C<ProhibitQuotedWordLists> in your F<.perlcriticrc> file.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITQUOTEDWORDLISTS

$fatpacked{"Perl/Critic/Policy/CodeLayout/ProhibitTrailingWhitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITTRAILINGWHITESPACE';
  package Perl::Critic::Policy::CodeLayout::ProhibitTrailingWhitespace;
  
  use 5.006001;
  use strict;
  use warnings;
  use English qw(-no_match_vars);
  use Readonly;
  
  use charnames qw{};
  
  use PPI::Token::Whitespace;
  use Perl::Critic::Utils qw{ :characters :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Don't use whitespace at the end of lines};
  
  ## no critic (RequireInterpolationOfMetachars)
  Readonly::Hash my %C_STYLE_ESCAPES =>
      (
          ord "\t" => q{\t},
          ord "\n" => q{\n},
          ord "\r" => q{\r},
          ord "\f" => q{\f},
          ord "\b" => q{\b},
          ord "\a" => q{\a},
          ord "\e" => q{\e},
      );
  ## use critic
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw{ }                    }
  sub default_severity     { return $SEVERITY_LOWEST         }
  sub default_themes       { return qw( core maintenance )   }
  sub applies_to           { return 'PPI::Token::Whitespace' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $token, undef ) = @_;
  
      if ( $token->content() =~ m< ( (?! \n) \s )+ \n >xms ) {
          my $extra_whitespace = $1;
  
          my $description = q{Found "};
          $description .=
              join
                  $EMPTY,
                  map { _escape($_) } split $EMPTY, $extra_whitespace;
          $description .= q{" at the end of the line};
  
          return $self->violation( $description, $EXPL, $token );
      }
  
      return;
  }
  
  sub _escape {
      my $character = shift;
      my $ordinal = ord $character;
  
      if (my $c_escape = $C_STYLE_ESCAPES{$ordinal}) {
          return $c_escape;
      }
  
  
      # Apparently, the charnames.pm that ships with older perls does not
      # support the C<viacode> function, and newer versions of the module are
      # not distributed separately from perl itself So if the C<viacode> method
      # is not supported, then just substitute something.
  
  
      ## no critic (RequireInterpolationOfMetachars)
      if ( charnames->can( 'viacode' ) ) {
          return q/\N{/ . charnames::viacode($ordinal) . q/}/;
      }
      else {
          return '\N{WHITESPACE CHAR}';
      }
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::ProhibitTrailingWhitespace - Don't use whitespace at the end of lines.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Anything that is not readily visually detectable is a bad thing in
  general, and more specifically, as different people edit the same
  code, their editors may automatically strip out trailing whitespace,
  causing spurious differences between different versions of the same
  file (i.e. code in a source control system).
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_PROHIBITTRAILINGWHITESPACE

$fatpacked{"Perl/Critic/Policy/CodeLayout/RequireConsistentNewlines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_REQUIRECONSISTENTNEWLINES';
  package Perl::Critic::Policy::CodeLayout::RequireConsistentNewlines;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use PPI::Token::Whitespace;
  use English qw(-no_match_vars);
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  Readonly::Scalar my $LINE_END => qr/\015{1,2}\012|[\012\015]/mxs;
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use the same newline through the source};
  Readonly::Scalar my $EXPL => q{Change your newlines to be the same throughout};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()              }
  sub default_severity     { return $SEVERITY_HIGH  }
  sub default_themes       { return qw( core bugs ) }
  sub applies_to           { return 'PPI::Document' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, undef, $doc ) = @_;
  
      my $filename = $doc->filename();
      return if !$filename;
  
      my $fh;
      return if !open $fh, '<', $filename;
      local $RS = undef;
      my $source = <$fh>;
      close $fh or return;
  
      my $newline; # undef until we find the first one
      my $line = 1;
      my @v;
      while ( $source =~ m/\G([^\012\015]*)($LINE_END)/cgmxs ) {
          my $code = $1;
          my $nl = $2;
          my $col = length $code;
          $newline ||= $nl;
          if ( $nl ne $newline ) {
              my $token = PPI::Token::Whitespace->new( $nl );
              # TODO this is a terrible violation of encapsulation, but absent a
              # mechanism to override the line numbers in the violation, I do
              # not know what to do about it.
              $token->{_location} = [$line, $col, $col, $line, $filename];
              push @v, $self->violation( $DESC, $EXPL, $token );
          }
          $line++;
      }
      return @v;
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords GnuPG
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::RequireConsistentNewlines - Use the same newline through the source.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Source code files are divided into lines with line endings of C<\r>,
  C<\n> or C<\r\n>.  Mixing these different line endings causes problems
  in many text editors and, notably, Module::Signature and GnuPG.
  
  
  =head1 CAVEAT
  
  This policy works outside of PPI because PPI automatically normalizes
  source code to local newline conventions.  So, this will only work if
  we know the filename of the source code.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_REQUIRECONSISTENTNEWLINES

$fatpacked{"Perl/Critic/Policy/CodeLayout/RequireTidyCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETIDYCODE';
  package Perl::Critic::Policy::CodeLayout::RequireTidyCode;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use IO::String qw< >;
  use Readonly;
  
  use Perl::Tidy qw< >;
  
  use Perl::Critic::Utils qw{ :booleans :characters :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Code is not tidy};
  Readonly::Scalar my $EXPL => [ 33 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'perltidyrc',
              description     => 'The Perl::Tidy configuration file to use, if any.',
              default_string  => undef,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOWEST      }
  sub default_themes   { return qw(core pbp cosmetic) }
  sub applies_to       { return 'PPI::Document'       }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      # Set configuration if defined
      if (defined $self->{_perltidyrc} && $self->{_perltidyrc} eq $EMPTY) {
          my $rc = $EMPTY;
          $self->{_perltidyrc} = \$rc;
      }
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # Perl::Tidy seems to produce slightly different output, depending
      # on the trailing whitespace in the input.  As best I can tell,
      # Perl::Tidy will truncate any extra trailing newlines, and if the
      # input has no trailing newline, then it adds one.  But when you
      # re-run it through Perl::Tidy here, that final newline gets lost,
      # which causes the policy to insist that the code is not tidy.
      # This only occurs when Perl::Tidy is writing the output to a
      # scalar, but does not occur when writing to a file.  I may
      # investigate further, but for now, this seems to do the trick.
  
      my $source = $doc->serialize();
      $source =~ s{ \s+ \Z}{\n}xms;
  
      # Remove the shell fix code from the top of program, if applicable
      ## no critic (ProhibitComplexRegexes)
      my $shebang_re = qr< [#]! [^\015\012]+ [\015\012]+ >xms;
      my $shell_re   = qr<eval [ ] 'exec [ ] [^\015\012]* [ ] \$0 [ ] \$[{]1[+]"\$@"}'
                          [ \t]*[\012\015]+ [ \t]* if [^\015\012]+ [\015\012]+ >xms;
      $source =~ s/\A ($shebang_re) $shell_re /$1/xms;
  
      my $dest    = $EMPTY;
      my $stderr  = $EMPTY;
  
  
      # Perl::Tidy gets confused if @ARGV has arguments from
      # another program.  Also, we need to override the
      # stdout and stderr redirects that the user may have
      # configured in their .perltidyrc file.
      # Also override -b because we are using dest and source.
      local @ARGV = qw(-nst -nse -nb);
  
      # Trap Perl::Tidy errors, just in case it dies
      my $eval_worked = eval {
  
          # Perl::Tidy 20120619 no longer accepts a scalar reference for stdio.
          my $handle = IO::String->new( $stderr );
  
          # Beginning with version 20120619, Perl::Tidy modifies $source. So we
          # make a copy so we can get a good comparison after tidying. Doing an
          # s/// on $source after the fact appears not to work with previous
          # versions of Perl::Tidy.
          my $source_copy = $source;
  
          # In version 20120619 (and possibly earlier), Perl::Tidy assigns the
          # stderr parameter directly to *STDERR.  So when our $stderr goes out
          # of scope, the handle gets closed.  Subsequent calls to warn() will
          # then cause a fatal exception.  See RT #78182 for more details.  In
          # the meantime, we workaround it by localizing STDERR first.
          local *STDERR = \*STDERR;
  
          Perl::Tidy::perltidy(
              source      => \$source_copy,
              destination => \$dest,
              stderr      => $handle,
              defined $self->{_perltidyrc} ? (perltidyrc => $self->{_perltidyrc}) : (),
         );
         1;
      };
  
      if ($stderr or not $eval_worked) {
          # Looks like perltidy had problems
          return $self->violation( 'perltidy had errors!!', $EXPL, $elem );
      }
  
      if ( $source ne $dest ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return;    #ok!
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords perltidy
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::RequireTidyCode - Must run code through L<perltidy|perltidy>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway does make specific recommendations for whitespace and
  curly-braces in your code, but the most important thing is to adopt a
  consistent layout, regardless of the specifics.  And the easiest way
  to do that is to use L<Perl::Tidy|Perl::Tidy>.  This policy will
  complain if you're code hasn't been run through Perl::Tidy.
  
  
  =head1 CONFIGURATION
  
  This policy can be configured to tell Perl::Tidy to use a particular
  F<perltidyrc> file or no configuration at all.  By default, Perl::Tidy
  is told to look in its default location for configuration.
  Perl::Critic can be told to tell Perl::Tidy to use a specific
  configuration file by putting an entry in a F<.perlcriticrc> file like
  this:
  
      [CodeLayout::RequireTidyCode]
      perltidyrc = /usr/share/perltidy.conf
  
  As a special case, setting C<perltidyrc> to the empty string tells
  Perl::Tidy not to load any configuration file at all and just use
  Perl::Tidy's own default style.
  
      [CodeLayout::RequireTidyCode]
      perltidyrc =
  
  
  =head1 SEE ALSO
  
  L<Perl::Tidy|Perl::Tidy>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETIDYCODE

$fatpacked{"Perl/Critic/Policy/CodeLayout/RequireTrailingCommas.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETRAILINGCOMMAS';
  package Perl::Critic::Policy::CodeLayout::RequireTrailingCommas;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{List declaration without trailing comma};
  Readonly::Scalar my $EXPL => [ 17 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_LOWEST       }
  sub default_themes       { return qw(core pbp cosmetic)  }
  sub applies_to           { return 'PPI::Structure::List' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      $elem =~ m{ \n }xms || return;
  
      # Is it an assignment of some kind?
      my $sib = $elem->sprevious_sibling();
      return if !$sib;
      $sib->isa('PPI::Token::Operator') && $sib =~ m{ = }xms || return;
  
      # List elements are children of an expression
      my $expr = $elem->schild(0);
      return if !$expr;
  
      # Does the list have more than 1 element?
      # This means list element, not PPI element.
      my @children = $expr->schildren();
      return if 1 >= grep {    $_->isa('PPI::Token::Operator')
                            && $_ eq $COMMA } @children;
  
      # Is the final element a comma?
      my $final = $children[-1];
      if ( ! ($final->isa('PPI::Token::Operator') && $final eq $COMMA) ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return; #ok!
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::CodeLayout::RequireTrailingCommas - Put a comma at the end of every multi-line list declaration, including the last one.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway suggests that all elements in a multi-line list should be
  separated by commas, including the last element.  This makes it a
  little easier to re-order the list by cutting and pasting.
  
      my @list = ($foo,
                  $bar,
                  $baz);  #not ok
  
      my @list = ($foo,
                  $bar,
                  $baz,); #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  In the PPI parlance, a "list" is almost anything with parentheses.
  I've tried to make this Policy smart by targeting only "lists" that
  have at least one element and are being assigned to something.
  However, there may be some edge cases that I haven't covered.  If you
  find one, send me a note.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CODELAYOUT_REQUIRETRAILINGCOMMAS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitCStyleForLoops.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCSTYLEFORLOOPS';
  package Perl::Critic::Policy::ControlStructures::ProhibitCStyleForLoops;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{C-style "for" loop used};
  Readonly::Scalar my $EXPL => [ 100 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_LOW              }
  sub default_themes       { return qw( core pbp maintenance ) }
  sub applies_to           { return 'PPI::Structure::For'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( _is_cstyle($elem) ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  sub _is_cstyle {
      my $elem      = shift;
      my $nodes_ref = $elem->find('PPI::Token::Structure');
      return if !$nodes_ref;
      my @semis     = grep { $_ eq $SCOLON } @{$nodes_ref};
      return scalar @semis == 2;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitCStyleForLoops - Write C<for(0..20)> instead of C<for($i=0; $i<=20; $i++)>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The 3-part C<for> loop that Perl inherits from C is butt-ugly, and
  only really necessary if you need irregular counting.  The very
  Perlish C<..> operator is much more elegant and readable.
  
      for($i=0; $i<=$max; $i++){      #ick!
          do_something($i);
      }
  
      for(0..$max){                   #very nice
          do_something($_);
      }
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCSTYLEFORLOOPS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitCascadingIfElse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCASCADINGIFELSE';
  package Perl::Critic::Policy::ControlStructures::ProhibitCascadingIfElse;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Cascading if-elsif chain};
  Readonly::Scalar my $EXPL => [ 117, 118 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_elsif',
              description     => 'The maximum number of alternatives that will be allowed.',
              default_string  => '2',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM                      }
  sub default_themes   { return qw( core pbp maintenance complexity ) }
  sub applies_to       { return 'PPI::Statement::Compound'            }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if ($elem->type() ne 'if');
  
      if ( _count_elsifs($elem) > $self->{_max_elsif} ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  sub _count_elsifs {
      my $elem = shift;
      return
        grep { $_->isa('PPI::Token::Word') && $_->content() eq 'elsif' } $elem->schildren();
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords lookup
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitCascadingIfElse - Don't write long "if-elsif-elsif-elsif-elsif...else" chains.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Long C<if-elsif> chains are hard to digest, especially if they are
  longer than a single page or screen.  If testing for equality, use a
  hash lookup instead.  If you're using perl 5.10 or later, use
  C<given>/C<when>.
  
      if ($condition1) {         #ok
          $foo = 1;
      }
      elsif ($condition2) {      #ok
          $foo = 2;
      }
      elsif ($condition3) {      #ok
          $foo = 3;
      }
      elsif ($condition4) {      #too many!
          $foo = 4;
      }
      else {                     #ok
          $foo = $default;
      }
  
  =head1 CONFIGURATION
  
  This policy can be configured with a maximum number of C<elsif>
  alternatives to allow.  The default is 2.  This can be specified via a
  C<max_elsif> item in the F<.perlcriticrc> file:
  
      [ControlStructures::ProhibitCascadingIfElse]
      max_elsif = 3
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITCASCADINGIFELSE

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitDeepNests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITDEEPNESTS';
  package Perl::Critic::Policy::ControlStructures::ProhibitDeepNests;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Code structure is deeply nested};
  Readonly::Scalar my $EXPL => q{Consider refactoring};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_nests',
              description     => 'The maximum number of nested constructs to allow.',
              default_string  => '5',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM                }
  sub default_themes   { return qw(core maintenance complexity) }
  sub applies_to       { return 'PPI::Statement::Compound'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $nest_count = 1;  #For _this_ element
      my $parent = $elem;
  
      while ( $parent = $parent->parent() ){
          if( $parent->isa('PPI::Statement::Compound') ) {
              $nest_count++;
          }
      }
  
      if ( $nest_count > $self->{_max_nests} ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  
  1;
  
  __END__
  
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords refactored
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitDeepNests - Don't write deeply nested loops and conditionals.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Deeply nested code is often hard to understand and may be a sign that
  it needs to be refactored.  There are several good books on how to
  refactor code.  I like Martin Fowler's "Refactoring: Improving The
  Design of Existing Code".
  
  
  =head1 CONFIGURATION
  
  The maximum number of nested control structures can be configured via
  a value for C<max_nests> in a F<.perlcriticrc> file.  Each for-loop,
  if-else, while, and until block is counted as one nest.  Postfix forms
  of these constructs are not counted.  The default maximum is 5.
  Customization in a F<.perlcriticrc> file looks like this:
  
      [ControlStructures::ProhibitDeepNests]
      max_nests = 3
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITDEEPNESTS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitLabelsWithSpecialBlockNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITLABELSWITHSPECIALBLOCKNAMES';
  package Perl::Critic::Policy::ControlStructures::ProhibitLabelsWithSpecialBlockNames;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities hashify };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  Readonly::Hash my %SPECIAL_BLOCK_NAMES =>
      hashify( qw< BEGIN END INIT CHECK UNITCHECK > );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Special block name used as label.>;
  Readonly::Scalar my $EXPL =>
      q<Use a label that cannot be confused with BEGIN, END, CHECK, INIT, or UNITCHECK blocks.>;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                      }
  sub default_severity     { return $SEVERITY_HIGH          }
  sub default_themes       { return qw< core bugs >         }
  sub applies_to           { return qw< PPI::Token::Label > }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      # Does the function call have enough arguments?
      my $label = $elem->content();
      $label =~ s/ \s* : \z //xms;
      return if not $SPECIAL_BLOCK_NAMES{ $label };
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =for stopwords Lauen O'Regan
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitLabelsWithSpecialBlockNames - Don't use labels that are the same as the special block names.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  When using one of the special Perl blocks C<BEGIN>, C<END>, C<CHECK>,
  C<INIT>, and C<UNITCHECK>, it is easy to mistakenly add a colon to the
  end of the block name.  E.g.:
  
      # a BEGIN block that gets executed at compile time.
      BEGIN { <...code...> }
  
      # an ordinary labeled block that gets executed at run time.
      BEGIN: { <...code...> }
  
  The labels "BEGIN:", "END:", etc. are probably errors.  This policy
  prohibits the special Perl block names from being used as labels.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  The Perl Buzz article on this issue at
  L<http://perlbuzz.com/2008/05/colons-invalidate-your-begin-and-end-blocks.html>.
  
  
  =head1 ACKNOWLEDGMENT
  
  Randy Lauen for identifying the problem.
  
  
  =head1 AUTHOR
  
  Mike O'Regan
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Mike O'Regan.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITLABELSWITHSPECIALBLOCKNAMES

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitMutatingListFunctions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITMUTATINGLISTFUNCTIONS';
  package Perl::Critic::Policy::ControlStructures::ProhibitMutatingListFunctions;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw( none any );
  
  use Perl::Critic::Utils qw{
      :booleans :characters :severities :data_conversion :classification :ppi
  };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array my @BUILTIN_LIST_FUNCS => qw( map grep );
  Readonly::Array my @CPAN_LIST_FUNCS    => _get_cpan_list_funcs();
  
  #-----------------------------------------------------------------------------
  
  sub _get_cpan_list_funcs {
      return  qw( List::Util::first ),
          map { 'List::MoreUtils::'.$_ } _get_list_moreutils_funcs();
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_list_moreutils_funcs {
      return  qw(any all none notall true false firstidx first_index
                 lastidx last_index insert_after insert_after_string);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_topic {
      my $elem = shift;
      return defined $elem
          && $elem->isa('PPI::Token::Magic')
              && $elem->content() eq q{$_}; ##no critic (InterpolationOfMetachars)
  }
  
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Don't modify $_ in list functions};  ##no critic (InterpolationOfMetachars)
  Readonly::Scalar my $EXPL => [ 114 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'list_funcs',
              description     => 'The base set of functions to check.',
              default_string  => join ($SPACE, @BUILTIN_LIST_FUNCS, @CPAN_LIST_FUNCS ),
              behavior        => 'string list',
          },
          {
              name            => 'add_list_funcs',
              description     => 'The set of functions to check, in addition to those given in list_funcs.',
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_HIGHEST  }
  sub default_themes   { return qw(core bugs pbp certrule )  }
  sub applies_to       { return 'PPI::Token::Word' }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      $self->{_all_list_funcs} = {
          hashify keys %{ $self->{_list_funcs} }, keys %{ $self->{_add_list_funcs} }
      };
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
  
      # Is this element a list function?
      return if not $self->{_all_list_funcs}->{$elem};
      return if not is_function_call($elem);
  
      # Only the block form of list functions can be analyzed.
      return if not my $first_arg = first_arg( $elem );
      return if not $first_arg->isa('PPI::Structure::Block');
      return if not $self->_has_topic_side_effect( $first_arg, $doc );
  
      # Must be a violation
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _has_topic_side_effect {
      my ( $self, $node, $doc ) = @_;
  
      # Search through all significant elements in the block,
      # testing each element to see if it mutates the topic.
      my $tokens = $node->find( 'PPI::Token' ) || [];
      for my $elem ( @{ $tokens } ) {
          next if not $elem->significant();
          return 1 if _is_assignment_to_topic( $elem );
          return 1 if $self->_is_topic_mutating_regex( $elem, $doc );
          return 1 if _is_topic_mutating_func( $elem );
          return 1 if _is_topic_mutating_substr( $elem );
      }
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_assignment_to_topic {
      my $elem = shift;
      return if not _is_topic( $elem );
  
      my $sib = $elem->snext_sibling();
      if ($sib && $sib->isa('PPI::Token::Operator')) {
          return 1 if _is_assignment_operator( $sib );
      }
  
      my $psib = $elem->sprevious_sibling();
      if ($psib && $psib->isa('PPI::Token::Operator')) {
          return 1 if _is_increment_operator( $psib );
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_topic_mutating_regex {
      my ( $self, $elem, $doc ) = @_;
      return if ! ( $elem->isa('PPI::Token::Regexp::Substitute')
                    || $elem->isa('PPI::Token::Regexp::Transliterate') );
  
      # Exempt PPI::Token::Regexp::Transliterate objects IF the replacement
      # string is empty AND neither the /d or /s flags are specified, OR the
      # replacement string equals the match string AND neither the /c or /s
      # flags are specified. RT 44515.
      #
      # NOTE that, at least as of 5.14.2, tr/// does _not_ participate in the
      # 'use re /modifiers' mechanism. And a good thing, too, since the
      # modifiers that _are_ common (/s and /d) mean something completely
      # different in tr///.
      if ( $elem->isa( 'PPI::Token::Regexp::Transliterate') ) {
          my $subs = $elem->get_substitute_string();
          my %mods = $elem->get_modifiers();
          $mods{r} and return;    # Introduced in Perl 5.13.7
          if ( $EMPTY eq $subs ) {
              $mods{d} or $mods{s} or return;
          } elsif ( $elem->get_match_string() eq $subs ) {
              $mods{c} or $mods{s} or return;
          }
      }
  
      # As of 5.13.2, the substitute built-in supports the /r modifier, which
      # causes the operation to return the modified string and leave the
      # original unmodified. This does not parse under earlier Perls, so there
      # is no version check.
  
      if ( $elem->isa( 'PPI::Token::Regexp::Substitute' ) ) {
          my $re = $doc->ppix_regexp_from_element( $elem )
              or return;
          $re->modifier_asserted( 'r' )
              and return;
      }
  
      # If the previous sibling does not exist, then
      # the regex implicitly binds to $_
      my $prevsib = $elem->sprevious_sibling;
      return 1 if not $prevsib;
  
      # If the previous sibling does exist, then it
      # should be a binding operator.
      return 1 if not _is_binding_operator( $prevsib );
  
      # Check if the sibling before the biding operator
      # is explicitly set to $_
      my $bound_to = $prevsib->sprevious_sibling;
      return _is_topic( $bound_to );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_topic_mutating_func {
      my $elem = shift;
      return if not $elem->isa('PPI::Token::Word');
      my @mutator_funcs = qw(chop chomp undef);
      return if not any { $elem->content() eq $_ } @mutator_funcs;
      return if not is_function_call( $elem );
  
      # If these functions have no argument,
      # they default to mutating $_
      my $first_arg = first_arg( $elem );
      if (not defined $first_arg) {
          # undef does not default to $_, unlike the others
          return if $elem->content() eq 'undef';
          return 1;
      }
      return _is_topic( $first_arg );
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $MUTATING_SUBSTR_ARG_COUNT => 4;
  
  sub _is_topic_mutating_substr {
      my $elem = shift;
      return if $elem->content() ne 'substr';
      return if not is_function_call( $elem );
  
      # check and see if the first arg is $_
      my @args = parse_arg_list( $elem );
      return @args >= $MUTATING_SUBSTR_ARG_COUNT && _is_topic( $args[0]->[0] );
  }
  
  #-----------------------------------------------------------------------------
  
  {
      ##no critic(ArgUnpacking)
  
      my %assignment_ops = hashify qw(
          = *= /= += -= %= **= x= .= &= |= ^=  &&= ||= <<= >>= //= ++ --
      );
      sub _is_assignment_operator { return exists $assignment_ops{$_[0]} }
  
      my %increment_ops = hashify qw( ++ -- );
      sub _is_increment_operator { return exists $increment_ops{$_[0]} }
  
      my %binding_ops = hashify qw( =~ !~ );
      sub _is_binding_operator { return exists $binding_ops{$_[0]} }
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitMutatingListFunctions - Don't modify C<$_> in list functions.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  C<map>, C<grep> and other list operators are intended to transform
  arrays into other arrays by applying code to the array elements one by
  one.  For speed, the elements are referenced via a C<$_> alias rather
  than copying them.  As a consequence, if the code block of the C<map>
  or C<grep> modify C<$_> in any way, then it is actually modifying the
  source array.  This IS technically allowed, but those side effects can
  be quite surprising, especially when the array being passed is C<@_>
  or perhaps C<values(%ENV)>!  Instead authors should restrict in-place
  array modification to C<for(@array) { ... }> constructs instead, or
  use C<List::MoreUtils::apply()>.
  
  =head1 CONFIGURATION
  
  By default, this policy applies to the following list functions:
  
      map grep
      List::Util qw(first)
      List::MoreUtils qw(any all none notall true false firstidx
                         first_index lastidx last_index insert_after
                         insert_after_string)
  
  This list can be overridden the F<.perlcriticrc> file like this:
  
      [ControlStructures::ProhibitMutatingListFunctions]
      list_funcs = map grep List::Util::first
  
  Or, one can just append to the list like so:
  
      [ControlStructures::ProhibitMutatingListFunctions]
      add_list_funcs = Foo::Bar::listmunge
  
  =head1 LIMITATIONS
  
  This policy deliberately does not apply to C<for (@array) { ... }> or
  C<List::MoreUtils::apply()>.
  
  Currently, the policy only detects explicit external module usage like
  this:
  
      my @out = List::MoreUtils::any {s/^foo//} @in;
  
  and not like this:
  
      use List::MoreUtils qw(any);
      my @out = any {s/^foo//} @in;
  
  This policy looks only for modifications of C<$_>.  Other naughtiness
  could include modifying C<$a> and C<$b> in C<sort> and the like.
  That's beyond the scope of this policy.
  
  
  =head1 SEE ALSO
  
  There is discussion of this policy at
  L<http://perlmonks.org/index.pl?node_id=743445>.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  Michael Wolf <MichaelRWolf@att.net>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
  
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITMUTATINGLISTFUNCTIONS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitNegativeExpressionsInUnlessAndUntilConditions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITNEGATIVEEXPRESSIONSINUNLESSANDUNTILCONDITIONS';
  package Perl::Critic::Policy::ControlStructures::ProhibitNegativeExpressionsInUnlessAndUntilConditions;
  
  use 5.006001;
  use strict;
  use warnings;
  use English qw(-no_match_vars);
  use Readonly;
  
  use Perl::Critic::Utils qw< :characters :severities :classification hashify >;
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => [99];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw< >                      }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance pbp ) }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $token, undef ) = @_;
  
      return if $token->content() ne 'until' && $token->content() ne 'unless';
  
      return if is_hash_key($token);
      return if is_subroutine_name($token);
      return if is_method_call($token);
      return if is_included_module_name($token);
  
      return
          map
              { $self->_violation_for_operator( $_, $token ) }
              _get_negative_operators( $token );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_negative_operators {
      my ($token) = @_;
  
      my @operators;
      foreach my $element ( _get_condition_elements($token) ) {
          if ( $element->isa('PPI::Node') ) {
              my $operators = $element->find( \&_is_negative_operator );
              if ($operators) {
                  push @operators, @{$operators};
              }
          }
          else {
              if ( _is_negative_operator( undef, $element ) ) {
                  push @operators, $element;
              }
          }
      }
  
      return @operators;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_condition_elements {
      my ($token) = @_;
  
      my $statement = $token->statement();
      return if not $statement;
  
      if ($statement->isa('PPI::Statement::Compound')) {
          my $condition = $token->snext_sibling();
  
          return if not $condition;
          return if not $condition->isa('PPI::Structure::Condition');
  
          return ( $condition );
      }
  
      my @condition_elements;
      my $element = $token;
      while (
              $element = $element->snext_sibling()
          and $element->content() ne $SCOLON
      ) {
          push @condition_elements, $element;
      }
  
      return @condition_elements;
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %NEGATIVE_OPERATORS => hashify(
      qw/
          ! not
          !~ ne !=
          <   >   <=  >=  <=>
          lt  gt  le  ge  cmp
      /
  );
  
  sub _is_negative_operator {
      my (undef, $element) = @_;
  
      return
              $element->isa('PPI::Token::Operator')
          &&  $NEGATIVE_OPERATORS{$element};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _violation_for_operator {
      my ($self, $operator, $control_structure) = @_;
  
      return
          $self->violation(
              qq<Found "$operator" in condition for an "$control_structure">,
              $EXPL,
              $control_structure,
          );
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitNegativeExpressionsInUnlessAndUntilConditions - Don't use operators like C<not>, C<!~>, and C<le> within C<until> and C<unless>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
      until ($foo ne 'blah') {          #not ok
          ...
      }
  
      while ($foo eq 'blah') {          #ok
          ...
      }
  
  A number of people have problems figuring out the meaning of doubly
  negated expressions.  C<unless> and C<until> are both negative
  constructs, so any negative (e.g. C<!~>) or reversible operators (e.g.
  C<le>) included in their conditional expressions are double negations.
  Conway considers the following operators to be difficult to understand
  within C<unless> and C<until>:
  
    ! not
    !~ ne !=
    <   >   <=  >=  <=>
    lt  gt  le  ge  cmp
  
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ControlStructures::ProhibitUnlessBlocks|Perl::Critic::Policy::ControlStructures::ProhibitUnlessBlocks>
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITNEGATIVEEXPRESSIONSINUNLESSANDUNTILCONDITIONS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitPostfixControls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITPOSTFIXCONTROLS';
  package Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities :data_conversion :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %PAGES_OF => (
      if      => [ 93, 94 ],
      unless  => [ 96, 97 ],
      until   => [ 96, 97 ],
      for     => [ 96     ],
      foreach => [ 96     ],
      while   => [ 96     ],
      when    => q<Similar to "if", postfix "when" should only be used with flow-control>,
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name               => 'allow',
              description        => 'The permitted postfix controls.',
              default_string     => $EMPTY,
              behavior           => 'enumeration',
              enumeration_values => [ sort keys %PAGES_OF ],
              enumeration_allow_multiple_values   => 1,
          },
          {
              name               => 'flowcontrol',
              description        => 'The exempt flow control functions.',
              default_string     => 'carp cluck confess croak die exit goto warn',
              behavior           => 'string list',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOW         }
  sub default_themes   { return qw(core pbp cosmetic) }
  sub applies_to       { return 'PPI::Token::Word'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $expl = $PAGES_OF{$elem};
      return if not $expl;
  
      return if is_hash_key($elem);
      return if is_method_call($elem);
      return if is_subroutine_name($elem);
      return if is_included_module_name($elem);
      return if is_package_declaration($elem);
  
      # Skip controls that are allowed
      return if exists $self->{_allow}->{ $elem->content() };
  
      # Skip Compound variety (these are good)
      my $stmnt = $elem->statement();
      return if not $stmnt;
      return if $stmnt->isa('PPI::Statement::Compound');
      return if $stmnt->isa('PPI::Statement::When');
  
      # Handle special cases
      my $content = $elem->content();
      if ($content eq 'if' or $content eq 'when') {
          # Postfix 'if' allowed with loop breaks, or other
          # flow-controls like 'die', 'warn', and 'croak'
          return if $stmnt->isa('PPI::Statement::Break');
          return if defined $self->{_flowcontrol}{ $stmnt->schild(0)->content() };
      }
  
      # If we get here, it must be postfix.
      my $desc = qq{Postfix control "$content" used};
      return $self->violation($desc, $expl, $elem);
  }
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords flowcontrol brian foy
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls - Write C<if($condition){ do_something() }> instead of C<do_something() if $condition>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages using postfix control structures (C<if>, C<for>,
  C<unless>, C<until>, C<when>, C<while>) because they hide control
  flow.  The C<unless> and C<until> controls are particularly evil
  because they lead to double-negatives that are hard to comprehend.
  The only tolerable usage of a postfix C<if>/C<when> is when it follows
  a loop break such as C<last>, C<next>, C<redo>, or C<continue>.
  
      do_something() if $condition;           # not ok
      if ($condition) { do_something() }      # ok
  
      do_something() while $condition;        # not ok
      while ($condition) { do_something() }   # ok
  
      do_something() unless $condition;       # not ok
      do_something() unless ! $condition;     # really bad
      if (! $condition) { do_something() }    # ok
  
      do_something() until $condition;        # not ok
      do_something() until ! $condition;      # really bad
      while (! $condition) { do_something() } # ok
  
      do_something($_) for @list;             # not ok
  
      LOOP:
      for my $n (0..100) {
          next if $condition;                 # ok
          last LOOP if $other_condition;      # also ok
  
          next when m< 0 \z >xms;             # fine too
      }
  
  
  =head1 CONFIGURATION
  
  A set of constructs to be ignored by this policy can specified by
  giving a value for 'allow' of a string of space-delimited keywords:
  C<if>, C<for>, C<unless>, C<until>, C<when>, and/or C<while>.  An
  example of specifying allowed flow-control structures in a
  F<.perlcriticrc> file:
  
      [ControlStructures::ProhibitPostfixControls]
      allow = for if until
  
  By default, all postfix control keywords are prohibited.
  
  The set of flow-control functions that are exempt from the restriction
  can also be configured with the 'flowcontrol' directive in your
  F<.perlcriticrc> file:
  
      [ControlStructures::ProhibitPostfixControls]
      flowcontrol = warn die carp croak cluck confess goto exit
  
  This is useful if you're using additional modules that add things like
  C<assert> or C<throw>.
  
  
  =head1 NOTES
  
  The C<die>, C<croak>, and C<confess> functions are frequently used as
  flow-controls just like C<next> or C<last>.  So this Policy does
  permit you to use a postfix C<if> when the statement begins with one
  of those functions.  It is also pretty common to use C<warn>, C<carp>,
  and C<cluck> with a postfix C<if>, so those are allowed too.
  
  The C<when> keyword was added to the language after Perl Best
  Practices was written.  This policy treats C<when> the same way it
  does C<if>, i.e. it's allowed after flow-control constructs.  Thanks
  to brian d foy for the
  L<inspiration|http://www.effectiveperlprogramming.com/blog/543>.
  
  
  =head1 BUGS
  
  Look for the C<do {} while> case and change the explanation to point
  to page 123 when it is found.  RT #37905.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITPOSTFIXCONTROLS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitUnlessBlocks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNLESSBLOCKS';
  package Perl::Critic::Policy::ControlStructures::ProhibitUnlessBlocks;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"unless" block used};
  Readonly::Scalar my $EXPL => [ 97 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_LOW              }
  sub default_themes       { return qw(core pbp cosmetic)      }
  sub applies_to           { return 'PPI::Statement::Compound' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem->first_element() eq 'unless' ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitUnlessBlocks - Write C<if(! $condition)> instead of C<unless($condition)>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages using C<unless> because it leads to
  double-negatives that are hard to understand.  Instead, reverse the
  logic and use C<if>.
  
      unless($condition) { do_something() } #not ok
      unless(! $no_flag) { do_something() } #really bad
      if( ! $condition)  { do_something() } #ok
  
  This Policy only covers the block-form of C<unless>.  For the postfix
  variety, see C<ProhibitPostfixControls>.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls|Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNLESSBLOCKS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitUnreachableCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNREACHABLECODE';
  package Perl::Critic::Policy::ControlStructures::ProhibitUnreachableCode;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  Readonly::Array my @TERMINALS => qw( die exit croak confess );
  Readonly::Hash  my %TERMINALS => hashify( @TERMINALS );
  
  Readonly::Array my @CONDITIONALS => qw( if unless foreach while until for );
  Readonly::Hash  my %CONDITIONALS => hashify( @CONDITIONALS );
  
  Readonly::Array my @OPERATORS => qw( && || // and or err ? );
  Readonly::Hash  my %OPERATORS => hashify( @OPERATORS );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Unreachable code};
  Readonly::Scalar my $EXPL => q{Consider removing it};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                 }
  sub default_severity     { return $SEVERITY_HIGH     }
  sub default_themes       { return qw( core bugs certrec )    }
  sub applies_to           { return 'PPI::Token::Word' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $statement = $elem->statement();
      return if not $statement;
  
      # We check to see if this is an interesting token before calling
      # is_function_call().  This weeds out most candidate tokens and
      # prevents us from having to make an expensive function call.
  
      return if ( !exists $TERMINALS{$elem} ) &&
          ( !$statement->isa('PPI::Statement::Break') );
  
      return if not is_function_call($elem);
  
      # Scan the enclosing statement for conditional keywords or logical
      # operators.  If any are found, then this the following statements
      # could _potentially_ be executed, so this policy is satisfied.
  
      # NOTE: When the first operand in an boolean expression is
      # C<croak> or C<die>, etc., the second operand is technically
      # unreachable.  But this policy doesn't catch that situation.
  
      for my $child ( $statement->schildren() ) {
          return if $child->isa('PPI::Token::Operator') && exists $OPERATORS{$child};
          return if $child->isa('PPI::Token::Word') && exists $CONDITIONALS{$child};
      }
  
      return $self->_gather_violations($statement);
  }
  
  sub _gather_violations {
      my ($self, $statement) = @_;
  
      # If we get here, then the statement contained an unconditional
      # die or exit or return.  Then all the subsequent sibling
      # statements are unreachable, except for those that have labels,
      # which could be reached from anywhere using C<goto>.  Subroutine
      # declarations are also exempt for the same reason.  "use" and
      # "our" statements are exempt because they happen at compile time.
  
      my @violations = ();
      while ( $statement = $statement->snext_sibling() ) {
          my @children = $statement->schildren();
          last if @children && $children[0]->isa('PPI::Token::Label');
          next if $statement->isa('PPI::Statement::Sub');
          next if $statement->isa('PPI::Statement::End');
          next if $statement->isa('PPI::Statement::Data');
          next if $statement->isa('PPI::Statement::Package');
  
          next if $statement->isa('PPI::Statement::Include') &&
              $statement->type() ne 'require';
  
          next if $statement->isa('PPI::Statement::Variable') &&
              $statement->type() eq 'our';
  
          push @violations, $self->violation( $DESC, $EXPL, $statement );
      }
  
      return @violations;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitUnreachableCode - Don't write code after an unconditional C<die, exit, or next>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This policy prohibits code following a statement which unconditionally
  alters the program flow.  This includes calls to C<exit>, C<die>,
  C<return>, C<next>, C<last> and C<goto>.  Due to common usage,
  C<croak> and C<confess> from L<Carp|Carp> are also included.
  
  Code is reachable if any of the following conditions are true:
  
  =over
  
  =item * Flow-altering statement has a conditional attached to it
  
  =item * Statement is on the right side of an operator C<&&>, C<||>, C<//>, C<and>, C<or>, or C<err>.
  
  =item * Code is prefixed with a label (can potentially be reached via C<goto>)
  
  =item * Code is a subroutine
  
  =back
  
  =head1 EXAMPLES
  
    # not ok
  
    exit;
    print "123\n";
  
    # ok
  
    exit if !$xyz;
    print "123\n";
  
    # not ok
  
    for ( 1 .. 10 ) {
        next;
        print 1;
    }
  
    # ok
  
    for ( 1 .. 10 ) {
        next if $_ == 5;
        print 1;
    }
  
    # not ok
  
    sub foo {
        my $bar = shift;
        return;
        print 1;
    }
  
    # ok
  
    sub foo {
        my $bar = shift;
        return if $bar->baz();
        print 1;
    }
  
  
    # not ok
  
    die;
    print "123\n";
  
    # ok
  
    die;
    LABEL: print "123\n";
  
    # not ok
  
    croak;
    do_something();
  
    # ok
  
    croak;
    sub do_something {}
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls|Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls>
  
  =head1 AUTHOR
  
  Peter Guzis <pguzis@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Peter Guzis.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNREACHABLECODE

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitUntilBlocks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNTILBLOCKS';
  package Perl::Critic::Policy::ControlStructures::ProhibitUntilBlocks;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"until" block used};
  Readonly::Scalar my $EXPL => [ 97 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return 'PPI::Statement'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem->first_element() eq 'until' ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitUntilBlocks - Write C<while(! $condition)> instead of C<until($condition)>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages using C<until> because it leads to double-negatives
  that are hard to understand.  Instead, reverse the logic and use
  C<while>.
  
      until($condition)     { do_something() } #not ok
      until(! $no_flag)     { do_something() } #really bad
      while( ! $condition)  { do_something() } #ok
  
  This Policy only covers the block-form of C<until>.  For the postfix
  variety, see C<ProhibitPostfixControls>.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls|Perl::Critic::Policy::ControlStructures::ProhibitPostfixControls>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITUNTILBLOCKS

$fatpacked{"Perl/Critic/Policy/ControlStructures/ProhibitYadaOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITYADAOPERATOR';
  package Perl::Critic::Policy::ControlStructures::ProhibitYadaOperator;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{yada operator (...) used};
  Readonly::Scalar my $EXPL => q{The yada operator is a placeholder for code you have not yet written.};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw( core pbp maintenance ) }
  sub applies_to           { return 'PPI::Token::Operator' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( _is_yada( $elem ) ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  sub _is_yada {
      my ( $elem ) = @_;
  
      return if $elem ne '...';
      #return if not defined $elem->statement;
  
      # if there is something significant on both sides of the element it's
      # probably the three dot range operator
      return if ($elem->snext_sibling and $elem->sprevious_sibling);
  
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords yada Berndt
  
  =head1 NAME
  
  Perl::Critic::Policy::ControlStructures::ProhibitYadaOperator - Never use C<...> in production code.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The yada operator C<...> is not something you'd want in production
  code because it will throw an exception when executed.  However, it is
  perfectly useful in less critical environments as a placeholder for code
  not yet implemented.
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  =head1 AUTHOR
  
  Alan Berndt <alan@eatabrick.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2015-2017 Alan Berndt.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_CONTROLSTRUCTURES_PROHIBITYADAOPERATOR

$fatpacked{"Perl/Critic/Policy/Documentation/PodSpelling.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_PODSPELLING';
  package Perl::Critic::Policy::Documentation::PodSpelling;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use File::Spec;
  use File::Temp;
  use IO::String qw< >;
  use List::MoreUtils qw(uniq);
  use Pod::Spell qw< >;
  use Text::ParseWords qw< >;
  
  use Perl::Critic::Utils qw{
      :characters
      :booleans
      :severities
      words_from_string
  };
  use Perl::Critic::Exception::Fatal::Generic qw{ throw_generic };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $POD_RX => qr{\A = (?: for|begin|end ) }xms;
  Readonly::Scalar my $DESC => q{Check the spelling in your POD};
  Readonly::Scalar my $EXPL => [148];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'spell_command',
              description     => 'The command to invoke to check spelling.',
              default_string  => 'aspell list',
              behavior        => 'string',
          },
          {
              name            => 'stop_words',
              description     => 'The words to not consider as misspelled.',
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
          {
              name            => 'stop_words_file',
              description     => 'A file containing words to not consider as misspelled.',
              default_string  => $EMPTY,
              behavior        => 'string',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core cosmetic pbp ) }
  sub applies_to           { return 'PPI::Document'         }
  
  #-----------------------------------------------------------------------------
  
  my $got_sigpipe = 0;
  sub got_sigpipe {
      return $got_sigpipe;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ( $self, $config ) = @_;
  
      eval { require File::Which; 1 } or return $FALSE;
  
      return $FALSE if not $self->_derive_spell_command_line();
  
      return $FALSE if not $self->_run_spell_command( <<'END_TEST_CODE' );
  =pod
  
  =head1 Test The Spell Command
  
  =cut
  END_TEST_CODE
  
      $self->_load_stop_words_file();
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      my $code = $doc->serialize();
  
      my $words = $self->_run_spell_command($code);
  
      return if not $words;       # error running spell command
  
      return if not @{$words};    # no problems found
  
      return $self->violation( "$DESC: @{$words}", $EXPL, $doc );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _derive_spell_command_line {
      my ($self) = @_;
  
      my @words = Text::ParseWords::shellwords($self->_get_spell_command());
      if (!@words) {
          return;
      }
      if (! File::Spec->file_name_is_absolute($words[0])) {
         $words[0] = File::Which::which($words[0]);
      }
      if (! $words[0] || ! -x $words[0]) {
          return;
      }
      $self->_set_spell_command_line(\@words);
  
      return $self->_get_spell_command_line();
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_spell_command {
      my ( $self ) = @_;
  
      return $self->{_spell_command};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_spell_command_line {
      my ( $self ) = @_;
  
      return $self->{_spell_command_line};
  }
  
  sub _set_spell_command_line {
      my ( $self, $spell_command_line ) = @_;
  
      $self->{_spell_command_line} = $spell_command_line;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_stop_words {
      my ( $self ) = @_;
  
      return $self->{_stop_words};
  }
  
  sub _set_stop_words {
      my ( $self, $stop_words ) = @_;
  
      $self->{_stop_words} = $stop_words;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_stop_words_file {
      my ( $self ) = @_;
  
      return $self->{_stop_words_file};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _run_spell_command {
      my ($self, $code) = @_;
  
      my $infh = IO::String->new( $code );
  
      my $outfh = File::Temp->new();
  
      my $outfile = $outfh->filename();
      my @words;
  
      local $EVAL_ERROR = undef;
  
      eval {
          # temporarily add our special wordlist to this annoying global
          local %Pod::Wordlist::Wordlist =    ## no critic (ProhibitPackageVars)
              %{ $self->_get_stop_words() };
  
          Pod::Spell->new()->parse_from_filehandle($infh, $outfh);
          close $outfh or throw_generic "Failed to close pod temp file: $OS_ERROR";
          return if not -s $outfile; # Bail out if no words to spellcheck
  
          # run spell command and fetch output
          local $SIG{PIPE} = sub { $got_sigpipe = 1; };
          my $command_line = join $SPACE, @{$self->_get_spell_command_line()};
          open my $aspell_out_fh, q{-|}, "$command_line < $outfile"  ## Is this portable??
              or throw_generic "Failed to open handle to spelling program: $OS_ERROR";
  
          @words = uniq( <$aspell_out_fh> );
          close $aspell_out_fh
              or throw_generic "Failed to close handle to spelling program: $OS_ERROR";
  
          for (@words) {
              chomp;
          }
  
          # Why is this extra step needed???
          @words = grep { not exists $Pod::Wordlist::Wordlist{$_} } @words;  ## no critic (ProhibitPackageVars)
          1;
      }
          or do {
              # Eat anything we did ourselves above, propagate anything else.
              if (
                      $EVAL_ERROR
                  and not ref Perl::Critic::Exception::Fatal::Generic->caught()
              ) {
                  ref $EVAL_ERROR ? $EVAL_ERROR->rethrow() : die $EVAL_ERROR;  ## no critic (ErrorHandling::RequireCarping)
              }
  
              return;
          };
  
      return [ @words ];
  }
  
  #-----------------------------------------------------------------------------
  
  sub _load_stop_words_file {
      my ($self) = @_;
  
      my %stop_words = %{ $self->_get_stop_words() };
  
      my $file_name = $self->_get_stop_words_file() or return;
  
      open my $handle, '<', $file_name
          or do { warn qq<Could not open "$file_name": $OS_ERROR\n>; return; };
  
      while ( my $line = <$handle> ) {
          if ( my $word = _word_from_line($line) ) {
              $stop_words{$word} = 1;
          }
      }
  
      close $handle or warn qq<Could not close "$file_name": $OS_ERROR\n>;
  
      $self->_set_stop_words(\%stop_words);
  
      return;
  }
  
  sub _word_from_line {
      my ($line) = @_;
  
      $line =~ s< [#] .* \z ><>xms;
      $line =~ s< \s+ \z ><>xms;
      $line =~ s< \A \s+ ><>xms;
  
      return $line;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords foobie foobie-bletch Hmm stopwords
  
  =head1 NAME
  
  Perl::Critic::Policy::Documentation::PodSpelling - Check your spelling.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Did you write the documentation?  Check.
  
  Did you document all of the public methods?  Check.
  
  Is your documentation readable?  Hmm...
  
  Ideally, we'd like Perl::Critic to tell you when your documentation is
  inadequate.  That's hard to code, though.  So, inspired by
  L<Test::Spelling|Test::Spelling>, this module checks the spelling of
  your POD.  It does this by pulling the prose out of the code and
  passing it to an external spell checker.  It skips over words you
  flagged to ignore.  If the spell checker returns any misspelled words,
  this policy emits a violation.
  
  If anything else goes wrong -- we can't locate the spell checking program or
  (gasp!) your module has no POD -- then this policy passes.
  
  To add exceptions on a module-by-module basis, add "stopwords" as
  described in L<Pod::Spell|Pod::Spell>.  For example:
  
      =for stopword gibbles
  
      =head1 Gibble::Manip -- manipulate your gibbles
  
      =cut
  
  
  =head1 CONFIGURATION
  
  This policy can be configured to tell which spell checker to use or to
  set a global list of spelling exceptions.  To do this, put entries in
  a F<.perlcriticrc> file like this:
  
      [Documentation::PodSpelling]
      spell_command = aspell list
      stop_words = gibbles foobar
      stop_words_file = some/path/with/stop/words.txt
  
  The default spell command is C<aspell list> and it is interpreted as a
  shell command.  We parse the individual arguments via
  L<Text::ParseWords|Text::ParseWords> so feel free to use quotes around
  your arguments.  If the executable path is an absolute file name, it
  is used as-is.  If it is a relative file name, we employ
  L<File::Which|File::Which> to convert it to an absolute path via the
  C<PATH> environment variable.  As described in Pod::Spell and
  Test::Spelling, the spell checker must accept text on STDIN and print
  misspelled words one per line on STDOUT.
  
  You can specify global stop words via the C<stop_words> and
  C<stop_words_file> options.  The former is simply split up on
  whitespace.  The latter is looked at line by line, with anything after
  an octothorp ("#") removed and then leading and trailing whitespace
  removed.  Silly example valid file contents:
  
      # It's a comment!
  
      foo
      arglbargl    # Some other comment.
      bar
  
  The values from C<stop_words> and C<stop_words_file> are merged
  together into a single list of exemptions.
  
  
  =head1 NOTES
  
  A spell checking program is not included with Perl::Critic.
  
  The results of failures for this policy can be confusing when F<aspell>
  complains about words containing punctuation such as hyphens and apostrophes.
  In this situation F<aspell> will often only emit part of the word that it
  thinks is misspelled.  For example, if you ask F<aspell> to check
  "foobie-bletch", the output only complains about "foobie".  Unfortunately,
  you'll have to look through your POD to figure out what the real word that
  F<aspell> is complaining about is.  One thing to try is looking at the output
  of C<< perl -MPod::Spell -e 'print
  Pod::Spell->new()->parse_from_file("lib/Your/Module.pm")' >> to see what is
  actually being checked for spelling.
  
  
  =head1 PREREQUISITES
  
  This policy will disable itself if L<File::Which|File::Which> is not
  available.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_DOCUMENTATION_PODSPELLING

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePackageMatchesPodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPACKAGEMATCHESPODNAME';
  package Perl::Critic::Policy::Documentation::RequirePackageMatchesPodName;
  
  use 5.006001;
  
  use strict;
  use warnings;
  
  use Readonly;
  use English qw{ -no_match_vars };
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $PKG_RX => qr{ [[:alpha:]](?:[\w:\']*\w)? }xms;
  Readonly::Scalar my $DESC =>
      q{Pod NAME on line %d does not match the package declaration};
  Readonly::Scalar my $EXPL => q{};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                      }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core cosmetic )     }
  sub applies_to           { return 'PPI::Document'         }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      my ( $self, $document ) = @_;
  
      # idea: force NAME to match the file name in programs?
      return $document->is_module(); # mismatch is normal in program entry points
  }
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # No POD means no violation
      my $pods_ref = $doc->find('PPI::Token::Pod');
      return if !$pods_ref;
  
      for my $pod (@{$pods_ref}) {
          my $content = $pod->content;
  
          next if $content !~ m{^=head1 [ \t]+ NAME [ \t]*$ \s*}cgxms;
  
          my $line_number = $pod->line_number() + (
              substr( $content, 0, $LAST_MATCH_START[0] + 1 ) =~ tr/\n/\n/ );
  
          my ($pod_pkg) = $content =~ m{\G (\S+) }cgxms;
  
          if (!$pod_pkg) {
              return $self->violation( sprintf( $DESC, $line_number ),
                  q{Empty name declaration}, $pod );
          }
  
          # idea: worry about POD escapes?
          $pod_pkg =~ s{\A [CL]<(.*)>\z}{$1}gxms; # unwrap
          $pod_pkg =~ s{\'}{::}gxms;              # perl4 -> perl5
  
          foreach my $stmt ( @{ $doc->find('PPI::Statement::Package') || [] } ) {
              my $pkg = $stmt->namespace();
              $pkg =~ s{\'}{::}gxms;
              return if $pkg eq $pod_pkg;
          }
  
          return $self->violation( sprintf( $DESC, $line_number ),
              $EXPL, $pod );
      }
  
      return;  # no NAME section found
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Documentation::RequirePackageMatchesPodName - The C<=head1 NAME> section should match the package.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic> distribution.
  
  
  =head1 DESCRIPTION
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Chris Dolan
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPACKAGEMATCHESPODNAME

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePodAtEnd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODATEND';
  package Perl::Critic::Policy::Documentation::RequirePodAtEnd;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::Util qw(first);
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $POD_RX => qr{\A = (?: for|begin|end ) }xms;
  Readonly::Scalar my $DESC => q{POD before __END__};
  Readonly::Scalar my $EXPL => [139, 140];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                      }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core cosmetic pbp ) }
  sub applies_to           { return 'PPI::Document'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # No POD means no violation
      my $pods_ref = $doc->find('PPI::Token::Pod');
      return if !$pods_ref;
  
      # Look for first POD tag that isn't =for, =begin, or =end
      my $pod = first { $_ !~ $POD_RX} @{ $pods_ref };
      return if !$pod;
  
      my $end = $doc->find_first('PPI::Statement::End');
      if ($end) {  # No __END__ means definite violation
          my $pod_loc = $pod->location();
          my $end_loc = $end->location();
          if ( $pod_loc->[0] > $end_loc->[0] ) {
              # POD is after __END__, or relative position couldn't be determined
              return;
          }
      }
  
      return $self->violation( $DESC, $EXPL, $pod );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Documentation::RequirePodAtEnd - All POD should be after C<__END__>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl stops processing code when it sees an C<__END__> statement.  So,
  to save processing time, it's faster to put documentation after the
  C<__END__>.  Also, writing all the POD in one place usually leads to a
  more cohesive document, rather than being forced to follow the layout
  of your code.  This policy issues violations if any POD is found
  before an C<__END__>.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  Some folks like to use C<=for>, and C<=begin>, and C<=end> tags to
  create block comments in-line with their code.  Since those tags
  aren't usually part of the documentation, this Policy does allows them
  to appear before the C<__END__> statement.
  
      =begin comments
  
      frobulate()
      Accepts:  A list of things to frobulate
      Returns:  True if successful
  
      =end comments
  
      sub frobulate { ... }
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODATEND

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePodLinksIncludeText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODLINKSINCLUDETEXT';
  package Perl::Critic::Policy::Documentation::RequirePodLinksIncludeText;
  
  use 5.006001;
  
  use strict;
  use warnings;
  
  use Readonly;
  use English qw{ -no_match_vars };
  use Perl::Critic::Utils qw{ :booleans :characters :severities };
  use base 'Perl::Critic::Policy';
  
  use Perl::Critic::Utils::POD::ParseInteriorSequence;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => 'Without text, you are at the mercy of the POD translator';
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'allow_external_sections',
              description     => 'Allow external sections without text',
              default_string  => '1',
              behavior        => 'boolean',
          },
          {
              name            => 'allow_internal_sections',
              description     => 'Allow internal sections without text',
              default_string  => '1',
              behavior        => 'boolean',
          },
      );
  }
  sub default_severity { return $SEVERITY_LOW            }
  sub default_themes   { return qw(core maintenance)     }
  sub applies_to       { return 'PPI::Token::Pod'        }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $INCREMENT_NESTING => 1;
  Readonly::Scalar my $DECREMENT_NESTING => -1;
  Readonly::Hash my %ESCAPE_NESTING => (
      '<' => $INCREMENT_NESTING,
      '>' => $DECREMENT_NESTING,
  );
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      my @violations;
  
  =begin comment
  
      my $pod = $elem->content();
  
      # We look for _any_ POD escape, not just L<>. This way we can avoid false
      # positives on constructions like C<< L<Foo> >>. In an attempt to be
      # upward compatible (and at a slight (I hope!) risk of false negatives),
      # we accept any upper case letter as beginning a formatting sequence, not
      # just [IBCLEFSXZ].
      SCAN_POD:
      while ( $pod =~ m/ ( [[:upper:]] ) ( <+ )   /smxg ) {
  
          # Collect the results of the match.
          my $formatter = $1;
          my $link_start = $LAST_MATCH_START[0];
          my $content_start = $LAST_MATCH_END[0];
          my $num_brkt = length $2;
  
          # The only way to handle arbitrarily-nested brackets before Perl
          # 5.10 is the (??{}) construction, which is _still_ marked
          # 'experimental' as of 5.12.3 and 5.13.9. Taking them at their
          # word, I'm going to find the end of the POD escape the hard
          # way.
          my $link_end = $link_start + 1;
          my $nest = 0;
          while ( 1 ) {
              $nest += $ESCAPE_NESTING{ substr $pod, $link_end++, 1 } || 0;
              $nest or last;
              $link_end < length $pod
                  or last SCAN_POD;
          }
  
          # Manually advance past the end of the link so the regular
          # expression does not find any possible nested formatting.
          pos $pod = $link_end;
  
          # If it's not an 'L' formatter, we are not interested.
          'L' eq $formatter or next;
  
          # Save both the link itself and its contents for further analysis.
          my $link = substr $pod, $link_start, $link_end - $link_start;
          my $content = substr $pod, $content_start,
              $link_end - $num_brkt - $content_start;
  
          # If the link is allowed, pass on to the next one.
          $self->_allowed_link( $content ) and next;
  
          # A-Hah! Gotcha!
          my $line_number = $elem->line_number() + (
              substr( $pod, 0, $link_start ) =~ tr/\n/\n/ );
          push @violations, $self->violation(
              "Link $link on line $line_number does not specify text",
              $EXPL, $elem );
  
      }
  
  =end comment
  
  =cut
  
      my $parser = Perl::Critic::Utils::POD::ParseInteriorSequence->new();
      $parser->errorsub( sub { return 1 } );  # Suppress error messages.
  
      foreach my $seq ( $parser->get_interior_sequences( $elem->content() ) ) {
  
          # Not interested in nested thing like C<< L<Foo> >>. I think.
          $seq->nested() and next;
  
          # Not interested in anything but L<...>.
          'L' eq $seq->cmd_name() or next;
  
          # If the link is allowed, pass on to the next one.
          $self->_allowed_link( $seq ) and next;
  
          # A-Hah! Gotcha!
          my $line_number = $elem->line_number() + ( $seq->file_line() )[1] - 1;
          push @violations, $self->violation(
              join( $SPACE, 'Link', $seq->raw_text(),
                  "on line $line_number does not specify text" ),
              $EXPL, $elem );
      }
  
      return @violations;
  }
  
  sub _allowed_link {
  
  =begin comment
  
      my ( $self, $content ) = @_;
  
  =end comment
  
  =cut
  
      my ( $self, $pod_seq ) = @_;
  
      # Extract the content of the sequence.
      my $content = $pod_seq->raw_text();
      $content = substr $content, 0, - length $pod_seq->right_delimiter();
      $content = substr $content, length( $pod_seq->cmd_name() ) + length(
          $pod_seq->left_delimiter() );
  
      # Not interested in hyperlinks.
      $content =~ m{ \A \w+ : (?! : ) }smx
          and return $TRUE;
  
      # Links with text specified are good.
      $content =~ m/ [|] /smx
          and return $TRUE;
  
      # Internal sections without text are either good or bad, depending on how
      # we are configured.
      $content =~ m{ \A [/"] }smx
          and return $self->{_allow_internal_sections};
  
      # External sections without text are either good or bad, depending on how
      # we are configured.
      $content =~ m{ / }smx
          and return $self->{_allow_external_sections};
  
      # Anything else without text is bad.
      return $FALSE;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords licence
  
  =head1 NAME
  
  Perl::Critic::Policy::Documentation::RequirePodLinksIncludeText - Provide text to display with your pod links.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This Policy requires your POD links to contain text to override your POD
  translator's default link text, where this is possible.  Failure to provide
  your own text leaves you at the mercy of the POD translator, which may
  display something like C<< LE<lt>Foo> >> as C<the Foo manpage>.
  
  By default, links that specify a documentation section (for example, C<<
  LE<lt>Foo/bar> >>, or C<< LE<lt>/bar> >>) are exempt from this Policy.
  
  
  =head1 CONFIGURATION
  
  This Policy has two boolean options to configure the handling of links that
  specify a documentation section.
  
  The C<allow_external_sections> option configures the handling of links of the
  form C<< LE<lt>Foo/bar> >>.  If true, such links are accepted even without a text
  specification.  Such links tend to be turned into something like C<bar in
  Foo>.
  
  By default, this option is asserted.  If you want to prohibit things like
  C<< LE<lt>Foo/bar> >> (while allowing things like C<<< LE<lt>E<lt> Foo->bar()|Foo/bar >>
  >>>), put something like this in your F<.perlcriticrc>:
  
   [Documentation::RequirePodLinksIncludeText]
   allow_external_sections = 0
  
  The C<allow_internal_sections> option configures the handling of links of the
  form C<< LE<lt>/bar> >>.  If true, such links are accepted even without a text
  specification.  Such links tend to be turned into something like C<bar>.
  
  By default, this option is asserted.  If you want to prohibit things like
  C<< LE<lt>/bar> >> (while allowing things like C<< LE<lt>bar()|/bar> >>), put
  something like this in your F<.perlcriticrc>:
  
   [Documentation::RequirePodLinksIncludeText]
   allow_internal_sections = 0
  
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Thomas R. Wyant, III.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODLINKSINCLUDETEXT

$fatpacked{"Perl/Critic/Policy/Documentation/RequirePodSections.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODSECTIONS';
  package Perl::Critic::Policy::Documentation::RequirePodSections;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :characters :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => [133, 138];
  
  Readonly::Scalar my $BOOK                => 'book';
  Readonly::Scalar my $BOOK_FIRST_EDITION  => 'book_first_edition';
  Readonly::Scalar my $MODULE_STARTER_PBP  => 'module_starter_pbp';
  Readonly::Scalar my $M_S_PBP_0_0_3       => 'module_starter_pbp_0_0_3';
  
  Readonly::Scalar my $DEFAULT_SOURCE      => $BOOK_FIRST_EDITION;
  
  Readonly::Hash   my %SOURCE_TRANSLATION  => (
      $BOOK               => $BOOK_FIRST_EDITION,
      $BOOK_FIRST_EDITION => $BOOK_FIRST_EDITION,
      $MODULE_STARTER_PBP => $M_S_PBP_0_0_3,
      $M_S_PBP_0_0_3      => $M_S_PBP_0_0_3,
  );
  
  Readonly::Scalar my $EN_AU                       => 'en_AU';
  Readonly::Scalar my $EN_US                       => 'en_US';
  Readonly::Scalar my $ORIGINAL_MODULE_VERSION     => 'original';
  
  Readonly::Hash my %SOURCE_DEFAULT_LANGUAGE     => (
      $BOOK_FIRST_EDITION => $ORIGINAL_MODULE_VERSION,
      $M_S_PBP_0_0_3      => $EN_AU,
  );
  
  Readonly::Scalar my $BOOK_FIRST_EDITION_US_LIB_SECTIONS =>
      [
          'NAME',
          'VERSION',
          'SYNOPSIS',
          'DESCRIPTION',
          'SUBROUTINES/METHODS',
          'DIAGNOSTICS',
          'CONFIGURATION AND ENVIRONMENT',
          'DEPENDENCIES',
          'INCOMPATIBILITIES',
          'BUGS AND LIMITATIONS',
          'AUTHOR',
          'LICENSE AND COPYRIGHT',
      ];
  
  Readonly::Hash my %DEFAULT_LIB_SECTIONS => (
      $BOOK_FIRST_EDITION => {
          $ORIGINAL_MODULE_VERSION => $BOOK_FIRST_EDITION_US_LIB_SECTIONS,
          $EN_AU => [
              'NAME',
              'VERSION',
              'SYNOPSIS',
              'DESCRIPTION',
              'SUBROUTINES/METHODS',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENCE AND COPYRIGHT',
          ],
          $EN_US => $BOOK_FIRST_EDITION_US_LIB_SECTIONS,
      },
      $M_S_PBP_0_0_3 => {
          $EN_AU => [
              'NAME',
              'VERSION',
              'SYNOPSIS',
              'DESCRIPTION',
              'INTERFACE',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENCE AND COPYRIGHT',
              'DISCLAIMER OF WARRANTY',
          ],
          $EN_US => [
              'NAME',
              'VERSION',
              'SYNOPSIS',
              'DESCRIPTION',
              'INTERFACE',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENSE AND COPYRIGHT',
              'DISCLAIMER OF WARRANTY'
          ],
      },
  );
  
  Readonly::Hash my %DEFAULT_SCRIPT_SECTIONS => (
      $BOOK_FIRST_EDITION => {
          $ORIGINAL_MODULE_VERSION => [
              'NAME',
              'USAGE',
              'DESCRIPTION',
              'REQUIRED ARGUMENTS',
              'OPTIONS',
              'DIAGNOSTICS',
              'EXIT STATUS',
              'CONFIGURATION',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENSE AND COPYRIGHT',
          ],
          $EN_AU => [
              'NAME',
              'VERSION',
              'USAGE',
              'REQUIRED ARGUMENTS',
              'OPTIONS',
              'DESCRIPTION',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENCE AND COPYRIGHT',
          ],
          $EN_US => [
              'NAME',
              'VERSION',
              'USAGE',
              'REQUIRED ARGUMENTS',
              'OPTIONS',
              'DESCRIPTION',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENSE AND COPYRIGHT',
          ],
      },
      $M_S_PBP_0_0_3 => {
          $EN_AU => [
              'NAME',
              'VERSION',
              'USAGE',
              'REQUIRED ARGUMENTS',
              'OPTIONS',
              'DESCRIPTION',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENCE AND COPYRIGHT',
              'DISCLAIMER OF WARRANTY',
          ],
          $EN_US => [
              'NAME',
              'VERSION',
              'USAGE',
              'REQUIRED ARGUMENTS',
              'OPTIONS',
              'DESCRIPTION',
              'DIAGNOSTICS',
              'CONFIGURATION AND ENVIRONMENT',
              'DEPENDENCIES',
              'INCOMPATIBILITIES',
              'BUGS AND LIMITATIONS',
              'AUTHOR',
              'LICENSE AND COPYRIGHT',
              'DISCLAIMER OF WARRANTY',
          ],
      },
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'lib_sections',
              description     => 'The sections to require for modules (separated by qr/\s* [|] \s*/xms).',
              default_string  => $EMPTY,
              parser          => \&_parse_lib_sections,
          },
          {
              name            => 'script_sections',
              description     => 'The sections to require for programs (separated by qr/\s* [|] \s*/xms).',
              default_string  => $EMPTY,
              parser          => \&_parse_script_sections,
          },
          {
              name            => 'source',
              description     => 'The origin of sections to use.',
              default_string  => $DEFAULT_SOURCE,
              behavior        => 'enumeration',
              enumeration_values => [ keys %SOURCE_TRANSLATION ],
          },
          {
              name            => 'language',
              description     => 'The spelling of sections to use.',
              default_string  => $EMPTY,
              behavior        => 'enumeration',
              enumeration_values => [ $EN_AU, $EN_US ],
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOW            }
  sub default_themes   { return qw(core pbp maintenance) }
  sub applies_to       { return 'PPI::Document'          }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_sections {
      my $config_string = shift;
  
      my @sections = split m{ \s* [|] \s* }xms, $config_string;
  
      return map { uc } @sections;  # Normalize CaSe!
  }
  
  sub _parse_lib_sections {
      my ($self, $parameter, $config_string) = @_;
  
      if ( defined $config_string ) {
          $self->{_lib_sections} = [ _parse_sections( $config_string ) ];
      }
  
      return;
  }
  
  sub _parse_script_sections {
      my ($self, $parameter, $config_string) = @_;
  
      if ( defined $config_string ) {
          $self->{_script_sections} = [ _parse_sections( $config_string ) ];
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      my $source = $self->{_source};
      if ( not defined $source or not defined $DEFAULT_LIB_SECTIONS{$source} ) {
          $source = $DEFAULT_SOURCE;
      }
  
      my $language = $self->{_language};
      if (
              not defined $language
          or  not defined $DEFAULT_LIB_SECTIONS{$source}{$language}
      ) {
          $language = $SOURCE_DEFAULT_LANGUAGE{$source};
      }
  
      if ( not $self->_sections_specified('_lib_sections') ) {
          $self->{_lib_sections} = $DEFAULT_LIB_SECTIONS{$source}{$language};
      }
      if ( not $self->_sections_specified('_script_sections') ) {
          $self->{_script_sections} =
              $DEFAULT_SCRIPT_SECTIONS{$source}{$language};
      }
  
      return $TRUE;
  }
  
  sub _sections_specified {
      my ( $self, $sections_key ) = @_;
  
      my $sections = $self->{$sections_key};
  
      return 0 if not defined $sections;
  
      return scalar @{ $sections };
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # This policy does not apply unless there is some real code in the
      # file.  For example, if this file is just pure POD, then
      # presumably this file is ancillary documentation and you can use
      # whatever headings you want.
      return if ! $doc->schild(0);
  
      my %found_sections = ();
      my @violations = ();
  
      my @required_sections =
          $doc->is_program()
              ? @{ $self->{_script_sections} }
              : @{ $self->{_lib_sections} };
  
      my $pods_ref = $doc->find('PPI::Token::Pod');
      return if not $pods_ref;
  
      # Round up the names of all the =head1 sections
      my $pod_of_record;
      for my $pod ( @{ $pods_ref } ) {
          for my $found ( $pod =~ m{ ^ =head1 \s+ ( .+? ) \s* $ }gxms ) {
              # Use first matching POD as POD of record (RT #59268)
              $pod_of_record ||= $pod;
              #Leading/trailing whitespace is already removed
              $found_sections{ uc $found } = 1;
          }
      }
  
      # Compare the required sections against those we found
      for my $required ( @required_sections ) {
          if ( not exists $found_sections{$required} ) {
              my $desc = qq{Missing "$required" section in POD};
              # Report any violations against POD of record rather than whole
              # document (the point of RT #59268)
              # But if there are no =head1 records at all, rat out the
              # first pod found, as being better than blowing up. RT #67231
              push @violations, $self->violation( $desc, $EXPL,
                  $pod_of_record || $pods_ref->[0] );
          }
      }
  
      return @violations;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords licence
  
  =head1 NAME
  
  Perl::Critic::Policy::Documentation::RequirePodSections - Organize your POD into the customary sections.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This Policy requires your POD to contain certain C<=head1> sections.
  If the file doesn't contain any POD at all, then this Policy does not
  apply.  Tools like L<Module::Starter|Module::Starter> make it really
  easy to ensure that every module has the same documentation framework,
  and they can save you lots of keystrokes.
  
  
  =head1 DEFAULTS
  
  Different POD sections are required, depending on whether the file is
  a library or program (which is determined by the presence or absence
  of a perl shebang line).
  
                  Default Required POD Sections
  
      Perl Libraries                     Perl Programs
      -----------------------------      ---------------------
      NAME                               NAME
      VERSION
      SYNOPSIS                           USAGE
      DESCRIPTION                        DESCRIPTION
      SUBROUTINES/METHODS                REQUIRED ARGUMENTS
                                         OPTIONS
      DIAGNOSTICS                        DIAGNOSTICS
                                         EXIT STATUS
      CONFIGURATION AND ENVIRONMENT      CONFIGURATION
      DEPENDENCIES                       DEPENDENCIES
      INCOMPATIBILITIES                  INCOMPATIBILITIES
      BUGS AND LIMITATIONS               BUGS AND LIMITATIONS
      AUTHOR                             AUTHOR
      LICENSE AND COPYRIGHT              LICENSE AND COPYRIGHT
  
  
  =head1 CONFIGURATION
  
  The default sections above are derived from Damian Conway's I<Perl
  Best Practices> book.  Since the book has been published, Conway has
  released L<Module::Starter::PBP|Module::Starter::PBP>, which has
  different names for some of the sections, and adds some more.  Also,
  the book and module use Australian spelling, while the authors of this
  module have previously used American spelling.  To sort this all out,
  there are a couple of options that can be used: C<source> and
  C<language>.
  
  The C<source> option has two generic values, C<book> and
  C<module_starter_pbp>, and two version-specific values,
  C<book_first_edition> and C<module_starter_pbp_0_0_3>.  Currently, the
  generic values map to the corresponding version-specific values, but
  may change as new versions of the book and module are released, so use
  these if you want to keep up with the latest and greatest.  If you
  want things to remain stable, use the version-specific values.
  
  The C<language> option has a default, unnamed value but also accepts
  values of C<en_AU> and C<en_US>.  The reason the unnamed value exists
  is because the default values for programs don't actually match the
  book, even taking spelling into account, i.e. C<CONFIGURATION> instead
  of C<CONFIGURATION AND ENVIRONMENT>, the removal of C<VERSION>, and
  the addition of C<EXIT STATUS>.  To get precisely the sections as
  specified in the book, put the following in your F<.perlcriticrc>
  file:
  
      [Documentation::RequirePodSections]
      source   = book_first_edition
      language = en_AU
  
  If you want to use
  
      [Documentation::RequirePodSections]
      source   = module_starter_pbp
      language = en_US
  
  you will need to modify your F<~/.module-starter/PBP/Module.pm>
  template because it is generated using Australian spelling.
  
  Presently, the difference between C<en_AU> and C<en_US> is in how the
  word "licence" is spelled.
  
  The sections required for modules and programs can be independently
  customized, overriding any values for C<source> and C<language>, by
  giving values for C<script_sections> and C<lib_sections> of a string
  of pipe-delimited required POD section names.  An example of entries
  in a F<.perlcriticrc> file:
  
      [Documentation::RequirePodSections]
      lib_sections    = NAME | SYNOPSIS | BUGS AND LIMITATIONS | AUTHOR
      script_sections = NAME | USAGE | OPTIONS | EXIT STATUS | AUTHOR
  
  
  =head1 LIMITATIONS
  
  Currently, this Policy does not look for the required POD sections
  below the C<=head1> level.  Also, it does not require the sections to
  appear in any particular order.
  
  This Policy applies to the entire document, but can be disabled for a
  particular document by a C<## no critic (RequirePodSections)> annotation
  anywhere between the beginning of the document and the first POD section
  containing a C<=head1>, the C<__END__> (if any), or the C<__DATA__> (if any),
  whichever comes first.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_DOCUMENTATION_REQUIREPODSECTIONS

$fatpacked{"Perl/Critic/Policy/ErrorHandling/RequireCarping.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECARPING';
  package Perl::Critic::Policy::ErrorHandling::RequireCarping;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{
      :booleans :characters :severities :classification :data_conversion
  };
  use Perl::Critic::Utils::PPI qw{ is_ppi_expression_or_generic_statement };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => [ 283 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'allow_messages_ending_with_newlines',
              description    => q{Don't complain about die or warn if the message ends in a newline.},
              default_string => '1',
              behavior       => 'boolean',
          },
          {
              name           => 'allow_in_main_unless_in_subroutine',
              description    => q{Don't complain about die or warn in main::, unless in a subroutine.},
              default_string => '0',
              behavior       => 'boolean',
          },
      );
  }
  
  sub default_severity  { return $SEVERITY_MEDIUM                          }
  sub default_themes    { return qw( core pbp maintenance certrule )                }
  sub applies_to        { return 'PPI::Token::Word'                        }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $alternative;
      if ( $elem eq 'warn' ) {
          $alternative = 'carp';
      }
      elsif ( $elem eq 'die' ) {
          $alternative = 'croak';
      }
      else {
          return;
      }
  
      return if ! is_function_call($elem);
  
      if ($self->{_allow_messages_ending_with_newlines}) {
          return if _last_flattened_argument_list_element_ends_in_newline($elem);
      }
  
      return if $self->{_allow_in_main_unless_in_subroutine}
          && !$self->_is_element_contained_in_subroutine( $elem )
          && $self->_is_element_in_namespace_main( $elem );    # RT #56619
  
      my $desc = qq{"$elem" used instead of "$alternative"};
      return $self->violation( $desc, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _last_flattened_argument_list_element_ends_in_newline {
      my $die_or_warn = shift;
  
      my $last_flattened_argument =
          _find_last_flattened_argument_list_element($die_or_warn)
          or return $FALSE;
  
      if ( $last_flattened_argument->isa('PPI::Token::Quote') ) {
          my $last_flattened_argument_string =
              $last_flattened_argument->string();
          if (
                  $last_flattened_argument_string =~ m{ \n \z }xms
              or (
                      (
                              $last_flattened_argument->isa('PPI::Token::Quote::Double')
                          or $last_flattened_argument->isa('PPI::Token::Quote::Interpolate')
                      )
                  and $last_flattened_argument_string =~ m{ [\\] n \z }xms
              )
          ) {
              return $TRUE;
          }
      }
      elsif ( $last_flattened_argument->isa('PPI::Token::HereDoc') ) {
          return $TRUE;
      }
  
      return $FALSE
  }
  
  #-----------------------------------------------------------------------------
  # Here starts the fun.  Explanation by example:
  #
  # Let's say we've got the following (contrived) statement:
  #
  #    die q{Isn't }, ( $this, ( " fun?\n" ) , ) if "It isn't Monday.";
  #
  # This statement should pass because the last parameter that die is going to
  # get is C<" fun?\n">.
  #
  # The approach is to first find the last non-flattened parameter.  If this
  # is a simple token, we're done.  Else, it's some aggregate thing.  We can't
  # tell what C<some_function( "foo\n" )> is going to do, so we give up on
  # anything other than a PPI::Structure::List.
  #
  # There are three possible scenarios for the children of a List:
  #
  #   * No children of the List, i.e. the list looks like C< ( ) >.
  #   * One PPI::Statement::Expression element.
  #   * One PPI::Statement element.  That's right, an instance of the base
  #     statement class and not some subclass.  *sigh*
  #
  # In the first case, we're done.  The latter two cases get treated
  # identically.  We get the last child of the Statement and start the search
  # all over again.
  #
  # Back to our example.  The PPI tree for this expression is
  #
  #     PPI::Document
  #       PPI::Statement
  #         PPI::Token::Word    'die'
  #         PPI::Token::Quote::Literal          'q{Isn't }'
  #         PPI::Token::Operator        ','
  #         PPI::Structure::List        ( ... )
  #           PPI::Statement::Expression
  #             PPI::Token::Symbol      '$this'
  #             PPI::Token::Operator    ','
  #             PPI::Structure::List    ( ... )
  #               PPI::Statement::Expression
  #                 PPI::Token::Quote::Double   '" fun?\n"'
  #             PPI::Token::Operator    ','
  #         PPI::Token::Word    'if'
  #         PPI::Token::Quote::Double   '"It isn't Monday.\n"'
  #         PPI::Token::Structure       ';'
  #
  # We're starting with the Word containing 'die' (it could just as well be
  # 'warn') because the earlier parts of validate() have taken care of any
  # other possibility.  We're going to scan forward through 'die's siblings
  # until we reach what we think the end of its parameters are. So we get
  #
  #     1. A Literal. A perfectly good argument.
  #     2. A comma operator. Looks like we've got more to go.
  #     3. A List. Another argument.
  #     4. The Word 'if'.  Oops.  That's a postfix operator.
  #
  # Thus, the last parameter is the List.  So, we've got to scan backwards
  # through the components of the List; again, the goal is to find the last
  # value in the flattened list.
  #
  # Before decending into the List, we check that it isn't a subroutine call by
  # looking at its prior sibling.  In this case, the prior sibling is a comma
  # operator, so it's fine.
  #
  # The List has one Expression element as we expect.  We grab the Expression's
  # last child and start all over again.
  #
  #     1. The last child is a comma operator, which Perl will ignore, so we
  #        skip it.
  #     2. The comma's prior sibling is a List.  This is the last significant
  #        part of the outer list.
  #     3. The List's prior sibling isn't a Word, so we can continue because the
  #        List is not a parameter list.
  #     4. We go through the child Expression and find that the last child of
  #        that is a PPI::Token::Quote::Double, which is a simple, non-compound
  #        token.  We return that and we're done.
  
  sub _find_last_flattened_argument_list_element {
      my $die_or_warn = shift;
  
      # Zoom forward...
      my $current_candidate =
          _find_last_element_in_subexpression($die_or_warn);
  
      # ... scan back.
      while (
              $current_candidate
          and not _is_simple_list_element_token( $current_candidate )
          and not _is_complex_expression_token( $current_candidate )
      ) {
          if ( $current_candidate->isa('PPI::Structure::List') ) {
              $current_candidate =
                  _determine_if_list_is_a_plain_list_and_get_last_child(
                      $current_candidate,
                      $die_or_warn
                  );
          } elsif ( not $current_candidate->isa('PPI::Token') ) {
              return;
          } else {
              $current_candidate = $current_candidate->sprevious_sibling();
          }
      }
  
      return if not $current_candidate;
      return if _is_complex_expression_token( $current_candidate );
  
      my $penultimate_element = $current_candidate->sprevious_sibling();
      if ($penultimate_element) {
          # Bail if we've got a Word in front of the Element that isn't
          # the original 'die' or 'warn' or anything else that isn't
          # a comma or dot operator.
          if ( $penultimate_element->isa('PPI::Token::Operator') ) {
              if (
                      $penultimate_element ne $COMMA
                  and $penultimate_element ne $PERIOD
              ) {
                  return;
              }
          } elsif ( $penultimate_element != $die_or_warn ) {
              return
          }
      }
  
      return $current_candidate;
  }
  
  #-----------------------------------------------------------------------------
  # This is the part where we scan forward from the 'die' or 'warn' to find
  # the last argument.
  
  sub _find_last_element_in_subexpression {
      my $die_or_warn = shift;
  
      my $last_following_sibling;
      my $next_sibling = $die_or_warn;
      while (
              $next_sibling = $next_sibling->snext_sibling()
          and not _is_postfix_operator( $next_sibling )
      ) {
          $last_following_sibling = $next_sibling;
      }
  
      return $last_following_sibling;
  }
  
  #-----------------------------------------------------------------------------
  # Ensure that the list isn't a parameter list.  Find the last element of it.
  
  sub _determine_if_list_is_a_plain_list_and_get_last_child {
      my ($list, $die_or_warn) = @_;
  
      my $prior_sibling = $list->sprevious_sibling();
  
      if ( $prior_sibling ) {
          # Bail if we've got a Word in front of the List that isn't
          # the original 'die' or 'warn' or anything else that isn't
          # a comma operator.
          if ( $prior_sibling->isa('PPI::Token::Operator') ) {
              if ( $prior_sibling ne $COMMA ) {
                  return;
              }
          } elsif ( $prior_sibling != $die_or_warn ) {
              return
          }
      }
  
      my @list_children = $list->schildren();
  
      # If zero children, nothing to look for.
      # If multiple children, then PPI is not giving us
      # anything we understand.
      return if scalar (@list_children) != 1;
  
      my $list_child = $list_children[0];
  
      # If the child isn't an Expression or it is some other subclass
      # of Statement, we again don't understand PPI's output.
      return if not is_ppi_expression_or_generic_statement($list_child);
  
      my @statement_children = $list_child->schildren();
      return if scalar (@statement_children) < 1;
  
      return $statement_children[-1];
  }
  
  
  #-----------------------------------------------------------------------------
  Readonly::Hash my %POSTFIX_OPERATORS =>
      hashify qw{ if unless while until for foreach };
  
  sub _is_postfix_operator {
      my $element = shift;
  
      if (
              $element->isa('PPI::Token::Word')
          and $POSTFIX_OPERATORS{$element}
      ) {
          return $TRUE;
      }
  
      return $FALSE;
  }
  
  
  Readonly::Array my @SIMPLE_LIST_ELEMENT_TOKEN_CLASSES =>
      qw{
          PPI::Token::Number
          PPI::Token::Word
          PPI::Token::DashedWord
          PPI::Token::Symbol
          PPI::Token::Quote
          PPI::Token::HereDoc
      };
  
  sub _is_simple_list_element_token {
      my $element = shift;
  
      return $FALSE if not $element->isa('PPI::Token');
  
      foreach my $class (@SIMPLE_LIST_ELEMENT_TOKEN_CLASSES) {
          return $TRUE if $element->isa($class);
      }
  
      return $FALSE;
  }
  
  
  #-----------------------------------------------------------------------------
  # Tokens that can't possibly be part of an expression simple
  # enough for us to examine.
  
  Readonly::Array my @COMPLEX_EXPRESSION_TOKEN_CLASSES =>
      qw{
          PPI::Token::ArrayIndex
          PPI::Token::QuoteLike
          PPI::Token::Regexp
          PPI::Token::Cast
          PPI::Token::Label
          PPI::Token::Separator
          PPI::Token::Data
          PPI::Token::End
          PPI::Token::Prototype
          PPI::Token::Attribute
          PPI::Token::Unknown
      };
  
  sub _is_complex_expression_token {
      my $element = shift;
  
      return $FALSE if not $element->isa('PPI::Token');
  
      foreach my $class (@COMPLEX_EXPRESSION_TOKEN_CLASSES) {
          return $TRUE if $element->isa($class);
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  # Check whether the given element is contained in a subroutine.
  
  sub _is_element_contained_in_subroutine {
      my ( $self, $elem ) = @_;
  
      my $parent = $elem;
      while ( $parent = $parent->parent() ) {
          $parent->isa( 'PPI::Statement::Sub' ) and return $TRUE;
          $parent->isa( 'PPI::Structure::Block' ) or next;
          my $prior_elem = $parent->sprevious_sibling() or next;
          $prior_elem->isa( 'PPI::Token::Word' )
              and 'sub' eq $prior_elem->content()
              and return $TRUE;
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  # Check whether the given element is in main::
  
  sub _is_element_in_namespace_main {
      my ( $self, $elem ) = @_;
      my $current_elem = $elem;
      my $prior_elem;
  
      while ( $current_elem ) {
          while ( $prior_elem = $current_elem->sprevious_sibling() ) {
              if ( $prior_elem->isa( 'PPI::Statement::Package' ) ) {
                  return 'main' eq $prior_elem->namespace();
              }
          } continue {
              $current_elem = $prior_elem;
          }
          $current_elem = $current_elem->parent();
      }
  
      return $TRUE;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ErrorHandling::RequireCarping - Use functions from L<Carp|Carp> instead of C<warn> or C<die>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The C<die> and C<warn> functions both report the file and line number
  where the exception occurred.  But if someone else is using your
  subroutine, they usually don't care where B<your> code blew up.
  Instead, they want to know where B<their> code invoked the subroutine.
  The L<Carp|Carp> module provides alternative methods that report the
  exception from the caller's file and line number.
  
  By default, this policy will not complain about C<die> or C<warn>, if
  it can determine that the message will always result in a terminal
  newline.  Since perl suppresses file names and line numbers in this
  situation, it is assumed that no stack traces are desired either and
  none of the L<Carp|Carp> functions are necessary.
  
      die "oops" if $explosion;             #not ok
      warn "Where? Where?!" if $tiger;      #not ok
  
      open my $mouth, '<', 'food'
          or die 'of starvation';           #not ok
  
      if (! $dentist_appointment) {
          warn "You have bad breath!\n";    #ok
      }
  
      die "$clock not set.\n" if $no_time;  #ok
  
      my $message = "$clock not set.\n";
      die $message if $no_time;             #not ok, not obvious
  
  
  =head1 CONFIGURATION
  
  By default, this policy allows uses of C<die> and C<warn> ending in an
  explicit newline. If you give this policy an
  C<allow_messages_ending_with_newlines> option in your F<.perlcriticrc>
  with a false value, then this policy will prohibit such uses.
  
      [ErrorHandling::RequireCarping]
      allow_messages_ending_with_newlines = 0
  
  If you give this policy an C<allow_in_main_unless_in_subroutine> option
  in your F<.perlcriticrc> with a true value, then this policy will allow
  C<die> and C<warn> in name space main:: unless they appear in a
  subroutine, even if they do not end in an explicit newline.
  
      [ErrorHandling::RequireCarping]
      allow_in_main_unless_in_subroutine = 1
  
  =head1 BUGS
  
  Should allow C<die> when it is obvious that the "message" is a reference.
  
  
  =head1 SEE ALSO
  
  L<Carp::Always|Carp::Always>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECARPING

$fatpacked{"Perl/Critic/Policy/ErrorHandling/RequireCheckingReturnValueOfEval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECHECKINGRETURNVALUEOFEVAL';
  package Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Scalar::Util qw< refaddr >;
  
  use Perl::Critic::Utils qw< :booleans :characters :severities hashify
      precedence_of >;
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => 'Return value of eval not tested.';
  ## no critic (RequireInterpolationOfMetachars)
  Readonly::Scalar my $EXPL =>
      q<You can't depend upon the value of $@/$EVAL_ERROR to tell whether an eval failed.>;
  ## use critic
  
  Readonly::Hash my %BOOLEAN_OPERATORS => hashify qw< || && // or and >;
  Readonly::Hash my %POSTFIX_OPERATORS =>
      hashify qw< for foreach if unless while until >;
  
  Readonly::Scalar my $PRECEDENCE_OF_EQUALS => precedence_of( q{=} );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                 }
  sub default_severity     { return $SEVERITY_MEDIUM   }
  sub default_themes       { return qw( core bugs )    }
  sub applies_to           { return 'PPI::Token::Word' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'eval';
  
      my $evaluated = $elem->snext_sibling() or return; # Nothing to eval!
      my $following = $evaluated->snext_sibling();
  
      return if _is_in_right_hand_side_of_assignment($elem);
      return if _is_in_postfix_expression($elem);
      return if
          _is_in_correct_position_in_a_condition_or_foreach_loop_collection(
              $elem,
              $following,
          );
  
      return if _scan_backwards_for_grep( $elem );    # RT 69489
  
      if ( $following and $following->isa('PPI::Token::Operator') ) {
          return if $BOOLEAN_OPERATORS{ $following->content() };
          return if q{?} eq $following->content;
      }
  
      return $self->violation($DESC, $EXPL, $elem);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_in_right_hand_side_of_assignment {
      my ($elem) = @_;
  
      my $previous = $elem->sprevious_sibling();
  
      if (not $previous) {
          $previous =
              _grandparent_for_is_in_right_hand_side_of_assignment($elem);
      }
  
      while ($previous) {
          my $base_previous = $previous;
  
          EQUALS_SCAN:
          while ($previous) {
              if ( $previous->isa('PPI::Token::Operator') ) {
                  return $TRUE if $previous->content() =~ m/= \Z/xms;
                  last EQUALS_SCAN if _is_effectively_a_comma($previous);
              }
              $previous = $previous->sprevious_sibling();
          }
  
          $previous =
              _grandparent_for_is_in_right_hand_side_of_assignment($base_previous);
      }
  
      return;
  }
  
  sub _grandparent_for_is_in_right_hand_side_of_assignment {
      my ($elem) = @_;
  
      my $parent = $elem->parent() or return;
      $parent->isa('PPI::Statement') or return;
  
      my $grandparent = $parent->parent() or return;
  
      if (
              $grandparent->isa('PPI::Structure::Constructor')
          or  $grandparent->isa('PPI::Structure::List')
      ) {
          return $grandparent;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $CONDITION_POSITION_IN_C_STYLE_FOR_LOOP => 1;
  
  sub _is_in_correct_position_in_a_condition_or_foreach_loop_collection {
      my ($elem, $following) = @_;
  
      my $parent = $elem->parent();
      while ($parent) {
          if ( $parent->isa('PPI::Structure::Condition') ) {
              return
                  _is_in_correct_position_in_a_structure_condition(
                      $elem, $parent, $following,
                  );
          }
  
          # TECHNICAL DEBT: This code is basically shared with
          # ProhibitUnusedCapture.  I don't want to put this code
          # into Perl::Critic::Utils::*, but I don't have time to sort out
          # PPIx::Utilities::Structure::List yet.
          if (
                  $parent->isa('PPI::Structure::List')
              and my $parent_statement = $parent->statement()
          ) {
              return $TRUE if
                      $parent_statement->isa('PPI::Statement::Compound')
                  and $parent_statement->type() eq 'foreach';
          }
  
          if ( $parent->isa('PPI::Structure::For') ) {
              my @for_loop_components = $parent->schildren();
  
              my $condition =
                  $for_loop_components[$CONDITION_POSITION_IN_C_STYLE_FOR_LOOP]
                  or return;
  
              return _descendant_of($elem, $condition);
          }
  
          $parent = $parent->parent();
      }
  
      return;
  }
  
  sub _is_in_correct_position_in_a_structure_condition {
      my ($elem, $parent, $following) = @_;
  
      my $level = $elem;
      while ($level and refaddr $level != $parent) {
          my $cursor = refaddr $elem == refaddr $level ? $following : $level;
  
          IS_FINAL_EXPRESSION_AT_DEPTH:
          while ($cursor) {
              if ( _is_effectively_a_comma($cursor) ) {
                  $cursor = $cursor->snext_sibling();
                  while ( _is_effectively_a_comma($cursor) ) {
                      $cursor = $cursor->snext_sibling();
                  }
  
                  # Semicolon would be a syntax error here.
                  return if $cursor;
                  last IS_FINAL_EXPRESSION_AT_DEPTH;
              }
  
              $cursor = $cursor->snext_sibling();
          }
  
          my $statement = $level->parent();
          return $TRUE if not $statement; # Shouldn't happen.
          return $TRUE if not $statement->isa('PPI::Statement'); # Shouldn't happen.
  
          $level = $statement->parent();
          if (
                  not $level
              or  (
                      not $level->isa('PPI::Structure::List')
                  and not $level->isa('PPI::Structure::Condition')
              )
          ) {
              # Shouldn't happen.
              return $TRUE;
          }
      }
  
      return $TRUE;
  }
  
  # Replace with PPI implementation once it is released.
  sub _descendant_of {
      my ($cursor, $potential_ancestor) = @_;
  
      return $EMPTY if not $potential_ancestor;
  
      while ( refaddr $cursor != refaddr $potential_ancestor ) {
          $cursor = $cursor->parent() or return $EMPTY;
      }
  
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_in_postfix_expression {
      my ($elem) = @_;
  
      my $current_base = $elem;
      while ($TRUE) {
          my $previous = $current_base->sprevious_sibling();
          while ($previous) {
              if (
                      $previous->isa('PPI::Token::Word')
                  and $POSTFIX_OPERATORS{ $previous->content() }
              ) {
                  return $TRUE
              }
              $previous = $previous->sprevious_sibling();
          } # end while
  
          my $parent = $current_base->parent() or return;
          if ( $parent->isa('PPI::Statement') ) {
              return if $parent->specialized();
  
              my $grandparent = $parent->parent() or return;
              return if not $grandparent->isa('PPI::Structure::List');
  
              $current_base = $grandparent;
          } else {
              $current_base = $parent;
          }
  
          return if not $current_base->isa('PPI::Structure::List');
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _scan_backwards_for_grep {
      my ( $elem ) = @_;
  
      while ( $elem ) {
  
          my $parent = $elem->parent();
  
          while ( $elem = $elem->sprevious_sibling() ) {
              $elem->isa( 'PPI::Token::Word' )
                  and 'grep' eq $elem->content()
                  and return $TRUE;
              $elem->isa( 'PPI::Token::Operator' )
                  and precedence_of( $elem ) >= $PRECEDENCE_OF_EQUALS
                  and return $FALSE;
          }
  
          $elem = $parent;
      }
  
      return $FALSE;
  
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_effectively_a_comma {
      my ($elem) = @_;
  
      return if not $elem;
  
      return
              $elem->isa('PPI::Token::Operator')
          &&  (
                  $elem->content() eq $COMMA
              ||  $elem->content() eq $FATCOMMA
          );
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords destructors
  
  =head1 NAME
  
  Perl::Critic::Policy::ErrorHandling::RequireCheckingReturnValueOfEval - You can't depend upon the value of C<$@>/C<$EVAL_ERROR> to tell whether an C<eval> failed.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  A common idiom in perl for dealing with possible errors is to use
  C<eval> followed by a check of C<$@>/C<$EVAL_ERROR>:
  
      eval {
          ...
      };
      if ($EVAL_ERROR) {
          ...
      }
  
  There's a problem with this: the value of C<$EVAL_ERROR> can change
  between the end of the C<eval> and the C<if> statement.  The issue is
  object destructors:
  
      package Foo;
  
      ...
  
      sub DESTROY {
          ...
          eval { ... };
          ...
      }
  
      package main;
  
      eval {
          my $foo = Foo->new();
          ...
      };
      if ($EVAL_ERROR) {
          ...
      }
  
  Assuming there are no other references to C<$foo> created, when the
  C<eval> block in C<main> is exited, C<Foo::DESTROY()> will be invoked,
  regardless of whether the C<eval> finished normally or not.  If the
  C<eval> in C<main> fails, but the C<eval> in C<Foo::DESTROY()>
  succeeds, then C<$EVAL_ERROR> will be empty by the time that the C<if>
  is executed.  Additional issues arise if you depend upon the exact
  contents of C<$EVAL_ERROR> and both C<eval>s fail, because the
  messages from both will be concatenated.
  
  Even if there isn't an C<eval> directly in the C<DESTROY()> method
  code, it may invoke code that does use C<eval> or otherwise affects
  C<$EVAL_ERROR>.
  
  The solution is to ensure that, upon normal exit, an C<eval> returns a
  true value and to test that value:
  
      # Constructors are no problem.
      my $object = eval { Class->new() };
  
      # To cover the possiblity that an operation may correctly return a
      # false value, end the block with "1":
      if ( eval { something(); 1 } ) {
          ...
      }
  
      eval {
          ...
          1;
      }
          or do {
              # Error handling here
          };
  
  Unfortunately, you can't use the C<defined> function to test the
  result; C<eval> returns an empty string on failure.
  
  Various modules have been written to take some of the pain out of
  properly localizing and checking C<$@>/C<$EVAL_ERROR>. For example:
  
      use Try::Tiny;
      try {
          ...
      } catch {
          # Error handling here;
          # The exception is in $_/$ARG, not $@/$EVAL_ERROR.
      };  # Note semicolon.
  
  "But we don't use DESTROY() anywhere in our code!" you say.  That may
  be the case, but do any of the third-party modules you use have them?
  What about any you may use in the future or updated versions of the
  ones you already use?
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  See thread on perl5-porters starting here:
  L<http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2008-06/msg00537.html>.
  
  For a nice, easy, non-magical way of properly handling exceptions, see
  L<Try::Tiny|Try::Tiny>.
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_ERRORHANDLING_REQUIRECHECKINGRETURNVALUEOFEVAL

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitBacktickOperators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBACKTICKOPERATORS';
  package Perl::Critic::Policy::InputOutput::ProhibitBacktickOperators;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities is_in_void_context };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Use IPC::Open3 instead};
  Readonly::Scalar my $DESC => q{Backtick operator used};
  
  Readonly::Scalar my $VOID_EXPL => q{Assign result to a variable or use system() instead};
  Readonly::Scalar my $VOID_DESC => q{Backtick operator used in void context};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name        => 'only_in_void_context',
              description => 'Allow backticks everywhere except in void contexts.',
              behavior    => 'boolean',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM }
  sub default_themes   { return qw(core maintenance)   }
  sub applies_to       { return qw(PPI::Token::QuoteLike::Backtick
                                   PPI::Token::QuoteLike::Command ) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $self->{_only_in_void_context} ) {
          return if not is_in_void_context( $elem );
  
          return $self->violation( $VOID_DESC, $VOID_EXPL, $elem );
      }
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords perlipc
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitBacktickOperators - Discourage stuff like C<@files = `ls $directory`>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Backticks are super-convenient, especially for CGI programs, but I
  find that they make a lot of noise by filling up STDERR with messages
  when they fail.  I think its better to use IPC::Open3 to trap all the
  output and let the application decide what to do with it.
  
      use IPC::Open3 'open3';
      $SIG{CHLD} = 'IGNORE';
  
      @output = `some_command`;                      #not ok
  
      my ($writer, $reader, $err);
      open3($writer, $reader, $err, 'some_command'); #ok;
      @output = <$reader>;  #Output here
      @errors = <$err>;     #Errors here, instead of the console
  
  
  =head1 CONFIGURATION
  
  Alternatively, if you do want to use backticks, you can restrict
  checks to void contexts by adding the following to your
  F<.perlcriticrc> file:
  
      [InputOutput::ProhibitBacktickOperators]
      only_in_void_context = 1
  
  The purpose of backticks is to capture the output of an external
  command.  Use of them in a void context is likely a bug.  If the
  output isn't actually required, C<system()> should be used.  Otherwise
  assign the result to a variable.
  
      `some_command`;                      #not ok
      $output = `some_command`;            #ok
      @output = `some_command`;            #ok
  
  
  =head1 NOTES
  
  This policy also prohibits the generalized form of backticks seen as
  C<qx{}>.
  
  See L<perlipc|perlipc> for more discussion on using C<wait()> instead
  of C<$SIG{CHLD} = 'IGNORE'>.
  
  You might consider using the C<capture()> function from the
  L<IPC::System::Simple|IPC::System::Simple> module for a safer way of
  doing what backticks do, especially on Windows.  The module also has a
  safe wrapper around C<system()>.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBACKTICKOPERATORS

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitBarewordFileHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBAREWORDFILEHANDLES';
  package Perl::Critic::Policy::InputOutput::ProhibitBarewordFileHandles;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Bareword file handle opened};
  Readonly::Scalar my $EXPL => [ 202, 204 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGHEST   }
  sub default_themes       { return qw( core pbp bugs certrec ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      return if $elem->content() ne 'open';
      return if ! is_function_call($elem);
  
      my $first_arg = ( parse_arg_list($elem) )[0];
      return if !$first_arg;
      my $first_token = $first_arg->[0];
      return if !$first_token;
  
      if ( $first_token->isa('PPI::Token::Word') ) {
          if ( ($first_token ne 'my') && ($first_token !~ m/^STD(?:IN|OUT|ERR)$/xms ) ) {
              return $self->violation( $DESC, $EXPL, $elem );
          }
      }
      return; #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitBarewordFileHandles - Write C<open my $fh, q{<}, $filename;> instead of C<open FH, q{<}, $filename;>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using bareword symbols to refer to file handles is particularly evil
  because they are global, and you have no idea if that symbol already
  points to some other file handle.  You can mitigate some of that risk
  by C<local>izing the symbol first, but that's pretty ugly.  Since Perl
  5.6, you can use an undefined scalar variable as a lexical reference
  to an anonymous filehandle.  Alternatively, see the
  L<IO::Handle|IO::Handle> or L<IO::File|IO::File> or
  L<FileHandle|FileHandle> modules for an object-oriented approach.
  
      open FH, '<', $some_file;           #not ok
      open my $fh, '<', $some_file;       #ok
      my $fh = IO::File->new($some_file); #ok
  
  There are three exceptions: STDIN, STDOUT and STDERR.  These three
  standard filehandles are always package variables.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<IO::Handle|IO::Handle>
  
  L<IO::File|IO::File>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITBAREWORDFILEHANDLES

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitExplicitStdin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITEXPLICITSTDIN';
  package Perl::Critic::Policy::InputOutput::ProhibitExplicitStdin;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{ :severities :classification &parse_arg_list };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use "<>" or "<ARGV>" or a prompting module instead of "<STDIN>"};
  Readonly::Scalar my $EXPL => [216,220,221];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                                }
  sub default_severity     { return $SEVERITY_HIGH                    }
  sub default_themes       { return qw( core pbp maintenance )        }
  sub applies_to           { return 'PPI::Token::QuoteLike::Readline' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem ne '<STDIN>';
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitExplicitStdin - Use "<>" or "<ARGV>" or a prompting module instead of "<STDIN>".
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl has a useful magic filehandle called C<*ARGV> that checks the
  command line and if there are any arguments, opens and reads those as
  files.  If there are no arguments, C<*ARGV> behaves like C<*STDIN>
  instead.  This behavior is almost always what you want if you want to
  create a program that reads from C<STDIN>.  This is often written in
  one of the following two equivalent forms:
  
    while (<ARGV>) {
      # ... do something with each input line ...
    }
    # or, equivalently:
    while (<>) {
      # ... do something with each input line ...
    }
  
  If you want to prompt for user input, try special purpose modules like
  L<IO::Prompt|IO::Prompt>.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CAVEATS
  
  Due to a bug in the current version of PPI (v1.119_03) and earlier,
  the readline operator is often misinterpreted as less-than and
  greater-than operators after a comma.  Therefore, this policy misses
  important cases like
  
    my $content = join '', <STDIN>;
  
  because it interprets that line as the nonsensical statement:
  
    my $content = join '', < STDIN >;
  
  When that PPI bug is fixed, this policy should start catching those
  violations automatically.
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITEXPLICITSTDIN

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitInteractiveTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITINTERACTIVETEST';
  package Perl::Critic::Policy::InputOutput::ProhibitInteractiveTest;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use IO::Interactive::is_interactive() instead of -t};
  Readonly::Scalar my $EXPL => [ 218 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_HIGHEST      }
  sub default_themes       { return qw( core pbp bugs certrule )    }
  sub applies_to           { return 'PPI::Token::Operator' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
      return if $elem->content() ne '-t';
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitInteractiveTest - Use prompt() instead of -t.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The C<-t> operator is fragile and complicated.  When you are testing
  whether C<STDIN> is interactive, It's much more robust to use
  well-tested CPAN modules like L<IO::Interactive|IO::Interactive>.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITINTERACTIVETEST

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitJoinedReadline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITJOINEDREADLINE';
  package Perl::Critic::Policy::InputOutput::ProhibitJoinedReadline;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{ :severities :classification parse_arg_list };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use "local $/ = undef" or Path::Tiny instead of joined readline}; ## no critic qw(InterpolationOfMetachars)
  Readonly::Scalar my $EXPL => [213];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core pbp performance ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'join';
      return if ! is_function_call($elem);
      my @args = parse_arg_list($elem);
      shift @args; # ignore separator string
  
      if (any { any { $_->isa('PPI::Token::QuoteLike::Readline') } @{$_} } @args) {
         return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return;  # OK
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitJoinedReadline - Use C<local $/ = undef> or L<Path::Tiny|Path::Tiny> instead of joined readline.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  It's really easy to slurp a whole filehandle in at once with C<join
  q{}, <$fh>>, but that's inefficient -- Perl goes to the trouble of
  splitting the file into lines only to have that work thrown away.
  
  To save performance, either slurp the filehandle without splitting
  like so:
  
    do { local $/ = undef; <$fh> }
  
  or use L<Path::Tiny|Path::Tiny>, which is even faster.
  
  B<Note> that if the C<ProhibitPunctuationVars> policy is also in effect,
  it will complain about the use of C<$/> in the line above.  In that
  case, write this instead:
  
    use English '-no_match_vars';
  
    do { local $INPUT_RECORD_SEPARATOR = undef; <$fh> };
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CAVEATS
  
  Due to a bug in the current version of PPI (v1.119_03) and earlier,
  the readline operator is often misinterpreted as less-than and
  greater-than operators after a comma.  Therefore, this policy only
  works well on the empty filehandle, C<< <> >>.  When PPI is fixed,
  this should just start working.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITJOINEDREADLINE

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitOneArgSelect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITONEARGSELECT';
  package Perl::Critic::Policy::InputOutput::ProhibitOneArgSelect;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{One-argument "select" used};
  Readonly::Scalar my $EXPL => [ 224 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core bugs pbp certrule ) }
  sub applies_to           { return 'PPI::Token::Word'  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      return if $elem->content() ne 'select';
      return if ! is_function_call($elem);
  
      my @arguments = parse_arg_list($elem);
      if( 1 == @arguments ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return; #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitOneArgSelect - Never write C<select($fh)>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages the use of a raw C<select()> when setting
  autoflushes.  We'll extend that further by simply prohibiting the
  one-argument form of C<select()> entirely; if you really need it you
  should know when/where/why that is.  For performing autoflushes,
  Conway recommends the use of C<IO::Handle> instead.
  
    select((select($fh), $|=1)[0]);     # not ok
    select $fh;                         # not ok
  
     use IO::Handle;
     $fh->autoflush();                   # ok
     *STDOUT->autoflush();               # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<IO::Handle|IO::Handle>.
  
  =head1 AUTHOR
  
  Graham TerMarsch <graham@howlingfrog.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Graham TerMarsch.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITONEARGSELECT

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitReadlineInForLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITREADLINEINFORLOOP';
  package Perl::Critic::Policy::InputOutput::ProhibitReadlineInForLoop;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::Util qw< first >;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Readline inside "for" loop};
  Readonly::Scalar my $EXPL => [ 211 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                             }
  sub default_severity     { return $SEVERITY_HIGH                 }
  sub default_themes       { return qw< core bugs pbp >            }
  sub applies_to           { return qw< PPI::Statement::Compound > }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->type() ne 'foreach';
  
      my $list = first { $_->isa('PPI::Structure::List') } $elem->schildren()
          or return;
  
      if (
          my $readline = $list->find_first('PPI::Token::QuoteLike::Readline')
      ) {
          return $self->violation( $DESC, $EXPL, $readline );
      }
  
      return;  #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitReadlineInForLoop - Write C<< while( $line = <> ){...} >> instead of C<< for(<>){...} >>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using the readline operator in a C<for> or C<foreach> loop is very
  slow.  The iteration list of the loop creates a list context, which
  causes the readline operator to read the entire input stream before
  iteration even starts.  Instead, just use a C<while> loop, which only
  reads one line at a time.
  
    for my $line ( <$file_handle> ){ do_something($line) }      #not ok
    while ( my $line = <$file_handle> ){ do_something($line) }  #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITREADLINEINFORLOOP

$fatpacked{"Perl/Critic/Policy/InputOutput/ProhibitTwoArgOpen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITTWOARGOPEN';
  package Perl::Critic::Policy::InputOutput::ProhibitTwoArgOpen;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use version;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $STDIO_HANDLES_RX => qr/\b STD (?: IN | OUT | ERR \b)/xms;
  Readonly::Scalar my $FORK_HANDLES_RX => qr/\A (?: -[|] | [|]- ) \z/xms;
  Readonly::Scalar my $DESC => q{Two-argument "open" used};
  Readonly::Scalar my $EXPL => [ 207 ];
  
  Readonly::Scalar my $MINIMUM_VERSION => version->new(5.006);
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGHEST          }
  sub default_themes       { return qw(core pbp bugs security certrule) }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $document) = @_;
  
      return if $elem->content() ne 'open';
      return if ! is_function_call($elem);
  
      my $version = $document->highest_explicit_perl_version();
      return if $version and $version < $MINIMUM_VERSION;
  
      my @args = parse_arg_list($elem);
  
      if ( scalar @args == 2 ) {
          # When opening STDIN, STDOUT, or STDERR, the
          # two-arg form is the only option you have.
          return if $args[1]->[0] =~ $STDIO_HANDLES_RX;
          return if $args[1]->[0]->isa( 'PPI::Token::Quote' )
                 && $args[1]->[0]->string() =~ $FORK_HANDLES_RX;
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return; # ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords perlipc
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::ProhibitTwoArgOpen - Write C<< open $fh, q{<}, $filename; >> instead of C<< open $fh, "<$filename"; >>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The three-argument form of C<open> (introduced in Perl 5.6) prevents
  subtle bugs that occur when the filename starts with funny characters
  like '>' or '<'.  The L<IO::File|IO::File> module provides a nice
  object-oriented interface to filehandles, which I think is more
  elegant anyway.
  
    open( $fh, '>output.txt' );          # not ok
    open( $fh, q{>}, 'output.txt' );     # ok
  
    use IO::File;
    my $fh = IO::File->new( 'output.txt', q{>} ); # even better!
  
  It's also more explicitly clear to define the input mode of the file,
  as in the difference between these two:
  
    open( $fh, 'foo.txt' );       # BAD: Reader must think what default mode is
    open( $fh, '<', 'foo.txt' );  # GOOD: Reader can see open mode
  
  This policy will not complain if the file explicitly states that it is
  compatible with a version of perl prior to 5.6 via an include
  statement, e.g. by having C<require 5.005> in it.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  There are two cases in which you are forced to use the two-argument form of
  open. When re-opening STDIN, STDOUT, or STDERR, and when doing a safe pipe
  open, as described in L<perlipc|perlipc>.
  
  =head1 SEE ALSO
  
  L<IO::Handle|IO::Handle>
  
  L<IO::File|IO::File>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_PROHIBITTWOARGOPEN

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireBracedFileHandleWithPrint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRACEDFILEHANDLEWITHPRINT';
  package Perl::Critic::Policy::InputOutput::RequireBracedFileHandleWithPrint;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array my @POSTFIX_WORDS => qw( if unless for );
  Readonly::Hash my %POSTFIX_WORDS => hashify( @POSTFIX_WORDS );
  Readonly::Scalar my $PRINT_RX  => qr/ \A (?: print f? | say ) \z /xms;
  
  Readonly::Scalar my $DESC => q{File handle for "print" or "printf" is not braced};
  Readonly::Scalar my $EXPL => [ 217 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                      }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp cosmetic ) }
  sub applies_to           { return 'PPI::Token::Word'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem !~ $PRINT_RX;
      return if ! is_function_call($elem);
  
      my @sib;
  
      $sib[0] = $elem->snext_sibling();
      return if !$sib[0];
  
      # Deal with situations where 'print' is called with parentheses
      if ( $sib[0]->isa('PPI::Structure::List') ) {
          my $expr = $sib[0]->schild(0);
          return if !$expr;
          $sib[0] = $expr->schild(0);
          return if !$sib[0];
      }
  
      $sib[1] = $sib[0]->next_sibling();
      return if !$sib[1];
      $sib[2] = $sib[1]->next_sibling();
      return if !$sib[2];
  
      # First token must be a scalar symbol or bareword;
      return if !( ($sib[0]->isa('PPI::Token::Symbol') && $sib[0] =~ m/\A \$/xms)
                   || $sib[0]->isa('PPI::Token::Word') );
  
      # First token must not be a builtin function or control
      return if is_perl_builtin($sib[0]);
      return if exists $POSTFIX_WORDS{ $sib[0] };
  
      # Second token must be white space
      return if !$sib[1]->isa('PPI::Token::Whitespace');
  
      # Third token must not be an operator
      return if $sib[2]->isa('PPI::Token::Operator');
  
      # Special case for postfix controls
      return if exists $POSTFIX_WORDS{ $sib[2] };
  
      return if $sib[0]->isa('PPI::Structure::Block');
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::RequireBracedFileHandleWithPrint - Write C<print {$FH} $foo, $bar;> instead of C<print $FH $foo, $bar;>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The C<print> and C<printf> functions have a unique syntax that
  supports an optional file handle argument.  Conway suggests wrapping
  this argument in braces to make it visually stand out from the other
  arguments.  When you put braces around any of the special
  package-level file handles like C<STDOUT>, C<STDERR>, and C<DATA>, you
  must the C<'*'> sigil or else it won't compile under C<use strict
  'subs'>.
  
    print $FH   "Mary had a little lamb\n";  #not ok
    print {$FH} "Mary had a little lamb\n";  #ok
  
    print   STDERR   $foo, $bar, $baz;  #not ok
    print  {STDERR}  $foo, $bar, $baz;  #won't compile under 'strict'
    print {*STDERR}  $foo, $bar, $baz;  #perfect!
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRACEDFILEHANDLEWITHPRINT

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireBriefOpen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRIEFOPEN';
  package Perl::Critic::Policy::InputOutput::RequireBriefOpen;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{ :severities :classification :booleans
      hashify parse_arg_list
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Close filehandles as soon as possible after opening them..>;
  Readonly::Scalar my $EXPL => [209];
  
  Readonly::Scalar my $SCALAR_SIGIL => q<$>;
  Readonly::Scalar my $GLOB_SIGIL   => q<*>;
  
  # Identify the builtins that are equivalent to 'open' and 'close'. Note that
  # 'return' is considered equivalent to 'close'.
  Readonly::Hash my %CLOSE_BUILTIN => hashify( qw{
      close
      CORE::close
      CORE::GLOBAL::close
      return
  } );
  Readonly::Hash my %OPEN_BUILTIN => hashify( qw{
      open
      CORE::open
      CORE::GLOBAL::open
  } );
  
  # Possible values for $is_lexical
  Readonly::Scalar my $NOT_LEXICAL => 0;  # Guaranteed only false value
  Readonly::Scalar my $LOCAL_LEXICAL => 1;
  Readonly::Scalar my $NON_LOCAL_LEXICAL => 2;
  
  Readonly::Scalar my $LAST_ELEMENT => -1;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'lines',
              description     => 'The maximum number of lines between an open() and a close().',
              default_string  => '9',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw< core pbp maintenance > }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # Is it a call to open?
      $OPEN_BUILTIN{$elem->content()} or return;
      return if ! is_function_call($elem);
      my @open_args = parse_arg_list($elem);
      return if 2 > @open_args; # not a valid call to open()
  
      my ($is_lexical, $fh) = _get_opened_fh($open_args[0]);
      return if not $fh;
      return if $fh =~ m< \A [*]? STD (?: IN|OUT|ERR ) \z >xms;
  
      for my $close_token ( $self->_find_close_invocations_or_return(
              $elem, $is_lexical ) ) {
          # The $close_token might be a close() or a return()
          #  It doesn't matter which -- both satisfy this policy
          if (is_function_call($close_token)) {
              my @close_args = parse_arg_list($close_token);
  
              my $close_parameter = $close_args[0];
              if ('ARRAY' eq ref $close_parameter) {
                  $close_parameter = ${$close_parameter}[0];
              }
              if ( $close_parameter ) {
                  $close_parameter = "$close_parameter";
                  return if $fh eq $close_parameter;
  
                  if ( any { m< \A [*] >xms } ($fh, $close_parameter) ) {
                      (my $stripped_fh = $fh) =~ s< \A [*] ><>xms;
                      (my $stripped_parameter = $close_parameter) =~
                          s< \A [*] ><>xms;
  
                      return if $stripped_fh eq $stripped_parameter;
                  }
              }
          }
          elsif ($is_lexical && is_method_call($close_token)) {
              my $tok = $close_token->sprevious_sibling->sprevious_sibling;
              return if $fh eq $tok;
          }
      }
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  sub _find_close_invocations_or_return {
      my ($self, $elem, $is_lexical) = @_;
  
      my $parent = $self->_get_scope( $elem, $is_lexical );
      return if !$parent; # I can't think of a scenario where this would happen
  
      my $open_loc = $elem->location;
      # we don't actually allow _lines to be zero or undef, but maybe we will
      my $end_line = $self->{_lines} ? $open_loc->[0] + $self->{_lines} : undef;
  
      my $closes = $parent->find(sub {
          ##no critic (ProhibitExplicitReturnUndef)
          my ($parent, $candidate) = @_;  ## no critic(Variables::ProhibitReusedNames)
          return undef if $candidate->isa('PPI::Statement::Sub');
          my $candidate_loc = $candidate->location;
          return undef if !defined $candidate_loc->[0];
          return 0 if $candidate_loc->[0] < $open_loc->[0];
          return 0 if $candidate_loc->[0] == $open_loc->[0] && $candidate_loc->[1] <= $open_loc->[1];
          return undef if defined $end_line && $candidate_loc->[0] > $end_line;
          return 0 if !$candidate->isa('PPI::Token::Word');
          return $CLOSE_BUILTIN{ $candidate->content() } || 0;
      });
      return @{$closes || []};
  }
  
  sub _get_scope {
      my ( $self, $elem, $is_lexical ) = @_;
  
      my $open_loc = $elem->location;
      my $end_line = ( $self->{_lines} && defined $open_loc->[0] ) ?
          $open_loc->[0] + $self->{_lines} :
          undef;
  
      while ( my $dad = $elem->parent) {
          $elem = $dad;
          next if not $elem->scope;
  
          # If we are analyzing something like 'open my $fh ...', the
          # most-local scope suffices. RT #64437
          return $elem if $LOCAL_LEXICAL == $is_lexical;
          next if not defined $end_line;  # Presume search everywhere
  
          # If we are analyzing something like 'open $fh ...', 'open FH
          # ...', or 'open *FH ...' we need to use a scope that includes
          # the end of the legal range. We just give up and return the
          # current scope if we can not determine any of the locations
          # involved. RT #64437
          return $elem if not $open_loc;
          my $elem_loc = $elem->location
              or return $elem;
          my $last_kid = $elem->child( $LAST_ELEMENT )
              or return $elem;    # What? no children?
          my $last_kid_loc = $last_kid->location
              or return $elem;
          # At this point, the scope we have, even if it is not the
          # correct scope for the file handle, is big enough that if the
          # corresponding close() is outside it, it must be a violation.
          # RT #64437
          return $elem if $last_kid_loc->[0] > $end_line;
      }
      return $elem;   # Whatever the top-level PPI::Node was.
  }
  
  sub _get_opened_fh {
      my ($tokens) = shift;
  
      my $is_lexical;
      my $fh;
  
      if ( 2 == @{$tokens} ) {
          if ('my' eq $tokens->[0] &&
              $tokens->[1]->isa('PPI::Token::Symbol') &&
              $SCALAR_SIGIL eq $tokens->[1]->raw_type) {
  
              $is_lexical = $LOCAL_LEXICAL;
              $fh = $tokens->[1];
          }
      }
      elsif (1 == @{$tokens}) {
          my $argument = _unwrap_block( $tokens->[0] );
          if ( $argument->isa('PPI::Token::Symbol') ) {
              my $sigil = $argument->raw_type();
              if ($SCALAR_SIGIL eq $sigil) {
                  $is_lexical = $NON_LOCAL_LEXICAL;   # We need to
                                              # distinguish between
                                              # 'open my $fh ...' and
                                              # 'open $fh ...'. RT #64437
                  $fh = $argument;
              }
              elsif ($GLOB_SIGIL eq $sigil) {
                  $is_lexical = $NOT_LEXICAL;
                  $fh = $argument;
              }
          }
          elsif ($argument->isa('PPI::Token::Word') && $argument eq uc $argument) {
              $is_lexical = $NOT_LEXICAL;
              $fh = $argument;
          }
      }
  
      return ($is_lexical, $fh);
  }
  
  sub _unwrap_block {
      my ($element) = @_;
  
      return $element if not $element->isa('PPI::Structure::Block');
  
      my @children = $element->schildren();
      return $element if 1 != @children;
      my $child = $children[0];
  
      return $child if not $child->isa('PPI::Statement');
  
      my @grandchildren = $child->schildren();
      return $element if 1 != @grandchildren;
  
      return $grandchildren[0];
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords redeclared
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::RequireBriefOpen - Close filehandles as soon as possible after opening them.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  One way that production systems fail unexpectedly is by running out of
  filehandles.  Filehandles are a finite resource on every operating
  system that I'm aware of, and running out of them is virtually
  impossible to recover from.  The solution is to not run out in the
  first place.  What causes programs to run out of filehandles?
  Usually, it's leaks: you open a filehandle and forget to close it, or
  just wait a really long time before closing it.
  
  This problem is rarely exposed by test systems, because the tests
  rarely run long enough or have enough load to hit the filehandle
  limit.  So, the best way to avoid the problem is 1) always close all
  filehandles that you open and 2) close them as soon as is practical.
  
  This policy takes note of calls to C<open()> where there is no
  matching C<close()> call within C<N> lines of code.  If you really
  need to do a lot of processing on an open filehandle, then you can
  move that processing to another method like this:
  
      sub process_data_file {
          my ($self, $filename) = @_;
          open my $fh, '<', $filename
              or croak 'Failed to read datafile ' .  $filename . '; ' . $OS_ERROR;
          $self->_parse_input_data($fh);
          close $fh;
          return;
      }
      sub _parse_input_data {
          my ($self, $fh) = @_;
          while (my $line = <$fh>) {
              ...
          }
          return;
      }
  
  As a special case, this policy also allows code to return the
  filehandle after the C<open> instead of closing it.  Just like the
  close, however, that C<return> has to be within the right number of
  lines.  From there, you're on your own to figure out whether the code
  is promptly closing the filehandle.
  
  The STDIN, STDOUT, and STDERR handles are exempt from this policy.
  
  
  =head1 CONFIGURATION
  
  This policy allows C<close()> invocations to be up to C<N> lines after
  their corresponding C<open()> calls, where C<N> defaults to 9.  You
  can override this to set it to a different number with the C<lines>
  setting.  To do this, put entries in a F<.perlcriticrc> file like
  this:
  
    [InputOutput::RequireBriefOpen]
    lines = 5
  
  
  =head1 CAVEATS
  
  =head2 C<IO::File-E<gt>new>
  
  This policy only looks for explicit C<open> calls.  It does not detect
  calls to C<CORE::open> or C<IO::File-E<gt>new> or the like.
  
  
  =head2 Is it the right lexical?
  
  We don't currently check for redeclared filehandles.  So the following
  code is false negative, for example, because the outer scoped
  filehandle is not closed:
  
      open my $fh, '<', $file1 or croak;
      if (open my $fh, '<', $file2) {
          print <$fh>;
          close $fh;
      }
  
  This is a contrived example, but it isn't uncommon for people to use
  C<$fh> for the name of the filehandle every time.  Perhaps it's time
  to think of better variable names...
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREBRIEFOPEN

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireCheckedClose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDCLOSE';
  package Perl::Critic::Policy::InputOutput::RequireCheckedClose;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Return value of "close" ignored};
  Readonly::Scalar my $EXPL => q{Check the return value of "close" for success};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'autodie_modules',
              description     => 'Modules which export autodie.',
              default_string  => 'autodie',
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_LOW          }
  sub default_themes       { return qw( core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'close';
      return if ! is_unchecked_call( $elem, [ keys %{ $self->{_autodie_modules} } ] );
  
      return $self->violation( $DESC, $EXPL, $elem );
  
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords autodie
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::RequireCheckedClose - Write C<< my $error = close $fh; >> instead of C<< close $fh; >>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The perl builtin I/O function C<close> returns a false value on
  failure. That value should be checked to ensure that the close was
  successful.
  
  
      my $error = close $filehandle;                   # ok
      close $filehandle or die "unable to close: $!";  # ok
      close $filehandle;                               # not ok
  
      use autodie qw< :io >;
      close $filehandle;                               # ok
  
  You can use L<autodie|autodie>, L<Fatal|Fatal>, or
  L<Fatal::Exception|Fatal::Exception> to get around
  this.  Currently, L<autodie|autodie> is not properly treated as a pragma; its
  lexical effects aren't taken into account.
  
  
  =head1 CONFIGURATION
  
  If you create a module that exports C<autodie> you can tell this policy about
  it with the C<autodie_modules> setting:
  
      [InputOutput::RequireCheckedSyscalls]
      autodie_modules = My::Thing
  
  
  =head1 AUTHOR
  
  Andrew Moore <amoore@mooresystems.com>
  
  =head1 ACKNOWLEDGMENTS
  
  This policy module is based heavily on policies written by Jeffrey
  Ryan Thalhammer <jeff@imaginative-software.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Andrew Moore.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDCLOSE

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireCheckedOpen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDOPEN';
  package Perl::Critic::Policy::InputOutput::RequireCheckedOpen;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Return value of "open" ignored};
  Readonly::Scalar my $EXPL => q{Check the return value of "open" for success};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'autodie_modules',
              description     => 'Modules which export autodie.',
              default_string  => 'autodie',
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne 'open';
      return if ! is_unchecked_call( $elem, [ keys %{ $self->{_autodie_modules} } ] );
  
      return $self->violation( $DESC, $EXPL, $elem );
  
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords autodie
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::RequireCheckedOpen - Write C<< my $error = open $fh, $mode, $filename; >> instead of C<< open $fh, $mode, $filename; >>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The perl builtin I/O function C<open> returns a false value on
  failure. That value should always be checked to ensure that the open
  was successful.
  
  
      my $error = open( $filehandle, $mode, $filename );                  # ok
      open( $filehandle, $mode, $filename ) or die "unable to open: $!";  # ok
      open( $filehandle, $mode, $filename );                              # not ok
  
      use autodie;
      open $filehandle, $mode, $filename;                                 # ok
  
  You can use L<autodie|autodie>, L<Fatal|Fatal>, or
  L<Fatal::Exception|Fatal::Exception> to get around
  this.  Currently, L<autodie|autodie> is not properly treated as a pragma; its
  lexical effects aren't taken into account.
  
  
  =head1 CONFIGURATION
  
  If you create a module that exports C<autodie> you can tell this policy about
  it with the C<autodie_modules> setting:
  
      [InputOutput::RequireCheckedSyscalls]
      autodie_modules = My::Thing
  
  
  =head1 AUTHOR
  
  Andrew Moore <amoore@mooresystems.com>
  
  =head1 ACKNOWLEDGMENTS
  
  This policy module is based heavily on policies written by Jeffrey
  Ryan Thalhammer <jeff@imaginative-software.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Andrew Moore.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDOPEN

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireCheckedSyscalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDSYSCALLS';
  package Perl::Critic::Policy::InputOutput::RequireCheckedSyscalls;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :characters :severities :classification
                              hashify is_perl_bareword };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Return value of flagged function ignored};
  Readonly::Scalar my $EXPL => [208, 278];
  
  Readonly::Array my @DEFAULT_FUNCTIONS => qw(
      open close print say
  );
  # I created this list by searching for "return" in perlfunc
  Readonly::Array my @BUILTIN_FUNCTIONS => qw(
      accept bind binmode chdir chmod chown close closedir connect
      dbmclose dbmopen exec fcntl flock fork ioctl kill link listen
      mkdir msgctl msgget msgrcv msgsnd open opendir pipe print read
      readdir readline readlink readpipe recv rename rmdir say seek seekdir
      semctl semget semop send setpgrp setpriority setsockopt shmctl
      shmget shmread shutdown sleep socket socketpair symlink syscall
      sysopen sysread sysseek system syswrite tell telldir truncate
      umask unlink utime wait waitpid
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'functions',
              description     =>
                  'The set of functions to require checking the return value of.',
              default_string  => join( $SPACE, @DEFAULT_FUNCTIONS ),
              behavior        => 'string list',
          },
          {
              name            => 'exclude_functions',
              description     =>
                  'The set of functions to not require checking the return value of.',
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
          {
              name            => 'autodie_modules',
              description     => 'Modules which export autodie.',
              default_string  => 'autodie',
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_LOWEST       }
  sub default_themes       { return qw( core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      my @specified_functions = keys %{ $self->{_functions} };
      my @resulting_functions;
  
      foreach my $function (@specified_functions) {
          if ( $function eq ':defaults' ) {
              push @resulting_functions, @DEFAULT_FUNCTIONS;
          }
          elsif ( $function eq ':builtins' ) {
              push @resulting_functions, @BUILTIN_FUNCTIONS;
          }
          else {
              push @resulting_functions, $function;
          }
      }
  
      my %functions = hashify(@resulting_functions);
  
      foreach my $function ( keys %{ $self->{_exclude_functions} } ) {
          delete $functions{$function};
      }
  
      $self->{_functions} = \%functions;
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $self->{_functions}->{':all'} ) {
          return if is_perl_bareword($elem);
          return if $self->{_exclude_functions}->{ $elem->content() };
      }
      elsif ( not $self->{_functions}->{ $elem->content() } ) {
          return;
      }
  
      return if ! is_unchecked_call( $elem, [ keys %{ $self->{_autodie_modules} } ] );
  
      return $self->violation( "$DESC - " . $elem->content(), $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords nyah autodie builtins
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::RequireCheckedSyscalls - Return value of flagged function ignored.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This performs identically to InputOutput::RequireCheckedOpen/Close
  except that this is configurable to apply to any function, whether
  core or user-defined.
  
  If your module uses L<Fatal|Fatal>,
  L<Fatal::Exception|Fatal::Exception>, or L<autodie|autodie> then any functions
  wrapped by those modules will not trigger this policy.  For example:
  
      use Fatal qw(open);
      open my $fh, $filename;  # no violation
      close $fh;               # yes violation
  
      use autodie;
      open $filehandle, $mode, $filename;   # no violation
  
  Currently, L<autodie|autodie> is not properly treated as a pragma; its
  lexical effects aren't taken into account.
  
  
  =head1 CONFIGURATION
  
  This policy watches for a configurable list of function names.  By
  default, it applies to C<open>, C<print>, C<say> and C<close>.  You can
  override this to set it to a different list of functions with the
  C<functions> and C<exclude_functions> settings.  To do this, put
  entries in a F<.perlcriticrc> file like this:
  
      [InputOutput::RequireCheckedSyscalls]
      functions = open opendir read readline readdir close closedir
  
  We have defined a few shortcuts for creating this list
  
      [InputOutput::RequireCheckedSyscalls]
      functions = :defaults opendir readdir closedir
  
      [InputOutput::RequireCheckedSyscalls]
      functions = :builtins
  
      [InputOutput::RequireCheckedSyscalls]
      functions = :all
  
  The C<:builtins> shortcut above represents all of the builtin
  functions that have error conditions (about 65 of them, many of them
  rather obscure).
  
  You can require checking all builtins except C<print> by combining
  the C<functions> and C<exclude_functions>:
  
      [InputOutput::RequireCheckedSyscalls]
      functions = :builtins
      exclude_functions = print
  
  This is a lot easier to read than the alternative.
  
  The C<:all> is the insane case: you must check the return value of
  EVERY function call, even C<return> and C<exit>.  Yes, this "feature"
  is overkill and is wasting CPU cycles on your computer by just
  existing.  Nyah nyah.  I shouldn't code after midnight.
  
  If you create a module that exports C<autodie> you can tell this policy about
  it with the C<autodie_modules> setting:
  
      [InputOutput::RequireCheckedSyscalls]
      autodie_modules = My::Thing
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  This policy module is based heavily on policies written by Andrew
  Moore <amoore@mooresystems.com>.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIRECHECKEDSYSCALLS

$fatpacked{"Perl/Critic/Policy/InputOutput/RequireEncodingWithUTF8Layer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREENCODINGWITHUTF8LAYER';
  package Perl::Critic::Policy::InputOutput::RequireEncodingWithUTF8Layer;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use version;
  
  use Perl::Critic::Utils qw{ :severities :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{I/O layer ":utf8" used};
  Readonly::Scalar my $EXPL => q{Use ":encoding(UTF-8)" to get strict validation};
  
  Readonly::Scalar my $THREE_ARGUMENT_OPEN => 3;
  Readonly::Hash   my %RECOVER_ENCODING => (
      binmode => \&_recover_binmode_encoding,
      open => \&_recover_open_encoding,
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGHEST          }
  sub default_themes       { return qw(core bugs security) }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $document) = @_;
  
      my $handler = $RECOVER_ENCODING{ $elem->content() }
          or return;  # If we don't have a handler, we're not interested.
      my $encoding = $handler->( parse_arg_list( $elem ) )
          or return;  # If we can't recover an encoding, we give up.
      return if $encoding !~ m/ (?: \A | : ) utf8 \b /smxi;   # OK
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  # my $string = _get_argument_string( $arg[1] );
  #
  # This subroutine returns the string from the given argument (which must
  # be a reference to an array of PPI objects), _PROVIDED_ the array
  # contains a single PPI::Token::Quote object. Otherwise it simply
  # returns, since we're too stupid to analyze anything else.
  
  sub _get_argument_string {
      my ( $arg ) = @_;
      ref $arg eq 'ARRAY' or return;
      return if @{ $arg } == 0 || @{ $arg } > 1;
      return $arg->[0]->string() if $arg->[0]->isa( 'PPI::Token::Quote' );
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # my $encoding = _recover_binmode_encoding( _parse_arg_list( $elem ) );
  #
  # This subroutine returns the encoding specified by the given $elem,
  # which _MUST_ be the 'binmode' of a binmode() call.
  
  sub _recover_binmode_encoding {
      my ( @args ) = @_;
      return _get_argument_string( $args[1] );
  }
  
  #-----------------------------------------------------------------------------
  
  # my $encoding = _recover_open_encoding( _parse_arg_list( $elem ) );
  #
  # This subroutine returns the encoding specified by the given $elem,
  # which _MUST_ be the 'open' of a open() call.
  
  sub _recover_open_encoding {
      my ( @args ) = @_;
      @args < $THREE_ARGUMENT_OPEN
          and return;
      defined( my $string = _get_argument_string( $args[1] ) )
          or return;
      $string =~ s/ [+]? (?: < | >{1,2} ) //smx;
      return $string;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords PerlIO PerlMonks Wiki
  
  =head1 NAME
  
  Perl::Critic::Policy::InputOutput::RequireEncodingWithUTF8Layer - Write C<< open $fh, q{<:encoding(UTF-8)}, $filename; >> instead of C<< open $fh, q{<:utf8}, $filename; >>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Use of the C<:utf8> I/O layer (as opposed to C<:encoding(UTF8)> or
  C<:encoding(UTF-8)>) was suggested in the Perl documentation up to
  version 5.8.8. This may be OK for output, but on input C<:utf8> does not
  validate the input, leading to unexpected results.
  
  An exploit based on this behavior of C<:utf8> is exhibited on PerlMonks
  at L<http://www.perlmonks.org/?node_id=644786>. The exploit involves a
  string read from an external file and sanitized with C<m/^(\w+)$/>,
  where C<$1> nonetheless ends up containing shell meta-characters.
  
  To summarize:
  
   open $fh, '<:utf8', 'foo.txt';             # BAD
   open $fh, '<:encoding(UTF8)', 'foo.txt';   # GOOD
   open $fh, '<:encoding(UTF-8)', 'foo.txt';  # BETTER
  
  See the L<Encode|Encode> documentation for the difference between
  C<UTF8> and C<UTF-8>. The short version is that C<UTF-8> implements the
  Unicode standard, and C<UTF8> is liberalized.
  
  For consistency's sake, this policy checks files opened for output as
  well as input. For complete coverage it also checks C<binmode()> calls,
  where the direction of operation can not be determined.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  Because C<Perl::Critic> does a static analysis, this policy can not
  detect cases like
  
   my $encoding = ':utf8';
   binmode $fh, $encoding;
  
  where the encoding is computed.
  
  
  =head1 SEE ALSO
  
  L<PerlIO|PerlIO>
  
  L<Encode|Encode>
  
  C<perldoc -f binmode>
  
  L<http://www.socialtext.net/perl5/index.cgi?the_utf8_perlio_layer>
  
  L<http://www.perlmonks.org/?node_id=644786>
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 Thomas R. Wyant, III
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_INPUTOUTPUT_REQUIREENCODINGWITHUTF8LAYER

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitFormats.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITFORMATS';
  package Perl::Critic::Policy::Miscellanea::ProhibitFormats;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Format used};
  Readonly::Scalar my $EXPL => [ 449 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance pbp certrule ) }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem->content() ne 'format';
      return if ! is_function_call( $elem );
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Miscellanea::ProhibitFormats - Do not use C<format>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Formats are one of the oldest features of Perl.  Unfortunately, they
  suffer from several limitations.  Formats are static and cannot be
  easily defined at run time.  Also, formats depend on several obscure
  global variables.
  
  For more modern reporting tools, consider using one of the template
  frameworks like L<Template|Template> or try the
  L<Perl6::Form|Perl6::Form> module.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITFORMATS

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitTies.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITTIES';
  package Perl::Critic::Policy::Miscellanea::ProhibitTies;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Tied variable used};
  Readonly::Scalar my $EXPL => [ 451 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                       }
  sub default_severity     { return $SEVERITY_LOW            }
  sub default_themes       { return qw(core pbp maintenance) }
  sub applies_to           { return 'PPI::Token::Word'       }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem->content() ne 'tie';
      return if ! is_function_call( $elem );
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Miscellanea::ProhibitTies - Do not use C<tie>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway discourages using C<tie> to bind Perl primitive variables to
  user-defined objects.  Unless the tie is done close to where the
  object is used, other developers probably won't know that the variable
  has special behavior.  If you want to encapsulate complex behavior,
  just use a proper object or subroutine.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITTIES

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitUnrestrictedNoCritic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUNRESTRICTEDNOCRITIC';
  package Perl::Critic::Policy::Miscellanea::ProhibitUnrestrictedNoCritic;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw<:severities :booleans>;
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Unrestricted '## no critic' annotation};
  Readonly::Scalar my $EXPL => q{Only disable the Policies you really need to disable};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance )     }
  sub applies_to           { return 'PPI::Document'            }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $doc, undef ) = @_;
  
      # If for some reason $doc is not a P::C::Document, then all bets are off
      return if not $doc->isa('Perl::Critic::Document');
  
      my @violations = ();
      for my $annotation ($doc->annotations()) {
          if ($annotation->disables_all_policies()) {
              my $elem = $annotation->element();
              push @violations, $self->violation($DESC, $EXPL, $elem);
          }
      }
  
      return @violations;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords syntaxes
  
  =head1 NAME
  
  Perl::Critic::Policy::Miscellanea::ProhibitUnrestrictedNoCritic - Forbid a bare C<## no critic>
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  A bare C<## no critic> annotation will disable B<all> the active Policies.  This
  creates holes for other, unintended violations to appear in your code.  It is
  better to disable B<only> the particular Policies that you need to get around.
  By putting Policy names in a comma-separated list after the C<## no critic>
  annotation, then it will only disable the named Policies.  Policy names are
  matched as regular expressions, so you can use shortened Policy names, or
  patterns that match several Policies. This Policy generates a violation any
  time that an unrestricted C<## no critic> annotation appears.
  
      ## no critic                     # not ok
      ## no critic ''                  # not ok
      ## no critic ()                  # not ok
      ## no critic qw()                # not ok
  
      ## no critic   (Policy1, Policy2)  # ok
      ## no critic   (Policy1 Policy2)   # ok (can use spaces to separate)
      ## no critic qw(Policy1 Policy2)   # ok (the preferred style)
  
  
  =head1 NOTE
  
  Unfortunately, L<Perl::Critic|Perl::Critic> is very sloppy about
  parsing the Policy names that appear after a C<##no critic>
  annotation.  For example, you might be using one of these
  broken syntaxes...
  
      ## no critic Policy1 Policy2
      ## no critic 'Policy1, Policy2'
      ## no critic "Policy1, Policy2"
      ## no critic "Policy1", "Policy2"
  
  In all of these cases, Perl::Critic will silently disable B<all> Policies,
  rather than just the ones you requested.  But if you use the
  C<ProhibitUnrestrictedNoCritic> Policy, all of these will generate
  violations.  That way, you can track them down and correct them to use
  the correct syntax, as shown above in the L<"DESCRIPTION">.  If you've
  been using the syntax that is shown throughout the Perl::Critic
  documentation for the last few years, then you should be fine.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ###############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUNRESTRICTEDNOCRITIC

$fatpacked{"Perl/Critic/Policy/Miscellanea/ProhibitUselessNoCritic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUSELESSNOCRITIC';
  package Perl::Critic::Policy::Miscellanea::ProhibitUselessNoCritic;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use List::MoreUtils qw< none >;
  
  use Perl::Critic::Utils qw{ :severities :classification hashify };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Useless '## no critic' annotation};
  Readonly::Scalar my $EXPL => q{This annotation can be removed};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_LOW              }
  sub default_themes       { return qw(core maintenance)       }
  sub applies_to           { return 'PPI::Document'            }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, undef, $doc ) = @_;
  
      # If for some reason $doc is not a P::C::Document, then all bets are off
      return if not $doc->isa('Perl::Critic::Document');
  
      my @violations = ();
      my @suppressed_viols = $doc->suppressed_violations();
  
      for my $ann ( $doc->annotations() ) {
          if ( none { _annotation_suppresses_violation($ann, $_) } @suppressed_viols ) {
              push @violations, $self->violation($DESC, $EXPL, $ann->element());
          }
      }
  
      return @violations;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _annotation_suppresses_violation {
      my ($annotation, $violation) = @_;
  
      my $policy_name = $violation->policy();
      my $line = $violation->location()->[0];
  
      return $annotation->disables_line($line)
          && $annotation->disables_policy($policy_name);
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Miscellanea::ProhibitUselessNoCritic - Remove ineffective "## no critic" annotations.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic> distribution.
  
  
  =head1 DESCRIPTION
  
  Sometimes, you may need to use a C<"## no critic"> annotation to work around
  a false-positive bug in L<Perl::Critic|Perl::Critic>.  But eventually, that bug might get
  fixed, leaving your code with extra C<"## no critic"> annotations lying about.
  Or you may use them to locally disable a Policy, but then later decide to
  permanently remove that Policy entirely from your profile, making some of
  those C<"## no critic"> annotations pointless.  Or, you may accidentally
  disable too many Policies at once, creating an opportunity for new
  violations to slip in unnoticed.
  
  This Policy will emit violations if you have a C<"## no critic"> annotation in
  your source code that does not actually suppress any violations given your
  current profile.  To resolve this, you should either remove the annotation
  entirely, or adjust the Policy name patterns in the annotation to match only
  the Policies that are actually being violated in your code.
  
  
  =head1 EXAMPLE
  
  For example, let's say I have a regex, but I don't want to use the C</x> flag,
  which violates the C<RegularExpressions::RequireExtendedFormatting> policy.
  In the following code, the C<"## no critic"> annotation will suppress
  violations of that Policy and ALL Policies that match
  C<m/RegularExpressions/imx>
  
    my $re = qr/foo bar baz/ms;  ## no critic (RegularExpressions)
  
  However, this creates a potential loop-hole for someone to introduce
  additional violations in the future, without explicitly acknowledging them.
  This Policy is designed to catch these situations by warning you that you've
  disabled more Policies than the situation really requires.  The above code
  should be remedied like this:
  
    my $re = qr/foo bar baz/ms;  ## no critic (RequireExtendedFormatting)
  
  Notice how the C<RequireExtendedFormatting> pattern more precisely matches
  the name of the Policy that I'm trying to suppress.
  
  
  =head1 NOTE
  
  Changing your F<.perlcriticrc> file and disabling policies globally or running
  at a higher (i.e. less restrictive) severity level may cause this Policy to
  emit additional violations.  So you might want to defer using this Policy
  until you have a fairly stable profile.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 ACKNOWLEDGMENT
  
  This Policy was inspired by Adam Kennedy's article at
  L<http://use.perl.org/article.pl?sid=08/09/24/1957256>.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MISCELLANEA_PROHIBITUSELESSNOCRITIC

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitAutomaticExportation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITAUTOMATICEXPORTATION';
  package Perl::Critic::Policy::Modules::ProhibitAutomaticExportation;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use List::MoreUtils qw(any);
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Symbols are exported by default};
  Readonly::Scalar my $EXPL => q{Use '@EXPORT_OK' or '%EXPORT_TAGS' instead};  ## no critic (RequireInterpolation)
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()              }
  sub default_severity     { return $SEVERITY_HIGH  }
  sub default_themes       { return qw( core bugs ) }
  sub applies_to           { return 'PPI::Document' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      if ( _uses_exporter($doc) ) {
          if ( my $exp = _has_exports($doc) ) {
              return $self->violation( $DESC, $EXPL, $exp );
          }
      }
      return; #ok
  }
  
  #-----------------------------------------------------------------------------
  
  sub _uses_exporter {
      my ($doc) = @_;
  
      my $includes_ref = $doc->find('PPI::Statement::Include');
      return if not $includes_ref;
  
      # This covers both C<use Exporter;> and C<use base 'Exporter';>
      return scalar grep { m/ \b Exporter \b/xms }  @{ $includes_ref };
  }
  
  #------------------
  
  sub _has_exports {
      my ($doc) = @_;
  
      my $wanted =
          sub { _our_export(@_) or _vars_export(@_) or _package_export(@_) };
  
      return $doc->find_first( $wanted );
  }
  
  #------------------
  
  sub _our_export {
      my (undef, $elem) = @_;
  
      $elem->isa('PPI::Statement::Variable') or return 0;
      $elem->type() eq 'our' or return 0;
  
      return any { $_ eq '@EXPORT' } $elem->variables(); ## no critic(RequireInterpolationOfMetachars)
  }
  
  #------------------
  
  sub _vars_export {
      my (undef, $elem) = @_;
  
      $elem->isa('PPI::Statement::Include') or return 0;
      $elem->pragma() eq 'vars' or return 0;
  
      return $elem =~ m{ \@EXPORT \b }xms; #Crude, but usually works
  }
  
  #------------------
  
  sub _package_export {
      my (undef, $elem) = @_;
  
      $elem->isa('PPI::Token::Symbol') or return 0;
  
      return $elem =~ m{ \A \@ \S+ ::EXPORT \z }xms;
      #TODO: ensure that it is in _this_ package!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::ProhibitAutomaticExportation - Export symbols via C<@EXPORT_OK> or C<%EXPORT_TAGS> instead of C<@EXPORT>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  When using L<Exporter|Exporter>, symbols placed in the C<@EXPORT>
  variable are automatically exported into the caller's namespace.
  Although convenient, this practice is not polite, and may cause
  serious problems if the caller declares the same symbols.  The best
  practice is to place your symbols in C<@EXPORT_OK> or C<%EXPORT_TAGS>
  and let the caller choose exactly which symbols to export.
  
      package Foo;
  
      use Exporter 'import';
      our @EXPORT      = qw(foo $bar @baz);                  # not ok
      our @EXPORT_OK   = qw(foo $bar @baz);                  # ok
      our %EXPORT_TAGS = ( all => [ qw(foo $bar @baz) ] );   # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_PROHIBITAUTOMATICEXPORTATION

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitConditionalUseStatements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITCONDITIONALUSESTATEMENTS';
  package Perl::Critic::Policy::Modules::ProhibitConditionalUseStatements;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Conditional "use" statement};
  Readonly::Scalar my $EXPL => q{Use "require" to conditionally include a module.};
  
  # operators
  
  Readonly::Hash my %OPS => map { $_ => 1 } qw( || && or and );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()              }
  sub default_severity     { return $SEVERITY_MEDIUM  }
  sub default_themes       { return qw( core bugs ) }
  sub applies_to           { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
      return $self->violation( $DESC, $EXPL, $elem ) if $elem->type() eq 'use'
          && !$elem->pragma()
          && $elem->module()
          && $self->_is_in_conditional_logic($elem);
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # is this a non-string eval statement
  
  sub _is_eval {
      my ( $self, $elem ) = @_;
      $elem->isa('PPI::Statement') or return;
      my $first_elem = $elem->first_element();
      return $TRUE if $first_elem->isa('PPI::Token::Word')
          && $first_elem eq 'eval';
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # is this in a conditional do block
  
  sub _is_in_do_conditional_block {
      my ( $self, $elem ) = @_;
      return if !$elem->isa('PPI::Structure::Block');
      my $prev_sibling = $elem->sprevious_sibling() or return;
      if ($prev_sibling->isa('PPI::Token::Word') && $prev_sibling eq 'do') {
          my $next_sibling = $elem->snext_sibling();
          return $TRUE if $next_sibling
              && $next_sibling->isa('PPI::Token::Word');
          $prev_sibling = $prev_sibling->sprevious_sibling() or return;
          return $TRUE if $prev_sibling->isa('PPI::Token::Operator')
              && $OPS{$prev_sibling->content()};
      }
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # is this a compound statement
  
  sub _is_compound_statement {
      my ( $self, $elem ) = @_;
      return if !$elem->isa('PPI::Statement::Compound');
      return $TRUE if $elem->type() ne 'continue'; # exclude bare blocks
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # is this contained in conditional logic
  
  sub _is_in_conditional_logic {
      my ( $self, $elem ) = @_;
      while ($elem = $elem->parent()) {
          last if $elem->isa('PPI::Document');
          return $TRUE if $self->_is_compound_statement($elem)
              || $self->_is_eval($elem)
              || $self->_is_in_do_conditional_block($elem);
      }
      return;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords evals
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::ProhibitConditionalUseStatements - Avoid putting conditional logic around compile-time includes.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Modules included via "use" are loaded at compile-time.  Placing conditional
  logic around the "use" statement has no effect on whether the module will be
  loaded.  Doing so can also serve to confuse the reader as to the author's
  original intent.
  
  If you need to conditionally load a module you should be using "require"
  instead.
  
  This policy will catch the following forms of conditional "use" statements:
  
      # if-elsif-else
      if ($a == 1) { use Module; }
      if ($a == 1) { } elsif ($a == 2) { use Module; }
      if ($a == 1) { } else { use Module; }
  
      # for/foreach
      for (1..$a) { use Module; }
      foreach (@a) { use Module; }
  
      # while
      while ($a == 1) { use Module; }
  
      # unless
      unless ($a == 1) { use Module; }
  
      # until
      until ($a == 1) { use Module; }
  
      # do-condition
      do { use Module; } if $a == 1;
      do { use Module; } while $a == 1;
      do { use Module; } unless $a == 1;
      do { use Module; } until $a == 1;
  
      # operator-do
      $a == 1 || do { use Module; };
      $a == 1 && do { use Module; };
      $a == 1 or do { use Module; };
      $a == 1 and do { use Module; };
  
      # non-string eval
      eval { use Module; };
  
  Including a module via "use" in bare blocks, standalone do blocks, or
  string evals is allowed.
  
      # bare block
      { use Module; }
  
      # do
      do { use Module; }
  
      # string eval
      eval "use Module";
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Peter Guzis <pguzis@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 Peter Guzis.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_PROHIBITCONDITIONALUSESTATEMENTS

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitEvilModules.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITEVILMODULES';
  package Perl::Critic::Policy::Modules::ProhibitEvilModules;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue
      qw{ throw_policy_value };
  use Perl::Critic::Utils qw{
      :booleans :characters :severities :data_conversion
  };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Find an alternative module};
  
  Readonly::Scalar my $MODULE_NAME_REGEX =>
      qr<
          \b
          [[:alpha:]_]
          (?:
              (?: \w | :: )*
              \w
          )?
          \b
      >xms;
  Readonly::Scalar my $REGULAR_EXPRESSION_REGEX => qr< [/] ( [^/]+ ) [/] >xms;
  Readonly::Scalar my $DESCRIPTION_REGEX => qr< [{] ( [^}]+ ) [}] >xms;
  
  # It's kind of unfortunate that I had to put capturing parentheses in the
  # component regexes above, because they're not visible here and so make
  # figuring out the positions of captures hard.  Too bad we can't make the
  # minimum perl version 5.10. :]
  Readonly::Scalar my $MODULES_REGEX =>
      qr<
          \A
          \s*
          (?:
                  ( $MODULE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          (?: \s* $DESCRIPTION_REGEX )?
          \s*
      >xms;
  
  Readonly::Scalar my $MODULES_FILE_LINE_REGEX =>
      qr<
          \A
          \s*
          (?:
                  ( $MODULE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          \s*
          ( \S (?: .* \S )? )?
          \s*
          \z
      >xms;
  
  Readonly::Scalar my $DEFAULT_MODULES =>
      join
          $SPACE,
          map { "$_ {Found use of $_. This module is deprecated by the Perl 5 Porters.}" }
              qw< Class::ISA Pod::Plainer Shell Switch >;
  
  # Indexes in the arrays of regexes for the "modules" option.
  Readonly::Scalar my $INDEX_REGEX        => 0;
  Readonly::Scalar my $INDEX_DESCRIPTION  => 1;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'modules',
              description     => 'The names of or patterns for modules to forbid.',
              default_string  => $DEFAULT_MODULES,
              parser          => \&_parse_modules,
          },
          {
              name            => 'modules_file',
              description     => 'A file containing names of or patterns for modules to forbid.',
              default_string  => $EMPTY,
              parser          => \&_parse_modules_file,
          },
      );
  }
  
  sub default_severity  { return $SEVERITY_HIGHEST         }
  sub default_themes    { return qw( core bugs certrule )           }
  sub applies_to        { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_modules {
      my ($self, $parameter, $config_string) = @_;
  
      my $module_specifications =
          defined $config_string
              ? $config_string
              : $parameter->get_default_string();
  
      return if not $module_specifications;
      return if $module_specifications =~ m< \A \s* \z >xms;
  
      while ( $module_specifications =~ s< $MODULES_REGEX ><>xms ) {
          my ($module, $regex_string, $description) = ($1, $2, $3);
  
          $self->_handle_module_specification(
              module                  => $module,
              regex_string            => $regex_string,
              description             => $description,
              option_name             => 'modules',
              option_value            => $config_string,
          );
      }
  
      if ($module_specifications) {
          throw_policy_value
              policy         => $self->get_short_name(),
              option_name    => 'modules',
              option_value   => $config_string,
              message_suffix =>
                  qq{contains unparseable data: "$module_specifications"};
      }
  
      return;
  }
  
  sub _parse_modules_file {
      my ($self, $parameter, $config_string) = @_;
  
      return if not $config_string;
      return if $config_string =~ m< \A \s* \z >xms;
  
      open my $handle, '<', $config_string
          or throw_policy_value
              policy         => $self->get_short_name(),
              option_name    => 'modules_file',
              option_value   => $config_string,
              message_suffix =>
                  qq<refers to a file that could not be opened: $OS_ERROR>;
      while ( my $line = <$handle> ) {
          $self->_handle_module_specification_on_line($line, $config_string);
      }
      close $handle or warn qq<Could not close "$config_string": $OS_ERROR\n>;
  
      return;
  }
  
  sub _handle_module_specification_on_line {
      my ($self, $line, $config_string) = @_;
  
      $line =~ s< [#] .* \z ><>xms;
      $line =~ s< \s+ \z ><>xms;
      $line =~ s< \A \s+ ><>xms;
  
      return if not $line;
  
      if ( $line =~ s< $MODULES_FILE_LINE_REGEX ><>xms ) {
          my ($module, $regex_string, $description) = ($1, $2, $3);
  
          $self->_handle_module_specification(
              module                  => $module,
              regex_string            => $regex_string,
              description             => $description,
              option_name             => 'modules_file',
              option_value            => $config_string,
          );
      }
      else {
          throw_policy_value
              policy         => $self->get_short_name(),
              option_name    => 'modules_file',
              option_value   => $config_string,
              message_suffix =>
                  qq{contains unparseable data: "$line"};
      }
  
      return;
  }
  
  sub _handle_module_specification {
      my ($self, %arguments) = @_;
  
      my $description = $arguments{description} || $EMPTY;
  
      if ( my $regex_string = $arguments{regex_string} ) {
          # These are module name patterns (e.g. /Acme/)
          my $actual_regex;
  
          eval { $actual_regex = qr/$regex_string/; 1 }  ## no critic (ExtendedFormatting, LineBoundaryMatching, DotMatchAnything)
              or throw_policy_value
                  policy         => $self->get_short_name(),
                  option_name    => $arguments{option_name},
                  option_value   => $arguments{option_value},
                  message_suffix =>
                      qq{contains an invalid regular expression: "$regex_string"};
  
          # Can't use a hash due to stringification, so this is an AoA.
          $self->{_evil_modules_regexes} ||= [];
  
          push
              @{ $self->{_evil_modules_regexes} },
              [ $actual_regex, $description ];
      }
      else {
          # These are literal module names (e.g. Acme::Foo)
          $self->{_evil_modules} ||= {};
          $self->{_evil_modules}{ $arguments{module} } = $description;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      # Disable if no modules are specified; there's no point in running if
      # there aren't any.
      return
              exists $self->{_evil_modules}
          ||  exists $self->{_evil_modules_regexes};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $module = $elem->module();
      return if not $module;
  
      my $evil_modules = $self->{_evil_modules};
      my $evil_modules_regexes = $self->{_evil_modules_regexes};
      my $description;
  
      if ( exists $evil_modules->{$module} ) {
          $description = $evil_modules->{ $module };
      }
      else {
          REGEX:
          foreach my $regex ( @{$evil_modules_regexes} ) {
              if ( $module =~ $regex->[$INDEX_REGEX] ) {
                  $description = $regex->[$INDEX_DESCRIPTION];
                  last REGEX;
              }
          }
      }
  
      if (defined $description) {
          $description ||= qq<Prohibited module "$module" used>;
  
          return $self->violation( $description, $EXPL, $elem );
      }
  
      return;    # ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::ProhibitEvilModules - Ban modules that aren't blessed by your shop.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Use this policy if you wish to prohibit the use of specific modules.
  These may be modules that you feel are deprecated, buggy, unsupported,
  insecure, or just don't like.
  
  
  =head1 CONFIGURATION
  
  The set of prohibited modules is configurable via the C<modules> and
  C<modules_file> options.
  
  The value of C<modules> should be a string of space-delimited, fully
  qualified module names and/or regular expressions.  An example of
  prohibiting two specific modules in a F<.perlcriticrc> file:
  
      [Modules::ProhibitEvilModules]
      modules = Getopt::Std Autoload
  
  Regular expressions are identified by values beginning and ending with
  slashes.  Any module with a name that matches C<m/pattern/> will be
  forbidden.  For example:
  
      [Modules::ProhibitEvilModules]
      modules = /Acme::/
  
  would cause all modules that match C<m/Acme::/> to be forbidden.
  
  In addition, you can override the default message ("Prohibited module
  "I<module>" used") with your own, in order to give suggestions for
  alternative action.  To do so, put your message in curly braces after
  the module name or regular expression.  Like this:
  
      [Modules::ProhibitEvilModules]
      modules = Fatal {Found use of Fatal. Use autodie instead} /Acme::/ {We don't use joke modules}
  
  Similarly, the C<modules_file> option gives the name of a file
  containing specifications for prohibited modules.  Only one module
  specification is allowed per line and comments start with an octothorp
  and run to end of line; no curly braces are necessary for delimiting
  messages:
  
      Evil     # Prohibit the "Evil" module and use the default message.
  
      # Prohibit the "Fatal" module and give a replacement message.
      Fatal Found use of Fatal. Use autodie instead.
  
      # Use a regular expression.
      /Acme::/     We don't use joke modules.
  
  By default, the modules that have been deprecated by the Perl 5 Porters are
  reported; at the time of writing these are L<Class::ISA|Class::ISA>,
  L<Pod::Plainer|Pod::Plainer>, L<Shell|Shell>, and L<Switch|Switch>.
  Specifying a value for the C<modules> option will override this.
  
  
  =head1 NOTES
  
  Note that this policy doesn't apply to pragmas.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_PROHIBITEVILMODULES

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitExcessMainComplexity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITEXCESSMAINCOMPLEXITY';
  package Perl::Critic::Policy::Modules::ProhibitExcessMainComplexity;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use Perl::Critic::Utils::McCabe qw{ calculate_mccabe_of_main };
  
  use base 'Perl::Critic::Policy';
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Consider refactoring};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_mccabe',
              description     => 'The maximum complexity score allowed.',
              default_string  => '20',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM                }
  sub default_themes   { return qw(core complexity maintenance) }
  sub applies_to       { return 'PPI::Document'                 }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $doc, undef ) = @_;
  
      my $score = calculate_mccabe_of_main( $doc );
  
      # Is it too complex?
      return if $score <= $self->{_max_mccabe};
  
      my $desc = qq{Main code has high complexity score ($score)};
      return $self->violation( $desc, $EXPL, $doc );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords McCabe
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::ProhibitExcessMainComplexity - Minimize complexity in code that is B<outside> of subroutines.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  All else being equal, complicated code is more error-prone and more
  expensive to maintain than simpler code.  The first step towards
  managing complexity is to establish formal complexity metrics.  One
  such metric is the McCabe score, which describes the number of
  possible paths through a block of code.  This Policy approximates the
  McCabe score by summing the number of conditional statements and
  operators within a block of code.  Research has shown that a McCabe
  score higher than 20 is a sign of high-risk, potentially untestable
  code.  See L<http://en.wikipedia.org/wiki/Cyclomatic_complexity> for
  some discussion about the McCabe number and other complexity metrics.
  
  Whereas
  L<Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity|Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity>
  scores the complexity of each subroutine, this Policy scores the total
  complexity of all the code that is B<outside> of any subroutine
  declaration.
  
  The usual prescription for reducing complexity is to refactor code
  into smaller subroutines.  Mark Dominus book "Higher Order Perl" also
  describes callbacks, recursion, memoization, iterators, and other
  techniques that help create simple and extensible Perl code.
  
  
  =head1 CONFIGURATION
  
  The maximum acceptable McCabe score can be set with the C<max_mccabe>
  
  configuration item.  If the sum of all code B<outside> any subroutine has a
  McCabe score higher than this number, it will generate a Policy violation.
  The default is 20.  An example section for a F<.perlcriticrc>:
  
      [Modules::ProhibitExcessMainComplexity]
      max_mccabe = 30
  
  
  =head1 NOTES
  
  
    "Everything should be made as simple as possible, but no simpler."
  
                                                    -- Albert Einstein
  
  
  Complexity is subjective, but formal complexity metrics are still
  incredibly valuable.  Every problem has an inherent level of
  complexity, so it is not necessarily optimal to minimize the McCabe
  number.  So don't get offended if your code triggers this Policy.
  Just consider if there B<might> be a simpler way to get the job done.
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity|Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_PROHIBITEXCESSMAINCOMPLEXITY

$fatpacked{"Perl/Critic/Policy/Modules/ProhibitMultiplePackages.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_PROHIBITMULTIPLEPACKAGES';
  package Perl::Critic::Policy::Modules::ProhibitMultiplePackages;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC   => q{Multiple "package" declarations};
  Readonly::Scalar my $EXPL   => q{Limit to one per file};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()              }
  sub default_severity     { return $SEVERITY_HIGH  }
  sub default_themes       { return qw( core bugs ) }
  sub applies_to           { return 'PPI::Document' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
      my $nodes_ref = $doc->find('PPI::Statement::Package');
      return if !$nodes_ref;
      my @matches = @{$nodes_ref} > 1 ? @{$nodes_ref}[ 1 .. $#{$nodes_ref} ] :();
  
      return map {$self->violation($DESC, $EXPL, $_)} @matches;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::ProhibitMultiplePackages - Put packages (especially subclasses) in separate files.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway doesn't specifically mention this, but I find it annoying when
  there are multiple packages in the same file.  When searching for
  methods or keywords in your editor, it makes it hard to find the right
  chunk of code, especially if each package is a subclass of the same
  base.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_PROHIBITMULTIPLEPACKAGES

$fatpacked{"Perl/Critic/Policy/Modules/RequireBarewordIncludes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREBAREWORDINCLUDES';
  package Perl::Critic::Policy::Modules::RequireBarewordIncludes;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Use a bareword instead};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                        }
  sub default_severity     { return $SEVERITY_HIGHEST         }
  sub default_themes       { return qw(core portability)      }
  sub applies_to           { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $child = $elem->schild(1);
      return if !$child;
  
      if ( $child->isa('PPI::Token::Quote') ) {
          my $type = $elem->type;
          my $desc = qq{"$type" statement with library name as string};
          return $self->violation( $desc, $EXPL, $elem );
      }
      return; #ok!
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::RequireBarewordIncludes - Write C<require Module> instead of C<require 'Module.pm'>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  When including another module (or library) via the C<require> or
  C<use> statements, it is best to identify the module (or library)
  using a bareword rather than an explicit path.  This is because paths
  are usually not portable from one machine to another.  Also, Perl
  automatically assumes that the filename ends in '.pm' when the library
  is expressed as a bareword.  So as a side-effect, this Policy
  encourages people to write '*.pm' modules instead of the old-school
  '*.pl' libraries.
  
      use 'My/Perl/Module.pm';  #not ok
      use My::Perl::Module;     #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  This Policy is a replacement for C<ProhibitRequireStatements>, which
  completely banned the use of C<require> for the sake of eliminating
  the old '*.pl' libraries from Perl4.  Upon further consideration, I
  realized that C<require> is quite useful and necessary to enable
  run-time loading.  Thus, C<RequireBarewordIncludes> does allow you to
  use C<require>, but still encourages you to write '*.pm' modules.
  
  Sometimes, you may want to load modules at run-time, but you don't
  know at design-time exactly which module you will need to load
  (L<Perl::Critic|Perl::Critic> is an example of this).  In that case,
  just attach the C<'## no critic'> annotation like so:
  
      require $module_name;  ## no critic
  
  
  =head1 CREDITS
  
  Chris Dolan <cdolan@cpan.org> was instrumental in identifying the
  correct motivation for and behavior of this Policy.  Thanks Chris.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_REQUIREBAREWORDINCLUDES

$fatpacked{"Perl/Critic/Policy/Modules/RequireEndWithOne.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREENDWITHONE';
  package Perl::Critic::Policy::Modules::RequireEndWithOne;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Must end with a recognizable true value};
  Readonly::Scalar my $DESC => q{Module does not end with "1;"};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core bugs pbp certrule ) }
  sub applies_to           { return 'PPI::Document'     }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      my ( $self, $document ) = @_;
  
      return $document->is_module();   # Must be a library or module.
  }
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # Last statement should be just "1;"
      my @significant = grep { _is_code($_) } $doc->schildren();
      my $match = $significant[-1];
      return if !$match;
      return if ((ref $match) eq 'PPI::Statement' &&
                 $match =~  m{\A 1 \s* ; \z}xms );
  
      # Must be a violation...
      return $self->violation( $DESC, $EXPL, $match );
  }
  
  sub _is_code {
      my $elem = shift;
      return ! (    $elem->isa('PPI::Statement::End')
                 || $elem->isa('PPI::Statement::Data'));
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::RequireEndWithOne - End each module with an explicitly C<1;> instead of some funky expression.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  All files included via C<use> or C<require> must end with a true value
  to indicate to the caller that the include was successful.  The
  standard practice is to conclude your .pm files with C<1;>, but some
  authors like to get clever and return some other true value like
  C<return "Club sandwich";>.  We cannot tolerate such frivolity!  OK,
  we can, but we don't recommend it since it confuses the newcomers.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan C<cdolan@cpan.org>
  
  Some portions cribbed from
  L<Perl::Critic::Policy::Modules::RequireExplicitPackage|Perl::Critic::Policy::Modules::RequireExplicitPackage>.
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Chris Dolan and Imaginative Software Systems.  All
  rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_REQUIREENDWITHONE

$fatpacked{"Perl/Critic/Policy/Modules/RequireExplicitPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREEXPLICITPACKAGE';
  package Perl::Critic::Policy::Modules::RequireExplicitPackage;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Violates encapsulation};
  Readonly::Scalar my $DESC => q{Code not contained in explicit package};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'exempt_scripts',
              description    => q{Don't require programs to contain a package statement.},
              default_string => '1',
              behavior       => 'boolean',
          },
          {
              name           => 'allow_import_of',
              description    => q{Allow the specified modules to be imported outside a package},
              behavior       => 'string list',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_HIGH  }
  sub default_themes   { return qw( core bugs ) }
  sub applies_to       { return 'PPI::Document' }
  
  sub default_maximum_violations_per_document { return 1; }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      my ( $self, $document ) = @_;
  
      return ! $self->{_exempt_scripts} || $document->is_module();
  }
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # Find the first 'package' statement
      my $package_stmnt = $doc->find_first( 'PPI::Statement::Package' );
      my $package_line = $package_stmnt ? $package_stmnt->location()->[0] : undef;
  
      # Find all statements that aren't 'package' statements
      my $stmnts_ref = $doc->find( 'PPI::Statement' );
      return if !$stmnts_ref;
      my @non_packages = grep {
          $self->_is_statement_of_interest( $_ )
      } @{$stmnts_ref};
      return if !@non_packages;
  
      # If the 'package' statement is not defined, or the other
      # statements appear before the 'package', then it violates.
  
      my @viols = ();
      for my $stmnt ( @non_packages ) {
          my $stmnt_line = $stmnt->location()->[0];
          if ( (! defined $package_line) || ($stmnt_line < $package_line) ) {
              push @viols, $self->violation( $DESC, $EXPL, $stmnt );
          }
      }
  
      return @viols;
  }
  
  sub _is_statement_of_interest {
      my ( $self, $elem ) = @_;
  
      $elem
          or return $FALSE;
  
      $elem->isa( 'PPI::Statement::Package' )
          and return $FALSE;
  
      if ( $elem->isa( 'PPI::Statement::Include' ) ) {
          if ( my $module = $elem->module() ) {
              $self->{_allow_import_of}{$module}
                  and return $FALSE;
          }
      }
  
      return $TRUE;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::RequireExplicitPackage - Always make the C<package> explicit.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  In general, the first statement of any Perl module or library should
  be a C<package> statement.  Otherwise, all the code that comes before
  the C<package> statement is getting executed in the caller's package,
  and you have no idea who that is.  Good encapsulation and common
  decency require your module to keep its innards to itself.
  
  There are some valid reasons for not having a C<package> statement at
  all.  But make sure you understand them before assuming that you
  should do it too.
  
  The maximum number of violations per document for this policy defaults
  to 1.
  
  
  
  =head1 CONFIGURATION
  
  As for programs, most people understand that the default package is
  C<main>, so this Policy doesn't apply to files that begin with a perl
  shebang.  If you want to require an explicit C<package> declaration in
  all files, including programs, then add the following to your
  F<.perlcriticrc> file
  
      [Modules::RequireExplicitPackage]
      exempt_scripts = 0
  
  Some users may find it desirable to exempt the load of specific modules
  from this policy. For example, Perl does not support Unicode module
  names because of portability problems. Users who are not concerned about
  this and intend to use C<UTF-8> module names will need to specify
  C<use utf8;> before the package declaration. To do this, add the
  following to your F<.perlcriticrc> file
  
      [Modules::RequireExplicitPackage]
      allow_import_of = utf8
  
  The C<allow_import_of> configuration option takes multiple module names,
  separated by spaces.
  
  
  =head1 IMPORTANT CHANGES
  
  This policy was formerly called C<ProhibitUnpackagedCode> which
  sounded a bit odd.  If you get lots of "Cannot load policy module"
  errors, then you probably need to change C<ProhibitUnpackagedCode> to
  C<RequireExplicitPackage> in your F<.perlcriticrc> file.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_REQUIREEXPLICITPACKAGE

$fatpacked{"Perl/Critic/Policy/Modules/RequireFilenameMatchesPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREFILENAMEMATCHESPACKAGE';
  package Perl::Critic::Policy::Modules::RequireFilenameMatchesPackage;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use File::Spec;
  
  use Perl::Critic::Utils qw{ :characters :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Package declaration must match filename};
  Readonly::Scalar my $EXPL => q{Correct the filename or package statement};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                }
  sub default_severity     { return $SEVERITY_HIGHEST }
  sub default_themes       { return qw(core bugs)     }
  sub applies_to           { return 'PPI::Document'   }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      my ( $self, $document ) = @_;
      return $document->is_module();   # Must be a library or module.
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
  
      # 'Foo::Bar' -> ('Foo', 'Bar')
      my $pkg_node = $doc->find_first('PPI::Statement::Package');
      return if not $pkg_node;
      my $pkg = $pkg_node->namespace();
      return if $pkg eq 'main';
      my @pkg_parts = split m/(?:\'|::)/xms, $pkg;
  
  
      # 'lib/Foo/Bar.pm' -> ('lib', 'Foo', 'Bar')
      my $filename = $pkg_node->logical_filename() || $doc->filename();
      return if not $filename;
  
      my @path = File::Spec->splitpath($filename);
      $filename = $path[2];
      $filename =~ s/ [.] \w+ \z //xms;
      my @path_parts =
          grep {$_ ne $EMPTY} File::Spec->splitdir($path[1]), $filename;
  
  
      # To succeed, at least the lastmost must match
      # Beyond that, the search terminates if a dirname is an impossible package name
      my $matched_any;
      while (@pkg_parts && @path_parts) {
          my $pkg_part = pop @pkg_parts;
          my $path_part = pop @path_parts;
          if ($pkg_part eq $path_part) {
              $matched_any = 1;
              next;
          }
  
          # if it's a path that's not a possible package (like 'Foo-Bar-1.00'), that's OK
          last if ($path_part =~ m/\W/xms);
  
          # Mismatched name
          return $self->violation( $DESC, $EXPL, $pkg_node );
      }
  
      return if $matched_any;
      return $self->violation( $DESC, $EXPL, $pkg_node );
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::RequireFilenameMatchesPackage - Package declaration must match filename.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The package declaration should always match the name of the file that contains
  it.  For example, C<package Foo::Bar;> should be in a file called C<Bar.pm>.
  This makes it easier for developers to figure out which file a symbol comes
  from when they see it in your code.  For instance, when you see C<<
  Foo::Bar->new() >>, you should be able to find the class definition for a
  C<Foo::Bar> in a file called F<Bar.pm>
  
  Therefore, this Policy requires the last component of the first package name
  declared in the file to match the physical filename.  Or if C<#line>
  directives are used, then it must match the logical filename defined by the
  prevailing C<#line> directive at the point of the package declaration.  Here
  are some examples:
  
    # Any of the following in file "Foo/Bar/Baz.pm":
    package Foo::Bar::Baz;     # ok
    package Baz;               # ok
    package Nuts;              # not ok (doesn't match physical filename)
  
    # using #line directives in file "Foo/Bar/Baz.pm":
    #line 1 Nuts.pm
    package Nuts;             # ok
    package Baz;              # not ok (contradicts #line directive)
  
  If the file is not deemed to be a module, then this Policy does not apply.
  Also, if the first package namespace found in the file is "main" then this
  Policy does not apply.
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_REQUIREFILENAMEMATCHESPACKAGE

$fatpacked{"Perl/Critic/Policy/Modules/RequireNoMatchVarsWithUseEnglish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIRENOMATCHVARSWITHUSEENGLISH';
  package Perl::Critic::Policy::Modules::RequireNoMatchVarsWithUseEnglish;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw< :characters :severities >;
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL =>
      q{"use English" without the '-no_match_vars' argument degrades performance.'};
  Readonly::Scalar my $DESC => q{"use English" without '-no_match_vars' argument};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                        }
  sub default_severity     { return $SEVERITY_LOW             }
  sub default_themes       { return qw( core performance )    }
  sub applies_to           { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # "require"ing English is kind of useless.
      return if $elem->type() ne 'use';
      return if $elem->module() ne 'English';
  
      my @elements = $elem->schildren();
      shift @elements; # dump "use"
      shift @elements; # dump "English"
  
      if (not @elements) {
          return $self->violation($DESC, $EXPL, $elem);
      }
  
      _skip_version_number( \@elements );
  
      @elements = _descend_into_parenthesized_list_if_present(@elements);
  
      if (not @elements) {
          return $self->violation($DESC, $EXPL, $elem);
      }
  
      my $current_element = $elements[0];
  
      while ( $current_element ) {
          if ( $current_element->isa('PPI::Token::Quote') ) {
              return if $current_element->string() eq '-no_match_vars';
          }
          elsif ( $current_element->isa('PPI::Token::QuoteLike::Words') ) {
              return if $current_element->content() =~ m/-no_match_vars \b/xms;
          }
          elsif (
                  not $current_element->isa('PPI::Token::Operator')
              or  $current_element->content() ne $COMMA
              and $current_element->content() ne $FATCOMMA
          ) {
              return $self->violation($DESC, $EXPL, $elem);
          }
  
          shift @elements;
          $current_element = $elements[0];
      }
  
      return $self->violation($DESC, $EXPL, $elem);
  }
  
  
  sub _skip_version_number {
      my ($elements_ref) = @_;
  
      my $current_element = $elements_ref->[0];
  
      if ( $current_element->isa('PPI::Token::Number') ) {
          shift @{$elements_ref};
      }
      elsif (
              @{$elements_ref} >= 2
          and $current_element->isa('PPI::Token::Word')
          and $current_element->content() =~ m/\A v \d+ \z/xms
          and $elements_ref->[1]->isa('PPI::Token::Number')
      ) {
          # The above messy conditional necessary due to PPI not handling
          # v-strings.
          shift @{$elements_ref};
          shift @{$elements_ref};
      }
  
      return;
  }
  
  sub _descend_into_parenthesized_list_if_present {
      my @elements = @_;
  
      return if not @elements;
  
      my $current_element = $elements[0];
  
      if ( $current_element->isa('PPI::Structure::List') ) {
          my @grand_children = $current_element->schildren();
          if (not @grand_children) {
              return;
          }
  
          my $grand_child = $grand_children[0];
  
          if ( $grand_child->isa('PPI::Statement::Expression') ) {
              my @great_grand_children = $grand_child->schildren();
  
              if (not @great_grand_children) {
                  return;
              }
  
              return @great_grand_children;
          }
          else {
              return @grand_children;
          }
      }
  
      return @elements;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::RequireNoMatchVarsWithUseEnglish - C<use English> must be passed a C<-no_match_vars> argument.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Due to unfortunate history, if you use the L<English|English> module
  but don't pass in a C<-no_match_vars> argument, all regular
  expressions in the entire program, not merely the module in question,
  suffer a significant performance penalty, even if you only import a
  subset of the variables.
  
      use English;                              # not ok
      use English '-no_match_vars';             # ok
      use English qw< $ERRNO -no_match_vars >;  # ok
      use English qw($OS_ERROR);                # not ok
  
  In the last example above, while the match variables aren't loaded
  into your namespace, they are still created in the C<English>
  namespace and you still pay the cost.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_REQUIRENOMATCHVARSWITHUSEENGLISH

$fatpacked{"Perl/Critic/Policy/Modules/RequireVersionVar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_MODULES_REQUIREVERSIONVAR';
  package Perl::Critic::Policy::Modules::RequireVersionVar;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{No package-scoped "$VERSION" variable found}; ## no critic (RequireInterpolation)
  Readonly::Scalar my $EXPL => [ 404 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                       }
  sub default_severity     { return $SEVERITY_LOW            }
  sub default_themes       { return qw(core pbp readability) }
  sub applies_to           { return 'PPI::Document'          }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      return if $doc->find_first( \&_is_version_declaration );
  
      #If we get here, then no $VERSION was found
      return $self->violation( $DESC, $EXPL, $doc );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_version_declaration {  ## no critic (ArgUnpacking)
      return 1 if _is_our_version(@_);
      return 1 if _is_vars_version(@_);
      return 1 if _is_package_version(@_);
      return 1 if _is_readonly_version(@_);
      return 1 if _is_package_argument_version(@_);
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_our_version {
      my (undef, $elem) = @_;
      $elem->isa('PPI::Statement::Variable') || return 0;
      $elem->type() eq 'our' || return 0;
      return any { $_ eq '$VERSION' } $elem->variables(); ## no critic (RequireInterpolation)
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_vars_version {
      my (undef, $elem) = @_;
      $elem->isa('PPI::Statement::Include') || return 0;
      $elem->pragma() eq 'vars' || return 0;
      return $elem =~ m{ \$VERSION }xms; #Crude, but usually works
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_package_version {
      my (undef, $elem) = @_;
      $elem->isa('PPI::Token::Symbol') || return 0;
      return $elem =~ m{ \A \$ \S+ ::VERSION \z }xms;
      #TODO: ensure that it is in _this_ package!
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_readonly_version {
  
      #---------------------------------------------------------------
      # Readonly VERSION statements usually come in one of two forms:
      #
      #   Readonly our $VERSION = 1.0;
      #   Readonly::Scalar our $VERSION = 1.0;
      #---------------------------------------------------------------
  
      my (undef, $elem) = @_;
      $elem->isa('PPI::Token::Symbol') || return 0;
      return 0 if $elem !~ m{ \A \$VERSION \z }xms;
  
      my $psib = $elem->sprevious_sibling() || return 0;
      return 0 if $psib ne 'our';
  
      my $ppsib = $psib->sprevious_sibling() || return 0;
      return $ppsib eq 'Readonly' || $ppsib eq 'Readonly::Scalar';
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_package_argument_version {
      my (undef, $elem) = @_;
      $elem->isa( 'PPI::Statement::Package' ) or return 0;
      # Perldoc for 5.12.3 documents the statement as
      # package NAMESPACE VERSION
      # with no comma, and the compiler in fact does not accept one.
      my $ver = $elem->schild( 2 )
          or return 0;
      return $ver->isa( 'PPI::Token::Number' );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Modules::RequireVersionVar - Give every module a C<$VERSION> number.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Every Perl file (modules, libraries, and programs) should have a
  package-scoped C<$VERSION> variable.  The C<$VERSION> allows clients to
  insist on a particular revision of your file like this:
  
      use SomeModule 2.4;  #Only loads version 2.4
  
  This Policy scans your file for any package variable named
  C<$VERSION>.  I'm assuming that you are using C<strict>, so you'll
  have to declare it like one of these:
  
      our $VERSION = 1.0611;
      $MyPackage::VERSION = 1.061;
      use vars qw($VERSION);
      use version; our $VERSION = qv(1.0611);
  
  Perl's version system does not recognize lexical variables such as
  
      my $VERSION = 1.0611;
  
  so they are not accepted by this policy.
  
  A common practice is to use the C<$Revision$> keyword to
  automatically define the C<$VERSION> variable like this:
  
      our ($VERSION) = '$Revision$' =~ m{ \$Revision: \s+ (\S+) }x;
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  Conway recommends using the C<version> pragma instead of raw numbers
  or 'v-strings.'  However, this Policy only insists that the
  C<$VERSION> be defined somehow.  I may try to extend this in the
  future.
  
  
  =head1 TO DO
  
  Add check that C<$VERSION> is independently evaluatable.  In
  particular, prohibit this:
  
      our $VERSION = $Other::Module::VERSION;
  
  This doesn't work because PAUSE and other tools literally copy your
  version declaration out of your module and evaluates it in isolation,
  at which point there's nothing in C<Other::Module>, and so the
  C<$VERSION> is undefined.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_MODULES_REQUIREVERSIONVAR

$fatpacked{"Perl/Critic/Policy/NamingConventions/Capitalization.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_NAMINGCONVENTIONS_CAPITALIZATION';
  package Perl::Critic::Policy::NamingConventions::Capitalization;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw< -no_match_vars >;
  use Readonly;
  
  use List::MoreUtils qw< any >;
  
  use Perl::Critic::Exception::AggregateConfiguration;
  use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;
  use Perl::Critic::Utils qw<
      :booleans :characters :severities
      hashify is_perl_global
  >;
  use Perl::Critic::Utils::Perl qw< symbol_without_sigil >;
  use Perl::Critic::Utils::PPI qw<
      is_in_subroutine
  >;
  use PPIx::Utilities::Statement qw<
      get_constant_name_elements_from_declaring_statement
  >;
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  # Don't worry about leading digits-- let perl/PPI do that.
  Readonly::Scalar my $ALL_ONE_CASE_REGEX      =>
      qr< \A [@%\$]? (?: [[:lower:]_\d]+ | [[:upper:]_\d]+ ) \z >xms;
  Readonly::Scalar my $ALL_LOWER_REGEX         => qr< \A [[:lower:]_\d]+ \z >xms;
  Readonly::Scalar my $ALL_UPPER_REGEX         => qr< \A [[:upper:]_\d]+ \z >xms;
  Readonly::Scalar my $STARTS_WITH_LOWER_REGEX => qr< \A _* [[:lower:]\d]   >xms;
  Readonly::Scalar my $STARTS_WITH_UPPER_REGEX => qr< \A _* [[:upper:]\d]   >xms;
  Readonly::Scalar my $NO_RESTRICTION_REGEX    => qr< .                     >xms;
  
  Readonly::Hash my %CAPITALIZATION_SCHEME_TAGS    => (
      ':single_case'          => {
          regex               => $ALL_ONE_CASE_REGEX,
          regex_violation     => 'is not all lower case or all upper case',
      },
      ':all_lower'            => {
          regex               => $ALL_LOWER_REGEX,
          regex_violation     => 'is not all lower case',
      },
      ':all_upper'            => {
          regex               => $ALL_UPPER_REGEX,
          regex_violation     => 'is not all upper case',
      },
      ':starts_with_lower'    => {
          regex               => $STARTS_WITH_LOWER_REGEX,
          regex_violation     => 'does not start with a lower case letter',
      },
      ':starts_with_upper'    => {
          regex               => $STARTS_WITH_UPPER_REGEX,
          regex_violation     => 'does not start with a upper case letter',
      },
      ':no_restriction'       => {
          regex               => $NO_RESTRICTION_REGEX,
          regex_violation     => 'there is a bug in Perl::Critic if you are reading this',
      },
  );
  
  Readonly::Scalar my $PACKAGE_REGEX          => qr/ :: | ' /xms;
  
  Readonly::Hash my %NAME_FOR_TYPE => (
      package                 => 'Package',
      subroutine              => 'Subroutine',
      local_lexical_variable  => 'Local lexical variable',
      scoped_lexical_variable => 'Scoped lexical variable',
      file_lexical_variable   => 'File lexical variable',
      global_variable         => 'Global variable',
      constant                => 'Constant',
      label                   => 'Label',
  );
  
  Readonly::Hash my %IS_COMMA => hashify( $COMMA, $FATCOMMA );
  
  Readonly::Scalar my $EXPL                   => [ 45, 46 ];
  
  #-----------------------------------------------------------------------------
  
  # Can't handle named parameters yet.
  sub supported_parameters {
      return (
          {
              name               => 'packages',
              description        => 'How package name components should be capitalized.  Valid values are :single_case, :all_lower, :all_upper:, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':starts_with_upper',
              behavior           => 'string',
          },
          {
              name               => 'package_exemptions',
              description        => 'Package names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => 'main',
              behavior           => 'string list',
          },
          {
              name               => 'subroutines',
              description        => 'How subroutine names should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':single_case',  # Matches ProhibitMixedCaseSubs
              behavior           => 'string',
          },
          {
              name               => 'subroutine_exemptions',
              description        => 'Subroutine names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     =>
                  join (
                      $SPACE,
                      qw<
  
                          AUTOLOAD  BUILD     BUILDARGS CLEAR   CLOSE
                          DELETE    DEMOLISH  DESTROY   EXISTS  EXTEND
                          FETCH     FETCHSIZE FIRSTKEY  GETC    NEXTKEY
                          POP       PRINT     PRINTF    PUSH    READ
                          READLINE  SCALAR    SHIFT     SPLICE  STORE
                          STORESIZE TIEARRAY  TIEHANDLE TIEHASH TIESCALAR
                          UNSHIFT   UNTIE     WRITE
  
                      >,
                  ),
              behavior           => 'string list',
          },
          {
              name               => 'local_lexical_variables',
              description        => 'How local lexical variables names should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':single_case',  # Matches ProhibitMixedCaseVars
              behavior           => 'string',
          },
          {
              name               => 'local_lexical_variable_exemptions',
              description        => 'Local lexical variable names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => $EMPTY,
              behavior           => 'string list',
          },
          {
              name               => 'scoped_lexical_variables',
              description        => 'How lexical variables that are scoped to a subset of subroutines, should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':single_case',  # Matches ProhibitMixedCaseVars
              behavior           => 'string',
          },
          {
              name               => 'scoped_lexical_variable_exemptions',
              description        => 'Names for variables in anonymous blocks that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => $EMPTY,
              behavior           => 'string list',
          },
          {
              name               => 'file_lexical_variables',
              description        => 'How lexical variables at the file level should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':single_case',  # Matches ProhibitMixedCaseVars
              behavior           => 'string',
          },
          {
              name               => 'file_lexical_variable_exemptions',
              description        => 'File-scope lexical variable names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => $EMPTY,
              behavior           => 'string list',
          },
          {
              name               => 'global_variables',
              description        => 'How global (package) variables should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':single_case',  # Matches ProhibitMixedCaseVars
              behavior           => 'string',
          },
          {
              name               => 'global_variable_exemptions',
              description        => 'Global variable names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => '\$VERSION @ISA @EXPORT(?:_OK)? %EXPORT_TAGS \$AUTOLOAD %ENV %SIG \$TODO',  ## no critic (RequireInterpolation)
              behavior           => 'string list',
          },
          {
              name               => 'constants',
              description        => 'How constant names should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':all_upper',
              behavior           => 'string',
          },
          {
              name               => 'constant_exemptions',
              description        => 'Constant names that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => $EMPTY,
              behavior           => 'string list',
          },
          {
              name               => 'labels',
              description        => 'How labels should be capitalized.  Valid values are :single_case, :all_lower, :all_upper, :starts_with_lower, :starts_with_upper, :no_restriction, or a regex.',
              default_string     => ':all_upper',
              behavior           => 'string',
          },
          {
              name               => 'label_exemptions',
              description        => 'Labels that are exempt from capitalization rules.  The values here are regexes that will be surrounded by \A and \z.',
              default_string     => $EMPTY,
              behavior           => 'string list',
          },
      );
  }
  
  sub default_severity    { return $SEVERITY_LOWEST                       }
  sub default_themes      { return qw< core pbp cosmetic >                }
  sub applies_to          { return qw< PPI::Statement PPI::Token::Label > }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      my $configuration_exceptions =
          Perl::Critic::Exception::AggregateConfiguration->new();
  
      KIND:
      foreach my $kind_of_name ( qw<
          package                 subroutine
          local_lexical_variable  scoped_lexical_variable
          file_lexical_variable   global_variable
          constant                label
      > ) {
          my ($capitalization_regex, $message) =
              $self->_derive_capitalization_test_regex_and_message(
                  $kind_of_name, $configuration_exceptions,
              );
          my $exemption_regexes =
              $self->_derive_capitalization_exemption_test_regexes(
                  $kind_of_name, $configuration_exceptions,
              );
  
          # Keep going, despite problems, so that all problems can be reported
          # at one go, rather than the user fixing one problem, receiving a new
          # error, etc..
          next KIND if $configuration_exceptions->has_exceptions();
  
          $self->{"_${kind_of_name}_test"} = sub {
              my ($name) = @_;
  
              return if _name_is_exempt($name, $exemption_regexes);
  
              return $message if $name !~ m/$capitalization_regex/xms;
              return;
          }
      }
  
      if ( $configuration_exceptions->has_exceptions() ) {
          $configuration_exceptions->throw();
      }
  
      return $TRUE;
  }
  
  sub _derive_capitalization_test_regex_and_message {
      my ($self, $kind_of_name, $configuration_exceptions) = @_;
  
      my $capitalization_option = "${kind_of_name}s";
      my $capitalization = $self->{"_$capitalization_option"};
  
      if ( my $tag_properties = $CAPITALIZATION_SCHEME_TAGS{$capitalization} ) {
          return @{$tag_properties}{ qw< regex regex_violation > };
      }
      elsif ($capitalization =~ m< \A : >xms) {
          $configuration_exceptions->add_exception(
              Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(
                  policy          => $self,
                  option_name     => $capitalization_option,
                  option_value    => $capitalization,
                  message_suffix  =>
                          'is not a known capitalization scheme tag. Valid tags are: '
                      .   (join q<, >, sort keys %CAPITALIZATION_SCHEME_TAGS)
                      .   $PERIOD,
              )
          );
          return;
      }
  
      my $regex;
      eval { $regex = qr< \A $capitalization \z >xms; }
          or do {
              $configuration_exceptions->add_exception(
                  Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(
                      policy          => $self,
                      option_name     => $capitalization_option,
                      option_value    => $capitalization,
                      message_suffix  =>
                          "is not a valid regular expression: $EVAL_ERROR",
                  )
              );
              return;
          };
  
      return $regex, qq<does not match "\\A$capitalization\\z".>;
  }
  
  sub _derive_capitalization_exemption_test_regexes {
      my ($self, $kind_of_name, $configuration_exceptions) = @_;
  
      my $exemptions_option = "${kind_of_name}_exemptions";
      my $exemptions = $self->{"_$exemptions_option"};
  
      my @regexes;
  
      PATTERN:
      foreach my $pattern ( keys %{$exemptions} ) {
          my $regex;
          eval { $regex = qr< \A $pattern \z >xms; }
              or do {
                  $configuration_exceptions->add_exception(
                      Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue->new(
                          policy          => $self,
                          option_name     => $exemptions_option,
                          option_value    => $pattern,
                          message_suffix  =>
                              "is not a valid regular expression: $EVAL_ERROR",
                      )
                  );
                  next PATTERN;
              };
  
          push @regexes, $regex;
      }
  
      return \@regexes;
  }
  
  sub _name_is_exempt {
      my ($name, $exemption_regexes) = @_;
  
      foreach my $regex ( @{$exemption_regexes} ) {
          return $TRUE if $name =~ m/$regex/xms;
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # Want given.  Want 5.10.  Gimme gimme gimme.  :]
      if ( $elem->isa('PPI::Statement::Variable') ) {
          return $self->_variable_capitalization($elem);
      }
  
      if ( $elem->isa('PPI::Statement::Sub') ) {
          return $self->_subroutine_capitalization($elem);
      }
  
      if (
          my @names = get_constant_name_elements_from_declaring_statement($elem)
      ) {
          return ( grep { $_ }
              map { $self->_constant_capitalization( $elem, $_ ) } @names )
      }
  
      if ( $elem->isa('PPI::Statement::Package') ) {
          return $self->_package_capitalization($elem);
      }
  
      if (
          $elem->isa('PPI::Statement::Compound') and $elem->type() eq 'foreach'
      ) {
          return $self->_foreach_variable_capitalization($elem);
      }
  
      if ( $elem->isa('PPI::Token::Label') ) {
          return $self->_label_capitalization($elem);
      }
  
      return;
  }
  
  sub _variable_capitalization {
      my ($self, $elem) = @_;
  
      my @violations;
  
      NAME:
      for my $name ( map { $_->symbol() } $elem->symbols() ) {
          if ($elem->type() eq 'local') {
              # Fully qualified names are exempt because we can't be responsible
              # for other people's symbols.
              next NAME if $name =~ m/$PACKAGE_REGEX/xms;
              next NAME if is_perl_global($name);
  
              push
                  @violations,
                  $self->_check_capitalization(
                      symbol_without_sigil($name),
                      $name,
                      'global_variable',
                      $elem,
                  );
          }
          elsif ($elem->type() eq 'our') {
              push
                  @violations,
                  $self->_check_capitalization(
                      symbol_without_sigil($name),
                      $name,
                      'global_variable',
                      $elem,
                  );
          }
          else {
              # Got my or state
              my $parent = $elem->parent();
              if ( not $parent or $parent->isa('PPI::Document') ) {
                  push
                      @violations,
                      $self->_check_capitalization(
                          symbol_without_sigil($name),
                          $name,
                          'file_lexical_variable',
                          $elem,
                      );
              }
              else {
                  if ( _is_directly_in_scope_block($elem) ) {
                      push
                          @violations,
                          $self->_check_capitalization(
                              symbol_without_sigil($name),
                              $name,
                              'scoped_lexical_variable',
                              $elem,
                          );
                  }
                  else {
                      push
                          @violations,
                          $self->_check_capitalization(
                              symbol_without_sigil($name),
                              $name,
                              'local_lexical_variable',
                              $elem,
                          );
                  }
              }
          }
      }
  
      return @violations;
  }
  
  sub _subroutine_capitalization {
      my ($self, $elem) = @_;
  
      # These names are fixed and you've got no choice what to call them.
      return if $elem->isa('PPI::Statement::Scheduled');
  
      my $name = $elem->name();
      $name =~ s{ .* :: }{}smx;  # Allow for "sub Some::Package::foo {}"
  
      return $self->_check_capitalization($name, $name, 'subroutine', $elem);
  }
  
  sub _constant_capitalization {
      my ($self, $elem, $name) = @_;
  
      return $self->_check_capitalization(
          symbol_without_sigil($name), $name, 'constant', $elem,
      );
  }
  
  sub _package_capitalization {
      my ($self, $elem) = @_;
  
      my $namespace = $elem->namespace();
      my @components = split m/::/xms, $namespace;
  
      foreach my $component (@components) {
          my $violation =
              $self->_check_capitalization(
                  $component, $namespace, 'package', $elem,
              );
          return $violation if $violation;
      }
  
      return;
  }
  
  sub _foreach_variable_capitalization {
      my ($self, $elem) = @_;
  
      my $type;
      my $symbol;
      my $second_element = $elem->schild(1);
      return if not $second_element;
  
      if ($second_element->isa('PPI::Token::Word')) {
          $type = $second_element->content();
          $symbol = $second_element->snext_sibling();
      } else {
          $type = 'my';
          $symbol = $second_element;
      }
  
      return if not $symbol;
      return if not $symbol->isa('PPI::Token::Symbol');
  
      my $name = $symbol->symbol();
  
      if ($type eq 'local') {
          # Fully qualified names are exempt because we can't be responsible
          # for other people's symbols.
          return if $name =~ m/$PACKAGE_REGEX/xms;
          return if is_perl_global($name);
  
          return $self->_check_capitalization(
              symbol_without_sigil($name), $name, 'global_variable', $elem,
          );
      }
      elsif ($type eq 'our') {
          return $self->_check_capitalization(
              symbol_without_sigil($name), $name, 'global_variable', $elem,
          );
      }
  
      # Got my or state: treat as local lexical variable
      return $self->_check_capitalization(
          symbol_without_sigil($name), $name, 'local_lexical_variable', $elem,
      );
  }
  
  sub _label_capitalization {
      my ($self, $elem, $name) = @_;
  
      return if _is_not_real_label($elem);
      ( my $label = $elem->content() ) =~ s< \s* : \z ><>xms;
      return $self->_check_capitalization($label, $label, 'label', $elem);
  }
  
  sub _check_capitalization {
      my ($self, $to_match, $full_name, $name_type, $elem) = @_;
  
      my $test = $self->{"_${name_type}_test"};
      if ( my $message = $test->($to_match) ) {
          return $self->violation(
              qq<$NAME_FOR_TYPE{$name_type} "$full_name" $message>,
              $EXPL,
              $elem,
          );
      }
  
      return;
  }
  
  
  # { my $x } parses as
  #       PPI::Document
  #           PPI::Statement::Compound
  #               PPI::Structure::Block   { ... }
  #                   PPI::Statement::Variable
  #                       PPI::Token::Word        'my'
  #                       PPI::Token::Symbol      '$x'
  #                       PPI::Token::Structure   ';'
  #
  # Also, type() on the PPI::Statement::Compound returns "continue".  *sigh*
  #
  # The parameter is expected to be the PPI::Statement::Variable.
  sub _is_directly_in_scope_block {
      my ($elem) = @_;
  
  
      return if is_in_subroutine($elem);
  
      my $parent = $elem->parent();
      return if not $parent->isa('PPI::Structure::Block');
  
      my $grand_parent = $parent->parent();
      return $TRUE if not $grand_parent;
      return $TRUE if $grand_parent->isa('PPI::Document');
  
      return if not $grand_parent->isa('PPI::Statement::Compound');
  
      my $type = $grand_parent->type();
      return if not $type;
      return if $type ne 'continue';
  
      my $great_grand_parent = $grand_parent->parent();
      return if
          $great_grand_parent and not $great_grand_parent->isa('PPI::Document');
  
      # Make sure we aren't really in a continue block.
      my $prior_to_grand_parent = $grand_parent->sprevious_sibling();
      return $TRUE if not $prior_to_grand_parent;
      return $TRUE if not $prior_to_grand_parent->isa('PPI::Token::Word');
      return $prior_to_grand_parent->content() ne 'continue';
  }
  
  sub _is_not_real_label {
      my $elem = shift;
  
      # PPI misparses part of a ternary expression as a label
      # when the token to the left of the ":" is a bareword.
      # See http://rt.cpan.org/Ticket/Display.html?id=41170
      # For example...
      #
      # $foo = $condition ? undef : 1;
      #
      # PPI thinks that "undef" is a label.  To workaround this,
      # I'm going to check that whatever PPI thinks is the label,
      # actually is the first token in the statement.  I believe
      # this should be true for all real labels.
  
      my $stmnt = $elem->statement() || return;
      my $first_child = $stmnt->schild(0) || return;
      return $first_child ne $elem;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords pbp perlstyle Schwern THINGY
  
  =head1 NAME
  
  Perl::Critic::Policy::NamingConventions::Capitalization - Distinguish different program components by case.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic> distribution.
  
  
  =head1 DESCRIPTION
  
  Conway recommends to distinguish different program components by case.
  
  Normal subroutines, methods and variables are all in lower case.
  
      my $foo;            # ok
      my $foo_bar;        # ok
      sub foo {}          # ok
      sub foo_bar {}      # ok
  
      my $Foo;            # not ok
      my $foo_Bar;        # not ok
      sub Foo     {}      # not ok
      sub foo_Bar {}      # not ok
  
  Package and class names are capitalized.
  
      package IO::Thing;     # ok
      package Web::FooBar    # ok
  
      package foo;           # not ok
      package foo::Bar;      # not ok
  
  Constants are in all-caps.
  
      Readonly::Scalar my $FOO = 42;  # ok
  
      Readonly::Scalar my $foo = 42;  # not ok
  
  There are other opinions on the specifics, for example, in
  L<perlstyle|perlstyle>.  This
  policy can be configured to match almost any style that you can think of.
  
  
  =head1 CONFIGURATION
  
  You can specify capitalization rules for the following things:
  C<packages>, C<subroutines>, C<local_lexical_variables>,
  C<scoped_lexical_variables>, C<file_lexical_variables>,
  C<global_variables>, C<constants>, and C<labels>.
  
  C<constants> are things declared via L<constant|constant> or
  L<Readonly|Readonly>.
  
      use constant FOO => 193;
      Readonly::Array my @BAR => qw< a b c >;
  
  C<global_variables> are anything declared using C<local>, C<our>, or
  L<vars|vars>.  C<file_lexical_variables> are variables declared at the
  file scope.
  
  C<scoped_lexical_variables> are variables declared inside bare blocks
  that are outside of any subroutines or other control structures; these
  are usually created to limit scope of variables to a given subset of
  subroutines.  E.g.
  
      sub foo { ... }
  
      {
          my $thingy;
  
          sub bar { ... $thingy ... }
          sub baz { ... $thingy ... }
      }
  
  All other variable declarations are considered
  C<local_lexical_variables>.
  
  Each of the C<packages>, C<subroutines>, C<local_lexical_variables>,
  C<scoped_lexical_variables>, C<file_lexical_variables>,
  C<global_variables>, C<constants>, and C<labels> options can be
  specified as one of C<:single_case>, C<:all_lower>, C<:all_upper:>,
  C<:starts_with_lower>, C<:starts_with_upper>, or C<:no_restriction> or
  a regular expression; any value that does not start with a colon,
  C<:>, is considered to be a regular expression.  The C<:single_case>
  tag means a name can be all lower case or all upper case.  If a
  regular expression is specified, it is surrounded by C<\A> and C<\z>.
  
  C<packages> defaults to C<:starts_with_upper>.  C<subroutines>,
  C<local_lexical_variables>, C<scoped_lexical_variables>,
  C<file_lexical_variables>, and C<global_variables> default to
  C<:single_case>.  And C<constants> and C<labels> default to
  C<:all_upper>.
  
  There are corresponding C<package_exemptions>,
  C<subroutine_exemptions>, C<local_lexical_variable_exemptions>,
  C<scoped_lexical_variable_exemptions>,
  C<file_lexical_variable_exemptions>, C<global_variable_exemptions>,
  C<constant_exemptions>, and C<label_exemptions> options that are lists
  of regular expressions to exempt from the corresponding capitalization
  rule.  These values also end up being surrounded by C<\A> and C<\z>.
  
  C<package_exemptions> defaults to C<main>.  C<global_variable_exemptions>
  defaults to
  C<\$VERSION @ISA @EXPORT(?:_OK)? %EXPORT_TAGS \$AUTOLOAD %ENV %SIG \$TODO>.
  C<subroutine_exemptions> defaults to
  C<AUTOLOAD BUILD BUILDARGS CLEAR CLOSE DELETE DEMOLISH DESTROY EXISTS EXTEND FETCH FETCHSIZE FIRSTKEY GETC NEXTKEY POP PRINT PRINTF PUSH READ READLINE SCALAR SHIFT SPLICE STORE STORESIZE TIEARRAY TIEHANDLE TIEHASH TIESCALAR UNSHIFT UNTIE WRITE>
  which should cover all the standard Perl subroutines plus those from
  L<Moose|Moose>.
  
  For example, if you want all local variables to be in all lower-case
  and global variables to start with "G_" and otherwise not contain
  underscores, but exempt any variable with a name that contains
  "THINGY", you could put the following in your F<.perlcriticrc>:
  
      [NamingConventions::Capitalization]
      local_lexical_variables = :all_lower
      global_variables = G_(?:(?!_)\w)+
      global_variable_exemptions = .*THINGY.*
  
  
  =head1 TODO
  
  Handle C<use vars>.  Treat constant subroutines like constant
  variables.  Handle bareword file handles.  There needs to be "schemes"
  or ways of specifying "perlstyle" or "pbp".  Differentiate lexical
  L<Readonly|Readonly> constants in scopes.
  
  
  =head1 BUGS
  
  This policy won't catch problems with the declaration of C<$y> below:
  
      for (my $x = 3, my $y = 5; $x < 57; $x += 3) {
          ...
      }
  
  
  =head1 AUTHOR
  
  Multiple people
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Michael G Schwern.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_NAMINGCONVENTIONS_CAPITALIZATION

$fatpacked{"Perl/Critic/Policy/NamingConventions/ProhibitAmbiguousNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_NAMINGCONVENTIONS_PROHIBITAMBIGUOUSNAMES';
  package Perl::Critic::Policy::NamingConventions::ProhibitAmbiguousNames;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => [ 48 ];
  
  Readonly::Scalar my $DEFAULT_FORBID =>
      'abstract bases close contract last left no record right second set';
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'forbid',
              description     => 'The variable names that are not to be allowed.',
              default_string  => $DEFAULT_FORBID,
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM         }
  sub default_themes   { return qw(core pbp maintenance) }
  sub applies_to       { return qw(PPI::Statement::Sub
                                   PPI::Statement::Variable) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem->isa('PPI::Statement::Sub') ) {
          my @words = grep { $_->isa('PPI::Token::Word') } $elem->schildren();
          for my $word (@words) {
  
              # strip off any leading "Package::"
              my ($name) = $word =~ m/ (\w+) \z /xms;
              next if not defined $name; # should never happen, right?
  
              if ( exists $self->{_forbid}->{$name} ) {
                  return $self->violation(
                      qq<Ambiguously named subroutine "$name">,
                      $EXPL,
                      $elem,
                  );
              }
          }
          return;    # ok
      }
  
      # PPI::Statement::Variable
  
      # Accumulate them since there can be more than one violation
      # per variable statement
      my @violations;
  
      # TODO: false positive bug - this can erroneously catch the
      # assignment half of a variable statement
  
      my $symbols = $elem->find('PPI::Token::Symbol');
      if ($symbols) {   # this should always be true, right?
          for my $symbol ( @{$symbols} ) {
  
              # Strip off sigil and any leading "Package::"
              # Beware that punctuation vars may have no
              # alphanumeric characters.
  
              my ($name) = $symbol =~ m/ (\w+) \z /xms;
              next if ! defined $name;
  
              if ( exists $self->{_forbid}->{$name} ) {
                  push
                      @violations,
                      $self->violation(
                          qq<Ambiguously named variable "$name">,
                          $EXPL,
                          $elem,
                      );
              }
          }
      }
  
      return @violations;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords bioinformatics
  
  =head1 NAME
  
  Perl::Critic::Policy::NamingConventions::ProhibitAmbiguousNames - Don't use vague variable or subroutine names like 'last' or 'record'.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway lists a collection of English words which are highly ambiguous
  as variable or subroutine names.  For example, C<$last> can mean
  previous or final.
  
  This policy tests against a list of ambiguous words for variable
  names.
  
  
  =head1 CONFIGURATION
  
  The default list of forbidden words is:
  
      abstract bases close contract last left no record right second set
  
  This list can be changed by giving a value for C<forbid> of a series
  of forbidden words separated by spaces.
  
  For example, if you decide that C<bases> is an OK name for variables
  (e.g.  in bioinformatics), then put something like the following in
  C<$HOME/.perlcriticrc>:
  
      [NamingConventions::ProhibitAmbiguousNames]
      forbid = last set left right no abstract contract record second close
  
  
  =head1 BUGS
  
  Currently this policy checks the entire variable and subroutine name,
  not parts of the name.  For example, it catches C<$last> but not
  C<$last_record>.  Hopefully future versions will catch both cases.
  
  Some variable statements will be false positives if they have
  assignments where the right hand side uses forbidden names.  For
  example, in this case the C<last> incorrectly triggers a violation.
  
      my $previous_record = $Foo::last;
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_NAMINGCONVENTIONS_PROHIBITAMBIGUOUSNAMES

$fatpacked{"Perl/Critic/Policy/Objects/ProhibitIndirectSyntax.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_OBJECTS_PROHIBITINDIRECTSYNTAX';
  package Perl::Critic::Policy::Objects::ProhibitIndirectSyntax;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use Perl::Critic::Utils qw{ :severities :classification };
  use Readonly;
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %COMMA => {
      q<,> => 1,
      q{=>} => 1,
  };
  Readonly::Scalar my $DOLLAR => q<$>;
  
  Readonly::Scalar my $DESC => 'Subroutine "%s" called using indirect syntax';
  Readonly::Scalar my $EXPL => [ 349 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name                       => 'forbid',
              description                => 'Indirect method syntax is forbidden for these methods.',
              behavior                   => 'string list',
              list_always_present_values => [ qw{ new } ],
          }
      )
  }
  
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw( core pbp maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'         }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # We are only interested in the functions we have been told to check.
      # Do this before calling is_function_call() because we want to weed
      # out as many candidate tokens as possible before calling it.
      return if not $self->{_forbid}->{$elem->content()};
  
      # Make sure it really is a function call.
      return if not is_function_call($elem);
  
      # Per perlobj, it is only an indirect object call if the next sibling
      # is a word, a scalar symbol, or a block.
      my $object = $elem->snext_sibling() or return;
      return if not (
              $object->isa( 'PPI::Token::Word' )
          or      $object->isa( 'PPI::Token::Symbol' )
              and $DOLLAR eq $object->raw_type()
          or  $object->isa( 'PPI::Structure::Block' )
      );
  
      # Per perlobj, it is not an indirect object call if the operator after
      # the possible indirect object is a comma.
      if ( my $operator = $object->snext_sibling() ) {
          return if
                  $operator->isa( 'PPI::Token::Operator' )
              and $COMMA{ $operator->content() };
      }
  
      my $message = sprintf $DESC, $elem->content();
  
      return $self->violation( $message, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Objects::ProhibitIndirectSyntax - Prohibit indirect object call syntax.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Indirect object syntax is commonly used in other object-oriented languages for
  instantiating objects. Perl allows this, but to say that it supports it may be
  going too far. Instead of writing
  
      my $foo = new Foo;
  
  it is preferable to write
  
      my $foo = Foo->new;
  
  The problem is that Perl needs to make a number of assumptions at compile time
  to disambiguate the first form, so it tends to be fragile and to produce
  hard-to-track-down bugs.
  
  
  =head1 CONFIGURATION
  
  Indirect object syntax is also hard for Perl::Critic to disambiguate, so this
  policy only checks certain subroutine calls. The names of the subroutines can
  be configured using the C<forbid> configuration option:
  
      [Objects::ProhibitIndirectSyntax]
      forbid = create destroy
  
  The C<new> subroutine is configured by default; any additional C<forbid>
  values are in addition to C<new>.
  
  
  =head1 CAVEATS
  
  The general situation can not be handled via static analysis.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Dynamic::NoIndirect|Perl::Critic::Policy::Dynamic::NoIndirect>
  and L<indirect|indirect> both do a better job with this, but they require that you
  compile/execute your code.
  
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Tom Wyant.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
  
PERL_CRITIC_POLICY_OBJECTS_PROHIBITINDIRECTSYNTAX

$fatpacked{"Perl/Critic/Policy/References/ProhibitDoubleSigils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REFERENCES_PROHIBITDOUBLESIGILS';
  package Perl::Critic::Policy::References::ProhibitDoubleSigils;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Double-sigil dereference};
  Readonly::Scalar my $EXPL => [ 228 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return 'PPI::Token::Cast'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem eq q{\\};
  
      my $sib = $elem->snext_sibling;
      return if !$sib;
      if ( ! $sib->isa('PPI::Structure::Block') ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return; #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::References::ProhibitDoubleSigils - Write C<@{ $array_ref }> instead of C<@$array_ref>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  When dereferencing a reference, put braces around the reference to
  separate the sigils.  Especially for newbies, the braces eliminate any
  potential confusion about the relative precedence of the sigils.
  
    push @$array_ref, 'foo', 'bar', 'baz';      #not ok
    push @{ $array_ref }, 'foo', 'bar', 'baz';  #ok
  
    foreach ( keys %$hash_ref ){}               #not ok
    foreach ( keys %{ $hash_ref } ){}           #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REFERENCES_PROHIBITDOUBLESIGILS

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitCaptureWithoutTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCAPTUREWITHOUTTEST';
  package Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :data_conversion :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %CONDITIONAL_OPERATOR => hashify( qw{ && || ? and or xor } );
  Readonly::Hash my %UNAMBIGUOUS_CONTROL_TRANSFER => hashify(
      qw< next last redo return > );
  
  Readonly::Scalar my $DESC => q{Capture variable used outside conditional};
  Readonly::Scalar my $EXPL => [ 253 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return (
          {
              name        => 'exception_source',
              description => 'Names of ways to generate exceptions',
              behavior    => 'string list',
              list_always_present_values => [ qw{ die croak confess } ],
          }
      );
  }
  sub default_severity     { return $SEVERITY_MEDIUM         }
  sub default_themes       { return qw(core pbp maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Magic'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
      # TODO named capture variables
      return if $elem !~ m/\A \$[1-9] \z/xms;
      return if _is_in_conditional_expression($elem);
      return if $self->_is_in_conditional_structure($elem);
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  sub _is_in_conditional_expression {
      my $elem = shift;
  
      # simplistic check: is there a conditional operator between a match and
      # the capture var?
      my $psib = $elem->sprevious_sibling;
      while ($psib) {
          if ($psib->isa('PPI::Token::Operator')) {
              my $op = $psib->content;
              if ( $CONDITIONAL_OPERATOR{ $op } ) {
                  $psib = $psib->sprevious_sibling;
                  while ($psib) {
                      return 1 if ($psib->isa('PPI::Token::Regexp::Match'));
                      return 1 if ($psib->isa('PPI::Token::Regexp::Substitute'));
                      $psib = $psib->sprevious_sibling;
                  }
                  return; # false
              }
          }
          $psib = $psib->sprevious_sibling;
      }
  
      return; # false
  }
  
  sub _is_in_conditional_structure {
      my ( $self, $elem ) = @_;
  
      my $stmt = $elem->statement();
      while ($stmt && $elem->isa('PPI::Statement::Expression')) {
         #return if _is_in_conditional_expression($stmt);
         $stmt = $stmt->statement();
      }
      return if !$stmt;
  
      # Check if any previous statements in the same scope have regexp matches
      my $psib = $stmt->sprevious_sibling;
      while ($psib) {
          if ( $psib->isa( 'PPI::Node' ) and
              my $match = _find_exposed_match_or_substitute( $psib ) ) {
              return _is_control_transfer_to_left( $self, $match, $elem ) ||
                  _is_control_transfer_to_right( $self, $match, $elem );
          }
          $psib = $psib->sprevious_sibling;
      }
  
      # Check for an enclosing 'if', 'unless', 'elsif', 'else', or 'when'
      my $parent = $stmt->parent;
      while ($parent) { # never false as long as we're inside a PPI::Document
          if ($parent->isa('PPI::Statement::Compound') ||
              $parent->isa('PPI::Statement::When' )
          ) {
              return 1;
          }
          elsif ($parent->isa('PPI::Structure')) {
             return 1 if _is_in_conditional_expression($parent);
             return 1 if $self->_is_in_conditional_structure($parent);
             $parent = $parent->parent;
          }
          else {
             last;
          }
      }
  
      return; # fail
  }
  
  # This subroutine returns true if there is a control transfer to the left of
  # the match operation which would bypass the capture variable. The arguments
  # are the match operation and the capture variable.
  sub _is_control_transfer_to_left {
      my ( $self, $match, $elem ) = @_;
      # If a regexp match is found, we succeed if a match failure
      # appears to throw an exception, and fail otherwise. RT 36081
      my $prev = $match->sprevious_sibling() or return;
      while ( not ( $prev->isa( 'PPI::Token::Word' ) &&
              q<unless> eq $prev->content() ) ) {
          $prev = $prev->sprevious_sibling() or return;
      }
      # In this case we analyze the first thing to appear in the parent of the
      # 'unless'. This is the simplest case, and it will not be hard to dream up
      # cases where this is insufficient (e.g. do {something(); die} unless ...)
      my $parent = $prev->parent() or return;
      my $first = $parent->schild( 0 ) or return;
      if ( my $method = _get_method_name( $first ) ) {
          # Methods can also be exception sources.
          return $self->{_exception_source}{ $method->content() };
      }
      return $self->{_exception_source}{ $first->content() } ||
          _unambiguous_control_transfer( $first, $elem );
  }
  
  # This subroutine returns true if there is a control transfer to the right of
  # the match operation which would bypass the capture variable. The arguments
  # are the match operation and the capture variable.
  sub _is_control_transfer_to_right {
      my ( $self, $match, $elem ) = @_;
      # If a regexp match is found, we succeed if a match failure
      # appears to throw an exception, and fail otherwise. RT 36081
      my $oper = $match->snext_sibling() or return;   # fail
      my $oper_content = $oper->content();
      # We do not check 'dor' or '//' because a match failure does not
      # return an undefined value.
      q{or} eq $oper_content
          or q{||} eq $oper_content
          or return;                                  # fail
      my $next = $oper->snext_sibling() or return;    # fail
      if ( my $method = _get_method_name( $next ) ) {
          # Methods can also be exception sources.
          return $self->{_exception_source}{ $method->content() };
      }
      return $self->{_exception_source}{ $next->content() } ||
          _unambiguous_control_transfer( $next, $elem );
  }
  
  # Given a PPI::Node, find the last regexp match or substitution that is
  # in-scope to the node's next sibling.
  sub _find_exposed_match_or_substitute { # RT 36081
      my $elem = shift;
  FIND_REGEXP_NOT_IN_BLOCK:
      foreach my $regexp ( reverse @{ $elem->find(
              sub {
                  return $_[1]->isa( 'PPI::Token::Regexp::Substitute' )
                      || $_[1]->isa( 'PPI::Token::Regexp::Match' );
              }
          ) || [] } ) {
          my $parent = $regexp->parent();
          while ( $parent != $elem ) {
              $parent->isa( 'PPI::Structure::Block' )
                  and next FIND_REGEXP_NOT_IN_BLOCK;
              $parent = $parent->parent()
                  or next FIND_REGEXP_NOT_IN_BLOCK;
          }
          return $regexp;
      }
      return;
  }
  
  # If the argument introduces a method call, return the method name;
  # otherwise just return.
  sub _get_method_name {
      my ( $elem ) = @_;
      # We fail unless the element we were given looks like it might be an
      # object or a class name.
      $elem or return;
      (
          $elem->isa( 'PPI::Token::Symbol' ) &&
          q<$> eq $elem->raw_type() ||
          $elem->isa( 'PPI::Token::Word' ) &&
          $elem->content() =~ m/ \A [\w:]+ \z /smx
      ) or return;
      # We skip over all the subscripts and '->' operators to the right of
      # the original element, failing if we run out of objects.
      my $prior;
      my $next = $elem->snext_sibling() or return;
      while ( $next->isa( 'PPI::Token::Subscript' ) ||
          $next->isa( 'PPI::Token::Operator' ) &&
          q{->} eq $next->content() ) {
          $prior = $next;
          $next = $next->snext_sibling or return; # fail
      }
      # A method call must have a '->' operator before it.
      ( $prior &&
          $prior->isa( 'PPI::Token::Operator' ) &&
          q{->} eq $prior->content()
      ) or return;
      # Anything other than a PPI::Token::Word can not be statically
      # recognized as a method name.
      $next->isa( 'PPI::Token::Word' ) or return;
      # Whatever we have left at this point looks very like a method name.
      return $next;
  }
  
  # Determine whether the given element represents an unambiguous transfer of
  # control around anything that follows it in the same block. The arguments are
  # the element to check, and the capture variable that is the subject of this
  # call to the policy.
  sub _unambiguous_control_transfer { # RT 36081.
      my ( $xfer, $elem ) = @_;
  
      my $content = $xfer->content();
  
      # Anything in the hash is always a transfer of control.
      return $TRUE if $UNAMBIGUOUS_CONTROL_TRANSFER{ $content };
  
      # A goto is not unambiguous on the face of it, but at least some forms of
      # it can be accepted.
      q<goto> eq $content
          and return _unambiguous_goto( $xfer, $elem );
  
      # Anything left at this point is _not_ an unambiguous transfer of control
      # around whatever follows it.
      return;
  }
  
  # Determine whether the given goto represents an unambiguous transfer of
  # control around anything that follows it in the same block. The arguments are
  # the element to check, and the capture variable that is the subject of this
  # call to the policy.
  sub _unambiguous_goto {
      my ( $xfer, $elem ) = @_;
  
      # A goto without a target?
      my $target = $xfer->snext_sibling() or return;
  
      # The co-routine form of goto is an unambiguous transfer of control.
      $target->isa( 'PPI::Token::Symbol' )
          and q<&> eq $target->raw_type()
          and return $TRUE;
  
      # The label form of goto is an unambiguous transfer of control,
      # provided the label does not occur between the goto and the capture
      # variable.
      if ( $target->isa( 'PPI::Token::Word' ) ) {
  
          # We need to search in our most-local block, or the document if
          # there is no enclosing block.
          my $container = $target;
          while ( my $parent = $container->parent() ) {
              $container = $parent;
              $container->isa( 'PPI::Structure::Block' ) and last;
          }
  
          # We search the container for our label. If we find it, we return
          # true if it occurs before the goto or after the capture variable,
          # otherwise we return false. If we do not find it we return true.
          # Note that perl does not seem to consider duplicate labels an
          # error, but also seems to take the first one in the relevant
          # scope when this happens.
          my $looking_for = qr/ \A @{[ $target->content() ]} \s* : \z /smx;
          my ($start_line, $start_char) = @{ $xfer->location() || [] };
          defined $start_line or return;  # document not indexed.
          my ($end_line,   $end_char)   = @{ $elem->location() || [] };
          foreach my $label (
              @{ $container->find( 'PPI::Token::Label' ) || [] } )
          {
              $label->content() =~ m/$looking_for/smx or next;
              my ( $line, $char ) = @{ $label->location() || [] };
              return $TRUE
                  if $line < $start_line ||
                      $line == $start_line && $char < $start_char;
              return $TRUE
                  if $line > $end_line ||
                      $line == $end_line && $char > $end_char;
              return;
          }
          return $TRUE;
      }
  
      # Any other form of goto can not be statically analyzed, and so is not
      # an unambiguous transfer of control around the capture variable.
      return;
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest - Capture variable used outside conditional.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  =head1 DESCRIPTION
  
  If a regexp match fails, then any capture variables (C<$1>, C<$2>,
  ...) will be unaffected.  They will retain whatever old values they may
  have had.  Therefore it's important to check the return value of a match
  before using those variables.
  
      '12312123' =~ /(2)/;
      print $1;    # Prints 2
      '123123123' =~ /(X)/;
      print $1;    # Prints 2, because $1 has not changed.
  
  Note that because the values of C<$1> etc will be unaffected, you cannot
  determine if a match succeeded by checking to see if the capture variables
  have values.
  
      # WRONG
      $str =~ /foo(.+)/;
      if ( $1 ) {
          print "I found $1 after 'foo'";
      }
  
  This policy checks that the previous regexp for which the capture
  variable is in-scope is either in a conditional or causes an exception
  or other control transfer (i.e. C<next>, C<last>, C<redo>, C<return>, or
  sometimes C<goto>) if the match fails.
  
  A C<goto> is only accepted by this policy if it is a co-routine call
  (i.e.  C<goto &foo>) or a C<goto LABEL> where the label does not fall
  between the C<goto> and the capture variable in the scope of the
  C<goto>. A computed C<goto> (i.e. something like C<goto (qw{foo bar
  baz})[$i]>) is not accepted by this policy because its target can not be
  statically determined.
  
  This policy does not check whether that conditional is actually
  testing a regexp result, nor does it check whether a regexp actually
  has a capture in it.  Those checks are too hard.
  
  This policy also does not check arbitrarily complex conditionals guarding
  regexp results, for pretty much the same reason.  Simple things like
  
   m/(foo)/ or die "No foo!";
   die "No foo!" unless m/(foo)/;
  
  will be handled, but something like
  
   m/(foo)/ or do {
     ... lots of complicated calculations here ...
     die "No foo!";
   };
  
  are beyond its scope.
  
  
  =head1 CONFIGURATION
  
  By default, this policy considers C<die>, C<croak>, and C<confess> to
  throw exceptions. If you have additional subroutines or methods that may
  be used in lieu of one of these, you can configure them in your
  perlcriticrc as follows:
  
   [RegularExpressions::ProhibitCaptureWithoutTest]
   exception_source = my_exception_generator
  
  =head1 BUGS
  
  This policy does not recognize named capture variables. Yet.
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2017 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCAPTUREWITHOUTTEST

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitComplexRegexes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCOMPLEXREGEXES';
  package Perl::Critic::Policy::RegularExpressions::ProhibitComplexRegexes;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use List::Util qw{ min };
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Split long regexps into smaller qr// chunks};
  Readonly::Scalar my $EXPL => [261];
  
  Readonly::Scalar my $MAX_LITERAL_LENGTH => 7;
  Readonly::Scalar my $MAX_VARIABLE_LENGTH => 4;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_characters',
              description     =>
                  'The maximum number of characters to allow in a regular expression.',
              default_string  => '60',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core pbp maintenance ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $document ) = @_;
  
      # Optimization: if its short enough now, parsing won't make it longer
      return if $self->{_max_characters} >= length $elem->get_match_string();
  
      my $re = $document->ppix_regexp_from_element( $elem )
          or return;  # Abort on syntax error.
      $re->failures()
          and return; # Abort if parse errors found.
      my $qr = $re->regular_expression()
          or return;  # Abort if no regular expression.
  
      my $length = 0;
      # We use map { $_->tokens() } qr->children() rather than just
      # $qr->tokens() because we are not interested in the delimiters.
      foreach my $token ( map { $_->tokens() } $qr->children() ) {
  
          # Do not count whitespace or comments
          $token->significant() or next;
  
          if ( $token->isa( 'PPIx::Regexp::Token::Interpolation' ) ) {
  
              # Do not penalize long variable names
              $length += min( $MAX_VARIABLE_LENGTH, length $token->content() );
  
          } elsif ( $token->isa( 'PPIx::Regexp::Token::Literal' ) ) {
  
              # Do not penalize long literals like \p{...}
              $length += min( $MAX_LITERAL_LENGTH, length $token->content() );
  
          } else {
  
              # Take everything else at face value
              $length += length $token->content();
  
          }
  
      }
  
      return if $self->{_max_characters} >= $length;
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords BNF Tatsuhiko Miyagawa
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitComplexRegexes - Split long regexps into smaller C<qr//> chunks.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Big regexps are hard to read, perhaps even the hardest part of Perl.
  A good practice to write digestible chunks of regexp and put them
  together.  This policy flags any regexp that is longer than C<N>
  characters, where C<N> is a configurable value that defaults to 60.
  If the regexp uses the C<x> flag, then the length is computed after
  parsing out any comments or whitespace.
  
  Unfortunately the use of descriptive (and therefore longish) variable
  names can cause regexps to be in violation of this policy, so
  interpolated variables are counted as 4 characters no matter how long
  their names actually are.
  
  
  =head1 CASE STUDY
  
  As an example, look at the regexp used to match email addresses in
  L<Email::Valid::Loose|Email::Valid::Loose> (tweaked lightly to wrap
  for POD)
  
      (?x-ism:(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]
      \000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015
      "]*)*")(?:(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[
      \]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n
      \015"]*)*")|\.)*\@(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,
      ;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
      )(?:\.(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000
      -\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]))*)
  
  which is constructed from the following code:
  
      my $esc         = '\\\\';
      my $period      = '\.';
      my $space       = '\040';
      my $open_br     = '\[';
      my $close_br    = '\]';
      my $nonASCII    = '\x80-\xff';
      my $ctrl        = '\000-\037';
      my $cr_list     = '\n\015';
      my $qtext       = qq/[^$esc$nonASCII$cr_list\"]/; # "
      my $dtext       = qq/[^$esc$nonASCII$cr_list$open_br$close_br]/;
      my $quoted_pair = qq<$esc>.qq<[^$nonASCII]>;
      my $atom_char   = qq/[^($space)<>\@,;:\".$esc$open_br$close_br$ctrl$nonASCII]/;# "
      my $atom        = qq<$atom_char+(?!$atom_char)>;
      my $quoted_str  = qq<\"$qtext*(?:$quoted_pair$qtext*)*\">; # "
      my $word        = qq<(?:$atom|$quoted_str)>;
      my $domain_ref  = $atom;
      my $domain_lit  = qq<$open_br(?:$dtext|$quoted_pair)*$close_br>;
      my $sub_domain  = qq<(?:$domain_ref|$domain_lit)>;
      my $domain      = qq<$sub_domain(?:$period$sub_domain)*>;
      my $local_part  = qq<$word(?:$word|$period)*>; # This part is modified
      $Addr_spec_re   = qr<$local_part\@$domain>;
  
  If you read the code from bottom to top, it is quite readable.  And,
  you can even see the one violation of RFC822 that Tatsuhiko Miyagawa
  deliberately put into Email::Valid::Loose to allow periods.  Look for
  the C<|\.> in the upper regexp to see that same deviation.
  
  One could certainly argue that the top regexp could be re-written more
  legibly with C<m//x> and comments.  But the bottom version is
  self-documenting and, for example, doesn't repeat C<\x80-\xff> 18
  times.  Furthermore, it's much easier to compare the second version
  against the source BNF grammar in RFC 822 to judge whether the
  implementation is sound even before running tests.
  
  
  =head1 CONFIGURATION
  
  This policy allows regexps up to C<N> characters long, where C<N>
  defaults to 60.  You can override this to set it to a different number
  with the C<max_characters> setting.  To do this, put entries in a
  F<.perlcriticrc> file like this:
  
      [RegularExpressions::ProhibitComplexRegexes]
      max_characters = 40
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITCOMPLEXREGEXES

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitEnumeratedClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITENUMERATEDCLASSES';
  package Perl::Critic::Policy::RegularExpressions::ProhibitEnumeratedClasses;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use List::MoreUtils qw(all);
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities hashify };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use named character classes};
  Readonly::Scalar my $EXPL => [248];
  
  Readonly::Array my @PATTERNS => (  # order matters: most to least specific
     [q{ },'\\t','\\r','\\n']      => ['\\s', '\\S'],
     ['A-Z','a-z','0-9','_']       => ['\\w', '\\W'], # RT 69322
     ['A-Z','a-z']                 => ['[[:alpha:]]','[[:^alpha:]]'],
     ['A-Z']                       => ['[[:upper:]]','[[:^upper:]]'],
     ['a-z']                       => ['[[:lower:]]','[[:^lower:]]'],
     ['0-9']                       => ['\\d','\\D'],
     ['\w']                        => [undef, '\\W'],
     ['\s']                        => [undef, '\\S'],
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw()                    }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp cosmetic unicode ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  
  sub violates {
      my ( $self, $elem, $document ) = @_;
  
      # optimization: don't bother parsing the regexp if there are no character classes
      return if $elem !~ m/\[/xms;
  
      my $re = $document->ppix_regexp_from_element( $elem ) or return;
      $re->failures() and return;
  
      my $anyofs = $re->find( 'PPIx::Regexp::Structure::CharClass' )
          or return;
      foreach my $anyof ( @{ $anyofs } ) {
          my $violation;
          $violation = $self->_get_character_class_violations( $elem, $anyof )
              and return $violation;
      }
  
      return;  # OK
  }
  
  sub _get_character_class_violations {
      my ($self, $elem, $anyof) = @_;
  
      my %elements;
      foreach my $element ( $anyof->children() ) {
          $elements{ _fixup( $element ) } = 1;
      }
  
      for (my $i = 0; $i < @PATTERNS; $i += 2) {  ##no critic (CStyleForLoop)
          if (all { exists $elements{$_} } @{$PATTERNS[$i]}) {
              my $neg = $anyof->negated();
              my $improvement = $PATTERNS[$i + 1]->[$neg ? 1 : 0];
              next if !defined $improvement;
  
              if ($neg && ! defined $PATTERNS[$i + 1]->[0]) {
                  # the [^\w] => \W rule only applies if \w is the only token.
                  # that is it does not apply to [^\w\s]
                  next if 1 != scalar keys %elements;
              }
  
              my $orig = join q{}, '[', ($neg ? q{^} : ()), @{$PATTERNS[$i]}, ']';
              return $self->violation( $DESC . " ($orig vs. $improvement)", $EXPL, $elem );
          }
      }
  
      return;  # OK
  }
  
  Readonly::Hash my %ORDINALS => (
      ord "\n"    => '\\n',
      ord "\f"    => '\\f',
      ord "\r"    => '\\r',
      ord q< >    => q< >,
  );
  
  sub _fixup {
      my ( $element ) = @_;
      if ( $element->isa( 'PPIx::Regexp::Token::Literal' ) ) {
          my $ord = $element->ordinal();
          exists $ORDINALS{$ord} and return $ORDINALS{$ord};
          return $element->content();
      } elsif ( $element->isa( 'PPIx::Regexp::Node' ) ) {
          return join q{}, map{ _fixup( $_ ) } $element->elements();
      } else {
          return $element->content();
      }
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitEnumeratedClasses - Use named character classes instead of explicit character lists.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This policy is not for everyone!  If you are working in pure ASCII,
  then disable it now or you may see some false violations.
  
  On the other hand many of us are working in a multilingual world with
  an extended character set, probably Unicode.  In that world, patterns
  like C<m/[A-Z]/> can be a source of bugs when you really meant
  C<m/\p{IsUpper}/>.  This policy catches a selection of possible
  incorrect character class usage.
  
  Specifically, the patterns are:
  
  B<C<[\t\r\n\f\ ]>> vs. B<C<\s>>
  
  B<C<[\t\r\n\ ]>> vs. B<C<\s>>   (because many people forget C<\f>)
  
  B<C<[A-Za-z0-9_]>> vs. B<C<\w>>
  
  B<C<[A-Za-z]>> vs. B<C<\p{IsAlphabetic}>>
  
  B<C<[A-Z]>> vs. B<C<\p{IsUpper}>>
  
  B<C<[a-z]>> vs. B<C<\p{IsLower}>>
  
  B<C<[0-9]>> vs. B<C<\d>>
  
  B<C<[^\w]>> vs. B<C<\W>>
  
  B<C<[^\s]>> vs. B<C<\S>>
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITENUMERATEDCLASSES

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitEscapedMetacharacters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITESCAPEDMETACHARACTERS';
  package Perl::Critic::Policy::RegularExpressions::ProhibitEscapedMetacharacters;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use List::MoreUtils qw(any);
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities hashify };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use character classes for literal metachars instead of escapes};
  Readonly::Scalar my $EXPL => [247];
  
  Readonly::Hash my %REGEXP_METACHARS => hashify(split / /xms, '{ } ( ) . * + ? |');
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw()                    }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp cosmetic ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $document ) = @_;
  
      # optimization: don't bother parsing the regexp if there are no escapes
      return if $elem !~ m/\\/xms;
  
      my $re = $document->ppix_regexp_from_element( $elem ) or return;
      $re->failures() and return;
      my $qr = $re->regular_expression() or return;
  
      my $exacts = $qr->find( 'PPIx::Regexp::Token::Literal' ) or return;
      foreach my $exact( @{ $exacts } ) {
          $exact->content() =~ m/ \\ ( . ) /xms or next;
          return $self->violation( $DESC, $EXPL, $elem ) if $REGEXP_METACHARS{$1};
      }
  
      return; # OK
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords IPv4
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitEscapedMetacharacters - Use character classes for literal meta-characters instead of escapes.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Ever heard of leaning toothpick syndrome?  That comes from writing
  regular expressions that match on characters that are significant in
  regular expressions.  For example, the expression to match four
  forward slashes looks like:
  
      m/\/\/\/\//;
  
  Well, this policy doesn't solve that problem (write it as C<m{////}>
  instead!) but solves a related one.  As seen above, the escapes make
  the expression hard to parse visually.  One solution is to use
  character classes.  You see, inside of character classes, the only
  characters that are special are C<\>, C<]>, C<^> and C<->, so you
  don't need to escape the others.  So instead of the following loose
  IPv4 address matcher:
  
      m/ \d+ \. \d+ \. \d+ \. \d+ /x;
  
  You could write:
  
      m/ \d+ [.] \d+ [.] \d+ [.] \d+ /x;
  
  which is certainly more readable, if less recognizable prior the
  publication of Perl Best Practices.  (Of course, you should really use
  L<Regexp::Common::net|Regexp::Common::net> to match IPv4 addresses!)
  
  Specifically, this policy forbids backslashes immediately prior to the
  following characters:
  
      { } ( ) . * + ? | #
  
  We make special exception for C<$> because C</[$]/> turns into
  C</[5.008006/> for Perl 5.8.6.  We also make an exception for C<^>
  because it has special meaning (negation) in a character class.
  Finally, C<[> and C<]> are exempt, of course, because they are awkward
  to represent in character classes.
  
  Note that this policy does not forbid unnecessary escaping.  So go
  ahead and (pointlessly) escape C<!> characters.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 BUGS
  
  Perl treats C<m/[#]/x> in unexpected ways.
  I think it's a bug in Perl itself, but am not 100% sure that I have
  not simply misunderstood...
  
  This part makes sense:
  
      "#f" =~ m/[#]f/x;     # match
      "#f" =~ m/[#]a/x;     # no match
  
  This doesn't:
  
      $qr  = qr/f/;
      "#f" =~ m/[#]$qr/x; # no match
  
  Neither does this:
  
      print qr/[#]$qr/x;  # yields '(?x-ism:[#]$qr
                                  )'
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITESCAPEDMETACHARACTERS

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitFixedStringMatches.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITFIXEDSTRINGMATCHES';
  package Perl::Critic::Policy::RegularExpressions::ProhibitFixedStringMatches;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use English qw(-no_match_vars);
  use Carp;
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Use 'eq' or hash instead of fixed-pattern regexps};
  Readonly::Scalar my $EXPL => [271,272];
  
  Readonly::Scalar my $RE_METACHAR => qr/[\\#\$()*+.?\@\[\]^{|}]/xms;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw()                       }
  sub default_severity     { return $SEVERITY_LOW              }
  sub default_themes       { return qw( core pbp performance ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      my $re = $elem->get_match_string();
  
      # only flag regexps that are anchored front and back
      if ($re =~ m{\A \s*
                   (\\A|\^)  # front anchor == $1
                   (.*?)
                   (\\z|\$)  # end anchor == $2
                   \s* \z}xms) {
  
          my ($front_anchor, $words, $end_anchor) = ($1, $2, $3);
  
          # If it's a multiline match, then end-of-line anchors don't represent the whole string
          if ($front_anchor eq q{^} || $end_anchor eq q{$}) {
              my $regexp = $doc->ppix_regexp_from_element( $elem )
                  or return;
              return if $regexp->modifier_asserted( 'm' );
          }
  
          # check for grouping and optional alternation.  Grouping may or may not capture
          if ($words =~ m{\A \s*
                          [(]              # start group
                            (?:[?]:)?      # optional non-capturing indicator
                            \s* (.*?) \s*  # interior of group
                          [)]              # end of group
                          \s* \z}xms) {
              $words = $1;
              $words =~ s/[|]//gxms; # ignore alternation inside of parens -- just look at words
          }
  
          # Regexps that contain metachars are not fixed strings
          return if $words =~ m/$RE_METACHAR/oxms;
  
          return $self->violation( $DESC, $EXPL, $elem );
  
      } else {
          return; # OK
      }
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitFixedStringMatches - Use C<eq> or hash instead of fixed-pattern regexps.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  A regular expression that matches just a fixed set of constant strings
  is wasteful of performance and is hard on maintainers.  It is much
  more readable and often faster to use C<eq> or a hash to match such
  strings.
  
      # Bad
      my $is_file_function = $token =~ m/\A (?: open | close | read ) \z/xms;
  
      # Faster and more readable
      my $is_file_function = $token eq 'open' ||
                             $token eq 'close' ||
                             $token eq 'read';
  
  For larger numbers of strings, a hash is superior:
  
      # Bad
      my $is_perl_keyword =
          $token =~ m/\A (?: chomp | chop | chr | crypt | hex | index
                             lc | lcfirst | length | oct | ord | ... ) \z/xms;
  
      # Better
      Readonly::Hash my %PERL_KEYWORDS => map {$_ => 1} qw(
          chomp chop chr crypt hex index lc lcfirst length oct ord ...
      );
      my $is_perl_keyword = $PERL_KEYWORD{$token};
  
  Conway also suggests using C<lc()> instead of a case-insensitive match.
  
  
  =head2 VARIANTS
  
  This policy detects both grouped and non-grouped strings.  The
  grouping may or may not be capturing.  The grouped body may or may not
  be alternating.  C<\A> and C<\z> are always considered anchoring which
  C<^> and C<$> are considered anchoring is the C<m> regexp option is
  not in use.  Thus, all of these are violations:
  
      m/^foo$/;
      m/\A foo \z/x;
      m/\A foo \z/xm;
      m/\A(foo)\z/;
      m/\A(?:foo)\z/;
      m/\A(foo|bar)\z/;
      m/\A(?:foo|bar)\z/;
  
  Furthermore, this policy detects violations in C<m//>, C<s///> and
  C<qr//> constructs, as you would expect.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITFIXEDSTRINGMATCHES

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitSingleCharAlternation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITSINGLECHARALTERNATION';
  package Perl::Critic::Policy::RegularExpressions::ProhibitSingleCharAlternation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use List::MoreUtils qw(all);
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :characters :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => [265];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw()                    }
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp performance ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $document ) = @_;
  
      # optimization: don't bother parsing the regexp if there are no pipes
      return if $elem !~ m/[|]/xms;
  
      my $re = $document->ppix_regexp_from_element( $elem ) or return;
      $re->failures() and return;
  
      my @violations;
      foreach my $node ( @{ $re->find_parents( sub {
                  return $_[1]->isa( 'PPIx::Regexp::Token::Operator' )
                  && $_[1]->content() eq q<|>;
              } ) || [] } ) {
  
          my @singles;
          my @alternative;
          foreach my $kid ( $node->children() ) {
              if ( $kid->isa( 'PPIx::Regexp::Token::Operator' )
                  && $kid->content() eq q<|>
              ) {
                  @alternative == 1
                      and $alternative[0]->isa( 'PPIx::Regexp::Token::Literal' )
                      and push @singles, map { $_->content() } @alternative;
                  @alternative = ();
              } elsif ( $kid->significant() ) {
                  push @alternative, $kid;
              }
          }
          @alternative == 1
              and $alternative[0]->isa( 'PPIx::Regexp::Token::Literal' )
              and push @singles, map { $_->content() } @alternative;
  
          if ( 1 < @singles ) {
              my $description =
                    'Use ['
                  . join( $EMPTY, @singles )
                  . '] instead of '
                  . join q<|>, @singles;
              push @violations, $self->violation( $description, $EXPL, $elem );
          }
      }
  
      return @violations;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitSingleCharAlternation - Use C<[abc]> instead of C<a|b|c>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Character classes (like C<[abc]>) are significantly faster than single
  character alternations (like C<(?:a|b|c)>).  This policy complains if
  you have more than one instance of a single character in an
  alternation.  So C<(?:a|the)> is allowed, but C<(?:a|e|i|o|u)> is not.
  
  NOTE: Perl 5.10 (not released as of this writing) has major regexp
  optimizations which may mitigate the performance penalty of
  alternations, which will be rewritten behind the scenes as something
  like character classes.  Consequently, if you are deploying
  exclusively on 5.10, yo might consider ignoring this policy.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITSINGLECHARALTERNATION

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitUnusedCapture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSEDCAPTURE';
  package Perl::Critic::Policy::RegularExpressions::ProhibitUnusedCapture;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use List::MoreUtils qw(none);
  use Readonly;
  use Scalar::Util qw(refaddr);
  
  use Perl::Critic::Exception::Fatal::Internal qw{ throw_internal };
  use Perl::Critic::Utils qw{
      :booleans :characters :severities hashify precedence_of
      split_nodes_on_comma
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $WHILE => q{while};
  
  Readonly::Hash my %CAPTURE_REFERENCE => hashify( qw{ $+ $- } );
  Readonly::Hash my %CAPTURE_REFERENCE_ENGLISH => (
      hashify( qw{ $LAST_PAREN_MATCH $LAST_MATCH_START $LAST_MATCH_END } ),
      %CAPTURE_REFERENCE );
  
  Readonly::Scalar my $DESC => q{Only use a capturing group if you plan to use the captured value};
  Readonly::Scalar my $EXPL => [252];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return qw()                       }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core pbp maintenance ) }
  sub applies_to           {
      return qw< PPI::Token::Regexp::Match PPI::Token::Regexp::Substitute >
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $NUM_CAPTURES_FOR_GLOBAL => 100; # arbitrarily large number
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # optimization: don't bother parsing the regexp if there are no parens
      return if 0 > index $elem->content(), '(';
  
      my $re = $doc->ppix_regexp_from_element( $elem ) or return;
      $re->failures() and return;
  
      my $ncaptures = $re->max_capture_number() or return;
  
      my @captures;  # List of expected captures
      $#captures = $ncaptures - 1;
  
      my %named_captures; # List of expected named captures.
                          # Unlike the numbered capture logic, %named_captures
                          # entries are made undefined when a use of the name is
                          # found. Otherwise two hashes would be needed, one to
                          # become defined when a use is found, and one to hold
                          # the mapping of name to number.
      foreach my $struct ( @{ $re->find( 'PPIx::Regexp::Structure::NamedCapture'
                  ) || [] } ) {
          # There can be more than one capture with the same name, so we need to
          # record all of them. There will be duplications if the 'branch reset'
          # "(?| ... )" pattern is used, but this is benign given how numbered
          # captures are recorded.
          push @{ $named_captures{ $struct->name() } ||= [] }, $struct->number();
      }
  
      # Look for references to the capture in the regex itself
      return if _enough_uses_in_regexp( $re, \@captures, \%named_captures, $doc );
  
      if ( $re->modifier_asserted( 'g' )
              and not _check_if_in_while_condition_or_block( $elem ) ) {
          $ncaptures = $NUM_CAPTURES_FOR_GLOBAL;
          $#captures = $ncaptures - 1;
      }
  
      return if _enough_assignments($elem, \@captures) && !%named_captures;
      return if _is_in_slurpy_array_context($elem) && !%named_captures;
      return if _enough_magic($elem, $re, \@captures, \%named_captures, $doc);
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  # Find uses of both numbered and named capture variables in the regexp itself.
  # Return true if all are used.
  sub _enough_uses_in_regexp {
      my ( $re, $captures, $named_captures, $doc ) = @_;
  
      # Look for references to the capture in the regex itself. Note that this
      # will also find backreferences in the replacement string of s///.
      foreach my $token ( @{ $re->find( 'PPIx::Regexp::Token::Reference' )
              || [] } ) {
          if ( $token->is_named() ) {
              _record_named_capture( $token->name(), $captures, $named_captures );
          } else {
              _record_numbered_capture( $token->absolute(), $captures );
          }
      }
  
      foreach my $token ( @{ $re->find(
          'PPIx::Regexp::Token::Code' ) || [] } ) {
          my $ppi = $token->ppi() or next;
          _check_node_children( $ppi, {
                  regexp              => $re,
                  numbered_captures   => $captures,
                  named_captures      => $named_captures,
                  document            => $doc,
              }, _make_regexp_checker() );
      }
  
      return ( none {not defined} @{$captures} )
          && ( !%{$named_captures} ||
              none {defined} values %{$named_captures} );
  }
  
  sub _enough_assignments {
      my ($elem, $captures) = @_;
  
      # look backward for the assignment operator
      my $psib = $elem->sprevious_sibling;
    SIBLING:
      while (1) {
          return if !$psib;
          if ($psib->isa('PPI::Token::Operator')) {
              last SIBLING if q{=} eq $psib->content;
              return if q{!~} eq $psib->content;
          }
          $psib = $psib->sprevious_sibling;
      }
  
      $psib = $psib->sprevious_sibling;
      return if !$psib;  # syntax error: '=' at the beginning of a statement???
  
      if ($psib->isa('PPI::Token::Symbol')) {
          # @foo = m/(foo)/
          # @$foo = m/(foo)/
          # %foo = m/(foo)/
          # %$foo = m/(foo)/
          return $TRUE if _symbol_is_slurpy($psib);
  
      } elsif ($psib->isa('PPI::Structure::Block')) {
          # @{$foo} = m/(foo)/
          # %{$foo} = m/(foo)/
          return $TRUE if _block_is_slurpy($psib);
  
      } elsif ($psib->isa('PPI::Structure::List')) {
          # () = m/(foo)/
          # ($foo) = m/(foo)/
          # ($foo,$bar) = m/(foo)(bar)/
          # (@foo) = m/(foo)(bar)/
          # ($foo,@foo) = m/(foo)(bar)/
          # ($foo,@$foo) = m/(foo)(bar)/
          # ($foo,@{$foo}) = m/(foo)(bar)/
  
          my @args = $psib->schildren;
          return $TRUE if not @args;   # empty list (perhaps the "goatse" operator) is slurpy
  
          # Forward looking: PPI might change in v1.200 so schild(0) is a
          # PPI::Statement::Expression.
          if ( 1 == @args && $args[0]->isa('PPI::Statement::Expression') ) {
              @args = $args[0]->schildren;
          }
  
          my @parts = split_nodes_on_comma(@args);
        PART:
          for my $i (0 .. $#parts) {
              if (1 == @{$parts[$i]}) {
                  my $var = $parts[$i]->[0];
                  if ($var->isa('PPI::Token::Symbol') || $var->isa('PPI::Token::Cast')) {
                      return $TRUE if _has_array_sigil($var);
                  }
              }
              _record_numbered_capture( $i + 1, $captures );
                      # ith variable capture
          }
      }
  
      return none {not defined} @{$captures};
  }
  
  sub _symbol_is_slurpy {
      my ($symbol) = @_;
  
      return $TRUE if _has_array_sigil($symbol);
      return $TRUE if _has_hash_sigil($symbol);
      return $TRUE if _is_preceded_by_array_or_hash_cast($symbol);
      return;
  }
  
  sub _has_array_sigil {
      my ($elem) = @_;  # Works on PPI::Token::Symbol and ::Cast
  
      return q{@} eq substr $elem->content, 0, 1;
  }
  
  sub _has_hash_sigil {
      my ($elem) = @_;  # Works on PPI::Token::Symbol and ::Cast
  
      return q{%} eq substr $elem->content, 0, 1;
  }
  
  sub _block_is_slurpy {
      my ($block) = @_;
  
      return $TRUE if _is_preceded_by_array_or_hash_cast($block);
      return;
  }
  
  sub _is_preceded_by_array_or_hash_cast {
      my ($elem) = @_;
      my $psib = $elem->sprevious_sibling;
      my $cast;
      while ($psib && $psib->isa('PPI::Token::Cast')) {
          $cast = $psib;
          $psib = $psib->sprevious_sibling;
      }
      return if !$cast;
      my $sigil = substr $cast->content, 0, 1;
      return q{@} eq $sigil || q{%} eq $sigil;
  }
  
  sub _is_in_slurpy_array_context {
      my ($elem) = @_;
  
      # return true is the result of the regexp is passed to a subroutine.
      # doesn't check for array context due to assignment.
  
      # look backward for explicit regex operator
      my $psib = $elem->sprevious_sibling;
      if ($psib && $psib->content eq q{=~}) {
          # Track back through value
          $psib = _skip_lhs($psib);
      }
  
      if (!$psib) {
          my $parent = $elem->parent;
          return if !$parent;
          if ($parent->isa('PPI::Statement')) {
              $parent = $parent->parent;
              return if !$parent;
          }
  
          # Return true if we have a list that isn't part of a foreach loop.
          # TECHNICAL DEBT: This code is basically shared with
          # RequireCheckingReturnValueOfEval.  I don't want to put this code
          # into Perl::Critic::Utils::*, but I don't have time to sort out
          # PPIx::Utilities::Structure::List yet.
          if ( $parent->isa('PPI::Structure::List') ) {
              my $parent_statement = $parent->statement() or return $TRUE;
              return $TRUE if not
                  $parent_statement->isa('PPI::Statement::Compound');
              return $TRUE if $parent_statement->type() ne 'foreach';
          }
  
          return $TRUE if $parent->isa('PPI::Structure::Constructor');
          if ($parent->isa('PPI::Structure::Block')) {
              return $TRUE
                  if
                          refaddr($elem->statement)
                      eq  refaddr([$parent->schildren]->[-1]);
          }
          return;
      }
      if ($psib->isa('PPI::Token::Operator')) {
          # most operators kill slurpiness (except assignment, which is handled elsewhere)
          return $TRUE if q{,} eq $psib->content;
          return;
      }
      return $TRUE;
  }
  
  sub _skip_lhs {
      my ($elem) = @_;
  
      # TODO: better implementation to handle casts, expressions, subcalls, etc.
      $elem = $elem->sprevious_sibling();
  
      return $elem;
  }
  
  sub _enough_magic {
      my ($elem, $re, $captures, $named_captures, $doc) = @_;
  
      _check_for_magic($elem, $re, $captures, $named_captures, $doc);
  
      return ( none {not defined} @{$captures} )
          && ( !%{$named_captures} ||
              none {defined} values %{$named_captures} );
  }
  
  # void return
  sub _check_for_magic {
      my ($elem, $re, $captures, $named_captures, $doc) = @_;
  
      # Search for $1..$9 in :
      #  * the rest of this statement
      #  * subsequent sibling statements
      #  * if this is in a conditional boolean, the if/else bodies of the conditional
      #  * if this is in a while/for condition, the loop body
      # But NO intervening regexps!
  
      # Package up the usual arguments for _check_rest_of_statement().
      my $arg = {
          regexp              => $re,
          numbered_captures   => $captures,
          named_captures      => $named_captures,
          document            => $doc,
      };
  
      # Capture whether or not the regular expression is negated -- that
      # is, whether it is preceded by the '!~' binding operator.
      if ( my $prior_token = $elem->sprevious_sibling() ) {
          $arg->{negated} = $prior_token->isa( 'PPI::Token::Operator' ) &&
              q<!~> eq $prior_token->content();
      }
  
      return if ! _check_rest_of_statement( $elem, $arg );
  
      my $parent = $elem->parent();
      while ($parent && ! $parent->isa('PPI::Statement::Sub')) {
          return if ! _check_rest_of_statement( $parent, $arg );
          $parent = $parent->parent();
      }
  
      return;
  }
  
  # Check if we are in the condition or block of a 'while'
  sub _check_if_in_while_condition_or_block {
      my ( $elem ) = @_;
      $elem or return;
  
      my $parent = $elem->parent() or return;
      $parent->isa( 'PPI::Statement' ) or return;
  
      my $item = $parent = $parent->parent() or return;
      if ( $item->isa( 'PPI::Structure::Block' ) ) {
          $item = $item->sprevious_sibling() or return;
      }
      $item->isa( 'PPI::Structure::Condition' ) or return;
  
      $item = $item->sprevious_sibling() or return;
      $item->isa( 'PPI::Token::Word' ) or return;
  
      return $WHILE eq $item->content();
  }
  
  {
      # Shortcut operators '||', '//', and 'or' can cause everything after
      # them to be skipped. 'and' trumps '||' and '//', and causes things
      # to be evaluated again. The value is true to skip, false to cancel
      # skipping.
      Readonly::Hash my %SHORTCUT_OPERATOR => (
          q<||>   => $FALSE,
          q<//>   => $FALSE,
          and     => $TRUE,
          or      => $FALSE,
      );
  
      # RT #38942
      # The issue in the ticket is that in something like
      #   if ( /(a)/ || /(b) ) {
      #       say $1
      #   }
      # the capture variable can come from either /(a)/ or /(b)/. If we
      # don't take into account the short-cutting nature of the '||' we
      # erroneously conclude that the capture in /(a)/ is not used. So we
      # need to skip every regular expression after an alternation.
      #
      # The trick is that we want to still mark magic variables, because
      # of code like
      #   my $foo = $1 || $2;
      # so we can't just ignore everything after an alternation.
      #
      # To do all this correctly, we have to track precedence, and start
      # paying attention again if an 'and' is found after a '||'.
  
      # Subroutine _make_regexp_checker() manufactures a snippet of code
      # which is used to track regular expressions. It takes one optional
      # argument, which is the snippet used to track the parent object's
      # regular expressions.
      #
      # The snippet is passed each token encountered, and returns true if
      # the scan for capture variables is to be stopped. This will happen
      # if the token is a regular expression which is _not_ to the right
      # of an alternation operator ('||', '//', or 'or'), or it _is_ to
      # the right of an 'and', without an intervening alternation
      # operator.
      #
      # If _make_regexp_checker() was passed a snippet which
      # returns false on encountering a regular expression, the returned
      # snippet always returns false, for the benefit of code like
      #   /(a)/ || ( /(b)/ || /(c)/ ).
  
      sub _make_regexp_checker {
          my ( $parent ) = @_;
  
          $parent
              and not $parent->()
              and return sub { return $FALSE };
  
          my $check = $TRUE;
          my $precedence = 0;
  
          return sub {
              my ( $elem ) = @_;
  
              $elem or return $check;
  
              $elem->isa( 'PPI::Token::Regexp' )
                  and return $check;
  
              if ( $elem->isa( 'PPI::Token::Structure' )
                  && q<;> eq $elem->content() ) {
                  $check       = $TRUE;
                  $precedence  = 0;
                  return $FALSE;
              }
  
              $elem->isa( 'PPI::Token::Operator' )
                  or return $FALSE;
  
              my $content = $elem->content();
              defined( my $oper_check = $SHORTCUT_OPERATOR{$content} )
                  or return $FALSE;
  
              my $oper_precedence = precedence_of( $content );
              $oper_precedence >= $precedence
                  or return $FALSE;
  
              $precedence = $oper_precedence;
              $check = $oper_check;
  
              return $FALSE;
          };
      }
  }
  
  # false if we hit another regexp
  # The arguments are:
  #   $elem - The PPI::Element whose siblings are to be checked;
  #   $arg  - A hash reference containing the following keys:
  #       regexp => the relevant PPIx::Regexp object;
  #       numbered_captures => a reference to the array used to track the
  #           use of numbered captures;
  #       named_captures => a reference to the hash used to track the
  #           use of named captures;
  #       negated => true if the regexp was bound to its target with the
  #           '!~' operator;
  #       document => a reference to the Perl::Critic::Document;
  # Converted to passing the arguments everyone gets in a hash because of
  # the need to add the 'negated' argument, which would put us at six
  # arguments.
  sub _check_rest_of_statement {
      my ( $elem, $arg ) = @_;
  
      my $checker = _make_regexp_checker();
      my $nsib = $elem->snext_sibling;
  
      # If we are an if (or elsif) and the result of the regexp is
      # negated, we skip the first block found. RT #69867
      if ( $arg->{negated} && _is_condition_of_if_statement( $elem ) ) {
          while ( $nsib && ! $nsib->isa( 'PPI::Structure::Block' ) ) {
              $nsib = $nsib->snext_sibling();
          }
          $nsib and $nsib = $nsib->snext_sibling();
      }
  
      while ($nsib) {
          return if $checker->($nsib);
          if ($nsib->isa('PPI::Node')) {
              return if ! _check_node_children($nsib, $arg, $checker );
          } else {
              _mark_magic( $nsib, $arg->{regexp}, $arg->{numbered_captures},
                  $arg->{named_captures}, $arg->{document} );
          }
          $nsib = $nsib->snext_sibling;
      }
      return $TRUE;
  }
  
  {
  
      Readonly::Hash my %IS_IF_STATEMENT => hashify( qw{ if elsif } );
  
      # Return true if the argument is the condition of an if or elsif
      # statement, otherwise return false.
      sub _is_condition_of_if_statement {
          my ( $elem ) = @_;
          $elem
              and $elem->isa( 'PPI::Structure::Condition' )
              or return $FALSE;
          my $psib = $elem->sprevious_sibling()
              or return $FALSE;
          $psib->isa( 'PPI::Token::Word' )
              or return $FALSE;
          return $IS_IF_STATEMENT{ $psib->content() };
  
      }
  }
  
  # false if we hit another regexp
  # The arguments are:
  #   $elem - The PPI::Node whose children are to be checked;
  #   $arg  - A hash reference containing the following keys:
  #       regexp => the relevant PPIx::Regexp object;
  #       numbered_captures => a reference to the array used to track the
  #           use of numbered captures;
  #       named_captures => a reference to the hash used to track the
  #       use of named captures;
  #       document => a reference to the Perl::Critic::Document;
  #   $parent_checker - The parent's regexp checking code snippet,
  #       manufactured by _make_regexp_checker(). This argument is not in
  #       the $arg hash because that hash is shared among levels of the
  #       parse tree, whereas the regexp checker is not.
  # TODO the things in the $arg hash are widely shared among the various
  # pieces/parts of this policy; maybe more subroutines should use this
  # hash rather than passing all this stuff around as individual
  # arguments. This particular subroutine got the hash-reference treatment
  # because Subroutines::ProhibitManyArgs started complaining when the
  # checker argument was added.
  sub _check_node_children {
      my ($elem, $arg, $parent_checker) = @_;
  
      # caveat: this will descend into subroutine definitions...
  
      my $checker = _make_regexp_checker($parent_checker);
      for my $child ($elem->schildren) {
          return if $checker->($child);
          if ($child->isa('PPI::Node')) {
              return if ! _check_node_children($child, $arg, $checker);
          } else {
              _mark_magic($child, $arg->{regexp},
                  $arg->{numbered_captures}, $arg->{named_captures},
                  $arg->{document});
          }
      }
      return $TRUE;
  }
  
  sub _mark_magic {
      my ($elem, $re, $captures, $named_captures, $doc) = @_;
  
      # If we're a double-quotish element, we need to grub through its
      # content. RT #38942
      if ( _is_double_quotish_element( $elem ) ) {
          _mark_magic_in_content(
              $elem->content(), $re, $captures, $named_captures, $doc );
          return;
      }
  
      # Ditto a here document, though the logic is different. RT #38942
      if ( $elem->isa( 'PPI::Token::HereDoc' ) ) {
          $elem->content() =~ m/ \A << \s* ' /sxm
              or _mark_magic_in_content(
              join( $EMPTY, $elem->heredoc() ), $re, $captures,
              $named_captures, $doc );
          return;
      }
  
      # Only interested in magic, or known English equivalent.
      my $content = $elem->content();
      my $capture_ref = $doc->uses_module( 'English' ) ?
          \%CAPTURE_REFERENCE_ENGLISH :
          \%CAPTURE_REFERENCE;
      $elem->isa( 'PPI::Token::Magic' )
          or $capture_ref->{$content}
          or return;
  
      if ( $content =~ m/ \A \$ ( \d+ ) /xms ) {
  
          # Record if we see $1, $2, $3, ...
          my $num = $1;
          if (0 < $num) { # don't mark $0
              # Only mark the captures we really need -- don't mark superfluous magic vars
              if ($num <= @{$captures}) {
                  _record_numbered_capture( $num, $captures );
              }
          }
      } elsif ( $capture_ref->{$content} ) {
          _mark_magic_subscripted_code( $elem, $re, $captures, $named_captures );
      }
      return;
  }
  
  # Record a named capture referenced by a hash or array found in code.
  # The arguments are:
  #    $elem - The element that represents a subscripted capture variable;
  #    $re - The PPIx::Regexp object;
  #    $captures - A reference to the numbered capture array;
  #    $named_captures - A reference to the named capture hash.
  sub _mark_magic_subscripted_code {
      my ( $elem, $re, $captures, $named_captures ) = @_;
      my $subscr = $elem->snext_sibling() or return;
      $subscr->isa( 'PPI::Structure::Subscript' ) or return;
      my $subval = $subscr->content();
      _record_subscripted_capture(
          $elem->content(), $subval, $re, $captures, $named_captures );
      return;
  }
  
  # Find capture variables in the content of a double-quotish thing, and
  # record their use. RT #38942. The arguments are:
  #    $content - The content() ( or heredoc() in the case of a here
  #                document) to be analyzed;
  #    $re - The PPIx::Regexp object;
  #    $captures - A reference to the numbered capture array;
  #    $named_captures - A reference to the named capture hash.
  sub _mark_magic_in_content {
      my ( $content, $re, $captures, $named_captures, $doc ) = @_;
  
      my $capture_ref = $doc->uses_module( 'English' ) ?
          \%CAPTURE_REFERENCE_ENGLISH :
          \%CAPTURE_REFERENCE;
  
      while ( $content =~ m< ( \$ (?:
          [{] (?: \w+ | . ) [}] | \w+ | . ) ) >sxmg ) {
          my $name = $1;
          $name =~ s/ \A \$ [{] /\$/sxm;
          $name =~ s/ [}] \z //sxm;
  
          if ( $name =~ m/ \A \$ ( \d+ ) \z /sxm ) {
  
              my $num = $1;
              0 < $num
                  and $num <= @{ $captures }
                  and _record_numbered_capture( $num, $captures );
  
          } elsif ( $capture_ref->{$name} &&
              $content =~ m/ \G ( [{] [^}]+ [}] | [[] [^]] []] ) /smxgc )
          {
              _record_subscripted_capture(
                  $name, $1, $re, $captures, $named_captures );
  
          }
      }
      return;
  }
  
  # Return true if the given element is double-quotish. Always returns
  # false for a PPI::Token::HereDoc, since they're a different beast.
  # RT #38942.
  sub _is_double_quotish_element {
      my ( $elem ) = @_;
  
      $elem or return;
  
      my $content = $elem->content();
  
      if ( $elem->isa( 'PPI::Token::QuoteLike::Command' ) ) {
          return $content !~ m/ \A qx \s* ' /sxm;
      }
  
      foreach my $class ( qw{
              PPI::Token::Quote::Double
              PPI::Token::Quote::Interpolate
              PPI::Token::QuoteLike::Backtick
              PPI::Token::QuoteLike::Readline
          } ) {
          $elem->isa( $class ) and return $TRUE;
      }
  
      return $FALSE;
  }
  
  # Record a subscripted capture, either hash dereference or array
  # dereference. We assume that an array represents a numbered capture and
  # a hash represents a named capture, since we have to handle (e.g.) both
  # @+ and %+.
  sub _record_subscripted_capture {
      my ( $variable_name, $suffix, $re, $captures, $named_captures ) = @_;
      if ( $suffix =~ m/ \A [{] ( .*? ) [}] /smx ) {
          ( my $name = $1 ) =~ s/ \A ( ["'] ) ( .*? ) \1 \z /$2/smx;
          _record_named_capture( $name, $captures, $named_captures );
      } elsif ( $suffix =~ m/ \A [[] \s* ( [-+]? \d+ ) \s* []] /smx ) {
          _record_numbered_capture( $1 . q{}, $captures, $re );
      }
      return;
  }
  
  # Because a named capture is also one or more numbered captures, the recording
  # of the use of a named capture seemed complex enough to wrap in a subroutine.
  sub _record_named_capture {
      my ( $name, $captures, $named_captures ) = @_;
      defined ( my $numbers = $named_captures->{$name} ) or return;
      foreach my $capnum ( @{ $numbers } ) {
          _record_numbered_capture( $capnum, $captures );
      }
      $named_captures->{$name} = undef;
      return;
  }
  
  sub _record_numbered_capture {
      my ( $number, $captures, $re ) = @_;
      $re and $number < 0
          and $number = $re->max_capture_number() + $number + 1;
      return if $number <= 0;
      $captures->[ $number - 1 ] = 1;
      return;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords refactored
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitUnusedCapture - Only use a capturing group if you plan to use the captured value.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl regular expressions have multiple types of grouping syntax.  The
  basic parentheses (e.g. C<m/(foo)/>) captures into the magic variable
  C<$1>.  Non-capturing groups (e.g. C<m/(?:foo)/> are useful because
  they have better runtime performance and do not copy strings to the
  magic global capture variables.
  
  It's also easier on the maintenance programmer if you consistently use
  capturing vs. non-capturing groups, because that programmer can tell
  more easily which regexps can be refactored without breaking
  surrounding code which may use the captured values.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CAVEATS
  
  =head2 C<qr//> interpolation
  
  This policy can be confused by interpolation of C<qr//> elements, but
  those are always false negatives.  For example:
  
      my $foo_re = qr/(foo)/;
      my ($foo) = m/$foo_re (bar)/x;
  
  A human can tell that this should be a violation because there are two
  captures but only the first capture is used, not the second.  The
  policy only notices that there is one capture in the regexp and
  remains happy.
  
  =head2 C<@->, C<@+>, C<$LAST_MATCH_START> and C<$LAST_MATCH_END>
  
  This policy will only recognize capture groups referred to by these
  variables if the use is subscripted by a literal integer.
  
  =head2 C<$^N> and C<$LAST_SUBMATCH_RESULT>
  
  This policy will not recognize capture groups referred to only by these
  variables, because there is in general no way by static analysis to
  determine which capture group is referred to.  For example,
  
      m/ (?: (A[[:alpha:]]+) | (N\d+) ) (?{$foo=$^N}) /smx
  
  makes use of the first capture group if it matches, or the second
  capture group if the first does not match but the second does.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSEDCAPTURE

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitUnusualDelimiters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSUALDELIMITERS';
  package Perl::Critic::Policy::RegularExpressions::ProhibitUnusualDelimiters;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use English qw(-no_match_vars);
  use Carp;
  
  use Perl::Critic::Utils qw{ :booleans :severities hashify };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Use only '//' or '{}' to delimit regexps>;
  Readonly::Scalar my $EXPL => [246];
  
  Readonly::Array my @EXTRA_BRACKETS => qw{ () [] <> };
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name               => 'allow_all_brackets',
              description        =>
                  q[In addition to allowing '{}', allow '()', '[]', and '{}'.],
              behavior           => 'boolean',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp cosmetic ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ( $self, $config ) = @_;
  
      my %delimiters = hashify( qw< // {} > );
      if ( $self->{_allow_all_brackets} ) {
          @delimiters{ @EXTRA_BRACKETS } = (1) x @EXTRA_BRACKETS;
      }
  
      $self->{_allowed_delimiters} = \%delimiters;
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $allowed_delimiters = $self->{_allowed_delimiters};
      foreach my $delimiter ($elem->get_delimiters()) {
          next if $allowed_delimiters->{$delimiter};
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return;  # OK
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitUnusualDelimiters - Use only C<//> or C<{}> to delimit regexps.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl lets you delimit regular expressions with almost any character,
  but most choices are illegible.  Compare these equivalent expressions:
  
    s/foo/bar/;   # good
    s{foo}{bar};  # good
    s#foo#bar#;   # bad
    s;foo;bar;;   # worse
    s|\|\||\||;   # eye-gouging bad
  
  
  =head1 CONFIGURATION
  
  There is one option for this policy, C<allow_all_brackets>.  If this
  is true, then, in addition to allowing C<//> and C<{}>, the other
  matched pairs of C<()>, C<[]>, and C<< <> >> are allowed.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUNUSUALDELIMITERS

$fatpacked{"Perl/Critic/Policy/RegularExpressions/ProhibitUselessTopic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUSELESSTOPIC';
  package Perl::Critic::Policy::RegularExpressions::ProhibitUselessTopic;
  
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :ppi };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  ## no critic ( ValuesAndExpressions::RequireInterpolationOfMetachars )
  ## The numerous $_ variables make false positives.
  Readonly::Scalar my $DESC => q{Useless use of $_};
  Readonly::Scalar my $EXPL => q{$_ should be omitted when matching a regular expression};
  
  sub supported_parameters { return () }
  sub default_severity     { return $SEVERITY_LOW }
  sub default_themes       { return qw( core ) }
  sub applies_to           { return 'PPI::Token::Magic' }
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $content = $elem->content;
      if ( $content eq q{$_} ) {
          # Is there an op following the $_ ?
          my $op_node = $elem->snext_sibling;
          if ( $op_node && $op_node->isa('PPI::Token::Operator') ) {
              # If the op is a regex match, then we have an unnecessary $_ .
              my $op = $op_node->content;
              if ( $op eq q{=~} || $op eq q{!~} ) {
                  my $target_node = $op_node->snext_sibling;
                  if ( $target_node && ($target_node->isa('PPI::Token::Regexp') || $target_node->isa('PPI::Token::QuoteLike::Regexp')) ) {
                      return $self->violation( $DESC, $EXPL, $elem );
                  }
              }
          }
      }
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::ProhibitUselessTopic - Don't use $_ to match against regexes.
  
  =head1 AFFILIATION
  
  This Policy is part of the L<Perl::Critic|Perl::Critic> distribution.
  
  =head1 DESCRIPTION
  
  It is not necessary to specify the topic variable C<$_> when matching
  against a regular expression.
  
  Match or substitution operations are performed against variables, such as:
  
      $x =~ /foo/;
      $x =~ s/foo/bar/;
      $x =~ tr/a-mn-z/n-za-m/;
  
  If a variable is not specified, the match is against C<$_>.
  
      # These are identical.
      /foo/;
      $_ =~ /foo/;
  
      # These are identical.
      s/foo/bar/;
      $_ =~ s/foo/bar/;
  
      # These are identical.
      tr/a-mn-z/n-za-m/;
      $_ =~ tr/a-mn-z/n-za-m/;
  
  This applies to negative matching as well.
  
      # These are identical
      if ( $_ !~ /DEBUG/ ) { ...
      if ( !/DEBUG ) { ...
  
  Including the C<$_ =~> or C<$_ !~> is unnecessary, adds complexity,
  and is not idiomatic Perl.
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  =head1 AUTHOR
  
  Andy Lester <andy@petdance.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2013 Andy Lester <andy@petdance.com>
  
  This library is free software; you can redistribute it and/or modify it
  under the terms of the Artistic License 2.0.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_PROHIBITUSELESSTOPIC

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireBracesForMultiline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREBRACESFORMULTILINE';
  package Perl::Critic::Policy::RegularExpressions::RequireBracesForMultiline;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use English qw(-no_match_vars);
  use Carp;
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Use '{' and '}' to delimit multi-line regexps>;
  Readonly::Scalar my $EXPL => [242];
  
  Readonly::Array my @EXTRA_BRACKETS => qw{ () [] <> };
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name               => 'allow_all_brackets',
              description        =>
                  q[In addition to allowing '{}', allow '()', '[]', and '{}'.],
              behavior           => 'boolean',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_LOWEST        }
  sub default_themes       { return qw( core pbp cosmetic ) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ( $self, $config ) = @_;
  
      my %delimiters = ( q<{}> => 1 );
      if ( $self->{_allow_all_brackets} ) {
          @delimiters{ @EXTRA_BRACKETS } = (1) x @EXTRA_BRACKETS;
      }
  
      $self->{_allowed_delimiters} = \%delimiters;
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $re = $elem->get_match_string();
      return if $re !~ m/\n/xms;
  
      my ($match_delim) = $elem->get_delimiters();
      return if $self->{_allowed_delimiters}{$match_delim};
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::RequireBracesForMultiline - Use C<{> and C<}> to delimit multi-line regexps.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Long regular expressions are hard to read.  A good practice is to use
  the C<x> modifier and break the regex into multiple lines with
  comments explaining the parts.  But, with the usual C<//> delimiters,
  the beginning and end can be hard to match, especially in a C<s///>
  regexp.  Instead, try using C<{}> characters to delimit your
  expressions.
  
  Compare these:
  
      s/
         <a \s+ href="([^"]+)">
          (.*?)
         </a>
       /link=$1, text=$2/xms;
  
  vs.
  
      s{
         <a \s+ href="([^"]+)">
          (.*?)
         </a>
       }
       {link=$1, text=$2}xms;
  
  Is that an improvement?  Marginally, but yes.  The curly braces lead
  the eye better.
  
  
  =head1 CONFIGURATION
  
  There is one option for this policy, C<allow_all_brackets>.  If this
  is true, then, in addition to allowing C<{}>, the other matched pairs
  of C<()>, C<[]>, and C<< <> >> are allowed.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREBRACESFORMULTILINE

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireDotMatchAnything.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREDOTMATCHANYTHING';
  package Perl::Critic::Policy::RegularExpressions::RequireDotMatchAnything;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Regular expression without "/s" flag};
  Readonly::Scalar my $EXPL => [ 240, 241 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw<core pbp cosmetic> }
  sub applies_to           { return qw<PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp> }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      my $re = $doc->ppix_regexp_from_element( $elem )
          or return;
      $re->modifier_asserted( 's' )
          or return $self->violation( $DESC, $EXPL, $elem );
  
      return; #ok!;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::RequireDotMatchAnything - Always use the C</s> modifier with regular expressions.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  When asked what C<.> in a regular expression means, most people will
  say that it matches any character, which isn't true.  It's actually
  shorthand for C<[^\n]>.  Using the C<s> modifier makes C<.> act like
  people expect it to.
  
      my $match = m< foo.bar >xm;  # not ok
      my $match = m< foo.bar >xms; # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  Be cautious about slapping modifier flags onto existing regular
  expressions, as they can drastically alter their meaning.  See
  L<http://www.perlmonks.org/?node_id=484238> for an interesting
  discussion on the effects of blindly modifying regular expression
  flags.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer  <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREDOTMATCHANYTHING

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireExtendedFormatting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREEXTENDEDFORMATTING';
  package Perl::Critic::Policy::RegularExpressions::RequireExtendedFormatting;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Regular expression without "/x" flag};
  Readonly::Scalar my $EXPL => [ 236 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name               => 'minimum_regex_length_to_complain_about',
              description        =>
                  q<The number of characters that a regular expression must contain before this policy will complain.>,
              behavior           => 'integer',
              default_string     => '0',
              integer_minimum    => 0,
          },
          {
              name               => 'strict',
              description        =>
                  q<Should regexes that only contain whitespace and word characters be complained about?>,
              behavior           => 'boolean',
              default_string     => '0',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw< core pbp maintenance > }
  sub applies_to           {
      return qw<
          PPI::Token::Regexp::Match
          PPI::Token::Regexp::Substitute
          PPI::Token::QuoteLike::Regexp
      >;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      my $match = $elem->get_match_string();
      return if length $match <= $self->{_minimum_regex_length_to_complain_about};
      return if not $self->{_strict} and $match =~ m< \A [\s\w]* \z >xms;
  
      my $re = $doc->ppix_regexp_from_element( $elem )
          or return;
      $re->modifier_asserted( 'x' )
          or return $self->violation( $DESC, $EXPL, $elem );
  
      return; # ok!;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::RequireExtendedFormatting - Always use the C</x> modifier with regular expressions.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Extended regular expression formatting allows you mix whitespace and
  comments into the pattern, thus making them much more readable.
  
      # Match a single-quoted string efficiently...
  
      m{'[^\\']*(?:\\.[^\\']*)*'};  #Huh?
  
      # Same thing with extended format...
  
      m{
          '           # an opening single quote
          [^\\']      # any non-special chars (i.e. not backslash or single quote)
          (?:         # then all of...
              \\ .    #    any explicitly backslashed char
              [^\\']* #    followed by an non-special chars
          )*          # ...repeated zero or more times
          '           # a closing single quote
      }x;
  
  
  =head1 CONFIGURATION
  
  You might find that putting a C</x> on short regular expressions to be
  excessive.  An exception can be made for them by setting
  C<minimum_regex_length_to_complain_about> to the minimum match length
  you'll allow without a C</x>.  The length only counts the regular
  expression, not the braces or operators.
  
      [RegularExpressions::RequireExtendedFormatting]
      minimum_regex_length_to_complain_about = 5
  
      $num =~ m<(\d+)>;              # ok, only 5 characters
      $num =~ m<\d\.(\d+)>;          # not ok, 9 characters
  
  This option defaults to 0.
  
  Because using C</x> on a regex which has whitespace in it can make it
  harder to read (you have to escape all that innocent whitespace), by
  default, you can have a regular expression that only contains
  whitespace and word characters without the modifier.  If you want to
  restrict this, turn on the C<strict> option.
  
      [RegularExpressions::RequireExtendedFormatting]
      strict = 1
  
      $string =~ m/Basset hounds got long ears/;  # no longer ok
  
  This option defaults to false.
  
  
  =head1 NOTES
  
  For common regular expressions like e-mail addresses, phone numbers,
  dates, etc., have a look at the L<Regexp::Common|Regexp::Common> module.
  Also, be cautions about slapping modifier flags onto existing regular
  expressions, as they can drastically alter their meaning.  See
  L<http://www.perlmonks.org/?node_id=484238> for an interesting
  discussion on the effects of blindly modifying regular expression
  flags.
  
  
  =head1 TO DO
  
  Add an exemption for regular expressions that contain C<\Q> at the
  front and don't use C<\E> until the very end, if at all.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer  <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIREEXTENDEDFORMATTING

$fatpacked{"Perl/Critic/Policy/RegularExpressions/RequireLineBoundaryMatching.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIRELINEBOUNDARYMATCHING';
  package Perl::Critic::Policy::RegularExpressions::RequireLineBoundaryMatching;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Regular expression without "/m" flag};
  Readonly::Scalar my $EXPL => [ 237 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return qw(PPI::Token::Regexp::Match
                                       PPI::Token::Regexp::Substitute
                                       PPI::Token::QuoteLike::Regexp) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      my $re = $doc->ppix_regexp_from_element( $elem )
          or return;
      $re->modifier_asserted( 'm' )
          or return $self->violation( $DESC, $EXPL, $elem );
  
      return; #ok!;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::RegularExpressions::RequireLineBoundaryMatching - Always use the C</m> modifier with regular expressions.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Folks coming from a C<sed> or C<awk> background tend to assume that
  C<'$'> and C<'^'> match the beginning and end of the line, rather than
  then beginning and end of the string.  Adding the '/m' flag to your
  regex makes it behave as most people expect it should.
  
      my $match = m{ ^ $pattern $ }x;  #not ok
      my $match = m{ ^ $pattern $ }xm; #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  For common regular expressions like e-mail addresses, phone numbers,
  dates, etc., have a look at the L<Regexp::Common|Regexp::Common> module.
  Also, be cautions about slapping modifier flags onto existing regular
  expressions, as they can drastically alter their meaning.  See
  L<http://www.perlmonks.org/?node_id=484238> for an interesting
  discussion on the effects of blindly modifying regular expression
  flags.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer  <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_REGULAREXPRESSIONS_REQUIRELINEBOUNDARYMATCHING

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitAmpersandSigils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITAMPERSANDSIGILS';
  package Perl::Critic::Policy::Subroutines::ProhibitAmpersandSigils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities hashify };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC  => q{Subroutine called with "&" sigil};
  Readonly::Scalar my $EXPL  => [ 175 ];
  
  Readonly::Hash my %EXEMPTIONS =>
      hashify( qw< defined exists goto sort > );
  
  Readonly::Hash my %IS_COMMA =>
      hashify( q{,}, q{=>} );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                       }
  sub default_severity     { return $SEVERITY_LOW            }
  sub default_themes       { return qw(core pbp maintenance) }
  sub applies_to           { return 'PPI::Token::Symbol'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $previous = $elem->sprevious_sibling();
      if ( $previous ) {
          #Sigil is allowed if taking a reference, e.g. "\&my_sub"
          return if $previous->isa('PPI::Token::Cast') && $previous eq q{\\};
      }
  
      return if ( $elem !~ m{\A [&] }xms ); # ok
  
      # look up past parens to get say the "defined" in "defined(&foo)" or
      # "defined((&foo))" etc
      if (not $previous or
              $previous->isa( 'PPI::Token::Operator' ) and
              $IS_COMMA{ $previous->content() } ) {
          my $up = $elem;
  
          PARENT:
          while (
                  ($up = $up->parent)
              and (
                      $up->isa('PPI::Statement::Expression')
                  or  $up->isa('PPI::Structure::List')
                  or  $up->isa('PPI::Statement')
              )
          ) {
              if (my $word = $up->sprevious_sibling) {
                  # Since backslashes distribute over lists (per perlref), if
                  # we have a list and the previous is a backslash, we're cool.
                  return if
                          $up->isa('PPI::Structure::List')
                      &&  $word->isa('PPI::Token::Cast')
                      &&  $word->content() eq q{\\};
  
                  # For a word set $previous to have it checked against %EXEMPTIONS
                  # below.  For a non-word it's a violation, leave $previous false
                  # to get there.
                  if ($word->isa('PPI::Token::Word')) {
                      $previous = $word;
                  }
                  last PARENT;
              }
          }
      }
      return if $previous and $EXEMPTIONS{$previous};
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitAmpersandSigils - Don't call functions with a leading ampersand sigil.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Since Perl 5, the ampersand sigil is completely optional when invoking
  subroutines.  It also turns off checking of subroutine prototypes.
  It's easily confused with the bitwise 'and' operator.
  
    @result = &some_function(); # not ok
    @result = some_function();  # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITAMPERSANDSIGILS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitBuiltinHomonyms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITBUILTINHOMONYMS';
  package Perl::Critic::Policy::Subroutines::ProhibitBuiltinHomonyms;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion
                              :classification :characters };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array my @ALLOW => qw( import AUTOLOAD DESTROY );
  Readonly::Hash my %ALLOW => hashify( @ALLOW );
  Readonly::Scalar my $DESC  => q{Subroutine name is a homonym for builtin %s %s};
  Readonly::Scalar my $EXPL  => [177];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_HIGH        }
  sub default_themes       { return qw( core bugs pbp certrule )   }
  sub applies_to           { return 'PPI::Statement::Sub' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem->isa('PPI::Statement::Scheduled'); #e.g. BEGIN, INIT, END
      return if exists $ALLOW{ $elem->name() };
  
      my $homonym_type = $EMPTY;
      if ( is_perl_builtin( $elem ) ) {
          $homonym_type = 'function';
      }
      elsif ( is_perl_bareword( $elem ) ) {
          $homonym_type = 'keyword';
      }
      else {
          return;    #ok!
      }
  
      my $desc = sprintf $DESC, $homonym_type, $elem->name();
      return $self->violation($desc, $EXPL, $elem);
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords perlfunc perlsyn
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitBuiltinHomonyms - Don't declare your own C<open> function.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Common sense dictates that you shouldn't declare subroutines with the same
  name as one of Perl's built-in functions or keywords.  See
  L<perlfunc|perlfunc> for a list of built-in functions; see L<perlsyn|perlsyn>
  for keywords.
  
    sub open {}    #not ok
    sub exit {}    #not ok
    sub print {}   #not ok
    sub foreach {} #not ok
    sub if {}      #not ok
  
    #You get the idea...
  
  Exceptions are made for C<BEGIN>, C<END>, C<INIT> and C<CHECK> blocks,
  as well as C<AUTOLOAD>, C<DESTROY>, and C<import> subroutines.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 CAVEATS
  
  It is reasonable to declare an B<object> method with the same name as
  a Perl built-in function, since they are easily distinguished from
  each other.  However, at this time, Perl::Critic cannot tell whether a
  subroutine is static or an object method.
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITBUILTINHOMONYMS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitExcessComplexity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXCESSCOMPLEXITY';
  package Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion :classification };
  use Perl::Critic::Utils::McCabe qw{ calculate_mccabe_of_sub };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Consider refactoring};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_mccabe',
              description     => 'The maximum complexity score allowed.',
              default_string  => '20',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM                }
  sub default_themes   { return qw(core complexity maintenance) }
  sub applies_to       { return 'PPI::Statement::Sub'           }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $score = calculate_mccabe_of_sub( $elem );
  
      # Is it too complex?
      return if $score <= $self->{_max_mccabe};
  
      my $desc;
      if ( my $name = $elem->name() ) {
          $desc = qq<Subroutine "$name" with high complexity score ($score)>;
      }
      else {
          $desc = qq<Anonymous subroutine with high complexity score ($score)>;
      }
  
      return $self->violation( $desc, $EXPL, $elem );
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords McCabe
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitExcessComplexity - Minimize complexity by factoring code into smaller subroutines.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  All else being equal, complicated code is more error-prone and more
  expensive to maintain than simpler code.  The first step towards
  managing complexity is to establish formal complexity metrics.  One
  such metric is the McCabe score, which describes the number of
  possible paths through a subroutine.  This Policy approximates the
  McCabe score by summing the number of conditional statements and
  operators within a subroutine.  Research has shown that a McCabe score
  higher than 20 is a sign of high-risk, potentially untestable code.
  See L<http://en.wikipedia.org/wiki/Cyclomatic_complexity>
  for some discussion about the McCabe number and other complexity
  metrics.
  
  The usual prescription for reducing complexity is to refactor code
  into smaller subroutines.  Mark Dominus book "Higher Order Perl" also
  describes callbacks, recursion, memoization, iterators, and other
  techniques that help create simple and extensible Perl code.
  
  =head1 CONFIGURATION
  
  The maximum acceptable McCabe can be set with the C<max_mccabe>
  configuration item.  Any subroutine with a McCabe score higher than
  this number will generate a policy violation.  The default is 20.  An
  example section for a F<.perlcriticrc>:
  
    [Subroutines::ProhibitExcessComplexity]
    max_mccabe = 30
  
  =head1 NOTES
  
  
    "Everything should be made as simple as possible, but no simpler."
  
                                                    -- Albert Einstein
  
  
  Complexity is subjective, but formal complexity metrics are still
  incredibly valuable.  Every problem has an inherent level of
  complexity, so it is not necessarily optimal to minimize the McCabe
  number.  So don't get offended if your code triggers this Policy.
  Just consider if there B<might> be a simpler way to get the job done.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXCESSCOMPLEXITY

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitExplicitReturnUndef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXPLICITRETURNUNDEF';
  package Perl::Critic::Policy::Subroutines::ProhibitExplicitReturnUndef;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"return" statement with explicit "undef"};
  Readonly::Scalar my $EXPL => [ 199 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                 }
  sub default_severity     { return $SEVERITY_HIGHEST  }
  sub default_themes       { return qw(core pbp bugs certrec )  }
  sub applies_to           { return 'PPI::Token::Word' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem->content() ne 'return';
      return if is_hash_key($elem);
  
      my $sib = $elem->snext_sibling();
      return if !$sib;
      return if !$sib->isa('PPI::Token::Word');
      return if $sib->content() ne 'undef';
  
      # Must be 'return undef'
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitExplicitReturnUndef - Return failure with bare C<return> instead of C<return undef>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Returning C<undef> upon failure from a subroutine is pretty common.
  But if the subroutine is called in list context, an explicit C<return
  undef;> statement will return a one-element list containing
  C<(undef)>.  Now if that list is subsequently put in a boolean context
  to test for failure, then it evaluates to true.  But you probably
  wanted it to be false.
  
    sub read_file {
        my $file = shift;
        -f $file || return undef;  #file doesn't exist!
  
        #Continue reading file...
    }
  
    #and later...
  
    if ( my @data = read_file($filename) ){
  
        # if $filename doesn't exist,
        # @data will be (undef),
        # but I'll still be in here!
  
        process(@data);
    }
    else{
  
        # This is my error handling code.
        # I probably want to be in here
        # if $filname doesn't exist.
  
        die "$filename not found";
    }
  
  The solution is to just use a bare C<return> statement whenever you
  want to return failure.  In list context, Perl will then give you an
  empty list (which is false), and C<undef> in scalar context (which is
  also false).
  
    sub read_file {
        my $file = shift;
        -f $file || return;  #DWIM!
  
        #Continue reading file...
    }
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  You can fool this policy pretty easily by hiding C<undef> in a boolean
  expression.  But don't bother trying.  In fact, using return values to
  indicate failure is pretty poor technique anyway.  Consider using
  C<die> or C<croak> with C<eval>, or the L<Error|Error> module for a
  much more robust exception-handling model.  Conway has a real nice
  discussion on error handling in chapter 13 of PBP.
  
  
  =head1 SEE ALSO
  
  There's a discussion of the appropriateness of this policy at
  L<http://perlmonks.org/index.pl?node_id=741847>.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITEXPLICITRETURNUNDEF

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitManyArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITMANYARGS';
  package Perl::Critic::Policy::Subroutines::ProhibitManyArgs;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use File::Spec;
  use List::Util qw(first);
  use List::MoreUtils qw(uniq any);
  use English qw(-no_match_vars);
  use Carp;
  
  use Perl::Critic::Utils qw{ :booleans :severities split_nodes_on_comma };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $AT => q{@};
  Readonly::Scalar my $AT_ARG => q{@_}; ## no critic (InterpolationOfMetachars)
  
  Readonly::Scalar my $DESC => q{Too many arguments};
  Readonly::Scalar my $EXPL => [182];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_arguments',
              description     =>
                  'The maximum number of arguments to allow a subroutine to have.',
              default_string  => '5',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core pbp maintenance ) }
  sub applies_to           { return 'PPI::Statement::Sub'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # forward declaration?
      return if !$elem->block;
  
      my $num_args;
      if ($elem->prototype) {
          my $prototype = $elem->prototype();
          $prototype =~ s/ \\ [[] .*? []] /*/smxg;    # Allow for grouping
          $num_args = $prototype =~ tr/$@%&*_+/$@%&*_+/;    # RT 56627
      } else {
         $num_args = _count_args($elem->block->schildren);
      }
  
      if ($self->{_max_arguments} < $num_args) {
         return $self->violation( $DESC, $EXPL, $elem );
      }
      return;  # OK
  }
  
  sub _count_args {
      my @statements = @_;
  
      # look for these patterns:
      #    " ... = @_;"    => then examine previous variable list
      #    " ... = shift;" => counts as one arg, then look for more
  
      return 0 if !@statements;  # no statements
  
      my $statement = shift @statements;
      my @elements = $statement->schildren();
      my $operand = pop @elements;
      while ($operand && $operand->isa('PPI::Token::Structure') && q{;} eq $operand->content()) {
         $operand = pop @elements;
      }
      return 0 if !$operand;
  
      #print "pulled off last, remaining: '@elements'\n";
      my $operator = pop @elements;
      return 0 if !$operator;
      return 0 if !$operator->isa('PPI::Token::Operator');
      return 0 if q{=} ne $operator->content();
  
      if ($operand->isa('PPI::Token::Magic') && $AT_ARG eq $operand->content()) {
         return _count_list_elements(@elements);
      } elsif ($operand->isa('PPI::Token::Word') && 'shift' eq $operand->content()) {
         return 1 + _count_args(@statements);
      }
  
      return 0;
  }
  
  sub _count_list_elements {
     my @elements = @_;
  
     my $list = pop @elements;
     return 0 if !$list;
     return 0 if !$list->isa('PPI::Structure::List');
     my @inner = $list->schildren;
     if (1 == @inner && $inner[0]->isa('PPI::Statement::Expression')) {
        @inner = $inner[0]->schildren;
     }
     return scalar split_nodes_on_comma(@inner);
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords refactored
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitManyArgs - Too many arguments.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Subroutines that expect large numbers of arguments are hard to use
  because programmers routinely have to look at documentation to
  remember the order of those arguments.  Many arguments is often a sign
  that a subroutine should be refactored or that an object should be
  passed to the routine.
  
  
  =head1 CONFIGURATION
  
  By default, this policy allows up to 5 arguments without warning.  To
  change this threshold, put entries in a F<.perlcriticrc> file like
  this:
  
    [Subroutines::ProhibitManyArgs]
    max_arguments = 6
  
  
  =head1 CAVEATS
  
  PPI doesn't currently detect anonymous subroutines, so we don't check
  those.  This should just work when PPI gains that feature.
  
  We don't check for C<@ARG>, the alias for C<@_> from English.pm.
  That's deprecated anyway.
  
  
  =head1 TO DO
  
  Don't include C<$self> and C<$class> in the count.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITMANYARGS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitNestedSubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITNESTEDSUBS';
  package Perl::Critic::Policy::Subroutines::ProhibitNestedSubs;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Nested named subroutine};
  Readonly::Scalar my $EXPL =>
      q{Declaring a named sub inside another named sub does not prevent the }
          . q{inner sub from being global};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_HIGHEST     }
  sub default_themes       { return qw(core bugs)         }
  sub applies_to           { return 'PPI::Statement::Sub' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
  
      return if $elem->isa('PPI::Statement::Scheduled');
  
      my $inner = $elem->find_first(
          sub {
              return
                      $_[1]->isa('PPI::Statement::Sub')
                  &&  ! $_[1]->isa('PPI::Statement::Scheduled');
          }
      );
      return if not $inner;
  
      # Must be a violation...
      return $self->violation($DESC, $EXPL, $inner);
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords RJBS SIGNES
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitNestedSubs - C<sub never { sub correct {} }>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  B<Attention would-be clever Perl writers (including Younger RJBS):>
  
  This does not do what you think:
  
    sub do_something {
        ...
        sub do_subprocess {
            ...
        }
        ...
    }
  
  C<do_subprocess()> is global, despite where it is declared.  Either
  write your subs without nesting or use anonymous code references.
  
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTE
  
  Originally part of L<Perl::Critic::Tics|Perl::Critic::Tics>.
  
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Ricardo SIGNES.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITNESTEDSUBS

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitReturnSort.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITRETURNSORT';
  package Perl::Critic::Policy::Subroutines::ProhibitReturnSort;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"return" statement followed by "sort"};
  Readonly::Scalar my $EXPL => q{Behavior is undefined if called in scalar context};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                 }
  sub default_severity     { return $SEVERITY_HIGHEST  }
  sub default_themes       { return qw(core bugs certrule )      }
  sub applies_to           { return 'PPI::Token::Word' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem->content() ne 'return';
      return if is_hash_key($elem);
  
      my $sib = $elem->snext_sibling();
      return if !$sib;
      return if !$sib->isa('PPI::Token::Word');
      return if $sib->content() ne 'sort';
  
      # Must be 'return sort'
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords Ulrich Wisser
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitReturnSort - Behavior of C<sort> is not defined if called in scalar context.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  =head1 DESCRIPTION
  
  The behavior of the builtin C<sort> function is not defined if called
  in scalar context.  So if you write a subroutine that directly
  C<return>s the result of a C<sort> operation, then you code will
  behave unpredictably if someone calls your subroutine in a scalar
  context.  This Policy emits a violation if the C<return> keyword
  is directly followed by the C<sort> function.  To safely return a
  sorted list of values from a subroutine, you should assign the
  sorted values to a temporary variable first.  For example:
  
     sub frobulate {
  
         return sort @list;  # not ok!
  
         my @sorted_list = sort @list;
         return @sorted_list # OK
     }
  
  =head1 KNOWN BUGS
  
  This Policy is not sensitive to the C<wantarray> function.  So the
  following code would generate a false violation:
  
     sub frobulate {
  
         if (wantarray) {
             return sort @list;
         }
         else{
             return join @list;
         }
     }
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  =head1 CREDITS
  
  This Policy was suggested by Ulrich Wisser and the L<http://iis.se> team.
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2017 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITRETURNSORT

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitSubroutinePrototypes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITSUBROUTINEPROTOTYPES';
  package Perl::Critic::Policy::Subroutines::ProhibitSubroutinePrototypes;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Subroutine prototypes used};
  Readonly::Scalar my $EXPL => [ 194 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_HIGHEST     }
  sub default_themes       { return qw(core pbp bugs certrec )     }
  sub applies_to           { return 'PPI::Statement::Sub' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem->prototype() ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitSubroutinePrototypes - Don't write C<sub my_function (@@) {}>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Contrary to common belief, subroutine prototypes do not enable
  compile-time checks for proper arguments.  Don't use them.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITSUBROUTINEPROTOTYPES

$fatpacked{"Perl/Critic/Policy/Subroutines/ProhibitUnusedPrivateSubroutines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITUNUSEDPRIVATESUBROUTINES';
  package Perl::Critic::Policy::Subroutines::ProhibitUnusedPrivateSubroutines;
  
  use 5.006001;
  
  use strict;
  use warnings;
  
  use English qw< $EVAL_ERROR -no_match_vars >;
  use List::MoreUtils qw(any);
  use Readonly;
  
  use Perl::Critic::Utils qw{
      :characters hashify is_function_call is_method_call :severities
      $EMPTY $TRUE
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC =>
      q{Private subroutine/method '%s' declared but not used};
  Readonly::Scalar my $EXPL => q{Eliminate dead code};
  
  Readonly::Hash my %IS_COMMA => hashify( $COMMA, $FATCOMMA );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'private_name_regex',
              description     => 'Pattern that determines what a private subroutine is.',
              default_string  => '\b_\w+\b',  ## no critic (RequireInterpolationOfMetachars)
              behavior        => 'string',
              parser          => \&_parse_regex_parameter,
          },
          {
              name            => 'allow',
              description     =>
                  q<Subroutines matching the private name regex to allow under this policy.>,
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
          {
              name            => 'skip_when_using',
              description     =>
                  q<Modules that, if used within a file, will cause the policy to be disabled for this file>,
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
          {
              name            => 'allow_name_regex',
              description     =>
                  q<Pattern defining private subroutine names that are always allowed>,
              default_string  => $EMPTY,
              behavior        => 'string',
              parser          => \&_parse_regex_parameter,
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance certrec ) }
  sub applies_to           { return 'PPI::Statement::Sub'  }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_regex_parameter {
      my ($self, $parameter, $config_string) = @_;
      defined $config_string
          or $config_string = $parameter->get_default_string();
  
      my $regex;
      eval { $regex = qr/$config_string/; 1 } ## no critic (RegularExpressions)
          or $self->throw_parameter_value_exception(
              $parameter,
              $config_string,
              undef,
              "is not a valid regular expression: $EVAL_ERROR",
          );
  
      $self->__set_parameter_value($parameter, $regex);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $document ) = @_;
  
      my @skip_modules = keys %{ $self->{_skip_when_using} };
      return if any { $document->uses_module($_) } @skip_modules;
  
      # Not interested in forward declarations, only the real thing.
      $elem->forward() and return;
  
      # Not interested in subs without names.
      my $name = $elem->name() or return;
  
      # If the sub is shoved into someone else's name space, we wimp out.
      $name =~ m/ :: /smx and return;
  
      # If the name is explicitly allowed, we just return (OK).
      $self->{_allow}{$name} and return;
  
      # Allow names that match the 'allow_name_regex' pattern.
      if ($self->{_allow_name_regex}) {
          $name =~ m/ \A $self->{_allow_name_regex} \z /smx and return;
      }
  
      # If the name is not an anonymous subroutine according to our definition,
      # we just return (OK).
      $name =~ m/ \A $self->{_private_name_regex} \z /smx or return;
  
      # If the subroutine is called in the document, just return (OK).
      $self->_find_sub_call_in_document( $elem, $document ) and return;
  
      # If the subroutine is referred to in the document, just return (OK).
      $self->_find_sub_reference_in_document( $elem, $document ) and return;
  
      # If the subroutine is used in an overload, just return (OK).
      $self->_find_sub_overload_in_document( $elem, $document ) and return;
  
      # No uses of subroutine found. Return a violation.
      return $self->violation( sprintf( $DESC, $name ), $EXPL, $elem );
  }
  
  
  # Basically the spaceship operator for token locations. The arguments are the
  # two tokens to compare. If either location is unavailable we return undef.
  sub _compare_token_locations {
      my ( $left_token, $right_token ) = @_;
      my $left_loc = $left_token->location() or return;
      my $right_loc = $right_token->location() or return;
      return $left_loc->[0] <=> $right_loc->[0] ||
          $left_loc->[1] <=> $right_loc->[1];
  }
  
  # Find out if the subroutine defined in $elem is called in $document. Calls
  # inside the subroutine itself do not count.
  sub _find_sub_call_in_document {
      my ( $self, $elem, $document ) = @_;
  
      my $start_token = $elem->first_token();
      my $finish_token = $elem->last_token();
      my $name = $elem->name();
  
      if ( my $found = $document->find( 'PPI::Token::Word' ) ) {
          foreach my $usage ( @{ $found } ) {
              $name eq $usage->content() or next;
              is_function_call( $usage )
                  or is_method_call( $usage )
                  or next;
              _compare_token_locations( $usage, $start_token ) < 0
                  and return $TRUE;
              _compare_token_locations( $finish_token, $usage ) < 0
                  and return $TRUE;
          }
      }
  
      foreach my $regexp ( _find_regular_expressions( $document ) ) {
  
          _compare_token_locations( $regexp, $start_token ) >= 0
              and _compare_token_locations( $finish_token, $regexp ) >= 0
              and next;
          _find_sub_usage_in_regexp( $name, $regexp, $document )
              and return $TRUE;
  
      }
  
      return;
  }
  
  # Find analyzable regular expressions in the given document. This means
  # matches, substitutions, and the qr{} operator.
  sub _find_regular_expressions {
      my ( $document ) = @_;
  
      return ( map { @{ $document->find( $_ ) || [] } } qw{
          PPI::Token::Regexp::Match
          PPI::Token::Regexp::Substitute
          PPI::Token::QuoteLike::Regexp
      } );
  }
  
  # Find out if the subroutine named in $name is called in the given $regexp.
  # This could happen either by an explicit s/.../.../e, or by interpolation
  # (i.e. @{[...]} ).
  sub _find_sub_usage_in_regexp {
      my ( $name, $regexp, $document ) = @_;
  
      my $ppix = $document->ppix_regexp_from_element( $regexp ) or return;
      $ppix->failures() and return;
  
      foreach my $code ( @{ $ppix->find( 'PPIx::Regexp::Token::Code' ) || [] } ) {
          my $doc = $code->ppi() or next;
  
          foreach my $word ( @{ $doc->find( 'PPI::Token::Word' ) || [] } ) {
              $name eq $word->content() or next;
              is_function_call( $word )
                  or is_method_call( $word )
                  or next;
              return $TRUE;
          }
  
      }
  
      return;
  }
  
  # Find out if the subroutine defined in $elem handles an overloaded operator.
  # We recognize both string literals (the usual form) and words (in case
  # someone perversely followed the subroutine name by a fat comma). We ignore
  # the '\&_foo' construction, since _find_sub_reference_in_document() should
  # find this.
  sub _find_sub_overload_in_document {
      my ( $self, $elem, $document ) = @_;
  
      my $name = $elem->name();
  
      if ( my $found = $document->find( 'PPI::Statement::Include' ) ) {
          foreach my $usage ( @{ $found } ) {
              'overload' eq $usage->module() or next;
              my $inx;
              foreach my $arg ( _get_include_arguments( $usage ) ) {
                  $inx++ % 2 or next;
                  @{ $arg } == 1 or next;
                  my $element = $arg->[0];
  
                  if ( $element->isa( 'PPI::Token::Quote' ) ) {
                      $element->string() eq $name and return $TRUE;
                  } elsif ( $element->isa( 'PPI::Token::Word' ) ) {
                      $element->content() eq $name and return $TRUE;
                  }
              }
          }
      }
  
      return;
  }
  
  # Find things of the form '&_foo'. This includes both references proper (i.e.
  # '\&foo'), calls using the sigil, and gotos. The latter two do not count if
  # inside the subroutine itself.
  sub _find_sub_reference_in_document {
      my ( $self, $elem, $document ) = @_;
  
      my $start_token = $elem->first_token();
      my $finish_token = $elem->last_token();
      my $symbol = q<&> . $elem->name();
  
      if ( my $found = $document->find( 'PPI::Token::Symbol' ) ) {
          foreach my $usage ( @{ $found } ) {
              $symbol eq $usage->content() or next;
  
              my $prior = $usage->sprevious_sibling();
              $prior
                  and $prior->isa( 'PPI::Token::Cast' )
                  and q<\\> eq $prior->content()
                  and return $TRUE;
  
              is_function_call( $usage )
                  or $prior
                      and $prior->isa( 'PPI::Token::Word' )
                      and 'goto' eq $prior->content()
                  or next;
  
              _compare_token_locations( $usage, $start_token ) < 0
                  and return $TRUE;
              _compare_token_locations( $finish_token, $usage ) < 0
                  and return $TRUE;
          }
      }
  
      return;
  }
  
  # Expand the given element, losing any brackets along the way. This is
  # intended to be used to flatten the argument list of 'use overload'.
  sub _expand_element {
      my ( $element ) = @_;
      $element->isa( 'PPI::Node' )
          and return ( map { _expand_element( $_ ) } $_->children() );
      $element->significant() and return $element;
      return;
  }
  
  # Given an include statement, return its arguments. The return is a flattened
  # list of lists of tokens, each list of tokens representing an argument.
  sub _get_include_arguments {
      my ($include) = @_;
  
      # If there are no arguments, just return. We flatten the list because
      # someone might use parens to define it.
      my @arguments = map { _expand_element( $_ ) } $include->arguments()
          or return;
  
      my @elements;
      my $inx = 0;
      foreach my $element ( @arguments ) {
          if ( $element->isa( 'PPI::Token::Operator' ) &&
              $IS_COMMA{$element->content()} ) {
              $inx++;
          } else {
              push @{ $elements[$inx] ||= [] }, $element;
          }
      }
  
      return @elements;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProhibitUnusedPrivateSubroutines - Prevent unused private subroutines.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  By convention Perl authors (like authors in many other languages)
  indicate private methods and variables by inserting a leading
  underscore before the identifier.  This policy catches such subroutines
  which are not used in the file which declares them.
  
  This module defines a 'use' of a subroutine as a subroutine or method call to
  it (other than from inside the subroutine itself), a reference to it (i.e.
  C<< my $foo = \&_foo >>), a C<goto> to it outside the subroutine itself (i.e.
  C<goto &_foo>), or the use of the subroutine's name as an even-numbered
  argument to C<< use overload >>.
  
  
  =head1 CONFIGURATION
  
  You can define what a private subroutine name looks like by specifying
  a regular expression for the C<private_name_regex> option in your
  F<.perlcriticrc>:
  
      [Subroutines::ProhibitUnusedPrivateSubroutines]
      private_name_regex = _(?!_)\w+
  
  The above example is a way of saying that subroutines that start with
  a double underscore are not considered to be private.  (Perl::Critic,
  in its implementation, uses leading double underscores to indicate a
  distribution-private subroutine -- one that is allowed to be invoked by
  other Perl::Critic modules, but not by anything outside of
  Perl::Critic.)
  
  You can configure additional subroutines to accept by specifying them
  in a space-delimited list to the C<allow> option:
  
      [Subroutines::ProhibitUnusedPrivateSubroutines]
      allow = _bar _baz
  
  These are added to the default list of exemptions from this policy. So the
  above allows C<< sub _bar {} >> and C<< sub _baz {} >>, even if they are not
  referred to in the module that defines them.
  
  You can allow a whole class or subroutine names by defining a a regular
  expression that matches allowed names.
  
      [Subroutines::ProhibitUnusedPrivateSubroutines]
      allow_name_regex = _build_\w+
  
  You can configure this policy not to check private subroutines declared in a
  file that uses one or more particular named modules.  This allows you to, for
  example, exclude unused private subroutine checking in classes that are roles.
  
      [Subroutines::ProhibitUnusedPrivateSubroutines]
      skip_when_using = Moose::Role Moo::Role Role::Tiny
  
  
  =head1 HISTORY
  
  This policy is derived from
  L<Perl::Critic::Policy::Subroutines::ProtectPrivateSubs|Perl::Critic::Policy::Subroutines::ProtectPrivateSubs>,
  which looks at the other side of the problem.
  
  
  =head1 BUGS
  
  Does not forbid C<< sub Foo::_foo{} >> because it does not know (and can not
  assume) what is in the C<Foo> package.
  
  Does not respect the scope caused by multiple packages in the same file.  For
  example a file:
  
      package Foo;
      sub _is_private { print "A private sub!"; }
  
      package Bar;
      _is_private();
  
  Will not trigger a violation even though C<Foo::_is_private> is not called.
  Similarly, C<skip_when_using> currently works on a I<file> level, not on a
  I<package scope> level.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Subroutines::ProtectPrivateSubs|Perl::Critic::Policy::Subroutines::ProtectPrivateSubs>.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Thomas R. Wyant, III.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROHIBITUNUSEDPRIVATESUBROUTINES

$fatpacked{"Perl/Critic/Policy/Subroutines/ProtectPrivateSubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_PROTECTPRIVATESUBS';
  package Perl::Critic::Policy::Subroutines::ProtectPrivateSubs;
  
  use 5.006001;
  
  use strict;
  use warnings;
  
  use English qw< $EVAL_ERROR -no_match_vars >;
  use Readonly;
  
  use Perl::Critic::Utils qw<
      :severities $EMPTY is_function_call is_method_call
  >;
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Private subroutine/method used>;
  Readonly::Scalar my $EXPL => q<Use published APIs>;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'private_name_regex',
              description     => 'Pattern that determines what a private subroutine is.',
              default_string  => '\b_\w+\b',  ## no critic (RequireInterpolationOfMetachars)
              behavior        => 'string',
              parser          => \&_parse_private_name_regex,
          },
          {
              name            => 'allow',
              description     =>
                  q<Subroutines matching the private name regex to allow under this policy.>,
              default_string  => $EMPTY,
              behavior        => 'string list',
              list_always_present_values => [ qw<
                  POSIX::_PC_CHOWN_RESTRICTED
                  POSIX::_PC_LINK_MAX
                  POSIX::_PC_MAX_CANON
                  POSIX::_PC_MAX_INPUT
                  POSIX::_PC_NAME_MAX
                  POSIX::_PC_NO_TRUNC
                  POSIX::_PC_PATH_MAX
                  POSIX::_PC_PIPE_BUF
                  POSIX::_PC_VDISABLE
                  POSIX::_POSIX_ARG_MAX
                  POSIX::_POSIX_CHILD_MAX
                  POSIX::_POSIX_CHOWN_RESTRICTED
                  POSIX::_POSIX_JOB_CONTROL
                  POSIX::_POSIX_LINK_MAX
                  POSIX::_POSIX_MAX_CANON
                  POSIX::_POSIX_MAX_INPUT
                  POSIX::_POSIX_NAME_MAX
                  POSIX::_POSIX_NGROUPS_MAX
                  POSIX::_POSIX_NO_TRUNC
                  POSIX::_POSIX_OPEN_MAX
                  POSIX::_POSIX_PATH_MAX
                  POSIX::_POSIX_PIPE_BUF
                  POSIX::_POSIX_SAVED_IDS
                  POSIX::_POSIX_SSIZE_MAX
                  POSIX::_POSIX_STREAM_MAX
                  POSIX::_POSIX_TZNAME_MAX
                  POSIX::_POSIX_VDISABLE
                  POSIX::_POSIX_VERSION
                  POSIX::_SC_ARG_MAX
                  POSIX::_SC_CHILD_MAX
                  POSIX::_SC_CLK_TCK
                  POSIX::_SC_JOB_CONTROL
                  POSIX::_SC_NGROUPS_MAX
                  POSIX::_SC_OPEN_MAX
                  POSIX::_SC_PAGESIZE
                  POSIX::_SC_SAVED_IDS
                  POSIX::_SC_STREAM_MAX
                  POSIX::_SC_TZNAME_MAX
                  POSIX::_SC_VERSION
                  POSIX::_exit
              > ],
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Word'     }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_private_name_regex {
      my ($self, $parameter, $config_string) = @_;
  
      defined $config_string
          or $config_string = $parameter->get_default_string();
  
      my $regex;
      eval { $regex = qr/$config_string/; 1 } ## no critic (RegularExpressions)
          or $self->throw_parameter_value_exception(
              'private_name_regex',
              $config_string,
              undef,
              "is not a valid regular expression: $EVAL_ERROR",
          );
  
      $self->__set_parameter_value($parameter, $regex);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( my $prior = $elem->sprevious_sibling() ) {
          my $prior_name = $prior->content();
          return if $prior_name eq 'package';
          return if $prior_name eq 'require';
          return if $prior_name eq 'use';
      }
  
      if (
              $self->_is_other_pkg_private_function($elem)
          or  $self->_is_other_pkg_private_method($elem)
      ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return;  # ok!
  }
  
  sub _is_other_pkg_private_function {
      my ( $self, $elem ) = @_;
  
      return if ! is_method_call($elem) && ! is_function_call($elem);
  
      my $private_name_regex = $self->{_private_name_regex};
      my $content = $elem->content();
      return
              $content =~ m< \w+::$private_name_regex \z >xms
          &&  $content !~ m< \A SUPER::$private_name_regex \z >xms
          &&  ! $self->{_allow}{$content};
  }
  
  sub _is_other_pkg_private_method {
      my ( $self, $elem ) = @_;
  
      my $private_name_regex = $self->{_private_name_regex};
      my $content = $elem->content();
  
      # look for structures like "Some::Package->_foo()"
      return if $content !~ m< \A $private_name_regex \z >xms;
      my $operator = $elem->sprevious_sibling() or return;
      return if $operator->content() ne q[->];
  
      my $package = $operator->sprevious_sibling() or return;
      return if not $package->isa('PPI::Token::Word');
  
      # sometimes the previous sib is a keyword, as in:
      # shift->_private_method();  This is typically used as
      # shorthand for "my $self=shift; $self->_private_method()"
      return if $package->content() eq 'shift'
          or $package->content() eq '__PACKAGE__';
  
      # Maybe the user wanted to exempt this explicitly.
      return if $self->{_allow}{"${package}::$content"};
  
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::ProtectPrivateSubs - Prevent access to private subs in other packages.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  By convention Perl authors (like authors in many other languages)
  indicate private methods and variables by inserting a leading
  underscore before the identifier.  This policy catches attempts to
  access private variables from outside the package itself.
  
  The subroutines in the L<POSIX|POSIX> package which begin with an underscore
  (e.g. C<POSIX::_POSIX_ARG_MAX>) are not flagged as errors by this
  policy.
  
  
  =head1 CONFIGURATION
  
  You can define what a private subroutine name looks like by specifying
  a regular expression for the C<private_name_regex> option in your
  F<.perlcriticrc>:
  
      [Subroutines::ProtectPrivateSubs]
      private_name_regex = _(?!_)\w+
  
  The above example is a way of saying that subroutines that start with
  a double underscore are not considered to be private.  (Perl::Critic,
  in its implementation, uses leading double underscores to indicate a
  distribution-private subroutine-- one that is allowed to be invoked by
  other Perl::Critic modules, but not by anything outside of
  Perl::Critic.)
  
  You can configure additional subroutines to accept by specifying them
  in a space-delimited list to the C<allow> option:
  
      [Subroutines::ProtectPrivateSubs]
      allow = FOO::_bar FOO::_baz
  
  These are added to the default list of exemptions from this policy.
  Allowing a subroutine also allows the corresponding method call. So
  C<< FOO::_bar >> in the above example allows both C<< FOO::_bar() >>
  and C<< FOO->_bar() >>.
  
  
  =head1 HISTORY
  
  This policy is inspired by a similar test in L<B::Lint|B::Lint>.
  
  
  =head1 BUGS
  
  Doesn't forbid C<< $pkg->_foo() >> because it can't tell the
  difference between that and C<< $self->_foo() >>.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Variables::ProtectPrivateVars|Perl::Critic::Policy::Variables::ProtectPrivateVars>
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_PROTECTPRIVATESUBS

$fatpacked{"Perl/Critic/Policy/Subroutines/RequireArgUnpacking.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_REQUIREARGUNPACKING';
  package Perl::Critic::Policy::Subroutines::RequireArgUnpacking;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use Readonly;
  
  use File::Spec;
  use List::Util qw(first);
  use List::MoreUtils qw(uniq any);
  
  use Perl::Critic::Utils qw<
      :booleans :characters :classification hashify :severities words_from_string
  >;
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $AT => q{@};
  Readonly::Scalar my $AT_ARG => q{@_}; ## no critic (InterpolationOfMetachars)
  Readonly::Scalar my $DOLLAR => q{$};
  Readonly::Scalar my $DOLLAR_ARG => q{$_};   ## no critic (InterpolationOfMetaChars)
  
  Readonly::Scalar my $DESC => qq{Always unpack $AT_ARG first};
  Readonly::Scalar my $EXPL => [178];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'short_subroutine_statements',
              description     =>
                  'The number of statements to allow without unpacking.',
              default_string  => '0',
              behavior        => 'integer',
              integer_minimum => 0,
          },
          {
              name            => 'allow_subscripts',
              description     =>
                  'Should unpacking from array slices and elements be allowed?',
              default_string  => $FALSE,
              behavior        => 'boolean',
          },
          {
              name            => 'allow_delegation_to',
              description     =>
                  'Allow the usual delegation idiom to these namespaces/subroutines',
              behavior        => 'string list',
              list_always_present_values => [ qw< SUPER:: NEXT:: > ],
          }
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw( core pbp maintenance ) }
  sub applies_to           { return 'PPI::Statement::Sub'      }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # forward declaration?
      return if not $elem->block;
  
      my @statements = $elem->block->schildren;
  
      # empty sub?
      return if not @statements;
  
      # Don't apply policy to short subroutines
  
      # Should we instead be doing a find() for PPI::Statement
      # instances?  That is, should we count all statements instead of
      # just top-level statements?
      return if $self->{_short_subroutine_statements} >= @statements;
  
      # look for explicit dereferences of @_, including '$_[0]'
      # You may use "... = @_;" in the first paragraph of the sub
      # Don't descend into nested or anonymous subs
      my $state = 'unpacking'; # still in unpacking paragraph
      for my $statement (@statements) {
  
          my @magic = _get_arg_symbols($statement);
  
          my $saw_unpack = $FALSE;
  
          MAGIC:
          for my $magic (@magic) {
              # allow conditional checks on the size of @_
              next MAGIC if _is_size_check($magic);
  
              if ('unpacking' eq $state) {
                  if ($self->_is_unpack($magic)) {
                      $saw_unpack = $TRUE;
                      next MAGIC;
                  }
              }
  
              # allow @$_[] construct in "... for ();"
              # Check for "print @$_[] for ()" construct (rt39601)
              next MAGIC
                  if _is_cast_of_array($magic) and _is_postfix_foreach($magic);
  
              # allow $$_[], which is equivalent to $_->[] and not a use
              # of @_ at all.
              next MAGIC
                  if _is_cast_of_scalar( $magic );
  
              # allow delegation of the form "$self->SUPER::foo( @_ );"
              next MAGIC
                  if $self->_is_delegation( $magic );
  
              # If we make it this far, it is a violation
              return $self->violation( $DESC, $EXPL, $elem );
          }
          if (not $saw_unpack) {
              $state = 'post_unpacking';
          }
      }
      return;  # OK
  }
  
  sub _is_unpack {
      my ($self, $magic) = @_;
  
      my $prev = $magic->sprevious_sibling();
      my $next = $magic->snext_sibling();
  
      # If we have a subscript, we're dealing with an array slice on @_
      # or an array element of @_. See RT #34009.
      if ( $next and $next->isa('PPI::Structure::Subscript') ) {
          $self->{_allow_subscripts} or return;
          $next = $next->snext_sibling;
      }
  
      return $TRUE if
              $prev
          and $prev->isa('PPI::Token::Operator')
          and is_assignment_operator($prev->content())
          and (
                  not $next
              or  $next->isa('PPI::Token::Structure')
              and $SCOLON eq $next->content()
      );
      return;
  }
  
  sub _is_size_check {
      my ($magic) = @_;
  
      # No size check on $_[0]. RT #34009.
      $AT eq $magic->raw_type or return;
  
      my $prev = $magic->sprevious_sibling;
      my $next = $magic->snext_sibling;
  
      if ( $prev || $next ) {
  
          return $TRUE
              if _legal_before_size_check( $prev )
                  and _legal_after_size_check( $next );
      }
  
      my $parent = $magic;
      {
          $parent = $parent->parent()
              or return;
          $prev = $parent->sprevious_sibling();
          $next = $parent->snext_sibling();
          $prev
              or $next
              or redo;
      }   # until ( $prev || $next );
  
      return $TRUE
          if $parent->isa( 'PPI::Structure::Condition' );
  
      return;
  }
  
  {
  
      Readonly::Hash my %LEGAL_NEXT_OPER => hashify(
          qw{ && || == != > >= < <= and or } );
  
      Readonly::Hash my %LEGAL_NEXT_STRUCT => hashify( qw{ ; } );
  
      sub _legal_after_size_check {
          my ( $next ) = @_;
  
          $next
              or return $TRUE;
  
          $next->isa( 'PPI::Token::Operator' )
              and return $LEGAL_NEXT_OPER{ $next->content() };
  
          $next->isa( 'PPI::Token::Structure' )
              and return $LEGAL_NEXT_STRUCT{ $next->content() };
  
          return;
      }
  }
  
  {
  
      Readonly::Hash my %LEGAL_PREV_OPER => hashify(
          qw{ && || ! == != > >= < <= and or not } );
  
      Readonly::Hash my %LEGAL_PREV_WORD => hashify(
          qw{ if unless } );
  
      sub _legal_before_size_check {
          my ( $prev ) = @_;
  
          $prev
              or return $TRUE;
  
          $prev->isa( 'PPI::Token::Operator' )
              and return $LEGAL_PREV_OPER{ $prev->content() };
  
          $prev->isa( 'PPI::Token::Word' )
              and return $LEGAL_PREV_WORD{ $prev->content() };
  
          return;
      }
  
  }
  
  sub _is_postfix_foreach {
      my ($magic) = @_;
  
      my $sibling = $magic;
      while ( $sibling = $sibling->snext_sibling ) {
          return $TRUE
              if
                      $sibling->isa('PPI::Token::Word')
                  and $sibling =~ m< \A for (?:each)? \z >xms;
      }
      return;
  }
  
  sub _is_cast_of_array {
      my ($magic) = @_;
  
      my $prev = $magic->sprevious_sibling;
  
      return $TRUE
          if ( $prev && $prev->content() eq $AT )
              and $prev->isa('PPI::Token::Cast');
      return;
  }
  
  # This subroutine recognizes (e.g.) $$_[0]. This is a use of $_ (equivalent to
  # $_->[0]), not @_.
  
  sub _is_cast_of_scalar {
      my ($magic) = @_;
  
      my $prev = $magic->sprevious_sibling;
      my $next = $magic->snext_sibling;
  
      return $DOLLAR_ARG eq $magic->content() &&
          $prev && $prev->isa('PPI::Token::Cast') &&
              $DOLLAR eq $prev->content() &&
          $next && $next->isa('PPI::Structure::Subscript');
  }
  
  # A literal @_ is allowed as the argument for a delegation.
  # An example of the idiom we are looking for is $self->SUPER::foo(@_).
  # The argument list of (@_) is required; no other use of @_ is allowed.
  
  sub _is_delegation {
      my ($self, $magic) = @_;
  
      $AT_ARG eq $magic->content() or return; # Not a literal '@_'.
      my $parent = $magic->parent()           # Don't know what to do with
          or return;                          #   orphans.
      $parent->isa( 'PPI::Statement::Expression' )
          or return;                          # Parent must be expression.
      1 == $parent->schildren()               # '@_' must stand alone in
          or return;                          #   its expression.
      $parent = $parent->parent()             # Still don't know what to do
          or return;                          #   with orphans.
      $parent->isa ( 'PPI::Structure::List' )
          or return;                          # Parent must be a list.
      1 == $parent->schildren()               # '@_' must stand alone in
          or return;                          #   the argument list.
      my $subroutine_name = $parent->sprevious_sibling()
          or return;                          # Missing sub name.
      $subroutine_name->isa( 'PPI::Token::Word' )
          or return;
      $self->{_allow_delegation_to}{$subroutine_name}
          and return 1;
      my ($subroutine_namespace) = $subroutine_name =~ m/ \A ( .* ::) \w+ \z /smx
          or return;
      return $self->{_allow_delegation_to}{$subroutine_namespace};
  }
  
  
  sub _get_arg_symbols {
      my ($statement) = @_;
  
      return grep {$AT_ARG eq $_->symbol} @{$statement->find(\&_magic_finder) || []};
  }
  
  sub _magic_finder {
      # Find all @_ and $_[\d+] not inside of nested subs
      my (undef, $elem) = @_;
      return $TRUE if $elem->isa('PPI::Token::Magic'); # match
  
      if ($elem->isa('PPI::Structure::Block')) {
          # don't descend into a nested named sub
          return if $elem->statement->isa('PPI::Statement::Sub');
  
          my $prev = $elem->sprevious_sibling;
          # don't descend into a nested anon sub block
          return if $prev
              and $prev->isa('PPI::Token::Word')
              and 'sub' eq $prev->content();
      }
  
      return $FALSE; # no match, descend
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::RequireArgUnpacking - Always unpack C<@_> first.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Subroutines that use C<@_> directly instead of unpacking the arguments
  to local variables first have two major problems.  First, they are
  very hard to read.  If you're going to refer to your variables by
  number instead of by name, you may as well be writing assembler code!
  Second, C<@_> contains aliases to the original variables!  If you
  modify the contents of a C<@_> entry, then you are modifying the
  variable outside of your subroutine.  For example:
  
     sub print_local_var_plus_one {
         my ($var) = @_;
         print ++$var;
     }
     sub print_var_plus_one {
         print ++$_[0];
     }
  
     my $x = 2;
     print_local_var_plus_one($x); # prints "3", $x is still 2
     print_var_plus_one($x);       # prints "3", $x is now 3 !
     print $x;                     # prints "3"
  
  This is spooky action-at-a-distance and is very hard to debug if it's
  not intentional and well-documented (like C<chop> or C<chomp>).
  
  An exception is made for the usual delegation idiom C<<
  $object->SUPER::something( @_ ) >>. Only C<SUPER::> and C<NEXT::> are
  recognized (though this is configurable) and the argument list for the
  delegate must consist only of C<< ( @_ ) >>.
  
  =head1 CONFIGURATION
  
  This policy is lenient for subroutines which have C<N> or fewer
  top-level statements, where C<N> defaults to ZERO.  You can override
  this to set it to a higher number with the
  C<short_subroutine_statements> setting.  This is very much not
  recommended but perhaps you REALLY need high performance.  To do this,
  put entries in a F<.perlcriticrc> file like this:
  
    [Subroutines::RequireArgUnpacking]
    short_subroutine_statements = 2
  
  By default this policy does not allow you to specify array subscripts
  when you unpack arguments (i.e. by an array slice or by referencing
  individual elements).  Should you wish to permit this, you can do so
  using the C<allow_subscripts> setting. This defaults to false.  You can
  set it true like this:
  
    [Subroutines::RequireArgUnpacking]
    allow_subscripts = 1
  
  The delegation logic can be configured to allow delegation other than to
  C<SUPER::> or C<NEXT::>. The configuration item is
  C<allow_delegation_to>, and it takes a space-delimited list of allowed
  delegates. If a given delegate ends in a double colon, anything in the
  given namespace is allowed. If it does not, only that subroutine is
  allowed. For example, to allow C<next::method> from C<Class::C3> and
  _delegate from the current namespace in addition to SUPER and NEXT, the
  following configuration could be used:
  
    [Subroutines::RequireArgUnpacking]
    allow_delegation_to = next::method _delegate
  
  =head1 CAVEATS
  
  PPI doesn't currently detect anonymous subroutines, so we don't check
  those.  This should just work when PPI gains that feature.
  
  We don't check for C<@ARG>, the alias for C<@_> from English.pm.  That's
  deprecated anyway.
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_REQUIREARGUNPACKING

$fatpacked{"Perl/Critic/Policy/Subroutines/RequireFinalReturn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_SUBROUTINES_REQUIREFINALRETURN';
  package Perl::Critic::Policy::Subroutines::RequireFinalReturn;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Exception::Fatal::Internal qw{ throw_internal };
  use Perl::Critic::Utils qw{ :characters :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => [ 197 ];
  
  Readonly::Hash my %CONDITIONALS => hashify( qw(if unless for foreach) );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'terminal_funcs',
              description     => 'The additional subroutines to treat as terminal.',
              default_string  => $EMPTY,
              behavior        => 'string list',
              list_always_present_values =>
                  [ qw< croak confess die exec exit throw Carp::confess Carp::croak ...> ],
          },
      );
  }
  
  sub default_severity { return $SEVERITY_HIGH        }
  sub default_themes   { return qw( core bugs pbp certrec )   }
  sub applies_to       { return 'PPI::Statement::Sub' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # skip BEGIN{} and INIT{} and END{} etc
      return if $elem->isa('PPI::Statement::Scheduled');
  
      my @blocks = grep {$_->isa('PPI::Structure::Block')} $elem->schildren();
      if (@blocks > 1) {
         # sanity check
         throw_internal 'Subroutine should have no more than one block';
      }
      elsif (@blocks == 0) {
         #Technically, subroutines don't have to have a block at all. In
         # that case, its just a declaration so this policy doesn't really apply
         return; # ok!
      }
  
  
      my ($block) = @blocks;
      if ($self->_block_is_empty($block) || $self->_block_has_return($block)) {
          return; # OK
      }
  
      # Must be a violation
      my $desc;
      if ( my $name = $elem->name() ) {
          $desc = qq<Subroutine "$name" does not end with "return">;
      }
      else {
          $desc = q<Subroutine does not end with "return">;
      }
  
      return $self->violation( $desc, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _block_is_empty {
      my ( $self, $block ) = @_;
      return $block->schildren() == 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _block_has_return {
      my ( $self, $block ) = @_;
      my @blockparts = $block->schildren();
      my $final = $blockparts[-1]; # always defined because we call _block_is_empty first
      return if !$final;
      return $self->_is_explicit_return($final)
          || $self->_is_given_when_return($final)
          || $self->_is_compound_return($final);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_explicit_return {
      my ( $self, $final ) = @_;
  
      return if $self->_is_conditional_stmnt( $final );
      return $self->_is_return_or_goto_stmnt( $final )
          || $self->_is_terminal_stmnt( $final );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_compound_return {
      my ( $self, $final ) = @_;
  
      if (!$final->isa('PPI::Statement::Compound')) {
          return; #fail
      }
  
      my $begin = $final->schild(0);
      return if !$begin; #fail
      if (!($begin->isa('PPI::Token::Word') &&
            ($begin->content() eq 'if' || $begin->content() eq 'unless'))) {
          return; #fail
      }
  
      my @blocks = grep {!$_->isa('PPI::Structure::Condition') &&
                         !$_->isa('PPI::Token')} $final->schildren();
      # Sanity check:
      if (scalar grep {!$_->isa('PPI::Structure::Block')} @blocks) {
          throw_internal
              'Expected only conditions, blocks and tokens in the if statement';
      }
  
      for my $block (@blocks) {
          if (! $self->_block_has_return($block)) {
              return; #fail
          }
      }
  
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_given_when_return {
      my ( $self, $final ) = @_;
  
      if ( ! $final->isa( 'PPI::Statement::Given' ) ) {
          return; #fail
      }
  
      my $begin = $final->schild(0);
      return if !$begin; #fail
      if ( ! ( $begin->isa( 'PPI::Token::Word' ) &&
              $begin->content() eq 'given' ) ) {
          return; #fail
      }
  
      my @blocks = grep {!$_->isa( 'PPI::Structure::Given' ) &&
                         !$_->isa( 'PPI::Token' )} $final->schildren();
      # Sanity check:
      if (scalar grep {!$_->isa('PPI::Structure::Block')} @blocks) {
          throw_internal
              'Expected only givens, blocks and tokens in the given statement';
      }
      if (@blocks > 1) {
         # sanity check
         throw_internal 'Given statement should have no more than one block';
      }
      @blocks or return;  #fail
  
      my $have_default;   # We have to fail unless a default block is present
  
      foreach my $stmnt ( $blocks[0]->schildren() ) {
  
          if ( $stmnt->isa( 'PPI::Statement::When' ) ) {
  
              # Check for the default block.
              my $first_token;
              $first_token = $stmnt->schild( 0 )
                  and 'default' eq $first_token->content()
                  and $have_default = 1;
  
              $self->_is_when_stmnt_with_return( $stmnt )
                  or return;  #fail
  
          } else {
  
              $self->_is_suffix_when_with_return( $stmnt )
                  or return;  #fail
  
          }
  
      }
  
      return $have_default;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_return_or_goto_stmnt {
      my ( $self, $stmnt ) = @_;
      return if not $stmnt->isa('PPI::Statement::Break');
      my $first_token = $stmnt->schild(0) || return;
      return $first_token->content() eq 'return'
          || $first_token->content() eq 'goto';
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_terminal_stmnt {
      my ( $self, $stmnt ) = @_;
      return if not $stmnt->isa('PPI::Statement');
      my $first_token = $stmnt->schild(0) || return;
      return exists $self->{_terminal_funcs}->{$first_token};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_conditional_stmnt {
      my ( $self, $stmnt ) = @_;
      return if not $stmnt->isa('PPI::Statement');
      for my $elem ( $stmnt->schildren() ) {
          return 1 if $elem->isa('PPI::Token::Word')
              && exists $CONDITIONALS{$elem};
      }
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_when_stmnt_with_return {
      my ( $self, $stmnt ) = @_;
  
      my @inner = grep { ! $_->isa( 'PPI::Token' ) &&
                      ! $_->isa( 'PPI::Structure::When' ) }
                  $stmnt->schildren();
      if ( scalar grep { ! $_->isa( 'PPI::Structure::Block' ) } @inner ) {
          throw_internal 'When statement should contain only tokens, conditions, and blocks';
      }
      @inner > 1
          and throw_internal 'When statement should have no more than one block';
      @inner or return;   #fail
  
      foreach my $block ( @inner ) {
          if ( ! $self->_block_has_return( $block ) ) {
              return; #fail
          }
      }
  
      return 1;   #succeed
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_suffix_when_with_return {
      my ( $self, $stmnt ) = @_;
      return if not $stmnt->isa('PPI::Statement');
      foreach my $elem ( $stmnt->schildren() ) {
          return ( $self->_is_return_or_goto_stmnt( $stmnt ) ||
                  $self->_is_terminal_stmnt( $stmnt ) )
              if $elem->isa( 'PPI::Token::Word' )
                  && 'when' eq $elem->content();
      }
      return;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Subroutines::RequireFinalReturn - End every path through a subroutine with an explicit C<return> statement.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Require all subroutines to terminate explicitly with one of the
  following: C<return>, C<carp>, C<croak>, C<die>, C<exec>, C<exit>,
  C<goto>, or C<throw>.
  
  Subroutines without explicit return statements at their ends can be
  confusing.  It can be challenging to deduce what the return value will
  be.
  
  Furthermore, if the programmer did not mean for there to be a
  significant return value, and omits a return statement, some of the
  subroutine's inner data can leak to the outside.  Consider this case:
  
      package Password;
      # every time the user guesses the password wrong, its value
      # is rotated by one character
      my $password;
      sub set_password {
          $password = shift;
      }
      sub check_password {
          my $guess = shift;
          if ($guess eq $password) {
              unlock_secrets();
          } else {
              $password = (substr $password, 1).(substr $password, 0, 1);
          }
      }
      1;
  
  In this case, the last statement in check_password() is the
  assignment.  The result of that assignment is the implicit return
  value, so a wrong guess returns the right password!  Adding a
  C<return;> at the end of that subroutine solves the problem.
  
  The only exception allowed is an empty subroutine.
  
  Be careful when fixing problems identified by this Policy; don't
  blindly put a C<return;> statement at the end of every subroutine.
  
  =head1 CONFIGURATION
  
  If you've created your own terminal functions that behave like C<die>
  or C<exit>, then you can configure Perl::Critic to recognize those
  functions as well.  Just put something like this in your
  F<.perlcriticrc>:
  
      [Subroutines::RequireFinalReturn]
      terminal_funcs = quit abort bailout
  
  =head1 BUGS
  
  We do not look for returns inside ternary operators.  That
  construction is too complicated to analyze right now.  Besides, a
  better form is the return outside of the ternary like this: C<return
  foo ? 1 : bar ? 2 : 3>
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_SUBROUTINES_REQUIREFINALRETURN

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/ProhibitNoStrict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOSTRICT';
  package Perl::Critic::Policy::TestingAndDebugging::ProhibitNoStrict;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw(all);
  
  use Perl::Critic::Utils qw{ :characters :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Stricture disabled};
  Readonly::Scalar my $EXPL => [ 429 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'allow',
              description     => 'Allow vars, subs, and/or refs.',
              default_string  => $EMPTY,
              parser          => \&_parse_allow,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_HIGHEST         }
  sub default_themes   { return qw( core pbp bugs certrec )       }
  sub applies_to       { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_allow {
      my ($self, $parameter, $config_string) = @_;
  
      $self->{_allow} = {};
  
      if( defined $config_string ) {
          my $allowed = lc $config_string; #String of words
          my %allowed = hashify( $allowed =~ m/ (\w+) /gxms );
          $self->{_allow} = \%allowed;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->type()   ne 'no';
      return if $elem->pragma() ne 'strict';
  
      #Arguments to 'no strict' are usually a list of literals or a qw()
      #list.  Rather than trying to parse the various PPI elements, I
      #just use a regex to split the statement into words.  This is
      #kinda lame, but it does the trick for now.
  
      # TODO consider: a possible alternate implementation:
      #   my $re = join q{|}, keys %{$self->{allow}};
      #   return if $re && $stmnt =~ m/\b(?:$re)\b/mx;
      # May need to detaint for that to work...  Not sure.
  
      my $stmnt = $elem->statement();
      return if !$stmnt;
      my @words = $stmnt =~ m/ ([[:lower:]]+) /gxms;
      @words = grep { $_ ne 'qw' && $_ ne 'no' && $_ ne 'strict' } @words;
      return if @words && all { exists $self->{_allow}->{$_} } @words;
  
      #If we get here, then it must be a violation
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::TestingAndDebugging::ProhibitNoStrict - Prohibit various flavors of C<no strict>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  There are good reasons for disabling certain kinds of strictures, But
  if you were wise enough to C<use strict> in the first place, then it
  doesn't make sense to disable it completely.  By default, any C<no
  strict> statement will violate this policy.  However, you can
  configure this Policy to allow certain types of strictures to be
  disabled (See L</CONFIGURATION>).  A bare C<no strict> statement will
  always raise a violation.
  
  
  =head1 CONFIGURATION
  
  The permitted strictures can be configured via the C<allow> option.
  The value is a list of whitespace-delimited stricture types that you
  want to permit.  These can be C<vars>, C<subs> and/or C<refs>.  An
  example of this customization:
  
      [TestingAndDebugging::ProhibitNoStrict]
      allow = vars subs refs
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::TestingAndDebugging::RequireUseStrict|Perl::Critic::Policy::TestingAndDebugging::RequireUseStrict>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOSTRICT

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/ProhibitNoWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOWARNINGS';
  package Perl::Critic::Policy::TestingAndDebugging::ProhibitNoWarnings;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw(all);
  
  use Perl::Critic::Exception::Fatal::Internal qw{ throw_internal };
  use Perl::Critic::Utils qw{ :characters :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Warnings disabled};
  Readonly::Scalar my $EXPL => [ 431 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'allow',
              description     => 'Permitted warning categories.',
              default_string  => $EMPTY,
              parser          => \&_parse_allow,
          },
          {
              name           => 'allow_with_category_restriction',
              description    =>
                  'Allow "no warnings" if it restricts the kinds of warnings that are turned off.',
              default_string => '0',
              behavior       => 'boolean',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_HIGH            }
  sub default_themes   { return qw( core bugs pbp certrec )       }
  sub applies_to       { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_allow {
      my ($self, $parameter, $config_string) = @_;
  
      $self->{_allow} = {};
  
      if( defined $config_string ) {
          my $allowed = lc $config_string; #String of words
          my %allowed = hashify( $allowed =~ m/ (\w+) /gxms );
  
          $self->{_allow} = \%allowed;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
  
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->type()   ne 'no';
      return if $elem->pragma() ne 'warnings';
  
      my @words = _extract_potential_categories( $elem );
      @words >= 2
          and 'no' eq $words[0]
          and 'warnings' eq $words[1]
          or throw_internal
              q<'no warnings' word list did not begin with qw{ no warnings }>;
      splice @words, 0, 2;
  
      return if $self->{_allow_with_category_restriction} and @words;
      return if @words && all { exists $self->{_allow}->{$_} } @words;
  
      #If we get here, then it must be a violation
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  # Traverse the element, accumulating and ultimately returning things
  # that might be warnings categories. These are:
  # * Words (because of the 'foo' in 'no warnings foo => "bar"');
  # * Quotes (because of 'no warnings "foo"');
  # * qw{} strings (obviously);
  # * Nodes (because of 'no warnings ( "foo", "bar" )').
  # We don't lop off the 'no' and 'warnings' because we recurse.
  # RT #74647.
  
  {
  
      Readonly::Array my @HANDLER => (
          [ 'PPI::Token::Word' => sub { return $_[0]->content() } ],
          [ 'PPI::Token::QuoteLike::Words'  =>
              sub { return $_[0]->literal() }, ],
          [ 'PPI::Token::Quote' => sub { return $_[0]->string() } ],
          [ 'PPI::Node' => sub { _extract_potential_categories( $_[0] ) } ],
      );
  
      sub _extract_potential_categories {
          my ( $elem ) = @_;
  
          my @words;
          foreach my $child ( $elem->schildren() ) {
              foreach my $hdlr ( @HANDLER ) {
                  $child->isa( $hdlr->[0] )
                      or next;
                  push @words, $hdlr->[1]->( $child );
                  last;
              }
          }
  
          return @words;
      }
  
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords perllexwarn
  
  =head1 NAME
  
  Perl::Critic::Policy::TestingAndDebugging::ProhibitNoWarnings - Prohibit various flavors of C<no warnings>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  There are good reasons for disabling certain kinds of warnings.  But
  if you were wise enough to C<use warnings> in the first place, then it
  doesn't make sense to disable them completely.  By default, any
  C<no warnings> statement will violate this policy.  However, you can
  configure this Policy to allow certain types of warnings to be
  disabled (See L<"CONFIGURATION">).  A bare C<no warnings>
  statement will always raise a violation.
  
  
  =head1 CONFIGURATION
  
  The permitted warning types can be configured via the C<allow> option.
  The value is a list of whitespace-delimited warning types that you
  want to be able to disable.  See L<perllexwarn|perllexwarn> for a list
  of possible warning types.  An example of this customization:
  
      [TestingAndDebugging::ProhibitNoWarnings]
      allow = uninitialized once
  
  If a true value is specified for the
  C<allow_with_category_restriction> option, then any C<no warnings>
  that restricts the set of warnings that are turned off will pass.
  
      [TestingAndDebugging::ProhibitNoWarnings]
      allow_with_category_restriction = 1
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::TestingAndDebugging::RequireUseWarnings|Perl::Critic::Policy::TestingAndDebugging::RequireUseWarnings>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  The full text of this license can be found in
  the LICENSE file included with this module
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITNOWARNINGS

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/ProhibitProlongedStrictureOverride.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITPROLONGEDSTRICTUREOVERRIDE';
  package Perl::Critic::Policy::TestingAndDebugging::ProhibitProlongedStrictureOverride;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Don't turn off strict for large blocks of code};
  Readonly::Scalar my $EXPL => [ 433 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'statements',
              description     => 'The maximum number of statements in a no strict block.',
              default_string  => '3',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_HIGH            }
  sub default_themes   { return qw( core pbp bugs certrec )       }
  sub applies_to       { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
  
      return if $elem->type ne 'no';
      return if $elem->module ne 'strict';
  
      my $sib = $elem->snext_sibling;
      my $nstatements = 0;
      while ($nstatements++ <= $self->{_statements}) {
          return if !$sib;
          return if $sib->isa('PPI::Statement::Include') &&
              $sib->type eq 'use' &&
              $sib->module eq 'strict';
         $sib = $sib->snext_sibling;
      }
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::TestingAndDebugging::ProhibitProlongedStrictureOverride - Don't turn off strict for large blocks of code.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Every agrees that C<use strict> is the first step to writing
  maintainable code in Perl.  However, sometimes C<strict> is a little
  too strict.  In those cases, you can turn it off briefly with a C<no
  strict> directive.
  
  This policy checks that C<no strict> is only in effect for a small
  number of statements.
  
  
  =head1 CONFIGURATION
  
  The default number of statements allowed per C<no strict> is three.
  To override this number, put the following in your F<.perlcriticrc>:
  
      [TestingAndDebugging::ProhibitProlongedStrictureOverride]
      statements = 5
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_PROHIBITPROLONGEDSTRICTUREOVERRIDE

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/RequireTestLabels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIRETESTLABELS';
  package Perl::Critic::Policy::TestingAndDebugging::RequireTestLabels;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw(any);
  use Perl::Critic::Utils qw{
      :characters :severities :data_conversion :classification :ppi
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  Readonly::Hash my %LABEL_ARG_POS => (
     ok        => 1,
     is        => 2,
     isnt      => 2,
     like      => 2,
     unlike    => 2,
     cmp_ok    => 3,
     is_deeply => 2,
     pass      => 0,
     fail      => 0,
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Test without a label};
  Readonly::Scalar my $EXPL => q{Add a label argument to all Test::More functions};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'modules',
              description     => 'The additional modules to require labels for.',
              default_string  => $EMPTY,
              behavior        => 'string list',
              list_always_present_values => [ qw( Test::More ) ],
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM             }
  sub default_themes   { return qw( core maintenance tests ) }
  sub applies_to       { return 'PPI::Token::Word'           }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, $doc) = @_;
  
      my $arg_index = $LABEL_ARG_POS{$elem};
      return if not defined $arg_index;
      return if not is_function_call($elem);
      return if not $self->_has_test_more($doc);
  
      # Does the function call have enough arguments?
      my @args = parse_arg_list($elem);
      return if ( @args > $arg_index );
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _has_test_more {
      my ( $self, $doc ) = @_;
  
      # TODO: This method gets called every time violates() is invoked,
      # but it only needs to happen once per document.  Perhaps this
      # policy should just apply to PPI::Document, and then do its own
      # search for method calls.  Since Perl::Critic::Document is
      # optimized, this should be pretty fast.
  
      my $includes = $doc->find('PPI::Statement::Include');
      return if not $includes;
      return any { exists $self->{_modules}->{$_->module()} }
          @{ $includes };
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::TestingAndDebugging::RequireTestLabels - Tests should all have labels.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Most Perl modules with regression tests use L<Test::More|Test::More>
  as infrastructure for writing and running those tests.  It has an
  easy, procedural syntax for writing comparisons of results to
  expectations.
  
  Most of the Test::More functions allow the programmer to add an
  optional label that describes what each test is trying to judge.  When
  a test goes wrong, these labels are very useful for quickly
  determining where the problem originated.
  
  This policy enforces that all Test::More functions have labels where
  applicable.  This only applies to code that has a C<use Test::More> or
  C<require Test::More> declaration (see below to add more test modules
  to the list).
  
  
  =head1 CONFIGURATION
  
  A list of additional modules to require label parameters be passed to
  their methods can be specified with the C<modules> option.  The list
  must consist of whitespace-delimited, fully-qualified module names.
  For example:
  
      [TestingAndDebugging::RequireTestLabels]
      modules = My::Test::SubClass  Some::Other::Module
  
  The module list always implicitly includes L<Test::More|Test::More>.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIRETESTLABELS

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/RequireUseStrict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSESTRICT';
  package Perl::Critic::Policy::TestingAndDebugging::RequireUseStrict;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use version 0.77;
  use Readonly;
  use Scalar::Util qw{ blessed };
  
  use Perl::Critic::Utils qw{ :severities $EMPTY };
  use Perl::Critic::Utils::Constants qw{ :equivalent_modules };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Code before strictures are enabled};
  Readonly::Scalar my $EXPL => [ 429 ];
  
  Readonly::Scalar my $PERL_VERSION_WHICH_IMPLIES_STRICTURE => qv('v5.11.0');
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'equivalent_modules',
              description     =>
                  q<The additional modules to treat as equivalent to "strict".>,
              default_string  => $EMPTY,
              behavior        => 'string list',
              list_always_present_values => ['strict', @STRICT_EQUIVALENT_MODULES],
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGHEST   }
  sub default_themes       { return qw( core pbp bugs certrule certrec ) }
  sub applies_to           { return 'PPI::Document'     }
  
  sub default_maximum_violations_per_document { return 1; }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, undef, $doc ) = @_;
  
      # Find the first 'use strict' statement
      my $strict_stmnt = $doc->find_first( $self->_generate_is_use_strict() );
      my $strict_line  = $strict_stmnt ? $strict_stmnt->location()->[0] : undef;
  
      # Find all statements that aren't 'use', 'require', or 'package'
      my $stmnts_ref = $self->_find_isnt_include_or_package($doc);
      return if not $stmnts_ref;
  
      # If the 'use strict' statement is not defined, or the other
      # statement appears before the 'use strict', then it violates.
  
      my @viols = ();
      for my $stmnt ( @{ $stmnts_ref } ) {
          last if $stmnt->isa('PPI::Statement::End');
          last if $stmnt->isa('PPI::Statement::Data');
  
          my $stmnt_line = $stmnt->location()->[0];
          if ( (! defined $strict_line) || ($stmnt_line < $strict_line) ) {
              push @viols, $self->violation( $DESC, $EXPL, $stmnt );
          }
      }
      return @viols;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _generate_is_use_strict {
      my ($self) = @_;
  
      return sub {
          my (undef, $elem) = @_;
  
          return 0 if !$elem->isa('PPI::Statement::Include');
          return 0 if $elem->type() ne 'use';
  
          # We only want file-scoped pragmas
          my $parent = $elem->parent();
          return 0 if !$parent->isa('PPI::Document');
  
          if ( my $pragma = $elem->pragma() ) {
              return 1 if $self->{_equivalent_modules}{$pragma};
          }
          elsif ( my $module = $elem->module() ) {
              return 1 if $self->{_equivalent_modules}{$module};
          }
          elsif ( my $version = $elem->version() ) {
              # Currently Adam returns a string here. He has said he may return
              # a version object in the future, so best be prepared.
              if ( not blessed( $version ) or not $version->isa( 'version' ) ) {
                  if ( 'v' ne substr $version, 0, 1
                      and ( $version =~ tr/././ ) > 1 ) {
                      $version = 'v' . $version;
                  }
                  $version = version->parse( $version );
              }
              return 1 if $PERL_VERSION_WHICH_IMPLIES_STRICTURE <= $version;
          }
  
          return 0;
      };
  }
  
  #-----------------------------------------------------------------------------
  # Here, we're using the fact that Perl::Critic::Document::find() is optimized
  # to search for elements based on their type.  This is faster than using the
  # native PPI::Node::find() method with a custom callback function.
  
  sub _find_isnt_include_or_package {
      my ($self, $doc) = @_;
      my $all_statements = $doc->find('PPI::Statement') or return;
      my @wanted_statements = grep { _statement_isnt_include_or_package($_) } @{$all_statements};
      return @wanted_statements ? \@wanted_statements : ();
  }
  
  #-----------------------------------------------------------------------------
  
  sub _statement_isnt_include_or_package {
      my ($elem) = @_;
      return 0 if $elem->isa('PPI::Statement::Package');
      return 0 if $elem->isa('PPI::Statement::Include');
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::TestingAndDebugging::RequireUseStrict - Always C<use strict>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using strictures is probably the single most effective way to improve
  the quality of your code.  This policy requires that the C<'use
  strict'> statement must come before any other statements except
  C<package>, C<require>, and other C<use> statements.  Thus, all the
  code in the entire package will be affected.
  
  There are special exemptions for L<Moose|Moose>,
  L<Moose::Role|Moose::Role>, and
  L<Moose::Util::TypeConstraints|Moose::Util::TypeConstraints> because
  they enforces strictness; e.g.  C<'use Moose'> is treated as
  equivalent to C<'use strict'>.
  
  The maximum number of violations per document for this policy defaults
  to 1.
  
  
  =head1 CONFIGURATION
  
  If you make use of things like
  L<Moose::Exporter|Moose::Exporter>, you can create your own modules
  that import the L<strict|strict> pragma into the code that is
  C<use>ing them.  There is an option to add to the default set of
  pragmata and modules in your F<.perlcriticrc>: C<equivalent_modules>.
  
      [TestingAndDebugging::RequireUseStrict]
      equivalent_modules = MooseX::My::Sugar
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::TestingAndDebugging::ProhibitNoStrict|Perl::Critic::Policy::TestingAndDebugging::ProhibitNoStrict>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  The full text of this license can be found in
  the LICENSE file included with this module
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSESTRICT

$fatpacked{"Perl/Critic/Policy/TestingAndDebugging/RequireUseWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSEWARNINGS';
  package Perl::Critic::Policy::TestingAndDebugging::RequireUseWarnings;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::Util qw(first);
  use version ();
  
  use Perl::Critic::Utils qw{ :severities $EMPTY };
  use Perl::Critic::Utils::Constants qw{ :equivalent_modules };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Code before warnings are enabled};
  Readonly::Scalar my $EXPL => [431];
  
  Readonly::Scalar my $MINIMUM_VERSION => version->new(5.006);
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'equivalent_modules',
              description     =>
                  q<The additional modules to treat as equivalent to "warnings".>,
              default_string  => $EMPTY,
              behavior        => 'string list',
              list_always_present_values => ['warnings', @WARNINGS_EQUIVALENT_MODULES],
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core pbp bugs certrule ) }
  sub applies_to           { return 'PPI::Document'     }
  
  sub default_maximum_violations_per_document { return 1; }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, undef, $document ) = @_;
  
      my $version = $document->highest_explicit_perl_version();
      return if $version and $version < $MINIMUM_VERSION;
  
      # Find the first 'use warnings' statement
      my $warn_stmnt = $document->find_first( $self->_generate_is_use_warnings() );
      my $warn_line  = $warn_stmnt ? $warn_stmnt->location()->[0] : undef;
  
      # Find all statements that aren't 'use', 'require', or 'package'
      my $stmnts_ref =  $self->_find_isnt_include_or_package($document);
      return if !$stmnts_ref;
  
      # If the 'use warnings' statement is not defined, or the other
      # statement appears before the 'use warnings', then it violates.
  
      my @viols = ();
      for my $stmnt ( @{ $stmnts_ref } ) {
          last if $stmnt->isa('PPI::Statement::End');
          last if $stmnt->isa('PPI::Statement::Data');
  
          my $stmnt_line = $stmnt->location()->[0];
          if ( (! defined $warn_line) || ($stmnt_line < $warn_line) ) {
              push @viols, $self->violation( $DESC, $EXPL, $stmnt );
          }
      }
      return @viols;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _generate_is_use_warnings {
      my ($self) = @_;
  
      return sub {
          my (undef, $elem) = @_;
  
          return 0 if !$elem->isa('PPI::Statement::Include');
          return 0 if $elem->type() ne 'use';
  
          # We only want file-scoped pragmas
          my $parent = $elem->parent();
          return 0 if !$parent->isa('PPI::Document');
  
          if ( my $pragma = $elem->pragma() ) {
              return 1 if $self->{_equivalent_modules}{$pragma};
          }
          elsif ( my $module = $elem->module() ) {
              return 1 if $self->{_equivalent_modules}{$module};
          }
  
          return 0;
      };
  }
  
  #-----------------------------------------------------------------------------
  # Here, we're using the fact that Perl::Critic::Document::find() is optimized
  # to search for elements based on their type.  This is faster than using the
  # native PPI::Node::find() method with a custom callback function.
  
  sub _find_isnt_include_or_package {
      my ($self, $doc) = @_;
      my $all_statements = $doc->find('PPI::Statement') or return;
      my @wanted_statements = grep { _statement_isnt_include_or_package($_) } @{$all_statements};
      return @wanted_statements ? \@wanted_statements : ();
  }
  
  #-----------------------------------------------------------------------------
  
  sub _statement_isnt_include_or_package {
      my ($elem) = @_;
      return 0 if $elem->isa('PPI::Statement::Package');
      return 0 if $elem->isa('PPI::Statement::Include');
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::TestingAndDebugging::RequireUseWarnings - Always C<use warnings>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using warnings, and paying attention to what they say, is probably the
  single most effective way to improve the quality of your code.  This
  policy requires that the C<'use warnings'> statement must come before
  any other statements except C<package>, C<require>, and other C<use>
  statements.  Thus, all the code in the entire package will be
  affected.
  
  There are special exemptions for L<Moose|Moose>,
  L<Moose::Role|Moose::Role>, and
  L<Moose::Util::TypeConstraints|Moose::Util::TypeConstraints> because
  they enforces warnings; e.g.  C<'use Moose'> is treated as
  equivalent to C<'use warnings'>.
  
  This policy will not complain if the file explicitly states that it is
  compatible with a version of perl prior to 5.6 via an include
  statement, e.g. by having C<require 5.005> in it.
  
  The maximum number of violations per document for this policy defaults
  to 1.
  
  
  =head1 CONFIGURATION
  
  If you make use of things like
  L<Moose::Exporter|Moose::Exporter>, you can create your own modules
  that import the L<warnings|warnings> pragma into the code that is
  C<use>ing them.  There is an option to add to the default set of
  pragmata and modules in your F<.perlcriticrc>: C<equivalent_modules>.
  
      [TestingAndDebugging::RequireUseWarnings]
      equivalent_modules = MooseX::My::Sugar
  
  
  =head1 BUGS
  
  Needs to check for -w on the shebang line.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::TestingAndDebugging::ProhibitNoWarnings|Perl::Critic::Policy::TestingAndDebugging::ProhibitNoWarnings>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_TESTINGANDDEBUGGING_REQUIREUSEWARNINGS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitCommaSeparatedStatements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMMASEPARATEDSTATEMENTS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitCommaSeparatedStatements;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  
  use Perl::Critic::Utils qw{ :booleans :characters :severities :classification };
  use Perl::Critic::Utils::PPI qw{ is_ppi_statement_subclass };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Comma used to separate statements};
  Readonly::Scalar my $EXPL => [ 68, 71 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'allow_last_statement_to_be_comma_separated_in_map_and_grep',
              description    => 'Allow map and grep blocks to return lists.',
              default_string => $FALSE,
              behavior       => 'boolean',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core bugs pbp certrule ) }
  sub applies_to           { return 'PPI::Statement'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # Grrr... PPI instantiates non-leaf nodes in its class hierarchy...
      return if is_ppi_statement_subclass($elem);
  
      # Now, if PPI hasn't introduced any new PPI::Statement subclasses, we've
      # got an element who's class really is PPI::Statement.
  
      return if _is_parent_a_constructor_or_list($elem);
      return if _is_parent_a_for_loop($elem);
  
      if (
          $self->{_allow_last_statement_to_be_comma_separated_in_map_and_grep}
      ) {
          return if not _is_direct_part_of_map_or_grep_block($elem);
      }
  
      foreach my $child ( $elem->schildren() ) {
          if (
                  not $self->{_allow_last_statement_to_be_comma_separated_in_map_and_grep}
              and not _is_last_statement_in_a_block($child)
          ) {
              if ( $child->isa('PPI::Token::Word') ) {
                  return if _succeeding_commas_are_list_element_separators($child);
              }
              elsif ( $child->isa('PPI::Token::Operator') ) {
                  if ( $child->content() eq $COMMA ) {
                      return $self->violation($DESC, $EXPL, $elem);
                  }
              }
          }
      }
  
      return;
  }
  
  sub _is_parent_a_constructor_or_list {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
  
      return if not $parent;
  
      return (
              $parent->isa('PPI::Structure::Constructor')
          or  $parent->isa('PPI::Structure::List')
      );
  }
  
  sub _is_parent_a_for_loop {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
  
      return if not $parent;
  
      return if not $parent->isa('PPI::Structure::For');
  
      return 1 == scalar $parent->schildren(); # Multiple means C-style loop.
  }
  
  sub _is_direct_part_of_map_or_grep_block {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
      return if not $parent;
      return if not $parent->isa('PPI::Structure::Block');
  
      my $block_prior_sibling = $parent->sprevious_sibling();
      return if not $block_prior_sibling;
      return if not $block_prior_sibling->isa('PPI::Token::Word');
  
      return $block_prior_sibling eq 'map' || $block_prior_sibling eq 'grep';
  }
  
  sub _is_last_statement_in_a_block {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
      return if not $parent;
      return if not $parent->isa('PPI::Structure::Block');
  
      my $next_sibling = $elem->snext_sibling();
      return if not $next_sibling;
  
      return 1;
  }
  
  sub _succeeding_commas_are_list_element_separators {
      my ($elem) = @_;
  
      if (
              is_perl_builtin_with_zero_and_or_one_arguments($elem)
          and not is_perl_builtin_with_multiple_arguments($elem)
      ) {
          return;
      }
  
      my $sibling = $elem->snext_sibling();
  
      return 1 if not $sibling;  # There won't be any succeeding commas.
  
      return not $sibling->isa('PPI::Structure::List');
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitCommaSeparatedStatements - Don't use the comma operator as a statement separator.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl's comma statement separator has really low precedence, which
  leads to code that looks like it's using the comma list element
  separator not actually doing so.  Conway suggests that the statement
  separator not be used in order to prevent this situation.
  
  The confusion that the statement separator causes is primarily due to
  the assignment operators having higher precedence.
  
  For example, trying to combine two arrays into another like this won't
  work:
  
      @x = @y, @z;
  
  because it is equivalent to
  
      @x = @y;
      @z;
  
  Conversely, there are the built-in functions, like C<print>, that
  normally force the rest of the statement into list context, but don't
  when called like a subroutine.
  
  This is not likely to produce what is intended:
  
      print join q{, }, 2, 3, 5, 7, ": the single-digit primes.\n";
  
  The obvious fix is to add parentheses.  Placing them like
  
      print join( q{, }, 2, 3, 5, 7 ), ": the single-digit primes.\n";
  
  will work, but
  
      print ( join q{, }, 2, 3, 5, 7 ), ": the single-digit primes.\n";
  
  will not, because it is equivalent to
  
      print( join q{, }, 2, 3, 5, 7 );
      ": the single-digit primes.\n";
  
  
  =head1 CONFIGURATION
  
  This policy can be configured to allow the last statement in a C<map>
  or C<grep> block to be comma separated.  This is done via the
  C<allow_last_statement_to_be_comma_separated_in_map_and_grep> option
  like so:
  
      [ValuesAndExpressions::ProhibitCommaSeparatedStatements]
      allow_last_statement_to_be_comma_separated_in_map_and_grep = 1
  
  With this option off (the default), the following code violates this
  policy.
  
      %hash = map {$_, 1} @list;
  
  With this option on, this statement is allowed.  Even if this option
  is off, using a fat comma C<< => >> works, but that forces
  stringification on the first value, which may not be what you want.
  
  
  =head1 BUGS
  
  Needs to check for C<scalar( something, something )>.
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMMASEPARATEDSTATEMENTS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitComplexVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMPLEXVERSION';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitComplexVersion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use Perl::Critic::Utils qw{ :booleans :characters :severities };
  use Perl::Critic::Utils::PPI qw{
      get_next_element_in_same_simple_statement
      get_previous_module_used_on_same_line
      is_ppi_simple_statement
  };
  use Readonly;
  use Scalar::Util qw{ blessed };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DOLLAR => q<$>;
  # All uses of the $DOLLAR variable below are to prevent false failures in
  # xt/93_version.t.
  Readonly::Scalar my $VERSION_MODULE => q<version>;
  Readonly::Scalar my $VERSION_VARIABLE => $DOLLAR . q<VERSION>;
  
  Readonly::Scalar my $DESC =>
      $DOLLAR . q<VERSION value should not come from outside module>;
  Readonly::Scalar my $EXPL =>
      q<If the version comes from outside the module, you can get everything from unexpected version changes to denial-of-service attacks.>;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return (
          {
              name        => 'forbid_use_version',
              description =>
              qq<Make "use version; our ${DOLLAR}VERSION = qv('1.2.3');" a violation of this policy.>,
              default_string  => $FALSE,
              behavior        => 'boolean',
          },
      );
  }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core maintenance )     }
  sub applies_to           { return 'PPI::Token::Symbol'       }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # Any variable other than $VERSION is ignored.
      return if $VERSION_VARIABLE ne $elem->content();
  
      # We are only interested in assignments to $VERSION, but it might be a
      # list assignment, so if we do not find an assignment, we move up the
      # parse tree. If we hit a statement (or no parent at all) we do not
      # understand the code to be an assignment statement, and we simply return.
      my $operator;
      return if
              not $operator = get_next_element_in_same_simple_statement( $elem )
          or  $EQUAL ne $operator;
  
      # Find the simple statement we are in. If we can not find it, abandon the
      # attempt to analyze the code.
      my $statement = $self->_get_simple_statement( $elem )
          or return;
  
      # Check all symbols in the statement for violation.
      my $exception;
      return $exception if
          $exception =
              $self->_validate_fully_qualified_symbols($elem, $statement, $doc);
  
      # At this point we have found no data that is explicitly from outside the
      # file.  If the author wants to use a $VERSION from another module, _and_
      # wants MM->parse_version to understand it, the other module must be used
      # on the same line. So we assume no violation unless this has been done.
      my $module = get_previous_module_used_on_same_line( $elem )
          or return;
  
      # We make an exception for 'use version' unless configured otherwise; so
      # let it be written, so let it be done.
      return if $module eq $VERSION_MODULE and not $self->{_forbid_use_version};
  
      # We assume nefarious intent if we have any other module used on the same
      # line as the $VERSION assignment.
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  # Return the simple statement that contains our element. The classification
  # done by is_ppi_simple_statement is not quite good enough in this case -- if
  # our parent is a PPI::Structure::List, we want to keep looking.
  
  sub _get_simple_statement {
      my ( $self, $elem ) = @_;
  
      my $statement = $elem;
  
      while ( $statement) {
          my $parent;
          if ( is_ppi_simple_statement( $statement ) ) {
              return $statement if
                      not $parent = $statement->parent()
                  or  not $parent->isa( 'PPI::Structure::List' );
              $statement = $parent;
          } else {
              $statement = $statement->parent();
          }
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_fully_qualified_symbols {
      my ( $self, $elem, $statement, $doc ) = @_;
  
      # Find the package(s) in this file.
      my %local_package =
          map { $_->schild( 1 ) => 1 }
              @{ $doc->find( 'PPI::Statement::Package' ) || [] };
      $local_package{main} = 1;   # For completeness.
  
      # Check all symbols in the statement for violation.
      foreach my $symbol (
          @{ $statement->find( 'PPI::Token::Symbol' ) || [] }
      ) {
          if ( $symbol->canonical() =~ m< \A [@\$%&] ([\w:]*) :: >smx ) {
              $local_package{ $1 }
                  or return $self->violation( $DESC, $EXPL, $elem );
          }
      }
  
      # Check all interpolatable strings in the statement for violation.
      # TODO this does not correctly handle "@{[some_expression()]}".
      foreach my $string (
          @{
                  $statement->find(
                      sub {
                          return
                                  $_[1]->isa('PPI::Token::Quote::Double')
                              ||  $_[1]->isa('PPI::Token::Quote::Interpolate');
                      }
                  )
              or  []
          }
      ) {
          my $unquoted = $string->string();
          while (
              $unquoted =~
                  m<
                      (?: \A | [^\\] )
                      (?: \\{2} )*
                      [@\$]
                      [{]?
                      ([\w:]*)
                      ::
                  >gsmx
          ) {
              next if $local_package{ $1 };
  
              return $self->violation( $DESC, $EXPL, $elem );
          }
      }
  
      # Check all words in the statement for violation.
      foreach my $symbol ( @{ $statement->find( 'PPI::Token::Word' ) || [] } ) {
          if ( $symbol->content() =~ m/ \A ([\w:]*) :: /smx ) {
              return $self->violation( $DESC, $EXPL, $elem )
                  if not $local_package{ $1 };
          }
      }
  
      return;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitComplexVersion - Prohibit version values from outside the module.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  One tempting way to keep a group of related modules at the same version number
  is to have all of them import the version number from a designated module. For
  example, module C<Foo::Master> could be the version master for the C<Foo>
  package, and all other modules could use its C<$VERSION> by
  
      use Foo::Master; our $VERSION = $Foo::Master::VERSION;
  
  This turns out not to be a good idea, because all sorts of unintended things
  can happen - anything from unintended version number changes to
  denial-of-service attacks (since C<Foo::Master> is executed by the 'use').
  
  This policy examines statements that assign to C<$VERSION>, and declares a
  violation under two circumstances: first, if that statement uses a
  fully-qualified symbol that did not originate in a package declared in the
  file; second if there is a C<use> statement on the same line that makes the
  assignment.
  
  By default, an exception is made for C<use version;> because of its
  recommendation by Perl Best Practices. See the C<forbid_use_version>
  configuration variable if you do not want an exception made for C<use
  version;>.
  
  
  =head1 CONFIGURATION
  
  The construction
  
      use version; our $VERSION = qv('1.2.3');
  
  is exempt from this policy by default, because it is recommended by Perl Best
  Practices. Should you wish to identify C<use version;> as a violation, add the
  following to your perlcriticrc file:
  
      [ValuesAndExpressions::ProhibitComplexVersion]
      forbid_use_version = 1
  
  
  =head1 CAVEATS
  
  This code assumes that the hallmark of a violation is a 'use' on the same line
  as the C<$VERSION> assignment, because that is the way to have it seen by
  L<ExtUtils::MakeMaker|ExtUtils::MakeMaker>->parse_version(). Other ways to get
  a version value from outside the module can be imagined, and this policy is
  currently oblivious to them.
  
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Tom Wyant.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCOMPLEXVERSION

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitConstantPragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCONSTANTPRAGMA';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitConstantPragma;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Pragma "constant" used};
  Readonly::Scalar my $EXPL => [ 55 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                        }
  sub default_severity     { return $SEVERITY_HIGH            }
  sub default_themes       { return qw( core bugs pbp )       }
  sub applies_to           { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem->type() eq 'use' && $elem->pragma() eq 'constant' ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitConstantPragma - Don't C<< use constant FOO => 15 >>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic> distribution.
  
  
  =head1 DESCRIPTION
  
  Named constants are a good thing.  But don't use the C<constant>
  pragma because barewords don't interpolate.  Instead use the
  L<Readonly|Readonly> module.
  
    use constant FOOBAR => 42;  #not ok
  
    use Readonly;
    Readonly my $FOOBAR => 42;  #ok
    Readonly::Scalar my $FOOBAR => 42;  #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITCONSTANTPRAGMA

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitEmptyQuotes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITEMPTYQUOTES';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitEmptyQuotes;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EMPTY_RX => qr{\A ["'] \s* ['"] \z}xms;
  Readonly::Scalar my $DESC     => q<Quotes used with a string containing no non-whitespace characters>;
  Readonly::Scalar my $EXPL     => [ 53 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return 'PPI::Token::Quote'   }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem =~ $EMPTY_RX ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitEmptyQuotes - Write C<q{}> instead of C<''>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Don't use quotes for an empty string or any string that is pure
  whitespace.  Instead, use C<q{}> to improve legibility.  Better still,
  created named values like this.  Use the C<x> operator to repeat
  characters.
  
      $message = '';      #not ok
      $message = "";      #not ok
      $message = "     "; #not ok
  
      $message = q{};     #better
      $message = q{     } #better
  
      $EMPTY = q{};
      $message = $EMPTY;      #best
  
      $SPACE = q{ };
      $message = $SPACE x 5;  #best
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::ProhibitNoisyStrings|Perl::Critic::Policy::ValuesAndExpressions::ProhibitNoisyStrings>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITEMPTYQUOTES

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitEscapedCharacters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITESCAPEDCHARACTERS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitEscapedCharacters;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC     => q{Numeric escapes in interpolated string};
  Readonly::Scalar my $EXPL     => [ 54..55 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return qw(PPI::Token::Quote::Double
                                       PPI::Token::Quote::Interpolate) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $not_escaped = qr/(?<!\\)(?:\\\\)*/xms;
      my $hex         = qr/\\x[\dA-Fa-f]{2}/xms;
      my $widehex     = qr/\\x[{][\dA-Fa-f]+[}]/xms;
      my $oct         = qr/\\[01][0-7]/xms;
      if ($elem->content =~ m/$not_escaped (?:$hex|$widehex|$oct)/xmso) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitEscapedCharacters - Write C<"\N{DELETE}"> instead of C<"\x7F">, etc.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Escaped numeric values are hard to read and debug.  Instead, use named
  values.  The syntax is less compact, but dramatically more readable.
  
      $str = "\x7F\x06\x22Z";                         # not ok
  
      use charnames ':full';
      $str = "\N{DELETE}\N{ACKNOWLEDGE}\N{CANCEL}Z";  # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITESCAPEDCHARACTERS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitImplicitNewlines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITIMPLICITNEWLINES';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitImplicitNewlines;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Literal line breaks in a string};
  Readonly::Scalar my $EXPL => [60,61];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw( core pbp cosmetic ) }
  sub applies_to           { return 'PPI::Token::Quote'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->string !~ m/\n/xms;
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitImplicitNewlines - Use concatenation or HEREDOCs instead of literal line breaks in strings.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Strings with embedded line breaks are hard to read.  Use concatenation
  or HEREDOCs instead.
  
      my $foo = "Line one is quite long
      Line two";                                    # Bad
  
      my $foo = "Line one is quite long\nLine two"; # Better, but still hard to read
  
      my $foo = "Line one is quite long\n"
          . "Line two";                               # Better still
  
      my $foo = <<'EOF';                            # Use heredoc for longer passages
      Line one is quite long
      Line two
      Line three breaks the camel's back
      EOF
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 COPYRIGHT
  
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITIMPLICITNEWLINES

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitInterpolationOfLiterals.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITINTERPOLATIONOFLITERALS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitInterpolationOfLiterals;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{ :characters :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Useless interpolation of literal string};
  Readonly::Scalar my $EXPL => [51];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name               => 'allow',
              description        =>
                  'Kinds of delimiters to permit, e.g. "qq{", "qq(", "qq[", "qq/".',
              default_string     => $EMPTY,
              parser             => \&_parse_allow,
          },
          {
              name               => 'allow_if_string_contains_single_quote',
              description        =>
                  q<If the string contains ' characters, allow "" to quote it.>,
              default_string     => '0',
              behavior           => 'boolean',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOWEST        }
  sub default_themes   { return qw( core pbp cosmetic ) }
  sub applies_to       { return qw(PPI::Token::Quote::Double
                                   PPI::Token::Quote::Interpolate) }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $MAX_SPECIFICATION_LENGTH => 3;
  
  sub _parse_allow {
      my ($self, $parameter, $config_string) = @_;
  
      my @allow;
  
      if (defined $config_string) {
          @allow = words_from_string( $config_string );
          #Try to be forgiving with the configuration...
          for (@allow) {
              m{ \A qq }xms || ($_ = 'qq' . $_)
          }  #Add 'qq'
          for (@allow) {
              (length $_ <= $MAX_SPECIFICATION_LENGTH) || chop
          }    #Chop closing char
      }
  
      $self->{_allow} = \@allow;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # Skip if this string needs interpolation
      return if _has_interpolation($elem);
  
      # Overlook allowed quote styles
      return if any { $elem =~ m{ \A \Q$_\E }xms } @{ $self->{_allow} };
  
      # If the flag is set, allow "I'm here".
      if ( $self->{_allow_if_string_contains_single_quote} ) {
          return if index ($elem, $QUOTE) >= 0;
      }
  
      # Must be a violation
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _has_interpolation {
      my $elem = shift;
      return $elem =~ m<
          (?: \A | [^\\] )
          (?: \\{2} )*
          (?: [\$\@] \S+ | \\[tnrfbae0xcNLuLUEQ] )
      >xmso;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitInterpolationOfLiterals - Always use single quotes for literal strings.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Don't use double-quotes or C<qq//> if your string doesn't require
  interpolation.  This saves the interpreter a bit of work and it lets
  the reader know that you really did intend the string to be literal.
  
      print "foobar";     #not ok
      print 'foobar';     #ok
      print qq/foobar/;   #not ok
      print q/foobar/;    #ok
  
      print "$foobar";    #ok
      print "foobar\n";   #ok
      print qq/$foobar/;  #ok
      print qq/foobar\n/; #ok
  
      print qq{$foobar};  #preferred
      print qq{foobar\n}; #preferred
  
  Use of double-quotes might be reasonable if the string contains single
  quote (') characters:
  
      print "it's me";    # ok, if configuration flag set
  
  
  =head1 CONFIGURATION
  
  The types of quoting styles to exempt from this policy can be
  configured via the C<allow> option.  This must be a
  whitespace-delimited combination of some or all of the following
  styles: C<qq{}>, C<qq()>, C<qq[]>, and C<qq//>.
  
  This is useful because some folks have configured their editor to
  apply special syntax highlighting within certain styles of quotes.
  For example, you can tweak C<vim> to use SQL highlighting for
  everything that appears within C<qq{}> or C<qq[]> quotes.  But if
  those strings are literal, Perl::Critic will complain.  To prevent
  this, put the following in your F<.perlcriticrc> file:
  
      [ValuesAndExpressions::ProhibitInterpolationOfLiterals]
      allow = qq{} qq[]
  
  The flag C<allow_if_string_contains_single_quote> permits
  double-quoted strings if the string contains a single quote (')
  character.  It defaults to off; to turn it on put the following in
  your F<.perlcriticrc> file:
  
      [ValuesAndExpressions::ProhibitInterpolationOfLiterals]
      allow_if_string_contains_single_quote = 1
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::RequireInterpolationOfMetachars|Perl::Critic::Policy::ValuesAndExpressions::RequireInterpolationOfMetachars>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITINTERPOLATIONOFLITERALS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitLeadingZeros.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLEADINGZEROS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitLeadingZeros;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $LEADING_RX => qr<\A [+-]? (?: 0+ _* )+ [1-9]>xms;
  Readonly::Scalar my $EXPL       => [ 58 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'strict',
              description    =>
                  q<Don't allow any leading zeros at all.  Otherwise builtins that deal with Unix permissions, e.g. chmod, don't get flagged.>,
              default_string => '0',
              behavior       => 'boolean',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGHEST           }
  sub default_themes       { return qw< core pbp bugs certrec >         }
  sub applies_to           { return 'PPI::Token::Number::Octal' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem !~ $LEADING_RX;
      return $self->_create_violation($elem) if $self->{_strict};
      return if $self->_is_first_argument_of_chmod_or_umask($elem);
      return if $self->_is_second_argument_of_mkdir($elem);
      return if $self->_is_second_argument_of_mkfifo($elem);
      return if $self->_is_third_argument_of_dbmopen($elem);
      return if $self->_is_fourth_argument_of_sysopen($elem);
      return $self->_create_violation($elem);
  }
  
  sub _create_violation {
      my ($self, $elem) = @_;
  
      return $self->violation(
          qq<Integer with leading zeros: "$elem">,
          $EXPL,
          $elem
      );
  }
  
  sub _is_first_argument_of_chmod_or_umask {
      my ($self, $elem) = @_;
  
      my $previous_token = _previous_token_that_isnt_a_parenthesis($elem);
      return if not $previous_token;
  
      my $content = $previous_token->content();
      return $content eq 'chmod' || $content eq 'umask';
  }
  
  sub _is_second_argument_of_mkdir {
      my ($self, $elem) = @_;
  
      # Preceding comma.
      my $previous_token = _previous_token_that_isnt_a_parenthesis($elem);
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # Directory name.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      return $previous_token->content() eq 'mkdir';
  }
  
  sub _is_second_argument_of_mkfifo {
      my ($self, $elem) = @_;
  
      # Preceding comma.
      my $previous_token = _previous_token_that_isnt_a_parenthesis($elem);
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # FIFO name.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      return $previous_token->content() eq 'mkfifo'
          || $previous_token->content() eq 'POSIX::mkfifo';
  }
  
  sub _is_third_argument_of_dbmopen {
      my ($self, $elem) = @_;
  
      # Preceding comma.
      my $previous_token = _previous_token_that_isnt_a_parenthesis($elem);
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # File path.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      # Another comma.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # Variable name.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      return $previous_token->content() eq 'dbmopen';
  }
  
  sub _is_fourth_argument_of_sysopen {
      my ($self, $elem) = @_;
  
      # Preceding comma.
      my $previous_token = _previous_token_that_isnt_a_parenthesis($elem);
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # Mode.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      while ($previous_token and $previous_token->content() ne $COMMA) {
          $previous_token =
              _previous_token_that_isnt_a_parenthesis($previous_token);
      }
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # File name.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      # Yet another comma.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
      return if $previous_token->content() ne $COMMA;  # Don't know what it is.
  
      # File handle.
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      $previous_token =
          _previous_token_that_isnt_a_parenthesis($previous_token);
      return if not $previous_token;
  
      return $previous_token->content() eq 'sysopen';
  }
  
  sub _previous_token_that_isnt_a_parenthesis {
      my ($elem) = @_;
  
      my $previous_token = $elem->previous_token();
      while (
              $previous_token
          and (
                  not $previous_token->significant()
              or  $previous_token->content() eq $LEFT_PAREN
              or  $previous_token->content() eq $RIGHT_PAREN
          )
      ) {
          $previous_token = $previous_token->previous_token();
      }
  
      return $previous_token;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitLeadingZeros - Write C<oct(755)> instead of C<0755>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl interprets numbers with leading zeros as octal.  If that's what
  you really want, its better to use C<oct> and make it obvious.
  
      $var = 041;     # not ok, actually 33
      $var = oct(41); # ok
  
      chmod 0644, $file;                              # ok by default
      dbmopen %database, 'foo.db', 0600;              # ok by default
      mkdir $directory, 0755;                         # ok by default
      sysopen $filehandle, $filename, O_RDWR, 0666;   # ok by default
      umask 0002;                                     # ok by default
  
      use POSIX 'mkfifo';
      mkfifo $fifo, 0600;                             # ok by default
      POSIX::mkfifo $fifo, 0600;                      # ok by default
  
  =head1 CONFIGURATION
  
  If you want to ban all leading zeros, set C<strict> to a true value in
  a F<.perlcriticrc> file.
  
      [ValuesAndExpressions::ProhibitLeadingZeros]
      strict = 1
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLEADINGZEROS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitLongChainsOfMethodCalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLONGCHAINSOFMETHODCALLS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitLongChainsOfMethodCalls;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities };
  use Perl::Critic::Utils::PPI qw{ is_ppi_expression_or_generic_statement };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL =>
      q{Long chains of method calls indicate code that is too tightly coupled};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'max_chain_length',
              description     => 'The number of chained calls to allow.',
              default_string  => '3',
              behavior        => 'integer',
              integer_minimum => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOW          }
  sub default_themes   { return qw( core maintenance ) }
  sub applies_to       { return qw{ PPI::Statement };  }
  
  #-----------------------------------------------------------------------------
  
  sub _max_chain_length {
      my ( $self ) = @_;
  
      return $self->{_max_chain_length};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if not is_ppi_expression_or_generic_statement($elem);
  
      my $chain_length = 0;
      my $max_chain_length = $self->_max_chain_length();
      my @children = $elem->schildren();
      my $child = shift @children;
  
      while ($child) {
          # if it looks like we've got a subroutine call, drop the parameter
          # list.
          if (
                  $child->isa('PPI::Token::Word')
              and @children
              and $children[0]->isa('PPI::Structure::List')
          ) {
              shift @children;
          }
  
          if (
                  $child->isa('PPI::Token::Word')
              or  $child->isa('PPI::Token::Symbol')
          ) {
              if ( @children ) {
                  if ( $children[0]->isa('PPI::Token::Operator') ) {
                      if ( q{->} eq $children[0]->content() ) {
                          $chain_length++;
                          shift @children;
                      }
                  }
                  elsif ( not  $children[0]->isa('PPI::Token::Structure') ) {
                      $chain_length = 0;
                  }
              }
          }
          else {
              if ($chain_length > $max_chain_length) {
                  return
                      $self->violation(
                          "Found method-call chain of length $chain_length.",
                          $EXPL,
                          $elem,
                      );
              }
  
              $chain_length = 0;
          }
  
          $child = shift @children;
      }
  
      if ($chain_length > $max_chain_length) {
          return
              $self->violation(
                  "Found method-call chain of length $chain_length.",
                  $EXPL,
                  $elem,
              );
      }
  
      return;
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords MSCHWERN
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitLongChainsOfMethodCalls - Long chains of method calls indicate tightly coupled code.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  A long chain of method calls usually indicates that the code knows too
  much about the interrelationships between objects.  If the code is
  able to directly navigate far down a network of objects, then when the
  network changes structure in the future, the code will need to be
  modified to deal with the change.  The code is too tightly coupled and
  is brittle.
  
  
      $x = $y->a;           #ok
      $x = $y->a->b;        #ok
      $x = $y->a->b->c;     #questionable, but allowed by default
      $x = $y->a->b->c->d;  #not ok
  
  
  =head1 CONFIGURATION
  
  This policy has one option: C<max_chain_length> which controls how far
  the code is allowed to navigate.  The default value is 3.
  
  
  =head1 TO DO
  
  Add a C<class_method_exemptions> option to allow for things like
  
      File::Find::Rule
          ->name('*.blah')
          ->not_name('thingy')
          ->readable()
          ->directory()
          ->in(@roots);
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITLONGCHAINSOFMETHODCALLS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitMagicNumbers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMAGICNUMBERS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitMagicNumbers;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :characters :severities :data_conversion };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL =>
      q{Unnamed numeric literals make code less maintainable};
  Readonly::Scalar my $USE_READONLY_OR_CONSTANT =>
      ' Use the Readonly or Const::Fast module or the "constant" pragma instead';
  Readonly::Scalar my $TYPE_NOT_ALLOWED_SUFFIX =>
      ") are not allowed.$USE_READONLY_OR_CONSTANT";
  
  Readonly::Scalar my $UNSIGNED_NUMBER =>
      qr{
              \d+ (?: [$PERIOD] \d+ )?  # 1, 1.5, etc.
          |   [$PERIOD] \d+             # .3, .7, etc.
      }xms;
  Readonly::Scalar my $SIGNED_NUMBER => qr/ [-+]? $UNSIGNED_NUMBER /xms;
  
  Readonly::Scalar my $RANGE =>
      qr{
          \A
          ($SIGNED_NUMBER)
          [$PERIOD] [$PERIOD]
          ($SIGNED_NUMBER)
          (?:
              [$COLON] by [$LEFT_PAREN]
              ($UNSIGNED_NUMBER)
              [$RIGHT_PAREN]
          )?
          \z
      }xms;
  
  Readonly::Scalar my $SPECIAL_ARRAY_SUBSCRIPT_EXEMPTION => -1;
  
  #----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name           => 'allowed_values',
              description    => 'Individual and ranges of values to allow, and/or "all_integers".',
              default_string => '0 1 2',
              parser         => \&_parse_allowed_values,
          },
          {
              name               => 'allowed_types',
              description        => 'Kind of literals to allow.',
              default_string     => 'Float',
              behavior           => 'enumeration',
              enumeration_values => [ qw{ Binary Exp Float Hex Octal } ],
              enumeration_allow_multiple_values => 1,
          },
          {
              name           => 'allow_to_the_right_of_a_fat_comma',
              description    =>
                  q[Should anything to the right of a "=>" be allowed?],
              default_string => '1',
              behavior           => 'boolean',
          },
          {
              name            => 'constant_creator_subroutines',
              description     => q{Names of subroutines that create constants},
              behavior        => 'string list',
              list_always_present_values => [
                  qw<
                      Readonly Readonly::Scalar Readonly::Array Readonly::Hash
                      const
                  >,
              ],
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOW          }
  sub default_themes   { return qw( core maintenance certrec ) }
  sub applies_to       { return 'PPI::Token::Number'   }
  
  sub default_maximum_violations_per_document { return 10; }
  
  #----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      $self->_determine_checked_types();
  
      return $TRUE;
  }
  
  sub _parse_allowed_values {
      my ($self, $parameter, $config_string) = @_;
  
      my ( $all_integers_allowed, $allowed_values )
          = _determine_allowed_values($config_string);
  
      my $allowed_string = ' is not one of the allowed literal values (';
      if ($all_integers_allowed) {
          $allowed_string .= 'all integers';
  
          if ( %{$allowed_values} ) {
              $allowed_string .= ', ';
          }
      }
      $allowed_string
          .= ( join ', ', sort { $a <=> $b } keys %{$allowed_values} ) . ').'
          . $USE_READONLY_OR_CONSTANT;
  
      $self->{_allowed_values}       = $allowed_values;
      $self->{_all_integers_allowed} = $all_integers_allowed;
      $self->{_allowed_string}       = $allowed_string;
  
      return;
  }
  
  sub _determine_allowed_values {
      my ($config_string) = @_;
  
      my @allowed_values;
      my @potential_allowed_values;
      my $all_integers_allowed = 0;
  
      if ( defined $config_string ) {
          my @allowed_values_strings =
              grep {$_} split m/\s+/xms, $config_string;
  
          foreach my $value_string (@allowed_values_strings) {
              if ($value_string eq 'all_integers') {
                  $all_integers_allowed = 1;
              } elsif ( $value_string =~ m/ \A $SIGNED_NUMBER \z /xms ) {
                  push @potential_allowed_values, $value_string + 0;
              } elsif ( $value_string =~ m/$RANGE/xms ) {
                  my ( $minimum, $maximum, $increment ) = ($1, $2, $3);
                  $increment ||= 1;
  
                  $minimum += 0;
                  $maximum += 0;
                  $increment += 0;
  
                  for (                       ## no critic (ProhibitCStyleForLoops)
                      my $value = $minimum;
                      $value <= $maximum;
                      $value += $increment
                  ) {
                      push @potential_allowed_values, $value;
                  }
              } else {
                  die q{Invalid value for allowed_values: }, $value_string,
                      q{. Must be a number, a number range, or},
                      qq{ "all_integers".\n};
              }
          }
  
          if ($all_integers_allowed) {
              @allowed_values = grep { $_ != int $_ } @potential_allowed_values; ## no critic ( BuiltinFunctions::ProhibitUselessTopic )
          } else {
              @allowed_values = @potential_allowed_values;
          }
      } else {
          @allowed_values = (2);
      }
  
      if ( not $all_integers_allowed ) {
          push @allowed_values, 0, 1;
      }
      my %allowed_values = hashify(@allowed_values);
  
      return ( $all_integers_allowed, \%allowed_values );
  }
  
  sub _determine_checked_types {
      my ($self) = @_;
  
      my %checked_types = (
          'PPI::Token::Number::Binary'  => 'Binary literals (',
          'PPI::Token::Number::Float'   => 'Floating-point literals (',
          'PPI::Token::Number::Exp'     => 'Exponential literals (',
          'PPI::Token::Number::Hex'     => 'Hexadecimal literals (',
          'PPI::Token::Number::Octal'   => 'Octal literals (',
          'PPI::Token::Number::Version' => 'Version literals (',
      );
  
      # This will be set by the enumeration behavior specified in
      # supported_parameters() above.
      my $allowed_types = $self->{_allowed_types};
  
      foreach my $allowed_type ( keys %{$allowed_types} ) {
          delete $checked_types{"PPI::Token::Number::$allowed_type"};
  
          if ( $allowed_type eq 'Exp' ) {
  
              # because an Exp isa(Float).
              delete $checked_types{'PPI::Token::Number::Float'};
          }
      }
  
      $self->{_checked_types} = \%checked_types;
  
      return;
  }
  
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $self->{_allow_to_the_right_of_a_fat_comma} ) {
          return if _element_is_to_the_right_of_a_fat_comma($elem);
      }
  
      return if _element_is_in_an_include_readonly_or_version_statement(
          $self, $elem,
      );
      return if _element_is_in_a_plan_statement($elem);
      return if _element_is_in_a_constant_subroutine($elem);
      return if _element_is_a_package_statement_version_number($elem);
  
      my $literal = $elem->literal();
      if (
              defined $literal
          and not (
                      $self->{_all_integers_allowed}
                  and int $literal == $literal
              )
          and not defined $self->{_allowed_values}{$literal}
          and not (
                      _element_is_sole_component_of_a_subscript($elem)
                  and $literal == $SPECIAL_ARRAY_SUBSCRIPT_EXEMPTION
              )
      ) {
          return
              $self->violation(
                  $elem->content() . $self->{_allowed_string},
                  $EXPL,
                  $elem,
              );
      }
  
  
      my ( $number_type, $type_string );
  
      while (
          ( $number_type, $type_string ) = ( each %{ $self->{_checked_types} } )
      ) {
          if ( $elem->isa($number_type) ) {
              return
                  $self->violation(
                      $type_string . $elem->content() . $TYPE_NOT_ALLOWED_SUFFIX,
                      $EXPL,
                      $elem,
                  );
          }
      }
  
      return;
  }
  
  sub _element_is_to_the_right_of_a_fat_comma {
      my ($elem) = @_;
  
      my $previous = $elem->sprevious_sibling() or return;
  
      $previous->isa('PPI::Token::Operator') or return;
  
      return $previous->content() eq q[=>];
  }
  
  sub _element_is_sole_component_of_a_subscript {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
      if ( $parent and $parent->isa('PPI::Statement::Expression') ) {
          if ( $parent->schildren() > 1 ) {
              return 0;
          }
  
          my $grandparent = $parent->parent();
          if (
                  $grandparent
              and $grandparent->isa('PPI::Structure::Subscript')
          ) {
              return 1;
          }
      }
  
      return 0;
  }
  
  sub _element_is_in_an_include_readonly_or_version_statement {
      my ($self, $elem) = @_;
  
      my $parent = $elem->parent();
      while ($parent) {
          if ( $parent->isa('PPI::Statement') ) {
              return 1 if $parent->isa('PPI::Statement::Include');
  
              if ( $parent->isa('PPI::Statement::Variable') ) {
                  if ( $parent->type() eq 'our' ) {
                      my @variables = $parent->variables();
                      if (
                              scalar @variables == 1
                          and $variables[0] eq '$VERSION' ## no critic (RequireInterpolationOfMetachars)
                      ) {
                          return 1;
                      }
                  }
  
                  return 0;
              }
  
              my $first_token = $parent->first_token();
              if ( $first_token->isa('PPI::Token::Word') ) {
                  if ( $self->{_constant_creator_subroutines}{
                          $first_token->content() } ) {
                      return 1;
                  }
              } elsif ($parent->isa('PPI::Structure::Block')) {
                  return 0;
              }
          }
  
          $parent = $parent->parent();
      }
  
      return 0;
  }
  
  # Allow "plan tests => 39;".
  
  Readonly::Scalar my $PLAN_STATEMENT_MINIMUM_TOKENS => 4;
  
  sub _element_is_in_a_plan_statement {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
      return 0 if not $parent;
  
      return 0 if not $parent->isa('PPI::Statement');
  
      my @children = $parent->schildren();
      return 0 if @children < $PLAN_STATEMENT_MINIMUM_TOKENS;
  
      return 0 if not $children[0]->isa('PPI::Token::Word');
      return 0 if $children[0]->content() ne 'plan';
  
      return 0 if not $children[1]->isa('PPI::Token::Word');
      return 0 if $children[1]->content() ne 'tests';
  
      return 0 if not $children[2]->isa('PPI::Token::Operator');
      return 0 if $children[2]->content() ne '=>';
  
      return 1;
  }
  
  sub _element_is_in_a_constant_subroutine {
      my ($elem) = @_;
  
      my $parent = $elem->parent();
      return 0 if not $parent;
  
      return 0 if not $parent->isa('PPI::Statement');
  
      my $following = $elem->snext_sibling();
      if ($following) {
          return 0 if not $following->isa('PPI::Token::Structure');
          return 0 if $following->content() ne $SCOLON;
          return 0 if $following->snext_sibling();
      }
  
      my $preceding = $elem->sprevious_sibling();
      if ($preceding) {
          return 0 if not $preceding->isa('PPI::Token::Word');
          return 0 if $preceding->content() ne 'return';
          return 0 if $preceding->sprevious_sibling();
      }
  
      return 0 if $parent->snext_sibling();
      return 0 if $parent->sprevious_sibling();
  
      my $grandparent = $parent->parent();
      return 0 if not $grandparent;
  
      return 0 if not $grandparent->isa('PPI::Structure::Block');
  
      my $greatgrandparent = $grandparent->parent();
      return 0 if not $greatgrandparent;
      return 0 if not $greatgrandparent->isa('PPI::Statement::Sub');
  
      return 1;
  }
  
  sub _element_is_a_package_statement_version_number {
      my ($elem) = @_;
  
      my $parent = $elem->statement()
          or return 0;
  
      $parent->isa( 'PPI::Statement::Package' )
          or return 0;
  
      my $version = $parent->schild( 2 )
          or return 0;
  
      return $version == $elem;
  }
  
  1;
  
  __END__
  
  #----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitMagicNumbers - Don't use values that don't explain themselves.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  What is a "magic number"?  A magic number is a number that appears in
  code without any explanation; e.g.  C<$bank_account_balance *=
  57.492;>.  You look at that number and have to wonder where that
  number came from.  Since you don't understand the significance of the
  number, you don't understand the code.
  
  In general, numeric literals other than C<0> or C<1> in should not be used.
  Use the L<constant|constant> pragma or the L<Readonly|Readonly> or
  L<Const::Fast|Const::Fast> modules to give a descriptive name to the number.
  
  There are, of course, exceptions to when this rule should be applied.
  One good example is positioning of objects in some container like
  shapes on a blueprint or widgets in a user interface.  In these cases,
  the significance of a number can readily be determined by context.
  
  The maximum number of violations per document for this policy defaults
  to 10.
  
  
  =head2 Ways in which this module applies this rule.
  
  By default, this rule is relaxed in that C<2> is permitted to allow
  for common things like alternation, the STDERR file handle, etc..
  
  Numeric literals are allowed in C<use> and C<require> statements to
  allow for things like Perl version restrictions and
  L<Test::More|Test::More> plans.  Declarations of C<$VERSION> package
  variables are permitted.  Use of C<Readonly>, C<Readonly::Scalar>,
  C<Readonly::Array>, and C<Readonly::Hash> from the
  L<Readonly|Readonly> module are obviously valid, but use of
  C<Readonly::Scalar1>, C<Readonly::Array1>, and C<Readonly::Hash1> are
  specifically not supported.
  
  Use of binary, exponential, hexadecimal, octal, and version numbers,
  even for C<0> and C<1>, outside of C<use>/C<require>/C<Readonly>
  statements aren't permitted (but you can change this).
  
  There is a special exemption for accessing the last element of an
  array, i.e. C<$x[-1]>.
  
  
      $x = 0;                                   # ok
      $x = 0.0;                                 # ok
      $x = 1;                                   # ok
      $x = 1.0;                                 # ok
      $x = 1.5;                                 # not ok
      $x = 0b0                                  # not ok
      $x = 0b1                                  # not ok
      $x = 0x00                                 # not ok
      $x = 0x01                                 # not ok
      $x = 000                                  # not ok
      $x = 001                                  # not ok
      $x = 0e1                                  # not ok
      $x = 1e1                                  # not ok
  
      $frobnication_factor = 42;                # not ok
      use constant FROBNICATION_FACTOR => 42;   # ok
  
  
      use 5.6.1;                                # ok
      use Test::More plan => 57;                # ok
      plan tests => 39;                         # ok
      our $VERSION = 0.22;                      # ok
  
  
      $x = $y[-1]                               # ok
      $x = $y[-2]                               # not ok
  
  
  
      foreach my $solid (1..5) {                # not ok
          ...
      }
  
  
      use Readonly;
  
      Readonly my $REGULAR_GEOMETRIC_SOLIDS => 5;
  
      foreach my $solid (1..$REGULAR_GEOMETRIC_SOLIDS) {  #ok
          ...
      }
  
  
  =head1 CONFIGURATION
  
  This policy has four options: C<allowed_values>, C<allowed_types>,
  C<allow_to_the_right_of_a_fat_comma>, and C<constant_creator_subroutines>.
  
  
  =head2 C<allowed_values>
  
  The C<allowed_values> parameter is a whitespace delimited set of
  permitted number I<values>; this does not affect the permitted formats
  for numbers.  The defaults are equivalent to having the following in
  your F<.perlcriticrc>:
  
      [ValuesAndExpressions::ProhibitMagicNumbers]
      allowed_values = 0 1 2
  
  Note that this policy forces the values C<0> and C<1> into the
  permitted values.  Thus, specifying no values,
  
      allowed_values =
  
  is the same as simply listing C<0> and C<1>:
  
      allowed_values = 0 1
  
  The special C<all_integers> value, not surprisingly, allows all
  integral values to pass, subject to the restrictions on number types.
  
  Ranges can be specified as two (possibly fractional) numbers separated
  by two periods, optionally suffixed with an increment using the Perl 6
  C<:by()> syntax.  E.g.
  
      allowed_values = 7..10
  
  will allow 0, 1, 7, 8, 9, and 10 as literal values.  Using fractional
  values like so
  
      allowed_values = -3.5..-0.5:by(0.5)
  
  will permit -3.5, -3, -2.5, -2, -2.5, -1, -0.5, 0, and 1.
  Unsurprisingly, the increment defaults to 1, which means that
  
      allowed_values = -3.5..-0.5
  
  will make -3.5, -2.5, -2.5, -0.5, 0, and 1 valid.
  
  Ranges are not lazy, i.e. you'd better have a lot of memory available
  if you use a range of C<1..1000:by(0.01)>.  Also remember that all of
  this is done using floating-point math, which means that
  C<1..10:by(0.3333)> is probably not going to be very useful.
  
  Specifying an upper limit that is less than the lower limit will
  result in no values being produced by that range.  Negative increments
  are not permitted.
  
  Multiple ranges are permitted.
  
  To put this all together, the following is a valid, though not likely
  to be used, F<.perlcriticrc> entry:
  
      [ValuesAndExpressions::ProhibitMagicNumbers]
      allowed_values = 3.1415269 82..103 -507.4..57.8:by(0.2) all_integers
  
  
  =head2 C<allowed_types>
  
  The C<allowed_types> parameter is a whitespace delimited set of
  subclasses of L<PPI::Token::Number|PPI::Token::Number>.
  
  Decimal integers are always allowed.  By default, floating-point
  numbers are also allowed.
  
  For example, to allow hexadecimal literals, you could configure this
  policy like
  
      [ValuesAndExpressions::ProhibitMagicNumbers]
      allowed_types = Hex
  
  but without specifying anything for C<allowed_values>, the allowed
  hexadecimal literals will be C<0x00>, C<0x01>, and C<0x02>.  Note,
  also, as soon as you specify a value for this parameter, you must
  include C<Float> in the list to continue to be able to use floating
  point literals.  This effect can be used to restrict literals to only
  decimal integers:
  
      [ValuesAndExpressions::ProhibitMagicNumbers]
      allowed_types =
  
  If you permit exponential notation, you automatically also allow
  floating point values because an exponential is a subclass of
  floating-point in L<PPI|PPI>.
  
  
  =head2 C<allow_to_the_right_of_a_fat_comma>
  
  If this is set, you can put any number to the right of a fat comma.
  
      my %hash =     ( a => 4512, b => 293 );         # ok
      my $hash_ref = { a => 4512, b => 293 };         # ok
      some_subroutine( a => 4512, b => 293 );         # ok
  
  Currently, this only means I<directly> to the right of the fat comma.  By
  default, this value is I<true>.
  
  
  =head2 C<constant_creator_subroutines>
  
  This parameter allows you to specify the names of subroutines that create
  constants, in addition to C<Readonly>, C<Const::Fast>, and friends.  For
  example, if you use a custom C<Const::Fast>-like module that supports a
  C<create_constant> subroutine to create constants, you could add something
  like the following to your F<.perlcriticrc>:
  
      [ValuesAndExpressions::ProhibitMagicNumbers]
      constant_creator_subroutines = create_constant
  
  If you have more than one name to add, separate them by whitespace.
  
  The subroutine name should appear exactly as it is in your code.  For example,
  if your code does not import the creating subroutine
  subroutine, you would need to configure this policy as something like
  
      [ValuesAndExpressions::ProhibitMagicNumbers]
      constant_creator_subroutines = create_constant Constant::Create::create_constant
  
  
  =head1 BUGS
  
  There is currently no way to permit version numbers in regular code,
  even if you include them in the C<allowed_types>.  Some may actually
  consider this a feature.
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMAGICNUMBERS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitMismatchedOperators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMISMATCHEDOPERATORS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitMismatchedOperators;
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Mismatched operator>;
  Readonly::Scalar my $EXPL => q<Numeric/string operators and operands should match>;
  
  # token compatibility [ numeric, string ]
  Readonly::Hash my %TOKEN_COMPATIBILITY => (
      'PPI::Token::Number' => [$TRUE,  $FALSE],
      'PPI::Token::Symbol' => [$TRUE,  $TRUE ],
      'PPI::Token::Quote'  => [$FALSE, $TRUE ],
  );
  
  Readonly::Hash my %FILE_OPERATOR_COMPATIBILITY =>
      map {; "-$_" => [$TRUE, $FALSE] }
          qw< r w x o R W X O e z s f d l p S b c t u g k T B M A >;
  
  Readonly::Scalar my $TOKEN_COMPATIBILITY_INDEX_NUMERIC => 0;
  Readonly::Scalar my $TOKEN_COMPATIBILITY_INDEX_STRING  => 1;
  
  Readonly::Hash my %OPERATOR_TYPES => (
      # numeric
      (
          map { $_ => $TOKEN_COMPATIBILITY_INDEX_NUMERIC }
              qw[ == != > >= < <= + - * / += -= *= /= ]
      ),
      # string
      map { $_ => $TOKEN_COMPATIBILITY_INDEX_STRING }
          qw< eq ne lt gt le ge . .= >,
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw< core bugs certrule >        }
  sub applies_to           { return 'PPI::Token::Operator' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem) = @_;
  
      my $elem_text = $elem->content();
  
      return if not exists $OPERATOR_TYPES{$elem_text};
  
      my $leading_operator = $self->_get_potential_leading_operator($elem)
          or return;
  
      my $next_elem = $elem->snext_sibling() or return;
  
      if ( $next_elem->isa('PPI::Token::Operator') ) {
          $elem_text .= $next_elem->content();
          $next_elem = $next_elem->snext_sibling();
      }
  
      return if not exists $OPERATOR_TYPES{$elem_text};
      my $operator_type = $OPERATOR_TYPES{$elem_text};
  
      my $leading_operator_compatibility =
          $self->_get_token_compatibility($leading_operator);
      my $next_compatibility = $self->_get_token_compatibility($next_elem);
  
      return if
              (
                      ! defined $leading_operator_compatibility
                  ||  $leading_operator_compatibility->[$operator_type]
              )
          &&  (
                      ! defined $next_compatibility
                  ||  $next_compatibility->[$operator_type]
              );
  
      return if
              $operator_type
          &&  defined $leading_operator_compatibility
          &&  ! $leading_operator_compatibility->[$operator_type]
          &&  $self->_have_stringy_x($leading_operator); # RT 54524
  
      return $self->violation($DESC, $EXPL, $elem);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_token_compatibility {
      my ($self, $elem) = @_;
  
      return $FILE_OPERATOR_COMPATIBILITY{ $elem->content() }
          if $self->_is_file_operator($elem);
  
      for my $class (keys %TOKEN_COMPATIBILITY) {
          return $TOKEN_COMPATIBILITY{$class} if $elem->isa($class);
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _have_stringy_x {
      my ($self, $elem) = @_;
  
      return if not $elem;
  
      my $prev_oper = $elem->sprevious_sibling() or return;
  
      return if not $prev_oper->isa('PPI::Token::Operator');
      return if 'x' ne $prev_oper->content();
  
      return !! $prev_oper->sprevious_sibling();
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_potential_leading_operator {
      my ($self, $elem) = @_;
  
      my $previous_element = $elem->sprevious_sibling() or return;
  
      if ( $self->_get_token_compatibility($previous_element) ) {
          my $previous_sibling = $previous_element->sprevious_sibling();
          if (
              $previous_sibling and $self->_is_file_operator($previous_sibling)
          ) {
              $previous_element = $previous_sibling;
          }
      }
  
      return $previous_element;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_file_operator {
      my ($self, $elem) = @_;
  
      return if not $elem;
      return if not $elem->isa('PPI::Token::Operator');
      return !! $FILE_OPERATOR_COMPATIBILITY{ $elem->content() }
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitMismatchedOperators - Don't mix numeric operators with string operands, or vice-versa.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using the wrong operator type for a value can obscure coding intent
  and possibly lead to subtle errors.  An example of this is mixing a
  string equality operator with a numeric value, or vice-versa.
  
      if ($foo == 'bar') {}     #not ok
      if ($foo eq 'bar') {}     #ok
      if ($foo eq 123) {}       #not ok
      if ($foo == 123) {}       #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  If L<warnings|warnings> are enabled, the Perl interpreter usually
  warns you about using mismatched operators at run-time.  This Policy
  does essentially the same thing, but at author-time.  That way, you
  can find out about them sooner.
  
  
  =head1 AUTHOR
  
  Peter Guzis <pguzis@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Peter Guzis.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMISMATCHEDOPERATORS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitMixedBooleanOperators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMIXEDBOOLEANOPERATORS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitMixedBooleanOperators;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %LOW_BOOLEANS  => hashify( qw( not or and ) );
  Readonly::Hash my %HIGH_BOOLEANS => hashify( qw( ! || && ||= &&= //=) );
  
  Readonly::Hash my %EXEMPT_TYPES => hashify(
      qw(
          PPI::Statement::Block
          PPI::Statement::Scheduled
          PPI::Statement::Package
          PPI::Statement::Include
          PPI::Statement::Sub
          PPI::Statement::Variable
          PPI::Statement::Compound
          PPI::Statement::Data
          PPI::Statement::End
      )
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Mixed high and low-precedence booleans};
  Readonly::Scalar my $EXPL => [ 70 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                  }
  sub default_severity     { return $SEVERITY_HIGH      }
  sub default_themes       { return qw( core bugs pbp certrec ) }
  sub applies_to           { return 'PPI::Statement'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
  
      my ( $self, $elem, undef ) = @_;
  
      # PPI::Statement is the ancestor of several types of PPI elements.
      # But for this policy, we only want the ones that generally
      # represent a single statement or expression.  There might be
      # better ways to do this, such as scanning for a semi-colon or
      # some other marker.
  
      return if exists $EXEMPT_TYPES{ ref $elem };
  
      if (    $elem->find_first(\&_low_boolean)
           && $elem->find_first(\&_high_boolean) ) {
  
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  #-----------------------------------------------------------------------------
  
  sub _low_boolean {
      my (undef, $elem) = @_;
      return if $elem->isa('PPI::Statement');
      $elem->isa('PPI::Token::Operator') || return 0;
      return exists $LOW_BOOLEANS{$elem};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _high_boolean {
      my (undef, $elem) = @_;
      return if $elem->isa('PPI::Statement');
      $elem->isa('PPI::Token::Operator') || return 0;
      return exists $HIGH_BOOLEANS{$elem};
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitMixedBooleanOperators - Write C< !$foo && $bar || $baz > instead of C< not $foo && $bar or $baz>.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway advises against combining the low-precedence booleans ( C<and
  or not> ) with the high-precedence boolean operators ( C<&& || !> ) in
  the same expression.  Unless you fully understand the differences
  between the high and low-precedence operators, it is easy to
  misinterpret expressions that use both.  And even if you do understand
  them, it is not always clear if the author actually intended it.
  
      next if not $foo || $bar;  #not ok
      next if !$foo || $bar;     #ok
      next if !( $foo || $bar ); #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITMIXEDBOOLEANOPERATORS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitNoisyQuotes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITNOISYQUOTES';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitNoisyQuotes;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $NOISE_RX => qr{\A ["']  [^ \w () {} [\] <> ]{1,2}  ['"] \z}xms;
  Readonly::Scalar my $DESC     => q{Quotes used with a noisy string};
  Readonly::Scalar my $EXPL     => [ 53 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return qw(PPI::Token::Quote::Double
                                       PPI::Token::Quote::Single) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem !~ $NOISE_RX;
      my $statement = $elem->statement;
      return if $statement
          && $statement->isa('PPI::Statement::Include')
          && $statement->type eq 'use'
          && $statement->module eq 'overload';
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitNoisyQuotes - Use C<q{}> or C<qq{}> instead of quotes for awkward-looking strings.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Don't use quotes for one or two-character strings of non-alphanumeric
  characters (i.e. noise).  These tend to be hard to read.  For
  legibility, use C<q{}> or a named value.  However, braces,
  parentheses and brackets tend to look better in quotes, so those
  are allowed.
  
      $str = join ',', @list;     #not ok
      $str = join ",", @list;     #not ok
      $str = join q{,}, @list;    #better
  
      $COMMA = q{,};
      $str = join $COMMA, @list;  #best
  
      $lbrace = '(';          #ok
      $rbrace = ')';          #ok
      print '(', @list, ')';  #ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::ProhibitEmptyQuotes|Perl::Critic::Policy::ValuesAndExpressions::ProhibitEmptyQuotes>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITNOISYQUOTES

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitQuotesAsQuotelikeOperatorDelimiters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITQUOTESASQUOTELIKEOPERATORDELIMITERS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitQuotesAsQuotelikeOperatorDelimiters;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{
      :booleans :characters :severities :data_conversion
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %DESCRIPTIONS => (
      $QUOTE    => q{Single-quote used as quote-like operator delimiter},
      $DQUOTE   => q{Double-quote used as quote-like operator delimiter},
      $BACKTICK => q{Back-quote (back-tick) used as quote-like operator delimiter},
  );
  
  Readonly::Scalar my $EXPL =>
      q{Using quotes as delimiters for quote-like operators obfuscates code};
  
  Readonly::Array my @OPERATORS => qw{ m q qq qr qw qx s tr y };
  
  Readonly::Hash my %INFO_RETRIEVERS_BY_PPI_CLASS => (
      'PPI::Token::Quote::Literal'        => \&_info_for_single_character_operator,
      'PPI::Token::Quote::Interpolate'    => \&_info_for_two_character_operator,
      'PPI::Token::QuoteLike::Command'    => \&_info_for_two_character_operator,
      'PPI::Token::QuoteLike::Regexp'     => \&_info_for_two_character_operator,
      'PPI::Token::QuoteLike::Words'      => \&_info_for_two_character_operator,
      'PPI::Token::Regexp::Match'         => \&_info_for_match,
      'PPI::Token::Regexp::Substitute'    => \&_info_for_single_character_operator,
      'PPI::Token::Regexp::Transliterate' => \&_info_for_transliterate,
  );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name               => 'single_quote_allowed_operators',
              description        =>
                  'The operators to allow single-quotes as delimiters for.',
              default_string     => 'm s qr qx',
              behavior           => 'enumeration',
              enumeration_values => [ @OPERATORS ],
              enumeration_allow_multiple_values => 1,
          },
          {
              name               => 'double_quote_allowed_operators',
              description        =>
                  'The operators to allow double-quotes as delimiters for.',
              default_string     => $EMPTY,
              behavior           => 'enumeration',
              enumeration_values => [ @OPERATORS ],
              enumeration_allow_multiple_values => 1,
          },
          {
              name               => 'back_quote_allowed_operators',
              description        =>
                  'The operators to allow back-quotes (back-ticks) as delimiters for.',
              default_string     => $EMPTY,
              behavior           => 'enumeration',
              enumeration_values => [ @OPERATORS ],
              enumeration_allow_multiple_values => 1,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM       }
  sub default_themes   { return qw( core maintenance ) }
  
  sub applies_to {
      return qw{
          PPI::Token::Quote::Interpolate
          PPI::Token::Quote::Literal
          PPI::Token::QuoteLike::Command
          PPI::Token::QuoteLike::Regexp
          PPI::Token::QuoteLike::Words
          PPI::Token::Regexp::Match
          PPI::Token::Regexp::Substitute
          PPI::Token::Regexp::Transliterate
      };
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      $self->{_allowed_operators_by_delimiter} = {
          $QUOTE    => $self->_single_quote_allowed_operators(),
          $DQUOTE   => $self->_double_quote_allowed_operators(),
          $BACKTICK => $self->_back_quote_allowed_operators(),
      };
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _single_quote_allowed_operators {
      my ( $self ) = @_;
  
      return $self->{_single_quote_allowed_operators};
  }
  
  sub _double_quote_allowed_operators {
      my ( $self ) = @_;
  
      return $self->{_double_quote_allowed_operators};
  }
  
  sub _back_quote_allowed_operators {
      my ( $self ) = @_;
  
      return $self->{_back_quote_allowed_operators};
  }
  
  sub _allowed_operators_by_delimiter {
      my ( $self ) = @_;
  
      return $self->{_allowed_operators_by_delimiter};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      my $info_retriever = $INFO_RETRIEVERS_BY_PPI_CLASS{ ref $elem };
      return if not $info_retriever;
  
      my ($operator, $delimiter) = $info_retriever->( $elem );
  
      my $allowed_operators =
          $self->_allowed_operators_by_delimiter()->{$delimiter};
      return if not $allowed_operators;
  
      if ( not $allowed_operators->{$operator} ) {
          return $self->violation( $DESCRIPTIONS{$delimiter}, $EXPL, $elem );
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _info_for_single_character_operator {
      my ( $elem ) = @_;
  
      ## no critic (ProhibitParensWithBuiltins)
      return ( substr ($elem, 0, 1), substr ($elem, 1, 1) );
      ## use critic
  }
  
  #-----------------------------------------------------------------------------
  
  sub _info_for_two_character_operator {
      my ( $elem ) = @_;
  
      ## no critic (ProhibitParensWithBuiltins)
      return ( substr ($elem, 0, 2), substr ($elem, 2, 1) );
      ## use critic
  }
  
  #-----------------------------------------------------------------------------
  
  sub _info_for_match {
      my ( $elem ) = @_;
  
      if ( $elem =~ m/ ^ m /xms ) {
          return ('m', substr $elem, 1, 1);
      }
  
      return ('m', q{/});
  }
  
  #-----------------------------------------------------------------------------
  
  sub _info_for_transliterate {
      my ( $elem ) = @_;
  
      if ( $elem =~ m/ ^ tr /xms ) {
          return ('tr', substr $elem, 2, 1);
      }
  
      return ('y', substr $elem, 1, 1);
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords Schwern
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitQuotesAsQuotelikeOperatorDelimiters - Don't use quotes (C<'>, C<">, C<`>) as delimiters for the quote-like operators.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  With the obvious exception of using single-quotes to prevent
  interpolation, using quotes with the quote-like operators kind of
  defeats the purpose of them and produces obfuscated code, causing
  problems for future maintainers and their editors/IDEs.
  
      $x = q"q";                #not ok
      $x = q'q';                #not ok
      $x = q`q`;                #not ok
  
      $x = qq"q";               #not ok
      $x = qr"r";               #not ok
      $x = qw"w";               #not ok
  
      $x = qx`date`;            #not ok
  
      $x =~ m"m";               #not ok
      $x =~ s"s"x";             #not ok
      $x =~ tr"t"r";            #not ok
      $x =~ y"x"y";             #not ok
  
      $x =~ m'$x';              #ok
      $x =~ s'$x'y';            #ok
      $x = qr'$x'm;             #ok
      $x = qx'finger foo@bar';  #ok
  
  
  =head1 CONFIGURATION
  
  This policy has three options: C<single_quote_allowed_operators>,
  C<double_quote_allowed_operators>, and
  C<back_quote_allowed_operators>, which control which operators are
  allowed to use each of C<'>, C<">, C<`> as delimiters, respectively.
  
  The values allowed for these options are a whitespace delimited
  selection of the C<m>, C<q>, C<qq>, C<qr>, C<qw>, C<qx>, C<s>, C<tr>,
  and C<y> operators.
  
  By default, double quotes and back quotes (backticks) are not allowed
  as delimiters for any operators and single quotes are allowed as
  delimiters for the C<m>, C<qr>, C<qx>, and C<s> operators.  These
  defaults are equivalent to having the following in your
  F<.perlcriticrc>:
  
      [ValuesAndExpressions::ProhibitQuotesAsQuotelikeOperatorDelimiters]
      single_quote_allowed_operators = m s qr qx
      double_quote_allowed_operators =
      back_quote_allowed_operators =
  
  
  =head1 SUGGESTED BY
  
  Michael Schwern
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITQUOTESASQUOTELIKEOPERATORDELIMITERS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitSpecialLiteralHeredocTerminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITSPECIALLITERALHEREDOCTERMINATOR';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitSpecialLiteralHeredocTerminator;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %SPECIAL_LITERAL => map { '__' . $_ . '__' => 1 }
                                        qw( FILE LINE PACKAGE END DATA );
  Readonly::Scalar my $DESC =>
      q{Heredoc terminator must not be a special literal};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                       }
  sub default_severity     { return $SEVERITY_MEDIUM         }
  sub default_themes       { return qw(core maintenance)     }
  sub applies_to           { return 'PPI::Token::HereDoc'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # remove << and (optional) quotes from around terminator
      ( my $heredoc_terminator = $elem ) =~
          s{ \A << \s* (["']?) (.*) \1 \z }{$2}xms;
  
      if ( $SPECIAL_LITERAL{ $heredoc_terminator } ) {
          my $expl = qq{Used "$heredoc_terminator" as heredoc terminator};
          return $self->violation( $DESC, $expl, $elem );
      }
  
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitSpecialLiteralHeredocTerminator - Don't write C< print <<'__END__' >.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using one of Perl's special literals as a HEREDOC terminator could be
  confusing to tools that try to parse perl.
  
      print <<'__END__';           #not ok
      Hello world
      __END__
  
      print <<'__END_OF_WORLD__';  #ok
      Goodbye world!
      __END_OF_WORLD__
  
  The special literals that this policy prohibits are:
  
  =over
  
  =item __END__
  
  =item __DATA__
  
  =item __PACKAGE__
  
  =item __FILE__
  
  =item __LINE__
  
  =back
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator|Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator>
  
  L<Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator|Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator>
  
  
  =head1 AUTHOR
  
  Kyle Hasselbacher <kyle@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Kyle Hasselbacher.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITSPECIALLITERALHEREDOCTERMINATOR

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/ProhibitVersionStrings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITVERSIONSTRINGS';
  package Perl::Critic::Policy::ValuesAndExpressions::ProhibitVersionStrings;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Version string used};
  Readonly::Scalar my $EXPL => q{Use a real number instead};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                        }
  sub default_severity     { return $SEVERITY_MEDIUM          }
  sub default_themes       { return qw(core pbp maintenance)  }
  sub applies_to           { return 'PPI::Statement::Include' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ($self, $elem, undef) = @_;
  
      my $version;
  
      if ( my $module = $elem->module() ) {
          return if $module eq 'lib';
  
          $version = $elem->module_version();
      } else {
          $version = $elem->schild(1);
      }
  
      return if not defined $version;
      return if not $version->isa('PPI::Token::Number::Version');
  
      return $self->violation($DESC, $EXPL, $elem);
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::ProhibitVersionStrings - Don't use strings like C<v1.4> or C<1.4.5> when including other modules.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Whenever you C<use> or C<require> a module, you can specify a minimum
  version requirement.  To ensure compatibility with older Perls, this
  version number should be expressed as a floating-point number.  Do not
  use v-strings or three-part numbers.  The Perl convention for
  expressing version numbers as floats is: version + (patch level /
  1000).
  
      use Foo v1.2    qw(foo bar);  # not ok
      use Foo 1.2.03  qw(foo bar);  # not ok
      use Foo 1.00203 qw(foo bar);  # ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_PROHIBITVERSIONSTRINGS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireConstantVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRECONSTANTVERSION';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireConstantVersion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Carp;
  use English qw(-no_match_vars);
  use Perl::Critic::Utils qw<
      :booleans :characters :classification :data_conversion :language
      :severities
  >;
  use Perl::Critic::Utils::PPI qw{
      is_ppi_constant_element
      get_next_element_in_same_simple_statement
      get_previous_module_used_on_same_line
  };
  use Readonly;
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $BIND_REGEX => q<=~>;
  Readonly::Scalar my $DOLLAR => q<$>;
  # All uses of the $DOLLAR variable below are to prevent false failures in
  # xt/93_version.t.
  Readonly::Scalar my $QV => q<qv>;
  Readonly::Scalar my $VERSION_MODULE => q<version>;
  Readonly::Scalar my $VERSION_VARIABLE => $DOLLAR . q<VERSION>;
  
  # Operators which would make a new value our of our $VERSION, and therefore
  # not modify it. I'm sure this list is not exhaustive. The logical operators
  # generally do not qualify for this list. At least, I think not.
  Readonly::Hash my %OPERATOR_WHICH_MAKES_NEW_VALUE => hashify( qw{
      = . + - * ** / % ^ ~ & | > < == != >= <= eq ne gt lt ge le
      } );
  
  Readonly::Scalar my $DESC => $DOLLAR . q<VERSION value must be a constant>;
  Readonly::Scalar my $EXPL => qq<Computed ${DOLLAR}VERSION may tie the code to a single repository, or cause spooky action from a distance>;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return (
          {
              name    => 'allow_version_without_use_on_same_line',
              description =>
                  q{Allow qv() and version->new() without a 'use version' on the same line.},
              default_string => $FALSE,
              behavior => 'boolean',
          }
      );
  }
  sub default_severity     { return $SEVERITY_LOW              }
  sub default_themes       { return qw( core maintenance )     }
  sub applies_to           { return 'PPI::Token::Symbol'       }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      # Any variable other than $VERSION is ignored.
      return if $VERSION_VARIABLE ne $elem->content();
  
      # Get the next thing (presumably an operator) after $VERSION. The $VERSION
      # might be in a list, so if we get nothing we move upwards until we hit a
      # simple statement. If we have nothing at this point, we do not understand
      # the code, and so we return.
      my $operator;
      return if
          not $operator = get_next_element_in_same_simple_statement( $elem );
  
      # If the next operator is a regex binding, and its other operand is a
      # substitution operator, it is an attempt to modify $VERSION, so we
      # return an error to that effect.
      return $self->violation( $DESC, $EXPL, $elem )
          if $self->_validate_operator_bind_regex( $operator, $elem );
  
      # If the presumptive operator is not an assignment operator of some sort,
      # we are not modifying $VERSION at all, and so we just return.
      return if not $operator = _check_for_assignment_operator( $operator );
  
      # If there is no operand to the right of the assignment, we do not
      # understand the code; simply return.
      my $value;
      return if not $value = $operator->snext_sibling();
  
      # If the value is symbol '$VERSION', just return as we will see it again
      # later.
      return if
              $value->isa( 'PPI::Token::Symbol' )
          and $value->content() eq $VERSION_VARIABLE;
  
      # If the value is a word, there are a number of acceptable things it could
      # be. Check for these. If there was a problem, return it.
      $value = $self->_validate_word_token( $elem, $value );
      return $value if $value->isa( 'Perl::Critic::Exception' );
  
      # If the value is anything but a constant, we cry foul.
      return $self->violation( $DESC, $EXPL, $elem )
          if not is_ppi_constant_element( $value );
  
      # If we have nothing after the value, it is OK.
      my $structure;
      return if
          not $structure = get_next_element_in_same_simple_statement( $value );
  
      # If we have a semicolon after the value, it is OK.
      return if $SCOLON eq $structure->content();
  
      # If there is anything else after the value, we cry foul.
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  # Check if the element is an assignment operator. 
  
  sub _check_for_assignment_operator {
      my ( $operator ) = @_;
  
      return if not $operator->isa( 'PPI::Token::Operator' );
      return $operator if is_assignment_operator($operator->content());
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # Validate a bind_regex ('=~') operator appearing after $VERSION. We return
  # true if the operator is in fact '=~', and its next sibling isa
  # PPI::Token::Regexp::Substitute. Otherwise we return false.
  
  sub _validate_operator_bind_regex {
      my ( $self, $operator, $elem ) = @_;
  
      # We are not interested in anything but '=~ s/../../'.
      return if $BIND_REGEX ne $operator->content();
      my $operand;
      return if not $operand = $operator->snext_sibling();
      return if not $operand->isa( 'PPI::Token::Regexp::Substitute' );
  
      # The substitution is OK if it is of the form
      # '($var = $VERSION) =~ s/../../'.
  
      # We can't look like the desired form if we have a next sig. sib.
      return $TRUE if $elem->snext_sibling();
  
      # We can't look like the desired form if we are not in a list.
      my $containing_list;
      $containing_list = $elem->parent()
          and $containing_list->isa( 'PPI::Statement' )
          and $containing_list = $containing_list->parent()
          and $containing_list->isa( 'PPI::Structure::List' )
          or return $TRUE;
  
      # If we have no prior element, we're ( $VERSION ) =~ s/../../,
      # which flunks.
      my $prior = $elem->sprevious_sibling() or return $TRUE;
  
      # If the prior element is an operator which makes a new value, we pass.
      return if $prior->isa( 'PPI::Token::Operator' )
          && $OPERATOR_WHICH_MAKES_NEW_VALUE{ $prior->content() };
  
      # Now things get complicated, as RT #55600 shows. We need to grub through
      # the entire list, looking for something that looks like a subroutine
      # call, but without parens around the argument list. This catches the
      # ticket's case, which was
      # ( $foo = sprintf '%s/%s', __PACKAGE__, $VERSION ) =~ s/../../.
      my $current = $prior;
      while( $prior = $current->sprevious_sibling() ) {
          $prior->isa( 'PPI::Token::Word' ) or next;
          is_function_call( $prior) or next;
          # If this function has its own argument list, we need to keep looking;
          # otherwise we have found a function with no parens, and we can
          # return.
          $current->isa( 'PPI::Structure::List' )
              or return;
      } continue {
          $current = $prior;
      }
  
      # Maybe the whole list was arguments for a subroutine or method call.
      $prior = $containing_list->sprevious_sibling()
          or return $TRUE;
      if ( $prior->isa( 'PPI::Token::Word' ) ) {
          return if is_method_call( $prior );
          return if is_function_call( $prior );
      }
  
      # Anything left is presumed a violation.
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  # Validating a PPI::Token::Word is a complicated business, so we split it out
  # into its own subroutine. The $elem is to be used in forming the error
  # message, and the $value is the PPI::Token::Word we just encountered. The
  # return is either a PPI::Element for further analysis, or a
  # Perl::Critic::Exception to be returned.
  
  sub _validate_word_token {
      my ( $self, $elem, $value ) = @_;
  
      if ( $value->isa( 'PPI::Token::Word' ) ) {
          my $content = $value->content();
  
          # If the word is of the form 'v\d+' it may be the first portion of a
          # misparsed (by PPI) v-string. It is really a v-string if the next
          # element is a number. Unless v-strings are allowed, we return an
          # error.
          if ( $content =~ m/ \A v \d+ \z /smx ) {
              $value = $self->_validate_word_vstring( $elem, $value );
          }
          elsif ( $QV eq $content ) {
              # If the word is 'qv' we suspect use of the version module. If
              # 'use version' appears on the same line, _and_ the remainder of
              # the expression is of the form '(value)', we extract the value
              # for further analysis.
  
              $value = $self->_validate_word_qv( $elem, $value );
          }
          elsif ( $VERSION_MODULE eq $content ) {
              # If the word is 'version' we suspect use of the version module.
              # Check to see if it is properly used.
              $value = $self->_validate_word_version( $elem, $value );
          }
      }
  
      return $value;
  }
  
  #-----------------------------------------------------------------------------
  
  # Validate $VERSION = v1.2.3;
  # Note that this is needed because PPI mis-parses the 'v1.2.3' construct into
  # a word ('v1') and a number of some sort ('.2.3'). This method should only be
  # called if it is already known that the $value is a PPI::Token::Word matching
  # m/ \A v \d+ \z /smx;
  
  sub _validate_word_vstring {
      my ( $self, $elem, $value ) = @_;
  
      # Check for the second part of the mis-parsed v-string, flunking if it is
      # not found.
      my $next;
      return $self->violation( $DESC, $EXPL, $elem )
          if
                  not $next = $value->snext_sibling()
              or  not $next->isa( 'PPI::Token::Number' );
  
      # Return the second part of the v-string for further analysis.
      return $next;
  }
  
  #-----------------------------------------------------------------------------
  
  # Validate $VERSION = qv();
  
  sub _validate_word_qv {
      my ( $self, $elem, $value ) = @_;
  
      # Unless we are specifically allowing this construction without the
      # 'use version;' on the same line, check for it and flunk if we do not
      # find it.
      $self->{_allow_version_without_use_on_same_line}
          or do {
              my $module;
              return $self->violation( $DESC, $EXPL, $elem )
                  if not
                      $module = get_previous_module_used_on_same_line($value);
              return $self->violation( $DESC, $EXPL, $elem )
                  if $VERSION_MODULE ne $module->content();
          };
  
      # Dig out the first argument of 'qv()', flunking if we can not find it.
      my $next;
      return $self->violation( $DESC, $EXPL, $elem )
          if not (
                  $next = $value->snext_sibling()
              and $next->isa( 'PPI::Structure::List' )
              and $next = $next->schild( 0 )
              and $next->isa( 'PPI::Statement::Expression' )
              and $next = $next->schild( 0 )
          );
  
      # Return the qv() argument for further analysis.
      return $next;
  }
  
  #-----------------------------------------------------------------------------
  
  # Validate $VERSION = version->new();
  
  # TODO: Fix this EVIL dual-purpose return value.  This is ugggggleeeee.
  sub _validate_word_version {
      my ( $self, $elem, $value ) = @_;
  
      # Unless we are specifically allowing this construction without the
      # 'use version;' on the same line, check for it and flunk if we do not
      # find it.
      $self->{_allow_version_without_use_on_same_line}
          or do {
              my $module;
              return $self->violation( $DESC, $EXPL, $elem )
                  if not
                      $module = get_previous_module_used_on_same_line($value);
              return $self->violation( $DESC, $EXPL, $elem )
                  if $VERSION_MODULE ne $module->content();
          };
  
      # Dig out the first argument of '->new()', flunking if we can not find it.
      my $next;
      return $next if
              $next = $value->snext_sibling()
          and $next->isa( 'PPI::Token::Operator' )
          and q{->} eq $next->content()
          and $next = $next->snext_sibling()
          and $next->isa( 'PPI::Token::Word' )
          and q{new} eq $next->content()
          and $next = $next->snext_sibling()
          and $next->isa( 'PPI::Structure::List' )
          and $next = $next->schild( 0 )
          and $next->isa( 'PPI::Statement::Expression' )
          and $next = $next->schild( 0 );
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::RequireConstantVersion - Require $VERSION to be a constant rather than a computed value.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  The $VERSION variable of a module should be a simple constant - either a
  number, a single-quotish string, or a 'use version' object. In the latter case
  the 'use version;' must appear on the same line as the object construction.
  
  Computing the version has problems of various severities.
  
  The most benign violation is computing the version from (e.g.) a Subversion
  revision number:
  
      our ($VERSION) = q$REVISION: 42$ =~ /(\d+)/;
  
  The problem here is that the version is tied to a single repository. The code
  can not be moved to another repository (even of the same type) without
  changing its version, possibly in the wrong direction.
  
  This policy accepts v-strings (C<v1.2.3> or just plain C<1.2.3>), since these
  are already flagged by
  L<Perl::Critic::Policy::ValuesAndExpressions::ProhibitVersionStrings|Perl::Critic::Policy::ValuesAndExpressions::ProhibitVersionStrings>.
  
  
  =head1 CONFIGURATION
  
  The proper way to set a module's $VERSION to a C<version> object is to
  C<use version;> on the same line of code that assigns the value of $VERSION.
  That way, L<ExtUtils::MakeMaker|ExtUtils::MakeMaker> and
  L<Module::Build|Module::Build> can extract the version when packaging the
  module for CPAN. By default, this policy declares an error if this is not
  done.
  
  Should you wish to allow version objects without loading the version module on
  the same line, add the following to your configuration file:
  
      [ValuesAndExpressions::RequireConstantVersion]
      allow_version_without_use_on_same_line = 1
  
  
  =head1 CAVEATS
  
  There will be false negatives if the $VERSION appears on the left-hand side of
  a list assignment that assigns to more than one variable, or to C<undef>.
  
  There may be false positives if the $VERSION is assigned the value of a here
  document. This will probably remain the case until
  L<PPI::Token::HereDoc|PPI::Token::HereDoc> acquires the relevant portions of
  the L<PPI::Token::Quote|PPI::Token::Quote> interface.
  
  There will be false positives if $VERSION is assigned the value of a constant
  created by the L<Readonly|Readonly> module or the L<constant|constant> pragma,
  because the necessary infrastructure appears not to exist, and the author of
  the present module lacked the knowledge/expertise/gumption to put it in place.
  
  Currently the idiom
  
      our $VERSION = '1.005_05';
      $VERSION = eval $VERSION;
  
  will produce a violation on the second line of the example.
  
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Tom Wyant.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRECONSTANTVERSION

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireInterpolationOfMetachars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREINTERPOLATIONOFMETACHARS';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireInterpolationOfMetachars;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw< :booleans :characters :severities >;
  use base 'Perl::Critic::Policy';
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<String *may* require interpolation>;
  Readonly::Scalar my $EXPL => [ 51 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'rcs_keywords',
              description     => 'RCS keywords to ignore in potential interpolation.',
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_LOWEST      }
  sub default_themes       { return qw(core pbp cosmetic) }
  
  sub applies_to           {
      return qw< PPI::Token::Quote::Single PPI::Token::Quote::Literal >;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      my $rcs_keywords = $self->{_rcs_keywords};
      my @rcs_keywords = keys %{$rcs_keywords};
  
      if (@rcs_keywords) {
          my $rcs_regexes = [ map { qr/ \$ $_ [^\n\$]* \$ /xms } @rcs_keywords ];
          $self->{_rcs_regexes} = $rcs_regexes;
      }
  
      return $TRUE;
  }
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # The string() method strips off the quotes
      my $string = $elem->string();
      return if not _needs_interpolation($string);
      return if _looks_like_email_address($string);
      return if _looks_like_use_vars($elem);
  
      my $rcs_regexes = $self->{_rcs_regexes};
      return if $rcs_regexes and _contains_rcs_variable($string, $rcs_regexes);
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _needs_interpolation {
      my ($string) = @_;
  
      return
              # Contains a $ or @ not followed by "{}".
              $string =~ m< [\$\@] (?! [{] [}] ) \S+ >xms
              # Contains metachars
              # Note that \1 ... are not documented (that I can find), but are
              # treated the same way as \0 by S_scan_const in toke.c, at least
              # for regular double-quotish strings. Not, obviously, where
              # regexes are involved.
          ||  $string =~ m<
                  (?: \A | [^\\] )
                  (?: \\{2} )*
                  \\ [tnrfbae01234567xcNluLUEQ]
              >xms;
  }
  
  #-----------------------------------------------------------------------------
  
  # Stolen from Email::Address, which is deprecated.  Since we are not modifying
  # the original code at all, we are less stringent in being Critic-compliant.
  
  ## no critic ( RegularExpressions::RequireDotMatchAnything )
  ## no critic ( RegularExpressions::RequireExtendedFormatting )
  ## no critic ( RegularExpressions::RequireLineBoundaryMatching )
  ## no critic ( RegularExpressions::ProhibitEscapedMetacharacters )
  
  my $CTL            = q{\x00-\x1F\x7F};          ## no critic ( ValuesAndExpressions::RequireInterpolationOfMetachars )
  my $special        = q{()<>\\[\\]:;@\\\\,."};   ## no critic ( ValuesAndExpressions::RequireInterpolationOfMetachars )
  
  my $text           = qr/[^\x0A\x0D]/x;
  my $quoted_pair    = qr/\\$text/x;
  my $ctext          = qr/(?>[^()\\]+)/x;
  my $ccontent       = qr/$ctext|$quoted_pair/x;
  my $comment        = qr/\s*\((?:\s*$ccontent)*\s*\)\s*/x;
  my $cfws           = qr/$comment|\s+/xx;
  my $atext          = qq/[^$CTL$special\\s]/;
  my $atom           = qr/$cfws*$atext+$cfws*/x;
  my $dot_atom_text  = qr/$atext+(?:\.$atext+)*/x;
  my $dot_atom       = qr/$cfws*$dot_atom_text$cfws*/x;
  my $qtext          = qr/[^\\"]/x;
  my $qcontent       = qr/$qtext|$quoted_pair/x;
  my $quoted_string  = qr/$cfws*"$qcontent*"$cfws*/x;
  my $local_part     = qr/$dot_atom|$quoted_string/x;
  my $dtext          = qr/[^\[\]\\]/x;
  my $dcontent       = qr/$dtext|$quoted_pair/x;
  my $domain_literal = qr/$cfws*\[(?:\s*$dcontent)*\s*\]$cfws*/x;
  my $domain         = qr/$dot_atom|$domain_literal/x;
  my $addr_spec      = qr/$local_part\@$domain/x;
  
  sub _looks_like_email_address {
      my ($string) = @_;
  
      return if index ($string, q<@>) < 0;
      return if $string =~ m< \W \@ >xms;
      return if $string =~ m< \A \@ \w+ \b >xms;
  
      return $string =~ $addr_spec;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _contains_rcs_variable {
      my ($string, $rcs_regexes) = @_;
  
      foreach my $regex ( @{$rcs_regexes} ) {
          return $TRUE if $string =~ m/$regex/xms;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _looks_like_use_vars {
      my ($elem) = @_;
  
      my $statement = $elem;
      while ( not $statement->isa('PPI::Statement::Include') ) {
          $statement = $statement->parent() or return;
      }
  
      return if $statement->type() ne q<use>;
      return $statement->module() eq q<vars>;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords RCS
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::RequireInterpolationOfMetachars - Warns that you might have used single quotes when you really wanted double-quotes.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This policy warns you if you use single-quotes or C<q//> with a string
  that has unescaped metacharacters that may need interpolation. Its
  hard to know for sure if a string really should be interpolated
  without looking into the symbol table.  This policy just makes an
  educated guess by looking for metacharacters and sigils which usually
  indicate that the string should be interpolated.
  
  
  =head2 Exceptions
  
  =over
  
  =item *
  
  Variable names to C<use vars>:
  
      use vars '$x';          # ok
      use vars ('$y', '$z');  # ok
      use vars qw< $a $b >;   # ok
  
  
  =item *
  
  Things that look like e-mail addresses:
  
      print 'john@foo.com';           # ok
      $address = 'suzy.bar@baz.net';  # ok
  
  =back
  
  
  =head1 CONFIGURATION
  
  The C<rcs_keywords> option allows you to stop this policy from complaining
  about things that look like RCS variables, for example, in deriving values for
  C<$VERSION> variables.
  
  For example, if you've got code like
  
      our ($VERSION) = (q<$Revision$> =~ m/(\d+)/mx);
  
  You can specify
  
      [ValuesAndExpressions::RequireInterpolationOfMetachars]
      rcs_keywords = Revision
  
  in your F<.perlcriticrc> to provide an exemption.
  
  
  =head1 NOTES
  
  Perl's own C<warnings> pragma also warns you about this.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::ProhibitInterpolationOfLiterals|Perl::Critic::Policy::ValuesAndExpressions::ProhibitInterpolationOfLiterals>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREINTERPOLATIONOFMETACHARS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireNumberSeparators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRENUMBERSEPARATORS';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireNumberSeparators;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Long number not separated with underscores};
  Readonly::Scalar my $EXPL => [ 59 ];
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $MINIMUM_INTEGER_WITH_MULTIPLE_DIGITS => 10;
  
  sub supported_parameters {
      return (
          {
              name            => 'min_value',
              description     => 'The minimum absolute value to require separators in.',
              default_string  => '10_000',
              behavior        => 'integer',
              integer_minimum => $MINIMUM_INTEGER_WITH_MULTIPLE_DIGITS,
          },
      );
  }
  
  sub default_severity  { return $SEVERITY_LOW           }
  sub default_themes    { return qw( core pbp cosmetic ) }
  sub applies_to        { return 'PPI::Token::Number'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      my $min = $self->{_min_value};
  
      return if $elem !~ m{ \d{4} }xms;
      return if abs $elem->literal() < $min;
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::RequireNumberSeparators - Write C< 141_234_397.0145 > instead of C< 141234397.0145 >.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Long numbers can be difficult to read.  To improve legibility, Perl
  allows numbers to be split into groups of digits separated by
  underscores.  This policy requires number sequences of more than three
  digits to be separated.
  
      $long_int = 123456789;   #not ok
      $long_int = 123_456_789; #ok
  
      $long_float = 12345678.001;   #not ok
      $long_float = 12_345_678.001; #ok
  
  =head1 CONFIGURATION
  
  The minimum absolute value of numbers that must contain separators can
  be configured via the C<min_value> option.  The default is 10,000;
  thus, all numbers >= 10,000 and <= -10,000 must have separators.  For
  example:
  
      [ValuesAndExpressions::RequireNumberSeparators]
      min_value = 100000    # That's one-hundred-thousand!
  
  =head1 NOTES
  
  As it is currently written, this policy only works properly with
  decimal (base 10) numbers.  And it is obviously biased toward Western
  notation.  I'll try and address those issues in the future.
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIRENUMBERSEPARATORS

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireQuotedHeredocTerminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREQUOTEDHEREDOCTERMINATOR';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $HEREDOC_RX => qr/ \A << \s* ["'] .* ['"] \z /xms;
  Readonly::Scalar my $DESC       => q{Heredoc terminator must be quoted};
  Readonly::Scalar my $EXPL       => [ 64 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                       }
  sub default_severity     { return $SEVERITY_MEDIUM         }
  sub default_themes       { return qw(core pbp maintenance) }
  sub applies_to           { return 'PPI::Token::HereDoc'    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem !~ $HEREDOC_RX ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator - Write C< print <<'THE_END' > or C< print <<"THE_END" >.
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Putting single or double-quotes around your HEREDOC terminator make it
  obvious to the reader whether the content is going to be interpolated
  or not.
  
      print <<END_MESSAGE;    #not ok
      Hello World
      END_MESSAGE
  
      print <<'END_MESSAGE';  #ok
      Hello World
      END_MESSAGE
  
      print <<"END_MESSAGE";  #ok
      $greeting
      END_MESSAGE
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator|Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREQUOTEDHEREDOCTERMINATOR

$fatpacked{"Perl/Critic/Policy/ValuesAndExpressions/RequireUpperCaseHeredocTerminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREUPPERCASEHEREDOCTERMINATOR';
  package Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $HEREDOC_RX => qr{ \A << \s* (["']?) [[:upper:]_] [[:upper:]\d_]* \1 \z }xms;
  Readonly::Scalar my $DESC       => q{Heredoc terminator not alphanumeric and upper-case};
  Readonly::Scalar my $EXPL       => [ 64 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                    }
  sub default_severity     { return $SEVERITY_LOW         }
  sub default_themes       { return qw(core pbp cosmetic) }
  sub applies_to           { return 'PPI::Token::HereDoc' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem !~ $HEREDOC_RX ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator - Write C< <<'THE_END'; > instead of C< <<'theEnd'; >.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  For legibility, HEREDOC terminators should be all UPPER CASE letters
  (and numbers), without any whitespace.  Conway also recommends using a
  standard prefix like "END_" but this policy doesn't enforce that.
  
    print <<'the End';  #not ok
    Hello World
    the End
  
    print <<'THE_END';  #ok
    Hello World
    THE_END
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator|Perl::Critic::Policy::ValuesAndExpressions::RequireQuotedHeredocTerminator>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VALUESANDEXPRESSIONS_REQUIREUPPERCASEHEREDOCTERMINATOR

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitAugmentedAssignmentInDeclaration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITAUGMENTEDASSIGNMENTINDECLARATION';
  package Perl::Critic::Policy::Variables::ProhibitAugmentedAssignmentInDeclaration;
  
  use 5.006001;
  use strict;
  use warnings;
  use List::MoreUtils qw{ firstval };
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Augmented assignment operator '%s' used in declaration};
  Readonly::Scalar my $EXPL => q{Use simple assignment when initializing variables};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw( core bugs )            }
  sub applies_to           { return 'PPI::Statement::Variable' }
  
  #-----------------------------------------------------------------------------
  
  my %augmented_assignments = hashify( qw( **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= ) );
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # The assignment operator associated with a PPI::Statement::Variable
      # element is assumed to be the first immediate child of that element.
      # Other operators in the statement, e.g. the ',' in "my ( $a, $b ) = ();",
      # as assumed to never be immediate children.
  
      my $found = firstval { $_->isa('PPI::Token::Operator') } $elem->children();
      if ( $found ) {
          my $op = $found->content();
          if ( exists $augmented_assignments{ $op } ) {
              return $self->violation( sprintf( $DESC, $op ), $EXPL, $found );
          }
      }
  
      return;
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords O'Regan
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitAugmentedAssignmentInDeclaration - Do not write C< my $foo .= 'bar'; >.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Variable declarations that also do initialization with '=' are common.
  Perl also allows you to use operators like '.=', '+=', etc., but it
  it is more clear to not do so.
  
      my $foo .= 'bar';              # same as my $foo = 'bar';
      our $foo *= 2;                 # same as our $foo = 0;
      my ( $foo, $bar ) += ( 1, 2 ); # same as my ( $foo, $bar ) = ( undef, 2 );
      local $Carp::CarpLevel += 1;   # same as local $Carp::CarpLevel = 1;
      state $foo += 2;               # adds 2 every time it's encountered
  
  Such constructs are usually the result of botched cut-and-paste, and often are
  bugs. Some produce warnings.
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Mike O'Regan
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2011 Mike O'Regan.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITAUGMENTEDASSIGNMENTINDECLARATION

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitConditionalDeclarations.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITCONDITIONALDECLARATIONS';
  package Perl::Critic::Policy::Variables::ProhibitConditionalDeclarations;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Variable declared in conditional statement};
  Readonly::Scalar my $EXPL => q{Declare variables outside of the condition};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGHEST          }
  sub default_themes       { return qw( core bugs )            }
  sub applies_to           { return 'PPI::Statement::Variable' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if $elem->type() eq 'local';
  
      if ( $elem->find(\&_is_conditional) ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  my @conditionals = qw( if while foreach for until unless );
  my %conditionals = hashify( @conditionals );
  
  sub _is_conditional {
      my (undef, $elem) = @_;
  
      return if !$conditionals{$elem};
      return if ! $elem->isa('PPI::Token::Word');
      return if is_hash_key($elem);
      return if is_method_call($elem);
  
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitConditionalDeclarations - Do not write C< my $foo = $bar if $baz; >.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Declaring a variable with a postfix conditional is really confusing.
  If the conditional is false, its not clear if the variable will be
  false, undefined, undeclared, or what.  It's much more straightforward
  to make variable declarations separately.
  
      my $foo = $baz if $bar;          #not ok
      my $foo = $baz unless $bar;      #not ok
      our $foo = $baz for @list;       #not ok
      local $foo = $baz foreach @list; #not ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey R. Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITCONDITIONALDECLARATIONS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitEvilVariables.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITEVILVARIABLES';
  package Perl::Critic::Policy::Variables::ProhibitEvilVariables;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue
      qw{ throw_policy_value };
  use Perl::Critic::Utils qw{
      :characters :severities :data_conversion
  };
  use Perl::Critic::Utils::DataConversion qw{ dor };
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL => q{Find an alternative variable};
  
  Readonly::Hash my %SUBSCRIPTED_TYPE => hashify(qw{@ %});
  
  Readonly::Scalar my $VARIABLE_NAME_REGEX => qr< [\$\@%] \S+ >xms;
  Readonly::Scalar my $REGULAR_EXPRESSION_REGEX =>
      qr< [/] ( [^/]+ ) [/] >xms;
  Readonly::Array my @DESCRIPTION_REGEXES =>
      qr< [{] ( [^}]+ ) [}] >xms,
      qr{  <  ( [^>]+ )  >  }xms,
      qr{ [[] ( [^]]+ ) []] }xms,
      qr{ [(] ( [^)]+ ) [)] }xms,
  ;
  Readonly::Scalar my $DESCRIPTION_REGEX =>
      qr< @{[join '|', @DESCRIPTION_REGEXES]} >xms;
  
  # It's kind of unfortunate that I had to put capturing parentheses in the
  # component regexes above, because they're not visible here and so make
  # figuring out the positions of captures hard.  Too bad we can't make the
  # minimum perl version 5.10. :]
  Readonly::Scalar my $VARIABLES_REGEX =>
      qr<
          \A
          \s*
          (?:
                  ( $VARIABLE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          (?: \s* $DESCRIPTION_REGEX )?
          \s*
      >xms;
  
  Readonly::Scalar my $VARIABLES_FILE_LINE_REGEX =>
      qr<
          \A
          \s*
          (?:
                  ( $VARIABLE_NAME_REGEX )
              |   $REGULAR_EXPRESSION_REGEX
          )
          \s*
          ( \S (?: .* \S )? )?
          \s*
          \z
      >xms;
  
  # Indexes in the arrays of regexes for the "variables" option.
  Readonly::Scalar my $INDEX_REGEX        => 0;
  Readonly::Scalar my $INDEX_DESCRIPTION  => 1;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'variables',
              description     => 'The names of or patterns for variables to forbid.',
              default_string  => $EMPTY,
              parser          => \&_parse_variables,
          },
          {
              name            => 'variables_file',
              description     => 'A file containing names of or patterns for variables to forbid.',
              default_string  => $EMPTY,
              parser          => \&_parse_variables_file,
          },
      );
  }
  
  sub default_severity  { return $SEVERITY_HIGHEST         }
  sub default_themes    { return qw( core bugs )           }
  sub applies_to        { return qw{PPI::Token::Symbol}    }
  
  #-----------------------------------------------------------------------------
  
  sub _parse_variables {
      my ($self, $parameter, $config_string) = @_;
  
      return if not $config_string;
      return if $config_string =~ m< \A \s* \z >xms;
  
      my $variable_specifications = $config_string;
  
      while ( my ($variable, $regex_string, @descrs) =
          $variable_specifications =~ m< $VARIABLES_REGEX >xms) {
  
          substr $variable_specifications, 0, $LAST_MATCH_END[0], $EMPTY;
          my $description = dor(@descrs);
  
          $self->_handle_variable_specification(
              variable                => $variable,
              regex_string            => $regex_string,
              description             => $description,
              option_name             => 'variables',
              option_value            => $config_string,
          );
      }
  
      if ($variable_specifications) {
          throw_policy_value
              policy         => $self->get_short_name(),
              option_name    => 'variables',
              option_value   => $config_string,
              message_suffix =>
                  qq{contains unparseable data: "$variable_specifications"};
      }
  
      return;
  }
  
  sub _parse_variables_file {
      my ($self, $parameter, $config_string) = @_;
  
      return if not $config_string;
      return if $config_string =~ m< \A \s* \z >xms;
  
      open my $handle, '<', $config_string
          or throw_policy_value
              policy         => $self->get_short_name(),
              option_name    => 'variables_file',
              option_value   => $config_string,
              message_suffix =>
                  qq<refers to a file that could not be opened: $OS_ERROR>;
      while ( my $line = <$handle> ) {
          $self->_handle_variable_specification_on_line($line, $config_string);
      }
      close $handle or warn qq<Could not close "$config_string": $OS_ERROR\n>;
  
      return;
  }
  
  sub _handle_variable_specification_on_line {
      my ($self, $line, $config_string) = @_;
  
      $line =~ s< [#] .* \z ><>xms;
      $line =~ s< \s+ \z ><>xms;
      $line =~ s< \A \s+ ><>xms;
  
      return if not $line;
  
      if ( my ($variable, $regex_string, $description) =
          $line =~ m< $VARIABLES_FILE_LINE_REGEX >xms) {
  
          $self->_handle_variable_specification(
              variable                => $variable,
              regex_string            => $regex_string,
              description             => $description,
              option_name             => 'variables_file',
              option_value            => $config_string,
          );
      }
      else {
          throw_policy_value
              policy         => $self->get_short_name(),
              option_name    => 'variables_file',
              option_value   => $config_string,
              message_suffix =>
                  qq{contains unparseable data: "$line"};
      }
  
      return;
  }
  
  sub _handle_variable_specification {
      my ($self, %arguments) = @_;
  
      my $description = $arguments{description} || $EMPTY;
  
      if ( my $regex_string = $arguments{regex_string} ) {
          # These are variable name patterns (e.g. /acme/)
          my $actual_regex;
  
          eval { $actual_regex = qr/$regex_string/sm; ## no critic (ExtendedFormatting)
              1 }
              or throw_policy_value
                  policy         => $self->get_short_name(),
                  option_name    => $arguments{option_name},
                  option_value   => $arguments{option_value},
                  message_suffix =>
                      qq{contains an invalid regular expression: "$regex_string"};
  
          # Can't use a hash due to stringification, so this is an AoA.
          push
              @{ $self->{_evil_variables_regexes} ||= [] },
              [ $actual_regex, $description ];
      }
      else {
          # These are literal variable names (e.g. $[)
          $self->{_evil_variables} ||= {};
          my $name = $arguments{variable};
          $self->{_evil_variables}{$name} = $description;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      # Disable if no variables are specified; there's no point in running if
      # there aren't any.
      return
              exists $self->{_evil_variables}
          ||  exists $self->{_evil_variables_regexes};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if not $elem;
  
      my @names = $self->_compute_symbol_names( $elem )
          or return;
  
      my $evil_variables = $self->{_evil_variables};
      my $evil_variables_regexes = $self->{_evil_variables_regexes};
  
      foreach my $variable (@names) {
          exists $evil_variables->{$variable}
              and return $self->_make_violation(
                  $variable,
                  $evil_variables->{$variable},
                  $elem,
              );
      }
  
      foreach my $variable (@names) {
          foreach my $regex ( @{$evil_variables_regexes} ) {
              $variable =~ $regex->[$INDEX_REGEX]
                  and return $self->_make_violation(
                      $variable,
                      $regex->[$INDEX_DESCRIPTION],
                      $elem,
                  );
          }
      }
  
      return;    # ok!
  }
  
  #-----------------------------------------------------------------------------
  
  # We are unconditionally interested in the names of the symbol itself. If the
  # symbol is subscripted, we are interested in the subscripted form as well.
  
  sub _compute_symbol_names {
      my ($self, $elem) = @_;
  
      my @names;
  
      my $name = $elem->symbol();
      push @names, $name;
  
      if ($SUBSCRIPTED_TYPE{$elem->symbol_type()}) {
          $name = $elem->content();
          my $next = $elem->snext_sibling();
          my @subscr;
          while ($next and $next->isa('PPI::Structure::Subscript')) {
              push @subscr, $next->content();
              $next = $next->snext_sibling();
          }
          if (@subscr) {
              push @names, join $EMPTY, $name, @subscr;
          }
      }
  
      return @names;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _make_violation {
      my ($self, $variable, $description, $elem) = @_;
      return $self->violation(
          $description || qq<Prohibited variable "$variable" used>,
          $EXPL,
          $elem,
      );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords subscripted
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitEvilVariables - Ban variables that aren't blessed by your shop.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Use this policy if you wish to prohibit the use of specific variables. These
  may be global variables warned against in C<perlvar>, or just variables whose
  names you do not like.
  
  
  =head1 CONFIGURATION
  
  The set of prohibited variables is configurable via the C<variables> and
  C<variables_file> options.
  
  The value of C<variables> should be a string of space-delimited, fully
  qualified variable names and/or regular expressions.  An example of
  prohibiting two specific variables in a F<.perlcriticrc> file:
  
      [Variables::ProhibitEvilVariables]
      variables = $[ $^S $SIG{__DIE__}
  
  If you prohibit an array or hash (e.g. C<@INC>), use of elements of the array
  or hash will be prohibited as well. If you specify a subscripted variable (e.g.
  C<$SIG{__DIE__}>), only the literal subscript specified will be detected. The
  above <.perlcritic> file, for example, will cause C<perlcritic (1)> to detect
  C<$SIG{__DIE__} = \&foo>, but not
  
      my $foo = '__DIE__';
      $SIG{$foo} = \&foo;
  
  Regular expressions are identified by values beginning and ending with
  slashes.  Any variable with a name that matches C<m/pattern/sm> will be
  forbidden.  For example:
  
      [Variables::ProhibitEvilVariables]
      variables = /acme/
  
  would cause all variables that match C<m/acme/> to be forbidden.  If
  you want a case-blind check, you can use (?i: ... ).  For example
  
      [Variables::ProhibitEvilVariables]
      variables = /(?i:acme)/
  
  forbids variables that match C<m/acme/smi>.
  
  In addition, you can override the default message ("Prohibited variable
  "I<variable>" used") with your own, in order to give suggestions for
  alternative action.  To do so, put your message in curly braces after
  the variable name or regular expression.  Like this:
  
      [Variables::ProhibitEvilVariables]
      variables = $[ {Found use of $[. Program to base index 0 instead}
  
  If your message contains curly braces, you can enclose it in parentheses,
  angle brackets, or square brackets instead.
  
  Similarly, the C<variables_file> option gives the name of a file
  containing specifications for prohibited variables.  Only one variable
  specification is allowed per line and comments start with an octothorp
  and run to end of line; no curly braces are necessary for delimiting
  messages:
  
      $[      # Prohibit the "$[" variable and use the default message.
  
      # Prohibit the "$^S" variable and give a replacement message.
      $^S     Having to think about $^S in exception handlers is just wrong
  
      # Use a regular expression.
      /acme/  No coyotes allowed.
  
  By default, there are no prohibited variables, although I can think of a
  few that should be.  See C<perldoc perlvar> for a few suggestions.
  
  
  =head1 RESTRICTIONS
  
  Variables of the form C<${^foo}> are not recognized by PPI as of version
  1.206. When PPI recognizes these, this policy will Just Work for them too.
  
  Only direct references to prohibited variables and literal subscripts will be
  recognized. For example, if you prohibit $[, the first line in
  
   my $foo = \$[;
   $$foo = 1;
  
  will be flagged as a violation, but not the second, even though the second, in
  fact, assigns to $[. Similarly, if you prohibit $SIG{__DIE__}, this policy
  will not recognize
  
   my $foo = '__DIE__';
   $SIG{$foo} = sub {warn 'I cannot die!'};
  
  as an assignment to $SIG{__DIE__}.
  
  
  =head1 NOTES
  
  This policy leans heavily on
  L<Perl::Critic::Policy::Modules::ProhibitEvilModules|Perl::Critic::Policy::Modules::ProhibitEvilModules>
  by Jeffrey Ryan Thalhammer.
  
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Thomas R. Wyant, III
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITEVILVARIABLES

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitLocalVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITLOCALVARS';
  package Perl::Critic::Policy::Variables::ProhibitLocalVars;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $PACKAGE_RX => qr/::/xms;
  Readonly::Scalar my $DESC => q{Variable declared as "local"};
  Readonly::Scalar my $EXPL => [ 77, 78, 79 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_LOW              }
  sub default_themes       { return qw(core pbp maintenance)   }
  sub applies_to           { return 'PPI::Statement::Variable' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem->type() eq 'local' && !_all_global_vars($elem) ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  #-----------------------------------------------------------------------------
  
  sub _all_global_vars {
  
      my $elem = shift;
      for my $variable_name ( $elem->variables() ) {
          next if $variable_name =~ $PACKAGE_RX;
          # special exception for Test::More
          next if $variable_name eq '$TODO'; ## no critic (InterpolationOfMetachars)
          return if ! is_perl_global( $variable_name );
      }
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitLocalVars - Use C<my> instead of C<local>, except when you have to.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Since Perl 5, there are very few reasons to declare C<local>
  variables.  The most common exceptions are Perl's magical global
  variables.  If you do need to modify one of those global variables,
  you should localize it first.  You should also use the
  L<English|English> module to give those variables more meaningful
  names.
  
      local $foo;   #not ok
      my $foo;      #ok
  
      use English qw(-no_match_vars);
      local $INPUT_RECORD_SEPARATOR    #ok
      local $RS                        #ok
      local $/;                        #not ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 NOTES
  
  If an external module uses package variables as its interface, then
  using C<local> is actually a pretty sensible thing to do.  So
  Perl::Critic will not complain if you C<local>-ize variables with a
  fully qualified name such as C<$Some::Package::foo>.  However, if
  you're in a position to dictate the module's interface, I strongly
  suggest using accessor methods instead.
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Variables::ProhibitPunctuationVars|Perl::Critic::Policy::Variables::ProhibitPunctuationVars>
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITLOCALVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitMatchVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITMATCHVARS';
  package Perl::Critic::Policy::Variables::ProhibitMatchVars;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Match variable used};
  Readonly::Scalar my $EXPL => [ 82 ];
  
  Readonly::Array my @FORBIDDEN => qw( $` $& $' $MATCH $PREMATCH $POSTMATCH );
  Readonly::Hash my %FORBIDDEN => hashify( @FORBIDDEN );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw( core performance pbp ) }
  sub applies_to           { return qw( PPI::Token::Symbol
                                        PPI::Statement::Include ) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if (_is_use_english($elem) || _is_forbidden_var($elem)) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;  #ok!
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_use_english {
      my $elem = shift;
      $elem->isa('PPI::Statement::Include') || return;
      $elem->type() eq 'use' || return;
      $elem->module() eq 'English' || return;
  
      # Bare, lacking -no_match_vars.  Now handled by
      # Modules::RequireNoMatchVarsWithUseEnglish.
      return 0 if ($elem =~ m/\A use \s+ English \s* ;\z/xms);
  
      return 1 if ($elem =~ m/\$(?:PRE|POST|)MATCH/xms);
      return;  # either "-no_match_vars" or a specific list
  }
  
  sub _is_forbidden_var {
      my $elem = shift;
      $elem->isa('PPI::Token::Symbol') || return;
      return exists $FORBIDDEN{$elem};
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitMatchVars - Avoid C<$`>, C<$&>, C<$'> and their English equivalents.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Using the "match variables" C<$`>, C<$&>, and/or C<$'> can
  significantly degrade the performance of a program.  This policy
  forbids using them or their English equivalents.  See B<perldoc
  English> or PBP page 82 for more information.
  
  It used to forbid plain C<use English;> because it ends up causing the
  performance side-effects of the match variables.  However, the message
  emitted for that situation was not at all clear and there is now
  L<Perl::Critic::Policy::Modules::RequireNoMatchVarsWithUseEnglish|Perl::Critic::Policy::Modules::RequireNoMatchVarsWithUseEnglish>,
  which addresses this situation directly.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITMATCHVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitPackageVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITPACKAGEVARS';
  package Perl::Critic::Policy::Variables::ProhibitPackageVars;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use List::MoreUtils qw(all);
  
  use Perl::Critic::Utils qw{
      :booleans :characters :severities :data_conversion
  };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Package variable declared or used};
  Readonly::Scalar my $EXPL => [ 73, 75 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'packages',
              description     => 'The base set of packages to allow variables for.',
              default_string  => 'Data::Dumper File::Find FindBin Log::Log4perl',
              behavior        => 'string list',
          },
          {
              name            => 'add_packages',
              description     => 'The set of packages to allow variables for, in addition to those given in "packages".',
              default_string  => $EMPTY,
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity { return $SEVERITY_MEDIUM            }
  sub default_themes   { return qw(core pbp maintenance)    }
  sub applies_to       { return qw(PPI::Token::Symbol
                                   PPI::Statement::Variable
                                   PPI::Statement::Include) }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_if_enabled {
      my ($self, $config) = @_;
  
      $self->{_all_packages} = {
          hashify keys %{ $self->{_packages} }, keys %{ $self->{_add_packages} }
      };
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $self->_is_package_var($elem) ||
           _is_our_var($elem)            ||
           _is_vars_pragma($elem) )
         {
  
          return $self->violation( $DESC, $EXPL, $elem );
      }
  
      return;  # ok
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_package_var {
      my $self = shift;
      my $elem = shift;
      return if !$elem->isa('PPI::Token::Symbol');
      my ($package, $name) = $elem =~ m{ \A [@\$%] (.*) :: (\w+) \z }xms;
      return if not defined $package;
      return if _all_upcase( $name );
      return if $self->{_all_packages}->{$package};
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_our_var {
      my $elem = shift;
      return if not $elem->isa('PPI::Statement::Variable');
      return if $elem->type() ne 'our';
      return if _all_upcase( $elem->variables() );
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_vars_pragma {
      my $elem = shift;
      return if !$elem->isa('PPI::Statement::Include');
      return if $elem->pragma() ne 'vars';
  
      # Older Perls don't support the C<our> keyword, so we try to let
      # people use the C<vars> pragma instead, but only if all the
      # variable names are uppercase.  Since there are lots of ways to
      # pass arguments to pragmas (e.g. "$foo" or qw($foo) ) we just use
      # a regex to match things that look like variables names.
  
      my @varnames = $elem =~ m{ [@\$%&] (\w+) }gxms;
  
      return if !@varnames;   # no valid variables specified
      return if _all_upcase( @varnames );
      return 1;
  }
  
  sub _all_upcase {  ##no critic(ArgUnpacking)
      return all { $_ eq uc $_ } @_; ## no critic ( BuiltinFunctions::ProhibitUselessTopic )
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitPackageVars - Eliminate globals declared with C<our> or C<use vars>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Conway suggests avoiding package variables completely, because they
  expose your internals to other packages.  Never use a package variable
  when a lexical variable will suffice.  If your package needs to keep
  some dynamic state, consider using an object or closures to keep the
  state private.
  
  This policy assumes that you're using C<strict vars> so that naked
  variable declarations are not package variables by default.  Thus, it
  complains you declare a variable with C<our> or C<use vars>, or if you
  make reference to variable with a fully-qualified package name.
  
      $Some::Package::foo = 1;    # not ok
      our $foo            = 1;    # not ok
      use vars '$foo';            # not ok
      $foo = 1;                   # not allowed by 'strict'
      local $foo = 1;             # bad taste, but technically ok.
      use vars '$FOO';            # ok, because it's ALL CAPS
      my $foo = 1;                # ok
  
  In practice though, its not really practical to prohibit all package
  variables.  Common variables like C<$VERSION> and C<@EXPORT> need to
  be global, as do any variables that you want to Export.  To work
  around this, the Policy overlooks any variables that are in ALL_CAPS.
  This forces you to put all your exported variables in ALL_CAPS too,
  which seems to be the usual practice anyway.
  
  
  =head1 CONFIGURATION
  
  There is room for exceptions.  Some modules, like the core File::Find
  module, use package variables as their only interface, and others like
  Data::Dumper use package variables as their most common interface.
  These module can be specified from your F<.perlcriticrc> file, and the
  policy will ignore them.
  
      [Variables::ProhibitPackageVars]
      packages = Data::Dumper File::Find FindBin Log::Log4perl
  
  This is the default setting.  Using C<packages =>  will override these
  defaults.
  
  You can also add packages to the defaults like so:
  
      [Variables::ProhibitPackageVars]
      add_packages = My::Package
  
  You can add package C<main> to the list of packages, but that will
  only OK variables explicitly in the C<main> package.
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Variables::ProhibitPunctuationVars|Perl::Critic::Policy::Variables::ProhibitPunctuationVars>
  
  L<Perl::Critic::Policy::Variables::ProhibitLocalVars|Perl::Critic::Policy::Variables::ProhibitLocalVars>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITPACKAGEVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitPerl4PackageNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITPERL4PACKAGENAMES';
  package Perl::Critic::Policy::Variables::ProhibitPerl4PackageNames;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :severities :classification };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL =>
      q{Use double colon (::) to separate package name components instead of single quotes (')};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                                        }
  sub default_severity     { return $SEVERITY_LOW                             }
  sub default_themes       { return qw(core maintenance certrec )                      }
  sub applies_to           { return qw( PPI::Token::Word PPI::Token::Symbol ) }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      my $content = $elem->content();
  
      if ( (index $content, $QUOTE) < 0 ) {
          return;
      }
  
      if ( $content =~ m< \A [\$@%&*] ' \z >xms ) {
          # We've found $POSTMATCH.
          return;
      }
  
      if ( $elem->isa('PPI::Token::Word') && is_hash_key($elem) ) {
          return;
      }
  
      return
          $self->violation(
              qq{"$content" uses the obsolete single quote package separator.},
              $EXPL,
              $elem
          );
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords perlmod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitPerl4PackageNames - Use double colon (::) to separate package name components instead of single quotes (').
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl 5 kept single quotes (C<'>) as package component separators in
  order to remain backward compatible with prior C<perl>s, but advocated
  using double colon (C<::>) instead.  In the more than a decade since
  Perl 5, double colons have been overwhelmingly adopted and most people
  are not even aware that the single quote can be used in this manner.
  So, unless you're trying to obfuscate your code, don't use them.
  
      package Foo::Bar::Baz;    #ok
      package Foo'Bar'Baz;      #not ok
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<perlmod|perlmod>
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2014 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITPERL4PACKAGENAMES

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitPunctuationVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITPUNCTUATIONVARS';
  package Perl::Critic::Policy::Variables::ProhibitPunctuationVars;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  use English qw< -no_match_vars >;
  
  use PPI::Token::Magic;
  
  use Perl::Critic::Utils qw<
      :characters :severities :data_conversion :booleans
  >;
  
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q<Magic punctuation variable %s used>;
  Readonly::Scalar my $EXPL => [79];
  
  #-----------------------------------------------------------------------------
  
  # There is no English.pm equivalent for $].
  sub supported_parameters {
      return (
          {
              name           => 'allow',
              description    => 'The additional variables to allow.',
              default_string => $EMPTY,
              behavior       => 'string list',
              list_always_present_values =>
                  [ qw< $_ @_ $1 $2 $3 $4 $5 $6 $7 $8 $9 _ $] > ],
          },
          {
              name               => 'string_mode',
              description        =>
                  'Controls checking interpolated strings for punctuation variables.',
              default_string     => 'thorough',
              behavior           => 'enumeration',
              enumeration_values => [ qw< simple disable thorough > ],
              enumeration_allow_multiple_values => 0,
          },
      );
  }
  
  sub default_severity { return $SEVERITY_LOW }
  sub default_themes   { return qw< core pbp cosmetic > }
  
  sub applies_to {
      return qw<
          PPI::Token::Magic
          PPI::Token::Quote::Double
          PPI::Token::Quote::Interpolate
          PPI::Token::QuoteLike::Command
          PPI::Token::QuoteLike::Backtick
          PPI::Token::QuoteLike::Regexp
          PPI::Token::QuoteLike::Readline
          PPI::Token::HereDoc
      >;
  }
  
  #-----------------------------------------------------------------------------
  
  
  # This list matches the initialization of %PPI::Token::Magic::magic.
  ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
  Readonly::Array my @MAGIC_VARIABLES =>
      qw{
          $1 $2 $3 $4 $5 $6 $7 $8 $9
          $_ $& $` $' $+ @+ %+ $* $. $/ $|
          $\\ $" $; $% $= $- @- %- $)
          $~ $^ $: $? $! %! $@ $$ $< $>
          $( $0 $[ $] @_ @*
  
          $^L $^A $^E $^C $^D $^F $^H
          $^I $^M $^N $^O $^P $^R $^S
          $^T $^V $^W $^X %^H
  
          $::|
      },
      q<$}>,
      q<$,>,
      q<$#>,
      q<$#+>,
      q<$#->;
  ## use critic
  
  # The main regular expression for detecting magic variables.
  Readonly::Scalar my $MAGIC_REGEX => _create_magic_detector();
  
  # The magic vars in this array will be ignored in interpolated strings
  # in simple mode. See CONFIGURATION in the pod.
  Readonly::Array my @IGNORE_FOR_INTERPOLATION =>
      ( q{$'}, q{$$}, q{$#}, q{$:}, );    ## no critic ( RequireInterpolationOfMetachars, ProhibitQuotedWordLists )
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem->isa('PPI::Token::Magic') ) {
          return _violates_magic( $self, $elem );
      }
      elsif ( $elem->isa('PPI::Token::HereDoc') ) {
          return _violates_heredoc( $self, $elem );
      }
  
      #the remaining applies_to() classes are all interpolated strings
      return _violates_string( $self, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  # Helper functions for the three types of violations: code, quotes, heredoc
  
  sub _violates_magic {
      my ( $self, $elem, undef ) = @_;
  
      if ( !exists $self->{_allow}->{$elem} ) {
          return $self->_make_violation( $DESC, $EXPL, $elem );
      }
  
      return;    # no violation
  }
  
  sub _violates_string {
      my ( $self, $elem, undef ) = @_;
  
      # RT #55604: Variables::ProhibitPunctuationVars gives false-positive on
      # qr// regexp's ending in '$'
      # We want to analyze the content of the string in the dictionary sense of
      # the word 'content'. We can not simply use the PPI content() method to
      # get this, because content() includes the delimiters.
      my $string;
      if ( $elem->can( 'string' ) ) {
          # If we have a string() method (currently only the PPI::Token::Quote
          # classes) use it to extract the content of the string.
          $string = $elem->string();
      } else {
          # Lacking string(), we fake it under the assumption that the content
          # of our element represents one of the 'normal' Perl strings, with a
          # single-character delimiter, possibly preceded by an operator like
          # 'qx' or 'qr'. If there is a leading operator, spaces may appear
          # after it.
          $string = $elem->content();
          $string =~ s/ \A \w* \s* . //smx;
          chop $string;
      }
  
      my %matches = _strings_helper( $self, $string );
      if (%matches) {
          my $DESC = qq<$DESC in interpolated string>;
          return $self->_make_violation( $DESC, $EXPL, $elem, \%matches );
      }
  
      return;    # no violation
  }
  
  sub _violates_heredoc {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem->{_mode} eq 'interpolate' or $elem->{_mode} eq 'command' ) {
          my $heredoc_string = join "\n", $elem->heredoc();
          my %matches = _strings_helper( $self, $heredoc_string );
          if (%matches) {
              my $DESC = qq<$DESC in interpolated here-document>;
              return $self->_make_violation( $DESC, $EXPL, $elem, \%matches );
          }
      }
  
      return;    # no violation
  }
  
  #-----------------------------------------------------------------------------
  
  # Helper functions specific to interpolated strings
  
  sub _strings_helper {
      my ( $self, $target_string, undef ) = @_;
  
      return if ( $self->{_string_mode} eq 'disable' );
      return _strings_thorough( $self, $target_string )
          if $self->{_string_mode} eq 'thorough';
  
      # we are in string_mode = simple
  
      my @raw_matches = map { _unbracket_variable_name( $_ ) }
          $target_string =~ m/$MAGIC_REGEX/goxms;
      return if not @raw_matches;
  
      my %matches = hashify(@raw_matches);
  
      delete @matches{ keys %{ $self->{_allow} } };
      delete @matches{@IGNORE_FOR_INTERPOLATION};
  
      return %matches;
  }
  
  sub _strings_thorough {
      my ( $self, $target_string, undef ) = @_;
      my %matches;
  
      MATCH:
      while ( my ($match) = $target_string =~ m/$MAGIC_REGEX/gcxms ) {
          my $nextchar = substr $target_string, $LAST_MATCH_END[0], 1;
          my $vname = _unbracket_variable_name( $match );
          my $c = $vname . $nextchar;
  
          # These tests closely parallel those in PPI::Token::Magic,
          # from which the regular expressions were taken.
          # A degree of simplicity is sacrificed to maintain the parallel.
          # $c is so named by analogy to that module.
  
          # possibly *not* a magic variable
          if ($c =~ m/ ^  \$  .*  [  \w  :  \$  {  ]  $ /xms) {
              ## no critic (RequireInterpolationOfMetachars)
  
              if (
                      $c =~ m/ ^(\$(?:\_[\w:]|::)) /xms
                  or  $c =~ m/ ^\$\'[\w] /xms )
              {
                  next MATCH
                      if $c !~ m/ ^\$\'\d$ /xms;
                      # It not $' followed by a digit.
                      # So it's magic var with something immediately after.
              }
  
              next MATCH
                  if $c =~ m/ ^\$\$\w /xms; # It's a scalar dereference
              next MATCH
                  if $c eq '$#$'
                      or $c eq '$#{';       # It's an index dereferencing cast
              next MATCH
                  if $c =~ m/ ^(\$\#)\w /xms
              ;    # It's an array index thingy, e.g. $#array_name
  
              # PPI's checks for long escaped vars like $^WIDE_SYSTEM_CALLS
              # appear to be erroneous, and are omitted here.
              # if ( $c =~ m/^\$\^\w{2}$/xms ) {
              # }
  
              next MATCH if $c =~ m/ ^ \$ \# [{] /xms;    # It's a $#{...} cast
          }
  
          # The additional checking that PPI::Token::Magic does at this point
          # is not necessary here, in an interpolated string context.
  
          $matches{$vname} = 1;
      }
  
      delete @matches{ keys %{ $self->{_allow} } };
  
      return %matches;
  }
  
  # RT #72910: A magic variable may appear in bracketed form; e.g. "$$" as
  # "${$}".  Generate the bracketed form from the unbracketed form, and
  # return both.
  sub _bracketed_form_of_variable_name {
      my ( $name ) = @_;
      length $name > 1
          or return ( $name );
      my $brktd = $name;
      substr $brktd, 1, 0, '{';
      $brktd .= '}';
      return( $name, $brktd );
  }
  
  # RT #72910: Since we loaded both bracketed and unbracketed forms of the
  # punctuation variables into our detecting regex, we need to detect and
  # strip the brackets if they are present to recover the canonical name.
  sub _unbracket_variable_name {
      my ( $name ) = @_;
      $name =~ m/ \A ( . ) [{] ( .+ ) [}] \z /smx
          and return "$1$2";
      return $name;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _create_magic_detector {
      my ($config) = @_;
  
      # Set up the regexp alternation for matching magic variables.
      # We can't process $config->{_allow} here because of a quirk in the
      # way Perl::Critic handles testing.
      #
      # The sort is needed so that, e.g., $^ doesn't mask out $^M
      my $magic_alternation =
              '(?:'
          .   (
              join
                  q<|>,
                  map          { quotemeta }
                  reverse sort { length $a <=> length $b }
                  map          { _bracketed_form_of_variable_name( $_ ) }
                  grep         { q<%> ne substr $_, 0, 1 }
                  @MAGIC_VARIABLES
          )
          .   ')';
  
      return qr<
          (?: \A | [^\\] )       # beginning-of-string or any non-backslash
          (?: \\{2} )*           # zero or more double-backslashes
          ( $magic_alternation ) # any magic punctuation variable
      >xsm;
  }
  
  sub _make_violation {
      my ( $self, $desc, $expl, $elem, $vars ) = @_;
  
      my $vname = 'HASH' eq ref $vars ?
          join ', ', sort keys %{ $vars } :
          $elem->content();
      return $self->violation( sprintf( $desc, $vname ), $expl, $elem );
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitPunctuationVars - Write C<$EVAL_ERROR> instead of C<$@>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl's vocabulary of punctuation variables such as C<$!>, C<$.>, and
  C<$^> are perhaps the leading cause of its reputation as inscrutable
  line noise.  The simple alternative is to use the L<English|English>
  module to give them clear names.
  
    $| = undef;                      #not ok
  
    use English qw(-no_match_vars);
    local $OUTPUT_AUTOFLUSH = undef; #ok
  
  =head1 CONFIGURATION
  
  The scratch variables C<$_> and C<@_> are very common and are pretty
  well understood, so they are exempt from this policy.  The same goes
  for the less-frequently-used default filehandle C<_> used by stat().
  All the regexp capture variables (C<$1>, C<$2>, ...) are exempt too.
  C<$]> is exempt because there is no L<English|English> equivalent and
  L<Module::CoreList|Module::CoreList> is based upon it.
  
  You can add more exceptions to your configuration.  In your
  perlcriticrc file, add a block like this:
  
    [Variables::ProhibitPunctuationVars]
    allow = $@ $!
  
  The C<allow> property  should  be  a  whitespace-delimited  list  of
  punctuation variables.
  
  Other configuration options  control  the  parsing  of  interpolated
  strings in the search for forbidden variables. They have  no  effect
  on detecting punctuation variables outside of interpolated  strings.
  
    [Variables::ProhibitPunctuationVars]
    string_mode = thorough
  
  The option C<string_mode>  controls  whether  and  how  interpolated
  strings are searched for punctuation variables. Setting
  C<string_mode = thorough>, the default,  checks  for  special  cases
  that may look like punctuation variables  but  aren't,  for  example
  C<$#foo>, an array index count; C<$$bar>, a scalar  dereference;  or
  C<$::baz>, a global symbol.
  
  Setting C<string_mode = disable> causes all interpolated strings  to
  be ignored entirely.
  
  Setting C<string_mode = simple> uses a simple regular expression  to
  find matches. In this mode, the magic variables C<$$>, C<$'>,  C<$#>
  and C<$:> are ignored within interpolated strings due  to  the  high
  risk of false positives. Simple mode is  retained  from  an  earlier
  draft of the interpolated- strings code. Its use is only recommended
  as a workaround if bugs appear in thorough mode.
  
  The  C<string_mode>  option  will  go  away  when  the  parsing   of
  interpolated strings is implemented in PPI. See  L</CAVEATS>  below.
  
  
  =head1 BUGS
  
  Punctuation variables that confuse PPI's document parsing may not be
  detected  correctly  or  at  all,  and  may  prevent  detection   of
  subsequent ones. In particular, C<$"> is known to cause difficulties
  in interpolated strings.
  
  
  =head1 CAVEATS
  
  ProhibitPunctuationVars  relies   exclusively   on   PPI   to   find
  punctuation variables in code, but does all the parsing  itself  for
  interpolated strings. When, at some  point,  this  functionality  is
  transferred to PPI, ProhibitPunctuationVars  will  cease  doing  the
  interpolating  and  the  C<string_mode>   option   will   go   away.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITPUNCTUATIONVARS

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitReusedNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITREUSEDNAMES';
  package Perl::Critic::Policy::Variables::ProhibitReusedNames;
  
  use 5.006001;
  use strict;
  use warnings;
  use List::MoreUtils qw(part);
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification :data_conversion };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Reused variable name in lexical scope: };
  Readonly::Scalar my $EXPL => q{Invent unique variable names};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'allow',
              description     => 'The variables to not consider as duplicates.',
              default_string  => '$self $class',    ## no critic (RequireInterpolationOfMetachars)
              behavior        => 'string list',
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw( core bugs )            }
  sub applies_to           { return 'PPI::Statement::Variable' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      return if 'local' eq $elem->type;
  
      my $allow = $self->{_allow};
      my $names = [ grep { not $allow->{$_} } $elem->variables() ];
      # Assert: it is impossible for @$names to be empty in valid Perl syntax
      # But if it IS empty, this code should still work but will be inefficient
  
      # Walk up the PDOM looking for declared variables in the same
      # scope or outer scopes.  Quit when we hit the root or when we find
      # violations for all vars (the latter is a shortcut).
      my $outer = $elem;
      my @violations;
      while (1) {
          my $up = $outer->sprevious_sibling;
          if (not $up) {
              $up = $outer->parent;
              last if !$up; # top of PDOM, we're done
          }
          $outer = $up;
  
          if ($outer->isa('PPI::Statement::Variable') && 'local' ne $outer->type) {
              my %vars = map {$_ => undef} $outer->variables;
              my $hits;
              ($hits, $names) = part { exists $vars{$_} ? 0 : 1 } @{$names};
              if ($hits) {
                  push @violations, map { $self->violation( $DESC . $_, $EXPL, $elem ) } @{$hits};
                  last if not $names;  # found violations for ALL variables, we're done
              }
          }
      }
      return @violations;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitReusedNames - Do not reuse a variable name in a lexical scope
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  It's really hard on future maintenance programmers if you reuse a
  variable name in a lexical scope. The programmer is at risk of
  confusing which variable is which. And, worse, the programmer could
  accidentally remove the inner declaration, thus silently changing the
  meaning of the inner code to use the outer variable.
  
      my $x = 1;
      for my $i (0 .. 10) {
          my $x = $i+1;  # not OK, "$x" reused
      }
  
  With C<use warnings> in effect, Perl will warn you if you reuse a
  variable name at the same scope level but not within nested scopes.  Like so:
  
      % perl -we 'my $x; my $x'
      "my" variable $x masks earlier declaration in same scope at -e line 1.
  
  This policy takes that warning to a stricter level.
  
  
  =head1 CAVEATS
  
  =head2 Crossing subroutines
  
  This policy looks across subroutine boundaries.  So, the following may
  be a false positive for you:
  
      sub make_accessor {
          my ($self, $fieldname) = @_;
          return sub {
              my ($self) = @_;  # false positive, $self declared as reused
              return $self->{$fieldname};
          }
      }
  
  This is intentional, though, because it catches bugs like this:
  
      my $debug_mode = 0;
      sub set_debug {
          my $debug_mode = 1;  # accidental redeclaration
      }
  
  I've done this myself several times -- it's a strong habit to put that
  "my" in front of variables at the start of subroutines.
  
  
  =head2 Performance
  
  The current implementation walks the tree over and over.  For a big
  file, this can be a huge time sink.  I'm considering rewriting to
  search the document just once for variable declarations and cache the
  tree walking on that single analysis.
  
  
  =head1 CONFIGURATION
  
  This policy has a single option, C<allow>, which is a list of names to
  never count as duplicates.  It defaults to containing C<$self> and
  C<$class>.  You add to this by adding something like this to your
  F<.perlcriticrc>:
  
      [Variables::ProhibitReusedNames]
      allow = $self $class @blah
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  This policy is inspired by
  L<http://use.perl.org/~jdavidb/journal/37548>.  Java does not allow
  you to reuse variable names declared in outer scopes, which I think is
  a nice feature.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2013 Chris Dolan
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITREUSEDNAMES

$fatpacked{"Perl/Critic/Policy/Variables/ProhibitUnusedVariables.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROHIBITUNUSEDVARIABLES';
  package Perl::Critic::Policy::Variables::ProhibitUnusedVariables;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  use List::MoreUtils qw< any >;
  
  use PPI::Token::Symbol;
  use PPIx::QuoteLike;
  
  use Perl::Critic::Utils qw< :characters :severities >;
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $EXPL =>
      q<Unused variables clutter code and make it harder to read>;
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                     }
  sub default_severity     { return $SEVERITY_MEDIUM       }
  sub default_themes       { return qw< core maintenance certrec > }
  sub applies_to           { return qw< PPI::Document >    }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $document ) = @_;
  
      my %symbol_usage;
      _get_symbol_usage( \%symbol_usage, $document );
      _get_regexp_symbol_usage( \%symbol_usage, $document );
      return if not %symbol_usage;
  
      my $declarations = $document->find('PPI::Statement::Variable');
      return if not $declarations;
  
      my @violations;
  
      DECLARATION:
      foreach my $declaration ( @{$declarations} ) {
          next DECLARATION if 'my' ne $declaration->type();
  
          my @children = $declaration->schildren();
          next DECLARATION if any { $_->content() eq q<=> } @children;
  
          VARIABLE:
          foreach my $variable ( $declaration->variables() ) {
              my $count = $symbol_usage{ $variable };
              next VARIABLE if not $count; # BUG!
              next VARIABLE if $count > 1;
  
              push
                  @violations,
                  $self->violation(
                      qq<"$variable" is declared but not used.>,
                      $EXPL,
                      $declaration,
                  );
          }
      }
  
      return @violations;
  }
  
  sub _get_symbol_usage {
      my ( $symbol_usage, $document ) = @_;
  
      my $symbols = $document->find('PPI::Token::Symbol');
      return if not $symbols;
  
      foreach my $symbol ( @{$symbols} ) {
          $symbol_usage->{ $symbol->symbol() }++;
      }
  
      foreach my $class ( qw{
          PPI::Token::Quote::Double
          PPI::Token::Quote::Interpolate
          PPI::Token::QuoteLike::Backtick
          PPI::Token::QuoteLike::Command
          PPI::Token::QuoteLike::Readline
          PPI::Token::HereDoc
          } ) {
          foreach my $double_quotish (
              @{ $document->find( $class ) || [] }
          ) {
              my $str = PPIx::QuoteLike->new( $double_quotish )
                  or next;
              foreach my $var ( $str->variables() ) {
                  $symbol_usage->{ $var }++;
              }
          }
      }
  
      return;
  }
  
  sub _get_regexp_symbol_usage {
      my ( $symbol_usage, $document ) = @_;
  
      foreach my $class ( qw{
          PPI::Token::Regexp::Match
          PPI::Token::Regexp::Substitute
          PPI::Token::QuoteLike::Regexp
          } ) {
  
          foreach my $regex ( @{ $document->find( $class ) || [] } ) {
  
              my $ppix = $document->ppix_regexp_from_element( $regex ) or next;
              $ppix->failures() and next;
  
              foreach my $code ( @{
                  $ppix->find( 'PPIx::Regexp::Token::Code' ) || [] } ) {
                  my $subdoc = $code->ppi() or next;
                  _get_symbol_usage( $symbol_usage, $subdoc );
              }
  
          }
  
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProhibitUnusedVariables - Don't ask for storage you don't need.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Unused variables clutter code and require the reader to do mental
  bookkeeping to figure out if the variable is actually used or not.
  
  At present, this Policy is very limited in order to ensure that there
  aren't any false positives.  Hopefully, this will become more
  sophisticated soon.
  
  Right now, this only looks for simply declared, uninitialized lexical
  variables.
  
      my $x;          # not ok, assuming no other appearances.
      my @y = ();     # ok, not handled yet.
      our $z;         # ok, global.
      local $w;       # ok, global.
  
  This module is very dumb: it does no scoping detection, i.e. if the
  same variable name is used in two different locations, even if they
  aren't the same variable, this Policy won't complain.
  
  Have to start somewhere.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROHIBITUNUSEDVARIABLES

$fatpacked{"Perl/Critic/Policy/Variables/ProtectPrivateVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_PROTECTPRIVATEVARS';
  package Perl::Critic::Policy::Variables::ProtectPrivateVars;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Private variable used};
  Readonly::Scalar my $EXPL => q{Use published APIs};
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                   }
  sub default_severity     { return $SEVERITY_MEDIUM     }
  sub default_themes       { return qw(core maintenance certrule ) }
  sub applies_to           { return 'PPI::Token::Symbol' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      if ( $elem =~ m{ \w::_\w+ \z }xms ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::ProtectPrivateVars - Prevent access to private vars in other packages.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  By convention Perl authors (like authors in many other languages)
  indicate private methods and variables by inserting a leading
  underscore before the identifier.  This policy catches attempts to
  access private variables from outside the package itself.
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 HISTORY
  
  This policy is inspired by a similar test in L<B::Lint|B::Lint>
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Policy::Subroutines::ProtectPrivateSubs|Perl::Critic::Policy::Subroutines::ProtectPrivateSubs>
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_PROTECTPRIVATEVARS

$fatpacked{"Perl/Critic/Policy/Variables/RequireInitializationForLocalVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIREINITIALIZATIONFORLOCALVARS';
  package Perl::Critic::Policy::Variables::RequireInitializationForLocalVars;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{"local" variable not initialized};
  Readonly::Scalar my $EXPL => [ 78 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_MEDIUM           }
  sub default_themes       { return qw(core pbp bugs certrec )          }
  sub applies_to           { return 'PPI::Statement::Variable' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
      if ( $elem->type() eq 'local' && !_is_initialized($elem) ) {
          return $self->violation( $DESC, $EXPL, $elem );
      }
      return;    #ok!
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_initialized {
      my $elem = shift;
      my $wanted = sub { $_[1]->isa('PPI::Token::Operator') && $_[1] eq q{=} };
      return $elem->find( $wanted ) ? 1 : 0;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::RequireInitializationForLocalVars - Write C<local $foo = $bar;> instead of just C<local $foo;>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Most people don't realize that a localized copy of a variable does not
  retain its original value.  Unless you initialize the variable when
  you C<local>-ize it, it defaults to C<undef>.  If you want the
  variable to retain its original value, just initialize it to itself.
  If you really do want the localized copy to be undef, then make it
  explicit.
  
      package Foo;
      $Bar = '42';
  
      package Baz;
  
      sub frobulate {
  
          local $Foo::Bar;              #not ok, local $Foo::Bar is 'undef'
          local $Foo::Bar = undef;      #ok, local $Foo::Bar is obviously 'undef'
          local $Foo::Bar = $Foo::Bar;  #ok, local $Foo::Bar still equals '42'
  
      }
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_REQUIREINITIALIZATIONFORLOCALVARS

$fatpacked{"Perl/Critic/Policy/Variables/RequireLexicalLoopIterators.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIRELEXICALLOOPITERATORS';
  package Perl::Critic::Policy::Variables::RequireLexicalLoopIterators;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  use version ();
  
  use Perl::Critic::Utils qw{ :booleans :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Loop iterator is not lexical};
  Readonly::Scalar my $EXPL => [ 108 ];
  
  Readonly::Scalar my $MINIMUM_PERL_VERSION => version->new( 5.004 );
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                         }
  sub default_severity     { return $SEVERITY_HIGHEST          }
  sub default_themes       { return qw(core pbp bugs certrec )          }
  sub applies_to           { return 'PPI::Statement::Compound' }
  
  #-----------------------------------------------------------------------------
  
  sub prepare_to_scan_document {
      my ( $self, $document ) = @_;
      # perl5004delta says that is when lexical iterators were introduced,
      # so ... (RT 67760)
      my $version = $document->highest_explicit_perl_version();
      return ! $version || $version >= $MINIMUM_PERL_VERSION;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      # First child will be 'for' or 'foreach' keyword
      return if $elem->type() ne 'foreach';
  
      my $first_child = $elem->schild(0);
      return if not $first_child;
      my $start = $first_child->isa('PPI::Token::Label') ? 1 : 0;
  
      my $potential_scope = $elem->schild($start + 1);
      return if not $potential_scope;
      return if $potential_scope->isa('PPI::Structure::List');
  
      return if $potential_scope eq 'my';
  
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords foreach perlsyn
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::RequireLexicalLoopIterators - Write C<for my $element (@list) {...}> instead of C<for $element (@list) {...}>.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  This policy asks you to use C<my>-style lexical loop iterator variables:
  
      foreach my $zed (...) {
          ...
      }
  
  Unless you use C<my>, C<for>/C<foreach> loops use a global variable with
  its value C<local> to the block. In other words,
  
      foreach $zed (...) {
          ...
      }
  
  is more-or-less equivalent to
  
      {
          local $zed
          foreach $zed (...) {
              ...
          }
      }
  
  This may not seem like a big deal until you see code like
  
      my $bicycle;
      for $bicycle (@things_attached_to_the_bike_rack) {
          if (
                  $bicycle->is_red()
              and $bicycle->has_baseball_card_in_spokes()
              and $bicycle->has_bent_kickstand()
          ) {
              $bicycle->remove_lock();
  
              last;
          }
      }
  
      if ( $bicycle and $bicycle->is_unlocked() ) {
          ride_home($bicycle);
      }
  
  which is not going to allow you to arrive in time for dinner with your
  family because the C<$bicycle> outside the loop is not changed by the
  loop. You may have unlocked your bicycle, but you can't remember which
  one it was.
  
  Lexical loop variables were introduced in Perl 5.004. This policy does
  not report violations on code which explicitly specifies an earlier
  version of Perl (e.g. C<require 5.002;>).
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 SEE ALSO
  
  L<"Foreach Loops" in perlsyn|perlsyn/Foreach Loops>
  
  L<"my() in Control Structures" in perl5004delta|perl5004delta/my() in control structures>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_REQUIRELEXICALLOOPITERATORS

$fatpacked{"Perl/Critic/Policy/Variables/RequireLocalizedPunctuationVars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIRELOCALIZEDPUNCTUATIONVARS';
  package Perl::Critic::Policy::Variables::RequireLocalizedPunctuationVars;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities :classification $EMPTY hashify};
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $PACKAGE_RX => qr/::/xms;
  Readonly::Hash   my %EXCEPTIONS => hashify(qw(
      $_
      $ARG
      @_
  ));
  Readonly::Scalar my $DESC => q{Magic variable "%s" should be assigned as "local"};
  Readonly::Scalar my $EXPL => [ 81, 82 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters {
      return (
          {
              name            => 'allow',
              description     =>
                  q<Global variables to exclude from this policy.>,
              default_string  => $EMPTY,
              behavior        => 'string list',
              list_always_present_values => [ qw< $_ $ARG @_ > ],
          },
      );
  }
  
  sub default_severity     { return $SEVERITY_HIGH             }
  sub default_themes       { return qw(core pbp bugs certrec )          }
  sub applies_to           { return 'PPI::Token::Operator'     }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, undef ) = @_;
  
      return if $elem->content() ne q{=};
  
      my $destination = $elem->sprevious_sibling;
      return if !$destination;  # huh? assignment in void context??
      while ($destination->isa('PPI::Structure::Subscript')) {
          $destination = $destination->sprevious_sibling()
              or return;
      }
  
      if (my $var = $self->_is_non_local_magic_dest($destination)) {
         return $self->violation( sprintf( $DESC, $var ), $EXPL, $elem );
      }
      return;  # OK
  }
  
  sub _is_non_local_magic_dest {
      my ($self, $elem) = @_;
  
      # Quick exit if in good form
      my $modifier = $elem->sprevious_sibling;
      return
          if
                  $modifier
              &&  $modifier->isa('PPI::Token::Word')
              &&  ($modifier->content() eq 'local'
                  || $modifier->content() eq 'my');
  
      # Implementation note: Can't rely on PPI::Token::Magic,
      # unfortunately, because we need English too
  
      if ($elem->isa('PPI::Token::Symbol')) {
          return $self->_is_magic_var($elem) ? $elem : undef;
      }
      elsif (
              $elem->isa('PPI::Structure::List')
          or  $elem->isa('PPI::Statement::Expression')
      ) {
          for my $child ($elem->schildren) {
              my $var = $self->_is_non_local_magic_dest($child);
              return $var if $var;
          }
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_magic_var {
      my ($self, $elem) = @_;
  
      my $variable_name = $elem->symbol();
      return if $self->{_allow}{$variable_name};
      return 1 if $elem->isa('PPI::Token::Magic'); # optimization(?), and
                                          # helps with PPI 1.118 carat
                                          # bug. This bug is gone as of
                                          # 1.208, which is required for
                                          # P::C 1.113. RT 65514
      return if not is_perl_global( $elem );
  
      return 1;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::RequireLocalizedPunctuationVars - Magic variables should be assigned as "local".
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Punctuation variables (and their English.pm equivalents) are global
  variables.  Messing with globals is dangerous in a complex program as
  it can lead to very subtle and hard to fix bugs.  If you must change a
  magic variable in a non-trivial program, do it in a local scope.
  
  For example, to slurp a filehandle into a scalar, it's common to set
  the record separator to undef instead of a newline.  If you choose to
  do this (instead of using L<Path::Tiny|Path::Tiny>!) then be sure to
  localize the global and change it for as short a time as possible.
  
      # BAD:
      $/ = undef;
      my $content = <$fh>;
  
      # BETTER:
      my $content;
      {
          local $/ = undef;
          $content = <$fh>;
      }
  
      # A popular idiom:
      my $content = do { local $/ = undef; <$fh> };
  
  This policy also allows the use of C<my>.  Perl prevents using C<my>
  with "proper" punctuation variables, but allows C<$a>, C<@ARGV>, the
  names declared by L<English|English>, etc.  This is not a good coding
  practice, however it is not the concern of this specific policy to
  complain about that.
  
  There are exemptions for C<$_> and C<@_>, and the English equivalent
  C<$ARG>.
  
  
  =head1 CONFIGURATION
  
  You can configure your own exemptions using the C<allow> option:
  
      [Variables::RequireLocalizedPunctuationVars]
      allow = @ARGV $ARGV
  
  These are added to the default exemptions.
  
  
  =head1 CREDITS
  
  Initial development of this policy was supported by a grant from the
  Perl Foundation.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Chris Dolan.  Many rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_REQUIRELOCALIZEDPUNCTUATIONVARS

$fatpacked{"Perl/Critic/Policy/Variables/RequireNegativeIndices.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICY_VARIABLES_REQUIRENEGATIVEINDICES';
  package Perl::Critic::Policy::Variables::RequireNegativeIndices;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :severities };
  use base 'Perl::Critic::Policy';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $DESC => q{Negative array index should be used};
  Readonly::Scalar my $EXPL => [ 88 ];
  
  #-----------------------------------------------------------------------------
  
  sub supported_parameters { return ()                          }
  sub default_severity     { return $SEVERITY_HIGH              }
  sub default_themes       { return qw( core maintenance pbp )  }
  sub applies_to           { return 'PPI::Structure::Subscript' }
  
  #-----------------------------------------------------------------------------
  
  sub violates {
      my ( $self, $elem, $doc ) = @_;
  
      return if $elem->braces ne '[]';
      my ($name, $isref) = _is_bad_index( $elem );
      return if ( !$name );
      return if !_is_array_name( $elem, $name, $isref );
      return $self->violation( $DESC, $EXPL, $elem );
  }
  
  Readonly::Scalar my $MAX_EXPRESSION_COMPLEXETY => 4;
  
  sub _is_bad_index {
      # return (varname, 0|1) if this could be a violation
      my ( $elem ) = @_;
  
      my @children = $elem->schildren();
      return if @children != 1; # too complex
      return if !$children[0]->isa( 'PPI::Statement::Expression'); # too complex
  
      # This is the expression elements that compose the array indexing
      my @expr = $children[0]->schildren();
      return if !@expr || @expr > $MAX_EXPRESSION_COMPLEXETY;
      my ($name, $isref, $isindex) = _is_bad_var_in_index(\@expr);
      return if !$name;
      return $name, $isref if !@expr && $isindex;
      return if !_is_minus_number(@expr);
      return $name, $isref;
  }
  
  sub _is_bad_var_in_index {
      # return (varname, isref=0|1, isindex=0|1) if this could be a violation
      my ( $expr ) = @_;
  
      if ( $expr->[0]->isa('PPI::Token::ArrayIndex') ) {
          # [$#arr]
          return _arrayindex($expr);
      }
      elsif ( $expr->[0]->isa('PPI::Token::Cast') ) {
          # [$#{$arr} ...] or [$#$arr ...] or [@{$arr} ...] or [@$arr ...]
          return _cast($expr);
      }
      elsif ($expr->[0]->isa('PPI::Token::Symbol')) {
          # [@arr ...]
          return _symbol($expr);
      }
  
      return;
  }
  
  sub _arrayindex {
      # return (varname, isref=0|1, isindex=0|1) if this could be a violation
      my ( $expr ) = @_;
      my $arrindex = shift @{$expr};
      if ($arrindex->content =~ m/\A \$[#] (.*) \z /xms) { # What else could it be???
         return $1, 0, 1;
      }
      return;
  }
  
  sub _cast {
      # return (varname, isref=0|1, isindex=0|1) if this could be a violation
      my ( $expr ) = @_;
      my $cast = shift @{$expr};
      if ( $cast eq q{$#} || $cast eq q{@} ) { ## no critic(RequireInterpolationOfMetachars)
          my $isindex = $cast eq q{$#} ? 1 : 0;  ## no critic(RequireInterpolationOfMetachars)
          my $arrvar = shift @{$expr};
          if ($arrvar->isa('PPI::Structure::Block')) {
              # look for [$#{$arr} ...] or [@{$arr} ...]
              my @blockchildren = $arrvar->schildren();
              return if @blockchildren != 1;
              return if !$blockchildren[0]->isa('PPI::Statement');
              my @ggg = $blockchildren[0]->schildren;
              return if @ggg != 1;
              return if !$ggg[0]->isa('PPI::Token::Symbol');
              if ($ggg[0] =~ m/\A \$ (.*) \z/xms) {
                  return $1, 1, $isindex;
              }
          }
          elsif ( $arrvar->isa('PPI::Token::Symbol') ) {
             # look for [$#$arr ...] or [@$arr ...]
             if ($arrvar =~ m/\A \$ (.*) \z/xms) {
                return $1, 1, $isindex;
             }
          }
      }
      return;
  }
  
  sub _symbol {
      # return (varname, isref=0|1, isindex=0|1) if this could be a violation
      my ( $expr ) = @_;
      my $arrvar = shift @{$expr};
      if ($arrvar =~ m/\A \@ (.*) \z/xms) {
         return $1, 0, 0;
      }
      return;
  }
  
  sub _is_minus_number {  # return true if @expr looks like "- n"
      my @expr = @_;
  
      return if !@expr;
  
      return if @expr != 2;
  
      my $op = shift @expr;
      return if !$op->isa('PPI::Token::Operator');
      return if $op ne q{-};
  
      my $number = shift @expr;
      return if !$number->isa('PPI::Token::Number');
  
      return 1;
  }
  
  sub _is_array_name {  # return true if name and isref matches
      my ( $elem, $name, $isref ) = @_;
  
      my $sib = $elem->sprevious_sibling;
      return if !$sib;
  
      if ($sib->isa('PPI::Token::Operator') && $sib eq '->') {
          return if ( !$isref );
          $isref = 0;
          $sib = $sib->sprevious_sibling;
          return if !$sib;
      }
  
      return if !$sib->isa('PPI::Token::Symbol');
      return if $sib !~ m/\A \$ \Q$name\E \z/xms;
  
      my $cousin = $sib->sprevious_sibling;
      return if $isref ^ _is_dereferencer( $cousin );
      return if $isref && _is_dereferencer( $cousin->sprevious_sibling );
  
      return $elem;
  }
  
  sub _is_dereferencer { # must return 0 or 1, not undef
      my $elem = shift;
  
      return 0 if !$elem;
      return 1 if $elem->isa('PPI::Token::Operator') && $elem eq '->';
      return 1 if $elem->isa('PPI::Token::Cast');
      return 0;
  }
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =pod
  
  =for stopwords performant
  
  =head1 NAME
  
  Perl::Critic::Policy::Variables::RequireNegativeIndices - Negative array index should be used.
  
  
  =head1 AFFILIATION
  
  This Policy is part of the core L<Perl::Critic|Perl::Critic>
  distribution.
  
  
  =head1 DESCRIPTION
  
  Perl treats a negative array subscript as an offset from the end. Given
  this, the preferred way to get the last element is C<$x[-1]>, not
  C<$x[$#x]> or C<$x[@x-1]>, and the preferred way to get the next-to-last
  is C<$x[-2]>, not C<$x[$#x-1> or C<$x[@x-2]>.
  
  The biggest argument against the non-preferred forms is that B<their
  semantics change> when the computed index becomes negative. If C<@x>
  contains at least two elements, C<$x[$#x-1]> and C<$x[@x-2]> are
  equivalent to C<$x[-2]>. But if it contains a single element,
  C<$x[$#x-1]> and C<$x[@x-2]> are both equivalent to C<$x[-1]>. Simply
  put, the preferred form is more likely to do what you actually want.
  
  As Conway points out, the preferred forms also perform better, are more
  readable, and are easier to maintain.
  
  This policy notices all of the simple forms of the above problem, but
  does not recognize any of these more complex examples:
  
      $some->[$data_structure]->[$#{$some->[$data_structure]} -1];
      my $ref = \@arr; $ref->[$#arr];
  
  
  =head1 CONFIGURATION
  
  This Policy is not configurable except for the standard options.
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICY_VARIABLES_REQUIRENEGATIVEINDICES

$fatpacked{"Perl/Critic/PolicyConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYCONFIG';
  package Perl::Critic::PolicyConfig;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  our $VERSION = '1.132';
  
  use Perl::Critic::Exception::AggregateConfiguration;
  use Perl::Critic::Exception::Configuration::Option::Policy::ParameterValue;
  use Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter;
  use Perl::Critic::Utils qw< :booleans :characters severity_to_number >;
  use Perl::Critic::Utils::Constants qw< :profile_strictness >;
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $NON_PUBLIC_DATA    => '_non_public_data';
  Readonly::Scalar my $NO_LIMIT           => 'no_limit';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, $policy_short_name, $specification) = @_;
  
      my %self = $specification ? %{ $specification } : ();
      my %non_public_data;
  
      $non_public_data{_policy_short_name} = $policy_short_name;
      $non_public_data{_profile_strictness} =
          $self{$NON_PUBLIC_DATA}{_profile_strictness};
  
      foreach my $standard_parameter (
          qw< maximum_violations_per_document severity set_themes add_themes >
      ) {
          if ( exists $self{$standard_parameter} ) {
              $non_public_data{"_$standard_parameter"} =
                  delete $self{$standard_parameter};
          }
      }
  
      $self{$NON_PUBLIC_DATA} = \%non_public_data;
  
  
      return bless \%self, $class;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_non_public_data {
      my $self = shift;
  
      return $self->{$NON_PUBLIC_DATA};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_policy_short_name {
      my $self = shift;
  
      return $self->_get_non_public_data()->{_policy_short_name};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_set_themes {
      my ($self) = @_;
  
      return $self->_get_non_public_data()->{_set_themes};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_add_themes {
      my ($self) = @_;
  
      return $self->_get_non_public_data()->{_add_themes};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_severity {
      my ($self) = @_;
  
      return $self->_get_non_public_data()->{_severity};
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_maximum_violations_per_document_unlimited {
      my ($self) = @_;
  
      my $maximum_violations = $self->get_maximum_violations_per_document();
      if (
              not defined $maximum_violations
          or  $maximum_violations eq $EMPTY
          or  $maximum_violations =~ m<\A $NO_LIMIT \z>xmsio
      ) {
          return $TRUE;
      }
  
      return $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_maximum_violations_per_document {
      my ($self) = @_;
  
      return $self->_get_non_public_data()->{_maximum_violations_per_document};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get {
      my ($self, $parameter) = @_;
  
      return if $parameter eq $NON_PUBLIC_DATA;
  
      return $self->{$parameter};
  }
  
  #-----------------------------------------------------------------------------
  
  sub remove {
      my ($self, $parameter) = @_;
  
      return if $parameter eq $NON_PUBLIC_DATA;
  
      delete $self->{$parameter};
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_empty {
      my ($self) = @_;
  
      return 1 >= keys %{$self};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_parameter_names {
      my ($self) = @_;
  
      return grep { $_ ne $NON_PUBLIC_DATA } keys %{$self};
  }
  
  #-----------------------------------------------------------------------------
  
  sub handle_extra_parameters {
      my ($self, $policy, $errors) = @_;
  
      my $profile_strictness = $self->{$NON_PUBLIC_DATA}{_profile_strictness};
      defined $profile_strictness
          or $profile_strictness = $PROFILE_STRICTNESS_DEFAULT;
  
      return if $profile_strictness eq $PROFILE_STRICTNESS_QUIET;
  
      my $parameter_errors = $profile_strictness eq $PROFILE_STRICTNESS_WARN ?
          Perl::Critic::Exception::AggregateConfiguration->new() : $errors;
  
      foreach my $offered_param ( $self->get_parameter_names() ) {
          $parameter_errors->add_exception(
              Perl::Critic::Exception::Configuration::Option::Policy::ExtraParameter->new(
                  policy => $policy->get_short_name(),
                  option_name => $offered_param,
                  source  => undef,
              )
          );
      }
  
      warn qq<$parameter_errors\n>
          if ($profile_strictness eq $PROFILE_STRICTNESS_WARN
              && $parameter_errors->has_exceptions());
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub set_profile_strictness {
      my ($self, $profile_strictness) = @_;
  
      $self->{$NON_PUBLIC_DATA}{_profile_strictness} = $profile_strictness;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyConfig - Configuration data for a Policy.
  
  
  
  =head1 DESCRIPTION
  
  A container for the configuration of a Policy.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<get_policy_short_name()>
  
  The name of the policy this configuration is for.  Primarily here for
  the sake of debugging.
  
  
  =item C< get_set_themes() >
  
  The value of C<set_themes> in the user's F<.perlcriticrc>.
  
  
  =item C< get_add_themes() >
  
  The value of C<add_themes> in the user's F<.perlcriticrc>.
  
  
  =item C< get_severity() >
  
  The value of C<severity> in the user's F<.perlcriticrc>.
  
  
  =item C< is_maximum_violations_per_document_unlimited() >
  
  Answer whether the value of C<maximum_violations_per_document> should
  be considered to be unlimited.
  
  
  =item C< get_maximum_violations_per_document() >
  
  The value of C<maximum_violations_per_document> in the user's
  F<.perlcriticrc>.
  
  
  =item C< get($parameter) >
  
  Retrieve the value of the specified parameter in the user's
  F<.perlcriticrc>.
  
  
  =item C< remove($parameter) >
  
  Delete the value of the specified parameter.
  
  
  =item C< is_empty() >
  
  Answer whether there is any non-standard configuration information
  left.
  
  
  =item C< get_parameter_names() >
  
  Retrieve the names of the parameters in this object.
  
  
  =item C< set_profile_strictness($profile_strictness) >
  
  Sets the profile strictness associated with the configuration.
  
  
  =item C< handle_extra_parameters($policy,$errors) >
  
  Deals with any extra parameters according to the profile_strictness
  setting.  To be called by Perl::Critic::Policy->new() once all valid
  policies have been processed and removed from the configuration.
  
  If profile_strictness is $PROFILE_STRICTNESS_QUIET, extra policy
  parameters are ignored.
  
  If profile_strictness is $PROFILE_STRICTNESS_WARN, extra policy
  parameters generate a warning.
  
  If profile_strictness is $PROFILE_STRICTNESS_FATAL, extra policy
  parameters generate a fatal error.
  
  If no profile_strictness was set, the behavior is that specified by
  $PROFILE_STRICTNESS_DEFAULT.
  
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::DEVELOPER/"MAKING YOUR POLICY CONFIGURABLE">
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYCONFIG

$fatpacked{"Perl/Critic/PolicyFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYFACTORY';
  package Perl::Critic::PolicyFactory;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  
  use File::Spec::Unix qw();
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{
      :characters
      $POLICY_NAMESPACE
      :data_conversion
      policy_long_name
      policy_short_name
      :internal_lookup
  };
  use Perl::Critic::PolicyConfig;
  use Perl::Critic::Exception::AggregateConfiguration;
  use Perl::Critic::Exception::Configuration;
  use Perl::Critic::Exception::Fatal::Generic qw{ throw_generic };
  use Perl::Critic::Exception::Fatal::Internal qw{ throw_internal };
  use Perl::Critic::Exception::Fatal::PolicyDefinition
      qw{ throw_policy_definition };
  use Perl::Critic::Exception::Configuration::NonExistentPolicy qw< >;
  use Perl::Critic::Utils::Constants qw{ :profile_strictness };
  
  use Exception::Class;   # this must come after "use P::C::Exception::*"
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  # Globals.  Ick!
  my @site_policy_names = ();
  
  #-----------------------------------------------------------------------------
  
  # Blech!!!  This is ug-lee.  Belongs in the constructor.  And it shouldn't be
  # called "test" mode.
  sub import {
  
      my ( $class, %args ) = @_;
      my $test_mode = $args{-test};
      my $extra_test_policies = $args{'-extra-test-policies'};
  
      if ( not @site_policy_names ) {
          my $eval_worked = eval {
              require Module::Pluggable;
              Module::Pluggable->import(search_path => $POLICY_NAMESPACE,
                                        require => 1, inner => 0);
              @site_policy_names = plugins(); #Exported by Module::Pluggable
              1;
          };
  
          if (not $eval_worked) {
              if ( $EVAL_ERROR ) {
                  throw_generic
                      qq<Can't load Policies from namespace "$POLICY_NAMESPACE": $EVAL_ERROR>;
              }
  
              throw_generic
                  qq<Can't load Policies from namespace "$POLICY_NAMESPACE" for an unknown reason.>;
          }
  
          if ( not @site_policy_names ) {
              throw_generic
                  qq<No Policies found in namespace "$POLICY_NAMESPACE".>;
          }
      }
  
      # In test mode, only load native policies, not third-party ones.  So this
      # filters out any policy that was loaded from within a directory called
      # "blib".  During the usual "./Build test" process this works fine,
      # but it doesn't work if you are using prove to test against the code
      # directly in the lib/ directory.
  
      if ( $test_mode && any {m/\b blib \b/xms} @INC ) {
          @site_policy_names = _modules_from_blib( @site_policy_names );
  
          if ($extra_test_policies) {
              my @extra_policy_full_names =
                  map { "${POLICY_NAMESPACE}::$_" } @{$extra_test_policies};
  
              push @site_policy_names, @extra_policy_full_names;
          }
      }
  
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  # Some static helper subs
  
  sub _modules_from_blib {
      my (@modules) = @_;
      return grep { _was_loaded_from_blib( _module2path($_) ) } @modules;
  }
  
  sub _module2path {
      my $module = shift || return;
      return File::Spec::Unix->catdir(split m/::/xms, $module) . '.pm';
  }
  
  sub _was_loaded_from_blib {
      my $path = shift || return;
      my $full_path = $INC{$path};
      return $full_path && $full_path =~ m/ (?: \A | \b b ) lib \b /xms;
  }
  
  #-----------------------------------------------------------------------------
  
  sub new {
  
      my ( $class, %args ) = @_;
      my $self = bless {}, $class;
      $self->_init( %args );
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init {
  
      my ($self, %args) = @_;
  
      my $profile = $args{-profile};
      $self->{_profile} = $profile
          or throw_internal q{The -profile argument is required};
  
      my $incoming_errors = $args{-errors};
      my $profile_strictness = $args{'-profile-strictness'};
      $profile_strictness ||= $PROFILE_STRICTNESS_DEFAULT;
      $self->{_profile_strictness} = $profile_strictness;
  
      if ( $profile_strictness ne $PROFILE_STRICTNESS_QUIET ) {
          my $errors;
  
          # If we're supposed to be strict or problems have already been found...
          if (
                  $profile_strictness eq $PROFILE_STRICTNESS_FATAL
              or  ( $incoming_errors and @{ $incoming_errors->exceptions() } )
          ) {
              $errors =
                  $incoming_errors
                      ? $incoming_errors
                      : Perl::Critic::Exception::AggregateConfiguration->new();
          }
  
          $self->_validate_policies_in_profile( $errors );
  
          if (
                  not $incoming_errors
              and $errors
              and $errors->has_exceptions()
          ) {
              $errors->rethrow();
          }
      }
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub create_policy {
  
      my ($self, %args ) = @_;
  
      my $policy_name = $args{-name}
          or throw_internal q{The -name argument is required};
  
      # Normalize policy name to a fully-qualified package name
      $policy_name = policy_long_name( $policy_name );
      my $policy_short_name = policy_short_name( $policy_name );
  
  
      # Get the policy parameters from the user profile if they were
      # not given to us directly.  If none exist, use an empty hash.
      my $profile = $self->_profile();
      my $policy_config;
      if ( $args{-params} ) {
          $policy_config =
              Perl::Critic::PolicyConfig->new(
                  $policy_short_name, $args{-params}
              );
      }
      else {
          $policy_config = $profile->policy_params($policy_name);
          $policy_config ||=
              Perl::Critic::PolicyConfig->new( $policy_short_name );
      }
  
      # Pull out base parameters.
      return $self->_instantiate_policy( $policy_name, $policy_config );
  }
  
  #-----------------------------------------------------------------------------
  
  sub create_all_policies {
  
      my ( $self, $incoming_errors ) = @_;
  
      my $errors =
          $incoming_errors
              ? $incoming_errors
              : Perl::Critic::Exception::AggregateConfiguration->new();
      my @policies;
  
      foreach my $name ( site_policy_names() ) {
          my $policy = eval { $self->create_policy( -name => $name ) };
  
          $errors->add_exception_or_rethrow( $EVAL_ERROR );
  
          if ( $policy ) {
              push @policies, $policy;
          }
      }
  
      if ( not $incoming_errors and $errors->has_exceptions() ) {
          $errors->rethrow();
      }
  
      return @policies;
  }
  
  #-----------------------------------------------------------------------------
  
  sub site_policy_names {
      my @sorted_policy_names = sort @site_policy_names;
      return @sorted_policy_names;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _profile {
      my ($self) = @_;
  
      return $self->{_profile};
  }
  
  #-----------------------------------------------------------------------------
  
  # This two-phase initialization is caused by the historical lack of a
  # requirement for Policies to invoke their super-constructor.
  sub _instantiate_policy {
      my ($self, $policy_name, $policy_config) = @_;
  
      $policy_config->set_profile_strictness( $self->{_profile_strictness} );
  
      my $policy = eval { $policy_name->new( %{$policy_config} ) };
      _handle_policy_instantiation_exception(
          $policy_name,
          $policy,        # Note: being used as a boolean here.
          $EVAL_ERROR,
      );
  
      $policy->__set_config( $policy_config );
  
      my $eval_worked = eval { $policy->__set_base_parameters(); 1; };
      _handle_policy_instantiation_exception(
          $policy_name, $eval_worked, $EVAL_ERROR,
      );
  
      return $policy;
  }
  
  sub _handle_policy_instantiation_exception {
      my ($policy_name, $eval_worked, $eval_error) = @_;
  
      if (not $eval_worked) {
          if ($eval_error) {
              my $exception = Exception::Class->caught();
  
              if (ref $exception) {
                  $exception->rethrow();
              }
  
              throw_policy_definition
                  qq<Unable to create policy "$policy_name": $eval_error>;
          }
  
          throw_policy_definition
              qq<Unable to create policy "$policy_name" for an unknown reason.>;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_policies_in_profile {
      my ($self, $errors) = @_;
  
      my $profile = $self->_profile();
      my %known_policies = hashify( $self->site_policy_names() );
  
      for my $policy_name ( $profile->listed_policies() ) {
          if ( not exists $known_policies{$policy_name} ) {
              my $message = qq{Policy "$policy_name" is not installed.};
  
              if ( $errors ) {
                  $errors->add_exception(
                      Perl::Critic::Exception::Configuration::NonExistentPolicy->new(
                          policy  => $policy_name,
                      )
                  );
              }
              else {
                  warn qq{$message\n};
              }
          }
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  
  =pod
  
  =for stopwords PolicyFactory -params
  
  =head1 NAME
  
  Perl::Critic::PolicyFactory - Instantiates Policy objects.
  
  
  =head1 DESCRIPTION
  
  This is a helper class that instantiates
  L<Perl::Critic::Policy|Perl::Critic::Policy> objects with the user's
  preferred parameters. There are no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new( -profile => $profile, -errors => $config_errors ) >>
  
  Returns a reference to a new Perl::Critic::PolicyFactory object.
  
  B<-profile> is a reference to a
  L<Perl::Critic::UserProfile|Perl::Critic::UserProfile> object.  This
  argument is required.
  
  B<-errors> is a reference to an instance of
  L<Perl::Critic::ConfigErrors|Perl::Critic::ConfigErrors>.  This
  argument is optional.  If specified, than any problems found will be
  added to the object.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<< create_policy( -name => $policy_name, -params => \%param_hash ) >>
  
  Creates one Policy object.  If the object cannot be instantiated, it
  will throw a fatal exception.  Otherwise, it returns a reference to
  the new Policy object.
  
  B<-name> is the name of a L<Perl::Critic::Policy|Perl::Critic::Policy>
  subclass module.  The C<'Perl::Critic::Policy'> portion of the name
  can be omitted for brevity.  This argument is required.
  
  B<-params> is an optional reference to hash of parameters that will be
  passed into the constructor of the Policy.  If C<-params> is not
  defined, we will use the appropriate Policy parameters from the
  L<Perl::Critic::UserProfile|Perl::Critic::UserProfile>.
  
  Note that the Policy will not have had
  L<Perl::Critic::Policy/"initialize_if_enabled"> invoked on it, so it
  may not yet be usable.
  
  
  =item C< create_all_policies() >
  
  Constructs and returns one instance of each
  L<Perl::Critic::Policy|Perl::Critic::Policy> subclass that is
  installed on the local system.  Each Policy will be created with the
  appropriate parameters from the user's configuration profile.
  
  Note that the Policies will not have had
  L<Perl::Critic::Policy/"initialize_if_enabled"> invoked on them, so
  they may not yet be usable.
  
  
  =back
  
  
  =head1 SUBROUTINES
  
  Perl::Critic::PolicyFactory has a few static subroutines that are used
  internally, but may be useful to you in some way.
  
  =over
  
  =item C<site_policy_names()>
  
  Returns a list of all the Policy modules that are currently installed
  in the Perl::Critic:Policy namespace.  These will include modules that
  are distributed with Perl::Critic plus any third-party modules that
  have been installed.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYFACTORY

$fatpacked{"Perl/Critic/PolicyListing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYLISTING';
  package Perl::Critic::PolicyListing;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  
  use Perl::Critic::Policy qw();
  
  use overload ( q<""> => 'to_string' );
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %args) = @_;
  
      my $self = bless {}, $class;
  
      my $policies = $args{-policies} || [];
      $self->{_policies} = [ sort _by_type @{ $policies } ];
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub to_string {
      my ($self) = @_;
  
      Perl::Critic::Policy::set_format( "%s %p [%t]\n" );
  
      return join q{}, map { "$_" } @{ $self->{_policies} };
  }
  
  #-----------------------------------------------------------------------------
  
  sub _by_type { return ref $a cmp ref $b }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::PolicyListing - Display minimal information about Policies.
  
  
  =head1 DESCRIPTION
  
  This is a helper class that formats a set of Policy objects for
  pretty-printing.  There are no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new( -policies => \@POLICY_OBJECTS ) >>
  
  Returns a reference to a new C<Perl::Critic::PolicyListing> object.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item to_string()
  
  Returns a string representation of this C<PolicyListing>.  See
  L<"OVERLOADS"> for more information.
  
  
  =back
  
  
  =head1 OVERLOADS
  
  When a L<Perl::Critic::PolicyListing|Perl::Critic::PolicyListing> is
  evaluated in string context, it produces a one-line summary of the
  default severity, policy name, and default themes for each
  L<Perl::Critic::Policy|Perl::Critic::Policy> object that was given to
  the constructor of this C<PolicyListing>.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYLISTING

$fatpacked{"Perl/Critic/PolicyParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER';
  package Perl::Critic::PolicyParameter;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Exporter 'import';
  
  Readonly::Array our @EXPORT_OK => qw{ $NO_DESCRIPTION_AVAILABLE };
  
  use String::Format qw{ stringf };
  
  use Perl::Critic::Exception::Fatal::PolicyDefinition
      qw{ throw_policy_definition };
  use Perl::Critic::PolicyParameter::Behavior;
  use Perl::Critic::PolicyParameter::Behavior::Boolean;
  use Perl::Critic::PolicyParameter::Behavior::Enumeration;
  use Perl::Critic::PolicyParameter::Behavior::Integer;
  use Perl::Critic::PolicyParameter::Behavior::String;
  use Perl::Critic::PolicyParameter::Behavior::StringList;
  
  use Perl::Critic::Utils qw{ :characters &interpolate };
  use Perl::Critic::Utils::DataConversion qw{ &defined_or_empty };
  
  our $VERSION = '1.132';
  
  Readonly::Scalar our $NO_DESCRIPTION_AVAILABLE => 'No description available.';
  
  #-----------------------------------------------------------------------------
  
  # Grrr... one of the OO limitations of Perl: you can't put references to
  # subclases in a superclass (well, not nicely).  This map and method belong
  # in Behavior.pm.
  Readonly::Hash my %BEHAVIORS =>
      (
          'boolean'     => Perl::Critic::PolicyParameter::Behavior::Boolean->new(),
          'enumeration' => Perl::Critic::PolicyParameter::Behavior::Enumeration->new(),
          'integer'     => Perl::Critic::PolicyParameter::Behavior::Integer->new(),
          'string'      => Perl::Critic::PolicyParameter::Behavior::String->new(),
          'string list' => Perl::Critic::PolicyParameter::Behavior::StringList->new(),
      );
  
  sub _get_behavior_for_name {
      my $behavior_name = shift;
  
      my $behavior = $BEHAVIORS{$behavior_name}
          or throw_policy_definition qq{There's no "$behavior_name" behavior.};
  
      return $behavior;
  }
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, $specification) = @_;
      my $self = bless {}, $class;
  
      defined $specification
          or throw_policy_definition
              'Attempt to create a ', __PACKAGE__, ' without a specification.';
  
      my $behavior_specification;
  
      my $specification_type = ref $specification;
      if ( not $specification_type ) {
          $self->{_name} = $specification;
  
          $behavior_specification = {};
      } else {
          $specification_type eq 'HASH'
              or throw_policy_definition
                  'Attempt to create a ',
                  __PACKAGE__,
                  " with a $specification_type as a specification.",
                  ;
  
          defined $specification->{name}
              or throw_policy_definition
                  'Attempt to create a ', __PACKAGE__, ' without a name.';
          $self->{_name} = $specification->{name};
  
          $behavior_specification = $specification;
      }
  
      $self->_initialize_from_behavior($behavior_specification);
      $self->_finish_standard_initialization($behavior_specification);
  
      return $self;
  }
  
  # See if the specification includes a Behavior name, and if so, let the
  # Behavior with that name plug in its implementations of parser, etc.
  sub _initialize_from_behavior {
      my ($self, $specification) = @_;
  
      my $behavior_name = $specification->{behavior};
      my $behavior;
      if ($behavior_name) {
          $behavior = _get_behavior_for_name($behavior_name);
      } else {
          $behavior = _get_behavior_for_name('string');
      }
  
      $self->{_behavior} = $behavior;
      $self->{_behavior_values} = {};
  
      $behavior->initialize_parameter($self, $specification);
  
      return;
  }
  
  # Grab the rest of the values out of the specification, including overrides
  # of what the Behavior specified.
  sub _finish_standard_initialization {
      my ($self, $specification) = @_;
  
      my $description =
          $specification->{description} || $NO_DESCRIPTION_AVAILABLE;
      $self->_set_description($description);
      $self->_set_default_string($specification->{default_string});
  
      $self->_set_parser($specification->{parser});
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_name {
      my $self = shift;
  
      return $self->{_name};
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_description {
      my $self = shift;
  
      return $self->{_description};
  }
  
  sub _set_description {
      my ($self, $new_value) = @_;
  
      return if not defined $new_value;
      $self->{_description} = $new_value;
  
      return;
  }
  
  sub _get_description_with_trailing_period {
      my $self = shift;
  
      my $description = $self->get_description();
      if ($description) {
          if ( $PERIOD ne substr $description, ( length $description ) - 1 ) {
              $description .= $PERIOD;
          }
      } else {
          $description = $EMPTY;
      }
  
      return $description;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_default_string {
      my $self = shift;
  
      return $self->{_default_string};
  }
  
  sub _set_default_string {
      my ($self, $new_value) = @_;
  
      return if not defined $new_value;
      $self->{_default_string} = $new_value;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_behavior {
      my $self = shift;
  
      return $self->{_behavior};
  }
  
  sub _get_behavior_values {
      my $self = shift;
  
      return $self->{_behavior_values};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_parser {
      my $self = shift;
  
      return $self->{_parser};
  }
  
  sub _set_parser {
      my ($self, $new_value) = @_;
  
      return if not defined $new_value;
      $self->{_parser} = $new_value;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub parse_and_validate_config_value {
      my ($self, $policy, $config) = @_;
  
      my $config_string = $config->{$self->get_name()};
  
      my $parser = $self->_get_parser();
      if ($parser) {
          $parser->($policy, $self, $config_string);
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub generate_full_description {
      my ($self) = @_;
  
      return $self->_get_behavior()->generate_parameter_description($self);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _generate_full_description {
      my ($self, $prefix) = @_;
  
      my $description = $self->generate_full_description();
  
      if (not $description) {
          return $EMPTY;
      }
  
      if ($prefix) {
          $description =~ s/ ^ /$prefix/xmsg;
      }
  
      return $description;
  }
  
  #-----------------------------------------------------------------------------
  
  sub to_formatted_string {
      my ($self, $format) = @_;
  
      my %specification = (
          n => sub { $self->get_name() },
          d => sub { defined_or_empty( $self->get_description() ) },
          D => sub { defined_or_empty( $self->get_default_string() ) },
          f => sub { $self->_generate_full_description(@_) },
      );
  
      return stringf( interpolate($format), %specification );
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords parsable
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter - Metadata about a parameter for a Policy.
  
  
  =head1 DESCRIPTION
  
  A provider of validation and parsing of parameter values and metadata
  about the parameter.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 METHODS
  
  =over
  
  =item C<get_name()>
  
  Return the name of the parameter.  This is the key that will be looked
  for in the F<.perlcriticrc>.
  
  
  =item C<get_description()>
  
  Return an explanation of the significance of the parameter, as
  provided by the developer of the policy.
  
  
  =item C<get_default_string()>
  
  Return a representation of the default value of this parameter as it
  would appear if it was specified in a F<.perlcriticrc> file.
  
  
  =item C<parse_and_validate_config_value( $parser, $config )>
  
  Extract the configuration value for this parameter from the overall
  configuration and initialize the policy based upon it.
  
  
  =item C<generate_full_description()>
  
  Produce a more complete explanation of the significance of this
  parameter than the value returned by C<get_description()>.
  
  If no description can be derived, returns the empty string.
  
  Note that the result may contain multiple lines.
  
  
  =item C<to_formatted_string( $format )>
  
  Generate a string representation of this parameter, based upon the
  format.
  
  The format is a combination of literal and escape characters similar
  to the way C<sprintf> works.  If you want to know the specific
  formatting capabilities, look at L<String::Format|String::Format>.
  Valid escape characters are:
  
  =over
  
  =item C<%n>
  
  The name of the parameter.
  
  =item C<%d>
  
  The description, as supplied by the programmer.
  
  =item C<%D>
  
  The default value, in a parsable form.
  
  =item C<%f>
  
  The full description, which is an extension of the value returned by
  C<%d>.  Takes a parameter of a prefix for the beginning of each line.
  
  
  =back
  
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::DEVELOPER/"MAKING YOUR POLICY CONFIGURABLE">
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER

$fatpacked{"Perl/Critic/PolicyParameter/Behavior.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR';
  package Perl::Critic::PolicyParameter::Behavior;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Perl::Critic::Utils qw{ :characters };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my $class = shift;
  
      return bless {}, $class;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_parameter {
      my ($self, $parameter, $specification) = @_;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub generate_parameter_description {
      my ($self, $parameter) = @_;
  
      return $parameter->_get_description_with_trailing_period();
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter::Behavior - Default type-specific actions for a parameter.
  
  
  =head1 DESCRIPTION
  
  Provides a standard set of functionality for a
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter> so that
  the developer of a policy does not have to provide it her/himself.
  The developer can override most of the functionality in the
  subclasses; these are just defaults.
  
  All subclasses have singleton instances held onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<initialize_parameter( $parameter, $specification )>
  
  Plug in the functionality this behavior provides into the parameter,
  based upon the configuration provided by the specification.  The
  configuration items looked for depends upon the specific behavior
  subclass.
  
  =item C<generate_parameter_description( $parameter )>
  
  Create a description of the parameter, based upon the description on
  the parameter itself, but enhancing it with information from this
  behavior.
  
  Note that this may return C<undef> if the parameter itself doesn't
  have a description.  Also, the returned value may include multiple
  lines.
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_BOOLEAN';
  package Perl::Critic::PolicyParameter::Behavior::Boolean;
  
  use 5.006001;
  use strict;
  use warnings;
  use Perl::Critic::Utils;
  
  use base qw{ Perl::Critic::PolicyParameter::Behavior };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub _parse {
      my ($policy, $parameter, $config_string) = @_;
  
      my $value;
      my $value_string = $parameter->get_default_string();
  
      if (defined $config_string) {
          $value_string = $config_string;
      }
  
      if ( $value_string ) {
          $value = $TRUE;
      } else {
          $value = $FALSE;
      }
  
      $policy->__set_parameter_value($parameter, $value);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_parameter {
      my ($self, $parameter, $specification) = @_;
  
      $parameter->_set_parser(\&_parse);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter::Behavior::Boolean - Actions appropriate for a boolean parameter.
  
  
  =head1 DESCRIPTION
  
  Provides a standard set of functionality for a boolean
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter> so that
  the developer of a policy does not have to provide it her/himself.
  
  NOTE: Do not instantiate this class.  Use the singleton instance held
  onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<initialize_parameter( $parameter, $specification )>
  
  Plug in the functionality this behavior provides into the parameter.
  At present, this behavior isn't customizable by the specification.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_BOOLEAN

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/Enumeration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_ENUMERATION';
  package Perl::Critic::PolicyParameter::Behavior::Enumeration;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Perl::Critic::Exception::Fatal::PolicyDefinition
      qw{ &throw_policy_definition };
  use Perl::Critic::Utils qw{ :characters &words_from_string &hashify };
  
  use base qw{ Perl::Critic::PolicyParameter::Behavior };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub initialize_parameter {
      my ($self, $parameter, $specification) = @_;
  
      my $valid_values = $specification->{enumeration_values}
          or throw_policy_definition
              'No enumeration_values given for '
                  . $parameter->get_name()
                  . $PERIOD;
      ref $valid_values eq 'ARRAY'
          or throw_policy_definition
              'The value given for enumeration_values for '
                  . $parameter->get_name()
                  . ' is not an array reference.';
      scalar @{$valid_values} > 1
          or throw_policy_definition
              'There were not at least two valid values given for'
                  . ' enumeration_values for '
                  . $parameter->get_name()
                  . $PERIOD;
  
      # Unfortunately, this has to be a reference, rather than a regular hash,
      # due to a problem in Devel::Cycle
      # (http://rt.cpan.org/Ticket/Display.html?id=25360) which causes
      # t/92_memory_leaks.t to fall over.
      my $value_lookup = { hashify( @{$valid_values} ) };
      $parameter->_get_behavior_values()->{enumeration_values} = $value_lookup;
  
      my $allow_multiple_values =
          $specification->{enumeration_allow_multiple_values};
  
      if ($allow_multiple_values) {
          $parameter->_set_parser(
              sub {
                  # Normally bad thing, obscuring a variable in a outer scope
                  # with a variable with the same name is being done here in
                  # order to remain consistent with the parser function interface.
                  my ($policy, $parameter, $config_string) = @_;  ## no critic(Variables::ProhibitReusedNames)
  
                  my @potential_values;
                  my $value_string = $parameter->get_default_string();
  
                  if (defined $config_string) {
                      $value_string = $config_string;
                  }
  
                  if ( defined $value_string ) {
                      @potential_values = words_from_string($value_string);
  
                      my @bad_values =
                          grep { not exists $value_lookup->{$_} } @potential_values;
                      if (@bad_values) {
                          $policy->throw_parameter_value_exception(
                              $parameter->get_name(),
                              $value_string,
                              undef,
                              q{contains invalid values: }
                                  . join (q{, }, @bad_values)
                                  . q{. Allowed values are: }
                                  . join (q{, }, sort keys %{$value_lookup})
                                  . qq{.\n},
                          );
                      }
                  }
  
                  my %actual_values = hashify(@potential_values);
  
                  $policy->__set_parameter_value($parameter, \%actual_values);
  
                  return;
              }
          );
      } else {
          $parameter->_set_parser(
              sub {
                  # Normally bad thing, obscuring a variable in a outer scope
                  # with a variable with the same name is being done here in
                  # order to remain consistent with the parser function interface.
                  my ($policy, $parameter, $config_string) = @_;  ## no critic(Variables::ProhibitReusedNames)
  
                  my $value_string = $parameter->get_default_string();
  
                  if (defined $config_string) {
                      $value_string = $config_string;
                  }
  
                  if (
                          defined $value_string
                      and $EMPTY ne $value_string
                      and not defined $value_lookup->{$value_string}
                  ) {
                      $policy->throw_parameter_value_exception(
                          $parameter->get_name(),
                          $value_string,
                          undef,
                          q{is not one of the allowed values: }
                              . join (q{, }, sort keys %{$value_lookup})
                              . qq{.\n},
                      );
                  }
  
                  $policy->__set_parameter_value($parameter, $value_string);
  
                  return;
              }
          );
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub generate_parameter_description {
      my ($self, $parameter) = @_;
  
      my $description = $parameter->_get_description_with_trailing_period();
      if ( $description ) {
          $description .= qq{\n};
      }
  
      my %values = %{$parameter->_get_behavior_values()->{enumeration_values}};
      return
          $description
          . 'Valid values: '
          . join (', ', sort keys %values)
          . $PERIOD;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter::Behavior::Enumeration - Actions appropriate for an enumerated value.
  
  
  =head1 DESCRIPTION
  
  Provides a standard set of functionality for an enumerated
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter> so that
  the developer of a policy does not have to provide it her/himself.
  
  NOTE: Do not instantiate this class.  Use the singleton instance held
  onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<initialize_parameter( $parameter, $specification )>
  
  Plug in the functionality this behavior provides into the parameter,
  based upon the configuration provided by the specification.
  
  This behavior looks for two configuration items:
  
  =over
  
  =item enumeration_values
  
  Mandatory.  The set of valid values for the parameter, as an array
  reference.
  
  
  =item enumeration_allow_multiple_values
  
  Optional, defaults to false.  Should the parameter support a single
  value or accept multiple?
  
  
  =back
  
  
  =item C<generate_parameter_description( $parameter )>
  
  Create a description of the parameter, based upon the description on
  the parameter itself, but enhancing it with information from this
  behavior.
  
  In this specific case, the universe of values is added at the end.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_ENUMERATION

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/Integer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_INTEGER';
  package Perl::Critic::PolicyParameter::Behavior::Integer;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Perl::Critic::Utils qw{ :characters };
  
  use base qw{ Perl::Critic::PolicyParameter::Behavior };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub initialize_parameter {
      my ($self, $parameter, $specification) = @_;
  
      my $minimum = $specification->{integer_minimum};
      my $maximum = $specification->{integer_maximum};
  
      $parameter->_get_behavior_values()->{minimum} = $minimum;
      $parameter->_get_behavior_values()->{maximum} = $maximum;
  
      $parameter->_set_parser(
          sub {
              # Normally bad thing, obscuring a variable in a outer scope
              # with a variable with the same name is being done here in
              # order to remain consistent with the parser function interface.
              my ($policy, $parameter, $config_string) = @_;  ## no critic(Variables::ProhibitReusedNames)
  
              my $value_string = $parameter->get_default_string();
  
              if (defined $config_string) {
                  $value_string = $config_string;
              }
  
              my $value;
              if ( defined $value_string ) {
                  if (
                          $value_string !~ m/ \A [-+]? [1-9] [\d_]* \z /xms
                      and $value_string ne '0'
                  ) {
                      $policy->throw_parameter_value_exception(
                          $parameter->get_name(),
                          $value_string,
                          undef,
                          'does not look like an integer.',
                      );
                  }
  
                  $value_string =~ tr/_//d;
                  $value = $value_string + 0;
  
                  if ( defined $minimum and $minimum > $value ) {
                      $policy->throw_parameter_value_exception(
                          $parameter->get_name(),
                          $value_string,
                          undef,
                          qq{is less than $minimum.},
                      );
                  }
  
                  if ( defined $maximum and $maximum < $value ) {
                      $policy->throw_parameter_value_exception(
                          $parameter->get_name(),
                          $value_string,
                          undef,
                          qq{is greater than $maximum.},
                      );
                  }
              }
  
              $policy->__set_parameter_value($parameter, $value);
              return;
          }
      );
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub generate_parameter_description {
      my ($self, $parameter) = @_;
  
      my $minimum = $parameter->_get_behavior_values()->{minimum};
      my $maximum = $parameter->_get_behavior_values()->{maximum};
  
      my $description = $parameter->_get_description_with_trailing_period();
      if ( $description ) {
          $description .= qq{\n};
      }
  
      if (defined $minimum or defined $maximum) {
          if (defined $minimum) {
              $description .= "Minimum value $minimum. ";
          } else {
              $description .= 'No minimum. ';
          }
  
          if (defined $maximum) {
              $description .= "Maximum value $maximum.";
          } else {
              $description .= 'No maximum.';
          }
      } else {
          $description .= 'No limits.';
      }
  
      return $description;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter::Behavior::Integer - Actions appropriate for an integer parameter.
  
  
  =head1 DESCRIPTION
  
  Provides a standard set of functionality for an integer
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter> so that
  the developer of a policy does not have to provide it her/himself.
  
  The parser provided by this behavior allows underscores ("_") in input
  values as in a Perl numeric literal.
  
  NOTE: Do not instantiate this class.  Use the singleton instance held
  onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<initialize_parameter( $parameter, $specification )>
  
  Plug in the functionality this behavior provides into the parameter,
  based upon the configuration provided by the specification.
  
  This behavior looks for two configuration items:
  
  =over
  
  =item integer_minimum
  
  Optional.  The minimum acceptable value.  Inclusive.
  
  
  =item integer_maximum
  
  Optional.  The maximum acceptable value.  Inclusive.
  
  
  =back
  
  
  =item C<generate_parameter_description( $parameter )>
  
  Create a description of the parameter, based upon the description on
  the parameter itself, but enhancing it with information from this
  behavior.
  
  In this case, this means including the minimum and maximum values.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_INTEGER

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRING';
  package Perl::Critic::PolicyParameter::Behavior::String;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Perl::Critic::Utils;
  
  use base qw{ Perl::Critic::PolicyParameter::Behavior };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub _parse {
      my ($policy, $parameter, $config_string) = @_;
  
      my $value = $parameter->get_default_string();
  
      if ( defined $config_string ) {
          $value = $config_string;
      }
  
      $policy->__set_parameter_value($parameter, $value);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub initialize_parameter {
      my ($self, $parameter, $specification) = @_;
  
      $parameter->_set_parser(\&_parse);
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter::Behavior::String - Actions appropriate for a simple string parameter.
  
  
  =head1 DESCRIPTION
  
  Provides a standard set of functionality for a string
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter> so that
  the developer of a policy does not have to provide it her/himself.
  
  NOTE: Do not instantiate this class.  Use the singleton instance held
  onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<initialize_parameter( $parameter, $specification )>
  
  Plug in the functionality this behavior provides into the parameter.
  At present, this behavior isn't customizable by the specification.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRING

$fatpacked{"Perl/Critic/PolicyParameter/Behavior/StringList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRINGLIST';
  package Perl::Critic::PolicyParameter::Behavior::StringList;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Perl::Critic::Utils qw{ :characters &words_from_string &hashify };
  
  use base qw{ Perl::Critic::PolicyParameter::Behavior };
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub initialize_parameter {
      my ($self, $parameter, $specification) = @_;
  
      # Unfortunately, this has to be kept as a reference, rather than a regular
      # array, due to a problem in Devel::Cycle
      # (http://rt.cpan.org/Ticket/Display.html?id=25360) which causes
      # t/92_memory_leaks.t to fall over.
      my $always_present_values = $specification->{list_always_present_values};
      $parameter->_get_behavior_values()->{always_present_values} =
          $always_present_values;
  
      if ( not $always_present_values ) {
          $always_present_values = [];
      }
  
      $parameter->_set_parser(
          sub {
              # Normally bad thing, obscuring a variable in a outer scope
              # with a variable with the same name is being done here in
              # order to remain consistent with the parser function interface.
              my ($policy, $parameter, $config_string) = @_;  ## no critic(Variables::ProhibitReusedNames)
  
              my @values = @{$always_present_values};
              my $value_string = $parameter->get_default_string();
  
              if (defined $config_string) {
                  $value_string = $config_string;
              }
  
              if ( defined $value_string ) {
                  push @values, words_from_string($value_string);
              }
  
              my %values = hashify(@values);
  
              $policy->__set_parameter_value($parameter, \%values);
  
              return;
          }
      );
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub generate_parameter_description {
      my ($self, $parameter) = @_;
  
      my $always_present_values =
          $parameter->_get_behavior_values()->{always_present_values};
  
      my $description = $parameter->_get_description_with_trailing_period();
      if ( $description and $always_present_values ) {
          $description .= qq{\n};
      }
  
      if ( $always_present_values ) {
          $description .= 'Values that are always included: ';
          $description .= join ', ', sort @{ $always_present_values };
          $description .= $PERIOD;
      }
  
      return $description;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::PolicyParameter::Behavior::StringList - Actions appropriate for a parameter that is a list of strings.
  
  
  =head1 DESCRIPTION
  
  Provides a standard set of functionality for a string list
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter> so that
  the developer of a policy does not have to provide it her/himself.
  
  NOTE: Do not instantiate this class.  Use the singleton instance held
  onto by
  L<Perl::Critic::PolicyParameter|Perl::Critic::PolicyParameter>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<initialize_parameter( $parameter, $specification )>
  
  Plug in the functionality this behavior provides into the parameter,
  based upon the configuration provided by the specification.
  
  This behavior looks for one configuration item:
  
  =over
  
  =item always_present_values
  
  Optional.  Values that should always be included, regardless of what
  the configuration of the parameter specifies, as an array reference.
  
  =back
  
  =item C<generate_parameter_description( $parameter )>
  
  Create a description of the parameter, based upon the description on
  the parameter itself, but enhancing it with information from this
  behavior.
  
  In this specific case, the always present values are added at the end.
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_POLICYPARAMETER_BEHAVIOR_STRINGLIST

$fatpacked{"Perl/Critic/ProfilePrototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_PROFILEPROTOTYPE';
  package Perl::Critic::ProfilePrototype;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  
  use Perl::Critic::Config qw{};
  use Perl::Critic::Policy qw{};
  use Perl::Critic::Utils qw{ :characters };
  use overload ( q{""} => 'to_string' );
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {}, $class;
  
      my $policies = $args{-policies} || [];
      $self->{_policies} = [ sort _by_type @{ $policies } ];
  
      my $comment_out_parameters = $args{'-comment-out-parameters'};
      if (not defined $comment_out_parameters) {
          $comment_out_parameters = 1;
      }
      $self->{_comment_out_parameters} = $comment_out_parameters;
  
      my $configuration = $args{'-config'};
      if (not $configuration) {
          $configuration = Perl::Critic::Config->new(-profile => $EMPTY);
      }
      $self->{_configuration} = $configuration;
  
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_policies {
      my ($self) = @_;
  
      return $self->{_policies};
  }
  
  sub _comment_out_parameters {
      my ($self) = @_;
  
      return $self->{_comment_out_parameters};
  }
  
  sub _configuration {
      my ($self) = @_;
  
      return $self->{_configuration};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _line_prefix {
      my ($self) = @_;
  
      return $self->_comment_out_parameters() ? q{# } : $EMPTY;
  }
  
  #-----------------------------------------------------------------------------
  
  sub to_string {
      my ($self) = @_;
  
      my $prefix = $self->_line_prefix();
      my $configuration = $self->_configuration();
  
      my $prototype = "# Globals\n";
  
      $prototype .= $prefix;
      $prototype .= q{severity = };
      $prototype .= $configuration->severity();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{force = };
      $prototype .= $configuration->force();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{only = };
      $prototype .= $configuration->only();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{allow-unsafe = };
      $prototype .= $configuration->unsafe_allowed();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{profile-strictness = };
      $prototype .= $configuration->profile_strictness();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{color = };
      $prototype .= $configuration->color();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{pager = };
      $prototype .= $configuration->pager();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{top = };
      $prototype .= $configuration->top();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{verbose = };
      $prototype .= $configuration->verbose();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{include = };
      $prototype .= join $SPACE, $configuration->include();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{exclude = };
      $prototype .= join $SPACE, $configuration->exclude();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{single-policy = };
      $prototype .= join $SPACE, $configuration->single_policy();
      $prototype .= "\n";
  
      $prototype .= $prefix;
      $prototype .= q{theme = };
      $prototype .= $configuration->theme()->rule();
      $prototype .= "\n";
  
      foreach my $item (qw<
          color-severity-highest
          color-severity-high
          color-severity-medium
          color-severity-low
          color-severity-lowest
          >) {
          ( my $accessor = $item ) =~ s/ - /_/gmsx;
          $prototype .= $prefix;
          $prototype .= "$item = ";
          $prototype .= $configuration->$accessor;
          $prototype .= "\n";
      }
  
      $prototype .= $prefix;
      $prototype .= q{program-extensions = };
      $prototype .= join $SPACE, $configuration->program_extensions();
  
      Perl::Critic::Policy::set_format( $self->_proto_format() );
  
      my $policy_prototypes = join qq{\n}, map { "$_" } @{ $self->_get_policies() };
      $policy_prototypes =~ s/\s+ \z//xms; # Trim trailing whitespace
      return $prototype . "\n\n" . $policy_prototypes . "\n";
  }
  
  #-----------------------------------------------------------------------------
  
  # About "%{\\n%\\x7b# \\x7df\n${prefix}%n = %D\\n}O" below:
  #
  # The %0 format for a policy specifies how to format parameters.
  # For a parameter %f specifies the full description.
  #
  # The problem is that both of these need to take options, but String::Format
  # doesn't allow nesting of {}.  So, to get the option to the %f, the braces
  # are hex encoded.  I.e., assuming that comment_out_parameters is in effect,
  # the parameter sees:
  #
  #    \n%{# }f\n# %n = %D\n
  
  sub _proto_format {
      my ($self) = @_;
  
      my $prefix = $self->_line_prefix();
  
      return <<"END_OF_FORMAT";
  # %a
  [%p]
  ${prefix}set_themes                         = %t
  ${prefix}add_themes                         =
  ${prefix}severity                           = %s
  ${prefix}maximum_violations_per_document    = %v
  %{\\n%\\x7b# \\x7df\\n${prefix}%n = %D\\n}O%{${prefix}Cannot programmatically discover what parameters this policy takes.\\n}U
  END_OF_FORMAT
  
  }
  
  #-----------------------------------------------------------------------------
  
  sub _by_type { return ref $a cmp ref $b }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::ProfilePrototype - Generate an initial Perl::Critic profile.
  
  
  =head1 DESCRIPTION
  
  This is a helper class that generates a prototype of a
  L<Perl::Critic|Perl::Critic> profile (e.g. a F<.perlcriticrc> file.
  There are no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new( -policies => \@POLICY_OBJECTS ) >>
  
  Returns a reference to a new C<Perl::Critic::ProfilePrototype> object.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item to_string()
  
  Returns a string representation of this C<ProfilePrototype>.  See
  L<"OVERLOADS"> for more information.
  
  
  =back
  
  
  =head1 OVERLOADS
  
  When a
  L<Perl::Critic::ProfilePrototype|Perl::Critic::ProfilePrototype> is
  evaluated in string context, it produces a multi-line summary of the
  policy name, default themes, and default severity for each
  L<Perl::Critic::Policy|Perl::Critic::Policy> object that was given to
  the constructor of this C<ProfilePrototype>.  If the Policy supports
  an additional parameters, they will also be listed (but
  commented-out).  The format is suitable for use as a F<.perlcriticrc>
  file.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_PROFILEPROTOTYPE

$fatpacked{"Perl/Critic/Statistics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_STATISTICS';
  package Perl::Critic::Statistics;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  
  use Perl::Critic::Utils::McCabe qw{ calculate_mccabe_of_sub };
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ( $class ) = @_;
  
      my $self = bless {}, $class;
  
      $self->{_modules} = 0;
      $self->{_subs} = 0;
      $self->{_statements} = 0;
      $self->{_lines} = 0;
      $self->{_lines_of_blank} = 0;
      $self->{_lines_of_comment} = 0;
      $self->{_lines_of_data} = 0;
      $self->{_lines_of_perl} = 0;
      $self->{_lines_of_pod} = 0;
      $self->{_violations_by_policy} = {};
      $self->{_violations_by_severity} = {};
      $self->{_total_violations} = 0;
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub accumulate {
      my ($self, $doc, $violations) = @_;
  
      $self->{_modules}++;
  
      my $subs = $doc->find('PPI::Statement::Sub');
      if ($subs) {
          foreach my $sub ( @{$subs} ) {
              $self->{_subs}++;
              $self->{_subs_total_mccabe} += calculate_mccabe_of_sub( $sub );
          }
      }
  
      my $statements = $doc->find('PPI::Statement');
      $self->{_statements} += $statements ? scalar @{$statements} : 0;
  
      ## no critic (RequireDotMatchAnything, RequireExtendedFormatting, RequireLineBoundaryMatching)
      my @lines = split /$INPUT_RECORD_SEPARATOR/, $doc->serialize();
      ## use critic
      $self->{_lines} += scalar @lines;
      {
          my ( $in_data, $in_pod );
          foreach ( @lines ) {
              if ( q{=} eq substr $_, 0, 1 ) {    ## no critic (ProhibitCascadingIfElse)
                  $in_pod = not m/ \A \s* =cut \b /smx;
                  $self->{_lines_of_pod}++;
              } elsif ( $in_pod ) {
                  $self->{_lines_of_pod}++;
              } elsif ( q{__END__} eq $_ || q{__DATA__} eq $_ ) {
                  $in_data = 1;
                  $self->{_lines_of_perl}++;
              } elsif ( $in_data ) {
                  $self->{_lines_of_data}++;
              } elsif ( m/ \A \s* \# /smx ) {
                  $self->{_lines_of_comment}++;
              } elsif ( m/ \A \s* \z /smx ) {
                  $self->{_lines_of_blank}++;
              } else {
                  $self->{_lines_of_perl}++;
              }
          }
      }
  
      foreach my $violation ( @{ $violations } ) {
          $self->{_violations_by_severity}->{ $violation->severity() }++;
          $self->{_violations_by_policy}->{ $violation->policy() }++;
          $self->{_total_violations}++;
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub modules {
      my ( $self ) = @_;
  
      return $self->{_modules};
  }
  
  #-----------------------------------------------------------------------------
  
  sub subs {
      my ( $self ) = @_;
  
      return $self->{_subs};
  }
  
  #-----------------------------------------------------------------------------
  
  sub statements {
      my ( $self ) = @_;
  
      return $self->{_statements};
  }
  
  #-----------------------------------------------------------------------------
  
  sub lines {
      my ( $self ) = @_;
  
      return $self->{_lines};
  }
  
  #-----------------------------------------------------------------------------
  
  sub lines_of_blank {
      my ( $self ) = @_;
  
      return $self->{_lines_of_blank};
  }
  
  #-----------------------------------------------------------------------------
  
  sub lines_of_comment {
      my ( $self ) = @_;
  
      return $self->{_lines_of_comment};
  }
  
  #-----------------------------------------------------------------------------
  
  sub lines_of_data {
      my ( $self ) = @_;
  
      return $self->{_lines_of_data};
  }
  
  #-----------------------------------------------------------------------------
  
  sub lines_of_perl {
      my ( $self ) = @_;
  
      return $self->{_lines_of_perl};
  }
  
  #-----------------------------------------------------------------------------
  
  sub lines_of_pod {
      my ( $self ) = @_;
  
      return $self->{_lines_of_pod};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _subs_total_mccabe {
      my ( $self ) = @_;
  
      return $self->{_subs_total_mccabe};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violations_by_severity {
      my ( $self ) = @_;
  
      return $self->{_violations_by_severity};
  }
  
  #-----------------------------------------------------------------------------
  
  sub violations_by_policy {
      my ( $self ) = @_;
  
      return $self->{_violations_by_policy};
  }
  
  #-----------------------------------------------------------------------------
  
  sub total_violations {
      my ( $self ) = @_;
  
      return $self->{_total_violations};
  }
  
  #-----------------------------------------------------------------------------
  
  sub statements_other_than_subs {
      my ( $self ) = @_;
  
      return $self->statements() - $self->subs();
  }
  
  #-----------------------------------------------------------------------------
  
  sub average_sub_mccabe {
      my ( $self ) = @_;
  
      return if $self->subs() == 0;
  
      return $self->_subs_total_mccabe() / $self->subs();
  }
  
  #-----------------------------------------------------------------------------
  
  sub violations_per_file {
      my ( $self ) = @_;
  
      return if $self->modules() == 0;
  
      return $self->total_violations() / $self->modules();
  }
  
  #-----------------------------------------------------------------------------
  
  sub violations_per_statement {
      my ( $self ) = @_;
  
      my $statements = $self->statements_other_than_subs();
  
      return if $statements == 0;
  
      return $self->total_violations() / $statements;
  }
  
  #-----------------------------------------------------------------------------
  
  sub violations_per_line_of_code {
      my ( $self ) = @_;
  
      return if $self->lines() == 0;
  
      return $self->total_violations() / $self->lines();
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords McCabe
  
  =head1 NAME
  
  Perl::Critic::Statistics - Compile stats on Perl::Critic violations.
  
  
  =head1 DESCRIPTION
  
  This class accumulates statistics on Perl::Critic violations across one or
  more files.  NOTE: This class is experimental and subject to change.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<new()>
  
  Create a new instance of Perl::Critic::Statistics.  No arguments are supported
  at this time.
  
  
  =item C< accumulate( $doc, \@violations ) >
  
  Accumulates statistics about the C<$doc> and the C<@violations> that were
  found.
  
  
  =item C<modules()>
  
  The number of chunks of code (usually files) that have been analyzed.
  
  
  =item C<subs()>
  
  The total number of subroutines analyzed by this Critic.
  
  
  =item C<statements()>
  
  The total number of statements analyzed by this Critic.
  
  
  =item C<lines()>
  
  The total number of lines of code analyzed by this Critic.
  
  
  =item C<lines_of_blank()>
  
  The total number of blank lines analyzed by this Critic. This includes only
  blank lines in code, not POD or data.
  
  
  =item C<lines_of_comment()>
  
  The total number of comment lines analyzed by this Critic. This includes only
  lines whose first non-whitespace character is C<#>.
  
  
  =item C<lines_of_data()>
  
  The total number of lines of data section analyzed by this Critic, not
  counting the C<__END__> or C<__DATA__> line. POD in a data section is counted
  as POD, not data.
  
  
  =item C<lines_of_perl()>
  
  The total number of lines of Perl code analyzed by this Critic. Perl appearing
  in the data section is not counted.
  
  
  =item C<lines_of_pod()>
  
  The total number of lines of POD analyzed by this Critic. Pod occurring in a
  data section is counted as POD, not as data.
  
  
  =item C<violations_by_severity()>
  
  The number of violations of each severity found by this Critic as a
  reference to a hash keyed by severity.
  
  
  =item C<violations_by_policy()>
  
  The number of violations of each policy found by this Critic as a
  reference to a hash keyed by full policy name.
  
  
  =item C<total_violations()>
  
  The total number of violations found by this Critic.
  
  
  =item C<statements_other_than_subs()>
  
  The total number of statements minus the number of subroutines.
  Useful because a subroutine is considered a statement by PPI.
  
  
  =item C<average_sub_mccabe()>
  
  The average McCabe score of all scanned subroutines.
  
  
  =item C<violations_per_file()>
  
  The total violations divided by the number of modules.
  
  
  =item C<violations_per_statement()>
  
  The total violations divided by the number statements minus
  subroutines.
  
  
  =item C<violations_per_line_of_code()>
  
  The total violations divided by the lines of code.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank C<< <perl@galumph.com> >>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_STATISTICS

$fatpacked{"Perl/Critic/TestUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_TESTUTILS';
  package Perl::Critic::TestUtils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use Exporter 'import';
  
  use File::Path ();
  use File::Spec ();
  use File::Spec::Unix ();
  use File::Temp ();
  use File::Find qw( find );
  
  use Perl::Critic;
  use Perl::Critic::Config;
  use Perl::Critic::Exception::Fatal::Generic qw{ &throw_generic };
  use Perl::Critic::Exception::Fatal::Internal qw{ &throw_internal };
  use Perl::Critic::Utils qw{ :severities :data_conversion policy_long_name };
  use Perl::Critic::PolicyFactory (-test => 1);
  
  our $VERSION = '1.132';
  
  Readonly::Array our @EXPORT_OK => qw(
      pcritique pcritique_with_violations
      critique  critique_with_violations
      fcritique fcritique_with_violations
      subtests_in_tree
      should_skip_author_tests
      get_author_test_skip_message
      starting_points_including_examples
      bundled_policy_names
      names_of_policies_willing_to_work
  );
  
  sub assert_version {
      my $expected_version = shift;
  
      if ( $expected_version ne $Perl::Critic::VERSION ) {
          require Carp;
          Carp::confess( "Expected Perl::Critic $expected_version but it is actually $Perl::Critic::VERSION" );
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  # If the user already has an existing perlcriticrc file, it will get
  # in the way of these test.  This little tweak to ensures that we
  # don't find the perlcriticrc file.
  
  sub block_perlcriticrc {
      no warnings 'redefine';  ## no critic (ProhibitNoWarnings);
      *Perl::Critic::UserProfile::_find_profile_path = sub { return }; ## no critic (ProtectPrivateVars)
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  # Criticize a code snippet using only one policy.  Returns the violations.
  
  sub pcritique_with_violations {
      my($policy, $code_ref, $config_ref) = @_;
      my $c = Perl::Critic->new( -profile => 'NONE' );
      $c->add_policy(-policy => $policy, -config => $config_ref);
      return $c->critique($code_ref);
  }
  
  #-----------------------------------------------------------------------------
  # Criticize a code snippet using only one policy.  Returns the number
  # of violations
  
  sub pcritique {  ##no critic(ArgUnpacking)
      return scalar pcritique_with_violations(@_);
  }
  
  #-----------------------------------------------------------------------------
  # Criticize a code snippet using a specified config.  Returns the violations.
  
  sub critique_with_violations {
      my ($code_ref, $config_ref) = @_;
      my $c = Perl::Critic->new( %{$config_ref} );
      return $c->critique($code_ref);
  }
  
  #-----------------------------------------------------------------------------
  # Criticize a code snippet using a specified config.  Returns the
  # number of violations
  
  sub critique {  ##no critic(ArgUnpacking)
      return scalar critique_with_violations(@_);
  }
  
  #-----------------------------------------------------------------------------
  # Like pcritique_with_violations, but forces a PPI::Document::File context.
  # The $filename arg is a Unix-style relative path, like 'Foo/Bar.pm'
  
  Readonly::Scalar my $TEMP_FILE_PERMISSIONS => oct 700;
  
  sub fcritique_with_violations {
      my($policy, $code_ref, $filename, $config_ref) = @_;
      my $c = Perl::Critic->new( -profile => 'NONE' );
      $c->add_policy(-policy => $policy, -config => $config_ref);
  
      my $dir = File::Temp::tempdir( 'PerlCritic-tmpXXXXXX', TMPDIR => 1 );
      $filename ||= 'Temp.pm';
      my @fileparts = File::Spec::Unix->splitdir($filename);
      if (@fileparts > 1) {
          my $subdir = File::Spec->catdir($dir, @fileparts[0..$#fileparts-1]);
          File::Path::mkpath($subdir, 0, $TEMP_FILE_PERMISSIONS);
      }
      my $file = File::Spec->catfile($dir, @fileparts);
      if (open my $fh, '>', $file) {
          print {$fh} ${$code_ref};
          close $fh or throw_generic "unable to close $file: $OS_ERROR";
      }
  
      # Use eval so we can clean up before throwing an exception in case of
      # error.
      my @v = eval {$c->critique($file)};
      my $err = $EVAL_ERROR;
      File::Path::rmtree($dir, 0, 1);
      if ($err) {
          throw_generic $err;
      }
      return @v;
  }
  
  #-----------------------------------------------------------------------------
  # Like pcritique, but forces a PPI::Document::File context.  The
  # $filename arg is a Unix-style relative path, like 'Foo/Bar.pm'
  
  sub fcritique {  ##no critic(ArgUnpacking)
      return scalar fcritique_with_violations(@_);
  }
  
  # Note: $include_extras is not documented in the POD because I'm not
  # committing to the interface yet.
  sub subtests_in_tree {
      my ($start, $include_extras) = @_;
  
      my %subtests;
  
      find(
          {
              wanted => sub {
                  return if not -f;
  
                  my ($fileroot) = m{(.+)[.]run\z}xms;
  
                  return if not $fileroot;
  
                  my @pathparts = File::Spec->splitdir($fileroot);
                  if (@pathparts < 2) {
                      throw_internal 'confusing policy test filename ' . $_;
                  }
  
                  my $policy = join q{::}, @pathparts[-2, -1]; ## no critic (MagicNumbers)
  
                  my $globals = _globals_from_file( $_ );
                  if ( my $prerequisites = $globals->{prerequisites} ) {
                      foreach my $prerequisite ( keys %{$prerequisites} ) {
                          eval "require $prerequisite; 1" or return;
                      }
                  }
  
                  my @subtests = _subtests_from_file( $_ );
  
                  if ($include_extras) {
                      $subtests{$policy} =
                          { subtests => [ @subtests ], globals => $globals };
                  }
                  else {
                      $subtests{$policy} = [ @subtests ];
                  }
  
                  return;
              },
              no_chdir => 1,
          },
          $start
      );
  
      return \%subtests;
  }
  
  # Answer whether author test should be run.
  #
  # Note: this code is duplicated in
  # t/tlib/Perl/Critic/TestUtilitiesWithMinimalDependencies.pm.
  # If you change this here, make sure to change it there.
  
  sub should_skip_author_tests {
      return not $ENV{TEST_AUTHOR_PERL_CRITIC}
  }
  
  sub get_author_test_skip_message {
      ## no critic (RequireInterpolation);
      return 'Author test.  Set $ENV{TEST_AUTHOR_PERL_CRITIC} to a true value to run.';
  }
  
  
  sub starting_points_including_examples {
      return (-e 'blib' ? 'blib' : 'lib', 'examples');
  }
  
  sub _globals_from_file {
      my $test_file = shift;
  
      my %valid_keys = hashify qw< prerequisites >;
  
      return if -z $test_file;  # Skip if the Policy has a regular .t file.
  
      my %globals;
  
      open my $handle, '<', $test_file   ## no critic (RequireBriefOpen)
          or throw_internal "Couldn't open $test_file: $OS_ERROR";
  
      while ( my $line = <$handle> ) {
          chomp;
  
          if (
              my ($key,$value) =
                  $line =~ m<\A [#][#] [ ] global [ ] (\S+) (?:\s+(.+))? >xms
          ) {
              next if not $key;
              if ( not $valid_keys{$key} ) {
                  throw_internal "Unknown global key $key in $test_file";
              }
  
              if ( $key eq 'prerequisites' ) {
                  $value = { hashify( words_from_string($value) ) };
              }
              $globals{$key} = $value;
          }
      }
      close $handle or throw_generic "unable to close $test_file: $OS_ERROR";
  
      return \%globals;
  }
  
  # The internal representation of a subtest is just a hash with some
  # named keys.  It could be an object with accessors for safety's sake,
  # but at this point I don't see why.
  sub _subtests_from_file {
      my $test_file = shift;
  
      my %valid_keys = hashify qw( name failures parms TODO error filename optional_modules );
  
      return if -z $test_file;  # Skip if the Policy has a regular .t file.
  
      open my $fh, '<', $test_file   ## no critic (RequireBriefOpen)
          or throw_internal "Couldn't open $test_file: $OS_ERROR";
  
      my @subtests;
  
      my $incode = 0;
      my $cut_in_code = 0;
      my $subtest;
      my $lineno;
      while ( <$fh> ) {
          ++$lineno;
          chomp;
          my $inheader = /^## name/ .. /^## cut/; ## no critic (ExtendedFormatting LineBoundaryMatching DotMatchAnything)
  
          my $line = $_;
  
          if ( $inheader ) {
              $line =~ m/\A [#]/xms or throw_internal "Code before cut: $test_file";
              my ($key,$value) = $line =~ m/\A [#][#] [ ] (\S+) (?:\s+(.+))? /xms;
              next if !$key;
              next if $key eq 'cut';
              if ( not $valid_keys{$key} ) {
                  throw_internal "Unknown key $key in $test_file";
              }
  
              if ( $key eq 'name' ) {
                  if ( $subtest ) { # Stash any current subtest
                      push @subtests, _finalize_subtest( $subtest );
                      undef $subtest;
                  }
                  $subtest->{lineno} = $lineno;
                  $incode = 0;
                  $cut_in_code = 0;
              }
              if ($incode) {
                  throw_internal "Header line found while still in code: $test_file";
              }
              $subtest->{$key} = $value;
          }
          elsif ( $subtest ) {
              $incode = 1;
              $cut_in_code ||= $line =~ m/ \A [#][#] [ ] cut \z /smx;
              # Don't start a subtest if we're not in one.
              # Don't add to the test if we have seen a '## cut'.
              $cut_in_code or push @{$subtest->{code}}, $line;
          }
          elsif (@subtests) {
              ## don't complain if we have not yet hit the first test
              throw_internal "Got some code but I'm not in a subtest: $test_file";
          }
      }
      close $fh or throw_generic "unable to close $test_file: $OS_ERROR";
      if ( $subtest ) {
          if ( $incode ) {
              push @subtests, _finalize_subtest( $subtest );
          }
          else {
              throw_internal "Incomplete subtest in $test_file";
          }
      }
  
      return @subtests;
  }
  
  sub _finalize_subtest {
      my $subtest = shift;
  
      if ( $subtest->{code} ) {
          $subtest->{code} = join "\n", @{$subtest->{code}};
      }
      else {
          throw_internal "$subtest->{name} has no code lines";
      }
      if ( !defined $subtest->{failures} ) {
          throw_internal "$subtest->{name} does not specify failures";
      }
      if ($subtest->{parms}) {
          $subtest->{parms} = eval $subtest->{parms}; ## no critic(StringyEval)
          if ($EVAL_ERROR) {
              throw_internal
                  "$subtest->{name} has an error in the 'parms' property:\n"
                    . $EVAL_ERROR;
          }
          if ('HASH' ne ref $subtest->{parms}) {
              throw_internal
                  "$subtest->{name} 'parms' did not evaluate to a hashref";
          }
      } else {
          $subtest->{parms} = {};
      }
  
      if (defined $subtest->{error}) {
          if ( $subtest->{error} =~ m{ \A / (.*) / \z }xms) {
              $subtest->{error} = eval {qr/$1/}; ## no critic (ExtendedFormatting LineBoundaryMatching DotMatchAnything)
              if ($EVAL_ERROR) {
                  throw_internal
                      "$subtest->{name} 'error' has a malformed regular expression";
              }
          }
      }
  
      return $subtest;
  }
  
  sub bundled_policy_names {
      require ExtUtils::Manifest;
      my $manifest = ExtUtils::Manifest::maniread();
      my @policy_paths = map {m{\A lib/(Perl/Critic/Policy/.*).pm \z}xms} keys %{$manifest};
      my @policies = map { join q{::}, split m{/}xms } @policy_paths;
      my @sorted_policies = sort @policies;
      return @sorted_policies;
  }
  
  sub names_of_policies_willing_to_work {
      my %configuration = @_;
  
      my @policies_willing_to_work =
          Perl::Critic::Config
              ->new( %configuration )
              ->policies();
  
      return map { ref } @policies_willing_to_work;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords RCS subtest subtests
  
  =head1 NAME
  
  Perl::Critic::TestUtils - Utility functions for testing new Policies.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 SYNOPSIS
  
      use Perl::Critic::TestUtils qw(critique pcritique fcritique);
  
      my $code = '<<END_CODE';
      package Foo::Bar;
      $foo = frobulator();
      $baz = $foo ** 2;
      1;
      END_CODE
  
      # Critique code against all loaded policies...
      my $perl_critic_config = { -severity => 2 };
      my $violation_count = critique( \$code, $perl_critic_config);
  
      # Critique code against one policy...
      my $custom_policy = 'Miscellanea::ProhibitFrobulation'
      my $violation_count = pcritique( $custom_policy, \$code );
  
      # Critique code against one filename-related policy...
      my $custom_policy = 'Modules::RequireFilenameMatchesPackage'
      my $violation_count = fcritique( $custom_policy, \$code, 'Foo/Bar.pm' );
  
  
  =head1 DESCRIPTION
  
  This module is used by L<Perl::Critic|Perl::Critic> only for
  self-testing. It provides a few handy subroutines for testing new
  Perl::Critic::Policy modules.  Look at the test programs that ship with
  Perl::Critic for more examples of how to use these subroutines.
  
  
  =head1 EXPORTS
  
  =over
  
  =item assert_version( $version )
  
  Asserts that the C<$version> passed matches the version of Perl::Critic.
  
  
  =item block_perlcriticrc()
  
  If a user has a F<~/.perlcriticrc> file, this can interfere with
  testing.  This handy method disables the search for that file --
  simply call it at the top of your F<.t> program.  Note that this is
  not easily reversible, but that should not matter.
  
  
  =item critique_with_violations( $code_string_ref, $config_ref )
  
  Test a block of code against the specified Perl::Critic::Config
  instance (or C<undef> for the default).  Returns the violations that
  occurred.
  
  
  =item critique( $code_string_ref, $config_ref )
  
  Test a block of code against the specified Perl::Critic::Config
  instance (or C<undef> for the default).  Returns the number of
  violations that occurred.
  
  
  =item pcritique_with_violations( $policy_name, $code_string_ref, $config_ref )
  
  Like C<critique_with_violations()>, but tests only a single policy
  instead of the whole bunch.
  
  
  =item pcritique( $policy_name, $code_string_ref, $config_ref )
  
  Like C<critique()>, but tests only a single policy instead of the
  whole bunch.
  
  
  =item fcritique_with_violations( $policy_name, $code_string_ref, $filename, $config_ref )
  
  Like C<pcritique_with_violations()>, but pretends that the code was
  loaded from the specified filename.  This is handy for testing
  policies like C<Modules::RequireFilenameMatchesPackage> which care
  about the filename that the source derived from.
  
  The C<$filename> parameter must be a relative path, not absolute.  The
  file and all necessary subdirectories will be created via
  L<File::Temp|File::Temp> and will be automatically deleted.
  
  
  =item fcritique( $policy_name, $code_string_ref, $filename, $config_ref )
  
  Like C<pcritique()>, but pretends that the code was loaded from the
  specified filename.  This is handy for testing policies like
  C<Modules::RequireFilenameMatchesPackage> which care about the
  filename that the source derived from.
  
  The C<$filename> parameter must be a relative path, not absolute.  The
  file and all necessary subdirectories will be created via
  L<File::Temp|File::Temp> and will be automatically deleted.
  
  
  =item subtests_in_tree( $dir )
  
  Searches the specified directory recursively for F<.run> files.  Each
  one found is parsed and a hash-of-list-of-hashes is returned.  The
  outer hash is keyed on policy short name, like
  C<Modules::RequireEndWithOne>.  The inner hash specifies a single test
  to be handed to C<pcritique()> or C<fcritique()>, including the code
  string, test name, etc.  See below for the syntax of the F<.run>
  files.
  
  
  =item should_skip_author_tests()
  
  Answers whether author tests should run.
  
  
  =item get_author_test_skip_message()
  
  Returns a string containing the message that should be emitted when a
  test is skipped due to it being an author test when author tests are
  not enabled.
  
  
  =item starting_points_including_examples()
  
  Returns a list of the directories contain code that needs to be tested
  when it is desired that the examples be included.
  
  
  =item bundled_policy_names()
  
  Returns a list of Policy packages that come bundled with this package.
  This functions by searching F<MANIFEST> for
  F<lib/Perl/Critic/Policy/*.pm> and converts the results to package
  names.
  
  
  =item names_of_policies_willing_to_work( %configuration )
  
  Returns a list of the packages of policies that are willing to
  function on the current system using the specified configuration.
  
  
  =back
  
  
  =head1 F<.run> file information
  
  Testing a policy follows a very simple pattern:
  
      * Policy name
          * Subtest name
          * Optional parameters
          * Number of failures expected
          * Optional exception expected
          * Optional filename for code
  
  Each of the subtests for a policy is collected in a single F<.run>
  file, with test properties as comments in front of each code block
  that describes how we expect Perl::Critic to react to the code.  For
  example, say you have a policy called Variables::ProhibitVowels:
  
      (In file t/Variables/ProhibitVowels.run)
  
      ## name Basics
      ## failures 1
      ## cut
  
      my $vrbl_nm = 'foo';    # Good, vowel-free name
      my $wango = 12;         # Bad, pronouncable name
  
  
      ## name Sometimes Y
      ## failures 1
      ## cut
  
      my $yllw = 0;       # "y" not a vowel here
      my $rhythm = 12;    # But here it is
  
  These are called "subtests", and two are shown above.  The beauty of
  incorporating multiple subtests in a file is that the F<.run> is
  itself a (mostly) valid Perl file, and not hidden in a HEREDOC, so
  your editor's color-coding still works, and it is much easier to work
  with the code and the POD.
  
  If you need to pass any configuration parameters for your subtest, do
  so like this:
  
      ## parms { allow_y => '0' }
  
  Note that all the values in this hash must be strings because that's
  what Perl::Critic will hand you from a F<.perlcriticrc>.
  
  If it's a TODO subtest (probably because of some weird corner of PPI
  that we exercised that Adam is getting around to fixing, right?), then
  make a C<##TODO> entry.
  
      ## TODO Should pass when PPI 1.xxx comes out
  
  If the code is expected to trigger an exception in the policy,
  indicate that like so:
  
      ## error 1
  
  If you want to test the error message, mark it with C</.../> to
  indicate a C<like()> test:
  
      ## error /Can't load Foo::Bar/
  
  If the policy you are testing cares about the filename of the code,
  you can indicate that C<fcritique> should be used like so (see
  C<fcritique> for more details):
  
      ## filename lib/Foo/Bar.pm
  
  The value of C<parms> will get C<eval>ed and passed to C<pcritique()>,
  so be careful.
  
  In general, a subtest document runs from the C<## cut> that starts it to
  either the next C<## name> or the end of the file. In very rare circumstances
  you may need to end the test document earlier. A second C<## cut> will do
  this. The only known need for this is in
  F<t/Miscellanea/RequireRcsKeywords.run>, where it is used to prevent the RCS
  keywords in the file footer from producing false positives or negatives in the
  last test.
  
  Note that nowhere within the F<.run> file itself do you specify the
  policy that you're testing.  That's implicit within the filename.
  
  
  =head1 BUGS AND CAVEATS AND TODO ITEMS
  
  Test that we have a t/*/*.run for each lib/*/*.pm
  
  Allow us to specify the nature of the failures, and which one.  If
  there are 15 lines of code, and six of them fail, how do we know
  they're the right six?
  
  
  =head1 AUTHOR
  
  Chris Dolan <cdolan@cpan.org>
  and the rest of the L<Perl::Critic|Perl::Critic> team.
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Chris Dolan.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_TESTUTILS

$fatpacked{"Perl/Critic/Theme.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_THEME';
  package Perl::Critic::Theme;
  
  use 5.006001;
  use strict;
  use warnings;
  use English qw(-no_match_vars);
  use Readonly;
  
  use Exporter 'import';
  
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Utils qw{ :characters :data_conversion };
  use Perl::Critic::Exception::Fatal::Internal qw{ &throw_internal };
  use Perl::Critic::Exception::Configuration::Option::Global::ParameterValue
      qw{ &throw_global_value };
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw{
      $RULE_INVALID_CHARACTER_REGEX
      cook_rule
  };
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar our $RULE_INVALID_CHARACTER_REGEX =>
      qr/ ( [^()\s\w\d+\-*&|!] ) /xms;
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $CONFIG_KEY => 'theme';
  
  #-----------------------------------------------------------------------------
  
  sub new {
  
      my ( $class, %args ) = @_;
      my $self = bless {}, $class;
      $self->_init( %args );
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init {
  
      my ($self, %args) = @_;
      my $rule = $args{-rule} || $EMPTY;
  
      if ( $rule =~ m/$RULE_INVALID_CHARACTER_REGEX/xms ) {
          throw_global_value
              option_name     => $CONFIG_KEY,
              option_value    => $rule,
              message_suffix => qq{contains an invalid character: "$1".};
      }
  
      $self->{_rule} = cook_rule( $rule );
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub rule {
      my $self = shift;
      return $self->{_rule};
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy_is_thematic {
  
      my ($self, %args) = @_;
      my $policy = $args{-policy}
          || throw_internal 'The -policy argument is required';
      ref $policy
          || throw_internal 'The -policy must be an object';
  
      my $rule = $self->{_rule} or return 1;
      my %themes = hashify( $policy->get_themes() );
  
      # This bit of magic turns the rule into a perl expression that can be
      # eval-ed for truth.  Each theme name in the rule is translated to 1 or 0
      # if the $policy belongs in that theme.  For example:
      #
      # 'bugs && (pbp || core)'  ...could become... '1 && (0 || 1)'
  
      my $as_code = $rule; #Making a copy, so $rule is preserved
      $as_code =~ s/ ( [\w\d]+ ) /exists $themes{$1} || 0/gexms;
      my $is_thematic = eval $as_code;  ## no critic (ProhibitStringyEval)
  
      if ($EVAL_ERROR) {
          throw_global_value
              option_name     => $CONFIG_KEY,
              option_value    => $rule,
              message_suffix  => q{contains a syntax error.};
      }
  
      return $is_thematic;
  }
  
  #-----------------------------------------------------------------------------
  
  sub cook_rule {
      my ($raw_rule) = @_;
      return if not defined $raw_rule;
  
      #Translate logical operators
      $raw_rule =~ s{\b not \b}{!}ixmsg;     # "not" -> "!"
      $raw_rule =~ s{\b and \b}{&&}ixmsg;    # "and" -> "&&"
      $raw_rule =~ s{\b or  \b}{||}ixmsg;    # "or"  -> "||"
  
      #Translate algebra operators (for backward compatibility)
      $raw_rule =~ s{\A [-] }{!}ixmsg;     # "-" -> "!"     e.g. difference
      $raw_rule =~ s{   [-] }{&& !}ixmsg;  # "-" -> "&& !"  e.g. difference
      $raw_rule =~ s{   [*] }{&&}ixmsg;    # "*" -> "&&"    e.g. intersection
      $raw_rule =~ s{   [+] }{||}ixmsg;    # "+" -> "||"    e.g. union
  
      my $cooked_rule = lc $raw_rule;  #Is now cooked!
      return $cooked_rule;
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Theme - Construct thematic sets of policies.
  
  
  =head1 DESCRIPTION
  
  This is a helper class for evaluating theme expressions into sets of
  Policy objects.  There are no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<< new( -rule => $rule_expression ) >>
  
  Returns a reference to a new Perl::Critic::Theme object.  C<-rule> is
  a string expression that evaluates to true or false for each Policy..
  See L<"THEME RULES"> for more information.
  
  
  =item C<< policy_is_thematic( -policy => $policy ) >>
  
  Given a reference to a L<Perl::Critic::Policy|Perl::Critic::Policy>
  object, this method returns evaluates the rule against the themes that
  are associated with the Policy.  Returns 1 if the Policy satisfies the
  rule, 0 otherwise.
  
  
  =item C< rule() >
  
  Returns the rule expression that was used to construct this Theme.
  The rule may have been translated into a normalized expression.  See
  L<"THEME RULES"> for more information.
  
  =back
  
  
  =head2 THEME RULES
  
  A theme rule is a simple boolean expression, where the operands are
  the names of any of the themes associated with the
  Perl::Critic::Polices.
  
  Theme names can be combined with logical operators to form arbitrarily
  complex expressions.  Precedence is the same as normal mathematics,
  but you can use parentheses to enforce precedence as well.  Supported
  operators are:
  
     Operator    Altertative    Example
     ----------------------------------------------------------------
     &&          and            'pbp && core'
     ||          or             'pbp || (bugs && security)'
     !           not            'pbp && ! (portability || complexity)
  
  See L<Perl::Critic/"CONFIGURATION"> for more information about
  customizing the themes for each Policy.
  
  
  =head1 SUBROUTINES
  
  =over
  
  =item C<cook_rule( $rule )>
  
  Standardize a rule into a almost executable Perl code.  The "almost"
  comes from the fact that theme names are left as is.
  
  
  =back
  
  
  =head1 CONSTANTS
  
  =over
  
  =item C<$RULE_INVALID_CHARACTER_REGEX>
  
  A regular expression that will return the first character in the
  matched expression that is not valid in a rule.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer  <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006-2011 Imaginative Software Systems
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_THEME

$fatpacked{"Perl/Critic/ThemeListing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_THEMELISTING';
  package Perl::Critic::ThemeListing;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw<-no_match_vars>;
  
  use Perl::Critic::Utils qw< hashify >;
  
  use overload ( q<""> => 'to_string' );
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
      my ($class, %args) = @_;
  
      my $self = bless {}, $class;
  
      $self->{_policies} = $args{-policies} || [];
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub to_string {
      my ($self) = @_;
  
      my %themes;
      foreach my $policy ( @{ $self->{_policies} } ) {
          my @themes = $policy->get_themes();
          @themes{ @themes } = @themes;
      }
  
      return join ("\n", sort keys %themes) . "\n";
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::ThemeListing - List the themes of the installed Policies.
  
  
  =head1 DESCRIPTION
  
  This is a helper class that gathers the themes of the installed
  Policies.  There are no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<< new( -policies => \@POLICY_OBJECTS ) >>
  
  Returns a reference to a new C<Perl::Critic::ThemeListing> object.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  
  =item to_string()
  
  Returns a string representation of this C<ThemeListing>.  See
  L<"OVERLOADS"> for more information.
  
  
  =back
  
  
  =head1 OVERLOADS
  
  
  When a L<Perl::Critic::ThemeListing|Perl::Critic::ThemeListing> is
  evaluated in string context, it produces a one-line summary of the
  default severity, policy name, and default themes for each
  L<Perl::Critic::Policy|Perl::Critic::Policy> object that was given to
  the constructor of this C<ThemeListing>.
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_THEMELISTING

$fatpacked{"Perl/Critic/UserProfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_USERPROFILE';
  package Perl::Critic::UserProfile;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw(-no_match_vars);
  use Readonly;
  
  use Config::Tiny qw();
  use File::Spec qw();
  
  use Perl::Critic::OptionsProcessor qw();
  use Perl::Critic::Utils qw{ $EMPTY policy_long_name policy_short_name };
  use Perl::Critic::Exception::Fatal::Internal qw{ throw_internal };
  use Perl::Critic::Exception::Configuration::Generic qw{ throw_generic };
  use Perl::Critic::PolicyConfig;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub new {
  
      my ( $class, %args ) = @_;
      my $self = bless {}, $class;
      $self->_init( %args );
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _init {
  
      my ( $self, %args ) = @_;
      # The profile can be defined, undefined, or an empty string.
      my $profile = defined $args{-profile} ? $args{-profile} : _find_profile_path();
      $self->_load_profile( $profile );
      $self->_set_options_processor();
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub options_processor {
  
      my ($self) = @_;
      return $self->{_options_processor};
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy_params {
  
      my ( $self, $policy ) = @_;
  
      my $short_name = policy_short_name($policy);
  
      return Perl::Critic::PolicyConfig->new(
          $short_name,
          $self->raw_policy_params($policy),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub raw_policy_params {
  
      my ( $self, $policy ) = @_;
      my $profile = $self->{_profile};
      my $long_name  = ref $policy || policy_long_name( $policy );
      my $short_name = policy_short_name( $long_name );
  
      return
              $profile->{$short_name}
          ||  $profile->{$long_name}
          ||  $profile->{"-$short_name"}
          ||  $profile->{"-$long_name"}
          ||  {};
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy_is_disabled {
  
      my ( $self, $policy ) = @_;
      my $profile = $self->{_profile};
      my $long_name  = ref $policy || policy_long_name( $policy );
      my $short_name = policy_short_name( $long_name );
  
      return exists $profile->{"-$short_name"}
          || exists $profile->{"-$long_name"};
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy_is_enabled {
  
      my ( $self, $policy ) = @_;
      my $profile = $self->{_profile};
      my $long_name  = ref $policy || policy_long_name( $policy );
      my $short_name = policy_short_name( $long_name );
  
      return exists $profile->{$short_name}
          || exists $profile->{$long_name};
  }
  
  #-----------------------------------------------------------------------------
  
  sub listed_policies {
  
      my ( $self, $policy ) = @_;
      my @normalized_policy_names = ();
  
      for my $policy_name ( sort keys %{$self->{_profile}} ) {
          $policy_name =~ s/\A - //xmso; #Chomp leading "-"
          my $policy_long_name = policy_long_name( $policy_name );
          push @normalized_policy_names, $policy_long_name;
      }
  
      return @normalized_policy_names;
  }
  
  #-----------------------------------------------------------------------------
  
  sub source {
      my ( $self ) = @_;
  
      return $self->{_source};
  }
  
  sub _set_source {
      my ( $self, $source ) = @_;
  
      $self->{_source} = $source;
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  # Begin PRIVATE methods
  
  Readonly::Hash my %LOADER_FOR => (
      ARRAY   => \&_load_profile_from_array,
      DEFAULT => \&_load_profile_from_file,
      HASH    => \&_load_profile_from_hash,
      SCALAR  => \&_load_profile_from_string,
  );
  
  sub _load_profile {
  
      my ( $self, $profile ) = @_;
  
      my $ref_type = ref $profile || 'DEFAULT';
      my $loader = $LOADER_FOR{$ref_type};
  
      if (not $loader) {
          throw_internal qq{Can't load UserProfile from type "$ref_type"};
      }
  
      $self->{_profile} = $loader->($self, $profile);
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _set_options_processor {
  
      my ($self) = @_;
      my $profile = $self->{_profile};
      my $defaults = delete $profile->{__defaults__} || {};
      $self->{_options_processor} =
          Perl::Critic::OptionsProcessor->new( %{ $defaults } );
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _load_profile_from_file {
      my ( $self, $file ) = @_;
  
      # Handle special cases.
      return {} if not defined $file;
      return {} if $file eq $EMPTY;
      return {} if $file eq 'NONE';
  
      $self->_set_source( $file );
  
      my $profile = Config::Tiny->read( $file );
      if (not defined $profile) {
          my $errstr = Config::Tiny::errstr();
          throw_generic
              message => qq{Could not parse profile "$file": $errstr},
              source  => $file;
      }
  
      _fix_defaults_key( $profile );
  
      return $profile;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _load_profile_from_array {
      my ( $self, $array_ref ) = @_;
      my $joined    = join qq{\n}, @{ $array_ref };
      my $profile = Config::Tiny->read_string( $joined );
  
      if (not defined $profile) {
          throw_generic 'Profile error: ' . Config::Tiny::errstr();
      }
  
      _fix_defaults_key( $profile );
  
      return $profile;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _load_profile_from_string {
      my ( $self, $string ) = @_;
      my $profile = Config::Tiny->read_string( ${ $string } );
  
      if (not defined $profile) {
          throw_generic 'Profile error: ' . Config::Tiny::errstr();
      }
  
      _fix_defaults_key( $profile );
  
      return $profile;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _load_profile_from_hash {
      my ( $self, $hash_ref ) = @_;
      return $hash_ref;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _find_profile_path {
  
      #Define default filename
      my $rc_file = '.perlcriticrc';
  
      #Check explicit environment setting
      return $ENV{PERLCRITIC} if exists $ENV{PERLCRITIC};
  
      #Check current directory
      return $rc_file if -f $rc_file;
  
      #Check home directory
      if ( my $home_dir = _find_home_dir() ) {
          my $path = File::Spec->catfile( $home_dir, $rc_file );
          return $path if -f $path;
      }
  
      #No profile defined
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _find_home_dir {
  
      # Try using File::HomeDir
      if ( eval { require File::HomeDir } ) {
          return File::HomeDir->my_home();
      }
  
      # Check usual environment vars
      for my $key (qw(HOME USERPROFILE HOMESHARE)) {
          next if not defined $ENV{$key};
          return $ENV{$key} if -d $ENV{$key};
      }
  
      # No home directory defined
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  # !$%@$%^ Config::Tiny uses a completely non-descriptive name for global
  # values.
  sub _fix_defaults_key {
      my ( $profile ) = @_;
  
      my $defaults = delete $profile->{_};
      if ($defaults) {
          $profile->{__defaults__} = $defaults;
      }
  
      return;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords UserProfile
  
  =head1 NAME
  
  Perl::Critic::UserProfile - The contents of the user's profile, often F<.perlcriticrc>.
  
  
  =head1 DESCRIPTION
  
  This is a helper class that encapsulates the contents of the user's
  profile, which is usually stored in a F<.perlcriticrc> file. There are
  no user-serviceable parts here.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a non-public class.  Its interface is subject
  to change without notice.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C< new( -profile => $p ) >
  
  B<-profile> is the path to the user's profile.  If -profile is not
  defined, then it looks for the profile at F<./.perlcriticrc> and then
  F<$HOME/.perlcriticrc>.  If neither of those files exists, then the
  UserProfile is created with default values.
  
  This object does not take into account any command-line overrides;
  L<Perl::Critic::Config|Perl::Critic::Config> does that.
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C< options_processor() >
  
  Returns the
  L<Perl::Critic::OptionsProcessor|Perl::Critic::OptionsProcessor>
  object for this UserProfile.
  
  
  =item C< policy_is_disabled( $policy ) >
  
  Given a reference to a L<Perl::Critic::Policy|Perl::Critic::Policy>
  object or the name of one, returns true if the user has disabled that
  policy in their profile.
  
  
  =item C< policy_is_enabled( $policy ) >
  
  Given a reference to a L<Perl::Critic::Policy|Perl::Critic::Policy>
  object or the name of one, returns true if the user has explicitly
  enabled that policy in their user profile.
  
  
  =item C< policy_params( $policy ) >
  
  Given a reference to a L<Perl::Critic::Policy|Perl::Critic::Policy>
  object or the name of one, returns a
  L<Perl::Critic::PolicyConfig|Perl::Critic::PolicyConfig> for the
  user's configuration parameters for that policy.
  
  
  =item C< raw_policy_params( $policy ) >
  
  Given a reference to a L<Perl::Critic::Policy|Perl::Critic::Policy>
  object or the name of one, returns a reference to a hash of the user's
  configuration parameters for that policy.
  
  
  =item C< listed_policies() >
  
  Returns a list of the names of all the Policies that are mentioned in
  the profile.  The Policy names will be fully qualified (e.g.
  Perl::Critic::Foo).
  
  
  =item C< source() >
  
  The place where the profile information came from, if available.
  Usually the path to a F<.perlcriticrc>.
  
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Config|Perl::Critic::Config>,
  L<Perl::Critic::OptionsProcessor|Perl::Critic::OptionsProcessor>
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_USERPROFILE

$fatpacked{"Perl/Critic/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS';
  # NOTE: This module is way too large.  Please think about adding new
  # functionality into a P::C::Utils::* module instead.
  
  package Perl::Critic::Utils;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Carp qw( confess );
  use English qw(-no_match_vars);
  use File::Find qw();
  use File::Spec qw();
  use Scalar::Util qw( blessed );
  use B::Keywords qw();
  use PPI::Token::Quote::Single;
  use List::MoreUtils qw(any);
  
  use Perl::Critic::Exception::Fatal::Generic qw{ throw_generic };
  use Perl::Critic::Utils::PPI qw< is_ppi_expression_or_generic_statement >;
  
  use Exporter 'import';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  # Exportable symbols here.
  
  Readonly::Array our @EXPORT_OK => qw(
      $TRUE
      $FALSE
  
      $POLICY_NAMESPACE
  
      $SEVERITY_HIGHEST
      $SEVERITY_HIGH
      $SEVERITY_MEDIUM
      $SEVERITY_LOW
      $SEVERITY_LOWEST
      @SEVERITY_NAMES
  
      $DEFAULT_VERBOSITY
      $DEFAULT_VERBOSITY_WITH_FILE_NAME
  
      $COLON
      $COMMA
      $DQUOTE
      $EMPTY
      $EQUAL
      $FATCOMMA
      $PERIOD
      $PIPE
      $QUOTE
      $BACKTICK
      $SCOLON
      $SPACE
      $SLASH
      $BSLASH
      $LEFT_PAREN
      $RIGHT_PAREN
  
      all_perl_files
      find_keywords
      first_arg
      hashify
      interpolate
      is_assignment_operator
      is_class_name
      is_function_call
      is_hash_key
      is_in_void_context
      is_included_module_name
      is_integer
      is_label_pointer
      is_method_call
      is_package_declaration
      is_perl_bareword
      is_perl_builtin
      is_perl_builtin_with_list_context
      is_perl_builtin_with_multiple_arguments
      is_perl_builtin_with_no_arguments
      is_perl_builtin_with_one_argument
      is_perl_builtin_with_optional_argument
      is_perl_builtin_with_zero_and_or_one_arguments
      is_perl_filehandle
      is_perl_global
      is_qualified_name
      is_script
      is_subroutine_name
      is_unchecked_call
      is_valid_numeric_verbosity
      parse_arg_list
      policy_long_name
      policy_short_name
      precedence_of
      severity_to_number
      shebang_line
      split_nodes_on_comma
      verbosity_to_format
      words_from_string
  );
  
  
  # Note: this is deprecated.  This should also violate ProhibitAutomaticExportation,
  # but at the moment, we aren't smart enough to deal with Readonly variables.
  Readonly::Array our @EXPORT => @EXPORT_OK;
  
  
  Readonly::Hash our %EXPORT_TAGS => (
      all             => [ @EXPORT_OK ],
      booleans        => [ qw{ $TRUE $FALSE } ],
      severities      => [
          qw{
              $SEVERITY_HIGHEST
              $SEVERITY_HIGH
              $SEVERITY_MEDIUM
              $SEVERITY_LOW
              $SEVERITY_LOWEST
              @SEVERITY_NAMES
          }
      ],
      characters      => [
          qw{
              $COLON
              $COMMA
              $DQUOTE
              $EMPTY
              $EQUAL
              $FATCOMMA
              $PERIOD
              $PIPE
              $QUOTE
              $BACKTICK
              $SCOLON
              $SPACE
              $SLASH
              $BSLASH
              $LEFT_PAREN
              $RIGHT_PAREN
          }
      ],
      classification  => [
          qw{
              is_assignment_operator
              is_class_name
              is_function_call
              is_hash_key
              is_included_module_name
              is_integer
              is_label_pointer
              is_method_call
              is_package_declaration
              is_perl_bareword
              is_perl_builtin
              is_perl_filehandle
              is_perl_global
              is_perl_builtin_with_list_context
              is_perl_builtin_with_multiple_arguments
              is_perl_builtin_with_no_arguments
              is_perl_builtin_with_one_argument
              is_perl_builtin_with_optional_argument
              is_perl_builtin_with_zero_and_or_one_arguments
              is_qualified_name
              is_script
              is_subroutine_name
              is_unchecked_call
              is_valid_numeric_verbosity
          }
      ],
      data_conversion => [ qw{ hashify words_from_string interpolate } ],
      ppi             => [ qw{ first_arg parse_arg_list } ],
      internal_lookup => [ qw{ severity_to_number verbosity_to_format } ],
      language        => [ qw{ precedence_of } ],
      deprecated      => [ qw{ find_keywords } ],
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar our $POLICY_NAMESPACE => 'Perl::Critic::Policy';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar our $SEVERITY_HIGHEST => 5;
  Readonly::Scalar our $SEVERITY_HIGH    => 4;
  Readonly::Scalar our $SEVERITY_MEDIUM  => 3;
  Readonly::Scalar our $SEVERITY_LOW     => 2;
  Readonly::Scalar our $SEVERITY_LOWEST  => 1;
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar our $COMMA        => q{,};
  Readonly::Scalar our $EQUAL        => q{=};
  Readonly::Scalar our $FATCOMMA     => q{=>};
  Readonly::Scalar our $COLON        => q{:};
  Readonly::Scalar our $SCOLON       => q{;};
  Readonly::Scalar our $QUOTE        => q{'};
  Readonly::Scalar our $DQUOTE       => q{"};
  Readonly::Scalar our $BACKTICK     => q{`};
  Readonly::Scalar our $PERIOD       => q{.};
  Readonly::Scalar our $PIPE         => q{|};
  Readonly::Scalar our $SPACE        => q{ };
  Readonly::Scalar our $SLASH        => q{/};
  Readonly::Scalar our $BSLASH       => q{\\};
  Readonly::Scalar our $LEFT_PAREN   => q{(};
  Readonly::Scalar our $RIGHT_PAREN  => q{)};
  Readonly::Scalar our $EMPTY        => q{};
  Readonly::Scalar our $TRUE         => 1;
  Readonly::Scalar our $FALSE        => 0;
  
  #-----------------------------------------------------------------------------
  
  #TODO: Should this include punctuations vars?
  
  
  
  #-----------------------------------------------------------------------------
  ## no critic (ProhibitNoisyQuotes);
  
  Readonly::Hash my %PRECEDENCE_OF => (
      '->'   => 1,
      '++'   => 2,
      '--'   => 2,
      '**'   => 3,
      '!'    => 4,
      '~'    => 4,
      '\\'   => 4,
      '=~'   => 5,
      '!~'   => 5,
      '*'    => 6,
      '/'    => 6,
      '%'    => 6,
      'x'    => 6,
      '+'    => 7,
      '-'    => 7,
      '.'    => 7,
      '<<'   => 8,
      '>>'   => 8,
      '-R'   => 9,
      '-W'   => 9,
      '-X'   => 9,
      '-r'   => 9,
      '-w'   => 9,
      '-x'   => 9,
      '-e'   => 9,
      '-O'   => 9,
      '-o'   => 9,
      '-z'   => 9,
      '-s'   => 9,
      '-M'   => 9,
      '-A'   => 9,
      '-C'   => 9,
      '-S'   => 9,
      '-c'   => 9,
      '-b'   => 9,
      '-f'   => 9,
      '-d'   => 9,
      '-p'   => 9,
      '-l'   => 9,
      '-u'   => 9,
      '-g'   => 9,
      '-k'   => 9,
      '-t'   => 9,
      '-T'   => 9,
      '-B'   => 9,
      '<'    => 10,
      '>'    => 10,
      '<='   => 10,
      '>='   => 10,
      'lt'   => 10,
      'gt'   => 10,
      'le'   => 10,
      'ge'   => 10,
      '=='   => 11,
      '!='   => 11,
      '<=>'  => 11,
      'eq'   => 11,
      'ne'   => 11,
      'cmp'  => 11,
      '~~'   => 11,
      '&'    => 12,
      '|'    => 13,
      '^'    => 13,
      '&&'   => 14,
      '//'   => 15,
      '||'   => 15,
      '..'   => 16,
      '...'  => 17,
      '?'    => 18,
      ':'    => 18,
      '='    => 19,
      '+='   => 19,
      '-='   => 19,
      '*='   => 19,
      '/='   => 19,
      '%='   => 19,
      '||='  => 19,
      '&&='  => 19,
      '|='   => 19,
      '&='   => 19,
      '**='  => 19,
      'x='   => 19,
      '.='   => 19,
      '^='   => 19,
      '<<='  => 19,
      '>>='  => 19,
      '//='  => 19,
      ','    => 20,
      '=>'   => 20,
      'not'  => 22,
      'and'  => 23,
      'or'   => 24,
      'xor'  => 24,
  );
  
  ## use critic
  
  Readonly::Scalar my $MIN_PRECEDENCE_TO_TERMINATE_PARENLESS_ARG_LIST =>
      precedence_of( 'not' );
  
  #-----------------------------------------------------------------------------
  
  sub hashify {  ## no critic (ArgUnpacking)
      return map { $_ => 1 } @_;
  }
  
  #-----------------------------------------------------------------------------
  
  sub interpolate {
      my ( $literal ) = @_;
      return eval "\"$literal\"" || confess $EVAL_ERROR;  ## no critic (StringyEval);
  }
  
  #-----------------------------------------------------------------------------
  
  sub find_keywords {
      my ( $doc, $keyword ) = @_;
      my $nodes_ref = $doc->find('PPI::Token::Word');
      return if !$nodes_ref;
      my @matches = grep { $_ eq $keyword } @{$nodes_ref};
      return @matches ? \@matches : undef;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _name_for_sub_or_stringified_element {
      my $elem = shift;
  
      if ( blessed $elem and $elem->isa('PPI::Statement::Sub') ) {
          return $elem->name();
      }
  
      return "$elem";
  }
  
  #-----------------------------------------------------------------------------
  ## no critic (ProhibitPackageVars)
  
  Readonly::Hash my %BUILTINS => hashify( @B::Keywords::Functions );
  
  sub is_perl_builtin {
      my $elem = shift;
      return if !$elem;
  
      return exists $BUILTINS{ _name_for_sub_or_stringified_element($elem) };
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %BAREWORDS => hashify( @B::Keywords::Barewords );
  
  sub is_perl_bareword {
      my $elem = shift;
      return if !$elem;
  
      return exists $BAREWORDS{ _name_for_sub_or_stringified_element($elem) };
  }
  
  #-----------------------------------------------------------------------------
  
  sub _build_globals_without_sigils {
      # B::Keywords as of 1.08 forgot $\
      my @globals =
          map { substr $_, 1 }
              @B::Keywords::Arrays,
              @B::Keywords::Hashes,
              @B::Keywords::Scalars,
              '$\\'; ## no critic (RequireInterpolationOfMetachars)
  
      # Not all of these have sigils
      foreach my $filehandle (@B::Keywords::Filehandles) {
          (my $stripped = $filehandle) =~ s< \A [*] ><>xms;
          push @globals, $stripped;
      }
  
      return @globals;
  }
  
  Readonly::Array my @GLOBALS_WITHOUT_SIGILS => _build_globals_without_sigils();
  
  Readonly::Hash my %GLOBALS => hashify( @GLOBALS_WITHOUT_SIGILS );
  
  sub is_perl_global {
      my $elem = shift;
      return if !$elem;
      my $var_name = "$elem"; #Convert Token::Symbol to string
      $var_name =~ s{\A [\$@%*] }{}xms;  #Chop off the sigil
      return exists $GLOBALS{ $var_name };
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %FILEHANDLES => hashify( @B::Keywords::Filehandles );
  
  sub is_perl_filehandle {
      my $elem = shift;
      return if !$elem;
  
      return exists $FILEHANDLES{ _name_for_sub_or_stringified_element($elem) };
  }
  
  ## use critic
  #-----------------------------------------------------------------------------
  
  # egrep '=item.*LIST' perlfunc.pod
  Readonly::Hash my %BUILTINS_WHICH_PROVIDE_LIST_CONTEXT =>
      hashify(
          qw{
              chmod
              chown
              die
              exec
              formline
              grep
              import
              join
              kill
              map
              no
              open
              pack
              print
              printf
              push
              reverse
              say
              sort
              splice
              sprintf
              syscall
              system
              tie
              unlink
              unshift
              use
              utime
              warn
          },
      );
  
  sub is_perl_builtin_with_list_context {
      my $elem = shift;
  
      return
          exists
              $BUILTINS_WHICH_PROVIDE_LIST_CONTEXT{
                  _name_for_sub_or_stringified_element($elem)
              };
  }
  
  #-----------------------------------------------------------------------------
  
  # egrep '=item.*[A-Z],' perlfunc.pod
  Readonly::Hash my %BUILTINS_WHICH_TAKE_MULTIPLE_ARGUMENTS =>
      hashify(
          qw{
              accept
              atan2
              bind
              binmode
              bless
              connect
              crypt
              dbmopen
              fcntl
              flock
              gethostbyaddr
              getnetbyaddr
              getpriority
              getservbyname
              getservbyport
              getsockopt
              index
              ioctl
              link
              listen
              mkdir
              msgctl
              msgget
              msgrcv
              msgsnd
              open
              opendir
              pipe
              read
              recv
              rename
              rindex
              seek
              seekdir
              select
              semctl
              semget
              semop
              send
              setpgrp
              setpriority
              setsockopt
              shmctl
              shmget
              shmread
              shmwrite
              shutdown
              socket
              socketpair
              splice
              split
              substr
              symlink
              sysopen
              sysread
              sysseek
              syswrite
              truncate
              unpack
              vec
              waitpid
          },
          keys %BUILTINS_WHICH_PROVIDE_LIST_CONTEXT
      );
  
  sub is_perl_builtin_with_multiple_arguments {
      my $elem = shift;
  
      return
          exists
              $BUILTINS_WHICH_TAKE_MULTIPLE_ARGUMENTS{
                  _name_for_sub_or_stringified_element($elem)
              };
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %BUILTINS_WHICH_TAKE_NO_ARGUMENTS =>
      hashify(
          qw{
              endgrent
              endhostent
              endnetent
              endprotoent
              endpwent
              endservent
              fork
              format
              getgrent
              gethostent
              getlogin
              getnetent
              getppid
              getprotoent
              getpwent
              getservent
              setgrent
              setpwent
              split
              time
              times
              wait
              wantarray
          }
      );
  
  sub is_perl_builtin_with_no_arguments {
      my $elem = shift;
  
      return
          exists
              $BUILTINS_WHICH_TAKE_NO_ARGUMENTS{
                  _name_for_sub_or_stringified_element($elem)
              };
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %BUILTINS_WHICH_TAKE_ONE_ARGUMENT =>
      hashify(
          qw{
              closedir
              dbmclose
              delete
              each
              exists
              fileno
              getgrgid
              getgrnam
              gethostbyname
              getnetbyname
              getpeername
              getpgrp
              getprotobyname
              getprotobynumber
              getpwnam
              getpwuid
              getsockname
              goto
              keys
              local
              prototype
              readdir
              readline
              readpipe
              rewinddir
              scalar
              sethostent
              setnetent
              setprotoent
              setservent
              telldir
              tied
              untie
              values
          }
      );
  
  sub is_perl_builtin_with_one_argument {
      my $elem = shift;
  
      return
          exists
              $BUILTINS_WHICH_TAKE_ONE_ARGUMENT{
                  _name_for_sub_or_stringified_element($elem)
              };
  }
  
  #-----------------------------------------------------------------------------
  
  ## no critic (ProhibitPackageVars)
  Readonly::Hash my %BUILTINS_WHICH_TAKE_OPTIONAL_ARGUMENT =>
      hashify(
          grep { not exists $BUILTINS_WHICH_TAKE_ONE_ARGUMENT{ $_ } }
          grep { not exists $BUILTINS_WHICH_TAKE_NO_ARGUMENTS{ $_ } }
          grep { not exists $BUILTINS_WHICH_TAKE_MULTIPLE_ARGUMENTS{ $_ } }
          @B::Keywords::Functions
      );
  ## use critic
  
  sub is_perl_builtin_with_optional_argument {
      my $elem = shift;
  
      return
          exists
              $BUILTINS_WHICH_TAKE_OPTIONAL_ARGUMENT{
                  _name_for_sub_or_stringified_element($elem)
              };
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_perl_builtin_with_zero_and_or_one_arguments {
      my $elem = shift;
  
      return if not $elem;
  
      my $name = _name_for_sub_or_stringified_element($elem);
  
      return (
              exists $BUILTINS_WHICH_TAKE_ONE_ARGUMENT{ $name }
          or  exists $BUILTINS_WHICH_TAKE_NO_ARGUMENTS{ $name }
          or  exists $BUILTINS_WHICH_TAKE_OPTIONAL_ARGUMENT{ $name }
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_qualified_name {
      my $name = shift;
  
      return if not $name;
  
      return index ( $name, q{::} ) >= 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub precedence_of {
      my $elem = shift;
      return if !$elem;
      return $PRECEDENCE_OF{ ref $elem ? "$elem" : $elem };
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_hash_key {
      my $elem = shift;
      return if !$elem;
  
      #If followed by an argument list, then its a function call, not a literal
      return if _is_followed_by_parens($elem);
  
      #Check curly-brace style: $hash{foo} = bar;
      my $parent = $elem->parent();
      return if !$parent;
      my $grandparent = $parent->parent();
      return if !$grandparent;
      return 1 if $grandparent->isa('PPI::Structure::Subscript');
  
  
      #Check declarative style: %hash = (foo => bar);
      my $sib = $elem->snext_sibling();
      return if !$sib;
      return 1 if $sib->isa('PPI::Token::Operator') && $sib eq '=>';
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_followed_by_parens {
      my $elem = shift;
      return if !$elem;
  
      my $sibling = $elem->snext_sibling() || return;
      return $sibling->isa('PPI::Structure::List');
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_included_module_name {
      my $elem  = shift;
      return if !$elem;
      my $stmnt = $elem->statement();
      return if !$stmnt;
      return if !$stmnt->isa('PPI::Statement::Include');
      return $stmnt->schild(1) == $elem;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_integer {
      my ($value) = @_;
      return 0 if not defined $value;
  
      return $value =~ m{ \A [+-]? \d+ \z }xms;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_label_pointer {
      my $elem = shift;
      return if !$elem;
  
      my $statement = $elem->statement();
      return if !$statement;
  
      my $psib = $elem->sprevious_sibling();
      return if !$psib;
  
      return $statement->isa('PPI::Statement::Break')
          && $psib =~ m/(?:redo|goto|next|last)/xmso;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_method_call {
      my $elem = shift;
      return if !$elem;
  
      return _is_dereference_operator( $elem->sprevious_sibling() );
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_class_name {
      my $elem = shift;
      return if !$elem;
  
      return _is_dereference_operator( $elem->snext_sibling() )
          && !_is_dereference_operator( $elem->sprevious_sibling() );
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_dereference_operator {
      my $elem = shift;
      return if !$elem;
  
      return $elem->isa('PPI::Token::Operator') && $elem eq q{->};
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_package_declaration {
      my $elem  = shift;
      return if !$elem;
      my $stmnt = $elem->statement();
      return if !$stmnt;
      return if !$stmnt->isa('PPI::Statement::Package');
      return $stmnt->schild(1) == $elem;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_subroutine_name {
      my $elem  = shift;
      return if !$elem;
      my $sib   = $elem->sprevious_sibling();
      return if !$sib;
      my $stmnt = $elem->statement();
      return if !$stmnt;
      return $stmnt->isa('PPI::Statement::Sub') && $sib eq 'sub';
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_function_call {
      my $elem = shift or return;
  
      return if is_perl_bareword($elem);
      return if is_perl_filehandle($elem);
      return if is_package_declaration($elem);
      return if is_included_module_name($elem);
      return if is_method_call($elem);
      return if is_class_name($elem);
      return if is_subroutine_name($elem);
      return if is_label_pointer($elem);
      return if is_hash_key($elem);
  
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_script {
      my $doc = shift;
  
      warnings::warnif(
          'deprecated',
          'Perl::Critic::Utils::is_script($doc) deprecated, use $doc->is_program() instead.',  ## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
      );
  
      return $doc->is_program()
          if blessed($doc) && $doc->isa('Perl::Critic::Document');
  
      return 1 if shebang_line($doc);
      return 1 if _is_PL_file($doc);
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _is_PL_file {  ## no critic (NamingConventions::Capitalization)
      my ($doc) = @_;
      return if not $doc->can('filename');
      my $filename = $doc->filename() || return;
      return 1 if $filename =~ m/[.] PL \z/xms;
      return 0;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_in_void_context {
      my ($token) = @_;
  
      # If part of a collective, can't be void.
      return if $token->sprevious_sibling();
  
      my $parent = $token->statement()->parent();
      if ($parent) {
          return if $parent->isa('PPI::Structure::List');
          return if $parent->isa('PPI::Structure::For');
          return if $parent->isa('PPI::Structure::Condition');
          return if $parent->isa('PPI::Structure::Constructor');
          return if $parent->isa('PPI::Structure::Subscript');
  
          my $grand_parent = $parent->parent();
          if ($grand_parent) {
              return if
                      $parent->isa('PPI::Structure::Block')
                  and not $grand_parent->isa('PPI::Statement::Compound');
          }
      }
  
      return $TRUE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy_long_name {
      my ( $policy_name ) = @_;
      if ( $policy_name !~ m{ \A $POLICY_NAMESPACE }xms ) {
          $policy_name = $POLICY_NAMESPACE . q{::} . $policy_name;
      }
      return $policy_name;
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy_short_name {
      my ( $policy_name ) = @_;
      $policy_name =~ s{\A $POLICY_NAMESPACE ::}{}xms;
      return $policy_name;
  }
  
  #-----------------------------------------------------------------------------
  
  sub first_arg {
      my $elem = shift;
      my $sib  = $elem->snext_sibling();
      return if !$sib;
  
      if ( $sib->isa('PPI::Structure::List') ) {
  
          my $expr = $sib->schild(0);
          return if !$expr;
          return $expr->isa('PPI::Statement') ? $expr->schild(0) : $expr;
      }
  
      return $sib;
  }
  
  #-----------------------------------------------------------------------------
  
  sub parse_arg_list {
      my $elem = shift;
      my $sib  = $elem->snext_sibling();
      return if !$sib;
  
      if ( $sib->isa('PPI::Structure::List') ) {
  
          #Pull siblings from list
          my @list_contents = $sib->schildren();
          return if not @list_contents;
  
          my @list_expressions;
          foreach my $item (@list_contents) {
              if (
                  is_ppi_expression_or_generic_statement($item)
              ) {
                  push
                      @list_expressions,
                      split_nodes_on_comma( $item->schildren() );
              }
              else {
                  push @list_expressions, $item;
              }
          }
  
          return @list_expressions;
      }
      else {
  
          #Gather up remaining nodes in the statement
          my $iter     = $elem;
          my @arg_list = ();
  
          while ($iter = $iter->snext_sibling() ) {
              last if $iter->isa('PPI::Token::Structure') and $iter eq $SCOLON;
              last if $iter->isa('PPI::Token::Operator')
                  and $MIN_PRECEDENCE_TO_TERMINATE_PARENLESS_ARG_LIST <=
                      precedence_of( $iter );
              push @arg_list, $iter;
          }
          return split_nodes_on_comma( @arg_list );
      }
  }
  
  #---------------------------------
  
  sub split_nodes_on_comma {
      my @nodes = @_;
  
      my $i = 0;
      my @node_stacks;
      for my $node (@nodes) {
          if (
                  $node->isa('PPI::Token::Operator')
              and ($node eq $COMMA or $node eq $FATCOMMA)
          ) {
              if (@node_stacks) {
                  $i++; #Move forward to next 'node stack'
              }
              next;
          } elsif ( $node->isa('PPI::Token::QuoteLike::Words' )) {
              my $section = $node->{sections}->[0];
              my @words = words_from_string(substr $node->content, $section->{position}, $section->{size});
              my $loc = $node->location;
              for my $word (@words) {
                  my $token = PPI::Token::Quote::Single->new(q{'} . $word . q{'});
                  $token->{_location} = $loc;
                  push @{ $node_stacks[$i++] }, $token;
              }
              next;
          }
          push @{ $node_stacks[$i] }, $node;
      }
      return @node_stacks;
  }
  
  #-----------------------------------------------------------------------------
  
  # XXX: You must keep the regular expressions in extras/perlcritic.el in sync
  # if you change these.
  Readonly::Hash my %FORMAT_OF => (
      1 => "%f:%l:%c:%m\n",
      2 => "%f: (%l:%c) %m\n",
      3 => "%m at %f line %l\n",
      4 => "%m at line %l, column %c.  %e.  (Severity: %s)\n",
      5 => "%f: %m at line %l, column %c.  %e.  (Severity: %s)\n",
      6 => "%m at line %l, near '%r'.  (Severity: %s)\n",
      7 => "%f: %m at line %l near '%r'.  (Severity: %s)\n",
      8 => "[%p] %m at line %l, column %c.  (Severity: %s)\n",
      9 => "[%p] %m at line %l, near '%r'.  (Severity: %s)\n",
     10 => "%m at line %l, column %c.\n  %p (Severity: %s)\n%d\n",
     11 => "%m at line %l, near '%r'.\n  %p (Severity: %s)\n%d\n",
  );
  
  Readonly::Scalar our $DEFAULT_VERBOSITY => 4;
  Readonly::Scalar our $DEFAULT_VERBOSITY_WITH_FILE_NAME => 5;
  Readonly::Scalar my $DEFAULT_FORMAT => $FORMAT_OF{$DEFAULT_VERBOSITY};
  
  sub is_valid_numeric_verbosity {
      my ($verbosity) = @_;
  
      return exists $FORMAT_OF{$verbosity};
  }
  
  sub verbosity_to_format {
      my ($verbosity) = @_;
      return $DEFAULT_FORMAT if not defined $verbosity;
      return $FORMAT_OF{abs int $verbosity} || $DEFAULT_FORMAT if is_integer($verbosity);
      return interpolate( $verbosity );  #Otherwise, treat as a format spec
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %SEVERITY_NUMBER_OF => (
     gentle  => 5,
     stern   => 4,
     harsh   => 3,
     cruel   => 2,
     brutal  => 1,
  );
  
  Readonly::Array our @SEVERITY_NAMES =>  #This is exported!
      sort
          { $SEVERITY_NUMBER_OF{$a} <=> $SEVERITY_NUMBER_OF{$b} }
          keys %SEVERITY_NUMBER_OF;
  
  sub severity_to_number {
      my ($severity) = @_;
      return _normalize_severity( $severity ) if is_integer( $severity );
      my $severity_number = $SEVERITY_NUMBER_OF{lc $severity};
  
      if ( not defined $severity_number ) {
          throw_generic qq{Invalid severity: "$severity"};
      }
  
      return $severity_number;
  }
  
  sub _normalize_severity {
      my $s = shift || return $SEVERITY_HIGHEST;
      $s = $s > $SEVERITY_HIGHEST ? $SEVERITY_HIGHEST : $s;
      $s = $s < $SEVERITY_LOWEST  ? $SEVERITY_LOWEST : $s;
      return $s;
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array my @SKIP_DIR => qw( CVS RCS .svn _darcs {arch} .bzr .cdv .git .hg .pc _build blib );
  Readonly::Hash my %SKIP_DIR => hashify( @SKIP_DIR );
  
  sub all_perl_files {
      my @arg = @_;
      my @code_files;
  
      # The old code did a breadth-first search (documentation to the
      # contrary notwithstanding,) whereas File::Find does depth-first. So
      # there appears to be no way to use File::Find without changing the
      # order in which the files are returned.
      File::Find::find( {
              wanted        => sub {
                  if ( -d && $SKIP_DIR{$_} ) {
                      $File::Find::prune = 1;
                  } elsif ( -f && ! _is_backup( $_ ) && _is_perl( $_ ) ) {
                      push @code_files, $File::Find::name;
                  }
                  return;
              },
          },
          @arg,
      );
  
      # Use File::Spec->abs2rel()  to get rid of leading './' or other OS
      # equivalent on relative filenames.
      # Use map {} to get rid of leading './', or other OS equivalent
      return ( map { File::Spec->file_name_is_absolute( $_ ) ?
          $_ : File::Spec->abs2rel( $_ ) } @code_files );
  }
  
  
  #-----------------------------------------------------------------------------
  # Decide if it's some sort of backup file
  
  sub _is_backup {
      my ($file) = @_;
      return 1 if $file =~ m{ [.] swp \z}xms;
      return 1 if $file =~ m{ [.] bak \z}xms;
      return 1 if $file =~ m{  ~ \z}xms;
      return 1 if $file =~ m{ \A [#] .+ [#] \z}xms;
      return;
  }
  
  #-----------------------------------------------------------------------------
  # Returns true if the argument ends with a perl-ish file
  # extension, or if it has a shebang-line containing 'perl' This
  # subroutine was also poached from Test::Perl::Critic
  
  sub _is_perl {
      my ($file) = @_;
  
      #Check filename extensions
      return 1 if $file =~ m{ [.] PL    \z}xms;
      return 1 if $file =~ m{ [.] p[lm] \z}xms;
      return 1 if $file =~ m{ [.] psgi  \z}xms;
      return 1 if $file =~ m{ [.] t     \z}xms;
  
      #Check for shebang
      open my $fh, '<', $file or return;
      my $first = <$fh>;
      close $fh or throw_generic "unable to close $file: $OS_ERROR";
  
      return 1 if defined $first && ( $first =~ m{ \A [#]!.*perl }xms );
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub shebang_line {
      my $doc = shift;
      my $first_element = $doc->first_element();
      return if not $first_element;
      return if not $first_element->isa('PPI::Token::Comment');
      my $location = $first_element->location();
      return if !$location;
      # The shebang must be the first two characters in the file, according to
      # http://en.wikipedia.org/wiki/Shebang_(Unix)
      return if $location->[0] != 1; # line number
      return if $location->[1] != 1; # column number
      my $shebang = $first_element->content;
      return if $shebang !~ m{ \A [#]! }xms;
      return $shebang;
  }
  
  #-----------------------------------------------------------------------------
  
  sub words_from_string {
      my $str = shift;
  
      return split q{ }, $str; # This must be a literal space, not $SPACE
  }
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %ASSIGNMENT_OPERATORS => hashify( qw( = **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= ) );
  
  sub is_assignment_operator {
      my $elem = shift;
  
      return $ASSIGNMENT_OPERATORS{ $elem };
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_unchecked_call {
      my ( $elem, $autodie_modules ) = @_;
  
      return if not is_function_call( $elem );
  
      # check to see if there's an '=' or 'unless' or something before this.
      if( my $sib = $elem->sprevious_sibling() ){
          return if $sib;
      }
  
  
      if( my $statement = $elem->statement() ){
  
          # "open or die" is OK.
          # We can't check snext_sibling for 'or' since the next siblings are an
          # unknown number of arguments to the system call. Instead, check all of
          # the elements to this statement to see if we find 'or' or '||'.
  
          my $or_operators = sub  {
              my (undef, $elem) = @_;  ## no critic(Variables::ProhibitReusedNames)
              return if not $elem->isa('PPI::Token::Operator');
              return if $elem ne q{or} && $elem ne q{||};
              return 1;
          };
  
          return if $statement->find( $or_operators );
  
  
          if( my $parent = $elem->statement()->parent() ){
  
              # Check if we're in an if( open ) {good} else {bad} condition
              return if $parent->isa('PPI::Structure::Condition');
  
              # Return val could be captured in data structure and checked later
              return if $parent->isa('PPI::Structure::Constructor');
  
              # "die if not ( open() )" - It's in list context.
              if ( $parent->isa('PPI::Structure::List') ) {
                  if( my $uncle = $parent->sprevious_sibling() ){
                      return if $uncle;
                  }
              }
          }
      }
  
      return if _is_fatal($elem, $autodie_modules);
  
      # Otherwise, return. this system call is unchecked.
      return 1;
  }
  
  # Based upon autodie 2.10.
  Readonly::Hash my %AUTODIE_PARAMETER_TO_AFFECTED_BUILTINS_MAP => (
      # Map builtins to themselves.
      (
          map { $_ => { hashify( $_ ) } }
              qw<
                  accept bind binmode chdir chmod close closedir connect
                  dbmclose dbmopen exec fcntl fileno flock fork getsockopt ioctl
                  link listen mkdir msgctl msgget msgrcv msgsnd open opendir
                  pipe read readlink recv rename rmdir seek semctl semget semop
                  send setsockopt shmctl shmget shmread shutdown socketpair
                  symlink sysopen sysread sysseek system syswrite truncate umask
                  unlink
              >
      ),
  
      # Generate these using tools/dump-autodie-tag-contents
      ':threads'      => { hashify( qw< fork                          > ) },
      ':system'       => { hashify( qw< exec system                   > ) },
      ':dbm'          => { hashify( qw< dbmclose dbmopen              > ) },
      ':semaphore'    => { hashify( qw< semctl semget semop           > ) },
      ':shm'          => { hashify( qw< shmctl shmget shmread         > ) },
      ':msg'          => { hashify( qw< msgctl msgget msgrcv msgsnd   > ) },
      ':file'     => {
          hashify(
              qw<
                  binmode chmod close fcntl fileno flock ioctl open sysopen
                  truncate
              >
          )
      },
      ':filesys'      => {
          hashify(
              qw<
                  chdir closedir link mkdir opendir readlink rename rmdir
                  symlink umask unlink
              >
          )
      },
      ':ipc'      => {
          hashify(
              qw<
                  msgctl msgget msgrcv msgsnd pipe semctl semget semop shmctl
                  shmget shmread
              >
          )
      },
      ':socket'       => {
          hashify(
              qw<
                  accept bind connect getsockopt listen recv send setsockopt
                  shutdown socketpair
              >
          )
      },
      ':io'       => {
          hashify(
              qw<
                  accept bind binmode chdir chmod close closedir connect
                  dbmclose dbmopen fcntl fileno flock getsockopt ioctl link
                  listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe
                  read readlink recv rename rmdir seek semctl semget semop send
                  setsockopt shmctl shmget shmread shutdown socketpair symlink
                  sysopen sysread sysseek syswrite truncate umask unlink
              >
          )
      },
      ':default'      => {
          hashify(
              qw<
                  accept bind binmode chdir chmod close closedir connect
                  dbmclose dbmopen fcntl fileno flock fork getsockopt ioctl link
                  listen mkdir msgctl msgget msgrcv msgsnd open opendir pipe
                  read readlink recv rename rmdir seek semctl semget semop send
                  setsockopt shmctl shmget shmread shutdown socketpair symlink
                  sysopen sysread sysseek syswrite truncate umask unlink
              >
          )
      },
      ':all'      => {
          hashify(
              qw<
                  accept bind binmode chdir chmod close closedir connect
                  dbmclose dbmopen exec fcntl fileno flock fork getsockopt ioctl
                  link listen mkdir msgctl msgget msgrcv msgsnd open opendir
                  pipe read readlink recv rename rmdir seek semctl semget semop
                  send setsockopt shmctl shmget shmread shutdown socketpair
                  symlink sysopen sysread sysseek system syswrite truncate umask
                  unlink
              >
          )
      },
  );
  
  sub _is_fatal {
      my ( $elem, $autodie_modules ) = @_;
  
      my $top = $elem->top();
      return if not $top->isa('PPI::Document');
  
      my $includes = $top->find('PPI::Statement::Include');
      return if not $includes;
  
      for my $include (@{$includes}) {
          next if 'use' ne $include->type();
  
          if ('Fatal' eq $include->module()) {
              my @args = parse_arg_list($include->schild(1));
              foreach my $arg (@args) {
                  return $TRUE if $arg->[0]->isa('PPI::Token::Quote') && $elem eq $arg->[0]->string();
              }
          }
          elsif ('Fatal::Exception' eq $include->module()) {
              my @args = parse_arg_list($include->schild(1));
              shift @args;  # skip exception class name
              foreach my $arg (@args) {
                  return $TRUE if $arg->[0]->isa('PPI::Token::Quote') && $elem eq $arg->[0]->string();
              }
          }
          elsif ($include->pragma eq 'autodie' || any {$_ eq $include->module()} @{$autodie_modules || []}) {
              return _is_covered_by_autodie($elem, $include);
          }
      }
  
      return;
  }
  
  sub _is_covered_by_autodie {
      my ($elem, $include) = @_;
  
      my $autodie = $include->schild(1);
      my @args = parse_arg_list($autodie);
      my $first_arg = first_arg($autodie);
  
      # The first argument to any `use` pragma could be a version number.
      # If so, then we just discard it. We only want the arguments after it.
      if ($first_arg and $first_arg->isa('PPI::Token::Number')){ shift @args };
  
      if (@args) {
          foreach my $arg (@args) {
              my $builtins =
                  $AUTODIE_PARAMETER_TO_AFFECTED_BUILTINS_MAP{
                      $arg->[0]->string
                  };
  
              return $TRUE if $builtins and $builtins->{$elem->content()};
          }
      }
      else {
          my $builtins =
              $AUTODIE_PARAMETER_TO_AFFECTED_BUILTINS_MAP{':default'};
  
          return $TRUE if $builtins and $builtins->{$elem->content()};
      }
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Perl::Critic::Utils - General utility subroutines and constants for Perl::Critic and derivative distributions.
  
  
  =head1 DESCRIPTION
  
  This module provides several static subs and variables that are useful
  for developing L<Perl::Critic::Policy|Perl::Critic::Policy>
  subclasses.  Unless you are writing Policy modules, you probably don't
  care about this package.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE SUBS
  
  =over
  
  =item C<find_keywords( $doc, $keyword )>
  
  B<DEPRECATED:> Since version 0.11, every Policy is evaluated at each
  element of the document.  So you shouldn't need to go looking for a
  particular keyword.  If you I<do> want to use this, please import it
  via the C<:deprecated> tag, rather than directly, to mark the module
  as needing updating.
  
  Given a L<PPI::Document|PPI::Document> as C<$doc>, returns a reference
  to an array containing all the L<PPI::Token::Word|PPI::Token::Word>
  elements that match C<$keyword>.  This can be used to find any
  built-in function, method call, bareword, or reserved keyword.  It
  will not match variables, subroutine names, literal strings, numbers,
  or symbols.  If the document doesn't contain any matches, returns
  undef.
  
  =item C<is_assignment_operator( $element )>
  
  Given a L<PPI::Token::Operator|PPI::Token::Operator> or a string,
  returns true if that token represents one of the assignment operators
  (e.g. C<= &&= ||= //= += -=> etc.).
  
  =item C<is_perl_global( $element )>
  
  Given a L<PPI::Token::Symbol|PPI::Token::Symbol> or a string, returns
  true if that token represents one of the global variables provided by
  the L<English|English> module, or one of the builtin global variables
  like C<%SIG>, C<%ENV>, or C<@ARGV>.  The sigil on the symbol is
  ignored, so things like C<$ARGV> or C<$ENV> will still return true.
  
  
  =item C<is_perl_builtin( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8.
  
  
  =item C<is_perl_bareword( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a bareword (e.g. "if", "else", "sub", "package")
  defined in Perl 5.8.8.
  
  
  =item C<is_perl_filehandle( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, or string, returns true
  if that token represents one of the global filehandles (e.g. C<STDIN>,
  C<STDERR>, C<STDOUT>, C<ARGV>) that are defined in Perl 5.8.8.  Note
  that this function will return false if given a filehandle that is
  represented as a typeglob (e.g. C<*STDIN>)
  
  
  =item C<is_perl_builtin_with_list_context( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8 that provide a list context to the following tokens.
  
  
  =item C<is_perl_builtin_with_multiple_arguments( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8 that B<can> take multiple arguments.
  
  
  =item C<is_perl_builtin_with_no_arguments( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8 that B<cannot> take any arguments.
  
  
  =item C<is_perl_builtin_with_one_argument( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8 that takes B<one and only one> argument.
  
  
  =item C<is_perl_builtin_with_optional_argument( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8 that takes B<no more than one> argument.
  
  The sets of values for which
  C<is_perl_builtin_with_multiple_arguments()>,
  C<is_perl_builtin_with_no_arguments()>,
  C<is_perl_builtin_with_one_argument()>, and
  C<is_perl_builtin_with_optional_argument()> return true are disjoint
  and their union is precisely the set of values that
  C<is_perl_builtin()> will return true for.
  
  
  =item C<is_perl_builtin_with_zero_and_or_one_arguments( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>,
  L<PPI::Statement::Sub|PPI::Statement::Sub>, or string, returns true if
  that token represents a call to any of the builtin functions defined
  in Perl 5.8.8 that takes no and/or one argument.
  
  Returns true if any of C<is_perl_builtin_with_no_arguments()>,
  C<is_perl_builtin_with_one_argument()>, and
  C<is_perl_builtin_with_optional_argument()> returns true.
  
  
  =item C<is_qualified_name( $name )>
  
  Given a string, L<PPI::Token::Word|PPI::Token::Word>, or
  L<PPI::Token::Symbol|PPI::Token::Symbol>, answers whether it has a
  module component, i.e. contains "::".
  
  
  =item C<precedence_of( $element )>
  
  Given a L<PPI::Token::Operator|PPI::Token::Operator> or a string,
  returns the precedence of the operator, where 1 is the highest
  precedence.  Returns undef if the precedence can't be determined
  (which is usually because it is not an operator).
  
  
  =item C<is_hash_key( $element )>
  
  Given a L<PPI::Element|PPI::Element>, returns true if the element is a
  literal hash key.  PPI doesn't distinguish between regular barewords
  (like keywords or subroutine calls) and barewords in hash subscripts
  (which are considered literal).  So this subroutine is useful if your
  Policy is searching for L<PPI::Token::Word|PPI::Token::Word> elements
  and you want to filter out the hash subscript variety.  In both of the
  following examples, "foo" is considered a hash key:
  
      $hash1{foo} = 1;
      %hash2 = (foo => 1);
  
  But if the bareword is followed by an argument list, then perl treats
  it as a function call.  So in these examples, "foo" is B<not>
  considered a hash key:
  
      $hash1{ foo() } = 1;
      &hash2 = (foo() => 1);
  
  
  =item C<is_included_module_name( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, returns true if the
  element is the name of a module that is being included via C<use>,
  C<require>, or C<no>.
  
  
  =item C<is_integer( $value )>
  
  Answers whether the parameter, as a string, looks like an integral
  value.
  
  
  =item C<is_class_name( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, returns true if the
  element that immediately follows this element is the dereference
  operator "->". When a bareword has a "->" on the B<right> side, it
  usually means that it is the name of the class (from which a method is
  being called).
  
  
  =item C<is_label_pointer( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, returns true if the
  element is the label in a C<next>, C<last>, C<redo>, or C<goto>
  statement.  Note this is not the same thing as the label declaration.
  
  
  =item C<is_method_call( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, returns true if the
  element that immediately precedes this element is the dereference
  operator "->". When a bareword has a "->" on the B<left> side, it
  usually means that it is the name of a method (that is being called
  from a class).
  
  
  =item C<is_package_declaration( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, returns true if the
  element is the name of a package that is being declared.
  
  
  =item C<is_subroutine_name( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word>, returns true if the
  element is the name of a subroutine declaration.  This is useful for
  distinguishing barewords and from function calls from subroutine
  declarations.
  
  
  =item C<is_function_call( $element )>
  
  Given a L<PPI::Token::Word|PPI::Token::Word> returns true if the
  element appears to be call to a static function.  Specifically, this
  function returns true if C<is_hash_key>, C<is_method_call>,
  C<is_subroutine_name>, C<is_included_module_name>,
  C<is_package_declaration>, C<is_perl_bareword>, C<is_perl_filehandle>,
  C<is_label_pointer> and C<is_subroutine_name> all return false for the
  given element.
  
  
  =item C<first_arg( $element )>
  
  Given a L<PPI::Element|PPI::Element> that is presumed to be a function
  call (which is usually a L<PPI::Token::Word|PPI::Token::Word>), return
  the first argument.  This is similar of C<parse_arg_list()> and
  follows the same logic.  Note that for the code:
  
      int($x + 0.5)
  
  this function will return just the C<$x>, not the whole expression.
  This is different from the behavior of C<parse_arg_list()>.  Another
  caveat is:
  
      int(($x + $y) + 0.5)
  
  which returns C<($x + $y)> as a
  L<PPI::Structure::List|PPI::Structure::List> instance.
  
  
  =item C<parse_arg_list( $element )>
  
  Given a L<PPI::Element|PPI::Element> that is presumed to be a function
  call (which is usually a L<PPI::Token::Word|PPI::Token::Word>), splits
  the argument expressions into arrays of tokens.  Returns a list
  containing references to each of those arrays.  This is useful because
  parentheses are optional when calling a function, and PPI parses them
  very differently.  So this method is a poor-man's parse tree of PPI
  nodes.  It's not bullet-proof because it doesn't respect precedence.
  In general, I don't like the way this function works, so don't count
  on it to be stable (or even present).
  
  
  =item C<split_nodes_on_comma( @nodes )>
  
  This has the same return type as C<parse_arg_list()> but expects to be
  passed the nodes that represent the interior of a list, like:
  
      'foo', 1, 2, 'bar'
  
  
  =item C<is_script( $document )>
  
  B<This subroutine is deprecated and will be removed in a future release.> You
  should use the L<Perl::Critic::Document/"is_program()"> method instead.
  
  
  =item C<is_in_void_context( $token )>
  
  Given a L<PPI::Token|PPI::Token>, answer whether it appears to be in a
  void context.
  
  
  =item C<policy_long_name( $policy_name )>
  
  Given a policy class name in long or short form, return the long form.
  
  
  =item C<policy_short_name( $policy_name )>
  
  Given a policy class name in long or short form, return the short
  form.
  
  
  =item C<all_perl_files( @directories )>
  
  Given a list of directories, recursively searches through all the
  directories (depth first) and returns a list of paths for all the
  files that are Perl code files.  Any administrative files for CVS or
  Subversion are skipped, as are things that look like temporary or
  backup files.
  
  A Perl code file is:
  
  =over
  
  =item * Any file that ends in F<.PL>, F<.pl>, F<.pm>, F<.psgi>, or F<.t>
  
  =item * Any file that has a first line with a shebang containing 'perl'
  
  =back
  
  
  =item C<severity_to_number( $severity )>
  
  If C<$severity> is given as an integer, this function returns
  C<$severity> but normalized to lie between C<$SEVERITY_LOWEST> and
  C<$SEVERITY_HIGHEST>.  If C<$severity> is given as a string, this
  function returns the corresponding severity number.  If the string
  doesn't have a corresponding number, this function will throw an
  exception.
  
  
  =item C<is_valid_numeric_verbosity( $severity )>
  
  Answers whether the argument has a translation to a Violation format.
  
  
  =item C<verbosity_to_format( $verbosity_level )>
  
  Given a verbosity level between 1 and 10, returns the corresponding
  predefined format string.  These formats are suitable for passing to
  the C<set_format> method in
  L<Perl::Critic::Violation|Perl::Critic::Violation>.  See the
  L<perlcritic|perlcritic> documentation for a listing of the predefined
  formats.
  
  
  =item C<hashify( @list )>
  
  Given C<@list>, return a hash where C<@list> is in the keys and each
  value is 1.  Duplicate values in C<@list> are silently squished.
  
  
  =item C<interpolate( $literal )>
  
  Given a C<$literal> string that may contain control characters (e.g..
  '\t' '\n'), this function does a double interpolation on the string
  and returns it as if it had been declared in double quotes.  For
  example:
  
      'foo \t bar \n' ...becomes... "foo \t bar \n"
  
  
  =item C<shebang_line( $document )>
  
  Given a L<PPI::Document|PPI::Document>, test if it starts with C<#!>.
  If so, return that line.  Otherwise return undef.
  
  
  =item C<words_from_string( $str )>
  
  Given config string I<$str>, return all the words from the string.
  This is safer than splitting on whitespace.
  
  
  =item C<is_unchecked_call( $element, $autodie_modules )>
  
  Given a L<PPI::Element|PPI::Element>, test to see if it contains a
  function call whose return value is not checked. The second argument
  is an array reference of module names which export C<autodie>. The
  C<autodie> module is always included in this list by default.
  
  
  =back
  
  
  =head1 IMPORTABLE VARIABLES
  
  =over
  
  =item C<$COMMA>
  
  =item C<$FATCOMMA>
  
  =item C<$COLON>
  
  =item C<$SCOLON>
  
  =item C<$QUOTE>
  
  =item C<$DQUOTE>
  
  =item C<$BACKTICK>
  
  =item C<$PERIOD>
  
  =item C<$PIPE>
  
  =item C<$EMPTY>
  
  =item C<$EQUAL>
  
  =item C<$SPACE>
  
  =item C<$SLASH>
  
  =item C<$BSLASH>
  
  =item C<$LEFT_PAREN>
  
  =item C<$RIGHT_PAREN>
  
  These character constants give clear names to commonly-used strings
  that can be hard to read when surrounded by quotes and other
  punctuation.  Can be imported in one go via the C<:characters> tag.
  
  =item C<$SEVERITY_HIGHEST>
  
  =item C<$SEVERITY_HIGH>
  
  =item C<$SEVERITY_MEDIUM>
  
  =item C<$SEVERITY_LOW>
  
  =item C<$SEVERITY_LOWEST>
  
  These numeric constants define the relative severity of violating each
  L<Perl::Critic::Policy|Perl::Critic::Policy>.  The C<get_severity> and
  C<default_severity> methods of every Policy subclass must return one
  of these values. Can be imported via the C<:severities> tag.
  
  =item C<$DEFAULT_VERBOSITY>
  
  The default numeric verbosity.
  
  =item C<$DEFAULT_VERBOSITY_WITH_FILE_NAME>
  
  The numeric verbosity that corresponds to the format indicated by
  C<$DEFAULT_VERBOSITY>, but with the file name prefixed to it.
  
  =item C<$TRUE>
  
  =item C<$FALSE>
  
  These are simple booleans. 1 and 0 respectively.  Be mindful of using
  these with string equality.  C<$FALSE ne $EMPTY>.  Can be imported via
  the C<:booleans> tag.
  
  
  =back
  
  
  =head1 IMPORT TAGS
  
  The following groups of functions and constants are available as
  parameters to a C<use Perl::Critic::Util> statement.
  
  =over
  
  =item C<:all>
  
  The lot.
  
  
  =item C<:booleans>
  
  Includes:
  C<$TRUE>, C<$FALSE>
  
  
  =item C<:severities>
  
  Includes:
  C<$SEVERITY_HIGHEST>,
  C<$SEVERITY_HIGH>,
  C<$SEVERITY_MEDIUM>,
  C<$SEVERITY_LOW>,
  C<$SEVERITY_LOWEST>,
  C<@SEVERITY_NAMES>
  
  
  =item C<:characters>
  
  Includes:
  C<$COLON>,
  C<$COMMA>,
  C<$DQUOTE>,
  C<$EMPTY>,
  C<$FATCOMMA>,
  C<$PERIOD>,
  C<$PIPE>,
  C<$QUOTE>,
  C<$BACKTICK>,
  C<$SCOLON>,
  C<$SPACE>,
  C<$SLASH>,
  C<$BSLASH>
  C<$LEFT_PAREN>
  C<$RIGHT_PAREN>
  
  
  =item C<:classification>
  
  Includes:
  C<is_assignment_operator>,
  C<is_class_name>,
  C<is_function_call>,
  C<is_hash_key>,
  C<is_included_module_name>,
  C<is_integer>,
  C<is_label_pointer>,
  C<is_method_call>,
  C<is_package_declaration>,
  C<is_perl_bareword>,
  C<is_perl_builtin>,
  C<is_perl_filehandle>,
  C<is_perl_global>,
  C<is_perl_builtin_with_list_context>
  C<is_perl_builtin_with_multiple_arguments>
  C<is_perl_builtin_with_no_arguments>
  C<is_perl_builtin_with_one_argument>
  C<is_perl_builtin_with_optional_argument>
  C<is_perl_builtin_with_zero_and_or_one_arguments>
  C<is_qualified_name>,
  C<is_script>,
  C<is_subroutine_name>,
  C<is_unchecked_call>
  C<is_valid_numeric_verbosity>
  
  See also L<Perl::Critic::Utils::PPI|Perl::Critic::Utils::PPI>.
  
  
  =item C<:data_conversion>
  
  Generic manipulation, not having anything specific to do with
  Perl::Critic.
  
  Includes:
  C<hashify>,
  C<words_from_string>,
  C<interpolate>
  
  
  =item C<:ppi>
  
  Things for dealing with L<PPI|PPI>, other than classification.
  
  Includes:
  C<first_arg>,
  C<parse_arg_list>
  
  See also L<Perl::Critic::Utils::PPI|Perl::Critic::Utils::PPI>.
  
  
  =item C<:internal_lookup>
  
  Translations between internal representations.
  
  Includes:
  C<severity_to_number>,
  C<verbosity_to_format>
  
  
  =item C<:language>
  
  Information about Perl not programmatically available elsewhere.
  
  Includes:
  C<precedence_of>
  
  
  =item C<:deprecated>
  
  Not surprisingly, things that are deprecated.  It is preferred to use
  this tag to get to these functions, rather than the function names
  themselves, so as to mark any module using them as needing cleanup.
  
  Includes:
  C<find_keywords>
  
  
  =back
  
  
  =head1 SEE ALSO
  
  L<Perl::Critic::Utils::Constants|Perl::Critic::Utils::Constants>,
  L<Perl::Critic::Utils::McCabe|Perl::Critic::Utils::McCabe>,
  L<Perl::Critic::Utils::PPI|Perl::Critic::Utils::PPI>,
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS

$fatpacked{"Perl/Critic/Utils/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_CONSTANTS';
  package Perl::Critic::Utils::Constants;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ $EMPTY hashify };
  
  use Exporter 'import';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  our @EXPORT_OK = qw{
      $PROFILE_STRICTNESS_WARN
      $PROFILE_STRICTNESS_FATAL
      $PROFILE_STRICTNESS_QUIET
      $PROFILE_STRICTNESS_DEFAULT
      %PROFILE_STRICTNESSES
      $PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT
      $PROFILE_COLOR_SEVERITY_HIGH_DEFAULT
      $PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT
      $PROFILE_COLOR_SEVERITY_LOW_DEFAULT
      $PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT
      $_MODULE_VERSION_TERM_ANSICOLOR
      @STRICT_EQUIVALENT_MODULES
      @WARNINGS_EQUIVALENT_MODULES
  };
  
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
      profile_strictness => [
          qw{
              $PROFILE_STRICTNESS_WARN
              $PROFILE_STRICTNESS_FATAL
              $PROFILE_STRICTNESS_QUIET
              $PROFILE_STRICTNESS_DEFAULT
              %PROFILE_STRICTNESSES
          }
      ],
      color_severity  => [
          qw{
              $PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT
              $PROFILE_COLOR_SEVERITY_HIGH_DEFAULT
              $PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT
              $PROFILE_COLOR_SEVERITY_LOW_DEFAULT
              $PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT
          }
      ],
      equivalent_modules => [
          qw{
             @STRICT_EQUIVALENT_MODULES
             @WARNINGS_EQUIVALENT_MODULES
          }
      ],
  );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar our $PROFILE_STRICTNESS_WARN    => 'warn';
  Readonly::Scalar our $PROFILE_STRICTNESS_FATAL   => 'fatal';
  Readonly::Scalar our $PROFILE_STRICTNESS_QUIET   => 'quiet';
  Readonly::Scalar our $PROFILE_STRICTNESS_DEFAULT => $PROFILE_STRICTNESS_WARN;
  
  Readonly::Hash our %PROFILE_STRICTNESSES =>
      hashify(
          $PROFILE_STRICTNESS_WARN,
          $PROFILE_STRICTNESS_FATAL,
          $PROFILE_STRICTNESS_QUIET,
      );
  
  Readonly::Scalar our $PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT    => 'bold red';
  Readonly::Scalar our $PROFILE_COLOR_SEVERITY_HIGH_DEFAULT       => 'magenta';
  Readonly::Scalar our $PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT     => $EMPTY;
  Readonly::Scalar our $PROFILE_COLOR_SEVERITY_LOW_DEFAULT        => $EMPTY;
  Readonly::Scalar our $PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT     => $EMPTY;
  
  # If the following changes, the corresponding change needs to be made in
  # inc/Perl/Critic/BuildUtilities.pm, sub recommended_module_versions().
  Readonly::Scalar our $_MODULE_VERSION_TERM_ANSICOLOR => 2.02;
  
  Readonly::Array our @STRICT_EQUIVALENT_MODULES => qw(
      Mo
  
      Moo
      Moo::Role
  
      Moose
      Moose::Role
      Moose::Exporter
      Moose::Util::TypeConstraints
  
      MooseX::NonMoose
      MooseX::Singleton
      MooseX::Role::Parameterized
  
      Mouse
      Mouse::Role
      Mouse::Exporter
      Mouse::Util
      Mouse::Util::TypeConstraints
  
      Moos
  
      Mousse
  
      Any::Moose
  
      Modern::Perl
  
      Dancer
      Dancer2
  
      Mojolicious::Lite
      Mojo::Base
  
      Object::Simple
  
      Role::Tiny
  
      sane
      shit
      strictures
  );
  
  # Such modules tend to inflict both strictures and warnings, so for
  # the moment these equivalent module lists are exactly the same.
  Readonly::Array our @WARNINGS_EQUIVALENT_MODULES
      => @STRICT_EQUIVALENT_MODULES;
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Utils::Constants - Global constants.
  
  =head1 DESCRIPTION
  
  Defines commonly used constants for L<Perl::Critic|Perl::Critic>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE CONSTANTS
  
  =over
  
  =item C<$PROFILE_STRICTNESS_WARN>
  
  =item C<$PROFILE_STRICTNESS_FATAL>
  
  =item C<$PROFILE_STRICTNESS_QUIET>
  
  =item C<$PROFILE_STRICTNESS_DEFAULT>
  
  =item C<%PROFILE_STRICTNESSES>
  
  Valid values for the L<perlcritic/"-profile-strictness"> option.
  Determines whether recoverable problems found in a profile file appear
  as warnings, are fatal, or are ignored.
  C<$PROFILE_STRICTNESS_DEFAULT> is set to C<$PROFILE_STRICTNESS_WARN>.
  Importable via the C<:profile_strictness> tag.
  
  
  =item C<$PROFILE_COLOR_SEVERITY_HIGHEST_DEFAULT>
  
  Default for the -color-severity-highest option. Importable via the
  C<:color_severity> tag.
  
  =item C<$PROFILE_COLOR_SEVERITY_HIGH_DEFAULT>
  
  Default for the -color-severity-high option. Importable via the
  C<:color_severity> tag.
  
  =item C<$PROFILE_COLOR_SEVERITY_MEDIUM_DEFAULT>
  
  Default for the -color-severity-medium option. Importable via the
  C<:color_severity> tag.
  
  =item C<$PROFILE_COLOR_SEVERITY_LOW_DEFAULT>
  
  Default for the -color-severity-low option. Importable via the
  C<:color_severity> tag.
  
  =item C<$PROFILE_COLOR_SEVERITY_LOWEST_DEFAULT>
  
  Default for the -color-severity-lowest option. Importable via the
  C<:color_severity> tag.
  
  =item C<@STRICT_EQUIVALENT_MODULES>
  
  =item C<@WARNINGS_EQUIVALENT_MODULES>
  
  As the names suggest, these are lists of modules that are equivalent to
  applying the L<strict|strict> or L<warnings|warnings> pragma when loaded. At
  the moment, both lists are exactly the same. B<Note:> These lists are not
  exhaustive; they only include the most commonly used modules. Policies that
  use these lists should permit configuration of additional modules.
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_CONSTANTS

$fatpacked{"Perl/Critic/Utils/DataConversion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_DATACONVERSION';
  package Perl::Critic::Utils::DataConversion;
  
  use 5.006001;
  use strict;
  use warnings;
  use Readonly;
  
  use Perl::Critic::Utils qw{ :characters :booleans };
  
  use Exporter 'import';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK => qw(
      boolean_to_number
      dor
      defined_or_empty
  );
  
  #-----------------------------------------------------------------------------
  
  sub boolean_to_number {  ## no critic (RequireArgUnpacking)
      return $_[0] ? $TRUE : $FALSE;
  }
  
  #-----------------------------------------------------------------------------
  
  sub dor {  ## no critic (RequireArgUnpacking)
      foreach (@_) {
          return $_ if defined;
      }
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub defined_or_empty {  ## no critic (RequireArgUnpacking)
      return defined $_[0] ? $_[0] : $EMPTY;
  }
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Utils::DataConversion - Utilities for converting from one type of data to another.
  
  =head1 DESCRIPTION
  
  Provides data conversion functions.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE SUBS
  
  =over
  
  =item C<boolean_to_number( $value )>
  
  Return 0 or 1 based upon the value of parameter in a boolean context.
  
  
  =item C<dor( $value, $default )>
  
  Return either the value or the default based upon whether the value is
  defined or not.
  
  =item C<dor_n( $value0, $value1, ... )>
  
  Returns the first defined value among its arguments. If none is defined,
  simply returns.
  
  
  
  =item C<defined_or_empty( $value )>
  
  Return either the parameter or an empty string based upon whether the
  parameter is defined or not.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_DATACONVERSION

$fatpacked{"Perl/Critic/Utils/McCabe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_MCCABE';
  package Perl::Critic::Utils::McCabe;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Perl::Critic::Utils qw{ :data_conversion :classification };
  
  use Exporter 'import';
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  Readonly::Array our @EXPORT_OK =>
    qw( calculate_mccabe_of_sub calculate_mccabe_of_main );
  
  #-----------------------------------------------------------------------------
  
  Readonly::Hash my %LOGIC_OPS =>
      hashify( qw( && || ||= &&= or and xor ? <<= >>= ) );
  
  Readonly::Hash my %LOGIC_KEYWORDS =>
      hashify( qw( if else elsif unless until while for foreach ) );
  
  #-----------------------------------------------------------------------------
  
  sub calculate_mccabe_of_sub {
  
      my ( $sub ) = @_;
  
      my $count = 1; # Minimum score is 1
      $count += _count_logic_keywords( $sub );
      $count += _count_logic_operators( $sub );
  
      return $count;
  }
  
  #-----------------------------------------------------------------------------
  
  sub calculate_mccabe_of_main {
  
      my ( $doc ) = @_;
  
      my $count = 1; # Minimum score is 1
      $count += _count_main_logic_operators_and_keywords( $doc );
      return $count;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _count_main_logic_operators_and_keywords {
  
      my ( $doc ) = @_;
  
      # I can't leverage Perl::Critic::Document's fast search mechanism here
      # because we're not searching for elements by class name.  So to speed
      # things up, search for both keywords and operators at the same time.
  
      my $wanted = sub {
  
          my (undef, $elem) = @_;
  
          # Only count things that *are not* in a subroutine.  Returning an
          # explicit 'undef' here prevents PPI from descending into the node.
  
          ## no critic (ProhibitExplicitReturnUndef)
          return undef if $elem->isa('PPI::Statement::Sub');
  
  
          if ( $elem->isa('PPI::Token::Word') ) {
              return 0 if is_hash_key( $elem );
              return exists $LOGIC_KEYWORDS{$elem};
          }
          elsif ($elem->isa('PPI::Token::Operator') ) {
              return exists $LOGIC_OPS{$elem};
          }
      };
  
      my $logic_operators_and_keywords = $doc->find( $wanted );
  
      my $count = $logic_operators_and_keywords ?
        scalar @{$logic_operators_and_keywords} : 0;
  
      return $count;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _count_logic_keywords {
  
      my ( $sub ) = @_;
      my $count = 0;
  
      # Here, I'm using this round-about method of finding elements so
      # that I can take advantage of Perl::Critic::Document's faster
      # find() mechanism.  It can only search for elements by class name.
  
      my $keywords_ref = $sub->find('PPI::Token::Word');
      if ( $keywords_ref ) { # should always be true due to "sub" keyword
          my @filtered = grep { ! is_hash_key($_) } @{ $keywords_ref };
          $count = grep { exists $LOGIC_KEYWORDS{$_} } @filtered;
      }
      return $count;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _count_logic_operators {
  
      my ( $sub ) = @_;
      my $count = 0;
  
      # Here, I'm using this round-about method of finding elements so
      # that I can take advantage of Perl::Critic::Document's faster
      # find() mechanism.  It can only search for elements by class name.
  
      my $operators_ref = $sub->find('PPI::Token::Operator');
      if ( $operators_ref ) {
          $count = grep { exists $LOGIC_OPS{$_} }  @{ $operators_ref };
      }
  
      return $count;
  }
  
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords McCabe
  
  =head1 NAME
  
  Perl::Critic::Utils::McCabe - Functions that calculate the McCabe score of source code.
  
  
  =head1 DESCRIPTION
  
  Provides approximations of McCabe scores.  The McCabe score of a set
  of code describes the number of possible paths through it.  The
  functions here approximate the McCabe score by summing the number of
  conditional statements and operators within a set of code.  See
  L<http://en.wikipedia.org/wiki/Cyclomatic_complexity> for
  some discussion about the McCabe number and other complexity metrics.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE SUBS
  
  =over
  
  =item C<calculate_mccabe_of_sub( $sub )>
  
  Calculates an approximation of the McCabe number of the code in a
  L<PPI::Statement::Sub|PPI::Statement::Sub>.
  
  
  =item C<calculate_mccabe_of_main( $doc )>
  
  Calculates an approximation of the McCabe number of all the code in a
  L<PPI::Statement::Document|PPI::Statement::Document> that is B<not>
  contained in a subroutine.
  
  =back
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_MCCABE

$fatpacked{"Perl/Critic/Utils/POD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_POD';
  package Perl::Critic::Utils::POD;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use English qw< -no_match_vars >;
  
  use IO::String ();
  use Pod::PlainText ();
  use Pod::Select ();
  
  # TODO: non-fatal generic?
  use Perl::Critic::Exception::Fatal::Generic qw< throw_generic >;
  use Perl::Critic::Exception::IO qw< throw_io >;
  use Perl::Critic::Utils qw< :characters >;
  
  use Exporter 'import';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  our @EXPORT_OK = qw(
      get_pod_file_for_module
      get_raw_pod_section_from_file
      get_raw_pod_section_from_filehandle
      get_raw_pod_section_from_string
      get_raw_pod_section_for_module
      get_pod_section_from_file
      get_pod_section_from_filehandle
      get_pod_section_from_string
      get_pod_section_for_module
      trim_raw_pod_section
      trim_pod_section
      get_raw_module_abstract_from_file
      get_raw_module_abstract_from_filehandle
      get_raw_module_abstract_from_string
      get_raw_module_abstract_for_module
      get_module_abstract_from_file
      get_module_abstract_from_filehandle
      get_module_abstract_from_string
      get_module_abstract_for_module
  );
  
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  #-----------------------------------------------------------------------------
  
  sub get_pod_file_for_module {
      my ($module_name) = @_;
  
      # No File::Spec: %INC always uses forward slashes.
      (my $relative_path = $module_name) =~ s< :: ></>xmsg;
      $relative_path .= '.pm';
  
      my $absolute_path = $INC{$relative_path} or return;
  
      (my $pod_path = $absolute_path) =~ s< [.] [^.]+ \z><.pod>xms;
      return $pod_path if -f $pod_path;
  
      return $absolute_path;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_pod_section_from_file {
      my ($file_name, $section_name) = @_;
  
      return _get_pod_section_from_file(
          $file_name,
          $section_name,
          Pod::Select->new(),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_pod_section_from_filehandle {
      my ($file_handle, $section_name) = @_;
  
      return _get_pod_section_from_filehandle(
          $file_handle,
          $section_name,
          Pod::Select->new(),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_pod_section_from_string {
      my ($source, $section_name) = @_;
  
      return _get_pod_section_from_string(
          $source,
          $section_name,
          Pod::Select->new(),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_pod_section_for_module {
      my ($module_name, $section_name) = @_;
  
      my $file_name = get_pod_file_for_module($module_name)
          or throw_generic qq<Could not find POD for "$module_name".>;
  
      return get_raw_pod_section_from_file($file_name, $section_name);
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_pod_section_from_file {
      my ($file_name, $section_name) = @_;
  
      return _get_pod_section_from_file(
          $file_name,
          $section_name,
          Pod::PlainText->new(),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_pod_section_from_filehandle {
      my ($file_handle, $section_name) = @_;
  
      return _get_pod_section_from_filehandle(
          $file_handle,
          $section_name,
          Pod::PlainText->new(),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_pod_section_from_string {
      my ($source, $section_name) = @_;
  
      return _get_pod_section_from_string(
          $source,
          $section_name,
          Pod::PlainText->new(),
      );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_pod_section_for_module {
      my ($module_name, $section_name) = @_;
  
      my $file_name = get_pod_file_for_module($module_name)
          or throw_generic qq<Could not find POD for "$module_name".>;
  
      return get_pod_section_from_file($file_name, $section_name);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_pod_section_from_file {
      my ($file_name, $section_name, $parser) = @_;
  
      open my $file_handle, '<', $file_name
          or throw_io
              message     => qq<Could not open "$file_name": $ERRNO>,
              file_name   => $file_name,
              errno       => $ERRNO;
  
      my $content =
          _get_pod_section_from_filehandle(
              $file_handle, $section_name, $parser,
          );
  
      close $file_handle
          or throw_io
              message     => qq<Could not close "$file_name": $ERRNO>,
              file_name   => $file_name,
              errno       => $ERRNO;
  
      return $content;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_pod_section_from_filehandle {
      my ($file_handle, $section_name, $parser) = @_;
  
      $parser->select($section_name);
  
      my $content = $EMPTY;
      my $content_handle = IO::String->new( \$content );
  
      $parser->parse_from_filehandle( $file_handle, $content_handle );
  
      return if $content eq $EMPTY;
      return $content;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_pod_section_from_string {
      my ($source, $section_name, $parser) = @_;
  
      my $source_handle = IO::String->new( \$source );
  
      return
          _get_pod_section_from_filehandle(
              $source_handle, $section_name, $parser,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub trim_raw_pod_section {
      my ($pod) = @_;
  
      return if not defined $pod;
  
      $pod =~ s< \A =head1 \b [^\n]* \n $ ><>xms;
      $pod =~ s< \A \s+ ><>xms;
      $pod =~ s< \s+ \z ><>xms;
  
      return $pod;
  }
  
  #-----------------------------------------------------------------------------
  
  sub trim_pod_section {
      my ($pod) = @_;
  
      return if not defined $pod;
  
      $pod =~ s< \A [^\n]* \n ><>xms;
      $pod =~ s< \A \s* \n ><>xms;
      $pod =~ s< \s+ \z ><>xms;
  
      return $pod;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_module_abstract_from_file {
      my ($file_name) = @_;
  
      return
          _get_module_abstract_from_file(
              $file_name,
              Pod::Select->new(),
              \&trim_raw_pod_section,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_module_abstract_from_filehandle {
      my ($file_handle) = @_;
  
      return
          _get_module_abstract_from_filehandle(
              $file_handle,
              Pod::Select->new(),
              \&trim_raw_pod_section,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_module_abstract_from_string {
      my ($source) = @_;
  
      return
          _get_module_abstract_from_string(
              $source,
              Pod::Select->new(),
              \&trim_raw_pod_section,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_raw_module_abstract_for_module {
      my ($module_name) = @_;
  
      my $file_name = get_pod_file_for_module($module_name)
          or throw_generic qq<Could not find POD for "$module_name".>;
  
      return get_raw_module_abstract_from_file($file_name);
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_module_abstract_from_file {
      my ($file_name) = @_;
  
      return
          _get_module_abstract_from_file(
              $file_name,
              Pod::PlainText->new(),
              \&trim_pod_section,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_module_abstract_from_filehandle {
      my ($file_handle) = @_;
  
      return
          _get_module_abstract_from_filehandle(
              $file_handle,
              Pod::PlainText->new(),
              \&trim_pod_section,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_module_abstract_from_string {
      my ($source) = @_;
  
      return
          _get_module_abstract_from_string(
              $source,
              Pod::PlainText->new(),
              \&trim_pod_section,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_module_abstract_for_module {
      my ($module_name) = @_;
  
      my $file_name = get_pod_file_for_module($module_name)
          or throw_generic qq<Could not find POD for "$module_name".>;
  
      return get_module_abstract_from_file($file_name);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_module_abstract_from_file {
      my ($file_name, $parser, $trimmer) = @_;
  
      open my $file_handle, '<', $file_name
          or throw_io
              message     => qq<Could not open "$file_name": $ERRNO>,
              file_name   => $file_name,
              errno       => $ERRNO;
  
      my $module_abstract =
          _get_module_abstract_from_filehandle(
              $file_handle, $parser, $trimmer,
          );
  
      close $file_handle
          or throw_io
              message     => qq<Could not close "$file_name": $ERRNO>,
              file_name   => $file_name,
              errno       => $ERRNO;
  
      return $module_abstract;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_module_abstract_from_filehandle { ## no critic (RequireFinalReturn)
      my ($file_handle, $parser, $trimmer) = @_;
  
      my $name_section =
          _get_pod_section_from_filehandle( $file_handle, 'NAME', $parser );
      return if not $name_section;
  
      $name_section = $trimmer->($name_section);
      return if not $name_section;
  
      # Testing for parser class, blech.  But it's a lot simpler and it's all
      # hidden in the implementation.
      if ('Pod::Select' eq ref $parser) {
          if ( $name_section =~ m< \n >xms ) {
              throw_generic
                  qq<Malformed NAME section in "$name_section". >
                  . q<It must be on a single line>;
          }
      }
      else {
          $name_section =~ s< \s+ >< >xmsg;
  
          # Ugh.  Pod::PlainText splits up module names.
          if (
              $name_section =~ m<
                  \A
                  \s*
                  (
                      \w [ \w:]+ \w
                  )
                  (
                      \s*
                      -
                      .*
                  )?
                  \z
              >xms
          ) {
              my ($module_name, $rest) = ($1, $2);
  
              $module_name =~ s/ [ ] //xms;
  
              $name_section = $module_name . ( $rest ? $rest : $EMPTY );
          }
      }
  
      if (
          $name_section =~ m<
              \A
              \s*
              [\w:]+              # Module name.
              \s+
              -                   # The required single hyphen.
              \s+
              (
                  \S              # At least one non-whitespace.
                  (?: .* \S)?     # Everything up to the last non-whitespace.
              )
              \s*
              \z
          >xms
      ) {
          my $module_abstract = $1;
          return $module_abstract;
      }
  
      if (
          $name_section =~ m<
              \A
              \s*
              [\w:]+              # Module name.
              (?: \s* - )?        # The single hyphen is now optional.
              \s*
              \z
          >xms
      ) {
          return;
      }
  
      throw_generic qq<Malformed NAME section in "$name_section".>;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _get_module_abstract_from_string {
      my ($source, $parser, $trimmer) = @_;
  
      my $source_handle = IO::String->new( \$source );
  
      return
          _get_module_abstract_from_filehandle(
              $source_handle, $parser, $trimmer,
          );
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Utils::POD - Utility functions for dealing with POD.
  
  
  =head1 SYNOPSIS
  
      use Perl::Critic::Utils::POD qw< get_pod_section_from_file >;
  
      my $synopsis =
          get_pod_section_from_file('Perl/Critic/Utils/POD.pm', 'SYNOPSIS');
  
      my $see_also =
          get_pod_section_from_filehandle($file_handle, 'SEE ALSO');
  
  
      my $see_also_content = trim_pod_section($see_also);
  
  
      # "Utility functions for dealing with POD."
      my $module_abstract =
          get_module_abstract_from_file('Perl/Critic/Utils/POD.pm');
  
      my $module_abstract =
          get_module_abstract_from_filehandle($file_handle);
  
  
  =head1 DESCRIPTION
  
  Provides means of accessing chunks of POD.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE SUBROUTINES
  
  =over
  
  =item C<get_pod_file_for_module( $module_name )>
  
  Figure out where to find the POD for the parameter.
  
  This depends upon the module already being loaded; it will not find
  the path for arbitrary modules.
  
  If there is a file with a ".pod" extension next to the real module
  location, it will be returned in preference to the actual module.
  
  
  =item C<get_raw_pod_section_from_file( $file_name, $section_name )>
  
  Retrieves the specified section of POD (i.e. something marked by
  C<=head1>) from the file.  This is uninterpreted; escapes are not
  processed and any sub-sections will be present.  E.g. if the content
  contains "CZ<><$x>", the return value will contain "CZ<><$x>".
  
  Returns nothing if no such section is found.
  
  Throws a L<Perl::Critic::Exception::IO|Perl::Critic::Exception::IO> if
  there's a problem with the file.
  
  
  =item C<get_raw_pod_section_from_filehandle( $file_handle, $section_name )>
  
  Does the same as C<get_raw_pod_section_from_file()>, but with a file
  handle.
  
  
  =item C<get_raw_pod_section_from_string( $source, $section_name )>
  
  Does the same as C<get_raw_pod_section_from_file()>, but with a string
  that contains the raw POD.
  
  
  =item C<get_raw_pod_section_for_module( $module_name, $section_name )>
  
  Does the same as C<get_raw_pod_section_from_file()>, but with a module
  name.
  
  Throws a
  L<Perl::Critic::Exception::Generic|Perl::Critic::Exception::Generic>
  if a file containing POD for the module can't be found.
  
  
  =item C<get_pod_section_from_file( $file_name, $section_name )>
  
  Retrieves the specified section of POD (i.e. something marked by
  C<=head1>) from the file.  This is interpreted into plain text.
  
  Returns nothing if no such section is found.
  
  Throws a L<Perl::Critic::Exception::IO|Perl::Critic::Exception::IO> if
  there's a problem with the file.
  
  
  =item C<get_pod_section_from_filehandle( $file_handle, $section_name )>
  
  Does the same as C<get_pod_section_from_file()>, but with a file
  handle.
  
  
  =item C<get_pod_section_from_string( $source, $section_name )>
  
  Does the same as C<get_pod_section_from_file()>, but with a string
  that contains the raw POD.
  
  
  =item C<get_pod_section_for_module( $module_name, $section_name )>
  
  Does the same as C<get_pod_section_from_file()>, but with a module
  name.
  
  Throws a
  L<Perl::Critic::Exception::Generic|Perl::Critic::Exception::Generic>
  if a file containing POD for the module can't be found.
  
  
  =item C<trim_raw_pod_section( $pod_section )>
  
  Returns a copy of the parameter, with any starting C<=item1 BLAH>
  removed and all leading and trailing whitespace (including newlines)
  removed after that.
  
  For example, using one of the C<get_raw_pod_section_from_*> functions
  to get the "NAME" section of this module and then calling
  C<trim_raw_pod_section()> on the result would give you
  "Perl::Critic::Utils::POD - Utility functions for dealing with POD.".
  
  
  =item C<trim_pod_section( $pod_section )>
  
  Returns a copy of the parameter, with any starting line removed and
  leading blank lines and trailing whitespace (including newlines)
  removed after that.  Note that only leading whitespace on the first
  real line of the section will remain.
  
  Since this cannot count upon a C<=item1> marker, this is much less
  reliable than C<trim_raw_pod_section()>.
  
  
  =item C<get_raw_module_abstract_from_file( $file_name )>
  
  Attempts to parse the "NAME" section of the specified file and get the
  abstract of the module from that.  If it succeeds, it returns the
  abstract.  If it fails, either because there is no "NAME" section or
  there is no abstract after the module name, returns nothing.  If it
  looks like there's a malformed abstract, throws a
  L<Perl::Critic::Exception::Fatal::Generic|Perl::Critic::Exception::Fatal::Generic>.
  
  Example "well formed" "NAME" sections without abstracts:
  
      Some::Module
  
      Some::Other::Module -
  
  Example "NAME" sections that will result in an exception:
  
      Some::Bad::Module This has no hyphen.
  
      Some::Mean::Module -- This has double hyphens.
  
      Some::Nasty::Module - This one attempts to
      span multiple lines.
  
  
  =item C<get_raw_module_abstract_from_filehandle( $file_handle )>
  
  Does the same as C<get_raw_module_abstract_from_file()>, but with a
  file handle.
  
  
  =item C<get_raw_module_abstract_from_string( $source )>
  
  Does the same as C<get_raw_module_abstract_from_file()>, but with a
  string that contains the raw POD.
  
  
  =item C<get_raw_module_abstract_for_module( $module_name )>
  
  Does the same as C<get_raw_module_abstract_from_file()>, but for a
  module name.
  
  
  =item C<get_module_abstract_from_file( $file_name )>
  
  Does the same as C<get_raw_module_abstract_from_file()>, but with
  escapes interpreted.
  
  
  =item C<get_module_abstract_from_filehandle( $file_handle )>
  
  Does the same as C<get_module_abstract_from_file()>, but with a file
  handle.
  
  
  =item C<get_module_abstract_from_string( $source )>
  
  Does the same as C<get_module_abstract_from_file()>, but with a string
  that contains the raw POD.
  
  
  =item C<get_module_abstract_for_module( $module_name )>
  
  Does the same as C<get_module_abstract_from_file()>, but for a module
  name.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_POD

$fatpacked{"Perl/Critic/Utils/POD/ParseInteriorSequence.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_POD_PARSEINTERIORSEQUENCE';
  package Perl::Critic::Utils::POD::ParseInteriorSequence;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use base qw{ Pod::Parser };
  
  use IO::String;
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  sub interior_sequence {
      my ( $self, $seq_cmd, $seq_arg, $pod_seq ) = @_;
      push @{ $self->{+__PACKAGE__}{interior_sequence} ||= [] }, $pod_seq;
      return $self->SUPER::interior_sequence( $seq_cmd, $seq_arg, $pod_seq );
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_interior_sequences {
      my ( $self, $pod ) = @_;
      $self->{+__PACKAGE__}{interior_sequence} = [];
      my $result;
      $self->parse_from_filehandle(
          IO::String->new( \$pod ),
          IO::String->new( \$result )
      );
      return @{ $self->{+__PACKAGE__}{interior_sequence} };
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Utils::POD::ParseInteriorSequence - Pod::Parser subclass to find all interior sequences.
  
  
  =head1 SYNOPSIS
  
      use Perl::Critic::Utils::POD::ParseInteriorSequence;
  
      my $parser = Perl::Critic::Utils::POD::ParseInteriorSequence->new();
      my @sequences = $parser->parse_interior_sequences(
          $pod->content() );
  
  
  =head1 DESCRIPTION
  
  Provides a means to extract interior sequences from POD text.
  
  
  =head1 INTERFACE SUPPORT
  
  This module is considered to be private to Perl::Critic. It can be
  changed or removed without notice.
  
  
  =head1 METHODS
  
  =over
  
  =item C<get_interior_sequences( $pod_text )>
  
  Returns an array of all the interior sequences from a given chunk of POD
  text, represented as L<Pod::InteriorSequence|Pod::InputObjects> objects.
  The POD text is assumed to begin with a POD command (e.g.  C<=pod>).
  
  =item C<interior_sequence( $seq_cmd, $seq_arg, $pod_seq )>
  
  Overrides the parent's method of the same name. Stashes the $pod_seq
  argument, which is a C<Pod::InteriorSequence> object, so that
  C<get_interior_sequences()> has access to it.
  
  =back
  
  
  =head1 AUTHOR
  
  Thomas R. Wyant, III F<wyant at cpan dot org>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2011 Thomas R. Wyant, III
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_POD_PARSEINTERIORSEQUENCE

$fatpacked{"Perl/Critic/Utils/PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_PPI';
  package Perl::Critic::Utils::PPI;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use Scalar::Util qw< blessed readonly >;
  
  use Exporter 'import';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  our @EXPORT_OK = qw(
      is_ppi_expression_or_generic_statement
      is_ppi_generic_statement
      is_ppi_statement_subclass
      is_ppi_simple_statement
      is_ppi_constant_element
      is_subroutine_declaration
      is_in_subroutine
      get_constant_name_element_from_declaring_statement
      get_next_element_in_same_simple_statement
      get_previous_module_used_on_same_line
  );
  
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  #-----------------------------------------------------------------------------
  
  sub is_ppi_expression_or_generic_statement {
      my $element = shift;
  
      return if not $element;
      return if not $element->isa('PPI::Statement');
      return 1 if $element->isa('PPI::Statement::Expression');
  
      my $element_class = blessed($element);
  
      return if not $element_class;
      return $element_class eq 'PPI::Statement';
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_ppi_generic_statement {
      my $element = shift;
  
      my $element_class = blessed($element);
  
      return if not $element_class;
      return if not $element->isa('PPI::Statement');
  
      return $element_class eq 'PPI::Statement';
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_ppi_statement_subclass {
      my $element = shift;
  
      my $element_class = blessed($element);
  
      return if not $element_class;
      return if not $element->isa('PPI::Statement');
  
      return $element_class ne 'PPI::Statement';
  }
  
  #-----------------------------------------------------------------------------
  
  # Can not use hashify() here because Perl::Critic::Utils already depends on
  # this module.
  Readonly::Hash my %SIMPLE_STATEMENT_CLASS => map { $_ => 1 } qw<
      PPI::Statement
      PPI::Statement::Break
      PPI::Statement::Include
      PPI::Statement::Null
      PPI::Statement::Package
      PPI::Statement::Variable
  >;
  
  sub is_ppi_simple_statement {
      my $element = shift or return;
  
      my $element_class = blessed( $element ) or return;
  
      return $SIMPLE_STATEMENT_CLASS{ $element_class };
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_ppi_constant_element {
      my $element = shift or return;
  
      blessed( $element ) or return;
  
      # TODO implement here documents once PPI::Token::HereDoc grows the
      # necessary PPI::Token::Quote interface.
      return
              $element->isa( 'PPI::Token::Number' )
          ||  $element->isa( 'PPI::Token::Quote::Literal' )
          ||  $element->isa( 'PPI::Token::Quote::Single' )
          ||  $element->isa( 'PPI::Token::QuoteLike::Words' )
          ||  (
                  $element->isa( 'PPI::Token::Quote::Double' )
              ||  $element->isa( 'PPI::Token::Quote::Interpolate' ) )
              &&  $element->string() !~ m< (?: \A | [^\\] ) (?: \\\\)* [\$\@] >smx
          ;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_subroutine_declaration {
      my $element = shift;
  
      return if not $element;
  
      return 1 if $element->isa('PPI::Statement::Sub');
  
      if ( is_ppi_generic_statement($element) ) {
          my $first_element = $element->first_element();
  
          return 1 if
                  $first_element
              and $first_element->isa('PPI::Token::Word')
              and $first_element->content() eq 'sub';
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub is_in_subroutine {
      my ($element) = @_;
  
      return if not $element;
      return 1 if is_subroutine_declaration($element);
  
      while ( $element = $element->parent() ) {
          return 1 if is_subroutine_declaration($element);
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_constant_name_element_from_declaring_statement {
      my ($element) = @_;
  
      warnings::warnif(
          'deprecated',
          'Perl::Critic::Utils::PPI::get_constant_name_element_from_declaring_statement() is deprecated. Use PPIx::Utilities::Statement::get_constant_name_elements_from_declaring_statement() instead.',
      );
  
      return if not $element;
      return if not $element->isa('PPI::Statement');
  
      if ( $element->isa('PPI::Statement::Include') ) {
          my $pragma;
          if ( $pragma = $element->pragma() and $pragma eq 'constant' ) {
              return _constant_name_from_constant_pragma($element);
          }
      }
      elsif (
              is_ppi_generic_statement($element)
          and $element->schild(0)->content() =~ m< \A Readonly \b >xms
      ) {
          return $element->schild(2);
      }
  
      return;
  }
  
  sub _constant_name_from_constant_pragma {
      my ($include) = @_;
  
      my @arguments = $include->arguments() or return;
  
      my $follower = $arguments[0];
      return if not defined $follower;
  
      return $follower;
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_next_element_in_same_simple_statement {
      my $element = shift or return;
  
      while ( $element and (
              not is_ppi_simple_statement( $element )
              or $element->parent()
              and $element->parent()->isa( 'PPI::Structure::List' ) ) ) {
          my $next;
          $next = $element->snext_sibling() and return $next;
          $element = $element->parent();
      }
      return;
  
  }
  
  #-----------------------------------------------------------------------------
  
  sub get_previous_module_used_on_same_line {
      my $element = shift or return;
  
      my ( $line ) = @{ $element->location() || []};
  
      while (not is_ppi_simple_statement( $element )) {
          $element = $element->parent() or return;
      }
  
      while ( $element = $element->sprevious_sibling() ) {
          ( @{ $element->location() || []} )[0] == $line or return;
          $element->isa( 'PPI::Statement::Include' )
              and return $element->schild( 1 );
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Utils::PPI - Utility functions for dealing with PPI objects.
  
  
  =head1 DESCRIPTION
  
  Provides classification of L<PPI::Elements|PPI::Elements>.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE SUBS
  
  =over
  
  =item C<is_ppi_expression_or_generic_statement( $element )>
  
  Answers whether the parameter is an expression or an undifferentiated
  statement.  I.e. the parameter either is a
  L<PPI::Statement::Expression|PPI::Statement::Expression> or the class
  of the parameter is L<PPI::Statement|PPI::Statement> and not one of
  its subclasses other than C<Expression>.
  
  
  =item C<is_ppi_generic_statement( $element )>
  
  Answers whether the parameter is an undifferentiated statement, i.e.
  the parameter is a L<PPI::Statement|PPI::Statement> but not one of its
  subclasses.
  
  
  =item C<is_ppi_statement_subclass( $element )>
  
  Answers whether the parameter is a specialized statement, i.e. the
  parameter is a L<PPI::Statement|PPI::Statement> but the class of the
  parameter is not L<PPI::Statement|PPI::Statement>.
  
  
  =item C<is_ppi_simple_statement( $element )>
  
  Answers whether the parameter represents a simple statement, i.e. whether the
  parameter is a L<PPI::Statement|PPI::Statement>,
  L<PPI::Statement::Break|PPI::Statement::Break>,
  L<PPI::Statement::Include|PPI::Statement::Include>,
  L<PPI::Statement::Null|PPI::Statement::Null>,
  L<PPI::Statement::Package|PPI::Statement::Package>, or
  L<PPI::Statement::Variable|PPI::Statement::Variable>.
  
  
  =item C<is_ppi_constant_element( $element )>
  
  Answers whether the parameter represents a constant value, i.e. whether the
  parameter is a L<PPI::Token::Number|PPI::Token::Number>,
  L<PPI::Token::Quote::Literal|PPI::Token::Quote::Literal>,
  L<PPI::Token::Quote::Single|PPI::Token::Quote::Single>, or
  L<PPI::Token::QuoteLike::Words|PPI::Token::QuoteLike::Words>, or is a
  L<PPI::Token::Quote::Double|PPI::Token::Quote::Double> or
  L<PPI::Token::Quote::Interpolate|PPI::Token::Quote::Interpolate> which does
  not in fact contain any interpolated variables.
  
  This subroutine does B<not> interpret any form of here document as a constant
  value, and may not until L<PPI::Token::HereDoc|PPI::Token::HereDoc> acquires
  the relevant portions of the L<PPI::Token::Quote|PPI::Token::Quote> interface.
  
  This subroutine also does B<not> interpret entities created by the
  L<Readonly|Readonly> module or the L<constant|constant> pragma as constants,
  because the infrastructure to detect these appears not to be present, and the
  author of this subroutine (B<not> Mr. Shank or Mr. Thalhammer) lacks the
  knowledge/expertise/gumption to put it in place.
  
  
  =item C<is_subroutine_declaration( $element )>
  
  Is the parameter a subroutine declaration, named or not?
  
  
  =item C<is_in_subroutine( $element )>
  
  Is the parameter a subroutine or inside one?
  
  
  =item C<get_constant_name_element_from_declaring_statement($statement)>
  
  B<This subroutine is deprecated.> You should use
  L<PPIx::Utilities::Statement/get_constant_name_elements_from_declaring_statement()>
  instead.
  
  Given a L<PPI::Statement|PPI::Statement>, if the statement is a C<use
  constant> or L<Readonly|Readonly> declaration statement, return the name of
  the thing being defined.
  
  Given
  
      use constant 1.16 FOO => 'bar';
  
  this will return "FOO".  Similarly, given
  
      Readonly::Hash my %FOO => ( bar => 'baz' );
  
  this will return "%FOO".
  
  B<Caveat:> in the case where multiple constants are declared using the same
  C<use constant> statement (e.g. C<< use constant { FOO => 1, BAR => 2 }; >>,
  this subroutine will return the declaring
  L<PPI::Structure::Constructor|PPI::Structure::Constructor>. In the case of
  C<< use constant 1.16 { FOO => 1, BAR => 2 }; >> it may return a
  L<PPI::Structure::Block|PPI::Structure::Block> instead of a
  L<PPI::Structure::Constructor|PPI::Structure::Constructor>, due to a parse
  error in L<PPI|PPI>.
  
  
  =item C<get_next_element_in_same_simple_statement( $element )>
  
  Given a L<PPI::Element|PPI::Element>, this subroutine returns the next element
  in the same simple statement as defined by is_ppi_simple_statement(). If no
  next element can be found, this subroutine simply returns.
  
  If the $element is undefined or unblessed, we simply return.
  
  If the $element satisfies C<is_ppi_simple_statement()>, we return, B<unless>
  it has a parent which is a L<PPI::Structure::List|PPI::Structure::List>.
  
  If the $element is the last significant element in its L<PPI::Node|PPI::Node>,
  we replace it with its parent and iterate again.
  
  Otherwise, we return C<< $element->snext_sibling() >>.
  
  
  =item C<get_previous_module_used_on_same_line( $element )>
  
  Given a L<PPI::Element|PPI::Element>, returns the L<PPI::Element|PPI::Element>
  representing the name of the module included by the previous C<use> or
  C<require> on the same line as the $element. If none is found, simply returns.
  
  For example, with the line
  
      use version; our $VERSION = ...;
  
  given the L<PPI::Token::Symbol|PPI::Token::Symbol> instance for C<$VERSION>, this will return
  "version".
  
  If the given element is in a C<use> or <require>, the return is from the
  previous C<use> or C<require> on the line, if any.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_PPI

$fatpacked{"Perl/Critic/Utils/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_UTILS_PERL';
  package Perl::Critic::Utils::Perl;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter 'import';
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  our @EXPORT_OK = qw(
      symbol_without_sigil
  );
  
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  #-----------------------------------------------------------------------------
  
  sub symbol_without_sigil {
      my ($symbol) = @_;
  
      (my $without_sigil = $symbol) =~ s< \A [\$@%*&] ><>xms;
  
      return $without_sigil;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords
  
  =head1 NAME
  
  Perl::Critic::Utils::Perl - Utility functions for dealing with Perl language issues.
  
  
  =head1 SYNOPSIS
  
      use Perl::Critic::Utils::Perl qw< :all >;
  
      my $name = symbol_without_sigil('$foo');    # $name is "foo".
  
  
  =head1 DESCRIPTION
  
  This handles various issues with Perl, the language, that aren't necessarily
  L<PPI|PPI> related.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public module.  Any changes to its
  interface will go through a deprecation cycle.
  
  
  =head1 IMPORTABLE SUBROUTINES
  
  =over
  
  =item C<symbol_without_sigil( $symbol )>
  
  Returns the name of the specified symbol with any sigil at the front.
  The parameter can be a vanilla Perl string or a L<PPI::Element|PPI::Element>.
  
  
  =back
  
  
  =head1 AUTHOR
  
  Elliot Shank <perl@galumph.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007-2011 Elliot Shank.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_UTILS_PERL

$fatpacked{"Perl/Critic/Violation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_CRITIC_VIOLATION';
  package Perl::Critic::Violation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Readonly;
  
  use File::Basename qw< basename >;
  use Scalar::Util qw< blessed >;
  use String::Format qw< stringf >;
  
  use overload ( q{""} => 'to_string', cmp => '_compare' );
  
  use Perl::Critic::Utils qw< :characters :internal_lookup >;
  use Perl::Critic::Utils::POD qw<
      get_pod_section_for_module
      trim_pod_section
  >;
  use Perl::Critic::Exception::Fatal::Internal qw< throw_internal >;
  
  our $VERSION = '1.132';
  
  
  Readonly::Scalar my $NO_EXCEPTION_NO_SPLIT_LIMIT        => -1;
  Readonly::Scalar my $LOCATION_LINE_NUMBER               => 0;
  Readonly::Scalar my $LOCATION_COLUMN_NUMBER             => 1;
  Readonly::Scalar my $LOCATION_VISUAL_COLUMN_NUMBER      => 2;
  Readonly::Scalar my $LOCATION_LOGICAL_LINE_NUMBER       => 3;
  Readonly::Scalar my $LOCATION_LOGICAL_FILENAME          => 4;
  
  # Class variables...
  my $format = "%m at line %l, column %c. %e.\n"; # Default stringy format
  my %diagnostics = ();  # Cache of diagnostic messages
  
  #-----------------------------------------------------------------------------
  
  Readonly::Scalar my $CONSTRUCTOR_ARG_COUNT => 5;
  
  sub new {
      my ( $class, $desc, $expl, $elem, $sev ) = @_;
  
      # Check arguments to help out developers who might
      # be creating new Perl::Critic::Policy modules.
  
      if ( @_ != $CONSTRUCTOR_ARG_COUNT ) {
          throw_internal 'Wrong number of args to Violation->new()';
      }
  
      if ( eval { $elem->isa( 'Perl::Critic::Document' ) } ) {
          # break the facade, return the real PPI::Document
          $elem = $elem->ppi_document();
      }
  
      if ( not eval { $elem->isa( 'PPI::Element' ) } ) {
          throw_internal '3rd arg to Violation->new() must be a PPI::Element';
      }
  
      # Strip punctuation.  These are controlled by the user via the
      # formats.  He/She can use whatever makes sense to them.
      ($desc, $expl) = _chomp_periods($desc, $expl);
  
      # Create object
      my $self = bless {}, $class;
      $self->{_description} = $desc;
      $self->{_explanation} = $expl;
      $self->{_severity}    = $sev;
      $self->{_policy}      = caller;
  
      # PPI eviscerates the Elements in a Document when the Document gets
      # DESTROY()ed, and thus they aren't useful after it is gone.  So we have
      # to preemptively grab everything we could possibly want.
      $self->{_element_class} = blessed $elem;
  
      my $top = $elem->top();
      $self->{_filename} = $top->can('filename') ? $top->filename() : undef;
      $self->{_source}   = _line_containing_violation( $elem );
      $self->{_location} =
          $elem->location() || [ 0, 0, 0, 0, $self->filename() ];
  
      return $self;
  }
  
  #-----------------------------------------------------------------------------
  
  sub set_format { return $format = verbosity_to_format( $_[0] ); }  ## no critic(ArgUnpacking)
  sub get_format { return $format;         }
  
  #-----------------------------------------------------------------------------
  
  sub sort_by_location {  ## no critic(ArgUnpacking)
  
      ref $_[0] || shift;              # Can call as object or class method
      return scalar @_ if ! wantarray; # In case we are called in scalar context
  
      ## TODO: What if $a and $b are not Violation objects?
      return
          map {$_->[0]}
              sort { ($a->[1] <=> $b->[1]) || ($a->[2] <=> $b->[2]) }
                  map {[$_, $_->location->[0] || 0, $_->location->[1] || 0]}
                      @_;
  }
  
  #-----------------------------------------------------------------------------
  
  sub sort_by_severity {  ## no critic(ArgUnpacking)
  
      ref $_[0] || shift;              # Can call as object or class method
      return scalar @_ if ! wantarray; # In case we are called in scalar context
  
      ## TODO: What if $a and $b are not Violation objects?
      return
          map {$_->[0]}
              sort { $a->[1] <=> $b->[1] }
                  map {[$_, $_->severity() || 0]}
                      @_;
  }
  
  #-----------------------------------------------------------------------------
  
  sub location {
      my $self = shift;
  
      return $self->{_location};
  }
  
  #-----------------------------------------------------------------------------
  
  sub line_number {
      my ($self) = @_;
  
      return $self->location()->[$LOCATION_LINE_NUMBER];
  }
  
  #-----------------------------------------------------------------------------
  
  sub logical_line_number {
      my ($self) = @_;
  
      return $self->location()->[$LOCATION_LOGICAL_LINE_NUMBER];
  }
  
  #-----------------------------------------------------------------------------
  
  sub column_number {
      my ($self) = @_;
  
      return $self->location()->[$LOCATION_COLUMN_NUMBER];
  }
  
  #-----------------------------------------------------------------------------
  
  sub visual_column_number {
      my ($self) = @_;
  
      return $self->location()->[$LOCATION_VISUAL_COLUMN_NUMBER];
  }
  
  #-----------------------------------------------------------------------------
  
  sub diagnostics {
      my ($self) = @_;
      my $policy = $self->policy();
  
      if ( not $diagnostics{$policy} ) {
          eval {              ## no critic (RequireCheckingReturnValueOfEval)
              my $module_name = ref $policy || $policy;
              $diagnostics{$policy} =
                  trim_pod_section(
                      get_pod_section_for_module( $module_name, 'DESCRIPTION' )
                  );
          };
          $diagnostics{$policy} ||= "    No diagnostics available\n";
      }
      return $diagnostics{$policy};
  }
  
  #-----------------------------------------------------------------------------
  
  sub description {
      my $self = shift;
      return $self->{_description};
  }
  
  #-----------------------------------------------------------------------------
  
  sub explanation {
      my $self = shift;
      my $expl = $self->{_explanation};
      if ( !$expl ) {
         $expl = '(no explanation)';
      }
      if ( ref $expl eq 'ARRAY' ) {
          my $page = @{$expl} > 1 ? 'pages' : 'page';
          $page .= $SPACE . join $COMMA, @{$expl};
          $expl = "See $page of PBP";
      }
      return $expl;
  }
  
  #-----------------------------------------------------------------------------
  
  sub severity {
      my $self = shift;
      return $self->{_severity};
  }
  
  #-----------------------------------------------------------------------------
  
  sub policy {
      my $self = shift;
      return $self->{_policy};
  }
  
  #-----------------------------------------------------------------------------
  
  sub filename {
      my $self = shift;
      return $self->{_filename};
  }
  
  #-----------------------------------------------------------------------------
  
  sub logical_filename {
      my ($self) = @_;
  
      return $self->location()->[$LOCATION_LOGICAL_FILENAME];
  }
  
  #-----------------------------------------------------------------------------
  
  sub source {
      my $self = shift;
      return $self->{_source};
  }
  
  #-----------------------------------------------------------------------------
  
  sub element_class {
      my ($self) = @_;
  
      return $self->{_element_class};
  }
  
  #-----------------------------------------------------------------------------
  
  sub to_string {
      my $self = shift;
  
      my $long_policy = $self->policy();
      (my $short_policy = $long_policy) =~ s/ \A Perl::Critic::Policy:: //xms;
  
      # Wrap the more expensive ones in sub{} to postpone evaluation
      my %fspec = (
           'f' => sub { $self->logical_filename()             },
           'F' => sub { basename( $self->logical_filename() ) },
           'g' => sub { $self->filename()                     },
           'G' => sub { basename( $self->filename() )         },
           'l' => sub { $self->logical_line_number()          },
           'L' => sub { $self->line_number()                  },
           'c' => sub { $self->visual_column_number()         },
           'C' => sub { $self->element_class()                },
           'm' => $self->description(),
           'e' => $self->explanation(),
           's' => $self->severity(),
           'd' => sub { $self->diagnostics()                  },
           'r' => sub { $self->source()                       },
           'P' => $long_policy,
           'p' => $short_policy,
      );
      return stringf($format, %fspec);
  }
  
  #-----------------------------------------------------------------------------
  # Apparently, some perls do not implicitly stringify overloading
  # objects before doing a comparison.  This causes a couple of our
  # sorting tests to fail.  To work around this, we overload C<cmp> to
  # do it explicitly.
  #
  # 20060503 - More information:  This problem has been traced to
  # Test::Simple versions <= 0.60, not perl itself.  Upgrading to
  # Test::Simple v0.62 will fix the problem.  But rather than forcing
  # everyone to upgrade, I have decided to leave this workaround in
  # place.
  
  sub _compare { return "$_[0]" cmp "$_[1]" }
  
  #-----------------------------------------------------------------------------
  
  sub _line_containing_violation {
      my ( $elem ) = @_;
  
      my $stmnt = $elem->statement() || $elem;
      my $code_string = $stmnt->content() || $EMPTY;
  
      # Split into individual lines
      # From `perldoc -f split`:
      # If LIMIT is negative, it is treated as if it were instead
      # arbitrarily large; as many fields as possible are produced.
      #
      # If it's omitted, it's the same except trailing empty fields, so we need
      # without a limit for the split and without an exception
      my @lines = split qr{ \n }xms, $code_string, $NO_EXCEPTION_NO_SPLIT_LIMIT;
  
      # Take the line containing the element that is in violation
      my $inx = ( $elem->line_number() || 0 ) -
          ( $stmnt->line_number() || 0 );
      $inx > @lines and return $EMPTY;
      return $lines[$inx];
  }
  
  #-----------------------------------------------------------------------------
  
  sub _chomp_periods {
      my @args = @_;
  
      for (@args) {
          next if not defined or ref;
          s{ [.]+ \z }{}xms
      }
  
      return @args;
  }
  
  #-----------------------------------------------------------------------------
  
  1;
  
  #-----------------------------------------------------------------------------
  
  __END__
  
  =head1 NAME
  
  Perl::Critic::Violation - A violation of a Policy found in some source code.
  
  
  =head1 SYNOPSIS
  
    use PPI;
    use Perl::Critic::Violation;
  
    my $elem = $doc->child(0);      # $doc is a PPI::Document object
    my $desc = 'Offending code';    # Describe the violation
    my $expl = [1,45,67];           # Page numbers from PBP
    my $sev  = 5;                   # Severity level of this violation
  
    my $vio  = Perl::Critic::Violation->new($desc, $expl, $node, $sev);
  
  
  =head1 DESCRIPTION
  
  Perl::Critic::Violation is the generic representation of an individual
  Policy violation.  Its primary purpose is to provide an abstraction
  layer so that clients of L<Perl::Critic|Perl::Critic> don't have to
  know anything about L<PPI|PPI>.  The C<violations> method of all
  L<Perl::Critic::Policy|Perl::Critic::Policy> subclasses must return a
  list of these Perl::Critic::Violation objects.
  
  
  =head1 INTERFACE SUPPORT
  
  This is considered to be a public class.  Any changes to its interface
  will go through a deprecation cycle.
  
  
  =head1 CONSTRUCTOR
  
  =over
  
  =item C<new( $description, $explanation, $element, $severity )>
  
  Returns a reference to a new C<Perl::Critic::Violation> object. The
  arguments are a description of the violation (as string), an
  explanation for the policy (as string) or a series of page numbers in
  PBP (as an ARRAY ref), a reference to the L<PPI|PPI> element that
  caused the violation, and the severity of the violation (as an
  integer).
  
  
  =back
  
  
  =head1 METHODS
  
  =over
  
  =item C<description()>
  
  Returns a brief description of the specific violation.  In other
  words, this value may change on a per violation basis.
  
  
  =item C<explanation()>
  
  Returns an explanation of the policy as a string or as reference to an
  array of page numbers in PBP.  This value will generally not change
  based upon the specific code violating the policy.
  
  
  =item C<location()>
  
  Don't use this method.  Use the C<line_number()>,
  C<logical_line_number()>, C<column_number()>,
  C<visual_column_number()>, and C<logical_filename()> methods instead.
  
  Returns a five-element array reference containing the line and real &
  virtual column and logical numbers and logical file name where this
  Violation occurred, as in L<PPI::Element|PPI::Element>.
  
  
  =item C<line_number()>
  
  Returns the physical line number that the violation was found on.
  
  
  =item C<logical_line_number()>
  
  Returns the logical line number that the violation was found on.  This
  can differ from the physical line number when there were C<#line>
  directives in the code.
  
  
  =item C<column_number()>
  
  Returns the physical column that the violation was found at.  This
  means that hard tab characters count as a single character.
  
  
  =item C<visual_column_number()>
  
  Returns the column that the violation was found at, as it would appear
  if hard tab characters were expanded, based upon the value of
  L<PPI::Document/"tab_width [ $width ]">.
  
  
  =item C<filename()>
  
  Returns the path to the file where this Violation occurred.  In some
  cases, the path may be undefined because the source code was not read
  directly from a file.
  
  
  =item C<logical_filename()>
  
  Returns the logical path to the file where the Violation occurred.
  This can differ from C<filename()> when there was a C<#line> directive
  in the code.
  
  
  =item C<severity()>
  
  Returns the severity of this Violation as an integer ranging from 1 to
  5, where 5 is the "most" severe.
  
  
  =item C<sort_by_severity( @violation_objects )>
  
  If you need to sort Violations by severity, use this handy routine:
  
      @sorted = Perl::Critic::Violation::sort_by_severity(@violations);
  
  
  =item C<sort_by_location( @violation_objects )>
  
  If you need to sort Violations by location, use this handy routine:
  
      @sorted = Perl::Critic::Violation::sort_by_location(@violations);
  
  
  =item C<diagnostics()>
  
  Returns a formatted string containing a full discussion of the
  motivation for and details of the Policy module that created this
  Violation.  This information is automatically extracted from the
  C<DESCRIPTION> section of the Policy module's POD.
  
  
  =item C<policy()>
  
  Returns the name of the L<Perl::Critic::Policy|Perl::Critic::Policy>
  that created this Violation.
  
  
  =item C<source()>
  
  Returns the string of source code that caused this exception.  If the
  code spans multiple lines (e.g. multi-line statements, subroutines or
  other blocks), then only the line containing the violation will be
  returned.
  
  
  =item C<element_class()>
  
  Returns the L<PPI::Element|PPI::Element> subclass of the code that caused this
  exception.
  
  
  =item C<set_format( $format )>
  
  Class method.  Sets the format for all Violation objects when they are
  evaluated in string context.  The default is C<'%d at line %l, column
  %c. %e'>.  See L<"OVERLOADS"> for formatting options.
  
  
  =item C<get_format()>
  
  Class method. Returns the current format for all Violation objects
  when they are evaluated in string context.
  
  
  =item C<to_string()>
  
  Returns a string representation of this violation.  The content of the
  string depends on the current value of the C<$format> package
  variable.  See L<"OVERLOADS"> for the details.
  
  
  =back
  
  
  =head1 OVERLOADS
  
  Perl::Critic::Violation overloads the C<""> operator to produce neat
  little messages when evaluated in string context.
  
  Formats are a combination of literal and escape characters similar to
  the way C<sprintf> works.  If you want to know the specific formatting
  capabilities, look at L<String::Format|String::Format>. Valid escape
  characters are:
  
      Escape    Meaning
      -------   ----------------------------------------------------------------
      %c        Column number where the violation occurred
      %d        Full diagnostic discussion of the violation (DESCRIPTION in POD)
      %e        Explanation of violation or page numbers in PBP
      %F        Just the name of the logical file where the violation occurred.
      %f        Path to the logical file where the violation occurred.
      %G        Just the name of the physical file where the violation occurred.
      %g        Path to the physical file where the violation occurred.
      %l        Logical line number where the violation occurred
      %L        Physical line number where the violation occurred
      %m        Brief description of the violation
      %P        Full name of the Policy module that created the violation
      %p        Name of the Policy without the Perl::Critic::Policy:: prefix
      %r        The string of source code that caused the violation
      %C        The class of the PPI::Element that caused the violation
      %s        The severity level of the violation
  
  Explanation of the C<%F>, C<%f>, C<%G>, C<%G>, C<%l>, and C<%L> formats:
  Using C<#line> directives, you can affect what perl thinks the current line
  number and file name are; see L<perlsyn/Plain Old Comments (Not!)> for
  the details.  Under normal circumstances, the values of C<%F>, C<%f>, and
  C<%l> will match the values of C<%G>, C<%g>, and C<%L>, respectively.  In the
  presence of a C<#line> directive, the values of C<%F>, C<%f>, and C<%l> will
  change to take that directive into account.  The values of C<%G>, C<%g>, and
  C<%L> are unaffected by those directives.
  
  Here are some examples:
  
      Perl::Critic::Violation::set_format("%m at line %l, column %c.\n");
      # looks like "Mixed case variable name at line 6, column 23."
  
      Perl::Critic::Violation::set_format("%m near '%r'\n");
      # looks like "Mixed case variable name near 'my $theGreatAnswer = 42;'"
  
      Perl::Critic::Violation::set_format("%l:%c:%p\n");
      # looks like "6:23:NamingConventions::Capitalization"
  
      Perl::Critic::Violation::set_format("%m at line %l. %e. \n%d\n");
      # looks like "Mixed case variable name at line 6.  See page 44 of PBP.
        Conway's recommended naming convention is to use lower-case words
        separated by underscores.  Well-recognized acronyms can be in ALL
        CAPS, but must be separated by underscores from other parts of the
        name."
  
  
  =head1 AUTHOR
  
  Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
PERL_CRITIC_VIOLATION

$fatpacked{"Readonly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'READONLY';
  package Readonly;
  use 5.005;
  use strict;
  
  #use warnings;
  #no warnings 'uninitialized';
  package Readonly;
  our $VERSION = '2.05';
  $VERSION = eval $VERSION;
  
  # Autocroak (Thanks, MJD)
  # Only load Carp.pm if module is croaking.
  sub croak {
      require Carp;
      goto &Carp::croak;
  }
  
  # These functions may be overridden by Readonly::XS, if installed.
  use vars qw/$XSokay/;    # Set to true in Readonly::XS, if available
  
  # Predeclare the following, so we can use them recursively
  sub _ARRAY (\@);
  sub _HASH (\%);
  
  # For perl 5.8.x or higher
  # These functions are exposed in perl 5.8.x (Thanks, Leon!)
  # They may be overridden by Readonly::XS, if installed on old perl versions
  if ($] < 5.008) {    # 'Classic' perl
      *is_sv_readonly = sub ($) {0};
      *make_sv_readonly
          = sub ($) { die "make_sv_readonly called but not overridden" };
  
      # See if we can use the XS stuff.
      $Readonly::XS::MAGIC_COOKIE = $Readonly::XS::MAGIC_COOKIE
          = "Do NOT use or require Readonly::XS unless you're me.";
      eval 'use Readonly::XS';
  }
  else {               # Modern perl doesn't need Readonly::XS
      *is_sv_readonly = sub ($) { Internals::SvREADONLY($_[0]) };
      *make_sv_readonly
          = sub ($) { Internals::SvREADONLY($_[0], 1) };
      $XSokay = 1;     # We're using the new built-ins so this is a white lie
  }
  
  # Undo setting readonly
  sub _SCALAR ($) {
      my ($r_var) = @_;
      if ($XSokay) {
          Internals::SvREADONLY($r_var, 0) if is_sv_readonly($r_var);
      }
      else {
          return if tied($r_var) !~ 'Readonly::Scalar';
          my $r_scalar;
          {
              my $obj = tied $$r_var;
              $r_scalar = $obj;
          }
          untie $r_var;
          $r_var = $r_scalar;
      }
  }
  
  sub _ARRAY (\@) {
      my ($r_var) = @_;
      return if !tied(@$r_var);
      return if tied(@$r_var) !~ 'Readonly::Array';
      my $r_array;
      {
          my $obj = tied @$r_var;
          $r_array = $obj;
      }
      untie @$r_var;
      @$r_var = @$r_array;
  
      # Recursively check child elements for references; clean if Readonly
      foreach (@$r_var) {
          my $_reftype = ref $_;
          if ($_reftype eq 'SCALAR') { _SCALAR($_) }
          elsif ($_reftype eq 'ARRAY') {
              _ARRAY(@$_);
          }
          elsif ($_reftype eq 'HASH') {
              _HASH(%$_);
          }
      }
  }
  
  sub _HASH (\%) {
      my ($r_var) = @_;
      return if !tied(%$r_var);
      return if tied(%$r_var) !~ 'Readonly::Hash';
      my $r_hash;
      {
          my $obj = tied %$r_var;
          $r_hash = $obj;
      }
      untie %$r_var;
      %$r_var = %$r_hash;
  
      # Recursively check child elements for references; clean if Readonly
      foreach (values %$r_var) {
          my $_reftype = ref $_;
          if ($_reftype eq 'SCALAR') { _SCALAR($_) }
          elsif ($_reftype eq 'ARRAY') {
              _ARRAY(@$_);
          }
          elsif ($_reftype eq 'HASH') {
              _HASH(%$_);
          }
      }
  }
  
  # Common error messages, or portions thereof
  use vars qw/$MODIFY $REASSIGN $ODDHASH/;
  $MODIFY   = 'Modification of a read-only value attempted';
  $REASSIGN = 'Attempt to reassign a readonly';
  $ODDHASH  = 'May not store an odd number of values in a hash';
  
  # ----------------
  # Read-only scalars
  # ----------------
  package Readonly::Scalar;
  
  sub STORABLE_freeze {
      my ($self, $cloning) = @_;
      Readonly::_SCALAR($$self) if $cloning;
  }
  
  sub TIESCALAR {
      my $whence
          = (caller 2)[3];    # Check if naughty user is trying to tie directly.
      Readonly::croak "Invalid tie"
          unless $whence && $whence =~ /^Readonly::(?:Scalar1?|Readonly)$/;
      my $class = shift;
      Readonly::croak "No value specified for readonly scalar" unless @_;
      Readonly::croak "Too many values specified for readonly scalar"
          unless @_ == 1;
      my $value = shift;
      return bless \$value, $class;
  }
  
  sub FETCH {
      my $self = shift;
      return $$self;
  }
  *STORE = *STORE = sub { Readonly::croak $Readonly::MODIFY };
  *UNTIE = *UNTIE
      = sub { Readonly::croak $Readonly::MODIFY if caller() ne 'Readonly' };
  
  # ----------------
  # Read-only arrays
  # ----------------
  package Readonly::Array;
  
  sub STORABLE_freeze {
      my ($self, $cloning) = @_;
      Readonly::_ARRAY(@$self) if $cloning;
  }
  
  sub TIEARRAY {
      my $whence
          = (caller 1)[3];    # Check if naughty user is trying to tie directly.
      Readonly::croak "Invalid tie" unless $whence =~ /^Readonly::Array1?$/;
      my $class = shift;
      my @self  = @_;
      return bless \@self, $class;
  }
  
  sub FETCH {
      my $self  = shift;
      my $index = shift;
      return $self->[$index];
  }
  
  sub FETCHSIZE {
      my $self = shift;
      return scalar @$self;
  }
  
  BEGIN {
      eval q{
          sub EXISTS
             {
             my $self  = shift;
             my $index = shift;
             return exists $self->[$index];
             }
      } if $] >= 5.006;    # couldn't do "exists" on arrays before then
  }
  *STORE = *STORESIZE = *EXTEND = *PUSH = *POP = *UNSHIFT = *SHIFT = *SPLICE
      = *CLEAR = *STORE = *STORESIZE = *EXTEND = *PUSH = *POP = *UNSHIFT
      = *SHIFT = *SPLICE = *CLEAR = sub { Readonly::croak $Readonly::MODIFY};
  *UNTIE = *UNTIE
      = sub { Readonly::croak $Readonly::MODIFY if caller() ne 'Readonly' };
  
  # ----------------
  # Read-only hashes
  # ----------------
  package Readonly::Hash;
  
  sub STORABLE_freeze {
      my ($self, $cloning) = @_;
      Readonly::_HASH(%$self) if $cloning;
  }
  
  sub TIEHASH {
      my $whence
          = (caller 1)[3];    # Check if naughty user is trying to tie directly.
      Readonly::croak "Invalid tie" unless $whence =~ /^Readonly::Hash1?$/;
      my $class = shift;
  
      # must have an even number of values
      Readonly::croak $Readonly::ODDHASH unless (@_ % 2 == 0);
      my %self = @_;
      return bless \%self, $class;
  }
  
  sub FETCH {
      my $self = shift;
      my $key  = shift;
      return $self->{$key};
  }
  
  sub EXISTS {
      my $self = shift;
      my $key  = shift;
      return exists $self->{$key};
  }
  
  sub FIRSTKEY {
      my $self  = shift;
      my $dummy = keys %$self;
      return scalar each %$self;
  }
  
  sub NEXTKEY {
      my $self = shift;
      return scalar each %$self;
  }
  *STORE = *DELETE = *CLEAR = *STORE = *DELETE = *CLEAR
      = sub { Readonly::croak $Readonly::MODIFY};
  *UNTIE = *UNTIE
      = sub { Readonly::croak $Readonly::MODIFY if caller() ne 'Readonly'; };
  
  # ----------------------------------------------------------------
  # Main package, containing convenience functions (so callers won't
  # have to explicitly tie the variables themselves).
  # ----------------------------------------------------------------
  package Readonly;
  use Exporter;
  use vars qw/@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS/;
  push @ISA,       'Exporter';
  push @EXPORT,    qw/Readonly/;
  push @EXPORT_OK, qw/Scalar Array Hash Scalar1 Array1 Hash1/;
  
  # Predeclare the following, so we can use them recursively
  sub Scalar ($$);
  sub Array (\@;@);
  sub Hash (\%;@);
  
  # Returns true if a string begins with "Readonly::"
  # Used to prevent reassignment of Readonly variables.
  sub _is_badtype {
      my $type = $_[0];
      return lc $type if $type =~ s/^Readonly:://;
      return;
  }
  
  # Shallow Readonly scalar
  sub Scalar1 ($$) {
      croak "$REASSIGN scalar" if is_sv_readonly($_[0]);
      my $badtype = _is_badtype(ref tied $_[0]);
      croak "$REASSIGN $badtype" if $badtype;
  
      # xs method: flag scalar as readonly
      if ($XSokay) {
          $_[0] = $_[1];
          make_sv_readonly($_[0]);
          return;
      }
  
      # pure-perl method: tied scalar
      my $tieobj = eval { tie $_[0], 'Readonly::Scalar', $_[1] };
      if ($@) {
          croak "$REASSIGN scalar" if substr($@, 0, 43) eq $MODIFY;
          die $@;    # some other error?
      }
      return $tieobj;
  }
  
  # Shallow Readonly array
  sub Array1 (\@;@) {
      my $badtype = _is_badtype(ref tied $_[0]);
      croak "$REASSIGN $badtype" if $badtype;
      my $aref = shift;
      return tie @$aref, 'Readonly::Array', @_;
  }
  
  # Shallow Readonly hash
  sub Hash1 (\%;@) {
      my $badtype = _is_badtype(ref tied $_[0]);
      croak "$REASSIGN $badtype" if $badtype;
      my $href = shift;
  
      # If only one value, and it's a hashref, expand it
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          return tie %$href, 'Readonly::Hash', %{$_[0]};
      }
  
      # otherwise, must have an even number of values
      croak $ODDHASH unless (@_ % 2 == 0);
      return tie %$href, 'Readonly::Hash', @_;
  }
  
  # Deep Readonly scalar
  sub Scalar ($$) {
      croak "$REASSIGN scalar" if is_sv_readonly($_[0]);
      my $badtype = _is_badtype(ref tied $_[0]);
      croak "$REASSIGN $badtype" if $badtype;
      my $value = $_[1];
  
   # Recursively check passed element for references; if any, make them Readonly
      foreach ($value) {
          if    (ref eq 'SCALAR') { Scalar my $v => $$_; $_ = \$v }
          elsif (ref eq 'ARRAY')  { Array my @v  => @$_; $_ = \@v }
          elsif (ref eq 'HASH')   { Hash my %v   => $_;  $_ = \%v }
      }
  
      # xs method: flag scalar as readonly
      if ($XSokay) {
          $_[0] = $value;
          make_sv_readonly($_[0]);
          return;
      }
  
      # pure-perl method: tied scalar
      my $tieobj = eval { tie $_[0], 'Readonly::Scalar', $value };
      if ($@) {
          croak "$REASSIGN scalar" if substr($@, 0, 43) eq $MODIFY;
          die $@;    # some other error?
      }
      return $tieobj;
  }
  
  # Deep Readonly array
  sub Array (\@;@) {
      my $badtype = _is_badtype(ref tied @{$_[0]});
      croak "$REASSIGN $badtype" if $badtype;
      my $aref   = shift;
      my @values = @_;
  
  # Recursively check passed elements for references; if any, make them Readonly
      foreach (@values) {
          if    (ref eq 'SCALAR') { Scalar my $v => $$_; $_ = \$v }
          elsif (ref eq 'ARRAY')  { Array my @v  => @$_; $_ = \@v }
          elsif (ref eq 'HASH')   { Hash my %v   => $_;  $_ = \%v }
      }
  
      # Lastly, tie the passed reference
      return tie @$aref, 'Readonly::Array', @values;
  }
  
  # Deep Readonly hash
  sub Hash (\%;@) {
      my $badtype = _is_badtype(ref tied %{$_[0]});
      croak "$REASSIGN $badtype" if $badtype;
      my $href   = shift;
      my @values = @_;
  
      # If only one value, and it's a hashref, expand it
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          @values = %{$_[0]};
      }
  
      # otherwise, must have an even number of values
      croak $ODDHASH unless (@values % 2 == 0);
  
  # Recursively check passed elements for references; if any, make them Readonly
      foreach (@values) {
          if    (ref eq 'SCALAR') { Scalar my $v => $$_; $_ = \$v }
          elsif (ref eq 'ARRAY')  { Array my @v  => @$_; $_ = \@v }
          elsif (ref eq 'HASH')   { Hash my %v   => $_;  $_ = \%v }
      }
      return tie %$href, 'Readonly::Hash', @values;
  }
  
  sub Clone(\[$@%]) {
      require Storable;
      my $retval = Storable::dclone($_[0]);
      $retval = $$retval if ref $retval eq 'REF';
      my $reftype = ref $retval;
      if ($reftype eq 'SCALAR') {
          _SCALAR($retval);
          return $$retval;
      }
      elsif ($reftype eq 'ARRAY') {
          _ARRAY(@$retval);
      }
      elsif ($reftype eq 'HASH') {
          _HASH(%$retval);
          return %$retval if wantarray;
      }
      return $retval;
  }
  
  # Common entry-point for all supported data types
  eval q{sub Readonly} . ($] < 5.008 ? '' : '(\[$@%]@)') . <<'SUB_READONLY';
  {
      if (ref $_[0] eq 'SCALAR')
      {
          croak $MODIFY if is_sv_readonly ${$_[0]};
          my $badtype = _is_badtype (ref tied ${$_[0]});
          croak "$REASSIGN $badtype" if $badtype;
          croak "Readonly scalar must have only one value" if @_ > 2;
  
          # Because of problems with handling \$ prototypes declarations like
          # Readonly my @a = ... and Readonly my %h = ... are also caught here
          croak 'Invalid initialization by assignment'
              if @_ == 1 && defined ${$_[0]};
  
          my $tieobj = eval {tie ${$_[0]}, 'Readonly::Scalar', $_[1]};
          # Tie may have failed because user tried to tie a constant, or we screwed up somehow.
          if ($@)
          {
              croak $MODIFY if $@ =~ /^$MODIFY at/;    # Point the finger at the user.
              die "$@\n";        # Not a modify read-only message; must be our fault.
          }
          return $tieobj;
      }
      elsif (ref $_[0] eq 'ARRAY')
      {
          my $aref = shift;
          return Array @$aref, @_;
      }
      elsif (ref $_[0] eq 'HASH')
      {
          my $href = shift;
          croak $ODDHASH  if @_%2 != 0  &&  !(@_ == 1  && ref $_[0] eq 'HASH');
          return Hash %$href, @_;
      }
      elsif (ref $_[0])
      {
          croak "Readonly only supports scalar, array, and hash variables.";
      }
      else
      {
          croak "First argument to Readonly must be a reference.";
      }
  }
  SUB_READONLY
  1;
  
  =head1 NAME
  
  Readonly - Facility for creating read-only scalars, arrays, hashes
  
  =head1 Synopsis
  
      use Readonly;
  
      # Deep Read-only scalar
      Readonly::Scalar    $sca => $initial_value;
      Readonly::Scalar my $sca => $initial_value;
  
      # Deep Read-only array
      Readonly::Array    @arr => @values;
      Readonly::Array my @arr => @values;
  
      # Deep Read-only hash
      Readonly::Hash    %has => (key => value, key => value, ...);
      Readonly::Hash my %has => (key => value, key => value, ...);
      # or:
      Readonly::Hash    %has => {key => value, key => value, ...};
  
      # You can use the read-only variables like any regular variables:
      print $sca;
      $something = $sca + $arr[2];
      next if $has{$some_key};
  
      # But if you try to modify a value, your program will die:
      $sca = 7;
      push @arr, 'seven';
      delete $has{key};
      # The error message is "Modification of a read-only value attempted"
  
      # Alternate form (Perl 5.8 and later)
      Readonly    $sca => $initial_value;
      Readonly my $sca => $initial_value;
      Readonly    @arr => @values;
      Readonly my @arr => @values;
      Readonly    %has => (key => value, key => value, ...);
      Readonly my %has => (key => value, key => value, ...);
      Readonly my $sca; # Implicit undef, readonly value
  
      # Alternate form (for Perls earlier than v5.8)
      Readonly    \$sca => $initial_value;
      Readonly \my $sca => $initial_value;
      Readonly    \@arr => @values;
      Readonly \my @arr => @values;
      Readonly    \%has => (key => value, key => value, ...);
      Readonly \my %has => (key => value, key => value, ...);
  
  =head1 Description
  
  This is a facility for creating non-modifiable variables. This is useful for
  configuration files, headers, etc. It can also be useful as a development and
  debugging tool for catching updates to variables that should not be changed.
  
  =head1 Variable Depth
  
  Readonly has the ability to create both deep and shallow readonly variables.
  
  If you pass a C<$ref>, an C<@array> or a C<%hash> to corresponding functions
  C<::Scalar()>, C<::Array()> and C<::Hash()>, then those functions recurse over
  the data structure, marking everything as readonly. The entire structure is
  then non-modifiable. This is normally what you want.
  
  If you want only the top level to be readonly, use the alternate (and poorly
  named) C<::Scalar1()>, C<::Array1()>, and C<::Hash1()> functions.
  
  Plain C<Readonly()> creates what the original author calls a "shallow"
  readonly variable, which is great if you don't plan to use it on anything but
  only one dimensional scalar values.
  
  C<Readonly::Scalar()> makes the variable 'deeply' readonly, so the following
  snippet kills over as you expect:
  
   use Readonly;
  
   Readonly::Scalar my $ref => { 1 => 'a' };
   $ref->{1} = 'b';
   $ref->{2} = 'b';
  
  While the following snippet does B<not> make your structure 'deeply' readonly:
  
   use Readonly;
  
   Readonly my $ref => { 1 => 'a' };
   $ref->{1} = 'b';
   $ref->{2} = 'b';
  
  =head1
  
  =head1 The Past
  
  The following sections are updated versions of the previous authors
  documentation.
  
  =head2 Comparison with "use constant"
  
  Perl provides a facility for creating constant values, via the L<constant>
  pragma. There are several problems with this pragma.
  
  =over 2
  
  =item * The constants created have no leading sigils.
  
  =item * These constants cannot be interpolated into strings.
  
  =item * Syntax can get dicey sometimes.  For example:
  
      use constant CARRAY => (2, 3, 5, 7, 11, 13);
      $a_prime = CARRAY[2];        # wrong!
      $a_prime = (CARRAY)[2];      # right -- MUST use parentheses
  
  =item * You have to be very careful in places where barewords are allowed.
  
  For example:
  
      use constant SOME_KEY => 'key';
      %hash = (key => 'value', other_key => 'other_value');
      $some_value = $hash{SOME_KEY};        # wrong!
      $some_value = $hash{+SOME_KEY};       # right
  
  (who thinks to use a unary plus when using a hash to scalarize the key?)
  
  =item * C<use constant> works for scalars and arrays, not hashes.
  
  =item * These constants are global to the package in which they're declared;
  cannot be lexically scoped.
  
  =item * Works only at compile time.
  
  =item * Can be overridden:
  
      use constant PI => 3.14159;
      ...
      use constant PI => 2.71828;
  
  (this does generate a warning, however, if you have warnings enabled).
  
  =item * It is very difficult to make and use deep structures (complex data
  structures) with C<use constant>.
  
  =back
  
  =head1 Comparison with typeglob constants
  
  Another popular way to create read-only scalars is to modify the symbol table
  entry for the variable by using a typeglob:
  
      *a = \'value';
  
  This works fine, but it only works for global variables ("my" variables have
  no symbol table entry). Also, the following similar constructs do B<not> work:
  
      *a = [1, 2, 3];      # Does NOT create a read-only array
      *a = { a => 'A'};    # Does NOT create a read-only hash
  
  =head2 Pros
  
  Readonly.pm, on the other hand, will work with global variables and with
  lexical ("my") variables. It will create scalars, arrays, or hashes, all of
  which look and work like normal, read-write Perl variables. You can use them
  in scalar context, in list context; you can take references to them, pass them
  to functions, anything.
  
  Readonly.pm also works well with complex data structures, allowing you to tag
  the whole structure as nonmodifiable, or just the top level.
  
  Also, Readonly variables may not be reassigned. The following code will die:
  
      Readonly::Scalar $pi => 3.14159;
      ...
      Readonly::Scalar $pi => 2.71828;
  
  =head2 Cons
  
  Readonly.pm used to impose a performance penalty. It was pretty slow. How
  slow? Run the C<eg/benchmark.pl> script that comes with Readonly. On my test
  system, "use constant" (const), typeglob constants (tglob), regular read/write
  Perl variables (normal/literal), and the new Readonly (ro/ro_simple) are all
  about the same speed, the old, tie based Readonly.pm constants were about 1/22
  the speed.
  
  However, there is relief. There is a companion module available, Readonly::XS.
  You won't need this if you're using Perl 5.8.x or higher.
  
  I repeat, you do not need Readonly::XS if your environment has perl 5.8.x or
  higher. Please see section entitled L<Internals|/"Internals"> for more.
  
  =head1 Functions
  
  =over 4
  
  =item Readonly::Scalar $var => $value;
  
  Creates a nonmodifiable scalar, C<$var>, and assigns a value of C<$value> to
  it. Thereafter, its value may not be changed. Any attempt to modify the value
  will cause your program to die.
  
  A value I<must> be supplied. If you want the variable to have C<undef> as its
  value, you must specify C<undef>.
  
  If C<$value> is a reference to a scalar, array, or hash, then this function
  will mark the scalar, array, or hash it points to as being Readonly as well,
  and it will recursively traverse the structure, marking the whole thing as
  Readonly. Usually, this is what you want. However, if you want only the
  C<$value> marked as Readonly, use C<Scalar1>.
  
  If $var is already a Readonly variable, the program will die with an error
  about reassigning Readonly variables.
  
  =item Readonly::Array @arr => (value, value, ...);
  
  Creates a nonmodifiable array, C<@arr>, and assigns the specified list of
  values to it. Thereafter, none of its values may be changed; the array may not
  be lengthened or shortened or spliced. Any attempt to do so will cause your
  program to die.
  
  If any of the values passed is a reference to a scalar, array, or hash, then
  this function will mark the scalar, array, or hash it points to as being
  Readonly as well, and it will recursively traverse the structure, marking the
  whole thing as Readonly. Usually, this is what you want. However, if you want
  only the hash C<%@arr> itself marked as Readonly, use C<Array1>.
  
  If C<@arr> is already a Readonly variable, the program will die with an error
  about reassigning Readonly variables.
  
  =item Readonly::Hash %h => (key => value, key => value, ...);
  
  =item Readonly::Hash %h => {key => value, key => value, ...};
  
  Creates a nonmodifiable hash, C<%h>, and assigns the specified keys and values
  to it. Thereafter, its keys or values may not be changed. Any attempt to do so
  will cause your program to die.
  
  A list of keys and values may be specified (with parentheses in the synopsis
  above), or a hash reference may be specified (curly braces in the synopsis
  above). If a list is specified, it must have an even number of elements, or
  the function will die.
  
  If any of the values is a reference to a scalar, array, or hash, then this
  function will mark the scalar, array, or hash it points to as being Readonly
  as well, and it will recursively traverse the structure, marking the whole
  thing as Readonly. Usually, this is what you want. However, if you want only
  the hash C<%h> itself marked as Readonly, use C<Hash1>.
  
  If C<%h> is already a Readonly variable, the program will die with an error
  about reassigning Readonly variables.
  
  =item Readonly $var => $value;
  
  =item Readonly @arr => (value, value, ...);
  
  =item Readonly %h => (key => value, ...);
  
  =item Readonly %h => {key => value, ...};
  
  =item Readonly $var;
  
  The C<Readonly> function is an alternate to the C<Scalar>, C<Array>, and
  C<Hash> functions. It has the advantage (if you consider it an advantage) of
  being one function. That may make your program look neater, if you're
  initializing a whole bunch of constants at once. You may or may not prefer
  this uniform style.
  
  It has the disadvantage of having a slightly different syntax for versions of
  Perl prior to 5.8.  For earlier versions, you must supply a backslash, because
  it requires a reference as the first parameter.
  
      Readonly \$var => $value;
      Readonly \@arr => (value, value, ...);
      Readonly \%h   => (key => value, ...);
      Readonly \%h   => {key => value, ...};
  
  You may or may not consider this ugly.
  
  Note that you can create implicit undefined variables with this function like
  so C<Readonly my $var;> while a verbose undefined value must be passed to the
  standard C<Scalar>, C<Array>, and C<Hash> functions.
  
  =item Readonly::Scalar1 $var => $value;
  
  =item Readonly::Array1 @arr => (value, value, ...);
  
  =item Readonly::Hash1 %h => (key => value, key => value, ...);
  
  =item Readonly::Hash1 %h => {key => value, key => value, ...};
  
  These alternate functions create shallow Readonly variables, instead of deep
  ones. For example:
  
      Readonly::Array1 @shal => (1, 2, {perl=>'Rules', java=>'Bites'}, 4, 5);
      Readonly::Array  @deep => (1, 2, {perl=>'Rules', java=>'Bites'}, 4, 5);
  
      $shal[1] = 7;           # error
      $shal[2]{APL}='Weird';  # Allowed! since the hash isn't Readonly
      $deep[1] = 7;           # error
      $deep[2]{APL}='Weird';  # error, since the hash is Readonly
  
  =back
  
  =head1 Cloning
  
  When cloning using L<Storable> or L<Clone> you will notice that the value stays
  readonly, which is correct. If you want to clone the value without copying the
  readonly flag, use the C<Clone> function:
  
      Readonly::Scalar my $scalar => {qw[this that]};
      # $scalar->{'eh'} = 'foo'; # Modification of a read-only value attempted
      my $scalar_clone = Readonly::Clone $scalar;
      $scalar_clone->{'eh'} = 'foo';
      # $scalar_clone is now {this => 'that', eh => 'foo'};
  
  The new variable (C<$scalar_clone>) is a mutable clone of the original
  C<$scalar>.
  
  =head1 Examples
  
  These are a few very simple examples:
  
  =head2 Scalars
  
  A plain old read-only value
  
      Readonly::Scalar $a => "A string value";
  
  The value need not be a compile-time constant:
  
      Readonly::Scalar $a => $computed_value;
  
  =head2 Arrays/Lists
  
  A read-only array:
  
      Readonly::Array @a => (1, 2, 3, 4);
  
  The parentheses are optional:
  
      Readonly::Array @a => 1, 2, 3, 4;
  
  You can use Perl's built-in array quoting syntax:
  
      Readonly::Array @a => qw/1 2 3 4/;
  
  You can initialize a read-only array from a variable one:
  
      Readonly::Array @a => @computed_values;
  
  A read-only array can be empty, too:
  
      Readonly::Array @a => ();
      Readonly::Array @a;        # equivalent
  
  =head2 Hashes
  
  Typical usage:
  
      Readonly::Hash %a => (key1 => 'value1', key2 => 'value2');
  
  A read-only hash can be initialized from a variable one:
  
      Readonly::Hash %a => %computed_values;
  
  A read-only hash can be empty:
  
      Readonly::Hash %a => ();
      Readonly::Hash %a;        # equivalent
  
  If you pass an odd number of values, the program will die:
  
      Readonly::Hash %a => (key1 => 'value1', "value2");
      # This dies with "May not store an odd number of values in a hash"
  
  =head1 Exports
  
  Historically, this module exports the C<Readonly> symbol into the calling
  program's namespace by default. The following symbols are also available for
  import into your program, if you like: C<Scalar>, C<Scalar1>, C<Array>,
  C<Array1>, C<Hash>, and C<Hash1>.
  
  =head1 Internals
  
  Some people simply do not understand the relationship between this module and
  Readonly::XS so I'm adding this section. Odds are, they still won't understand
  but I like to write so...
  
  In the past, Readonly's "magic" was performed by C<tie()>-ing variables to the
  C<Readonly::Scalar>, C<Readonly::Array>, and C<Readonly::Hash> packages (not
  to be confused with the functions of the same names) and acting on C<WRITE>,
  C<READ>, et. al. While this worked well, it was slow. Very slow. Like 20-30
  times slower than accessing variables directly or using one of the other
  const-related modules that have cropped up since Readonly was released in
  2003.
  
  To 'fix' this, Readonly::XS was written. If installed, Readonly::XS used the
  internal methods C<SvREADONLY> and C<SvREADONLY_on> to lock simple scalars. On
  the surface, everything was peachy but things weren't the same behind the
  scenes. In edge cases, code performed very differently if Readonly::XS was
  installed and because it wasn't a required dependency in most code, it made
  downstream bugs very hard to track.
  
  In the years since Readonly::XS was released, the then private internal
  methods have been exposed and can be used in pure perl. Similar modules were
  written to take advantage of this and a patch to Readonly was created. We no
  longer need to build and install another module to make Readonly useful on
  modern builds of perl.
  
  =over
  
  =item * You do not need to install Readonly::XS.
  
  =item * You should stop listing Readonly::XS as a dependency or expect it to
  be installed.
  
  =item * Stop testing the C<$Readonly::XSokay> variable!
  
  =back
  
  =head1 Requirements
  
  Please note that most users of Readonly no longer need to install the
  companion module Readonly::XS which is recommended but not required for perl
  5.6.x and under. Please do not force it as a requirement in new code and do
  not use the package variable C<$Readonly::XSokay> in code/tests. For more, see
  L<the section on Readonly's new internals/Internals>.
  
  There are no non-core requirements.
  
  =head1 Bug Reports
  
  If email is better for you, L<my address is mentioned below|/"Author"> but I
  would rather have bugs sent through the issue tracker found at
  http://github.com/sanko/readonly/issues.
  
  =head1 Acknowledgements
  
  Thanks to Slaven Rezic for the idea of one common function (Readonly) for all
  three types of variables (13 April 2002).
  
  Thanks to Ernest Lergon for the idea (and initial code) for deeply-Readonly
  data structures (21 May 2002).
  
  Thanks to Damian Conway for the idea (and code) for making the Readonly
  function work a lot smoother under perl 5.8+.
  
  =head1 Author
  
  Sanko Robinson <sanko@cpan.org> - http://sankorobinson.com/
  
  CPAN ID: SANKO
  
  Original author: Eric J. Roode, roode@cpan.org
  
  =head1 License and Legal
  
  Copyright (C) 2013-2016 by Sanko Robinson <sanko@cpan.org>
  
  Copyright (c) 2001-2004 by Eric J. Roode. All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
  
  =cut
READONLY

$fatpacked{"String/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_FORMAT';
  package String::Format;
  
  # ----------------------------------------------------------------------
  #  Copyright (C) 2002,2009 darren chamberlain <darren@cpan.org>
  #
  #  This program is free software; you can redistribute it and/or
  #  modify it under the terms of the GNU General Public License as
  #  published by the Free Software Foundation; version 2.
  #
  #  This program is distributed in the hope that it will be useful, but
  #  WITHOUT ANY WARRANTY; without even the implied warranty of
  #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  #  General Public License for more details.
  #
  #  You should have received a copy of the GNU General Public License
  #  along with this program; if not, write to the Free Software
  #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  #  02110-1301 USA.
  # -------------------------------------------------------------------
  
  use strict;
  use vars qw($VERSION @EXPORT);
  use Exporter;
  use base qw(Exporter);
  
  $VERSION = '1.18';
  @EXPORT = qw(stringf);
  
  sub _replace {
      my ($args, $orig, $alignment, $min_width,
          $max_width, $passme, $formchar) = @_;
  
      # For unknown escapes, return the orignial
      return $orig unless defined $args->{$formchar};
  
      $alignment = '+' unless defined $alignment;
  
      my $replacement = $args->{$formchar};
      if (ref $replacement eq 'CODE') {
          # $passme gets passed to subrefs.
          $passme ||= "";
          $passme =~ tr/{}//d;
          $replacement = $replacement->($passme);
      }
  
      my $replength = length $replacement;
      $min_width  ||= $replength;
      $max_width  ||= $replength;
  
      # length of replacement is between min and max
      if (($replength > $min_width) && ($replength < $max_width)) {
          return $replacement;
      }
  
      # length of replacement is longer than max; truncate
      if ($replength > $max_width) {
          return substr($replacement, 0, $max_width);
      }
      
      # length of replacement is less than min: pad
      if ($alignment eq '-') {
          # left align; pad in front
          return $replacement . " " x ($min_width - $replength);
      }
  
      # right align, pad at end
      return " " x ($min_width - $replength) . $replacement;
  }
  
  my $regex = qr/
                 (%             # leading '%'
                  (-)?          # left-align, rather than right
                  (\d*)?        # (optional) minimum field width
                  (?:\.(\d*))?  # (optional) maximum field width
                  (\{.*?\})?    # (optional) stuff inside
                  (\S)          # actual format character
               )/x;
  sub stringf {
      my $format = shift || return;
      my $args = UNIVERSAL::isa($_[0], 'HASH') ? shift : { @_ };
         $args->{'n'} = "\n" unless exists $args->{'n'};
         $args->{'t'} = "\t" unless exists $args->{'t'};
         $args->{'%'} = "%"  unless exists $args->{'%'};
  
      $format =~ s/$regex/_replace($args, $1, $2, $3, $4, $5, $6)/ge;
  
      return $format;
  }
  
  sub stringfactory {
      shift;  # It's a class method, but we don't actually want the class
      my $args = UNIVERSAL::isa($_[0], "HASH") ? shift : { @_ };
      return sub { stringf($_[0], $args) };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  String::Format - sprintf-like string formatting capabilities with
  arbitrary format definitions
  
  =head1 ABSTRACT
  
  String::Format allows for sprintf-style formatting capabilities with
  arbitrary format definitions
  
  =head1 SYNOPSIS
  
    use String::Format;
  
    my %fruit = (
          'a' => "apples",
          'b' => "bannanas",
          'g' => "grapefruits",
          'm' => "melons",
          'w' => "watermelons",
    );
  
    my $format = "I like %a, %b, and %g, but not %m or %w.";
  
    print stringf($format, %fruit);
    
    # prints:
    # I like apples, bannanas, and grapefruits, but not melons or watermelons.
  
  =head1 DESCRIPTION
  
  String::Format lets you define arbitrary printf-like format sequences
  to be expanded.  This module would be most useful in configuration
  files and reporting tools, where the results of a query need to be
  formatted in a particular way.  It was inspired by mutt's index_format
  and related directives (see <URL:http://www.mutt.org/doc/manual/manual-6.html#index_format>).
  
  =head1 FUNCTIONS
  
  =head2 stringf
  
  String::Format exports a single function called stringf.  stringf
  takes two arguments:  a format string (see FORMAT STRINGS, below) and
  a reference to a hash of name => value pairs.  These name => value
  pairs are what will be expanded in the format string.
  
  =head1 FORMAT STRINGS
  
  Format strings must match the following regular expression:
  
    qr/
       (%             # leading '%'
        (-)?          # left-align, rather than right
        (\d*)?        # (optional) minimum field width
        (?:\.(\d*))?  # (optional) maximum field width
        ({.*?})?      # (optional) stuff inside
        (\S)          # actual format character
       )/x;
  
  If the escape character specified does not exist in %args, then the
  original string is used.  The alignment, minimum width, and maximum
  width options function identically to how they are defined in
  sprintf(3) (any variation is a bug, and should be reported).
  
  Note that Perl's sprintf definition is a little more liberal than the
  above regex; the deviations were intentional, and all deal with
  numeric formatting (the #, 0, and + leaders were specifically left
  out).
  
  The value attached to the key can be a scalar value or a subroutine
  reference; if it is a subroutine reference, then anything between the
  '{' and '}' ($5 in the above regex) will be passed as $_[0] to the
  subroutine reference.  This allows for entries such as this:
  
    %args = (
        d => sub { POSIX::strftime($_[0], localtime) }, 
    );
  
  Which can be invoked with this format string:
  
    "It is %{%M:%S}d right now, on %{%A, %B %e}d."
  
  And result in (for example):
  
    It is 17:45 right now, on Monday, February 4.
  
  Note that since the string is passed unmolested to the subroutine
  reference, and strftime would Do The Right Thing with this data, the
  above format string could be written as:
  
    "It is %{%M:%S right now, on %A, %B %e}d."
  
  By default, the formats 'n', 't', and '%' are defined to be a newline,
  tab, and '%', respectively, if they are not already defined in the
  hashref of arguments that gets passed it.  So we can add carriage
  returns simply:
  
    "It is %{%M:%S right now, on %A, %B %e}d.%n"
  
  Because of how the string is parsed, the normal "\n" and "\t" are
  turned into two characters each, and are not treated as a newline and
  tab.  This is a bug.
  
  =head1 FACTORY METHOD
  
  String::Format also supports a class method, named B<stringfactory>,
  which will return reference to a "primed" subroutine.  stringfatory
  should be passed a reference to a hash of value; the returned
  subroutine will use these values as the %args hash.
  
    my $self = Some::Groovy::Package->new($$, $<, $^T);
    my %formats = (
          'i' => sub { $self->id      },
          'd' => sub { $self->date    },
          's' => sub { $self->subject },
          'b' => sub { $self->body    },
    );
    my $index_format = String::Format->stringfactory(\%formats);
  
    print $index_format->($format1);
    print $index_format->($format2);
  
  This subroutine reference can be assigned to a local symbol table
  entry, and called normally, of course:
  
    *reformat = String::Format->stringfactory(\%formats);
  
    my $reformed = reformat($format_string);
  
  =head1 LICENSE
  
  C<String::Format> is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; version 2.
  
  
  =head1 AUTHOR
  
  darren chamberlain <darren@cpan.org>
STRING_FORMAT

$fatpacked{"Test/Perl/Critic/Policy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_PERL_CRITIC_POLICY';
  package Test::Perl::Critic::Policy;
  
  use 5.006001;
  
  use strict;
  use warnings;
  
  use Carp qw< croak confess >;
  use English qw< -no_match_vars >;
  use List::MoreUtils qw< all none >;
  use Readonly;
  
  use Test::Builder qw<>;
  use Test::More;
  
  use Perl::Critic::Violation;
  use Perl::Critic::TestUtils qw<
      pcritique_with_violations fcritique_with_violations subtests_in_tree
  >;
  
  #-----------------------------------------------------------------------------
  
  our $VERSION = '1.132';
  
  #-----------------------------------------------------------------------------
  
  use Exporter 'import';
  
  Readonly::Array our @EXPORT_OK      => qw< all_policies_ok >;
  Readonly::Hash  our %EXPORT_TAGS    => (all => \@EXPORT_OK);
  
  #-----------------------------------------------------------------------------
  
  Perl::Critic::Violation::set_format( "%m at line %l, column %c.  (%r)\n" );
  Perl::Critic::TestUtils::block_perlcriticrc();
  
  #-----------------------------------------------------------------------------
  
  my $TEST = Test::Builder->new();
  
  #-----------------------------------------------------------------------------
  
  sub all_policies_ok {
      my (%args) = @_;
      my $wanted_policies = $args{-policies};
      my $test_dir        = $args{'-test-directory'} || 't';
  
      my $subtests_with_extras =  subtests_in_tree( $test_dir, 'include extras' );
  
      if ($wanted_policies) {
          _validate_wanted_policy_names($wanted_policies, $subtests_with_extras);
          _filter_unwanted_subtests($wanted_policies, $subtests_with_extras);
      }
  
      $TEST->plan( tests => _compute_test_count($subtests_with_extras) );
      my $policies_to_test = join q{, }, keys %{$subtests_with_extras};
      $TEST->note("Running tests for policies: $policies_to_test");
  
      for my $policy ( sort keys %{$subtests_with_extras} ) {
  
          my ($full_policy_name, $method) = ("Perl::Critic::Policy::$policy", 'violates');
          my $can_ok_label = qq{Class '$full_policy_name' has method '$method'};
          $TEST->ok( $full_policy_name->can($method), $can_ok_label );
  
          for my $subtest ( @{ $subtests_with_extras->{$policy}{subtests} } ) {
              my $todo = $subtest->{TODO};
              if ($todo) { $TEST->todo_start( $todo ); }
  
              my ($error, @violations) = _run_subtest($policy, $subtest);
              my ($ok, @diag)= _evaluate_test_results($subtest, $error, \@violations);
              $TEST->ok( $ok, _create_test_name($policy, $subtest) );
  
              if (@diag) { $TEST->diag(@diag); }
              if ($todo) { $TEST->todo_end(); }
          }
      }
  
      return;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _validate_wanted_policy_names {
      my ($wanted_policies, $subtests_with_extras) = @_;
      return 1 if not $wanted_policies;
      my @all_testable_policies = keys %{ $subtests_with_extras };
      my @wanted_policies = @{ $wanted_policies };
  
  
      my @invalid = grep {my $p = $_; none { $_ =~ $p } @all_testable_policies}  @wanted_policies;
      croak( q{No tests found for policies matching: } . join q{, }, @invalid ) if @invalid;
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _filter_unwanted_subtests {
      my ($wanted_policies, $subtests_with_extras) = @_;
      return 1 if not $wanted_policies;
      my @all_testable_policies = keys %{ $subtests_with_extras };
      my @wanted_policies = @{ $wanted_policies };
  
      for my $p (@all_testable_policies) {
          if (none {$p =~ m/$_/xism} @wanted_policies) {
              delete $subtests_with_extras->{$p}; # side-effects!
          }
      }
      return 1;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _run_subtest {
      my ($policy, $subtest) = @_;
  
      my @violations;
      my $error;
      if ( $subtest->{filename} ) {
          eval {
              @violations =
                  fcritique_with_violations(
                      $policy,
                      \$subtest->{code},
                      $subtest->{filename},
                      $subtest->{parms},
                  );
              1;
          } or do {
              $error = $EVAL_ERROR || 'An unknown problem occurred.';
          };
      }
      else {
          eval {
              @violations =
                  pcritique_with_violations(
                      $policy,
                      \$subtest->{code},
                      $subtest->{parms},
                  );
              1;
          } or do {
              $error = $EVAL_ERROR || 'An unknown problem occurred.';
          };
      }
  
      return ($error, @violations);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _evaluate_test_results {
      my ($subtest, $error, $violations) = @_;
  
      if ($subtest->{error}) {
          return _evaluate_error_case($subtest, $error);
      }
      elsif ($error) {
          confess $error;
      }
      else {
          return _evaluate_violation_case($subtest, $violations);
      }
  }
  
  #-----------------------------------------------------------------------------
  
  sub _evaluate_violation_case {
      my ($subtest, $violations) = @_;
      my ($ok, @diagnostics);
  
      my @violations = @{$violations};
      my $have = scalar @violations;
      my $want = _compute_wanted_violation_count($subtest);
      if ( not $ok = $have == $want ) {
          my $msg = qq(Expected $want violations, got $have. );
          if (@violations) { $msg .= q(Found violations follow...); }
          push @diagnostics, $msg . "\n";
          push @diagnostics, map { qq(Found violation: $_) } @violations;
      }
  
      return ($ok, @diagnostics)
  }
  
  #-----------------------------------------------------------------------------
  
  sub _evaluate_error_case {
      my ($subtest, $error) = @_;
      my ($ok, @diagnostics);
  
      if ( 'Regexp' eq ref $subtest->{error} ) {
          $ok = $error =~ $subtest->{error}
            or push @diagnostics, qq(Error message '$error' doesn't match $subtest->{error}.);
      }
      else {
          $ok = $subtest->{error}
            or push @diagnostics, q(Didn't get an error message when we expected one.);
      }
  
      return ($ok, @diagnostics);
  }
  
  #-----------------------------------------------------------------------------
  
  sub _compute_test_count {
      my ($subtests_with_extras) = @_;
  
      # one can_ok() for each policy
      my $npolicies = scalar keys %{ $subtests_with_extras };
  
      my $nsubtests = 0;
      for my $subtest_with_extras ( values %{$subtests_with_extras} ) {
          # one [pf]critique() test per subtest
          $nsubtests += @{ $subtest_with_extras->{subtests} };
      }
  
      return $nsubtests + $npolicies;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _compute_wanted_violation_count {
      my ($subtest) = @_;
  
      # If any optional modules are NOT available, then there should be no violations.
      return 0 if not _all_optional_modules_are_available($subtest);
      return $subtest->{failures};
  }
  
  #-----------------------------------------------------------------------------
  
  sub _all_optional_modules_are_available {
      my ($subtest) = @_;
      my $optional_modules = $subtest->{optional_modules} or return 1;
      return all {eval "require $_;" or 0;} split m/,\s*/xms, $optional_modules;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _create_test_name {
      my ($policy, $subtest) = @_;
      return join ' - ', $policy, "line $subtest->{lineno}", $subtest->{name};
  }
  
  #-----------------------------------------------------------------------------
  1;
  
  __END__
  
  #-----------------------------------------------------------------------------
  
  =pod
  
  =for stopwords subtest subtests RCS
  
  =head1 NAME
  
  Test::Perl::Critic::Policy - A framework for testing your custom Policies
  
  =head1 SYNOPSIS
  
      use Test::Perl::Critic::Policy qw< all_policies_ok >;
  
      # Assuming .run files are inside 't' directory...
      all_policies_ok()
  
      # Or if your .run files are in a different directory...
      all_policies_ok( '-test-directory' => 'run' );
  
      # And if you just want to run tests for some polices...
      all_policies_ok( -policies => ['Some::Policy', 'Another::Policy'] );
  
      # If you want your test program to accept short Policy names as
      # command-line parameters...
      #
      # You can then test a single policy by running
      # "perl -Ilib t/policy-test.t My::Policy".
      my %args = @ARGV ? ( -policies => [ @ARGV ] ) : ();
      all_policies_ok(%args);
  
  
  =head1 DESCRIPTION
  
  This module provides a framework for function-testing your custom
  L<Perl::Critic::Policy|Perl::Critic::Policy> modules.  Policy testing usually
  involves feeding it a string of Perl code and checking its behavior.  In the
  old days, those strings of Perl code were mixed directly in the test script.
  That sucked.
  
  B<NOTE:> This module is alpha code -- interfaces and implementation are
  subject to major changes.  This module is an integral part of building and
  testing L<Perl::Critic|Perl::Critic> itself, but you should not write any code
  against this module until it has stabilized.
  
  
  =head1 IMPORTABLE SUBROUTINES
  
  =over
  
  =item all_policies_ok('-test-directory' => $path, -policies => \@policy_names)
  
  Loads all the F<*.run> files beneath the C<-test-directory> and runs the
  tests.  If C<-test-directory> is not specified, it defaults to F<t/>.
  C<-policies> is an optional reference to an array of shortened Policy names.
  If C<-policies> specified, only the tests for Policies that match one of the
  C<m/$POLICY_NAME/imx> will be run.
  
  
  =back
  
  
  =head1 CREATING THE *.run FILES
  
  Testing a policy follows a very simple pattern:
  
      * Policy name
          * Subtest name
          * Optional parameters
          * Number of failures expected
          * Optional exception expected
          * Optional filename for code
  
  Each of the subtests for a policy is collected in a single F<.run>
  file, with test properties as comments in front of each code block
  that describes how we expect Perl::Critic to react to the code.  For
  example, say you have a policy called Variables::ProhibitVowels:
  
      (In file t/Variables/ProhibitVowels.run)
  
      ## name Basics
      ## failures 1
      ## cut
  
      my $vrbl_nm = 'foo';    # Good, vowel-free name
      my $wango = 12;         # Bad, pronouncable name
  
  
      ## name Sometimes Y
      ## failures 1
      ## cut
  
      my $yllw = 0;       # "y" not a vowel here
      my $rhythm = 12;    # But here it is
  
  These are called "subtests", and two are shown above.  The beauty of
  incorporating multiple subtests in a file is that the F<.run> is
  itself a (mostly) valid Perl file, and not hidden in a HEREDOC, so
  your editor's color-coding still works, and it is much easier to work
  with the code and the POD.
  
  If you need to pass any configuration parameters for your subtest, do
  so like this:
  
      ## parms { allow_y => '0' }
  
  Note that all the values in this hash must be strings because that's
  what Perl::Critic will hand you from a F<.perlcriticrc>.
  
  If it's a TODO subtest (probably because of some weird corner of PPI
  that we exercised that Adam is getting around to fixing, right?), then
  make a C<##TODO> entry.
  
      ## TODO Should pass when PPI 1.xxx comes out
  
  If the code is expected to trigger an exception in the policy,
  indicate that like so:
  
      ## error 1
  
  If you want to test the error message, mark it with C</.../> to
  indicate a C<like()> test:
  
      ## error /Can't load Foo::Bar/
  
  If the policy you are testing cares about the filename of the code,
  you can indicate that C<fcritique> should be used like so (see
  C<fcritique> for more details):
  
      ## filename lib/Foo/Bar.pm
  
  The value of C<parms> will get C<eval>ed and passed to C<pcritique()>,
  so be careful.
  
  In general, a subtest document runs from the C<## cut> that starts it to
  either the next C<## name> or the end of the file. In very rare circumstances
  you may need to end the test document earlier. A second C<## cut> will do
  this. The only known need for this is in
  F<t/Miscellanea/RequireRcsKeywords.run>, where it is used to prevent the RCS
  keywords in the file footer from producing false positives or negatives in the
  last test.
  
  Note that nowhere within the F<.run> file itself do you specify the
  policy that you're testing.  That's implicit within the filename.
  
  
  =head1 BUGS AND CAVEATS AND TODO ITEMS
  
  Add policy_ok() method for running subtests in just a single TODO file.
  
  Can users mark this entire test as TODO or SKIP, using the normal mechanisms?
  
  Allow us to specify the nature of the failures, and which one.  If there are
  15 lines of code, and six of them fail, how do we know they're the right six?
  
  Consolidate code from L<Perl::Critic::TestUtils|Perl::Critic::TestUtils> and possibly deprecate some
  functions there.
  
  Write unit tests for this module.
  
  Test that we have a t/*/*.run for each lib/*/*.pm
  
  =head1 AUTHOR
  
  Andy Lester, Jeffrey Ryan Thalhammer <thaljef@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2009-2011 Andy Lester.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.  The full text of this license
  can be found in the LICENSE file included with this module.
  
  =cut
  
  ##############################################################################
  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  #   indent-tabs-mode: nil
  #   c-indentation-style: bsd
  # End:
  # ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
TEST_PERL_CRITIC_POLICY

$fatpacked{"darwin-2level/Clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLONE';
  package Clone;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);
  
  require Exporter;
  require DynaLoader;
  require AutoLoader;
  
  @ISA       = qw(Exporter DynaLoader);
  @EXPORT    = qw();
  @EXPORT_OK = qw( clone );
  
  $VERSION = '0.39';
  
  bootstrap Clone $VERSION;
  
  1;
  __END__
  
  =head1 NAME
  
  Clone - recursively copy Perl datatypes
  
  =for html
  <a href="https://travis-ci.org/garu/Clone"><img src="https://travis-ci.org/garu/Clone.png?branch=master" alt="Build Status"></a>
  <a href="https://coveralls.io/r/garu/Clone?branch=master"><img src="https://coveralls.io/repos/garu/Clone/badge.png?branch=master" alt="Coverage Status"></a>
  <a href="https://metacpan.org/pod/Clone"><img src="https://badge.fury.io/pl/Clone.svg" alt="CPAN version"></a>
  
  =head1 SYNOPSIS
  
      use Clone 'clone';
  
      my $data = {
         set => [ 1 .. 50 ],
         foo => {
             answer => 42,
             object => SomeObject->new,
         },
      };
  
      my $cloned_data = clone($data);
  
      $cloned_data->{foo}{answer} = 1;
      print $cloned_data->{foo}{answer};  # '1'
      print $data->{foo}{answer};         # '42'
  
  You can also add it to your class:
  
      package Foo;
      use parent 'Clone';
      sub new { bless {}, shift }
  
      package main;
  
      my $obj = Foo->new;
      my $copy = $obj->clone;
  
  =head1 DESCRIPTION
  
  This module provides a C<clone()> method which makes recursive
  copies of nested hash, array, scalar and reference types,
  including tied variables and objects.
  
  C<clone()> takes a scalar argument and duplicates it. To duplicate lists,
  arrays or hashes, pass them in by reference, e.g.
  
      my $copy = clone (\@array);
  
      # or
  
      my %copy = %{ clone (\%hash) };
  
  =head1 SEE ALSO
  
  L<Storable>'s C<dclone()> is a flexible solution for cloning variables,
  albeit slower for average-sized data structures. Simple
  and naive benchmarks show that Clone is faster for data structures
  with 3 or fewer levels, while C<dclone()> can be faster for structures
  4 or more levels deep.
  
  =head1 COPYRIGHT
  
  Copyright 2001-2017 Ray Finch. All Rights Reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Ray Finch C<< <rdf@cpan.org> >>
  
  Breno G. de Oliveira C<< <garu@cpan.org> >> and
  Florian Ragwitz C<< <rafl@debian.org> >> perform routine maintenance
  releases since 2012.
  
  =cut
DARWIN-2LEVEL_CLONE

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DARWIN-2LEVEL_PARAMS_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


package main;

use 5.006001;
use strict;
use warnings;

use Perl::Critic::Command qw< run >;

#-----------------------------------------------------------------------------

our $VERSION = '1.132';

#-----------------------------------------------------------------------------
# Begin program.  Don't run when loaded as a library

# This %ENV check is to allow perlcritic to function when bundled under PAR,
# which invokes this program not as the top stack frame. -- rjbs, 2008-08-11
exit run() if not caller or $ENV{PAR_0};

#-----------------------------------------------------------------------------
1;

__END__

#-----------------------------------------------------------------------------

=pod

=for stopwords DGR INI-style vim-fu minibuffer -noprofile API
-profileproto -profile-proto ben Jore formatter Peshak pbp Komodo
screenshots tty emacs gVIM plugin Perlish templating ActivePerl
ActiveState Twitter

=head1 NAME

C<perlcritic> - Command-line interface to critique Perl source.


=head1 SYNOPSIS

  perlcritic [-12345 | --brutal | --cruel | --harsh | --stern | --gentle]
             [--severity number | name] [{-p | --profile} file | --noprofile]
             [--top [ number ]] [--theme expression] [--include pattern]
             [--exclude pattern] [{-s | --single-policy} pattern]
             [--only | --noonly] [--profile-strictness {warn|fatal|quiet}]
             [--force | --noforce] [--statistics] [--statistics-only]
             [--count | -C] [--verbose {number | format}] [--allow-unsafe]
             [--color | --nocolor] [--pager pager] [--quiet]
             [--color-severity-highest color_specification]
             [--color-severity-high color_specification]
             [--color-severity-medium color_specification]
             [--color-severity-low color_specification]
             [--color-severity-lowest color_specification]
             [--files-with-violations | -l]
             [--files-without-violations | -L]
             [--program-extensions file_name_extension]
             {FILE | DIRECTORY | STDIN}

  perlcritic --profile-proto

  perlcritic { --list | --list-enabled | --list-themes | --doc pattern [...] }

  perlcritic { --help | --options | --man | --version }


=head1 DESCRIPTION

C<perlcritic> is a Perl source code analyzer.  It is the executable front-end
to the L<Perl::Critic> engine, which attempts to identify awkward, hard to
read, error-prone, or unconventional constructs in your code. Most of the
rules are based on Damian Conway's book B<Perl Best Practices>. However,
C<perlcritic> is B<not> limited to enforcing PBP, and it will even support
rules that contradict Conway.  All rules can easily be configured or disabled
to your liking.

This documentation only covers how to drive this command.  For all other
information, such as API reference and alternative interfaces, please see the
documentation for L<Perl::Critic> itself.


=head1 USAGE EXAMPLES

Before getting into all the gory details, here are some basic usage
examples to help get you started.

    # Report only most severe violations (severity = 5)
    perlcritic YourModule.pm

    # Same as above, but read input from STDIN
    perlcritic

    # Recursively process all Perl files beneath directory
    perlcritic /some/directory

    # Report slightly less severe violations too (severity >= 4)
    perlcritic -4 YourModule.pm

    # Same as above, but using named severity level
    perlcritic --stern YourModule.pm

    # Report all violations, regardless of severity (severity >= 1)
    perlcritic -1 YourModule.pm

    # Same as above, but using named severity level
    perlcritic --brutal YourModule.pm

    # Report only violations of things from "Perl Best Practices"
    perlcritic --theme pbp YourModule.pm

    # Report top 20 most severe violations (severity >= 1)
    perlcritic --top YourModule.pm

    # Report additional violations of Policies that match m/variables/xms
    perlcritic --include variables YourModule.pm

    # Use defaults from somewhere other than ~/.perlcriticrc
    perlcritic --profile project/specific/perlcriticrc YourModule.pm


=head1 ARGUMENTS

The arguments are paths to the files you wish to analyze.  You may specify
multiple files.  If an argument is a directory, C<perlcritic> will analyze all
Perl files below the directory.  If no arguments are specified, then input is
read from STDIN.


=head1 OPTIONS

Option names can be abbreviated to uniqueness and can be stated with singe or
double dashes, and option values can be separated from the option name by a
space or '=' (as with L<Getopt::Long>). Option names are also case-sensitive.

=over

=item C<--profile FILE> or C<-p FILE>

Directs C<perlcritic> to use a profile named by FILE rather than looking for
the default F<.perlcriticrc> file in the current directory or your home
directory.  See L<Perl::Critic/"CONFIGURATION"> for more information.

=item C<--noprofile>

Directs C<perlcritic> not to load any configuration file, thus reverting to
the default configuration for all Policies.

=item C<--severity N>

Directs C<perlcritic> to only apply Policies with a severity greater than
C<N>.  Severity values are integers ranging from 1 (least severe) to 5 (most
severe).  The default is 5.  For a given C<--profile>, decreasing the
C<--severity> will usually produce more violations. You can set the default
value for this option in your F<.perlcriticrc> file.  You can also redefine
the C<severity> for any Policy in your F<.perlcriticrc> file.  See
L<"CONFIGURATION"> for more information.

=item C<-5 | -4 | -3 | -2 | -1>

These are numeric shortcuts for setting the C<--severity> option.  For
example, C<"-4"> is equivalent to C<"--severity 4">.  If multiple shortcuts
are specified, then the most restrictive one wins.  If an explicit
C<--severity> option is also given, then all shortcut options are silently
ignored.  NOTE: Be careful not to put one of the number severity shortcut
options immediately after the C<--top> flag or C<perlcritic> will interpret it
as the number of violations to report.

=item C<--severity NAME>

If it is difficult for you to remember whether severity "5" is the most or
least restrictive level, then you can use one of these named values:

    SEVERITY NAME   ...is equivalent to...   SEVERITY NUMBER
    --------------------------------------------------------
    --severity gentle                           --severity 5
    --severity stern                            --severity 4
    --severity harsh                            --severity 3
    --severity cruel                            --severity 2
    --severity brutal                           --severity 1

=item C<--gentle | --stern | --harsh | --cruel | --brutal>

These are named shortcuts for setting the C<--severity> option.  For example,
C<"--cruel"> is equivalent to C<"--severity 2">.  If multiple shortcuts are
specified, then the most restrictive one wins.  If an explicit C<--severity>
option is also given, then all shortcut options are silently ignored.

=item C<--theme RULE>

Directs C<perlcritic> to apply only Policies with themes that satisfy the
C<RULE>.  Themes are arbitrary names for groups of related policies.  You can
combine theme names with boolean operators to create an arbitrarily complex
C<RULE>.  For example, the following would apply only Policies that have a
'bugs' AND 'pbp' theme:

    $> perlcritic --theme='bugs && pbp' MyModule.pm

Unless the C<--severity> option is explicitly given, setting C<--theme>
silently causes the C<--severity> to be set to 1.  You can set the default
value for this option in your F<.perlcriticrc> file. See
L<Perl::Critic/"POLICY THEMES"> for more information about themes.

=item C<--include PATTERN>

Directs C<perlcritic> to apply additional Policies that match the regex
C</PATTERN/imx>.  Use this option to temporarily override your profile and/or
the severity settings at the command-line.  For example:

    perlcritic --include=layout my_file.pl

This would cause C<perlcritic> to apply all the C<CodeLayout::*> policies even
if they have a severity level that is less than the default level of 5, or
have been disabled in your F<.perlcriticrc> file.  You can specify multiple
C<--include> options and you can use it in conjunction with the C<--exclude>
option.  Note that C<--exclude> takes precedence over C<--include> when a
Policy matches both patterns.  You can set the default value for this option
in your F<.perlcriticrc> file.

=item C<--exclude PATTERN>

Directs C<perlcritic> to not apply any Policy that matches the regex
C</PATTERN/imx>.  Use this option to temporarily override your profile and/or
the severity settings at the command-line.  For example:

    perlcritic --exclude=strict my_file.pl

This would cause C<perlcritic> to not apply the C<RequireUseStrict> and
C<ProhibitNoStrict> Policies even though they have the highest severity level.
You can specify multiple C<--exclude> options and you can use it in
conjunction with the C<--include> option.  Note that C<--exclude> takes
precedence over C<--include> when a Policy matches both patterns.  You can set
the default value for this option in your F<.perlcriticrc> file.

=item C<--single-policy PATTERN> or C<-s PATTERN>

Directs C<perlcritic> to apply just one Policy module matching the regex
C</PATTERN/ixms>, and exclude all other Policies.  This option has precedence
over the C<--severity>, C<--theme>, C<--include>, C<--exclude>, and C<--only>
options.  For example:

    perlcritic --single-policy=nowarnings my_file.pl

This would cause C<perlcritic> to apply just the C<ProhibitNoWarnings> Policy,
regardless of the severity level setting.  No other Policies would be applied.

This is equivalent to what one might intend by...

    perlcritic --exclude=. --include=nowarnings my_file.pl

... but this won't work because the C<--exclude> option overrides the
C<--include> option.

The equivalent of this option can be accomplished by creating a custom profile
containing only the desired policy and then running...

    perlcritic --profile=customprofile --only my_file.pl

=item C<--top [ N ]>

Directs C<perlcritic> to report only the top C<N> Policy violations in each
file, ranked by their severity.  If C<N> is not specified, it defaults to 20.
If the C<--severity> option (or one of the shortcuts) is not explicitly given,
the C<--top> option implies that the minimum severity level is "1" (i.e.
"brutal"). Users can redefine the severity for any Policy in their
F<.perlcriticrc> file.  See L<"CONFIGURATION"> for more information.  You can
set the default value for this option in your F<.perlcriticrc> file.  NOTE: Be
careful not to put one of the severity shortcut options immediately after the
C<--top> flag or C<perlcritic> will interpret it as the number of violations
to report.

=item C<--force>

Directs C<perlcritic> to ignore the magical C<"## no critic"> annotations in
the source code. See L<"BENDING THE RULES"> for more information.  You can set
the default value for this option in your F<.perlcriticrc> file.

=item C<--statistics>

Causes several statistics about the code being scanned and the violations
found to be reported after any other output.

=item C<--statistics-only>

Like the C<--statistics> option, but suppresses normal output and only shows
the statistics.

=item C<--verbose N | FORMAT>

Sets the verbosity level or format for reporting violations.  If given a
number (C<N>), C<perlcritic> reports violations using one of the predefined
formats described below.  If given a string (C<FORMAT>), it is interpreted to
be an actual format specification.  If the C<--verbose> option is not
specified, it defaults to either 4 or 5, depending on whether multiple files
were given as arguments to C<perlcritic>.  You can set the default value for
this option in your F<.perlcriticrc> file.

    Verbosity     Format Specification
    -----------   -------------------------------------------------------
     1            "%f:%l:%c:%m\n",
     2            "%f: (%l:%c) %m\n",
     3            "%m at %f line %l\n",
     4            "%m at line %l, column %c.  %e.  (Severity: %s)\n",
     5            "%f: %m at line %l, column %c.  %e.  (Severity: %s)\n",
     6            "%m at line %l, near '%r'.  (Severity: %s)\n",
     7            "%f: %m at line %l near '%r'.  (Severity: %s)\n",
     8            "[%p] %m at line %l, column %c.  (Severity: %s)\n",
     9            "[%p] %m at line %l, near '%r'.  (Severity: %s)\n",
    10            "%m at line %l, column %c.\n  %p (Severity: %s)\n%d\n",
    11            "%m at line %l, near '%r'.\n  %p (Severity: %s)\n%d\n"

Formats are a combination of literal and escape characters similar to the way
C<sprintf> works.  See L<String::Format|String::Format> for a full explanation
of the formatting capabilities.  Valid escape characters are:

    Escape    Meaning
    -------   ------------------------------------------------------------
    %c        Column number where the violation occurred
    %d        Full diagnostic discussion of the violation
    %e        Explanation of violation or page numbers in PBP
    %F        Just the name of the file where the violation occurred.
    %f        Path to the file where the violation occurred.
    %l        Line number where the violation occurred
    %m        Brief description of the violation
    %P        Full name of the Policy module that created the violation
    %p        Name of the Policy without the Perl::Critic::Policy:: prefix
    %r        The string of source code that caused the violation
    %C        The class of the PPI::Element that caused the violation
    %s        The severity level of the violation

The purpose of these formats is to provide some compatibility with text
editors that have an interface for parsing certain kinds of input. See
L<"EDITOR INTEGRATION"> for more information about that.

=item C<--list>

Displays a condensed listing of all the L<Perl::Critic::Policy> modules that
are found on this machine.  This option lists I<all> Policies, regardless of
your F<.perlcriticrc> or command line options.  For each Policy, the name,
default severity and default themes are shown.

=item C<--list-enabled>

Displays a condensed listing of all the L<Perl::Critic::Policy> modules that
I<would> be enforced, if you were actually going to critique a file with this
command. This is useful when you've constructed a complicated command or
modified your F<.perlcriticrc> file and you want to see exactly which Policies
are going to be enforced (or not enforced, as the case may be). For each
Policy, the name, default severity and default themes are shown.

=item C<--list-themes>

Displays a list of all the themes of the L<Perl::Critic::Policy> modules that
are found on this machine.

=item C<--profile-proto>

Displays an expanded listing of all the L<Perl::Critic::Policy> modules that
are found on this machine.  For each Policy, the name, default severity and
default themes are shown, as well as the name of any additional parameters
that the Policy supports.  The format is suitable as a prototype for your
F<.perlcriticrc> file.

=item C<--only>

Directs perlcritic to apply only Policies that are explicitly mentioned in
your F<.perlcriticrc> file.  This is useful if you want to use just a small
subset of Policies without having to disable all the others.  You can set the
default value for this option in your F<.perlcriticrc> file.

=item C<--profile-strictness {warn|fatal|quiet}>

Directs perlcritic how to treat certain recoverable problems found in a
F<.perlcriticrc> or file specified via the C<--profile> option. Valid values
are C<warn> (the default), C<fatal>, and C<quiet>.  For example, perlcritic
normally only warns about profiles referring to non-existent Policies, but
this option can make this situation fatal. You can set the default value for
this option in your F<.perlcriticrc> file.

=item C<--count>

=item C<-C>

Display only the number of violations for each file.  Use this feature to get
a quick handle on where a large pile of code might need the most attention.

=item C<--color>

=item C<--colour>

This option is on when outputting to a tty.  When set, Severity 5 and 4 are
colored red and yellow, respectively.  Colorization only happens if
L<Term::ANSIColor> is installed. For Windows environments,
L<Win32::Console::ANSI> must also be installed.
Negate this switch to disable color.  You can set the default value for this
option in your F<.perlcriticrc> file.

=item C<--pager PAGER_COMMAND_STRING>

If set, perlcritic will pipe it's output to the given PAGER_COMMAND_STRING.
You can set the default value for this option in your F<.perlcriticrc> file.

Setting a pager turns off color by default.  You will have to turn color on
explicitly.  If you want color, you'll probably also want to tell your pager
to display raw characters.  For C<less> and C<more>, use the -R switch.

=item C<--color-severity-highest COLOR_SPECIFICATION>

Specifies the color to be used for highest severity violations, as a
Term::ANSIColor color specification. Can also be specified as C<--colour-
severity-highest>, C<--color-severity-5>, or C<--colour-severity-5>.

=item C<--color-severity-high COLOR_SPECIFICATION>

Specifies the color to be used for high severity violations, as a
Term::ANSIColor color specification. Can also be specified as C<--colour-
severity-high>, C<--color-severity-4>, or C<--colour-severity-4>.

=item C<--color-severity-medium COLOR_SPECIFICATION>

Specifies the color to be used for medium severity violations, as a
Term::ANSIColor color specification. Can also be specified as C<--colour-
severity-medium>, C<--color-severity-3>, or C<--colour-severity-3>.

=item C<--color-severity-low COLOR_SPECIFICATION>

Specifies the color to be used for low severity violations, as a
Term::ANSIColor color specification. Can also be specified as C<--colour-
severity-low>, C<--color-severity-2>, or C<--colour-severity-2>.

=item C<--color-severity-lowest COLOR_SPECIFICATION>

Specifies the color to be used for lowest severity violations, as a
Term::ANSIColor color specification. Can also be specified as C<--colour-
severity-lowest>, C<--color-severity-1>, or C<--colour-severity-1>.

=item C<--files-with-violations>

Display only the names of files with violations.  Use this feature with
--single-policy to find files that contain violations of a given policy. Can
also be specified as C<--l>.

=item C<--files-without-violations>

Display only the names of files without violations.  Use this feature with
--single-policy to find files that do not contain violations of a given
policy. Can also be specified as C<--L>.

=item C<--program-extensions file_name_extension>

Tell C<perlcritic> to treat files whose names end in the given file name
extension as programs, not as modules. If a leading '.' is desired it must be
explicitly specified, e.g.

    --program-extensions .pl

The matching is case-sensitive, and the option may be specified as many times
as desired, e.g.

    --program-extensions .pl --program-extensions .cgi

The above can also be done by quoting the file name extensions:

    --program-extensions '.pl .cgi'

Files whose name ends in '.PL' will always be considered programs.

=item C<--doc PATTERN>

Displays the perldoc for all L<Perl::Critic::Policy> modules that match
C<m/PATTERN/ixms>.  Since Policy modules tend to have rather long names, this
just provides a more convenient way to say something like: C<"perldoc
Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseH
eredocTerminator"> at the command prompt.

=item C<--allow-unsafe>

This option directs C<perlcritic> to allow the use of Policies that have been
marked as "unsafe".  Unsafe Policies may result in risky operations by
compiling and executing the code they analyze.  All the Policies that ship in
the core L<Perl::Critic> distribution are safe.  However, third- party
Policies, such as those in the L<Perl::Critic::Dynamic> distribution are not
safe. Note that "safety" is honorary -- if a Policy author marks a Policy as
safe, it is not a guarantee that it won't do nasty things.  B<If you don't
trust your Policies and the code you are analyzing, then do not use this
switch>.

=item C<--quiet>

Suppress the "source OK" message when no violations are found.

=item C<--help>

=item C<-?>

=item C<-H>

Displays a brief summary of options and exits.

=item C<--options>

Displays the descriptions of the options and exits.  While this output is
long, it it nowhere near the length of the output of C<--man>.

=item C<--man>

Displays the complete C<perlcritic> manual and exits.

=item C<--version>

=item C<-V>

Displays the version number of C<perlcritic> and exits.

=back

=head1 CONFIGURATION

Most of the settings for Perl::Critic and each of the Policy modules can be
controlled by a configuration file.  The default configuration file is called
F<.perlcriticrc>.  C<perlcritic> will look for this file in the current
directory first, and then in your home directory. Alternatively, you can set
the C<PERLCRITIC> environment variable to explicitly point to a different file
in another location.  If none of these files exist, and the C<--profile>
option is not given on the command-line, then all Policies will be loaded with
their default configuration.

The format of the configuration file is a series of INI-style blocks that
contain key-value pairs separated by "=". Comments should start with "#" and
can be placed on a separate line or after the name-value pairs if you desire.

Default settings for perlcritic itself can be set B<before the first named
block.> For example, putting any or all of these at the top of your
F<.perlcriticrc> file will set the default value for the corresponding
command-line argument.

    severity  = 3                                     #Integer or named level
    only      = 1                                     #Zero or One
    force     = 0                                     #Zero or One
    verbose   = 4                                     #Integer or format spec
    top       = 50                                    #A positive integer
    theme     = (pbp + security) * bugs               #A theme expression
    include   = NamingConventions ClassHierarchies    #Space-delimited list
    exclude   = Variables  Modules::RequirePackage    #Space-delimited list

The remainder of the configuration file is a series of blocks like this:

    [Perl::Critic::Policy::Category::PolicyName]
    severity = 1
    set_themes = foo bar
    add_themes = baz
    arg1 = value1
    arg2 = value2

C<Perl::Critic::Policy::Category::PolicyName> is the full name of a module
that implements the policy.  The Policy modules distributed with Perl::Critic
have been grouped into categories according to the table of contents in Damian
Conway's book B<Perl Best Practices>. For brevity, you can omit the
C<'Perl::Critic::Policy'> part of the module name.

C<severity> is the level of importance you wish to assign to the Policy.  All
Policy modules are defined with a default severity value ranging from 1 (least
severe) to 5 (most severe).  However, you may disagree with the default
severity and choose to give it a higher or lower severity, based on your own
coding philosophy.  You can set the C<severity> to an integer from 1 to 5, or
use one of the equivalent names:

    SEVERITY NAME ...is equivalent to... SEVERITY NUMBER
    ----------------------------------------------------
    gentle                                             5
    stern                                              4
    harsh                                              3
    cruel                                              2
    brutal                                             1

C<set_themes> sets the theme for the Policy and overrides its default theme.
The argument is a string of one or more whitespace-delimited alphanumeric
words.  Themes are case-insensitive.  See L<"POLICY THEMES"> for more
information.

C<add_themes> appends to the default themes for this Policy.  The argument is
a string of one or more whitespace-delimited words. Themes are case-
insensitive.  See L<"POLICY THEMES"> for more information.

The remaining key-value pairs are configuration parameters that will be passed
into the constructor of that Policy.  The constructors for most Policy modules
do not support arguments, and those that do should have reasonable defaults.
See the documentation on the appropriate Policy module for more details.

Instead of redefining the severity for a given Policy, you can completely
disable a Policy by prepending a '-' to the name of the module in your
configuration file.  In this manner, the Policy will never be loaded,
regardless of the C<--severity> given on the command line.

A simple configuration might look like this:

    #--------------------------------------------------------------
    # I think these are really important, so always load them

    [TestingAndDebugging::RequireUseStrict]
    severity = 5

    [TestingAndDebugging::RequireUseWarnings]
    severity = 5

    #--------------------------------------------------------------
    # I think these are less important, so only load when asked

    [Variables::ProhibitPackageVars]
    severity = 2

    [ControlStructures::ProhibitPostfixControls]
    allow = if unless  # My custom configuration
    severity = cruel   # Same as "severity = 2"

    #--------------------------------------------------------------
    # Give these policies a custom theme.  I can activate just
    # these policies by saying "perlcritic --theme 'larry || curly'"

    [Modules::RequireFilenameMatchesPackage]
    add_themes = larry

    [TestingAndDebugging::RequireTestLabels]
    add_themes = curly moe

    #--------------------------------------------------------------
    # I do not agree with these at all, so never load them

    [-NamingConventions::Capitalization]
    [-ValuesAndExpressions::ProhibitMagicNumbers]

    #--------------------------------------------------------------
    # For all other Policies, I accept the default severity,
    # so no additional configuration is required for them.

Note that all policies included with the Perl::Critic distribution that have
integer parameters accept underscores ("_") in their values, as with Perl
numeric literals.  For example,

    [ValuesAndExpressions::RequireNumberSeparators]
    min_value = 1_000

For additional configuration examples, see the F<perlcriticrc> file that is
included in this F<examples> directory of this distribution.

Damian Conway's own Perl::Critic configuration is also included in this
distribution as F<examples/perlcriticrc-conway>.


=head1 THE POLICIES

A large number of Policy modules are distributed with Perl::Critic. They are
described briefly in the companion document L<Perl::Critic::PolicySummary> and
in more detail in the individual modules themselves.  Say C<"perlcritic --doc
PATTERN"> to see the perldoc for all Policy modules that match the regex
C<m/PATTERN/ixms>

There are a number of distributions of additional policies on CPAN. If
L<Perl::Critic> doesn't contain a policy that you want, some one may have
already written it.  See L<Perl::Critic/"SEE ALSO"> for a list of some of
these distributions.


=head1 POLICY THEMES

Each Policy is defined with one or more "themes".  Themes can be used to
create arbitrary groups of Policies.  They are intended to provide an
alternative mechanism for selecting your preferred set of Policies. For
example, you may wish disable a certain set of Policies when analyzing test
programs.  Conversely, you may wish to enable only a specific subset of
Policies when analyzing modules.

The Policies that ship with Perl::Critic are have been divided into the
following themes.  This is just our attempt to provide some basic logical
groupings.  You are free to invent new themes that suit your needs.

    THEME             DESCRIPTION
    ------------------------------------------------------------------------
    core              All policies that ship with Perl::Critic
    pbp               Policies that come directly from "Perl Best Practices"
    bugs              Policies that that prevent or reveal bugs
    certrec           Policies that CERT recommends
    certrule          Policies that CERT considers rules
    maintenance       Policies that affect the long-term health of the code
    cosmetic          Policies that only have a superficial effect
    complexity        Policies that specificaly relate to code complexity
    security          Policies that relate to security issues
    tests             Policies that are specific to test programs

Say C<"perlcritic --list"> to get a listing of all available policies and the
themes that are associated with each one.  You can also change the theme for
any Policy in your F<.perlcriticrc> file.  See the L<"CONFIGURATION"> section
for more information about that.

Using the C<--theme> command-line option, you can create an arbitrarily
complex rule that determines which Policies to apply. Precedence is the same
as regular Perl code, and you can use parentheses to enforce precedence as
well.  Supported operators are:

    Operator    Altertative    Example
    -----------------------------------------------------------------
    &&          and            'pbp && core'
    ||          or             'pbp || (bugs && security)'
    !           not            'pbp && ! (portability || complexity)'

Theme names are case-insensitive.  If the C<--theme> is set to an empty
string, then it evaluates as true all Policies.


=head1 BENDING THE RULES

Perl::Critic takes a hard-line approach to your code: either you comply or you
don't.  In the real world, it is not always practical (or even possible) to
fully comply with coding standards.  In such cases, it is wise to show that
you are knowingly violating the standards and that you have a Damn Good Reason
(DGR) for doing so.

To help with those situations, you can direct Perl::Critic to ignore certain
lines or blocks of code by using annotations:

  require 'LegacyLibaray1.pl';  ## no critic
  require 'LegacyLibrary2.pl';  ## no critic

  for my $element (@list) {

      ## no critic

      $foo = "";               #Violates 'ProhibitEmptyQuotes'
      $barf = bar() if $foo;   #Violates 'ProhibitPostfixControls'
      #Some more evil code...

      ## use critic

      #Some good code...
      do_something($_);
  }

The C<"## no critic"> annotations direct Perl::Critic to ignore the remaining
lines of code until a C<"## use critic"> annotation is found. If the C<"## no
critic"> annotation is on the same line as a code statement, then only that
line of code is overlooked.  To direct perlcritic to ignore the C<"## no
critic"> annotations, use the C<--force> option.

A bare C<"## no critic"> annotation disables all the active Policies.  If you
wish to disable only specific Policies, add a list of Policy names as
arguments just as you would for the C<"no strict"> or C<"no warnings"> pragma.
For example, this would disable the C<ProhibitEmptyQuotes> and
C<ProhibitPostfixControls> policies until the end of the block or until the
next C<"## use critic"> annotation (whichever comes first):

    ## no critic (EmptyQuotes, PostfixControls);

    # Now exempt from ValuesAndExpressions::ProhibitEmptyQuotes
    $foo = "";

    # Now exempt ControlStructures::ProhibitPostfixControls
    $barf = bar() if $foo;

    # Still subject to ValuesAndExpression::RequireNumberSeparators
    $long_int = 10000000000;

Since the Policy names are matched against the C<"## no critic"> arguments as
regular expressions, you can abbreviate the Policy names or disable an entire
family of Policies in one shot like this:

    ## no critic (NamingConventions)

    # Now exempt from NamingConventions::Capitalization
    my $camelHumpVar = 'foo';

    # Now exempt from NamingConventions::Capitalization
    sub camelHumpSub {}

The argument list must be enclosed in parentheses and must contain one or more
comma-separated barewords (i.e. don't use quotes).  The C<"## no critic">
annotations can be nested, and Policies named by an inner annotation will be
disabled along with those already disabled an outer annotation.

Some Policies like C<Subroutines::ProhibitExcessComplexity> apply to an entire
block of code.  In those cases, C<"## no critic"> must appear on the line
where the violation is reported.  For example:

    sub complicated_function {  ## no critic (ProhibitExcessComplexity)
        # Your code here...
    }

Some Policies like C<Documentation::RequirePodSections> apply to the entire
document, in which case violations are reported at line 1.  But if the file
requires a shebang line, it is impossible to put C<"## no critic"> on the
first line of the file.  This is a known limitation and it will be addressed
in a future release.  As a workaround, you can disable the affected policies
at the command-line or in your F<.perlcriticrc> file.  But beware that this
will affect the analysis of B<all> files.

Use this feature wisely.  C<"## no critic"> should be used in the smallest
possible scope, or only on individual lines of code. And you should always be
as specific as possible about which policies you want to disable (i.e. never
use a bare C<"## no critic">).  If Perl::Critic complains about your code, try
and find a compliant solution before resorting to this feature.


=head1 EDITOR INTEGRATION

For ease-of-use, C<perlcritic> can be integrated with your favorite text
editor.  The output-formatting capabilities of C<perlcritic> are specifically
intended for use with the "grep" or "compile" modes available in editors like
C<emacs> and C<vim>.  In these modes, you can run an arbitrary command and the
editor will parse the output into an interactive buffer that you can click on
and jump to the relevant line of code.

The Perl::Critic team thanks everyone who has helped integrate Perl-Critic
with their favorite editor.  Your contributions in particular have made Perl-
Critic a convenient and user-friendly tool for Perl developers of all stripes.
We sincerely appreciate your hard work.


=head2 EMACS

Joshua ben Jore has authored a minor-mode for emacs that allows you to run
perlcritic on the current region or buffer.  You can run it on demand, or
configure it to run automatically when you save the buffer. The output appears
in a hot-linked compiler buffer.  The code and installation instructions can
be found in the F<extras> directory inside this distribution.


=head2 VIM

Scott Peshak has published F<perlchecker.vim>, which is available at
L<http://www.vim.org/scripts/script.php?script_id=1731>.


=head2 gVIM

Fritz Mehner recently added support for C<perlcritic> to his fantastic gVIM
plugin.  In addition to providing a very Perlish IDE, Fritz's plugin enables
one-click access to C<perlcritic> and many other very useful utilities.  And
all is seamlessly integrated into the editor. See
L<http://lug.fh-swf.de/vim/vim-perl/screenshots-en.html> for complete details.


=head2 EPIC

EPIC is an open source Perl IDE based on the Eclipse platform. Features
include syntax highlighting, on-the-fly syntax check, content assist, code
completion, perldoc support, source formatting with L<Perl::Tidy|Perl::Tidy>,
code templates, a regular expression editing tool, and integration with the
Perl debugger.  Recent versions of EPIC also have built-in support for
Perl::Critic.  At least one Perl::Critic contributor swears by EPIC.  Go to
L<http://e-p-i-c.sourceforge.net> for more information about EPIC.

=head2 BBEdit

Josh Clark has produced an excellent Perl-Critic plugin for BBEdit. See
L<http://globalmoxie.com/projects/bbedit-perl-critic/index.shtml> for
download, installation, and usage instructions.  Apple users rejoice!


=head2 Komodo

Komodo is a proprietary IDE for Perl and several other dynamic languages.
Starting in version 5.1.1, Komodo has built-in support for Perl-Critic, if you
have the L<Perl::Critic> and L<criticism> modules installed.  Free trial
copies of Komodo can be obtained from the ActiveState website at
L<http://www.activestate.com>.


=head2 ActivePerl

ActivePerl includes a very slick graphical interface for configuring and
running Perl-Critic called C<perlcritic-gui>.  A free community edition of
ActivePerl can be obtained from the ActiveState website at
L<http://www.activestate.com>.


=head1 EXIT STATUS

If C<perlcritic> has any errors itself, exits with status == 1.  If there are
no errors, but C<perlcritic> finds Policy violations in your source code,
exits with status == 2.  If there were no errors and no violations were found,
exits with status == 0.


=head1 THE L<Perl::Critic> PHILOSOPHY

=over

Coding standards are deeply personal and highly subjective.  The goal of
Perl::Critic is to help you write code that conforms with a set of best
practices.  Our primary goal is not to dictate what those practices are, but
rather, to implement the practices discovered by others.  Ultimately, you make
the rules -- Perl::Critic is merely a tool for encouraging consistency.  If
there is a policy that you think is important or that we have overlooked, we
would be very grateful for contributions, or you can simply load your own
private set of policies into Perl::Critic.

=back


=head1 EXTENDING THE CRITIC

The modular design of Perl::Critic is intended to facilitate the addition of
new Policies.  You'll need to have some understanding of L<PPI>, but most
Policy modules are pretty straightforward and only require about 20 lines of
code.  Please see the L<Perl::Critic::DEVELOPER> file included in this
distribution for a step-by-step demonstration of how to create new Policy
modules.

If you develop any new Policy modules, feel free to send them to C<<
<team@perlcritic.com> >> and I'll be happy to consider putting them into the
Perl::Critic distribution.  Or if you would like to work on the Perl::Critic
project directly, you can fork our repository at
L<https://github.com/Perl-Critic/Perl-Critic.git>.

The Perl::Critic team is also available for hire.  If your organization has
its own coding standards, we can create custom Policies to enforce your local
guidelines.  Or if your code base is prone to a particular defect pattern, we
can design Policies that will help you catch those costly defects B<before>
they go into production. To discuss your needs with the Perl::Critic team,
just contact C<< <team@perlcritic.com> >>.


=head1 CONTACTING THE DEVELOPMENT TEAM

You are encouraged to subscribe to the mailing list at
L<https://groups.google.com/d/forum/perl-critic>.
At least one member of the development team is usually hanging around in
L<irc://irc.perl.org/#perlcritic> and you can follow Perl::Critic on Twitter,
at L<https://twitter.com/perlcritic>.


=head1 SEE ALSO

There are a number of distributions of additional Policies available. A few
are listed here:

L<Perl::Critic::More>

L<Perl::Critic::Bangs>

L<Perl::Critic::Lax>

L<Perl::Critic::StricterSubs>

L<Perl::Critic::Swift>

L<Perl::Critic::Tics>

These distributions enable you to use Perl::Critic in your unit tests:

L<Test::Perl::Critic>

L<Test::Perl::Critic::Progressive>

There is also a distribution that will install all the Perl::Critic related
modules known to the development team:

L<Task::Perl::Critic>


=head1 BUGS

Scrutinizing Perl code is hard for humans, let alone machines.  If you find
any bugs, particularly false-positives or false-negatives from a
Perl::Critic::Policy, please submit them at
L<https://github.com/Perl-Critic/Perl-Critic/issues>.  Thanks.

=head1 CREDITS

Adam Kennedy - For creating L<PPI>, the heart and soul of L<Perl::Critic>.

Damian Conway - For writing B<Perl Best Practices>, finally :)

Chris Dolan - For contributing the best features and Policy modules.

Andy Lester - Wise sage and master of all-things-testing.

Elliot Shank - The self-proclaimed quality freak.

Giuseppe Maxia - For all the great ideas and positive encouragement.

and Sharon, my wife - For putting up with my all-night code sessions.

Thanks also to the Perl Foundation for providing a grant to support Chris
Dolan's project to implement twenty PBP policies.
L<http://www.perlfoundation.org/april_1_2007_new_grant_awards>


=head1 AUTHOR

Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>


=head1 COPYRIGHT

Copyright (c) 2005-2011 Imaginative Software Systems.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the LICENSE file included with this module.

=cut

##############################################################################
# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 78
#   indent-tabs-mode: nil
#   c-indentation-style: bsd
# End:
# ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
