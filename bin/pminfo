#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/ModuleUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MODULEUTILS';
  package App::ModuleUtils;
  
  our $DATE = '2018-04-03'; # DATE
  our $VERSION = '0.720'; # VERSION
  
  1;
  # ABSTRACT: Alias for App::PMUtils
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::ModuleUtils - Alias for App::PMUtils
  
  =head1 VERSION
  
  This document describes version 0.720 of App::ModuleUtils (from Perl distribution App-PMUtils), released on 2018-04-03.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/App-PMUtils>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-App-PMUtils>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-PMUtils>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<App::PMUtils>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_MODULEUTILS

$fatpacked{"App/PMUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PMUTILS';
  package App::PMUtils;
  
  our $DATE = '2018-04-03'; # DATE
  our $VERSION = '0.720'; # VERSION
  
  use 5.010001;
  
  our %SPEC;
  
  our $arg_module_multiple = {
      schema => ['array*' => of=>'perl::modname*', min_len=>1],
      req    => 1,
      pos    => 0,
      greedy => 1,
      element_completion => sub {
          require Complete::Module;
          my %args = @_;
          Complete::Module::complete_module(word=>$args{word});
      },
  };
  
  our $arg_module_single = {
      schema => 'perl::modname*',
      req    => 1,
      pos    => 0,
      completion => sub {
          require Complete::Module;
          my %args = @_;
          Complete::Module::complete_module(word=>$args{word});
      },
  };
  
  $SPEC{pmpath} = {
      v => 1.1,
      summary => 'Get path to locally installed Perl module',
      args => {
          module => $App::PMUtils::arg_module_multiple,
          all => {
              summary => 'Return all found files for each module instead of the first one',
              schema => 'bool',
              cmdline_aliases => {a=>{}},
          },
          abs => {
              summary => 'Absolutify each path',
              schema => 'bool',
              cmdline_aliases => {P=>{}},
          },
          pm => {
              schema => ['int*', min=>0],
              default => 1,
          },
          pmc => {
              schema => ['int*', min=>0],
              default => 0,
          },
          pod => {
              schema => ['int*', min=>0],
              default => 0,
          },
          prefix => {
              schema => ['int*', min=>0],
              default => 0,
          },
          dir => {
              summary => 'Show directory instead of path',
              description => <<'_',
  
  Also, will return `.` if not found, so you can conveniently do this on a Unix
  shell:
  
      % cd `pmpath -Pd Moose`
  
  and it won't change directory if the module doesn't exist.
  
  _
              schema  => ['bool', is=>1],
              cmdline_aliases => {d=>{}},
          },
      },
  };
  sub pmpath {
      require Module::Path::More;
      my %args = @_;
  
      my $mods = $args{module};
      my $res = [];
      my $found;
  
      for my $mod (@{$mods}) {
          my $mpath = Module::Path::More::module_path(
              module      => $mod,
              find_pm     => $args{pm},
              find_pmc    => $args{pmc},
              find_pod    => $args{pod},
              find_prefix => $args{prefix},
              abs         => $args{abs},
              all         => $args{all},
          );
          $found++ if $mpath;
          for (ref($mpath) eq 'ARRAY' ? @$mpath : ($mpath)) {
              if ($args{dir}) {
                  require File::Spec;
                  my ($vol, $dir, $file) = File::Spec->splitpath($_);
                  $_ = $dir;
              }
              push @$res, @$mods > 1 ? {module=>$mod, path=>$_} : $_;
          }
      }
  
      if ($found) {
          [200, "OK", $res];
      } else {
          if ($args{dir}) {
              [200, "OK (not found)", "."];
          } else {
              [404, "No such module"];
          }
      }
  }
  
  $SPEC{pmdir} = do {
      my $meta = { %{ $SPEC{pmpath} } }; # shallow copy
      $meta->{summary} = "Get directory of locally installed Perl module/prefix";
      $meta->{description} = <<'_';
  
  This is basically a shortcut for:
  
      % pmpath -Pd MODULE_OR_PREFIX_NAME
  
  Sometimes I forgot that <prog:pmpath> has a `-d` option, and often intuitively
  look for a <prog:pmdir> command.
  
  _
      $meta->{args} = { %{ $SPEC{pmpath}{args} } }; # shalow copy
      delete $meta->{args}{all};
      delete $meta->{args}{dir};
      delete $meta->{args}{prefix};
      $meta;
  };
  sub pmdir {
      pmpath(@_, prefix=>1, dir=>1);
  }
  
  $SPEC{rel2mod} = {
      v => 1.1,
      summary => 'Convert release name (e.g. Foo-Bar-1.23.tar.gz) to '.
          'module name (Foo::Bar)',
      args => {
          releases => {
              #'x.name.is_plural' => 1,
              schema => ['array*', of=>'str*'],
              req => 1,
              pos => 0,
              greedy => 1,
              cmdline_src => 'stdin_or_args',
          },
      },
      result_naked => 1,
  };
  sub rel2mod {
      my %args = @_;
  
      #use DD; dd \%args;
  
      my @res;
      for (@{ $args{releases} }) {
          s!.+/!!; # remove directory path
          s/(.+)-v?\d.+/$1/;
          s/-/::/g;
          push @res, $_;
      }
  
      \@res;
  }
  
  1;
  # ABSTRACT: Command-line utilities related to Perl modules
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::PMUtils - Command-line utilities related to Perl modules
  
  =head1 VERSION
  
  This document describes version 0.720 of App::PMUtils (from Perl distribution App-PMUtils), released on 2018-04-03.
  
  =head1 SYNOPSIS
  
  This distribution provides the following command-line utilities related to Perl
  modules:
  
  =over
  
  =item * L<module-dir>
  
  =item * L<pmbin>
  
  =item * L<pmcat>
  
  =item * L<pmchkver>
  
  =item * L<pmcore>
  
  =item * L<pmcost>
  
  =item * L<pmdir>
  
  =item * L<pmdoc>
  
  =item * L<pmedit>
  
  =item * L<pmhtml>
  
  =item * L<pminfo>
  
  =item * L<pmless>
  
  =item * L<pmlines>
  
  =item * L<pmlist>
  
  =item * L<pmman>
  
  =item * L<pmminversion>
  
  =item * L<pmpath>
  
  =item * L<pmstripper>
  
  =item * L<pmuninst>
  
  =item * L<pmversion>
  
  =item * L<pmxs>
  
  =item * L<podlist>
  
  =item * L<podpath>
  
  =item * L<pwd2mod>
  
  =item * L<rel2mod>
  
  =back
  
  The main purpose of these utilities is tab completion.
  
  =head1 FUNCTIONS
  
  
  =head2 pmdir
  
  Usage:
  
   pmdir(%args) -> [status, msg, result, meta]
  
  Get directory of locally installed Perl module/prefix.
  
  This is basically a shortcut for:
  
   % pmpath -Pd MODULE_OR_PREFIX_NAME
  
  Sometimes I forgot that L<pmpath> has a C<-d> option, and often intuitively
  look for a L<pmdir> command.
  
  This function is not exported.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<abs> => I<bool>
  
  Absolutify each path.
  
  =item * B<module>* => I<array[perl::modname]>
  
  =item * B<pm> => I<int> (default: 1)
  
  =item * B<pmc> => I<int> (default: 0)
  
  =item * B<pod> => I<int> (default: 0)
  
  =back
  
  Returns an enveloped result (an array).
  
  First element (status) is an integer containing HTTP status code
  (200 means OK, 4xx caller error, 5xx function error). Second element
  (msg) is a string containing error message, or 'OK' if status is
  200. Third element (result) is optional, the actual result. Fourth
  element (meta) is called result metadata and is optional, a hash
  that contains extra information.
  
  Return value:  (any)
  
  
  =head2 pmpath
  
  Usage:
  
   pmpath(%args) -> [status, msg, result, meta]
  
  Get path to locally installed Perl module.
  
  This function is not exported.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<abs> => I<bool>
  
  Absolutify each path.
  
  =item * B<all> => I<bool>
  
  Return all found files for each module instead of the first one.
  
  =item * B<dir> => I<bool>
  
  Show directory instead of path.
  
  Also, will return C<.> if not found, so you can conveniently do this on a Unix
  shell:
  
   % cd C<pmpath -Pd Moose>
  
  and it won't change directory if the module doesn't exist.
  
  =item * B<module>* => I<array[perl::modname]>
  
  =item * B<pm> => I<int> (default: 1)
  
  =item * B<pmc> => I<int> (default: 0)
  
  =item * B<pod> => I<int> (default: 0)
  
  =item * B<prefix> => I<int> (default: 0)
  
  =back
  
  Returns an enveloped result (an array).
  
  First element (status) is an integer containing HTTP status code
  (200 means OK, 4xx caller error, 5xx function error). Second element
  (msg) is a string containing error message, or 'OK' if status is
  200. Third element (result) is optional, the actual result. Fourth
  element (meta) is called result metadata and is optional, a hash
  that contains extra information.
  
  Return value:  (any)
  
  
  =head2 rel2mod
  
  Usage:
  
   rel2mod(%args) -> any
  
  Convert release name (e.g. Foo-Bar-1.23.tar.gz) to module name (Foo::Bar).
  
  This function is not exported.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<releases>* => I<array[str]>
  
  =back
  
  Return value:  (any)
  
  =head1 FAQ
  
  =for BEGIN_BLOCK: faq
  
  =head2 What is the purpose of this distribution? Haven't other similar utilities existed?
  
  For example, L<mpath> from L<Module::Path> distribution is similar to L<pmpath>
  in L<App::PMUtils>, and L<mversion> from L<Module::Version> distribution is
  similar to L<pmversion> from L<App::PMUtils> distribution, and so on.
  
  True. The main point of these utilities is shell tab completion, to save
  typing.
  
  =for END_BLOCK: faq
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/App-PMUtils>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-App-PMUtils>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-PMUtils>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  =for BEGIN_BLOCK: see_also
  
  Below is the list of distributions that provide CLI utilities for various
  purposes, with the focus on providing shell tab completion feature.
  
  L<App::DistUtils>, utilities related to Perl distributions.
  
  L<App::DzilUtils>, utilities related to L<Dist::Zilla>.
  
  L<App::GitUtils>, utilities related to git.
  
  L<App::IODUtils>, utilities related to L<IOD> configuration files.
  
  L<App::LedgerUtils>, utilities related to Ledger CLI files.
  
  L<App::PlUtils>, utilities related to Perl scripts.
  
  L<App::PMUtils>, utilities related to Perl modules.
  
  L<App::ProgUtils>, utilities related to programs.
  
  L<App::WeaverUtils>, utilities related to L<Pod::Weaver>.
  
  =for END_BLOCK: see_also
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_PMUTILS

$fatpacked{"Log/ger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER';
  package Log::ger;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  our $re_addr = qr/\(0x([0-9a-f]+)/o;
  
  our %Levels = (
      fatal   => 10,
      error   => 20,
      warn    => 30,
      info    => 40,
      debug   => 50,
      trace   => 60,
  );
  
  our %Level_Aliases = (
      off     => 0,
      warning => 30,
  );
  
  our $Current_Level = 30;
  
  our $Caller_Depth_Offset = 0;
  
  # a flag that can be used by null output to skip using formatter
  our $_logger_is_null;
  
  our $_dumper;
  
  our %Global_Hooks;
  
  # in Log/ger/Heavy.pm
  # our %Default_Hooks = (
  
  our %Package_Targets; # key = package name, value = \%init_args
  our %Per_Package_Hooks; # key = package name, value = { phase => hooks, ... }
  
  our %Hash_Targets; # key = hash address, value = [$hashref, \%init_args]
  our %Per_Hash_Hooks; # key = hash address, value = { phase => hooks, ... }
  
  our %Object_Targets; # key = object address, value = [$obj, \%init_args]
  our %Per_Object_Hooks; # key = object address, value = { phase => hooks, ... }
  
  my $sub0 = sub {0};
  my $sub1 = sub {1};
  my $default_null_routines;
  
  sub install_routines {
      my ($target, $target_arg, $routines) = @_;
  
      if ($target eq 'package') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              #print "D:installing $name to package $target_arg\n";
              *{"$target_arg\::$name"} = $code;
          }
      } elsif ($target eq 'object') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          my $pkg = ref $target_arg;
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_method\z/;
              *{"$pkg\::$name"} = $code;
          }
      } elsif ($target eq 'hash') {
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              $target_arg->{$name} = $code;
          }
      }
  }
  
  sub add_target {
      my ($target, $target_arg, $args, $replace) = @_;
      $replace = 1 unless defined $replace;
  
      if ($target eq 'package') {
          unless ($replace) { return if $Package_Targets{$target_arg} }
          $Package_Targets{$target_arg} = $args;
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Object_Targets{$addr} }
          $Object_Targets{$addr} = [$target_arg, $args];
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Hash_Targets{$addr} }
          $Hash_Targets{$addr} = [$target_arg, $args];
      }
  }
  
  sub _set_default_null_routines {
      $default_null_routines ||= [
          (map {(
              [$sub0, "log_$_", $Levels{$_}, 'log_sub'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "log_is_$_", $Levels{$_}, 'is_sub'],
              [$sub0, $_, $Levels{$_}, 'log_method'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "is_$_", $Levels{$_}, 'is_method'],
          )} keys %Levels),
      ];
  }
  
  sub get_logger {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      my $obj = []; $obj =~ $re_addr;
      my $pkg = "Log::ger::Obj$1"; bless $obj, $pkg;
      add_target(object => $obj, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(object => $obj, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(object => $obj, $default_null_routines);
      }
      $obj; # XXX add DESTROY to remove from list of targets
  }
  
  sub import {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      add_target(package => $caller, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(package => $caller, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(package => $caller, $default_null_routines);
      }
  }
  
  1;
  # ABSTRACT: A lightweight, flexible logging framework
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger - A lightweight, flexible logging framework
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  In your module (producer):
  
   package Foo;
   use Log::ger; # will import some logging methods e.g. log_warn, log_error
  
   sub foo {
       ...
       # produce some logs
       log_error "an error occurred: %03d - %s", $errcode, $errmsg;
       ...
       log_debug "http response: %s", $http; # automatic dumping of data
   }
   1;
  
  In your application (consumer/listener):
  
   use Foo;
   use Log::ger::Output 'Screen';
  
   foo();
  
  =head1 DESCRIPTION
  
  Log::ger is yet another logging framework with the following features:
  
  =over
  
  =item * Separation of producers and consumers/listeners
  
  Like L<Log::Any>, this offers a very easy way for modules to produce some logs
  without having to configure anything. Configuring output, level, etc can be done
  in the application as log consumers/listeners. To read more about this, see the
  documentation of L<Log::Any> or L<Log::ger::Manual> (but nevertheless see
  L<Log::ger::Manual> on why you might prefer Log::ger to Log::Any).
  
  =item * Lightweight and fast
  
  B<Slim distribution.> No non-core dependencies, extra functionalities are
  provided in separate distributions to be pulled as needed.
  
  B<Low startup overhead.> Only ~0.5-1ms. For comparison, L<strict> ~0.2-0.5ms,
  L<warnings> ~2ms, L<Log::Any> 0.15 ~2-3ms, Log::Any 1.049 ~8-10ms,
  L<Log::Log4perl> ~35ms. This is measured on a 2014-2015 PC and before doing any
  output configuration. For more benchmarks, see L<Bencher::Scenarios::LogGer> or
  try yourself e.g. with L<bencher-code>:
  
   % bencher-code 'use Log::ger' 'use Log::Any' --startup
  
  B<Fast>. Low null-/stealth-logging overhead, about 1.5x faster than Log::Any, 3x
  faster than Log4perl, and 5x faster than L<Log::Fast>.
  
  B<Conditional compilation.> There is a plugin to optimize away unneeded logging
  statements, like assertion/conditional compilation, so they have zero runtime
  performance cost. See L<Log::ger::Plugin::OptAway>.
  
  Being lightweight means the module can be used more universally, from CLI to
  long-running daemons to inside routines with tight loops.
  
  =item * Flexible
  
  B<Customizable levels and routine/method names.> Can be used in a procedural or
  OO style. Log::ger can mimic the interface of L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, or some other popular logging frameworks, to ease migration or
  adjust with your personal style.
  
  B<Per-package settings.> Each importer package can use its own format/layout,
  output. For example, some modules that are migrated from Log::Any uses
  Log::Any-style logging, while another uses native Log::ger style, and yet some
  other uses block formatting like Log::Contextual. This eases code migration and
  teamwork. Each module author can preserve her own logging style, if wanted, and
  all the modules still use the same framework.
  
  B<Dynamic.> Outputs and levels can be changed anytime during run-time and
  logging routines will be updated automatically. This is useful in situation like
  a long-running server application: you can turn on tracing logs temporarily to
  debug problems, then turn them off again, without restarting your server.
  
  B<Interoperability.> There are modules to interop with Log::Any, either consume
  Log::Any logs (see L<Log::Any::Adapter::LogGer>) or produce logs to be consumed
  by Log::Any (see L<Log::ger::Output::LogAny>).
  
  B<Many output modules and plugins.> See C<Log::ger::Output::*>,
  C<Log::ger::Format::*>, C<Log::ger::Layout::*>, C<Log::ger::Plugin::*>. Writing
  an output module in Log::ger is easier than writing a Log::Any::Adapter::*.
  
  =back
  
  For more documentation, start with L<Log::ger::Manual>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  Some other popular logging frameworks: L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, L<Log::Dispatch>, L<Log::Dispatchouli>.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER

$fatpacked{"Log/ger/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT';
  package Log::ger::Format;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  sub _import_sets_for_current_package { 1 }
  
  1;
  # ABSTRACT: Use a format plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format - Use a format plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set for current package only:
  
   use Log::ger::Format 'Block';
  
  or:
  
   use Log::ger::Format;
   Log::ger::Format->set_for_current_package('Block');
  
  To set globally:
  
   use Log::ger::Format;
   Log::ger::Format->set('Block');
  
  =head1 DESCRIPTION
  
  Note: Since format plugins affect log-producing code, the import syntax defaults
  to setting for current package instead of globally.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT

$fatpacked{"Log/ger/Format/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT_NONE';
  package Log::ger::Format::None;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_formatter => [
              __PACKAGE__, 50,
              sub {
                  [sub {shift}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Perform no formatting on the message
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format::None - Perform no formatting on the message
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Format 'None';
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT_NONE

$fatpacked{"Log/ger/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_HEAVY';
  package Log::ger::Heavy;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  package
      Log::ger;
  
  #IFUNBUILT
  # use vars qw(
  #                $re_addr
  #                %Levels
  #                %Level_Aliases
  #                $Current_Level
  #                $Caller_Depth_Offset
  #                $_logger_is_null
  #                $_dumper
  #                %Global_Hooks
  #                %Package_Targets
  #                %Per_Package_Hooks
  #                %Hash_Targets
  #                %Per_Hash_Hooks
  #                %Object_Targets
  #                %Per_Object_Hooks
  #        );
  #END IFUNBUILT
  
  # key = phase, value = [ [key, prio, coderef], ... ]
  our %Default_Hooks = (
      create_formatter => [
          [__PACKAGE__, 90,
           # the default formatter is sprintf-style that dumps data structures
           # arguments as well as undef as '<undef>'.
           sub {
               my %args = @_;
  
               my $formatter = sub {
                   return $_[0] if @_ < 2;
                   my $fmt = shift;
                   my @args;
                   for (@_) {
                       if (!defined($_)) {
                           push @args, '<undef>';
                       } elsif (ref $_) {
                           require Log::ger::Util unless $_dumper;
                           push @args, Log::ger::Util::_dump($_);
                       } else {
                           push @args, $_;
                       }
                   }
                   sprintf $fmt, @args;
               };
               [$formatter];
           }],
      ],
  
      create_layouter => [],
  
      create_routine_names => [
          [__PACKAGE__, 90,
           # the default names are log_LEVEL() and log_is_LEVEL() for subroutine
           # names, or LEVEL() and is_LEVEL() for method names
           sub {
               my %args = @_;
  
               my $levels = [keys %Levels];
  
               return [{
                   log_subs    => [map { ["log_$_", $_]    } @$levels],
                   is_subs     => [map { ["log_is_$_", $_] } @$levels],
                   # used when installing to hash or object
                   log_methods => [map { ["$_", $_]        } @$levels],
                   is_methods  => [map { ["is_$_", $_]     } @$levels],
               }, 1];
           }],
      ],
  
      create_log_routine => [
          [__PACKAGE__, 10,
           # the default behavior is to create a null routine for levels that are
           # too high than the global level ($Current_Level). since we run at high
           # priority (10), this block typical output plugins at normal priority
           # (50). this is a convenience so normally a plugin does not have to
           # deal with level checking.
           sub {
               my %args = @_;
               my $level = $args{level};
               if (defined($level) && (
                   $Current_Level < $level ||
                       # there's only us
                       @{ $Global_Hooks{create_log_routine} } == 1)
               ) {
                   $_logger_is_null = 1;
                   return [sub {0}];
               }
               [undef]; # decline
           }],
      ],
  
      create_logml_routine => [],
  
      create_is_routine => [
          [__PACKAGE__, 90,
           # the default behavior is to compare to global level. normally this
           # behavior suffices. we run at low priority (90) so normal plugins
           # which typically use priority 50 can override us.
           sub {
               my %args = @_;
               my $level = $args{level};
               [sub { $Current_Level >= $level }];
           }],
      ],
  
      before_install_routines => [],
  
      after_install_routines => [],
  );
  
  for my $phase (keys %Default_Hooks) {
      $Global_Hooks{$phase} = [@{ $Default_Hooks{$phase} }];
  }
  
  # if flow_control is 1, stops after the first hook that gives non-undef result.
  # flow_control can also be a coderef that will be called after each hook with
  # ($hook, $hook_res) and can return 1 to mean stop.
  sub run_hooks {
      my ($phase, $hook_args, $flow_control,
          $target, $target_arg) = @_;
      #print "D: running hooks for phase $phase\n";
  
      $Global_Hooks{$phase} or die "Unknown phase '$phase'";
      my @hooks = @{ $Global_Hooks{$phase} };
  
      if ($target eq 'package') {
          unshift @hooks, @{ $Per_Package_Hooks{$target_arg}{$phase} || [] };
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Hash_Hooks{$addr}{$phase} || [] };
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Object_Hooks{$addr}{$phase} || [] };
      }
  
      my $res;
      for my $hook (sort {$a->[1] <=> $b->[1]} @hooks)  {
          my $hook_res = $hook->[2]->(%$hook_args);
          if (defined $hook_res->[0]) {
              $res = $hook_res->[0];
              #print "D:   got result from hook $res\n";
              if (ref $flow_control eq 'CODE') {
                  last if $flow_control->($hook, $hook_res);
              } else {
                  last if $flow_control;
              }
          }
          last if $hook_res->[1];
      }
      return $res;
  }
  
  sub init_target {
      my ($target, $target_arg, $init_args) = @_;
  
      #print "D:init_target($target, $target_arg, ...)\n";
      my %hook_args = (
          target     => $target,
          target_arg => $target_arg,
          init_args  => $init_args,
      );
  
      my %formatters;
      run_hooks(
          'create_formatter', \%hook_args,
          # collect formatters, until a hook instructs to stop
          sub {
              my ($hook, $hook_res) = @_;
              my ($formatter, $flow_control, $fmtname) = @$hook_res;
              $fmtname = 'default' if !defined($fmtname);
              $formatters{$fmtname} ||= $formatter;
              $flow_control;
          },
          $target, $target_arg);
  
      my $layouter =
          run_hooks('create_layouter', \%hook_args, 1, $target, $target_arg);
  
      my $routine_names = {};
      run_hooks(
          'create_routine_names', \%hook_args,
          # collect routine names, until a hook instructs to stop.
          sub {
              my ($hook, $hook_res) = @_;
              my ($rn, $flow_control) = @$hook_res;
              $rn or return;
              for (keys %$rn) {
                  push @{ $routine_names->{$_} }, @{ $rn->{$_} };
              }
              $flow_control;
          },
          $target, $target_arg);
  
      my @routines;
      my $object = $target eq 'object';
  
    CREATE_LOG_ROUTINES:
      {
          my @rn;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{log_subs} || [] };
              push @rn, @{ $routine_names->{logml_subs} || [] };
          } else {
              push @rn, @{ $routine_names->{log_methods} || [] };
              push @rn, @{ $routine_names->{logml_methods} || [] };
          }
          my $mllogger0;
          for my $rn (@rn) {
              my ($rname, $lname, $fmtname) = @$rn;
              my $lnum; $lnum = $Levels{$lname} if defined $lname;
              my $routine_name_is_ml = !defined($lname);
              $fmtname = 'default' if !defined($fmtname);
  
              my $logger;
              my ($logger0, $logger0_is_ml);
              $_logger_is_null = 0;
              for my $phase (qw/create_logml_routine create_log_routine/) {
                  local $hook_args{name} = $rname;
                  local $hook_args{level} = $lnum;
                  local $hook_args{str_level} = $lname;
                  $logger0_is_ml = $phase eq 'create_logml_routine';
                  if ($mllogger0) {
                      # we reuse the same multilevel logger0 for all log routines,
                      # since it can handle different levels
                      $logger0 = $mllogger0;
                      last;
                  }
                  $logger0 = run_hooks(
                      $phase, \%hook_args, 1, $target, $target_arg)
                      or next;
                  if ($logger0_is_ml) {
                      $mllogger0 = $logger0;
                  }
                  last;
              }
              # this can happen if there is no create_logml_routine hook but
              # routine name is a logml routine
              unless ($logger0) {
                  $_logger_is_null = 1;
                  $logger0 = sub {0};
              }
  
              require Log::ger::Util if !$logger0_is_ml && $routine_name_is_ml;
  
              {
                  if ($_logger_is_null) {
                      # if logger is a null logger (sub {0}) we don't need to
                      # format message, layout message, or care about the logger
                      # being a subroutine/object
                      $logger = $logger0;
                      last;
                  }
  
                  my $formatter = $formatters{$fmtname}
                      or die "Formatter named '$fmtname' not available";
                  if ($formatter) {
                      if ($layouter) {
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          }
                      } else { # no layouter
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              }
                          }
                      }
                  } else { # no formatter
                      { # no layouter, just to align
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) }; }
                              } else { # routine name not multiple-lvl
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,                          @_                             ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) }; }
                              } else {
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                                 @_                             ) }; }
                              }
                          }
                      }
                  }
              }
            L1:
              my $type = $routine_name_is_ml ?
                  ($object ? 'logml_method' : 'logml_sub') :
                  ($object ? 'log_method' : 'log_sub');
              push @routines, [$logger, $rname, $lnum, $type];
          }
      }
    CREATE_IS_ROUTINES:
      {
          my @rn;
          my $type;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{is_subs} || [] };
              $type = 'is_sub';
          } else {
              push @rn, @{ $routine_names->{is_methods} || [] };
              $type = 'is_method';
          }
          for my $rn (@rn) {
              my ($rname, $lname) = @$rn;
              my $lnum = $Levels{$lname};
  
              local $hook_args{name} = $rname;
              local $hook_args{level} = $lnum;
              local $hook_args{str_level} = $lname;
  
              my $code_is =
                  run_hooks('create_is_routine', \%hook_args, 1,
                            $target, $target_arg);
              next unless $code_is;
              push @routines, [$code_is, $rname, $lnum, $type];
          }
      }
  
      {
          local $hook_args{routines} = \@routines;
          local $hook_args{formatters} = \%formatters;
          local $hook_args{layouter} = $layouter;
          run_hooks('before_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  
      install_routines($target, $target_arg, \@routines);
  
      {
          local $hook_args{routines} = \@routines;
          run_hooks('after_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  }
  
  1;
  # ABSTRACT: The bulk of the implementation of Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Heavy - The bulk of the implementation of Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This module contains the bulk of the implementation of Log::ger, to keep
  Log::ger superslim.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_HEAVY

$fatpacked{"Log/ger/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_LAYOUT';
  package Log::ger::Layout;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Layout::/ }
  
  1;
  # ABSTRACT: Use a layout plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Layout - Use a layout plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Layout;
   Log::ger::Layout->set('Pattern');
  
  or:
  
   use Log::ger::Layout 'Pattern';
  
  To set for current package only:
  
   use Log::ger::Layout;
   Log::ger::Layout->set_for_current_package('Pattern');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  L<Log::ger::Format>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_LAYOUT

$fatpacked{"Log/ger/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT';
  package Log::ger::Output;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent 'Log::ger::Plugin';
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Output::/ }
  
  1;
  # ABSTRACT: Set logging output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output - Set logging output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Output;
   Log::ger::Output->set(Screen => (
       use_color => 1,
       ...
   );
  
  or:
  
   use Log::ger::Output 'Screen', (
       use_color=>1,
       ...
   );
  
  To set for current package only:
  
   use Log::ger::Output;
   Log::ger::Output->set_for_current_package(Screen => (
       use_color => 1,
       ...
   );
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT

$fatpacked{"Log/ger/Output/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAY';
  package Log::ger::Output::Array;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
  
                  my $logger = sub {
                      my ($ctx, $msg) = @_;
                      push @{$conf{array}}, $msg;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Array - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output Array => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAY

$fatpacked{"Log/ger/Output/ArrayML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAYML';
  package Log::ger::Output::ArrayML;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_logml_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $logger = sub {
                      my $level = Log::ger::Util::numeric_level($_[1]);
                      return if $level > $Log::ger::Current_Level;
                      push @{$conf{array}}, $_[2];
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::ArrayML - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output ArrayML => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  This output is just like L<Log::ger::Output::Array> except that it provides a
  C<create_logml_routine> hook instead of C<create_log_routine>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAYML

$fatpacked{"Log/ger/Output/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_NULL';
  package Log::ger::Output::Null;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  $Log::ger::_logger_is_null = 1;
                  [sub {0}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Null output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Null - Null output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger;
   use Log::ger::Output 'Null';
  
   log_warn "blah...";
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_NULL

$fatpacked{"Log/ger/Output/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_STRING';
  package Log::ger::Output::String;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{string} or die "Please specify string";
  
      my $formatter = $conf{formatter};
      my $append_newline = $conf{append_newline};
      $append_newline = 1 unless defined $append_newline;
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $level = $args{level};
                  my $logger = sub {
                      my $msg = $_[1];
                      if ($formatter) {
                          $msg = $formatter->($msg);
                      }
                      ${ $conf{string} } .= $msg;
                      ${ $conf{string} } .= "\n"
                          unless !$append_newline || $msg =~ /\R\z/;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Set output to a string
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::String - Set output to a string
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use var '$str';
   use Log::ger::Output 'String' => (
       string => \$str,
       # append_newline => 0, # default is true, to mimic Log::ger::Output::Screen
   );
   use Log::ger;
  
   log_warn "warn ...";
   log_error "debug ...";
  
  C<$str> will contain "warn ...\n".
  
  =head1 DESCRIPTION
  
  For testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 string => scalarref
  
  Required.
  
  =head2 formatter => coderef
  
  Optional.
  
  =head2 append_newline => bool (default: 1)
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_STRING

$fatpacked{"Log/ger/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN';
  package Log::ger::Plugin;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub set {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      $args{prefix} ||= $pkg . '::';
      $args{replace_package_regex} = $pkg->_replace_package_regex;
      Log::ger::Util::set_plugin(%args);
  }
  
  sub set_for_current_package {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      my $caller = caller(0);
      $args{target} = 'package';
      $args{target_arg} = $caller;
  
      set($pkg, \%args);
  }
  
  sub _import_sets_for_current_package { 0 }
  
  sub _replace_package_regex { undef }
  
  sub import {
      if (@_ > 1) {
          if ($_[0]->_import_sets_for_current_package) {
              goto &set_for_current_package;
          } else {
              goto &set;
          }
      }
  }
  
  1;
  # ABSTRACT: Use a plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin - Use a plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set('OptAway');
  
  or:
  
   use Log::ger::Plugin 'OptAway';
  
  To set for current package only:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set_for_current_package('OptAway');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN

$fatpacked{"Log/ger/Plugin/MultilevelLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN_MULTILEVELLOG';
  package Log::ger::Plugin::MultilevelLog;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      return {
          create_routine_names => [
              __PACKAGE__, 50,
              sub {
                  return [{
                      logml_subs    => [[$conf{sub_name}    || 'log', undef]],
                      logml_methods => [[$conf{method_name} || 'log', undef]],
                  }];
              },
          ],
      };
  }
  
  1;
  # ABSTRACT: Create a log($LEVEL, ...) subroutine/method
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin::MultilevelLog - Create a log($LEVEL, ...) subroutine/method
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Plugin MultilevelLog => (
       sub_name => 'log',    # optional
       method_name => 'log', # optional
   );
   use Log::ger;
  
  =head1 DESCRIPTION
  
  The default way is to create separate C<log_LEVEL> subroutine (or C<LEVEL>
  methods) for each level, e.g. C<log_trace> subroutine (or C<trace> method),
  C<log_warn> (or C<warn>), and so on. But sometimes you might want a log routine
  that takes $level as the first argument, e.g. instead of:
  
   log_warn('blah ...');
  
  or:
  
   $log->debug('Blah: %s', $data);
  
  you prefer:
  
   log('warn', 'blah ...');
  
  or:
  
   $log->log('debug', 'Blah: %s', $data);
  
  This plugin can create such log routine for you.
  
  Note: the multilevel log is slower because of extra argument and additional
  string level -> numeric level conversion.
  
  Note: the individual separate C<log_LEVEL> subroutines (or C<LEVEL> methods) are
  still installed.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 sub_name => str (default: "log")
  
  =head2 method_name => str (default: "log")
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN_MULTILEVELLOG

$fatpacked{"Log/ger/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_UTIL';
  package Log::ger::Util;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  require Log::ger;
  require Log::ger::Heavy;
  
  sub _dump {
      unless ($Log::ger::_dumper) {
          eval {
              no warnings 'once';
              require Data::Dmp;
              $Data::Dmp::OPT_REMOVE_PRAGMAS = 1;
              1;
          };
          if ($@) {
              no warnings 'once';
              require Data::Dumper;
              $Log::ger::_dumper = sub {
                  local $Data::Dumper::Terse = 1;
                  local $Data::Dumper::Indent = 0;
                  local $Data::Dumper::Useqq = 1;
                  local $Data::Dumper::Deparse = 1;
                  local $Data::Dumper::Quotekeys = 0;
                  local $Data::Dumper::Sortkeys = 1;
                  local $Data::Dumper::Trailingcomma = 1;
                  Data::Dumper::Dumper($_[0]);
              };
          } else {
              $Log::ger::_dumper = sub { Data::Dmp::dmp($_[0]) };
          }
      }
      $Log::ger::_dumper->($_[0]);
  }
  
  sub numeric_level {
      my $level = shift;
      return $level if $level =~ /\A\d+\z/;
      return $Log::ger::Levels{$level}
          if defined $Log::ger::Levels{$level};
      return $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      die "Unknown level '$level'";
  }
  
  sub string_level {
      my $level = shift;
      return $level if defined $Log::ger::Levels{$level};
      $level = $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      for (keys %Log::ger::Levels) {
          my $v = $Log::ger::Levels{$_};
          return $_ if $v == $level;
      }
      die "Unknown level '$level'";
  }
  
  sub set_level {
      no warnings 'once';
      $Log::ger::Current_Level = numeric_level(shift);
      reinit_all_targets();
  }
  
  sub _action_on_hooks {
      no warnings 'once';
  
      my ($action, $target, $target_arg, $phase) = splice @_, 0, 4;
  
      my $hooks = $Log::ger::Global_Hooks{$phase} or die "Unknown phase '$phase'";
      if ($target eq 'package') {
          $hooks = ($Log::ger::Per_Package_Hooks{$target_arg}{$phase} ||= []);
      } elsif ($target eq 'object') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Object_Hooks{$addr}{$phase} ||= []);
      } elsif ($target eq 'hash') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Hash_Hooks{$addr}{$phase} ||= []);
      }
  
      if ($action eq 'add') {
          my $hook = shift;
          # XXX remove duplicate key
          # my $key = $hook->[0];
          unshift @$hooks, $hook;
      } elsif ($action eq 'remove') {
          my $code = shift;
          for my $i (reverse 0..$#{$hooks}) {
              splice @$hooks, $i, 1 if $code->($hooks->[$i]);
          }
      } elsif ($action eq 'reset') {
          my $saved = [@$hooks];
          splice @$hooks, 0, scalar(@$hooks),
              @{ $Log::ger::Default_Hooks{$phase} };
          return $saved;
      } elsif ($action eq 'empty') {
          my $saved = [@$hooks];
          splice @$hooks, 0;
          return $saved;
      } elsif ($action eq 'save') {
          return [@$hooks];
      } elsif ($action eq 'restore') {
          my $saved = shift;
          splice @$hooks, 0, scalar(@$hooks), @$saved;
          return $saved;
      }
  }
  
  sub add_hook {
      my ($phase, $hook) = @_;
      _action_on_hooks('add', '', undef, $phase, $hook);
  }
  
  sub add_per_target_hook {
      my ($target, $target_arg, $phase, $hook) = @_;
      _action_on_hooks('add', $target, $target_arg, $phase, $hook);
  }
  
  sub remove_hook {
      my ($phase, $code) = @_;
      _action_on_hooks('remove', '', undef, $phase, $code);
  }
  
  sub remove_per_target_hook {
      my ($target, $target_arg, $phase, $code) = @_;
      _action_on_hooks('remove', $target, $target_arg, $phase, $code);
  }
  
  sub reset_hooks {
      my ($phase) = @_;
      _action_on_hooks('reset', '', undef, $phase);
  }
  
  sub reset_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('reset', $target, $target_arg, $phase);
  }
  
  sub empty_hooks {
      my ($phase) = @_;
      _action_on_hooks('empty', '', undef, $phase);
  }
  
  sub empty_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('empty', $target, $target_arg, $phase);
  }
  
  sub save_hooks {
      my ($phase) = @_;
      _action_on_hooks('save', '', undef, $phase);
  }
  
  sub save_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('save', $target, $target_arg, $phase);
  }
  
  sub restore_hooks {
      my ($phase, $saved) = @_;
      _action_on_hooks('restore', '', undef, $phase, $saved);
  }
  
  sub restore_per_target_hooks {
      my ($target, $target_arg, $phase, $saved) = @_;
      _action_on_hooks('restore', $target, $target_arg, $phase, $saved);
  }
  
  sub reinit_target {
      my ($target, $target_arg) = @_;
  
      # adds target if not already exists
      Log::ger::add_target($target, $target_arg, {}, 0);
  
      if ($target eq 'package') {
          my $init_args = $Log::ger::Package_Targets{$target_arg};
          Log::ger::init_target(package => $target_arg, $init_args);
      } elsif ($target eq 'object') {
          my ($obj_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid object '$target_arg': not a reference";
          my $v = $Log::ger::Object_Targets{$obj_addr}
              or die "Unknown object target '$target_arg'";
          Log::ger::init_target(object => $v->[0], $v->[1]);
      } elsif ($target eq 'hash') {
          my ($hash_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid hashref '$target_arg': not a reference";
          my $v = $Log::ger::Hash_Targets{$hash_addr}
              or die "Unknown hash target '$target_arg'";
          Log::ger::init_target(hash => $v->[0], $v->[1]);
      } else {
          die "Unknown target '$target'";
      }
  }
  
  sub reinit_all_targets {
      for my $pkg (keys %Log::ger::Package_Targets) {
          Log::ger::init_target(
              package => $pkg, $Log::ger::Package_Targets{$pkg});
      }
      for my $k (keys %Log::ger::Object_Targets) {
          my ($obj, $init_args) = @{ $Log::ger::Object_Targets{$k} };
          Log::ger::init_target(object => $obj, $init_args);
      }
      for my $k (keys %Log::ger::Hash_Targets) {
          my ($hash, $init_args) = @{ $Log::ger::Hash_Targets{$k} };
          Log::ger::init_target(hash => $hash, $init_args);
      }
  }
  
  sub set_plugin {
      my %args = @_;
  
      my $hooks;
      if ($args{hooks}) {
          $hooks = $args{hooks};
      } else {
          no strict 'refs';
          my $prefix = $args{prefix} || 'Log::ger::Plugin::';
          my $mod = $args{name};
          $mod = $prefix . $mod unless index($mod, $prefix) == 0;
          (my $mod_pm = "$mod.pm") =~ s!::!/!g;
          require $mod_pm;
          $hooks = &{"$mod\::get_hooks"}(%{ $args{conf} || {} });
      }
  
      {
          last unless $args{replace_package_regex};
          my $all_hooks;
          if (!$args{target}) {
              $all_hooks = \%Log::ger::Global_Hooks;
          } elsif ($args{target} eq 'package') {
              $all_hooks = $Log::ger::Per_Package_Hooks{ $args{target_arg} };
          } elsif ($args{target} eq 'object') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Object_Hooks{$addr};
          } elsif ($args{target} eq 'hash') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Hash_Hooks{$addr};
          }
          last unless $all_hooks;
          for my $phase (keys %$all_hooks) {
              my $hooks = $all_hooks->{$phase};
              for my $i (reverse 0..$#{$hooks}) {
                  splice @$hooks, $i, 1
                      if $hooks->[$i][0] =~ $args{replace_package_regex};
              }
          }
      }
  
      for my $phase (keys %$hooks) {
          my $hook = $hooks->{$phase};
          if (defined $args{target}) {
              add_per_target_hook(
                  $args{target}, $args{target_arg}, $phase, $hook);
          } else {
              add_hook($phase, $hook);
          }
      }
  
      my $reinit = $args{reinit};
      $reinit = 1 unless defined $reinit;
      if ($reinit) {
          if (defined $args{target}) {
              reinit_target($args{target}, $args{target_arg});
          } else {
              reinit_all_targets();
          }
      }
  }
  
  1;
  # ABSTRACT: Utility routines for Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Util - Utility routines for Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This package is created to keep Log::ger as minimalist as possible.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_UTIL

$fatpacked{"Perinci/CmdLine/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERINCI_CMDLINE_ANY';
  package Perinci::CmdLine::Any;
  
  our $DATE = '2017-07-22'; # DATE
  our $VERSION = '0.14'; # VERSION
  
  # IFUNBUILT
  # use strict;
  # use warnings;
  # END IFUNBUILT
  
  my %Opts = (
      -prefer_lite => 1,
  );
  
  sub import {
      my ($class, %args) = @_;
      $Opts{$_} = $args{$_} for keys %args;
  }
  
  sub new {
      my $class = shift;
  
      my @mods;
      my $env = $ENV{PERINCI_CMDLINE_ANY};
      if ($env) {
          if ($env eq 'classic') {
              $env = 'Perinci::CmdLine::Classic';
          } elsif ($env eq 'lite') {
              $env = 'Perinci::CmdLine::Lite';
          }
          @mods = ($env);
      } elsif ($Opts{-prefer_lite}) {
          @mods = qw(Perinci::CmdLine::Lite Perinci::CmdLine::Classic);
      } else {
          @mods = qw(Perinci::CmdLine::Classic Perinci::CmdLine::Lite);
      }
  
      for my $i (1..@mods) {
          my $mod = $mods[$i-1];
          my $modpm = $mod; $modpm =~ s!::!/!g; $modpm .= ".pm";
          if ($i == @mods) {
              require $modpm;
              return $mod->new(@_);
          } else {
              my $res;
              eval {
                  require $modpm;
                  $res = $mod->new(@_);
              };
              if ($@) {
                  next;
              } else {
                  return $res;
              }
          }
      }
  }
  
  1;
  # ABSTRACT: Choose Perinci::CmdLine implementation (::Lite or ::Classic)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Perinci::CmdLine::Any - Choose Perinci::CmdLine implementation (::Lite or ::Classic)
  
  =head1 VERSION
  
  This document describes version 0.14 of Perinci::CmdLine::Any (from Perl distribution Perinci-CmdLine-Any), released on 2017-07-22.
  
  =head1 SYNOPSIS
  
  In your command-line script (this will pick ::Lite first):
  
   #!perl
   use Perinci::CmdLine::Any;
   Perinci::CmdLine::Any->new(url => '/Package/func')->run;
  
  In your command-line script (this will pick ::Classic first, and falls back to
  ::Lite):
  
   #!perl
   use Perinci::CmdLine::Any -prefer_lite=>0;
   Perinci::CmdLine::Any->new(url => '/Package/func')->run;
  
  =head1 DESCRIPTION
  
  This module lets you use L<Perinci::CmdLine::Lite> or
  L<Perinci::CmdLine::Classic>.
  
  If you want to force using a specific class, you can set the
  C<PERINCI_CMDLINE_ANY> environment variable, e.g. the command below will only
  try to use Perinci::CmdLine::Classic:
  
   % PERINCI_CMDLINE_ANY=Perinci::CmdLine::Classic yourapp.pl
   % PERINCI_CMDLINE_ANY=classic yourapp.pl
  
  If you want to prefer to Perinci::CmdLine::Classic (but user will still be able
  to override using C<PERINCI_CMDLINE_ANY>):
  
   use Perinci::CmdLine::Any -prefer_lite => 0;
  
  =for Pod::Coverage ^(new)$
  
  =head1 ENVIRONMENT
  
  =head2 PERINCI_CMDLINE_ANY => str
  
  Either specify module name, or C<lite> or C<classic>.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Perinci-CmdLine-Any>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Perinci-CmdLine-Any>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Perinci-CmdLine-Any>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Perinci::CmdLine::Lite>, L<Perinci::CmdLine::Classic>
  
  Another alternative backend, but not available through Perinci::CmdLine::Any
  since it works by generating script instead: L<Perinci::CmdLine::Inline>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017, 2016, 2015, 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PERINCI_CMDLINE_ANY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl

our $DATE = '2018-04-03'; # DATE
our $VERSION = '0.720'; # VERSION

use 5.010;
use strict;
use warnings;
use Log::ger;

use App::PMUtils;
use Perinci::CmdLine::Any;

our %SPEC;
$SPEC{pminfo} = {
    v => 1.1,
    summary => 'Get Perl module information',
    description => <<'_',

Will show this information about each Perl module:

* path
* version
* number of lines of code
*

_
    args => {
        module => $App::PMUtils::arg_module_multiple,
    },
    result_naked => 1,
};
sub pminfo {
    require Module::Load;
    require Module::Path::More;

    my %args = @_;
    my $mods = $args{module};

    my $res = [];
    for my $mod (@$mods) {
        $mod =~ s!/!::!g;
        my $rec = {module=>$mod};
        push @$res, $rec;
        my $mpath = Module::Path::More::module_path(module=>$mod);
        $rec->{path} = $mpath;
        next unless $mpath;
        # load to get $VERSION & $DATE
        {
            no strict 'refs';
            Module::Load::load($mod);
            $rec->{version} = ${"$mod\::VERSION"};
            $rec->{date} = ${"$mod\::DATE"};
        }
        if (open my($fh), "<", $mpath) {
            my $lines = 0; $lines++ while <$fh>;
            $rec->{lines} = $lines;
        }
    }

    $res;
}

Perinci::CmdLine::Any->new(
    url => '/main/pminfo',
)->run;

# ABSTRACT: Get Perl module information
# PODNAME: pminfo

__END__

=pod

=encoding UTF-8

=head1 NAME

pminfo - Get Perl module information

=head1 VERSION

This document describes version 0.720 of pminfo (from Perl distribution App-PMUtils), released on 2018-04-03.

=head1 SYNOPSIS

 % pminfo Some::Module Another::Module

=head1 DESCRIPTION

Will show this information about each Perl module:

=over

=item * path

=item * version

=item * number of lines of code
*

=back

=head1 OPTIONS

C<*> marks required options.

=head2 Main options

=over

=item B<--module-json>=I<s>

See C<--module>.

=item B<--module>=I<s@>*

Can be specified multiple times.

=back

=head2 Configuration options

=over

=item B<--config-path>=I<filename>

Set path to configuration file.

Can be specified multiple times.

=item B<--config-profile>=I<s>

Set configuration profile to use.

=item B<--no-config>

Do not use any configuration file.

=back

=head2 Environment options

=over

=item B<--no-env>

Do not read environment for default options.

=back

=head2 Output options

=over

=item B<--format>=I<s>

Choose output format, e.g. json, text.

Default value:

 undef

=item B<--json>

Set output format to json.

=item B<--naked-res>

When outputing as JSON, strip result envelope.

Default value:

 0

By default, when outputing as JSON, the full enveloped result is returned, e.g.:

    [200,"OK",[1,2,3],{"func.extra"=>4}]

The reason is so you can get the status (1st element), status message (2nd
element) as well as result metadata/extra result (4th element) instead of just
the result (3rd element). However, sometimes you want just the result, e.g. when
you want to pipe the result for more post-processing. In this case you can use
`--naked-res` so you just get:

    [1,2,3]


=back

=head2 Other options

=over

=item B<--help>, B<-h>, B<-?>

Display help message and exit.

=item B<--version>, B<-v>

Display program's version and exit.

=back

=head1 COMPLETION

This script has shell tab completion capability with support for several
shells.

=head2 bash

To activate bash completion for this script, put:

 complete -C pminfo pminfo

in your bash startup (e.g. F<~/.bashrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is recommended, however, that you install modules using L<cpanm-shcompgen>
which can activate shell completion for scripts immediately.

=head2 tcsh

To activate tcsh completion for this script, put:

 complete pminfo 'p/*/`pminfo`/'

in your tcsh startup (e.g. F<~/.tcshrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is also recommended to install L<shcompgen> (see above).

=head2 other shells

For fish and zsh, install L<shcompgen> as described above.

=head1 CONFIGURATION FILE

This script can read configuration files. Configuration files are in the format of L<IOD>, which is basically INI with some extra features.

By default, these names are searched for configuration filenames (can be changed using C<--config-path>): F<~/.config/pminfo.conf>, F<~/pminfo.conf>, or F</etc/pminfo.conf>.

All found files will be read and merged.

To disable searching for configuration files, pass C<--no-config>.

You can put multiple profiles in a single file by using section names like C<[profile=SOMENAME]> or C<[SOMESECTION profile=SOMENAME]>. Those sections will only be read if you specify the matching C<--config-profile SOMENAME>.

You can also put configuration for multiple programs inside a single file, and use filter C<program=NAME> in section names, e.g. C<[program=NAME ...]> or C<[SOMESECTION program=NAME]>. The section will then only be used when the reading program matches.

Finally, you can filter a section by environment variable using the filter C<env=CONDITION> in section names. For example if you only want a section to be read if a certain environment variable is true: C<[env=SOMEVAR ...]> or C<[SOMESECTION env=SOMEVAR ...]>. If you only want a section to be read when the value of an environment variable has value equals something: C<[env=HOSTNAME=blink ...]> or C<[SOMESECTION env=HOSTNAME=blink ...]>. If you only want a section to be read when the value of an environment variable does not equal something: C<[env=HOSTNAME!=blink ...]> or C<[SOMESECTION env=HOSTNAME!=blink ...]>. If you only want a section to be read when an environment variable contains something: C<[env=HOSTNAME*=server ...]> or C<[SOMESECTION env=HOSTNAME*=server ...]>. Note that currently due to simplistic parsing, there must not be any whitespace in the value being compared because it marks the beginning of a new section filter or section name.

List of available configuration parameters:

 format (see --format)
 module (see --module)
 naked_res (see --naked-res)

=head1 ENVIRONMENT

=head2 PMINFO_OPT => str

Specify additional command-line options.

=head1 FILES

F<~/.config/pminfo.conf>

F<~/pminfo.conf>

F</etc/pminfo.conf>

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/App-PMUtils>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-App-PMUtils>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-PMUtils>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 SEE ALSO

L<pmversion>

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2018, 2017, 2016, 2015, 2014 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
