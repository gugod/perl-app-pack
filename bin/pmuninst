#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/ModuleUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MODULEUTILS';
  package App::ModuleUtils;
  
  our $DATE = '2018-04-03'; # DATE
  our $VERSION = '0.720'; # VERSION
  
  1;
  # ABSTRACT: Alias for App::PMUtils
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::ModuleUtils - Alias for App::PMUtils
  
  =head1 VERSION
  
  This document describes version 0.720 of App::ModuleUtils (from Perl distribution App-PMUtils), released on 2018-04-03.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/App-PMUtils>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-App-PMUtils>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-PMUtils>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<App::PMUtils>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_MODULEUTILS

$fatpacked{"App/PMUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PMUTILS';
  package App::PMUtils;
  
  our $DATE = '2018-04-03'; # DATE
  our $VERSION = '0.720'; # VERSION
  
  use 5.010001;
  
  our %SPEC;
  
  our $arg_module_multiple = {
      schema => ['array*' => of=>'perl::modname*', min_len=>1],
      req    => 1,
      pos    => 0,
      greedy => 1,
      element_completion => sub {
          require Complete::Module;
          my %args = @_;
          Complete::Module::complete_module(word=>$args{word});
      },
  };
  
  our $arg_module_single = {
      schema => 'perl::modname*',
      req    => 1,
      pos    => 0,
      completion => sub {
          require Complete::Module;
          my %args = @_;
          Complete::Module::complete_module(word=>$args{word});
      },
  };
  
  $SPEC{pmpath} = {
      v => 1.1,
      summary => 'Get path to locally installed Perl module',
      args => {
          module => $App::PMUtils::arg_module_multiple,
          all => {
              summary => 'Return all found files for each module instead of the first one',
              schema => 'bool',
              cmdline_aliases => {a=>{}},
          },
          abs => {
              summary => 'Absolutify each path',
              schema => 'bool',
              cmdline_aliases => {P=>{}},
          },
          pm => {
              schema => ['int*', min=>0],
              default => 1,
          },
          pmc => {
              schema => ['int*', min=>0],
              default => 0,
          },
          pod => {
              schema => ['int*', min=>0],
              default => 0,
          },
          prefix => {
              schema => ['int*', min=>0],
              default => 0,
          },
          dir => {
              summary => 'Show directory instead of path',
              description => <<'_',
  
  Also, will return `.` if not found, so you can conveniently do this on a Unix
  shell:
  
      % cd `pmpath -Pd Moose`
  
  and it won't change directory if the module doesn't exist.
  
  _
              schema  => ['bool', is=>1],
              cmdline_aliases => {d=>{}},
          },
      },
  };
  sub pmpath {
      require Module::Path::More;
      my %args = @_;
  
      my $mods = $args{module};
      my $res = [];
      my $found;
  
      for my $mod (@{$mods}) {
          my $mpath = Module::Path::More::module_path(
              module      => $mod,
              find_pm     => $args{pm},
              find_pmc    => $args{pmc},
              find_pod    => $args{pod},
              find_prefix => $args{prefix},
              abs         => $args{abs},
              all         => $args{all},
          );
          $found++ if $mpath;
          for (ref($mpath) eq 'ARRAY' ? @$mpath : ($mpath)) {
              if ($args{dir}) {
                  require File::Spec;
                  my ($vol, $dir, $file) = File::Spec->splitpath($_);
                  $_ = $dir;
              }
              push @$res, @$mods > 1 ? {module=>$mod, path=>$_} : $_;
          }
      }
  
      if ($found) {
          [200, "OK", $res];
      } else {
          if ($args{dir}) {
              [200, "OK (not found)", "."];
          } else {
              [404, "No such module"];
          }
      }
  }
  
  $SPEC{pmdir} = do {
      my $meta = { %{ $SPEC{pmpath} } }; # shallow copy
      $meta->{summary} = "Get directory of locally installed Perl module/prefix";
      $meta->{description} = <<'_';
  
  This is basically a shortcut for:
  
      % pmpath -Pd MODULE_OR_PREFIX_NAME
  
  Sometimes I forgot that <prog:pmpath> has a `-d` option, and often intuitively
  look for a <prog:pmdir> command.
  
  _
      $meta->{args} = { %{ $SPEC{pmpath}{args} } }; # shalow copy
      delete $meta->{args}{all};
      delete $meta->{args}{dir};
      delete $meta->{args}{prefix};
      $meta;
  };
  sub pmdir {
      pmpath(@_, prefix=>1, dir=>1);
  }
  
  $SPEC{rel2mod} = {
      v => 1.1,
      summary => 'Convert release name (e.g. Foo-Bar-1.23.tar.gz) to '.
          'module name (Foo::Bar)',
      args => {
          releases => {
              #'x.name.is_plural' => 1,
              schema => ['array*', of=>'str*'],
              req => 1,
              pos => 0,
              greedy => 1,
              cmdline_src => 'stdin_or_args',
          },
      },
      result_naked => 1,
  };
  sub rel2mod {
      my %args = @_;
  
      #use DD; dd \%args;
  
      my @res;
      for (@{ $args{releases} }) {
          s!.+/!!; # remove directory path
          s/(.+)-v?\d.+/$1/;
          s/-/::/g;
          push @res, $_;
      }
  
      \@res;
  }
  
  1;
  # ABSTRACT: Command-line utilities related to Perl modules
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::PMUtils - Command-line utilities related to Perl modules
  
  =head1 VERSION
  
  This document describes version 0.720 of App::PMUtils (from Perl distribution App-PMUtils), released on 2018-04-03.
  
  =head1 SYNOPSIS
  
  This distribution provides the following command-line utilities related to Perl
  modules:
  
  =over
  
  =item * L<module-dir>
  
  =item * L<pmbin>
  
  =item * L<pmcat>
  
  =item * L<pmchkver>
  
  =item * L<pmcore>
  
  =item * L<pmcost>
  
  =item * L<pmdir>
  
  =item * L<pmdoc>
  
  =item * L<pmedit>
  
  =item * L<pmhtml>
  
  =item * L<pminfo>
  
  =item * L<pmless>
  
  =item * L<pmlines>
  
  =item * L<pmlist>
  
  =item * L<pmman>
  
  =item * L<pmminversion>
  
  =item * L<pmpath>
  
  =item * L<pmstripper>
  
  =item * L<pmuninst>
  
  =item * L<pmversion>
  
  =item * L<pmxs>
  
  =item * L<podlist>
  
  =item * L<podpath>
  
  =item * L<pwd2mod>
  
  =item * L<rel2mod>
  
  =back
  
  The main purpose of these utilities is tab completion.
  
  =head1 FUNCTIONS
  
  
  =head2 pmdir
  
  Usage:
  
   pmdir(%args) -> [status, msg, result, meta]
  
  Get directory of locally installed Perl module/prefix.
  
  This is basically a shortcut for:
  
   % pmpath -Pd MODULE_OR_PREFIX_NAME
  
  Sometimes I forgot that L<pmpath> has a C<-d> option, and often intuitively
  look for a L<pmdir> command.
  
  This function is not exported.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<abs> => I<bool>
  
  Absolutify each path.
  
  =item * B<module>* => I<array[perl::modname]>
  
  =item * B<pm> => I<int> (default: 1)
  
  =item * B<pmc> => I<int> (default: 0)
  
  =item * B<pod> => I<int> (default: 0)
  
  =back
  
  Returns an enveloped result (an array).
  
  First element (status) is an integer containing HTTP status code
  (200 means OK, 4xx caller error, 5xx function error). Second element
  (msg) is a string containing error message, or 'OK' if status is
  200. Third element (result) is optional, the actual result. Fourth
  element (meta) is called result metadata and is optional, a hash
  that contains extra information.
  
  Return value:  (any)
  
  
  =head2 pmpath
  
  Usage:
  
   pmpath(%args) -> [status, msg, result, meta]
  
  Get path to locally installed Perl module.
  
  This function is not exported.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<abs> => I<bool>
  
  Absolutify each path.
  
  =item * B<all> => I<bool>
  
  Return all found files for each module instead of the first one.
  
  =item * B<dir> => I<bool>
  
  Show directory instead of path.
  
  Also, will return C<.> if not found, so you can conveniently do this on a Unix
  shell:
  
   % cd C<pmpath -Pd Moose>
  
  and it won't change directory if the module doesn't exist.
  
  =item * B<module>* => I<array[perl::modname]>
  
  =item * B<pm> => I<int> (default: 1)
  
  =item * B<pmc> => I<int> (default: 0)
  
  =item * B<pod> => I<int> (default: 0)
  
  =item * B<prefix> => I<int> (default: 0)
  
  =back
  
  Returns an enveloped result (an array).
  
  First element (status) is an integer containing HTTP status code
  (200 means OK, 4xx caller error, 5xx function error). Second element
  (msg) is a string containing error message, or 'OK' if status is
  200. Third element (result) is optional, the actual result. Fourth
  element (meta) is called result metadata and is optional, a hash
  that contains extra information.
  
  Return value:  (any)
  
  
  =head2 rel2mod
  
  Usage:
  
   rel2mod(%args) -> any
  
  Convert release name (e.g. Foo-Bar-1.23.tar.gz) to module name (Foo::Bar).
  
  This function is not exported.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<releases>* => I<array[str]>
  
  =back
  
  Return value:  (any)
  
  =head1 FAQ
  
  =for BEGIN_BLOCK: faq
  
  =head2 What is the purpose of this distribution? Haven't other similar utilities existed?
  
  For example, L<mpath> from L<Module::Path> distribution is similar to L<pmpath>
  in L<App::PMUtils>, and L<mversion> from L<Module::Version> distribution is
  similar to L<pmversion> from L<App::PMUtils> distribution, and so on.
  
  True. The main point of these utilities is shell tab completion, to save
  typing.
  
  =for END_BLOCK: faq
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/App-PMUtils>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-App-PMUtils>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-PMUtils>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  =for BEGIN_BLOCK: see_also
  
  Below is the list of distributions that provide CLI utilities for various
  purposes, with the focus on providing shell tab completion feature.
  
  L<App::DistUtils>, utilities related to Perl distributions.
  
  L<App::DzilUtils>, utilities related to L<Dist::Zilla>.
  
  L<App::GitUtils>, utilities related to git.
  
  L<App::IODUtils>, utilities related to L<IOD> configuration files.
  
  L<App::LedgerUtils>, utilities related to Ledger CLI files.
  
  L<App::PlUtils>, utilities related to Perl scripts.
  
  L<App::PMUtils>, utilities related to Perl modules.
  
  L<App::ProgUtils>, utilities related to programs.
  
  L<App::WeaverUtils>, utilities related to L<Pod::Weaver>.
  
  =for END_BLOCK: see_also
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_PMUTILS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use strict;
  use warnings;
  use Exporter   ();
  use File::Spec ();
  
  # ABSTRACT: Perl implementation of the which utility as an API
  our $VERSION = '1.22'; # VERSION
  
  
  our @ISA       = 'Exporter';
  our @EXPORT    = 'which';
  our @EXPORT_OK = 'where';
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  use constant IS_CYG => ($^O eq 'cygwin' || $^O eq 'msys');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
    # WinNT. PATHEXT might be set on Cygwin, but not used.
    if ( $ENV{PATHEXT} ) {
      push @PATHEXT, split ';', $ENV{PATHEXT};
    } else {
      # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
      push @PATHEXT, qw{.com .exe .bat};
    }
  } elsif ( IS_VMS ) {
    push @PATHEXT, qw{.exe .com};
  } elsif ( IS_CYG ) {
    # See this for more info
    # http://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-exe
    push @PATHEXT, qw{.exe .com};
  }
  
  
  sub which {
    my ($exec) = @_;
  
    return undef unless defined $exec;
    return undef if $exec eq '';
  
    my $all = wantarray;
    my @results = ();
  
    # check for aliases first
    if ( IS_VMS ) {
      my $symbol = `SHOW SYMBOL $exec`;
      chomp($symbol);
      unless ( $? ) {
        return $symbol unless $all;
        push @results, $symbol;
      }
    }
    if ( IS_MAC ) {
      my @aliases = split /\,/, $ENV{Aliases};
      foreach my $alias ( @aliases ) {
        # This has not been tested!!
        # PPT which says MPW-Perl cannot resolve `Alias $alias`,
        # let's just hope it's fixed
        if ( lc($alias) eq lc($exec) ) {
          chomp(my $file = `Alias $alias`);
          last unless $file;  # if it failed, just go on the normal way
          return $file unless $all;
          push @results, $file;
          # we can stop this loop as if it finds more aliases matching,
          # it'll just be the same result anyway
          last;
        }
      }
    }
  
    return $exec
            if !IS_VMS and !IS_MAC and !IS_DOS and $exec =~ /\// and -f $exec and -x $exec;
  
    my @path = File::Spec->path;
    if ( IS_DOS or IS_VMS or IS_MAC ) {
      unshift @path, File::Spec->curdir;
    }
  
    foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
      for my $ext ( @PATHEXT ) {
        my $file = $base.$ext;
  
        # We don't want dirs (as they are -x)
        next if -d $file;
  
        if (
          # Executable, normal case
          -x _
          or (
            # MacOS doesn't mark as executable so we check -e
            IS_MAC
            ||
            (
              ( IS_DOS or IS_CYG )
              and
              grep {
                $file =~ /$_\z/i
              } @PATHEXT[1..$#PATHEXT]
            )
            # DOSish systems don't pass -x on
            # non-exe/bat/com files. so we check -e.
            # However, we don't want to pass -e on files
            # that aren't in PATHEXT, like README.
            and -e _
          )
        ) {
          return $file unless $all;
          push @results, $file;
        }
      }
    }
  
    if ( $all ) {
      return @results;
    } else {
      return undef;
    }
  }
  
  
  sub where {
    # force wantarray
    my @res = which($_[0]);
    return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Which - Perl implementation of the which utility as an API
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
   use File::Which;                  # exports which()
   use File::Which qw(which where);  # exports which() and where()
   
   my $exe_path = which 'perldoc';
   
   my @paths = where 'perl';
   # Or
   my @paths = which 'perl'; # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  L<File::Which> finds the full or relative paths to executable programs on
  the system.  This is normally the function of C<which> utility.  C<which> is
  typically implemented as either a program or a built in shell command.  On
  some platforms, such as Microsoft Windows it is not provided as part of the
  core operating system.  This module provides a consistent API to this
  functionality regardless of the underlying platform.
  
  The focus of this module is correctness and portability.  As a consequence
  platforms where the current directory is implicitly part of the search path
  such as Microsoft Windows will find executables in the current directory,
  whereas on platforms such as UNIX where this is not the case executables 
  in the current directory will only be found if the current directory is
  explicitly added to the path.
  
  If you need a portable C<which> on the command line in an environment that
  does not provide it, install L<App::pwhich> which provides a command line
  interface to this API.
  
  =head2 Implementations
  
  L<File::Which> searches the directories of the user's C<PATH> (the current
  implementation uses L<File::Spec#path> to determine the correct C<PATH>),
  looking for executable files having the name specified as a parameter to
  L</which>. Under Win32 systems, which do not have a notion of directly
  executable files, but uses special extensions such as C<.exe> and C<.bat>
  to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head3 Linux, *BSD and other UNIXes
  
  There should not be any surprises here.  The current directory will not be
  searched unless it is explicitly added to the path.
  
  =head3 Modern Windows (including NT, XP, Vista, 7, 8, 10 etc)
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head3 Cygwin
  
  Cygwin provides a Unix-like environment for Microsoft Windows users.  In most
  ways it works like other Unix and Unix-like environments, but in a few key
  aspects it works like Windows.  As with other Unix environments, the current
  directory is not included in the search unless it is explicitly included in
  the search path.  Like on Windows, files with C<.EXE> or <.BAT> extensions will
  be discovered even if they are not part of the query.  C<.COM> or extensions
  specified using the C<PATHEXT> environment variable will NOT be discovered
  without the fully qualified name, however.
  
  =head3 Windows 95, 98, ME, MS-DOS, OS/2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  As of 2015 none of these platforms are tested frequently (or perhaps ever),
  but the current maintainer is determined not to intentionally remove support
  for older operating systems.
  
  =head3 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  As of 2015 the current maintainer does not test on VMS, and is in fact not
  certain it has ever been tested on VMS.  If this platform is important to you
  and you can help me verify and or support it on that platform please contact
  me.
  
  =head1 FUNCTIONS
  
  =head2 which
  
   my $path = which $short_exe_name;
   my @paths = which $short_exe_name;
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where
  
   my @paths = where $short_exe_name;
  
  Not exported by default.
  
  Same as L</which> in array context. Same as the
  C<where> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 CAVEATS
  
  This module has no non-core requirements for Perl 5.6.2 and better.
  
  This module is fully supported back to Perl 5.8.1.  It may work on 5.8.0.  
  It should work on Perl 5.6.x and I may even test on 5.6.2.  I will accept
  patches to maintain compatibility for such older Perls, but you may
  need to fix it on 5.6.x / 5.8.0 and send me a patch.
  
  Not tested on VMS although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  =head1 SUPPORT
  
  Bugs should be reported via the GitHub issue tracker
  
  L<https://github.com/plicease/File-Which/issues>
  
  For other issues, contact the maintainer.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<pwhich>, L<App::pwhich>
  
  Command line interface to this module.
  
  =item L<IPC::Cmd>
  
  Comes with a C<can_run> function with slightly different semantics that
  the traditional UNIX where.  It will find executables in the current
  directory, even though the current directory is not searched for by
  default on Unix.
  
  =item L<Devel::CheckBin>
  
  This module purports to "check that a command is available", but does not
  provide any documentation on how you might use it.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Per Einar Ellefsen <pereinar@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2002 by Per Einar Ellefsen <pereinar@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_WHICH

$fatpacked{"IO/Prompt/I18N.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PROMPT_I18N';
  package IO::Prompt::I18N;
  
  our $DATE = '2015-01-03'; # DATE
  our $VERSION = '0.80'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(prompt confirm);
  
  sub prompt {
      my ($text, $opts) = @_;
  
      $text //= "Enter value";
      $opts //= {};
  
      my $answer;
  
      my $default;
      $default = ${$opts->{var}} if $opts->{var};
      $default = $opts->{default} if defined($opts->{default});
  
      while (1) {
          # prompt
          print $text;
          print " ($default)" if defined($default) && $opts->{show_default}//1;
          print ":" unless $text =~ /[:?]\s*$/;
          print " ";
  
          # get input
          $answer = <STDIN>;
          if (!defined($answer)) {
              print "\n";
              $answer = "";
          }
          chomp($answer);
  
          # check+process answer
          if (defined($default)) {
              $answer = $default if !length($answer);
          }
          my $success = 1;
          if ($opts->{required}) {
              $success = 0 if !length($answer);
          }
          if ($opts->{regex}) {
              $success = 0 if $answer !~ /$opts->{regex}/;
          }
          last if $success;
      }
      ${$opts->{var}} = $answer if $opts->{var};
      $answer;
  }
  
  sub confirm {
      my ($text, $opts) = @_;
  
      $opts //= {};
  
      state $supported_langs = {
          en => {yes_words=>[qw/y yes/], no_words=>[qw/n no/]   , text=>'Confirm'},
          fr => {yes_words=>[qw/o oui/], no_words=>[qw/n non/]  , text=>'Confirmer'},
          id => {yes_words=>[qw/y ya/] , no_words=>[qw/t tidak/], text=>'Konfirmasi'},
      };
  
      $opts->{lang} //= do {
          if ($ENV{LANG} && $ENV{LANG} =~ /^([a-z]{2})/ &&
                  $supported_langs->{$1}) {
              $1;
          } elsif ($ENV{LANGUAGE} && $ENV{LANGUAGE} =~ /^([a-z]{2})/ &&
                  $supported_langs->{$1}) {
              $1;
          } else {
              'en';
          }
      };
  
      my $lang = $supported_langs->{$opts->{lang}}
          or die "Unknown language '$opts->{lang}'";
      $text //= $lang->{text};
      $opts->{yes_words} //= $lang->{yes_words};
      $opts->{no_words}  //= $lang->{no_words};
  
      my $default;
      if (defined $opts->{default}) {
          if ($opts->{default}) {
              $default = $opts->{yes_words}[0];
          } else {
              $default = $opts->{no_words}[0];
          }
      }
  
      my $suffix;
      my $show_default = 1;
      unless ($text =~ /[?]/) {
          $text .=
              join("",
                   " (",
                   join("/",
                        (map {$opts->{default} ? uc($_) : lc($_)}
                             @{ $opts->{yes_words} }),
                        (map {defined($opts->{default}) && !$opts->{default} ?
                                          uc($_) : lc($_)}
                             @{ $opts->{no_words} }),
                    ),
                   ")?",
               );
          $show_default = 0; # because we already indicate which using uppercase
      }
  
      my $re = join("|", map {quotemeta}
                        (@{$opts->{yes_words}}, @{$opts->{no_words}}));
      $re = qr/\A($re)\z/i;
  
      my $answer = prompt($text, {
          required     => 1,
          regex        => $re,
          show_default => $show_default,
          default      => $default,
      });
      use experimental 'smartmatch';
      $answer ~~ @{$opts->{yes_words}} ? 1:0;
  }
  
  1;
  # ABSTRACT: Prompt user question, with some options (including I18N)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  IO::Prompt::I18N - Prompt user question, with some options (including I18N)
  
  =head1 VERSION
  
  This document describes version 0.80 of IO::Prompt::I18N (from Perl distribution IO-Prompt-I18N), released on 2015-01-03.
  
  =head1 SYNOPSIS
  
   use IO::Prompt::I18N qw(prompt confirm);
   use Text::LocaleDomain 'My-App';
  
   my $file = prompt(__"Enter filename");
  
   if (confirm(__"Really delete filename", {lang=>"id", default=>0})) {
       unlink $file;
   }
  
  =head1 DESCRIPTION
  
  This module provides the C<prompt> function to ask for a value from STDIN. It
  features prompt text, default value, validation (using regex),
  optional/required. It also provides C<confirm> wrapper to ask yes/no, with
  localizable text.
  
  =head1 FUNCTIONS
  
  =head2 prompt([ $text[, \%opts] ]) => val
  
  Display C<$text> and ask value from STDIN. Will re-ask if value is not valid.
  Return the chomp-ed value.
  
  Options:
  
  =over
  
  =item * var => \$var
  
  =item * required => bool
  
  If set to true then will require that value is not empty (zero-length).
  
  =item * default => VALUE
  
  Set default value.
  
  =item * show_default => bool (default: 1)
  
  Whether to show default value if defined.
  
  =item * regex => REGEX
  
  Validate using regex.
  
  =back
  
  =head2 confirm([ $text, [\%opts] ]) => bool
  
  Display C<$text> (defaults to C<Confirm> in English) and ask for yes or no. Will
  return bool. Basically a convenient wrapper around C<prompt>.
  
  Options:
  
  =over
  
  =item * lang => str
  
  Support several languages (C<id>, C<en>, C<fr>). Default to using LANG/LANGUAGE
  or English. Will preset C<yes_words> and C<no_words> and adds the choice of
  words to C<$text>. Will die if language is not supported. Here are the supported
  languages:
  
    lang  yes_words     no_regex   default text
    ----  ---------     --------   ------------
    en    y, yes        n, no      Confirm
    fr    o, oui        n, non     Confirmer
    id    y, ya         t, tidak   Konfirmasi
  
  =item * yes_words => array
  
  Overrides preset from C<lang>.
  
  =item * no_words => array
  
  Overrides preset from C<lang>.
  
  =item * default => bool
  
  Set default value.
  
  =back
  
  =head1 SEE ALSO
  
  L<IO::Prompt>, L<IO::Prompt::Tiny>, L<Term::Prompt>, L<Prompt::Timeout>
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/IO-Prompt-I18N>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-IO-Prompt-I18N>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=IO-Prompt-I18N>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
IO_PROMPT_I18N

$fatpacked{"IPC/System/Options.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_SYSTEM_OPTIONS';
  package IPC::System::Options;
  
  our $DATE = '2017-08-10'; # DATE
  our $VERSION = '0.330'; # VERSION
  
  use strict;
  use warnings;
  
  use Proc::ChildError qw(explain_child_error);
  use String::ShellQuote;
  
  my $log;
  our %Global_Opts;
  
  sub import {
      my $self = shift;
  
      my $caller = caller();
      my $i = 0;
      while ($i < @_) {
          # backtick is the older, deprecated name for readpipe
          if ($_[$i] =~ /\A(system|readpipe|backtick|run|import)\z/) {
              no strict 'refs';
              *{"$caller\::$_[$i]"} = \&{"$self\::" . $_[$i]};
          } elsif ($_[$i] =~ /\A-(.+)/) {
              die "$_[$i] requires an argument" unless $i < @_-1;
              $Global_Opts{$1} = $_[$i+1];
              $i++;
          } else {
              die "$_[$i] is not exported by ".__PACKAGE__;
          }
          $i++;
      }
  }
  
  sub _quote {
      if (@_ == 1) {
          return $_[0];
      }
  
      if ($^O eq 'MSWin32') {
          require Win32::ShellQuote;
          return Win32::ShellQuote::quote_system_string(@_);
      } else {
          return shell_quote(@_);
      }
  }
  
  sub _system_or_readpipe_or_run {
      my $which = shift;
      my $opts = ref($_[0]) eq 'HASH' ? shift : {};
      for (keys %Global_Opts) {
          $opts->{$_} = $Global_Opts{$_} if !defined($opts->{$_});
      }
      my @args = @_;
  
      # check known options
      for (keys %$opts) {
          die "Unknown option '$_'"
              unless /\A(
                          capture_stdout|capture_stderr|capture_merged|
                          tee_stdout|tee_stderr|tee_merged|
                          chdir|dies?|dry_run|env|lang|log||max_log_output|shell|
                          stdin # XXX: only for run()
                      )\z/x;
      }
  
      my $opt_die = $opts->{die} || $opts->{dies};
  
      my $exit_code;
      my $os_error = "";
      my $extra_error;
  
      if ($opts->{log}) {
          require Log::ger;
          Log::ger->import;
      }
  
      my $cwd;
      if ($opts->{chdir}) {
          require Cwd;
          $cwd = Cwd::getcwd();
          if (!defined $cwd) { # checking $! is always true here, why?
              $log->error("Can't getcwd: $!") if $log;
              $exit_code = -1;
              $os_error = $!;
              $extra_error = "Can't getcwd";
              goto CHECK_RESULT;
          }
          unless (chdir $opts->{chdir}) {
              $log->error("Can't chdir to '$opts->{chdir}': $!") if $log;
              $exit_code = -1;
              $os_error = $!;
              $extra_error = "Can't chdir";
              goto CHECK_RESULT;
          }
      }
  
      # set ENV
      my %save_env;
      my %set_env;
      if ($opts->{lang}) {
          $set_env{LC_ALL}   = $opts->{lang};
          $set_env{LANGUAGE} = $opts->{lang};
          $set_env{LANG}     = $opts->{lang};
      }
      if ($opts->{env}) {
          $set_env{$_} = $opts->{env}{$_} for keys %{ $opts->{env} };
      }
      if (%set_env) {
          for (keys %set_env) {
              $save_env{$_} = $ENV{$_};
              $ENV{$_} = $set_env{$_};
          }
      }
  
      my $wa;
      my $res;
  
      my $code_capture = sub {
          my $doit = shift;
  
          if ($opts->{capture_stdout} && $opts->{capture_stderr}) {
              require Capture::Tiny;
              (${ $opts->{capture_stdout} }, ${ $opts->{capture_stderr} }) =
                  &Capture::Tiny::capture($doit);
          } elsif ($opts->{capture_merged}) {
              require Capture::Tiny;
              ${ $opts->{capture_merged} } =
                  &Capture::Tiny::capture_merged($doit);
          } elsif ($opts->{capture_stdout}) {
              require Capture::Tiny;
              ${ $opts->{capture_stdout} } =
                  &Capture::Tiny::capture_stdout($doit);
          } elsif ($opts->{capture_stderr}) {
              require Capture::Tiny;
              ${ $opts->{capture_stderr} } =
                  &Capture::Tiny::capture_stderr($doit);
  
          } elsif ($opts->{tee_stdout} && $opts->{tee_stderr}) {
              require Capture::Tiny;
              (${ $opts->{tee_stdout} }, ${ $opts->{tee_stderr} }) =
                  &Capture::Tiny::tee($doit);
          } elsif ($opts->{tee_merged}) {
              require Capture::Tiny;
              ${ $opts->{tee_merged} } =
                  &Capture::Tiny::tee_merged($doit);
          } elsif ($opts->{tee_stdout}) {
              require Capture::Tiny;
              ${ $opts->{tee_stdout} } =
                  &Capture::Tiny::tee_stdout($doit);
          } elsif ($opts->{tee_stderr}) {
              require Capture::Tiny;
              ${ $opts->{tee_stderr} } =
                  &Capture::Tiny::tee_stderr($doit);
          } else {
              $doit->();
          }
      };
  
      if ($which eq 'system') {
  
          if ($opts->{log} || $opts->{dry_run}) {
              if ($opts->{log}) {
                  no strict 'refs';
                  my $routine;
                  my $label = "";
                  if ($opts->{dry_run}) {
                      $label = "[DRY RUN] ";
                      $routine = "log_info";
                  } else {
                      $routine = "log_trace";
                  }
                  $routine->("%ssystem(%s), env=%s", $label, \@args, \%set_env);
              } else {
                  warn "[DRY RUN] system(".join(", ", @args).")\n";
              }
              if ($opts->{dry_run}) {
                  $exit_code = 0;
                  $res = "";
                  goto CHECK_RESULT;
              }
          }
  
          my $doit = sub {
              if ($opts->{shell}) {
                  # force the use of shell
                  $res = system _quote(@args);
              } elsif (defined $opts->{shell}) {
                  # forbid shell
                  $res = system {$args[0]} @args;
              } else {
                  # might or might not use shell (if @args == 1)
                  $res = system @args;
              }
              $exit_code = $?;
              $os_error = $!;
          };
          $code_capture->($doit);
  
      } elsif ($which eq 'readpipe') {
  
          $wa = wantarray;
          my $cmd = _quote(@args);
  
          if ($opts->{log} || $opts->{dry_run}) {
              if ($opts->{log}) {
                  no strict 'refs';
                  my $routine;
                  my $label = "";
                  if ($opts->{dry_run}) {
                      $label = "[DRY RUN] ";
                      $routine = "log_info";
                  } else {
                      $routine = "log_trace";
                  }
                  $routine->("%sreadpipe(%s), env=%s", $label, $cmd, \%set_env);
              } else {
                  warn "[DRY RUN] readpipe($cmd)\n";
              }
              if ($opts->{dry_run}) {
                  $exit_code = 0;
                  $res = "";
                  goto CHECK_RESULT;
              }
          }
  
          my $doit = sub {
              if ($wa) {
                  $res = [`$cmd`];
              } else {
                  $res = `$cmd`;
              }
              $exit_code = $?;
              $os_error = $!;
          };
          $code_capture->($doit);
  
          # log output
          if ($opts->{log}) {
              my $res_show;
              if (defined $opts->{max_log_output}) {
                  $res_show = '';
                  if ($wa) {
                      for (@$res) {
                          if (length($res_show) + length($_) >=
                                  $opts->{max_log_output}) {
                              $res_show .= substr(
                                  $_,0,$opts->{max_log_output}-length($res_show));
                              last;
                          } else {
                              $res_show .= $_;
                          }
                      }
                  } else {
                      if (length($res) > $opts->{max_log_output}) {
                          $res_show = substr($res, 0, $opts->{max_log_output});
                      }
                  }
              }
              log_trace("result of readpipe(): %s (%d bytes)",
                        defined($res_show) ? $res_show : $res,
                        defined($res_show) ?
                            $opts->{max_log_output} : length($res))
                  unless $exit_code;
          }
  
      } else {
  
          if ($opts->{log} || $opts->{dry_run}) {
              if ($opts->{log}) {
                  no strict 'refs';
                  my $routine;
                  my $label = "";
                  if ($opts->{dry_run}) {
                      $label = "[DRY RUN] ";
                      $routine = "log_info";
                  } else {
                      $routine = "log_trace";
                  }
                  $routine->("%srun(%s), env=%s", $label,
                             join(", ", @args), \%set_env);
              } else {
                  warn "[DRY RUN] run(".join(", ", @args).")\n";
              }
              if ($opts->{dry_run}) {
                  $exit_code = 0;
                  $res = "";
                  goto CHECK_RESULT;
              }
          }
  
          require IPC::Run;
          $res = IPC::Run::run(
              \@args,
              defined($opts->{stdin}) ? \$opts->{stdin} : \*STDIN,
              sub {
                  if ($opts->{capture_stdout}) {
                      ${$opts->{capture_stdout}} .= $_[0];
                  } else {
                      print $_[0];
                  }
              }, # out
              sub {
                  if ($opts->{capture_stderr}) {
                      ${$opts->{capture_stderr}} .= $_[0];
                  } else {
                      print STDERR $_[0];
                  }
              }, # err
          );
          $exit_code = $?;
          $os_error = $!;
  
      } # which
  
      # restore ENV
      if (%save_env) {
          for (keys %save_env) {
              if (defined $save_env{$_}) {
                  $ENV{$_} = $save_env{$_};
              } else {
                  undef $ENV{$_};
              }
          }
      }
  
      # restore previous working directory
      if ($cwd) {
          unless (chdir $cwd) {
              $log->error("Can't chdir back to '$cwd': $!") if $log;
              $exit_code ||= -1;
              $os_error = $!;
              $extra_error = "Can't chdir back";
              goto CHECK_RESULT;
          }
      }
  
    CHECK_RESULT:
      if ($exit_code) {
          if ($opts->{log} || $opt_die) {
              my $msg = sprintf(
                  "%s(%s) failed: %s (%s)%s%s%s",
                  $which,
                  join(" ", @args),
                  defined $extra_error ? "" : $exit_code,
                  defined $extra_error ? "$extra_error: $os_error" : explain_child_error($exit_code, $os_error),
                  (ref($opts->{capture_stdout}) ?
                       ", captured stdout: <<" .
                       (defined ${$opts->{capture_stdout}} ? ${$opts->{capture_stdout}} : ''). ">>" : ""),
                  (ref($opts->{capture_stderr}) ?
                       ", captured stderr: <<" .
                       (defined ${$opts->{capture_stderr}} ? ${$opts->{capture_stderr}} : ''). ">>" : ""),
                  (ref($opts->{capture_merged}) ?
                       ", captured merged: <<" .
                       (defined ${$opts->{capture_merged}} ? ${$opts->{capture_merged}} : ''). ">>" : ""),
              );
              log_error($msg) if $opts->{log};
              die $msg if $opt_die;
          }
      }
  
      $? = $exit_code;
  
      return $wa && $which ne 'run' ? @$res : $res;
  }
  
  sub system {
      _system_or_readpipe_or_run('system', @_);
  }
  
  # backtick is the older, deprecated name for readpipe
  sub backtick {
      _system_or_readpipe_or_run('readpipe', @_);
  }
  
  sub readpipe {
      _system_or_readpipe_or_run('readpipe', @_);
  }
  
  sub run {
      _system_or_readpipe_or_run('run', @_);
  }
  
  1;
  # ABSTRACT: Perl's system() and readpipe/qx replacement, with options
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  IPC::System::Options - Perl's system() and readpipe/qx replacement, with options
  
  =head1 VERSION
  
  This document describes version 0.330 of IPC::System::Options (from Perl distribution IPC-System-Options), released on 2017-08-10.
  
  =head1 SYNOPSIS
  
   use IPC::System::Options qw(system readpipe run);
  
   # use exactly like system()
   system(...);
  
   # use exactly like readpipe() (a.k.a. qx a.k.a. `` a.k.a. the backtick operator)
   my $res = readpipe(...);
   $res = `...`;
  
   # but these functions accept an optional hash first argument to specify options
   system({...}, ...);
   readpipe({...}, ...);
  
   # run without shell, even though there is only one argument
   system({shell=>0}, "ls");
   system({shell=>0}, "ls -lR"); # will fail, as there is no 'ls -lR' binary
  
   # force shell, even though there are multiple arguments (arguments will be
   # quoted for you, including proper quoting on Win32)
   system({shell=>1}, "ls", "-lR");
  
   # set LC_ALL/LANGUAGE/LANG environment variable
   $res = readpipe({lang=>"de_DE.UTF-8"}, "df");
  
   # log using Log::Any, die on failure
   system({log=>1, die=>1}, "blah", ...);
  
   # chdir first before running program (and chdir back afterwards)
   system({chdir => "/tmp", die => 1}, "some-program");
  
  Set default options for all calls (prefix each option with dash):
  
   use IPC::System::Options 'system', 'readpipe', -log=>1, -die=>1;
  
  C<run()> is like C<system()> but uses L<IPC::Run>'s C<run()> instead of
  C<system()>:
  
   run('ls');
  
   # also accepts an optional hash first argument. some additional options that
   # run() accepts: stdin.
   run({capture_stdout => \$stdout, capture_stderr => \$stderr}, 'ls', '-l');
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(backtick)$
  
  =head1 FUNCTIONS
  
  =head2 system([ \%opts ], @args)
  
  Just like perl's C<system()> except that it accepts an optional hash first
  argument to specify options. Currently known options:
  
  =over
  
  =item * shell => bool
  
  Can be set to 0 to always avoid invoking the shell. The default is to use the
  shell under certain conditions, like perl's C<system()>. But unlike perl's
  C<system()>, you can force shell usage even though you pass multiple arguments
  (in which case, the arguments will be quoted for you, including proper quoting
  on Win32).
  
  =item * lang => str
  
  Temporarily set locale-related environment variables: C<LC_ALL> (this is the
  highest precedence, even higher than the other C<LC_*> variables including
  C<LC_MESSAGES>), C<LANGUAGE> (this is used in Linux, with precedence higher than
  C<LANG> but lower than C<LC_*>), and C<LANG>.
  
  Of course you can set the environment variables manually (or use the C<env>
  option), this option is just for convenience.
  
  =item * env => hashref
  
  Temporarily set environment variables.
  
  =item * log => bool
  
  If set to true, then will log invocation as well as return/result value. Will
  log using L<Log::Any> at the C<trace> level.
  
  =item * die => bool
  
  If set to true, will die on failure.
  
  =item * capture_stdout => scalarref
  
  Capture stdout using L<Capture::Tiny>.
  
  Cannot be used together with C<tee_*> or C<capture_merged>.
  
  =item * capture_stderr => scalarref
  
  Capture stderr using L<Capture::Tiny>.
  
  Cannot be used together with C<tee_*> or C<capture_merged>.
  
  =item * capture_merged => scalarref
  
  Capture stdout and stderr in a single variable using L<Capture::Tiny>'s
  C<capture_merged>.
  
  Cannot be used together with C<tee_*>, C<capture_stdout>, or C<capture_stderr>.
  
  =item * tee_stdout => scalarref
  
  Tee stdout using L<Capture::Tiny>.
  
  Cannot be used together with C<capture_*> or C<tee_merged>.
  
  =item * tee_stderr => scalarref
  
  Capture stderr using L<Capture::Tiny>.
  
  Cannot be used together with C<capture_*> or C<tee_merged>.
  
  =item * tee_merged => scalarref
  
  Capture stdout and stderr in a single variable using L<Capture::Tiny>'s
  C<capture_merged>.
  
  Cannot be used together with C<capture_*>, C<tee_stdout>, or C<tee_stderr>.
  
  =item * chdir => str
  
  Attempt to change to specified directory first and change back to the original
  directory after the command has been run. This is a convenient option so you can
  do this kind of task in a single call:
  
   {
       my $cwd = getcwd();
       chdir $dir or die;
       system(...);
       chdir $cwd or die;
   }
  
  If the attempt to chdir before command execution fails, will die if C<die>
  option is set to true. Otherwise, C<$!> (OS error) will be set to the C<chdir()>
  error and to minimize surprise C<$?> (child exit code) will also be set to
  non-zero value (-1) even though at this point no child process has been run.
  
  If the attempt to chdir back (after command execution) fails, will die if C<die>
  option is set to true. Otherwise, C<$!> will be set to the C<chdir()> error and
  C<$?> will be set to -1 only if C<$?> is zero. So if the command fails, C<$?>
  will contain the exit code of the command.
  
  =item * dry_run => bool
  
  If set to true, then will only display what would be executed to STDERR (or log
  at C<warn> level, if C<log> option is true) instead of actually executing the
  command.
  
  Will set C<$?> (child exit code) to 0.
  
  An example of how this option can be used:
  
   system({ dry_run => $ENV{DRY_RUN} }, ...);
  
  This will allow you to run script in dry-run mode by setting environment
  variable.
  
  =back
  
  =head2 readpipe([ \%opts ], @args)
  
  Just like perl's C<readpipe()> (a.k.a. C<qx()> a.k.a. C<``> a.k.a. the backtick
  operator) except that it accepts an optional hash first argument to specify
  options. And it can accept multiple arguments (in which case, the arguments will
  be quoted for you, including proper quoting on Win32).
  
  Known options:
  
  =over
  
  =item * lang => str
  
  See option documentation in C<system()>.
  
  =item * env => hash
  
  See option documentation in C<system()>.
  
  =item * log => bool
  
  See option documentation in C<system()>.
  
  =item * die => bool
  
  See option documentation in C<system()>.
  
  =item * capture_stdout => scalarref
  
  See option documentation in C<system()>.
  
  =item * capture_stderr => scalarref
  
  See option documentation in C<system()>.
  
  =item * capture_merged => scalarref
  
  See option documentation in C<system()>.
  
  =item * tee_stdout => scalarref
  
  See option documentation in C<system()>.
  
  =item * tee_stderr => scalarref
  
  See option documentation in C<system()>.
  
  =item * tee_merged => scalarref
  
  See option documentation in C<system()>.
  
  =item * max_log_output => int
  
  If set, will limit result length being logged. It's a good idea to set this
  (e.g. to 1024) if you expect some command to return large output.
  
  =item * chdir => str
  
  See option documentation in C<system()>.
  
  =item * dry_run => bool
  
  See option documentation in C<system()>.
  
  =back
  
  =head2 run([ \%opts ], @args)
  
  Like C<system()>, but uses L<IPC::Run>'s C<run()>. Known options:
  
  =over
  
  =item * lang => str
  
  See option documentation in C<system()>.
  
  =item * env => hash
  
  See option documentation in C<system()>.
  
  =item * log => bool
  
  See option documentation in C<system()>.
  
  =item * die => bool
  
  See option documentation in C<system()>.
  
  =item * capture_stdout => scalarref
  
  See option documentation in C<system()>.
  
  =item * capture_stderr => scalarref
  
  See option documentation in C<system()>.
  
  =item * capture_merged => scalarref
  
  See option documentation in C<system()>.
  
  =item * tee_stdout => scalarref
  
  See option documentation in C<system()>.
  
  =item * tee_stderr => scalarref
  
  See option documentation in C<system()>.
  
  =item * tee_merged => scalarref
  
  See option documentation in C<system()>.
  
  =item * stdin => scalar
  
  Supply standard input.
  
  =item * chdir => str
  
  See option documentation in C<system()>.
  
  =item * dry_run => bool
  
  See option documentation in C<system()>.
  
  =back
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/IPC-System-Options>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-IPC-System-Options>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=IPC-System-Options>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017, 2016, 2015 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
IPC_SYSTEM_OPTIONS

$fatpacked{"Log/ger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER';
  package Log::ger;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  our $re_addr = qr/\(0x([0-9a-f]+)/o;
  
  our %Levels = (
      fatal   => 10,
      error   => 20,
      warn    => 30,
      info    => 40,
      debug   => 50,
      trace   => 60,
  );
  
  our %Level_Aliases = (
      off     => 0,
      warning => 30,
  );
  
  our $Current_Level = 30;
  
  our $Caller_Depth_Offset = 0;
  
  # a flag that can be used by null output to skip using formatter
  our $_logger_is_null;
  
  our $_dumper;
  
  our %Global_Hooks;
  
  # in Log/ger/Heavy.pm
  # our %Default_Hooks = (
  
  our %Package_Targets; # key = package name, value = \%init_args
  our %Per_Package_Hooks; # key = package name, value = { phase => hooks, ... }
  
  our %Hash_Targets; # key = hash address, value = [$hashref, \%init_args]
  our %Per_Hash_Hooks; # key = hash address, value = { phase => hooks, ... }
  
  our %Object_Targets; # key = object address, value = [$obj, \%init_args]
  our %Per_Object_Hooks; # key = object address, value = { phase => hooks, ... }
  
  my $sub0 = sub {0};
  my $sub1 = sub {1};
  my $default_null_routines;
  
  sub install_routines {
      my ($target, $target_arg, $routines) = @_;
  
      if ($target eq 'package') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              #print "D:installing $name to package $target_arg\n";
              *{"$target_arg\::$name"} = $code;
          }
      } elsif ($target eq 'object') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          my $pkg = ref $target_arg;
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_method\z/;
              *{"$pkg\::$name"} = $code;
          }
      } elsif ($target eq 'hash') {
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              $target_arg->{$name} = $code;
          }
      }
  }
  
  sub add_target {
      my ($target, $target_arg, $args, $replace) = @_;
      $replace = 1 unless defined $replace;
  
      if ($target eq 'package') {
          unless ($replace) { return if $Package_Targets{$target_arg} }
          $Package_Targets{$target_arg} = $args;
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Object_Targets{$addr} }
          $Object_Targets{$addr} = [$target_arg, $args];
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Hash_Targets{$addr} }
          $Hash_Targets{$addr} = [$target_arg, $args];
      }
  }
  
  sub _set_default_null_routines {
      $default_null_routines ||= [
          (map {(
              [$sub0, "log_$_", $Levels{$_}, 'log_sub'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "log_is_$_", $Levels{$_}, 'is_sub'],
              [$sub0, $_, $Levels{$_}, 'log_method'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "is_$_", $Levels{$_}, 'is_method'],
          )} keys %Levels),
      ];
  }
  
  sub get_logger {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      my $obj = []; $obj =~ $re_addr;
      my $pkg = "Log::ger::Obj$1"; bless $obj, $pkg;
      add_target(object => $obj, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(object => $obj, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(object => $obj, $default_null_routines);
      }
      $obj; # XXX add DESTROY to remove from list of targets
  }
  
  sub import {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      add_target(package => $caller, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(package => $caller, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(package => $caller, $default_null_routines);
      }
  }
  
  1;
  # ABSTRACT: A lightweight, flexible logging framework
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger - A lightweight, flexible logging framework
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  In your module (producer):
  
   package Foo;
   use Log::ger; # will import some logging methods e.g. log_warn, log_error
  
   sub foo {
       ...
       # produce some logs
       log_error "an error occurred: %03d - %s", $errcode, $errmsg;
       ...
       log_debug "http response: %s", $http; # automatic dumping of data
   }
   1;
  
  In your application (consumer/listener):
  
   use Foo;
   use Log::ger::Output 'Screen';
  
   foo();
  
  =head1 DESCRIPTION
  
  Log::ger is yet another logging framework with the following features:
  
  =over
  
  =item * Separation of producers and consumers/listeners
  
  Like L<Log::Any>, this offers a very easy way for modules to produce some logs
  without having to configure anything. Configuring output, level, etc can be done
  in the application as log consumers/listeners. To read more about this, see the
  documentation of L<Log::Any> or L<Log::ger::Manual> (but nevertheless see
  L<Log::ger::Manual> on why you might prefer Log::ger to Log::Any).
  
  =item * Lightweight and fast
  
  B<Slim distribution.> No non-core dependencies, extra functionalities are
  provided in separate distributions to be pulled as needed.
  
  B<Low startup overhead.> Only ~0.5-1ms. For comparison, L<strict> ~0.2-0.5ms,
  L<warnings> ~2ms, L<Log::Any> 0.15 ~2-3ms, Log::Any 1.049 ~8-10ms,
  L<Log::Log4perl> ~35ms. This is measured on a 2014-2015 PC and before doing any
  output configuration. For more benchmarks, see L<Bencher::Scenarios::LogGer> or
  try yourself e.g. with L<bencher-code>:
  
   % bencher-code 'use Log::ger' 'use Log::Any' --startup
  
  B<Fast>. Low null-/stealth-logging overhead, about 1.5x faster than Log::Any, 3x
  faster than Log4perl, and 5x faster than L<Log::Fast>.
  
  B<Conditional compilation.> There is a plugin to optimize away unneeded logging
  statements, like assertion/conditional compilation, so they have zero runtime
  performance cost. See L<Log::ger::Plugin::OptAway>.
  
  Being lightweight means the module can be used more universally, from CLI to
  long-running daemons to inside routines with tight loops.
  
  =item * Flexible
  
  B<Customizable levels and routine/method names.> Can be used in a procedural or
  OO style. Log::ger can mimic the interface of L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, or some other popular logging frameworks, to ease migration or
  adjust with your personal style.
  
  B<Per-package settings.> Each importer package can use its own format/layout,
  output. For example, some modules that are migrated from Log::Any uses
  Log::Any-style logging, while another uses native Log::ger style, and yet some
  other uses block formatting like Log::Contextual. This eases code migration and
  teamwork. Each module author can preserve her own logging style, if wanted, and
  all the modules still use the same framework.
  
  B<Dynamic.> Outputs and levels can be changed anytime during run-time and
  logging routines will be updated automatically. This is useful in situation like
  a long-running server application: you can turn on tracing logs temporarily to
  debug problems, then turn them off again, without restarting your server.
  
  B<Interoperability.> There are modules to interop with Log::Any, either consume
  Log::Any logs (see L<Log::Any::Adapter::LogGer>) or produce logs to be consumed
  by Log::Any (see L<Log::ger::Output::LogAny>).
  
  B<Many output modules and plugins.> See C<Log::ger::Output::*>,
  C<Log::ger::Format::*>, C<Log::ger::Layout::*>, C<Log::ger::Plugin::*>. Writing
  an output module in Log::ger is easier than writing a Log::Any::Adapter::*.
  
  =back
  
  For more documentation, start with L<Log::ger::Manual>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  Some other popular logging frameworks: L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, L<Log::Dispatch>, L<Log::Dispatchouli>.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER

$fatpacked{"Log/ger/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT';
  package Log::ger::Format;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  sub _import_sets_for_current_package { 1 }
  
  1;
  # ABSTRACT: Use a format plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format - Use a format plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set for current package only:
  
   use Log::ger::Format 'Block';
  
  or:
  
   use Log::ger::Format;
   Log::ger::Format->set_for_current_package('Block');
  
  To set globally:
  
   use Log::ger::Format;
   Log::ger::Format->set('Block');
  
  =head1 DESCRIPTION
  
  Note: Since format plugins affect log-producing code, the import syntax defaults
  to setting for current package instead of globally.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT

$fatpacked{"Log/ger/Format/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT_NONE';
  package Log::ger::Format::None;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_formatter => [
              __PACKAGE__, 50,
              sub {
                  [sub {shift}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Perform no formatting on the message
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format::None - Perform no formatting on the message
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Format 'None';
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT_NONE

$fatpacked{"Log/ger/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_HEAVY';
  package Log::ger::Heavy;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  package
      Log::ger;
  
  #IFUNBUILT
  # use vars qw(
  #                $re_addr
  #                %Levels
  #                %Level_Aliases
  #                $Current_Level
  #                $Caller_Depth_Offset
  #                $_logger_is_null
  #                $_dumper
  #                %Global_Hooks
  #                %Package_Targets
  #                %Per_Package_Hooks
  #                %Hash_Targets
  #                %Per_Hash_Hooks
  #                %Object_Targets
  #                %Per_Object_Hooks
  #        );
  #END IFUNBUILT
  
  # key = phase, value = [ [key, prio, coderef], ... ]
  our %Default_Hooks = (
      create_formatter => [
          [__PACKAGE__, 90,
           # the default formatter is sprintf-style that dumps data structures
           # arguments as well as undef as '<undef>'.
           sub {
               my %args = @_;
  
               my $formatter = sub {
                   return $_[0] if @_ < 2;
                   my $fmt = shift;
                   my @args;
                   for (@_) {
                       if (!defined($_)) {
                           push @args, '<undef>';
                       } elsif (ref $_) {
                           require Log::ger::Util unless $_dumper;
                           push @args, Log::ger::Util::_dump($_);
                       } else {
                           push @args, $_;
                       }
                   }
                   sprintf $fmt, @args;
               };
               [$formatter];
           }],
      ],
  
      create_layouter => [],
  
      create_routine_names => [
          [__PACKAGE__, 90,
           # the default names are log_LEVEL() and log_is_LEVEL() for subroutine
           # names, or LEVEL() and is_LEVEL() for method names
           sub {
               my %args = @_;
  
               my $levels = [keys %Levels];
  
               return [{
                   log_subs    => [map { ["log_$_", $_]    } @$levels],
                   is_subs     => [map { ["log_is_$_", $_] } @$levels],
                   # used when installing to hash or object
                   log_methods => [map { ["$_", $_]        } @$levels],
                   is_methods  => [map { ["is_$_", $_]     } @$levels],
               }, 1];
           }],
      ],
  
      create_log_routine => [
          [__PACKAGE__, 10,
           # the default behavior is to create a null routine for levels that are
           # too high than the global level ($Current_Level). since we run at high
           # priority (10), this block typical output plugins at normal priority
           # (50). this is a convenience so normally a plugin does not have to
           # deal with level checking.
           sub {
               my %args = @_;
               my $level = $args{level};
               if (defined($level) && (
                   $Current_Level < $level ||
                       # there's only us
                       @{ $Global_Hooks{create_log_routine} } == 1)
               ) {
                   $_logger_is_null = 1;
                   return [sub {0}];
               }
               [undef]; # decline
           }],
      ],
  
      create_logml_routine => [],
  
      create_is_routine => [
          [__PACKAGE__, 90,
           # the default behavior is to compare to global level. normally this
           # behavior suffices. we run at low priority (90) so normal plugins
           # which typically use priority 50 can override us.
           sub {
               my %args = @_;
               my $level = $args{level};
               [sub { $Current_Level >= $level }];
           }],
      ],
  
      before_install_routines => [],
  
      after_install_routines => [],
  );
  
  for my $phase (keys %Default_Hooks) {
      $Global_Hooks{$phase} = [@{ $Default_Hooks{$phase} }];
  }
  
  # if flow_control is 1, stops after the first hook that gives non-undef result.
  # flow_control can also be a coderef that will be called after each hook with
  # ($hook, $hook_res) and can return 1 to mean stop.
  sub run_hooks {
      my ($phase, $hook_args, $flow_control,
          $target, $target_arg) = @_;
      #print "D: running hooks for phase $phase\n";
  
      $Global_Hooks{$phase} or die "Unknown phase '$phase'";
      my @hooks = @{ $Global_Hooks{$phase} };
  
      if ($target eq 'package') {
          unshift @hooks, @{ $Per_Package_Hooks{$target_arg}{$phase} || [] };
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Hash_Hooks{$addr}{$phase} || [] };
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Object_Hooks{$addr}{$phase} || [] };
      }
  
      my $res;
      for my $hook (sort {$a->[1] <=> $b->[1]} @hooks)  {
          my $hook_res = $hook->[2]->(%$hook_args);
          if (defined $hook_res->[0]) {
              $res = $hook_res->[0];
              #print "D:   got result from hook $res\n";
              if (ref $flow_control eq 'CODE') {
                  last if $flow_control->($hook, $hook_res);
              } else {
                  last if $flow_control;
              }
          }
          last if $hook_res->[1];
      }
      return $res;
  }
  
  sub init_target {
      my ($target, $target_arg, $init_args) = @_;
  
      #print "D:init_target($target, $target_arg, ...)\n";
      my %hook_args = (
          target     => $target,
          target_arg => $target_arg,
          init_args  => $init_args,
      );
  
      my %formatters;
      run_hooks(
          'create_formatter', \%hook_args,
          # collect formatters, until a hook instructs to stop
          sub {
              my ($hook, $hook_res) = @_;
              my ($formatter, $flow_control, $fmtname) = @$hook_res;
              $fmtname = 'default' if !defined($fmtname);
              $formatters{$fmtname} ||= $formatter;
              $flow_control;
          },
          $target, $target_arg);
  
      my $layouter =
          run_hooks('create_layouter', \%hook_args, 1, $target, $target_arg);
  
      my $routine_names = {};
      run_hooks(
          'create_routine_names', \%hook_args,
          # collect routine names, until a hook instructs to stop.
          sub {
              my ($hook, $hook_res) = @_;
              my ($rn, $flow_control) = @$hook_res;
              $rn or return;
              for (keys %$rn) {
                  push @{ $routine_names->{$_} }, @{ $rn->{$_} };
              }
              $flow_control;
          },
          $target, $target_arg);
  
      my @routines;
      my $object = $target eq 'object';
  
    CREATE_LOG_ROUTINES:
      {
          my @rn;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{log_subs} || [] };
              push @rn, @{ $routine_names->{logml_subs} || [] };
          } else {
              push @rn, @{ $routine_names->{log_methods} || [] };
              push @rn, @{ $routine_names->{logml_methods} || [] };
          }
          my $mllogger0;
          for my $rn (@rn) {
              my ($rname, $lname, $fmtname) = @$rn;
              my $lnum; $lnum = $Levels{$lname} if defined $lname;
              my $routine_name_is_ml = !defined($lname);
              $fmtname = 'default' if !defined($fmtname);
  
              my $logger;
              my ($logger0, $logger0_is_ml);
              $_logger_is_null = 0;
              for my $phase (qw/create_logml_routine create_log_routine/) {
                  local $hook_args{name} = $rname;
                  local $hook_args{level} = $lnum;
                  local $hook_args{str_level} = $lname;
                  $logger0_is_ml = $phase eq 'create_logml_routine';
                  if ($mllogger0) {
                      # we reuse the same multilevel logger0 for all log routines,
                      # since it can handle different levels
                      $logger0 = $mllogger0;
                      last;
                  }
                  $logger0 = run_hooks(
                      $phase, \%hook_args, 1, $target, $target_arg)
                      or next;
                  if ($logger0_is_ml) {
                      $mllogger0 = $logger0;
                  }
                  last;
              }
              # this can happen if there is no create_logml_routine hook but
              # routine name is a logml routine
              unless ($logger0) {
                  $_logger_is_null = 1;
                  $logger0 = sub {0};
              }
  
              require Log::ger::Util if !$logger0_is_ml && $routine_name_is_ml;
  
              {
                  if ($_logger_is_null) {
                      # if logger is a null logger (sub {0}) we don't need to
                      # format message, layout message, or care about the logger
                      # being a subroutine/object
                      $logger = $logger0;
                      last;
                  }
  
                  my $formatter = $formatters{$fmtname}
                      or die "Formatter named '$fmtname' not available";
                  if ($formatter) {
                      if ($layouter) {
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          }
                      } else { # no layouter
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              }
                          }
                      }
                  } else { # no formatter
                      { # no layouter, just to align
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) }; }
                              } else { # routine name not multiple-lvl
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,                          @_                             ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) }; }
                              } else {
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                                 @_                             ) }; }
                              }
                          }
                      }
                  }
              }
            L1:
              my $type = $routine_name_is_ml ?
                  ($object ? 'logml_method' : 'logml_sub') :
                  ($object ? 'log_method' : 'log_sub');
              push @routines, [$logger, $rname, $lnum, $type];
          }
      }
    CREATE_IS_ROUTINES:
      {
          my @rn;
          my $type;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{is_subs} || [] };
              $type = 'is_sub';
          } else {
              push @rn, @{ $routine_names->{is_methods} || [] };
              $type = 'is_method';
          }
          for my $rn (@rn) {
              my ($rname, $lname) = @$rn;
              my $lnum = $Levels{$lname};
  
              local $hook_args{name} = $rname;
              local $hook_args{level} = $lnum;
              local $hook_args{str_level} = $lname;
  
              my $code_is =
                  run_hooks('create_is_routine', \%hook_args, 1,
                            $target, $target_arg);
              next unless $code_is;
              push @routines, [$code_is, $rname, $lnum, $type];
          }
      }
  
      {
          local $hook_args{routines} = \@routines;
          local $hook_args{formatters} = \%formatters;
          local $hook_args{layouter} = $layouter;
          run_hooks('before_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  
      install_routines($target, $target_arg, \@routines);
  
      {
          local $hook_args{routines} = \@routines;
          run_hooks('after_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  }
  
  1;
  # ABSTRACT: The bulk of the implementation of Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Heavy - The bulk of the implementation of Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This module contains the bulk of the implementation of Log::ger, to keep
  Log::ger superslim.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_HEAVY

$fatpacked{"Log/ger/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_LAYOUT';
  package Log::ger::Layout;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Layout::/ }
  
  1;
  # ABSTRACT: Use a layout plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Layout - Use a layout plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Layout;
   Log::ger::Layout->set('Pattern');
  
  or:
  
   use Log::ger::Layout 'Pattern';
  
  To set for current package only:
  
   use Log::ger::Layout;
   Log::ger::Layout->set_for_current_package('Pattern');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  L<Log::ger::Format>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_LAYOUT

$fatpacked{"Log/ger/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT';
  package Log::ger::Output;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent 'Log::ger::Plugin';
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Output::/ }
  
  1;
  # ABSTRACT: Set logging output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output - Set logging output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Output;
   Log::ger::Output->set(Screen => (
       use_color => 1,
       ...
   );
  
  or:
  
   use Log::ger::Output 'Screen', (
       use_color=>1,
       ...
   );
  
  To set for current package only:
  
   use Log::ger::Output;
   Log::ger::Output->set_for_current_package(Screen => (
       use_color => 1,
       ...
   );
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT

$fatpacked{"Log/ger/Output/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAY';
  package Log::ger::Output::Array;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
  
                  my $logger = sub {
                      my ($ctx, $msg) = @_;
                      push @{$conf{array}}, $msg;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Array - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output Array => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAY

$fatpacked{"Log/ger/Output/ArrayML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAYML';
  package Log::ger::Output::ArrayML;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_logml_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $logger = sub {
                      my $level = Log::ger::Util::numeric_level($_[1]);
                      return if $level > $Log::ger::Current_Level;
                      push @{$conf{array}}, $_[2];
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::ArrayML - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output ArrayML => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  This output is just like L<Log::ger::Output::Array> except that it provides a
  C<create_logml_routine> hook instead of C<create_log_routine>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAYML

$fatpacked{"Log/ger/Output/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_NULL';
  package Log::ger::Output::Null;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  $Log::ger::_logger_is_null = 1;
                  [sub {0}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Null output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Null - Null output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger;
   use Log::ger::Output 'Null';
  
   log_warn "blah...";
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_NULL

$fatpacked{"Log/ger/Output/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_STRING';
  package Log::ger::Output::String;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{string} or die "Please specify string";
  
      my $formatter = $conf{formatter};
      my $append_newline = $conf{append_newline};
      $append_newline = 1 unless defined $append_newline;
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $level = $args{level};
                  my $logger = sub {
                      my $msg = $_[1];
                      if ($formatter) {
                          $msg = $formatter->($msg);
                      }
                      ${ $conf{string} } .= $msg;
                      ${ $conf{string} } .= "\n"
                          unless !$append_newline || $msg =~ /\R\z/;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Set output to a string
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::String - Set output to a string
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use var '$str';
   use Log::ger::Output 'String' => (
       string => \$str,
       # append_newline => 0, # default is true, to mimic Log::ger::Output::Screen
   );
   use Log::ger;
  
   log_warn "warn ...";
   log_error "debug ...";
  
  C<$str> will contain "warn ...\n".
  
  =head1 DESCRIPTION
  
  For testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 string => scalarref
  
  Required.
  
  =head2 formatter => coderef
  
  Optional.
  
  =head2 append_newline => bool (default: 1)
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_STRING

$fatpacked{"Log/ger/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN';
  package Log::ger::Plugin;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub set {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      $args{prefix} ||= $pkg . '::';
      $args{replace_package_regex} = $pkg->_replace_package_regex;
      Log::ger::Util::set_plugin(%args);
  }
  
  sub set_for_current_package {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      my $caller = caller(0);
      $args{target} = 'package';
      $args{target_arg} = $caller;
  
      set($pkg, \%args);
  }
  
  sub _import_sets_for_current_package { 0 }
  
  sub _replace_package_regex { undef }
  
  sub import {
      if (@_ > 1) {
          if ($_[0]->_import_sets_for_current_package) {
              goto &set_for_current_package;
          } else {
              goto &set;
          }
      }
  }
  
  1;
  # ABSTRACT: Use a plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin - Use a plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set('OptAway');
  
  or:
  
   use Log::ger::Plugin 'OptAway';
  
  To set for current package only:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set_for_current_package('OptAway');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN

$fatpacked{"Log/ger/Plugin/MultilevelLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN_MULTILEVELLOG';
  package Log::ger::Plugin::MultilevelLog;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      return {
          create_routine_names => [
              __PACKAGE__, 50,
              sub {
                  return [{
                      logml_subs    => [[$conf{sub_name}    || 'log', undef]],
                      logml_methods => [[$conf{method_name} || 'log', undef]],
                  }];
              },
          ],
      };
  }
  
  1;
  # ABSTRACT: Create a log($LEVEL, ...) subroutine/method
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin::MultilevelLog - Create a log($LEVEL, ...) subroutine/method
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Plugin MultilevelLog => (
       sub_name => 'log',    # optional
       method_name => 'log', # optional
   );
   use Log::ger;
  
  =head1 DESCRIPTION
  
  The default way is to create separate C<log_LEVEL> subroutine (or C<LEVEL>
  methods) for each level, e.g. C<log_trace> subroutine (or C<trace> method),
  C<log_warn> (or C<warn>), and so on. But sometimes you might want a log routine
  that takes $level as the first argument, e.g. instead of:
  
   log_warn('blah ...');
  
  or:
  
   $log->debug('Blah: %s', $data);
  
  you prefer:
  
   log('warn', 'blah ...');
  
  or:
  
   $log->log('debug', 'Blah: %s', $data);
  
  This plugin can create such log routine for you.
  
  Note: the multilevel log is slower because of extra argument and additional
  string level -> numeric level conversion.
  
  Note: the individual separate C<log_LEVEL> subroutines (or C<LEVEL> methods) are
  still installed.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 sub_name => str (default: "log")
  
  =head2 method_name => str (default: "log")
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN_MULTILEVELLOG

$fatpacked{"Log/ger/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_UTIL';
  package Log::ger::Util;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  require Log::ger;
  require Log::ger::Heavy;
  
  sub _dump {
      unless ($Log::ger::_dumper) {
          eval {
              no warnings 'once';
              require Data::Dmp;
              $Data::Dmp::OPT_REMOVE_PRAGMAS = 1;
              1;
          };
          if ($@) {
              no warnings 'once';
              require Data::Dumper;
              $Log::ger::_dumper = sub {
                  local $Data::Dumper::Terse = 1;
                  local $Data::Dumper::Indent = 0;
                  local $Data::Dumper::Useqq = 1;
                  local $Data::Dumper::Deparse = 1;
                  local $Data::Dumper::Quotekeys = 0;
                  local $Data::Dumper::Sortkeys = 1;
                  local $Data::Dumper::Trailingcomma = 1;
                  Data::Dumper::Dumper($_[0]);
              };
          } else {
              $Log::ger::_dumper = sub { Data::Dmp::dmp($_[0]) };
          }
      }
      $Log::ger::_dumper->($_[0]);
  }
  
  sub numeric_level {
      my $level = shift;
      return $level if $level =~ /\A\d+\z/;
      return $Log::ger::Levels{$level}
          if defined $Log::ger::Levels{$level};
      return $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      die "Unknown level '$level'";
  }
  
  sub string_level {
      my $level = shift;
      return $level if defined $Log::ger::Levels{$level};
      $level = $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      for (keys %Log::ger::Levels) {
          my $v = $Log::ger::Levels{$_};
          return $_ if $v == $level;
      }
      die "Unknown level '$level'";
  }
  
  sub set_level {
      no warnings 'once';
      $Log::ger::Current_Level = numeric_level(shift);
      reinit_all_targets();
  }
  
  sub _action_on_hooks {
      no warnings 'once';
  
      my ($action, $target, $target_arg, $phase) = splice @_, 0, 4;
  
      my $hooks = $Log::ger::Global_Hooks{$phase} or die "Unknown phase '$phase'";
      if ($target eq 'package') {
          $hooks = ($Log::ger::Per_Package_Hooks{$target_arg}{$phase} ||= []);
      } elsif ($target eq 'object') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Object_Hooks{$addr}{$phase} ||= []);
      } elsif ($target eq 'hash') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Hash_Hooks{$addr}{$phase} ||= []);
      }
  
      if ($action eq 'add') {
          my $hook = shift;
          # XXX remove duplicate key
          # my $key = $hook->[0];
          unshift @$hooks, $hook;
      } elsif ($action eq 'remove') {
          my $code = shift;
          for my $i (reverse 0..$#{$hooks}) {
              splice @$hooks, $i, 1 if $code->($hooks->[$i]);
          }
      } elsif ($action eq 'reset') {
          my $saved = [@$hooks];
          splice @$hooks, 0, scalar(@$hooks),
              @{ $Log::ger::Default_Hooks{$phase} };
          return $saved;
      } elsif ($action eq 'empty') {
          my $saved = [@$hooks];
          splice @$hooks, 0;
          return $saved;
      } elsif ($action eq 'save') {
          return [@$hooks];
      } elsif ($action eq 'restore') {
          my $saved = shift;
          splice @$hooks, 0, scalar(@$hooks), @$saved;
          return $saved;
      }
  }
  
  sub add_hook {
      my ($phase, $hook) = @_;
      _action_on_hooks('add', '', undef, $phase, $hook);
  }
  
  sub add_per_target_hook {
      my ($target, $target_arg, $phase, $hook) = @_;
      _action_on_hooks('add', $target, $target_arg, $phase, $hook);
  }
  
  sub remove_hook {
      my ($phase, $code) = @_;
      _action_on_hooks('remove', '', undef, $phase, $code);
  }
  
  sub remove_per_target_hook {
      my ($target, $target_arg, $phase, $code) = @_;
      _action_on_hooks('remove', $target, $target_arg, $phase, $code);
  }
  
  sub reset_hooks {
      my ($phase) = @_;
      _action_on_hooks('reset', '', undef, $phase);
  }
  
  sub reset_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('reset', $target, $target_arg, $phase);
  }
  
  sub empty_hooks {
      my ($phase) = @_;
      _action_on_hooks('empty', '', undef, $phase);
  }
  
  sub empty_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('empty', $target, $target_arg, $phase);
  }
  
  sub save_hooks {
      my ($phase) = @_;
      _action_on_hooks('save', '', undef, $phase);
  }
  
  sub save_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('save', $target, $target_arg, $phase);
  }
  
  sub restore_hooks {
      my ($phase, $saved) = @_;
      _action_on_hooks('restore', '', undef, $phase, $saved);
  }
  
  sub restore_per_target_hooks {
      my ($target, $target_arg, $phase, $saved) = @_;
      _action_on_hooks('restore', $target, $target_arg, $phase, $saved);
  }
  
  sub reinit_target {
      my ($target, $target_arg) = @_;
  
      # adds target if not already exists
      Log::ger::add_target($target, $target_arg, {}, 0);
  
      if ($target eq 'package') {
          my $init_args = $Log::ger::Package_Targets{$target_arg};
          Log::ger::init_target(package => $target_arg, $init_args);
      } elsif ($target eq 'object') {
          my ($obj_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid object '$target_arg': not a reference";
          my $v = $Log::ger::Object_Targets{$obj_addr}
              or die "Unknown object target '$target_arg'";
          Log::ger::init_target(object => $v->[0], $v->[1]);
      } elsif ($target eq 'hash') {
          my ($hash_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid hashref '$target_arg': not a reference";
          my $v = $Log::ger::Hash_Targets{$hash_addr}
              or die "Unknown hash target '$target_arg'";
          Log::ger::init_target(hash => $v->[0], $v->[1]);
      } else {
          die "Unknown target '$target'";
      }
  }
  
  sub reinit_all_targets {
      for my $pkg (keys %Log::ger::Package_Targets) {
          Log::ger::init_target(
              package => $pkg, $Log::ger::Package_Targets{$pkg});
      }
      for my $k (keys %Log::ger::Object_Targets) {
          my ($obj, $init_args) = @{ $Log::ger::Object_Targets{$k} };
          Log::ger::init_target(object => $obj, $init_args);
      }
      for my $k (keys %Log::ger::Hash_Targets) {
          my ($hash, $init_args) = @{ $Log::ger::Hash_Targets{$k} };
          Log::ger::init_target(hash => $hash, $init_args);
      }
  }
  
  sub set_plugin {
      my %args = @_;
  
      my $hooks;
      if ($args{hooks}) {
          $hooks = $args{hooks};
      } else {
          no strict 'refs';
          my $prefix = $args{prefix} || 'Log::ger::Plugin::';
          my $mod = $args{name};
          $mod = $prefix . $mod unless index($mod, $prefix) == 0;
          (my $mod_pm = "$mod.pm") =~ s!::!/!g;
          require $mod_pm;
          $hooks = &{"$mod\::get_hooks"}(%{ $args{conf} || {} });
      }
  
      {
          last unless $args{replace_package_regex};
          my $all_hooks;
          if (!$args{target}) {
              $all_hooks = \%Log::ger::Global_Hooks;
          } elsif ($args{target} eq 'package') {
              $all_hooks = $Log::ger::Per_Package_Hooks{ $args{target_arg} };
          } elsif ($args{target} eq 'object') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Object_Hooks{$addr};
          } elsif ($args{target} eq 'hash') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Hash_Hooks{$addr};
          }
          last unless $all_hooks;
          for my $phase (keys %$all_hooks) {
              my $hooks = $all_hooks->{$phase};
              for my $i (reverse 0..$#{$hooks}) {
                  splice @$hooks, $i, 1
                      if $hooks->[$i][0] =~ $args{replace_package_regex};
              }
          }
      }
  
      for my $phase (keys %$hooks) {
          my $hook = $hooks->{$phase};
          if (defined $args{target}) {
              add_per_target_hook(
                  $args{target}, $args{target_arg}, $phase, $hook);
          } else {
              add_hook($phase, $hook);
          }
      }
  
      my $reinit = $args{reinit};
      $reinit = 1 unless defined $reinit;
      if ($reinit) {
          if (defined $args{target}) {
              reinit_target($args{target}, $args{target_arg});
          } else {
              reinit_all_targets();
          }
      }
  }
  
  1;
  # ABSTRACT: Utility routines for Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Util - Utility routines for Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This package is created to keep Log::ger as minimalist as possible.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_UTIL

$fatpacked{"Module/Path/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PATH_MORE';
  package Module::Path::More;
  
  our $DATE = '2017-02-01'; # DATE
  our $VERSION = '0.33'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(module_path pod_path);
  
  our $SEPARATOR;
  
  our %SPEC;
  
  $SPEC{':package'} = {
      v => 1.1,
      summary => 'Get path to locally installed Perl module',
  };
  
  BEGIN {
      if ($^O =~ /^(dos|os2)/i) {
          $SEPARATOR = '\\';
      } elsif ($^O =~ /^MacOS/i) {
          $SEPARATOR = ':';
      } else {
          $SEPARATOR = '/';
      }
  }
  
  $SPEC{module_path} = {
      v => 1.1,
      summary => 'Get path to locally installed Perl module',
      description => <<'_',
  
  Search `@INC` (reference entries are skipped) and return path(s) to Perl module
  files with the requested name.
  
  This function is like the one from <pm:Module::Path>, except with a different
  interface and more options (finding all matches instead of the first, the option
  of not absolutizing paths, finding `.pmc` & `.pod` files, finding module
  prefixes).
  
  _
      args => {
          module => {
              summary => 'Module name to search',
              schema  => 'str*',
              req     => 1,
              pos     => 0,
          },
          find_pm => {
              summary => 'Whether to find .pm files',
              schema  => ['int*', min=>0],
              default => 1,
              description => <<'_',
  
  The value of this option is an integer number from 0. 0 means to not search for
  .pm files, while number larger than 0 means to search for .pm files. The larger
  the number, the lower the priority. If more than one type is found (prefix, .pm,
  .pmc, .pod) then the type with the lowest number is returned first.
  
  _
          },
          find_pmc => {
              summary => 'Whether to find .pmc files',
              schema  => ['int*', min=>0],
              default => 2,
              description => <<'_',
  
  The value of this option is an integer number from 0. 0 means to not search for
  .pmc files, while number larger than 0 means to search for .pmc files. The
  larger the number, the lower the priority. If more than one type is found
  (prefix, .pm, .pmc, .pod) then the type with the lowest number is returned
  first.
  
  _
          },
          find_pod => {
              summary => 'Whether to find .pod files',
              schema  => ['int*', min=>0],
              default => 0,
              description => <<'_',
  
  The value of this option is an integer number from 0. 0 means to not search for
  .pod files, while number larger than 0 means to search for .pod files. The
  larger the number, the lower the priority. If more than one type is found
  (prefix, .pm, .pmc, .pod) then the type with the lowest number is returned
  first.
  
  _
          },
          find_prefix => {
              summary => 'Whether to find module prefixes',
              schema  => ['int*', min=>0],
              default => 0,
              description => <<'_',
  
  The value of this option is an integer number from 0. 0 means to not search for
  module prefix, while number larger than 0 means to search for module prefix. The
  larger the number, the lower the priority. If more than one type is found
  (prefix, .pm, .pmc, .pod) then the type with the lowest number is returned
  first.
  
  _
          },
          all => {
              summary => 'Return all results instead of just the first',
              schema  => 'bool',
              default => 0,
          },
          abs => {
              summary => 'Whether to return absolute paths',
              schema  => 'bool',
              default => 0,
          },
      },
      result => {
          schema => ['any' => of => ['str*', ['array*' => of => 'str*']]],
      },
      result_naked => 1,
      examples => [
          {
              summary => 'Find the first Foo::Bar (.pm or .pmc) in @INC',
              args => {module => 'Foo::Bar'},
          },
          {
              summary => 'Find all Foo::Bar (.pm or .pmc) in @INC, return absolute paths',
              args => {module => 'Foo::Bar', all => 1, abs => 1},
          },
          {
              summary => 'Find the Rinci (.pod first, then .pm) in @INC',
              args => {module => 'Rinci', find_pod => 1, find_pm => 2, find_pmc => 0},
          },
      ],
  };
  sub module_path {
      my %args = @_;
  
      my $module = $args{module} or die "Please specify module";
  
      $args{abs}         //= 0;
      $args{all}         //= 0;
      $args{find_pm}     //= 1;
      $args{find_pmc}    //= 2;
      $args{find_pod}    //= 0;
      $args{find_prefix} //= 0;
  
      require Cwd if $args{abs};
  
      my @res;
      my %unfound = (
          ("pm" => 1)     x !!$args{find_pm},
          ("pmc" => 1)    x !!$args{find_pmc},
          ("pod" => 1)    x !!$args{find_pod},
          ("prefix" => 1) x !!$args{find_prefix},
      );
      my $add = sub {
          my ($path, $prio) = @_;
          push @res, [$args{abs} ? Cwd::abs_path($path) : $path, $prio];
      };
  
      my $relpath;
  
      ($relpath = $module) =~ s/::/$SEPARATOR/g;
      $relpath =~ s/\.(pm|pmc|pod)\z//i;
  
      foreach my $dir (@INC) {
          next if not defined($dir);
          next if ref($dir);
  
          my $prefix = $dir . $SEPARATOR . $relpath;
          if ($args{find_pm}) {
              my $file = $prefix . ".pm";
              if (-f $file) {
                  $add->($file, $args{find_pm});
                  delete $unfound{pm};
                  last if !keys(%unfound) && !$args{all};
              }
          }
          if ($args{find_pmc}) {
              my $file = $prefix . ".pmc";
              if (-f $file) {
                  $add->($file, $args{find_pmc});
                  delete $unfound{pmc};
                  last if !keys(%unfound) && !$args{all};
              }
          }
          if ($args{find_pod}) {
              my $file = $prefix . ".pod";
              if (-f $file) {
                  $add->($file, $args{find_pod});
                  delete $unfound{pod};
                  last if !keys(%unfound) && !$args{all};
              }
          }
          if ($args{find_prefix}) {
              if (-d $prefix) {
                  $add->($prefix, $args{find_prefix});
                  delete $unfound{prefix};
                  last if !keys(%unfound) && !$args{all};
              }
          }
      }
  
      @res = map { $_->[0] } sort { $a->[1] <=> $b->[1] } @res;
  
      if ($args{all}) {
          return \@res;
      } else {
          return @res ? $res[0] : undef;
      }
  }
  
  $SPEC{pod_path} = {
      v => 1.1,
      summary => 'Get path to locally installed POD',
      description => <<'_',
  
  This is a shortcut for:
  
      module_path(%args, find_pm=>0, find_pmc=>0, find_pod=>1, find_prefix=>0)
  
  _
      args => {
          module => {
              summary => 'Module name to search',
              schema  => 'str*',
              req     => 1,
              pos     => 0,
          },
          all => {
              summary => 'Return all results instead of just the first',
              schema  => 'bool',
              default => 0,
          },
          abs => {
              summary => 'Whether to return absolute paths',
              schema  => 'bool',
              default => 0,
          },
      },
      result => {
          schema => ['any' => of => ['str*', ['array*' => of => 'str*']]],
      },
      result_naked => 1,
  };
  sub pod_path {
      module_path(@_, find_pm=>0, find_pmc=>0, find_pod=>1, find_prefix=>0);
  }
  
  1;
  # ABSTRACT: Get path to locally installed Perl module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Path::More - Get path to locally installed Perl module
  
  =head1 VERSION
  
  This document describes version 0.33 of Module::Path::More (from Perl distribution Module-Path-More), released on 2017-02-01.
  
  =head1 SYNOPSIS
  
   use Module::Path::More qw(module_path pod_path);
  
   $path = module_path(module=>'Test::More');
   if (defined($path)) {
     print "Test::More found at $path\n";
   } else {
     print "Danger Will Robinson!\n";
   }
  
   # find all found modules, as well as .pmc and .pod files
   $paths = module_path(module=>'Foo::Bar', all=>1, find_pmc=>1, find_pod=>1);
  
   # just a shortcut for module_path(module=>'Foo',
   #                                 find_pm=>0, find_pmc=>0, find_pod=>1);
   $path = pod_path(module=>'Foo');
  
  =head1 DESCRIPTION
  
  Module::Path::More provides a function, C<module_path()>, which will find where
  a module (or module prefix, or .pod file) is installed locally. (There is also
  another function C<pod_path()> which is just a convenience wrapper.)
  
  It works by looking in all the directories in @INC for an appropriately named
  file. If module is C<Foo::Bar>, will search for C<Foo/Bar.pm>, C<Foo/Bar.pmc>
  (if C<find_pmc> argument is true), C<Foo/Bar> directory (if C<find_prefix>
  argument is true), or C<Foo/Bar.pod> (if C<find_pod> argument is true).
  
  Caveats: Obviously this only works where the module you're after has its own
  C<.pm> file. If a file defines multiple packages, this won't work. This also
  won't find any modules that are being loaded in some special way, for example
  using a code reference in C<@INC>, as described in C<require> in L<perlfunc>.
  
  To check whether a module is available/loadable, it's generally better to use
  something like:
  
   if (eval { require Some::Module; 1 }) {
       # module is available
   }
  
  because this works with fatpacking or any other C<@INC> hook that might be
  installed. If you use:
  
   if (module_path(module => "Some::Module")) {
       # module is available
   }
  
  then it only works if the module is locatable in the filesystem. But on the
  other hand this method can avoid actual loading of the module.
  
  =head1 FUNCTIONS
  
  
  =head2 module_path(%args) -> str|array[str]
  
  Get path to locally installed Perl module.
  
  Examples:
  
  =over
  
  =item * Find the first Foo::Bar (.pm or .pmc) in @INC:
  
   module_path(module => "Foo::Bar"); # -> undef
  
  =item * Find all Foo::Bar (.pm or .pmc) in @INC, return absolute paths:
  
   module_path(module => "Foo::Bar", abs => 1, all => 1); # -> []
  
  =item * Find the Rinci (.pod first, then .pm) in @INC:
  
   module_path(module => "Rinci", find_pm => 2, find_pmc => 0, find_pod => 1);
  
  Result:
  
   "/home/u1/perl5/perlbrew/perls/perl-5.24.0/lib/site_perl/5.24.0/Rinci.pod"
  
  =back
  
  Search C<@INC> (reference entries are skipped) and return path(s) to Perl module
  files with the requested name.
  
  This function is like the one from L<Module::Path>, except with a different
  interface and more options (finding all matches instead of the first, the option
  of not absolutizing paths, finding C<.pmc> & C<.pod> files, finding module
  prefixes).
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<abs> => I<bool> (default: 0)
  
  Whether to return absolute paths.
  
  =item * B<all> => I<bool> (default: 0)
  
  Return all results instead of just the first.
  
  =item * B<find_pm> => I<int> (default: 1)
  
  Whether to find .pm files.
  
  The value of this option is an integer number from 0. 0 means to not search for
  .pm files, while number larger than 0 means to search for .pm files. The larger
  the number, the lower the priority. If more than one type is found (prefix, .pm,
  .pmc, .pod) then the type with the lowest number is returned first.
  
  =item * B<find_pmc> => I<int> (default: 2)
  
  Whether to find .pmc files.
  
  The value of this option is an integer number from 0. 0 means to not search for
  .pmc files, while number larger than 0 means to search for .pmc files. The
  larger the number, the lower the priority. If more than one type is found
  (prefix, .pm, .pmc, .pod) then the type with the lowest number is returned
  first.
  
  =item * B<find_pod> => I<int> (default: 0)
  
  Whether to find .pod files.
  
  The value of this option is an integer number from 0. 0 means to not search for
  .pod files, while number larger than 0 means to search for .pod files. The
  larger the number, the lower the priority. If more than one type is found
  (prefix, .pm, .pmc, .pod) then the type with the lowest number is returned
  first.
  
  =item * B<find_prefix> => I<int> (default: 0)
  
  Whether to find module prefixes.
  
  The value of this option is an integer number from 0. 0 means to not search for
  module prefix, while number larger than 0 means to search for module prefix. The
  larger the number, the lower the priority. If more than one type is found
  (prefix, .pm, .pmc, .pod) then the type with the lowest number is returned
  first.
  
  =item * B<module>* => I<str>
  
  Module name to search.
  
  =back
  
  Return value:  (str|array[str])
  
  
  =head2 pod_path(%args) -> str|array[str]
  
  Get path to locally installed POD.
  
  This is a shortcut for:
  
   module_path(%args, find_pm=>0, find_pmc=>0, find_pod=>1, find_prefix=>0)
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<abs> => I<bool> (default: 0)
  
  Whether to return absolute paths.
  
  =item * B<all> => I<bool> (default: 0)
  
  Return all results instead of just the first.
  
  =item * B<module>* => I<str>
  
  Module name to search.
  
  =back
  
  Return value:  (str|array[str])
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Module-Path-More>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Module-Path-More>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Path-More>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Module::Path>. Module::Path::More is actually a fork of Module::Path.
  Module::Path::More contains features that are not (or have not been accepted) in
  the original module, namely: finding all matches instead of the first found
  match, and finding C<.pmc/.pod> in addition to .pm files. B<Note that the
  interface is different> (Module::Path::More accepts hash/named arguments) so the
  two modules are not drop-in replacements for each other. Also, note that by
  default Module::Path::More does B<not> do an C<abs_path()> to each file it
  finds. I think this module's choice (not doing abs_path) is a more sensible
  default, because usually there is no actual need to do so and doing abs_path()
  or resolving symlinks will sometimes fail or expose filesystem quirks that we
  might not want to deal with at all. However, if you want to do abs_path, you can
  do so by setting C<abs> option to true.
  
  Command-line utility is not included in this distribution, unlike L<mpath> in
  C<Module-Path>. However, you can use L<pmpath|https://metacpan.org/pod/distribution/App-PMUtils/bin/pmpath> from L<App::PMUtils> distribution
  which uses this module.
  
  References:
  
  =over
  
  =item * L<https://github.com/neilbowers/Module-Path/issues/6>
  
  =item * L<https://github.com/neilbowers/Module-Path/issues/7>
  
  =item * L<https://github.com/neilbowers/Module-Path/issues/10>
  
  =item * L<https://rt.cpan.org/Public/Bug/Display.html?id=100979>
  
  =back
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
MODULE_PATH_MORE

$fatpacked{"Perinci/CmdLine/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERINCI_CMDLINE_ANY';
  package Perinci::CmdLine::Any;
  
  our $DATE = '2017-07-22'; # DATE
  our $VERSION = '0.14'; # VERSION
  
  # IFUNBUILT
  # use strict;
  # use warnings;
  # END IFUNBUILT
  
  my %Opts = (
      -prefer_lite => 1,
  );
  
  sub import {
      my ($class, %args) = @_;
      $Opts{$_} = $args{$_} for keys %args;
  }
  
  sub new {
      my $class = shift;
  
      my @mods;
      my $env = $ENV{PERINCI_CMDLINE_ANY};
      if ($env) {
          if ($env eq 'classic') {
              $env = 'Perinci::CmdLine::Classic';
          } elsif ($env eq 'lite') {
              $env = 'Perinci::CmdLine::Lite';
          }
          @mods = ($env);
      } elsif ($Opts{-prefer_lite}) {
          @mods = qw(Perinci::CmdLine::Lite Perinci::CmdLine::Classic);
      } else {
          @mods = qw(Perinci::CmdLine::Classic Perinci::CmdLine::Lite);
      }
  
      for my $i (1..@mods) {
          my $mod = $mods[$i-1];
          my $modpm = $mod; $modpm =~ s!::!/!g; $modpm .= ".pm";
          if ($i == @mods) {
              require $modpm;
              return $mod->new(@_);
          } else {
              my $res;
              eval {
                  require $modpm;
                  $res = $mod->new(@_);
              };
              if ($@) {
                  next;
              } else {
                  return $res;
              }
          }
      }
  }
  
  1;
  # ABSTRACT: Choose Perinci::CmdLine implementation (::Lite or ::Classic)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Perinci::CmdLine::Any - Choose Perinci::CmdLine implementation (::Lite or ::Classic)
  
  =head1 VERSION
  
  This document describes version 0.14 of Perinci::CmdLine::Any (from Perl distribution Perinci-CmdLine-Any), released on 2017-07-22.
  
  =head1 SYNOPSIS
  
  In your command-line script (this will pick ::Lite first):
  
   #!perl
   use Perinci::CmdLine::Any;
   Perinci::CmdLine::Any->new(url => '/Package/func')->run;
  
  In your command-line script (this will pick ::Classic first, and falls back to
  ::Lite):
  
   #!perl
   use Perinci::CmdLine::Any -prefer_lite=>0;
   Perinci::CmdLine::Any->new(url => '/Package/func')->run;
  
  =head1 DESCRIPTION
  
  This module lets you use L<Perinci::CmdLine::Lite> or
  L<Perinci::CmdLine::Classic>.
  
  If you want to force using a specific class, you can set the
  C<PERINCI_CMDLINE_ANY> environment variable, e.g. the command below will only
  try to use Perinci::CmdLine::Classic:
  
   % PERINCI_CMDLINE_ANY=Perinci::CmdLine::Classic yourapp.pl
   % PERINCI_CMDLINE_ANY=classic yourapp.pl
  
  If you want to prefer to Perinci::CmdLine::Classic (but user will still be able
  to override using C<PERINCI_CMDLINE_ANY>):
  
   use Perinci::CmdLine::Any -prefer_lite => 0;
  
  =for Pod::Coverage ^(new)$
  
  =head1 ENVIRONMENT
  
  =head2 PERINCI_CMDLINE_ANY => str
  
  Either specify module name, or C<lite> or C<classic>.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Perinci-CmdLine-Any>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Perinci-CmdLine-Any>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Perinci-CmdLine-Any>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Perinci::CmdLine::Lite>, L<Perinci::CmdLine::Classic>
  
  Another alternative backend, but not available through Perinci::CmdLine::Any
  since it works by generating script instead: L<Perinci::CmdLine::Inline>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017, 2016, 2015, 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PERINCI_CMDLINE_ANY

$fatpacked{"Proc/ChildError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PROC_CHILDERROR';
  package Proc::ChildError;
  
  our $DATE = '2016-01-06'; # DATE
  our $VERSION = '0.04'; # VERSION
  
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(explain_child_error);
  
  sub explain_child_error {
      my $opts;
      if (ref($_[0]) eq 'HASH') {
          $opts = shift;
      } else {
          $opts = {};
      }
  
      my ($num, $str);
      if (defined $_[0]) {
          $num = $_[0];
          $str = $_[1];
      } else {
          $num = $?;
          $str = $!;
      }
  
      my $prefix = "";
      if (defined $opts->{prog}) {
          $prefix = "$opts->{prog} ";
      }
  
      if ($num == -1) {
          return "${prefix}failed to execute: ".($str ? "$str ":"")."($num)";
      } elsif ($num & 127) {
          return sprintf(
              "${prefix}died with signal %d, %s coredump",
              ($num & 127),
              (($num & 128) ? 'with' : 'without'));
      } else {
          return sprintf("${prefix}exited with code %d", $num >> 8);
      }
  }
  
  1;
  # ABSTRACT: Explain process child error
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Proc::ChildError - Explain process child error
  
  =head1 VERSION
  
  This document describes version 0.04 of Proc::ChildError (from Perl distribution Proc-ChildError), released on 2016-01-06.
  
  =head1 FUNCTIONS
  
  =head2 explain_child_error([\%opts, ]$child_error, $os_error) => STR
  
  Produce a string description of an error number. C<$child_error> defaults to
  C<$?> if not specified. C<$os_error> defaults to C<$!> if not specified.
  
  The algorithm is taken from perldoc -f system. Some sample output:
  
   failed to execute: No such file or directory (-1)
   died with signal 15, with coredump
   exited with value 3
  
  An options hashref can be specified as the first argument to add information.
  Currently known keys:
  
  =over
  
  =item * prog => str
  
  Program name/path, to include in error messages:
  
   /usr/bin/foo failed to execute: Permission denied (-1)
   foo died with signal 15, with coredump
   /usr/bin/foo exited with value 3
  
  =back
  
  =head1 SEE ALSO
  
  L<Process::Status> provides a lightweight OO interface for C<$?>. I recommend
  this module now over Proc::ChildError.
  
  L<IPC::System::Simple> provides a replacement for Perl's C<system()>, with the
  difference that it will print a diagnostic error message similar to what
  C<Proc::ChildError> provides. You only need to do C<use IPC::System::Simple
  qw(system)> and use C<system()> as usual. Recommended.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Proc-ChildError>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Proc-ChildError>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Proc-ChildError>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PROC_CHILDERROR

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  # $Id: ShellQuote.pm,v 1.11 2010-06-11 20:08:57 roderick Exp $
  #
  # Copyright (c) 1997 Roderick Schertler.  All rights reserved.  This
  # program is free software; you can redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  =head1 NAME
  
  String::ShellQuote - quote strings for passing through the shell
  
  =head1 SYNOPSIS
  
      $string = shell_quote @list;
      $string = shell_quote_best_effort @list;
      $string = shell_comment_quote $string;
  
  =head1 DESCRIPTION
  
  This module contains some functions which are useful for quoting strings
  which are going to pass through the shell or a shell-like object.
  
  =over
  
  =cut
  
  package String::ShellQuote;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT);
  
  require Exporter;
  
  $VERSION	= '1.04';
  @ISA		= qw(Exporter);
  @EXPORT		= qw(shell_quote shell_quote_best_effort shell_comment_quote);
  
  sub croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _shell_quote_backend {
      my @in = @_;
      my @err = ();
  
      if (0) {
  	require RS::Handy;
  	print RS::Handy::data_dump(\@in);
      }
  
      return \@err, '' unless @in;
  
      my $ret = '';
      my $saw_non_equal = 0;
      foreach (@in) {
  	if (!defined $_ or $_ eq '') {
  	    $_ = "''";
  	    next;
  	}
  
  	if (s/\x00//g) {
  	    push @err, "No way to quote string containing null (\\000) bytes";
  	}
  
      	my $escape = 0;
  
  	# = needs quoting when it's the first element (or part of a
  	# series of such elements), as in command position it's a
  	# program-local environment setting
  
  	if (/=/) {
  	    if (!$saw_non_equal) {
  	    	$escape = 1;
  	    }
  	}
  	else {
  	    $saw_non_equal = 1;
  	}
  
  	if (m|[^\w!%+,\-./:=@^]|) {
  	    $escape = 1;
  	}
  
  	if ($escape
  		|| (!$saw_non_equal && /=/)) {
  
  	    # ' -> '\''
      	    s/'/'\\''/g;
  
  	    # make multiple ' in a row look simpler
  	    # '\'''\'''\'' -> '"'''"'
      	    s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
  
  	    $_ = "'$_'";
  	    s/^''//;
  	    s/''$//;
  	}
      }
      continue {
  	$ret .= "$_ ";
      }
  
      chop $ret;
      return \@err, $ret;
  }
  
  =item B<shell_quote> [I<string>]...
  
  B<shell_quote> quotes strings so they can be passed through the shell.
  Each I<string> is quoted so that the shell will pass it along as a
  single argument and without further interpretation.  If no I<string>s
  are given an empty string is returned.
  
  If any I<string> can't be safely quoted B<shell_quote> will B<croak>.
  
  =cut
  
  sub shell_quote {
      my ($rerr, $s) = _shell_quote_backend @_;
  
      if (@$rerr) {
      	my %seen;
      	@$rerr = grep { !$seen{$_}++ } @$rerr;
  	my $s = join '', map { "shell_quote(): $_\n" } @$rerr;
  	chomp $s;
  	croak $s;
      }
      return $s;
  }
  
  =item B<shell_quote_best_effort> [I<string>]...
  
  This is like B<shell_quote>, excpet if the string can't be safely quoted
  it does the best it can and returns the result, instead of dying.
  
  =cut
  
  sub shell_quote_best_effort {
      my ($rerr, $s) = _shell_quote_backend @_;
  
      return $s;
  }
  
  =item B<shell_comment_quote> [I<string>]
  
  B<shell_comment_quote> quotes the I<string> so that it can safely be
  included in a shell-style comment (the current algorithm is that a sharp
  character is placed after any newlines in the string).
  
  This routine might be changed to accept multiple I<string> arguments
  in the future.  I haven't done this yet because I'm not sure if the
  I<string>s should be joined with blanks ($") or nothing ($,).  Cast
  your vote today!  Be sure to justify your answer.
  
  =cut
  
  sub shell_comment_quote {
      return '' unless @_;
      unless (@_ == 1) {
  	croak "Too many arguments to shell_comment_quote "
  	    	    . "(got " . @_ . " expected 1)";
      }
      local $_ = shift;
      s/\n/\n#/g;
      return $_;
  }
  
  1;
  
  __END__
  
  =back
  
  =head1 EXAMPLES
  
      $cmd = 'fuser 2>/dev/null ' . shell_quote @files;
      @pids = split ' ', `$cmd`;
  
      print CFG "# Configured by: ",
  		shell_comment_quote($ENV{LOGNAME}), "\n";
  
  =head1 BUGS
  
  Only Bourne shell quoting is supported.  I'd like to add other shells
  (particularly cmd.exe), but I'm not familiar with them.  It would be a
  big help if somebody supplied the details.
  
  =head1 AUTHOR
  
  Roderick Schertler <F<roderick@argon.org>>
  
  =head1 SEE ALSO
  
  perl(1).
  
  =cut
STRING_SHELLQUOTE

$fatpacked{"darwin-2level/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
DARWIN-2LEVEL_VERSION

$fatpacked{"darwin-2level/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
DARWIN-2LEVEL_VERSION_REGEX

$fatpacked{"darwin-2level/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
DARWIN-2LEVEL_VERSION_VPP

$fatpacked{"darwin-2level/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
DARWIN-2LEVEL_VERSION_VXS

$fatpacked{"experimental.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPERIMENTAL';
  package experimental;
  $experimental::VERSION = '0.020';
  use strict;
  use warnings;
  use version ();
  
  BEGIN { eval { require feature } };
  use Carp qw/croak carp/;
  
  my %warnings = map { $_ => 1 } grep { /^experimental::/ } keys %warnings::Offsets;
  my %features = map { $_ => 1 } $] > 5.015006 ? keys %feature::feature : do {
  	my @features;
  	if ($] >= 5.010) {
  		push @features, qw/switch say state/;
  		push @features, 'unicode_strings' if $] > 5.011002;
  	}
  	@features;
  };
  
  my %min_version = (
  	array_base      => '5',
  	autoderef       => '5.14.0',
  	bitwise         => '5.22.0',
  	const_attr      => '5.22.0',
  	current_sub     => '5.16.0',
  	declared_refs   => '5.26.0',
  	evalbytes       => '5.16.0',
  	fc              => '5.16.0',
  	lexical_topic   => '5.10.0',
  	lexical_subs    => '5.18.0',
  	postderef       => '5.20.0',
  	postderef_qq    => '5.20.0',
  	refaliasing     => '5.22.0',
  	regex_sets      => '5.18.0',
  	say             => '5.10.0',
  	smartmatch      => '5.10.0',
  	signatures      => '5.20.0',
  	state           => '5.10.0',
  	switch          => '5.10.0',
  	unicode_eval    => '5.16.0',
  	unicode_strings => '5.12.0',
  );
  my %max_version = (
  	autoderef       => '5.23.1',
  	lexical_topic   => '5.23.4',
  );
  
  $_ = version->new($_) for values %min_version;
  $_ = version->new($_) for values %max_version;
  
  my %additional = (
  	postderef     => ['postderef_qq'],
  	switch        => ['smartmatch'],
  	declared_refs => ['refaliasing'],
  );
  
  sub _enable {
  	my $pragma = shift;
  	if ($warnings{"experimental::$pragma"}) {
  		warnings->unimport("experimental::$pragma");
  		feature->import($pragma) if exists $features{$pragma};
  		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif ($features{$pragma}) {
  		feature->import($pragma);
  		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif (not exists $min_version{$pragma}) {
  		croak "Can't enable unknown feature $pragma";
  	}
  	elsif ($] < $min_version{$pragma}) {
  		my $stable = $min_version{$pragma};
  		if ($stable->{version}[1] % 2) {
  			$stable = version->new(
  				"5.".($stable->{version}[1]+1).'.0'
  			);
  		}
  		croak "Need perl $stable or later for feature $pragma";
  	}
  	elsif ($] >= ($max_version{$pragma} || 7)) {
  		croak "Experimental feature $pragma has been removed from perl in version $max_version{$pragma}";
  	}
  }
  
  sub import {
  	my ($self, @pragmas) = @_;
  
  	for my $pragma (@pragmas) {
  		_enable($pragma);
  	}
  	return;
  }
  
  sub _disable {
  	my $pragma = shift;
  	if ($warnings{"experimental::$pragma"}) {
  		warnings->import("experimental::$pragma");
  		feature->unimport($pragma) if exists $features{$pragma};
  		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif ($features{$pragma}) {
  		feature->unimport($pragma);
  		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif (not exists $min_version{$pragma}) {
  		carp "Can't disable unknown feature $pragma, ignoring";
  	}
  }
  
  sub unimport {
  	my ($self, @pragmas) = @_;
  
  	for my $pragma (@pragmas) {
  		_disable($pragma);
  	}
  	return;
  }
  
  1;
  
  #ABSTRACT: Experimental features made easy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  experimental - Experimental features made easy
  
  =head1 VERSION
  
  version 0.020
  
  =head1 SYNOPSIS
  
   use experimental 'lexical_subs', 'smartmatch';
   my sub foo { $_[0] ~~ 1 }
  
  =head1 DESCRIPTION
  
  This pragma provides an easy and convenient way to enable or disable
  experimental features.
  
  Every version of perl has some number of features present but considered
  "experimental."  For much of the life of Perl 5, this was only a designation
  found in the documentation.  Starting in Perl v5.10.0, and more aggressively in
  v5.18.0, experimental features were placed behind pragmata used to enable the
  feature and disable associated warnings.
  
  The C<experimental> pragma exists to combine the required incantations into a
  single interface stable across releases of perl.  For every experimental
  feature, this should enable the feature and silence warnings for the enclosing
  lexical scope:
  
    use experimental 'feature-name';
  
  To disable the feature and, if applicable, re-enable any warnings, use:
  
    no experimental 'feature-name';
  
  The supported features, documented further below, are:
  
  =over 4
  
  =item * C<array_base> - allow the use of C<$[> to change the starting index of C<@array>.
  
  This is supported on all versions of perl.
  
  =item * C<autoderef> - allow push, each, keys, and other built-ins on references.
  
  This was added in perl 5.14.0 and removed in perl 5.23.1.
  
  =item * C<bitwise> - allow the new stringwise bit operators
  
  This was added in perl 5.22.0.
  
  =item * C<const_attr> - allow the :const attribute on subs
  
  This was added in perl 5.22.0.
  
  =item * C<lexical_topic> - allow the use of lexical C<$_> via C<my $_>.
  
  This was added in perl 5.10.0 and removed in perl 5.23.4.
  
  =item * C<lexical_subs> - allow the use of lexical subroutines.
  
  This was added in 5.18.0.
  
  =item * C<postderef> - allow the use of postfix dereferencing expressions,
  including in interpolating strings
  
  This was added in perl 5.20.0.
  
  =item * C<re_strict> - enables strict mode in regular expressions
  
  This was added in perl 5.22.0.
  
  =item * C<refaliasing> - allow aliasing via C<\$x = \$y>
  
  This was added in perl 5.22.0.
  
  =item * C<regex_sets> - allow extended bracketed character classes in regexps
  
  This was added in perl 5.18.0.
  
  =item * C<signatures> - allow subroutine signatures (for named arguments)
  
  This was added in perl 5.20.0.
  
  =item * C<smartmatch> - allow the use of C<~~>
  
  This was added in perl 5.10.0, but it should be noted there are significant
  incompatibilities between 5.10.0 and 5.10.1.
  
  =item * C<switch> - allow the use of C<~~>, given, and when
  
  This was added in perl 5.10.0.
  
  =item * C<win32_perlio> - allows the use of the :win32 IO layer.
  
  This was added on perl 5.22.0.
  
  =back
  
  =head2 Ordering matters
  
  Using this pragma to 'enable an experimental feature' is another way of saying
  that this pragma will disable the warnings which would result from using that
  feature.  Therefore, the order in which pragmas are applied is important.  In
  particular, you probably want to enable experimental features I<after> you
  enable warnings:
  
    use warnings;
    use experimental 'smartmatch';
  
  You also need to take care with modules that enable warnings for you.  A common
  example being Moose.  In this example, warnings for the 'smartmatch' feature are
  first turned on by the warnings pragma, off by the experimental pragma and back
  on again by the Moose module (fix is to switch the last two lines):
  
    use warnings;
    use experimental 'smartmatch';
    use Moose;
  
  =head2 Disclaimer
  
  Because of the nature of the features it enables, forward compatibility can not
  be guaranteed in any way.
  
  =head1 SEE ALSO
  
  L<perlexperimental|perlexperimental> contains more information about experimental features.
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXPERIMENTAL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


our $DATE = '2018-04-03'; # DATE
our $VERSION = '0.720'; # VERSION

use 5.010;
use strict;
use warnings;
use Log::ger;

use App::PMUtils;
use File::Which;
use IO::Prompt::I18N qw(confirm);
use Module::Path::More qw(module_path);
use IPC::System::Options qw(readpipe);
use Perinci::CmdLine::Any;

our %SPEC;
$SPEC{pmuninst} = {
    v => 1.1,
    summary => 'Uninstall an installed Perl module (using cpanm --uninstall)',
    args => {
        module => $App::PMUtils::arg_module_multiple,
        uninstall_rdeps => {
            schema => 'bool',
            summary => 'Also uninstall dists which depends on the module(s) being uninstalled',
            cmdline_aliases => {R=>{}},
        },
        confirm_yes => {
            schema => ['bool', is=>1],
            cmdline_aliases => {y=>{}},
        },
    },
    deps => {
        prog => 'cpanm',
    },
};
sub pmuninst {
    use experimental 'smartmatch';

    my %args = @_;
    my $mods = $args{module};

    if ($args{uninstall_rdeps}) {
        return [412, "lcpan is required to find reverse deps"]
            unless which("lcpan");
        require JSON::MaybeXS;
        my $res = readpipe(
            {log=>1, die=>1},
            "lcpan", "rdeps", "--phase", "ALL", "--rel", "requires", "--json",
            "-l", 2, # limit to this level for now, for speed
            "--no-naked-res",
            @$mods
        );
        $res = JSON::MaybeXS->new->decode($res);
        my @rmods;
        for (@{ $res->[2] }) {
            my $mod = $_->{dist}; $mod =~ s/^\s+//; $mod =~ s/-/::/g;
            next unless module_path(module=>$mod);
            push @rmods, $mod unless $mod ~~ @$mods;
        }
        if (@rmods && !$args{confirm_yes}) {
            return [200, "Cancelled"] unless
                confirm("These modules will also be uninstalled: ".
                        join(", ", @rmods) . ", are you sure?");
        }
        push @$mods, @rmods;
    }

    for my $mod (@$mods) {
        $mod =~ s/\.pm$//; $mod =~ s!/!::!g; # convenience
        system(
            "cpanm", "--uninstall",
            ($args{confirm_yes} ? ("-f") : ()),
            $mod,
        );
    }
    [200, "OK"]; # XXX check/accumulate success status
}

Perinci::CmdLine::Any->new(
    url => '/main/pmuninst',
)->run;

# ABSTRACT: Uninstall an installed Perl module (using cpanm --uninstall)
# PODNAME: pmuninst

__END__

=pod

=encoding UTF-8

=head1 NAME

pmuninst - Uninstall an installed Perl module (using cpanm --uninstall)

=head1 VERSION

This document describes version 0.720 of pmuninst (from Perl distribution App-PMUtils), released on 2018-04-03.

=head1 SYNOPSIS

 % pmuninst App::Stopwatch

=head1 OPTIONS

C<*> marks required options.

=head2 Main options

=over

=item B<--confirm-yes>, B<-y>

=item B<--module-json>=I<s>

See C<--module>.

=item B<--module>=I<s@>*

Can be specified multiple times.

=item B<--uninstall-rdeps>, B<-R>

Also uninstall dists which depends on the module(s) being uninstalled.

=back

=head2 Configuration options

=over

=item B<--config-path>=I<filename>

Set path to configuration file.

Can be specified multiple times.

=item B<--config-profile>=I<s>

Set configuration profile to use.

=item B<--no-config>

Do not use any configuration file.

=back

=head2 Environment options

=over

=item B<--no-env>

Do not read environment for default options.

=back

=head2 Output options

=over

=item B<--format>=I<s>

Choose output format, e.g. json, text.

Default value:

 undef

=item B<--json>

Set output format to json.

=item B<--naked-res>

When outputing as JSON, strip result envelope.

Default value:

 0

By default, when outputing as JSON, the full enveloped result is returned, e.g.:

    [200,"OK",[1,2,3],{"func.extra"=>4}]

The reason is so you can get the status (1st element), status message (2nd
element) as well as result metadata/extra result (4th element) instead of just
the result (3rd element). However, sometimes you want just the result, e.g. when
you want to pipe the result for more post-processing. In this case you can use
`--naked-res` so you just get:

    [1,2,3]


=back

=head2 Other options

=over

=item B<--help>, B<-h>, B<-?>

Display help message and exit.

=item B<--version>, B<-v>

Display program's version and exit.

=back

=head1 COMPLETION

This script has shell tab completion capability with support for several
shells.

=head2 bash

To activate bash completion for this script, put:

 complete -C pmuninst pmuninst

in your bash startup (e.g. F<~/.bashrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is recommended, however, that you install modules using L<cpanm-shcompgen>
which can activate shell completion for scripts immediately.

=head2 tcsh

To activate tcsh completion for this script, put:

 complete pmuninst 'p/*/`pmuninst`/'

in your tcsh startup (e.g. F<~/.tcshrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is also recommended to install L<shcompgen> (see above).

=head2 other shells

For fish and zsh, install L<shcompgen> as described above.

=head1 CONFIGURATION FILE

This script can read configuration files. Configuration files are in the format of L<IOD>, which is basically INI with some extra features.

By default, these names are searched for configuration filenames (can be changed using C<--config-path>): F<~/.config/pmuninst.conf>, F<~/pmuninst.conf>, or F</etc/pmuninst.conf>.

All found files will be read and merged.

To disable searching for configuration files, pass C<--no-config>.

You can put multiple profiles in a single file by using section names like C<[profile=SOMENAME]> or C<[SOMESECTION profile=SOMENAME]>. Those sections will only be read if you specify the matching C<--config-profile SOMENAME>.

You can also put configuration for multiple programs inside a single file, and use filter C<program=NAME> in section names, e.g. C<[program=NAME ...]> or C<[SOMESECTION program=NAME]>. The section will then only be used when the reading program matches.

Finally, you can filter a section by environment variable using the filter C<env=CONDITION> in section names. For example if you only want a section to be read if a certain environment variable is true: C<[env=SOMEVAR ...]> or C<[SOMESECTION env=SOMEVAR ...]>. If you only want a section to be read when the value of an environment variable has value equals something: C<[env=HOSTNAME=blink ...]> or C<[SOMESECTION env=HOSTNAME=blink ...]>. If you only want a section to be read when the value of an environment variable does not equal something: C<[env=HOSTNAME!=blink ...]> or C<[SOMESECTION env=HOSTNAME!=blink ...]>. If you only want a section to be read when an environment variable contains something: C<[env=HOSTNAME*=server ...]> or C<[SOMESECTION env=HOSTNAME*=server ...]>. Note that currently due to simplistic parsing, there must not be any whitespace in the value being compared because it marks the beginning of a new section filter or section name.

List of available configuration parameters:

 confirm_yes (see --confirm-yes)
 format (see --format)
 module (see --module)
 naked_res (see --naked-res)
 uninstall_rdeps (see --uninstall-rdeps)

=head1 ENVIRONMENT

=head2 PMUNINST_OPT => str

Specify additional command-line options.

=head1 FILES

F<~/.config/pmuninst.conf>

F<~/pmuninst.conf>

F</etc/pmuninst.conf>

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/App-PMUtils>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-App-PMUtils>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-PMUtils>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2018, 2017, 2016, 2015, 2014 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
