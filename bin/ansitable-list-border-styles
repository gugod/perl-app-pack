#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Border/Style.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BORDER_STYLE';
  package Border::Style;
  
  our $DATE = '2014-12-10'; # DATE
  our $VERSION = '0.01'; # VERSION
  
  1;
  # ABSTRACT: Border style structure
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Border::Style - Border style structure
  
  =head1 VERSION
  
  This document describes version 0.01 of Border::Style (from Perl distribution Border-Style), released on 2014-12-10.
  
  =head1 DESCRIPTION
  
  This module specifies a structure for border styles. The distribution also comes
  with utility routines and roles for managing border styles in applications.
  
  =head1 SPECIFICATION
  
  Border style is a L<DefHash> containing these keys: C<v>, C<name>, C<summary>,
  C<utf8> (bool, set to true to indicate that characters are Unicode characters in
  UTF8), C<chars> (array). Format for the characters in C<chars>:
  
   [
     [A, b, C, D],  # 0
     [E, F, G],     # 1
     [H, i, J, K],  # 2
     [L, M, N],     # 3
     [O, p, Q, R],  # 4
     [S, t, U, V],  # 5
   ]
  
   AbbbCbbbD        #0 Top border characters
   E   F   G        #1 Vertical separators for header row
   HiiiJiiiK        #2 Separator between header row and first data row
   L   M   N        #3 Vertical separators for data row
   OpppQpppR        #4 Separator between data rows
   L   M   N        #3
   StttUtttV        #5 Bottom border characters
  
  A character can also be a coderef that will be called with C<< ($self, %args)
  >>. Arguments in C<%args> contains information such as C<name>, C<y>, C<x>, C<n>
  (how many times should character be repeated), etc.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Border-Style>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Border-Style>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Border-Style>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
BORDER_STYLE

$fatpacked{"Border/Style/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BORDER_STYLE_ROLE';
  package Border::Style::Role;
  
  our $DATE = '2014-12-10'; # DATE
  our $VERSION = '0.01'; # VERSION
  
  # currently this is still very Text::ANSITable-ish.
  
  use 5.010001;
  use Moo::Role;
  
  with 'Term::App::Role::Attrs';
  
  has border_style_args  => (is => 'rw', default => sub { {} });
  has _all_border_styles => (is => 'rw');
  
  sub get_border_char {
      my ($self, $y, $x, $n, $args) = @_;
      my $bch = $self->{border_style}{chars};
      $n //= 1;
      if (ref($bch) eq 'CODE') {
          $bch->($self, y=>$y, x=>$x, n=>$n, %{$args // {}});
      } else {
          $bch->[$y][$x] x $n;
      }
  }
  
  sub border_style {
      my $self = shift;
  
      if (!@_) { return $self->{border_style} }
      my $bs = shift;
  
      my $p2 = "";
      if (!ref($bs)) {
          $p2 = " named $bs";
          $bs = $self->get_border_style($bs);
      }
  
      my $err;
      if ($bs->{box_chars} && !$self->use_box_chars) {
          $err = "use_box_chars is set to false";
      } elsif ($bs->{utf8} && !$self->use_utf8) {
          $err = "use_utf8 is set to false";
      }
      die "Can't select border style$p2: $err" if $err;
  
      $self->{border_style} = $bs;
  }
  
  sub get_border_style {
      my ($self, $bs) = @_;
  
      my $prefix = (ref($self) ? ref($self) : $self ) .
          '::BorderStyle'; # XXX allow override
  
      my $bss;
      my $pkg;
      if ($bs =~ s/(.+):://) {
          $pkg = "$prefix\::$1";
          my $pkgp = $pkg; $pkgp =~ s!::!/!g;
          require "$pkgp.pm";
          no strict 'refs';
          $bss = \%{"$pkg\::border_styles"};
      } else {
          #$bss = $self->list_border_styles(1);
          die "Please use SubPackage::name to choose border style, ".
              "use list_border_styles() to list available styles";
      }
      $bss->{$bs} or die "Unknown border style name '$bs'".
          ($pkg ? " in package $prefix\::$pkg" : "");
      $bss->{$bs};
  }
  
  sub list_border_styles {
      require Module::List;
      require Module::Load;
  
      my ($self, $detail) = @_;
  
      my $prefix = (ref($self) ? ref($self) : $self ) .
          '::BorderStyle'; # XXX allow override
      my $all_bs = $self->_all_border_styles;
  
      if (!$all_bs) {
          my $mods = Module::List::list_modules("$prefix\::",
                                                {list_modules=>1, recurse=>1});
          no strict 'refs';
          $all_bs = {};
          for my $mod (sort keys %$mods) {
              #$log->tracef("Loading border style module '%s' ...", $mod);
              Module::Load::load($mod);
              my $bs = \%{"$mod\::border_styles"};
              for (keys %$bs) {
                  my $cutmod = $mod;
                  $cutmod =~ s/^\Q$prefix\E:://;
                  my $name = "$cutmod\::$_";
                  $bs->{$_}{name} = $name;
                  $all_bs->{$name} = $bs->{$_};
              }
          }
          $self->_all_border_styles($all_bs);
      }
  
      if ($detail) {
          return $all_bs;
      } else {
          return sort keys %$all_bs;
      }
  }
  
  1;
  # ABSTRACT: Role for class wanting to support border styles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Border::Style::Role - Role for class wanting to support border styles
  
  =head1 VERSION
  
  This document describes version 0.01 of Border::Style::Role (from Perl distribution Border-Style), released on 2014-12-10.
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 border_style => HASH
  
  =head2 border_style_args => HASH
  
  =head1 METHODS
  
  =head2 $cl->list_border_styles($detail) => ARRAY
  
  =head2 $cl->get_border_style($name) => HASH
  
  =head2 $cl->get_border_char($y, $x, $repeat, \%args) => STR
  
  Pick border character from border style (and optionally repeat it C<$repeat>
  times). C<\%args> is a hashref to be supplied to the coderef if the 'chars'
  value from the style is a coderef.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Border-Style>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Border-Style>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Border-Style>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
BORDER_STYLE_ROLE

$fatpacked{"Color/ANSI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COLOR_ANSI_UTIL';
  package Color::ANSI::Util;
  
  our $DATE = '2017-12-03'; # DATE
  our $VERSION = '0.160'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
                         ansi16_to_rgb
                         rgb_to_ansi16
                         rgb_to_ansi16_fg_code
                         ansi16fg
                         rgb_to_ansi16_bg_code
                         ansi16bg
  
                         ansi256_to_rgb
                         rgb_to_ansi256
                         rgb_to_ansi256_fg_code
                         ansi256fg
                         rgb_to_ansi256_bg_code
                         ansi256bg
  
                         rgb_to_ansi24b_fg_code
                         ansi24bfg
                         rgb_to_ansi24b_bg_code
                         ansi24bbg
  
                         rgb_to_ansi_fg_code
                         ansifg
                         rgb_to_ansi_bg_code
                         ansibg
                 );
  
  our %SPEC;
  
  my %ansi16 = (
      0  => '000000',
      1  => '800000',
      2  => '008000',
      3  => '808000',
      4  => '000080',
      5  => '800080',
      6  => '008080',
      7  => 'c0c0c0',
      8  => '808080',
      9  => 'ff0000',
      10 => '00ff00',
      11 => 'ffff00',
      12 => '0000ff',
      13 => 'ff00ff',
      14 => '00ffff',
      15 => 'ffffff',
  );
  my @revansi16;
  for (sort {$a<=>$b} keys %ansi16) {
      $ansi16{$_} =~ /(..)(..)(..)/;
      push @revansi16, [hex($1), hex($2), hex($3), $_];
  }
  
  my %ansi256 = (
      %ansi16,
  
      16 => '000000',  17 => '00005f',  18 => '000087',  19 => '0000af',  20 => '0000d7',  21 => '0000ff',
      22 => '005f00',  23 => '005f5f',  24 => '005f87',  25 => '005faf',  26 => '005fd7',  27 => '005fff',
      28 => '008700',  29 => '00875f',  30 => '008787',  31 => '0087af',  32 => '0087d7',  33 => '0087ff',
      34 => '00af00',  35 => '00af5f',  36 => '00af87',  37 => '00afaf',  38 => '00afd7',  39 => '00afff',
      40 => '00d700',  41 => '00d75f',  42 => '00d787',  43 => '00d7af',  44 => '00d7d7',  45 => '00d7ff',
      46 => '00ff00',  47 => '00ff5f',  48 => '00ff87',  49 => '00ffaf',  50 => '00ffd7',  51 => '00ffff',
      52 => '5f0000',  53 => '5f005f',  54 => '5f0087',  55 => '5f00af',  56 => '5f00d7',  57 => '5f00ff',
      58 => '5f5f00',  59 => '5f5f5f',  60 => '5f5f87',  61 => '5f5faf',  62 => '5f5fd7',  63 => '5f5fff',
      64 => '5f8700',  65 => '5f875f',  66 => '5f8787',  67 => '5f87af',  68 => '5f87d7',  69 => '5f87ff',
      70 => '5faf00',  71 => '5faf5f',  72 => '5faf87',  73 => '5fafaf',  74 => '5fafd7',  75 => '5fafff',
      76 => '5fd700',  77 => '5fd75f',  78 => '5fd787',  79 => '5fd7af',  80 => '5fd7d7',  81 => '5fd7ff',
      82 => '5fff00',  83 => '5fff5f',  84 => '5fff87',  85 => '5fffaf',  86 => '5fffd7',  87 => '5fffff',
      88 => '870000',  89 => '87005f',  90 => '870087',  91 => '8700af',  92 => '8700d7',  93 => '8700ff',
      94 => '875f00',  95 => '875f5f',  96 => '875f87',  97 => '875faf',  98 => '875fd7',  99 => '875fff',
      100 => '878700', 101 => '87875f', 102 => '878787', 103 => '8787af', 104 => '8787d7', 105 => '8787ff',
      106 => '87af00', 107 => '87af5f', 108 => '87af87', 109 => '87afaf', 110 => '87afd7', 111 => '87afff',
      112 => '87d700', 113 => '87d75f', 114 => '87d787', 115 => '87d7af', 116 => '87d7d7', 117 => '87d7ff',
      118 => '87ff00', 119 => '87ff5f', 120 => '87ff87', 121 => '87ffaf', 122 => '87ffd7', 123 => '87ffff',
      124 => 'af0000', 125 => 'af005f', 126 => 'af0087', 127 => 'af00af', 128 => 'af00d7', 129 => 'af00ff',
      130 => 'af5f00', 131 => 'af5f5f', 132 => 'af5f87', 133 => 'af5faf', 134 => 'af5fd7', 135 => 'af5fff',
      136 => 'af8700', 137 => 'af875f', 138 => 'af8787', 139 => 'af87af', 140 => 'af87d7', 141 => 'af87ff',
      142 => 'afaf00', 143 => 'afaf5f', 144 => 'afaf87', 145 => 'afafaf', 146 => 'afafd7', 147 => 'afafff',
      148 => 'afd700', 149 => 'afd75f', 150 => 'afd787', 151 => 'afd7af', 152 => 'afd7d7', 153 => 'afd7ff',
      154 => 'afff00', 155 => 'afff5f', 156 => 'afff87', 157 => 'afffaf', 158 => 'afffd7', 159 => 'afffff',
      160 => 'd70000', 161 => 'd7005f', 162 => 'd70087', 163 => 'd700af', 164 => 'd700d7', 165 => 'd700ff',
      166 => 'd75f00', 167 => 'd75f5f', 168 => 'd75f87', 169 => 'd75faf', 170 => 'd75fd7', 171 => 'd75fff',
      172 => 'd78700', 173 => 'd7875f', 174 => 'd78787', 175 => 'd787af', 176 => 'd787d7', 177 => 'd787ff',
      178 => 'd7af00', 179 => 'd7af5f', 180 => 'd7af87', 181 => 'd7afaf', 182 => 'd7afd7', 183 => 'd7afff',
      184 => 'd7d700', 185 => 'd7d75f', 186 => 'd7d787', 187 => 'd7d7af', 188 => 'd7d7d7', 189 => 'd7d7ff',
      190 => 'd7ff00', 191 => 'd7ff5f', 192 => 'd7ff87', 193 => 'd7ffaf', 194 => 'd7ffd7', 195 => 'd7ffff',
      196 => 'ff0000', 197 => 'ff005f', 198 => 'ff0087', 199 => 'ff00af', 200 => 'ff00d7', 201 => 'ff00ff',
      202 => 'ff5f00', 203 => 'ff5f5f', 204 => 'ff5f87', 205 => 'ff5faf', 206 => 'ff5fd7', 207 => 'ff5fff',
      208 => 'ff8700', 209 => 'ff875f', 210 => 'ff8787', 211 => 'ff87af', 212 => 'ff87d7', 213 => 'ff87ff',
      214 => 'ffaf00', 215 => 'ffaf5f', 216 => 'ffaf87', 217 => 'ffafaf', 218 => 'ffafd7', 219 => 'ffafff',
      220 => 'ffd700', 221 => 'ffd75f', 222 => 'ffd787', 223 => 'ffd7af', 224 => 'ffd7d7', 225 => 'ffd7ff',
      226 => 'ffff00', 227 => 'ffff5f', 228 => 'ffff87', 229 => 'ffffaf', 230 => 'ffffd7', 231 => 'ffffff',
  
      232 => '080808', 233 => '121212', 234 => '1c1c1c', 235 => '262626', 236 => '303030', 237 => '3a3a3a',
      238 => '444444', 239 => '4e4e4e', 240 => '585858', 241 => '606060', 242 => '666666', 243 => '767676',
      244 => '808080', 245 => '8a8a8a', 246 => '949494', 247 => '9e9e9e', 248 => 'a8a8a8', 249 => 'b2b2b2',
      250 => 'bcbcbc', 251 => 'c6c6c6', 252 => 'd0d0d0', 253 => 'dadada', 254 => 'e4e4e4', 255 => 'eeeeee',
  );
  my @revansi256;
  for (sort {$a<=>$b} keys %ansi256) {
      $ansi256{$_} =~ /(..)(..)(..)/;
      push @revansi256, [hex($1), hex($2), hex($3), $_];
  }
  
  $SPEC{ansi16_to_rgb} = {
      v => 1.1,
      summary => 'Convert ANSI-16 color to RGB',
      description => <<'_',
  
  Returns 6-hexdigit, e.g. 'ff00cc'.
  
  _
      args => {
          color => {
              schema => 'color::ansi16*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::rgb24*',
      },
      result_naked => 1,
  };
  sub ansi16_to_rgb {
      my ($input) = @_;
  
      if ($input =~ /^\d+$/) {
          if ($input >= 0 && $input <= 15) {
              return $ansi16{$input + 0}; # to remove prefix zero e.g. "06"
          } else {
              die "Invalid ANSI 16-color number '$input'";
          }
      } elsif ($input =~ /^(?:(bold|bright) \s )?(black|red|green|yellow|blue|magenta|cyan|white)$/ix) {
          my ($bold, $col) = (lc($1 // ""), lc($2));
          my $i;
          if ($col eq 'black') {
              $i = 0;
          } elsif ($col eq 'red') {
              $i = 1;
          } elsif ($col eq 'green') {
              $i = 2;
          } elsif ($col eq 'yellow') {
              $i = 3;
          } elsif ($col eq 'blue') {
              $i = 4;
          } elsif ($col eq 'magenta') {
              $i = 5;
          } elsif ($col eq 'cyan') {
              $i = 6;
          } elsif ($col eq 'white') {
              $i = 7;
          }
          $i += 8 if $bold;
          return $ansi16{$i};
      } else {
          die "Invalid ANSI 16-color name '$input'";
      }
  }
  
  sub _rgb_to_indexed {
      my ($rgb, $table) = @_;
  
      $rgb =~ /^#?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
          or die "Invalid RGB input '$rgb'";
      my $r = hex($1);
      my $g = hex($2);
      my $b = hex($3);
  
      my ($minsqdist, $res);
      for my $e (@$table) {
          my $sqdist =
              abs($e->[0]-$r)**2 + abs($e->[1]-$g)**2 + abs($e->[2]-$b)**2;
          # exact match, return immediately
          return $e->[3] if $sqdist == 0;
          if (!defined($minsqdist) || $minsqdist > $sqdist) {
              #say "D:sqdist=$sqdist";
              $minsqdist = $sqdist;
              $res = $e->[3];
          }
      }
      return $res;
  }
  
  $SPEC{ansi256_to_rgb} = {
      v => 1.1,
      summary => 'Convert ANSI-256 color to RGB',
      args => {
          color => {
              schema => 'color::ansi256*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::rgb24',
      },
      result_naked => 1,
  };
  sub ansi256_to_rgb {
      my ($input) = @_;
  
      $input += 0;
      exists($ansi256{$input}) or die "Invalid ANSI 256-color index '$input'";
      $ansi256{$input};
  }
  
  $SPEC{rgb_to_ansi16} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-16 color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::ansi16*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi16 {
      my ($input) = @_;
      _rgb_to_indexed($input, \@revansi16);
  }
  
  $SPEC{rgb_to_ansi256} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-256 color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::ansi256*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi256 {
      my ($input) = @_;
      _rgb_to_indexed($input, \@revansi256);
  }
  
  $SPEC{rgb_to_ansi16_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-16 color escape sequence to change foreground color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi16_fg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[" . ($res >= 8 ? ($res+30-8) . ";1" : ($res+30)) . "m";
  }
  
  sub ansi16fg  { goto &rgb_to_ansi16_fg_code  }
  
  $SPEC{rgb_to_ansi16_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-16 color escape sequence to change background color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi16_bg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[" . ($res >= 8 ? ($res+40-8) : ($res+40)) . "m";
  }
  
  sub ansi16bg  { goto &rgb_to_ansi16_bg_code  }
  
  $SPEC{rgb_to_ansi256_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-256 color escape sequence to change foreground color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi256_fg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[38;5;${res}m";
  }
  
  sub ansi256fg { goto &rgb_to_ansi256_fg_code }
  
  $SPEC{rgb_to_ansi256_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-256 color escape sequence to change background color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi256_bg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[48;5;${res}m";
  }
  
  sub ansi256bg { goto &rgb_to_ansi256_bg_code }
  
  $SPEC{rgb_to_ansi24b_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI 24bit-color escape sequence to change foreground color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi24b_fg_code {
      my ($rgb) = @_;
  
      return sprintf("\e[38;2;%d;%d;%dm",
                     hex(substr($rgb, 0, 2)),
                     hex(substr($rgb, 2, 2)),
                     hex(substr($rgb, 4, 2)));
  }
  
  sub ansi24bfg { goto &rgb_to_ansi24b_fg_code }
  
  $SPEC{rgb_to_ansi24b_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI 24bit-color escape sequence to change background color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi24b_bg_code {
      my ($rgb) = @_;
  
      return sprintf("\e[48;2;%d;%d;%dm",
                     hex(substr($rgb, 0, 2)),
                     hex(substr($rgb, 2, 2)),
                     hex(substr($rgb, 4, 2)));
  }
  
  sub ansi24bbg { goto &rgb_to_ansi24b_bg_code }
  
  our $_use_termdetsw = 1;
  our $_color_depth; # cache, can be set during testing
  sub _color_depth {
      unless (defined $_color_depth) {
          {
              if (defined $ENV{COLOR} && !$ENV{COLOR}) {
                  $_color_depth = 0;
                  last;
              }
              if (defined $ENV{COLOR_DEPTH}) {
                  $_color_depth = $ENV{COLOR_DEPTH};
                  last;
              }
              if ($_use_termdetsw) {
                  eval { require Term::Detect::Software };
                  if (!$@) {
                      $_color_depth = Term::Detect::Software::detect_terminal_cached()->{color_depth};
                      last;
                  }
              }
              # simple heuristic
              if ($ENV{KONSOLE_DBUS_SERVICE}) {
                  $_color_depth = 2**24;
                  last;
              }
              # safe value
              $_color_depth = 16;
          }
      };
      $_color_depth;
  }
  
  $SPEC{rgb_to_ansi_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI color escape sequence to change foreground color',
      description => <<'_',
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Color depth used is determined by `COLOR_DEPTH` environment setting or from
  <pm:Term::Detect::Software> if that module is available. In other words, this
  function automatically chooses rgb_to_ansi{24b,256,16}_fg_code().
  
  _
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi_fg_code {
      my ($rgb) = @_;
      my $cd = _color_depth();
      if ($cd >= 2**24) {
          rgb_to_ansi24b_fg_code($rgb);
      } elsif ($cd >= 256) {
          rgb_to_ansi256_fg_code($rgb);
      } elsif ($cd >= 16) {
          rgb_to_ansi16_fg_code($rgb);
      } else {
          "";
      }
  }
  
  sub ansifg { goto &rgb_to_ansi_fg_code }
  
  $SPEC{rgb_to_ansi_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI color escape sequence to change background color',
      description => <<'_',
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Which color depth used is determined by `COLOR_DEPTH` environment setting or
  from <pm:Term::Detect::Software> if that module is available). In other words,
  this function automatically chooses rgb_to_ansi{24b,256,16}_bg_code().
  
  _
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi_bg_code {
      my ($rgb) = @_;
      my $cd = _color_depth();
      if ($cd >= 2**24) {
          rgb_to_ansi24b_bg_code($rgb);
      } elsif ($cd >= 256) {
          rgb_to_ansi256_bg_code($rgb);
      } else {
          rgb_to_ansi16_bg_code($rgb);
      }
  }
  
  sub ansibg { goto &rgb_to_ansi_bg_code }
  
  1;
  # ABSTRACT: Routines for dealing with ANSI colors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Color::ANSI::Util - Routines for dealing with ANSI colors
  
  =head1 VERSION
  
  This document describes version 0.160 of Color::ANSI::Util (from Perl distribution Color-ANSI-Util), released on 2017-12-03.
  
  =head1 SYNOPSIS
  
   use Color::ANSI::Util qw(
       ansifg
       ansibg
   );
  
   say ansifg("f0c010"); # => "\e[33;1m" (on 16-color terminal)
                         # => "\e[38;5;11m" (on 256-color terminal)
                         # => "\e[38;2;240;192;16m" (on 24-bit-color terminal)
  
   say ansibg("ff5f87"); # => "\e[47m" (on 16-color terminal)
                         # => "\e[48;5;7m" (on 256-color terminal)
                         # => "\e[48;2;255;95;135m" (on 24-bit-color terminal)
  
  There are a bunch of other exportable functions too, mostly for converting
  between RGB and ANSI color (16/256/24bit color depth).
  
  =head1 DESCRIPTION
  
  This module provides routines for dealing with ANSI colors. The two main
  functions are C<ansifg> and C<ansibg>. With those functions, you can specify
  colors in RGB and let it output the correct ANSI color escape code according to
  the color depth support of the terminal (whether 16-color, 256-color, or 24bit).
  There are other functions to convert RGB to ANSI in specific color depths, or
  reverse functions to convert from ANSI to RGB codes.
  
  Keywords: xterm, xterm-256color, terminal
  
  =head1 BUGS/NOTES
  
  Algorithm for finding closest indexed color from RGB color currently not very
  efficient. Probably can add some threshold square distance, below which we can
  shortcut to the final answer.
  
  =head1 FUNCTIONS
  
  
  =head2 ansi16_to_rgb
  
  Usage:
  
   ansi16_to_rgb($color) -> color::rgb24
  
  Convert ANSI-16 color to RGB.
  
  Returns 6-hexdigit, e.g. 'ff00cc'.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::ansi16>
  
  =back
  
  Return value:  (color::rgb24)
  
  
  =head2 ansi256_to_rgb
  
  Usage:
  
   ansi256_to_rgb($color) -> color::rgb24
  
  Convert ANSI-256 color to RGB.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::ansi256>
  
  =back
  
  Return value:  (color::rgb24)
  
  
  =head2 rgb_to_ansi16
  
  Usage:
  
   rgb_to_ansi16($color) -> color::ansi16
  
  Convert RGB to ANSI-16 color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (color::ansi16)
  
  
  =head2 rgb_to_ansi16_bg_code
  
  Usage:
  
   rgb_to_ansi16_bg_code($color) -> str
  
  Convert RGB to ANSI-16 color escape sequence to change background color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi16_fg_code
  
  Usage:
  
   rgb_to_ansi16_fg_code($color) -> str
  
  Convert RGB to ANSI-16 color escape sequence to change foreground color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi24b_bg_code
  
  Usage:
  
   rgb_to_ansi24b_bg_code($color) -> str
  
  Convert RGB to ANSI 24bit-color escape sequence to change background color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi24b_fg_code
  
  Usage:
  
   rgb_to_ansi24b_fg_code($color) -> str
  
  Convert RGB to ANSI 24bit-color escape sequence to change foreground color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi256
  
  Usage:
  
   rgb_to_ansi256($color) -> color::ansi256
  
  Convert RGB to ANSI-256 color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (color::ansi256)
  
  
  =head2 rgb_to_ansi256_bg_code
  
  Usage:
  
   rgb_to_ansi256_bg_code($color) -> str
  
  Convert RGB to ANSI-256 color escape sequence to change background color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi256_fg_code
  
  Usage:
  
   rgb_to_ansi256_fg_code($color) -> str
  
  Convert RGB to ANSI-256 color escape sequence to change foreground color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi_bg_code
  
  Usage:
  
   rgb_to_ansi_bg_code($color) -> str
  
  Convert RGB to ANSI color escape sequence to change background color.
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Which color depth used is determined by C<COLOR_DEPTH> environment setting or
  from L<Term::Detect::Software> if that module is available). In other words,
  this function automatically chooses rgb_to_ansi{24b,256,16}I<bg>code().
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi_fg_code
  
  Usage:
  
   rgb_to_ansi_fg_code($color) -> str
  
  Convert RGB to ANSI color escape sequence to change foreground color.
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Color depth used is determined by C<COLOR_DEPTH> environment setting or from
  L<Term::Detect::Software> if that module is available. In other words, this
  function automatically chooses rgb_to_ansi{24b,256,16}I<fg>code().
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  =head2 ansi16fg($rgb) => STR
  
  Alias for rgb_to_ansi16_fg_code().
  
  =head2 ansi16bg($rgb) => STR
  
  Alias for rgb_to_ansi16_bg_code().
  
  =head2 ansi256fg($rgb) => STR
  
  Alias for rgb_to_ansi256_fg_code().
  
  =head2 ansi256bg($rgb) => STR
  
  Alias for rgb_to_ansi256_bg_code().
  
  =head2 ansi24bfg($rgb) => STR
  
  Alias for rgb_to_ansi24b_fg_code().
  
  =head2 ansi24bbg($rgb) => STR
  
  Alias for rgb_to_ansi24b_bg_code().
  
  =head2 rgb_to_ansi_fg_code($rgb) => STR
  
  =head2 ansifg($rgb) => STR
  
  Alias for rgb_to_ansi_fg_code().
  
  =head2 ansibg($rgb) => STR
  
  Alias for rgb_to_ansi_bg_code().
  
  =head1 ENVIRONMENT
  
  =head2 COLOR => bool
  
  Can be used to explicitly disable color by setting it to 0.
  
  Observed by: ansi{fg,bg}.
  
  =head2 COLOR_DEPTH => INT
  
  Can be used to explicitly set color depth instead of trying to detect
  appropriate color depth.
  
  Observed by: ansi{fg,bg}.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Color-ANSI-Util>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/sharyanto/perl-Color-ANSI-Util>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Color-ANSI-Util>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Term::ANSIColor>
  
  L<http://en.wikipedia.org/wiki/ANSI_escape_code>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
COLOR_ANSI_UTIL

$fatpacked{"Color/Theme/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COLOR_THEME_ROLE';
  ## no critic (Subroutines::ProhibitReturnSort)
  
  package Color::Theme::Role;
  
  our $DATE = '2018-02-25'; # DATE
  our $VERSION = '0.020'; # VERSION
  
  use 5.010001;
  use Moo::Role;
  
  has color_theme_args  => (is => 'rw', default => sub { {} });
  has _all_color_themes => (is => 'rw');
  
  sub color_theme_module_prefix {
      my $self = shift;
  
      (ref($self) ? ref($self) : $self ) . '::ColorTheme';
  }
  
  sub color_theme {
      my $self = shift;
  
      if (!@_) { return $self->{color_theme} }
      my $ct = shift;
  
      my $p2 = "";
      if (!ref($ct)) {
          $p2 = " named $ct";
          $ct = $self->get_color_theme($ct);
      }
  
      my $err;
      if (!$ct->{no_color} && !$self->use_color) {
          $err = "color theme uses color but use_color is set to false";
      }
      die "Can't select color theme$p2: $err" if $err;
  
      $self->{color_theme} = $ct;
  }
  
  sub get_color_theme {
      my ($self, $ct) = @_;
  
      my $prefix = $self->color_theme_module_prefix;
      my $cts;
      my $pkg;
      if ($ct =~ s/(.+):://) {
          $pkg = "$prefix\::$1";
          my $pkgp = $pkg; $pkgp =~ s!::!/!g;
          require "$pkgp.pm";
          no strict 'refs';
          $cts = \%{"$pkg\::color_themes"};
      } else {
          #$cts = $self->list_color_themes(1);
          die "Please use SubPackage::name to choose color theme, ".
              "use list_color_themes() to list available themes";
      }
      $cts->{$ct} or die "Unknown color theme name '$ct'".
          ($pkg ? " in package $pkg" : "");
      ($cts->{$ct}{v} // 1.0) == 1.1 or die "Color theme '$ct' is too old ".
          "(v < 1.1)". ($pkg ? ", please upgrade $pkg" : "");
      $cts->{$ct};
  }
  
  sub get_theme_color {
      my ($self, $item_name) = @_;
  
      return undef if $self->{color_theme}{no_color};
      $self->{color_theme}{colors}{$item_name};
  }
  
  sub get_theme_color_as_rgb {
      my ($self, $item_name, $args) = @_;
      my $c = $self->get_theme_color($item_name);
      return undef unless defined($c);
  
      # resolve coderef color
      if (ref($c) eq 'CODE') {
          $args //= {};
          $c = $c->($self, %$args);
      }
  
      $c;
  }
  
  sub list_color_themes {
      require Module::List;
      require Module::Load;
  
      my ($self, $detail) = @_;
  
      my $prefix = $self->color_theme_module_prefix;
      my $all_ct = $self->_all_color_themes;
  
      if (!$all_ct) {
          my $mods = Module::List::list_modules("$prefix\::",
                                                {list_modules=>1, recurse=>1});
          no strict 'refs';
          $all_ct = {};
          for my $mod (sort keys %$mods) {
              #$log->tracef("Loading color theme module '%s' ...", $mod);
              Module::Load::load($mod);
              my $ct = \%{"$mod\::color_themes"};
              for (keys %$ct) {
                  my $cutmod = $mod;
                  $cutmod =~ s/^\Q$prefix\E:://;
                  my $name = "$cutmod\::$_";
                  $ct->{$_}{name} = $name;
                  $all_ct->{$name} = $ct->{$_};
              }
          }
          $self->_all_color_themes($all_ct);
      }
  
      if ($detail) {
          return $all_ct;
      } else {
          return sort keys %$all_ct;
      }
  }
  
  1;
  # ABSTRACT: Role for class wanting to support color themes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Color::Theme::Role - Role for class wanting to support color themes
  
  =head1 VERSION
  
  This document describes version 0.020 of Color::Theme::Role (from Perl distribution Color-Theme-Role), released on 2018-02-25.
  
  =head1 DESCRIPTION
  
  This role is for class that wants to support color themes. Color theme is
  represented as a structure according to the specification described in
  L<Color::Theme>.
  
  B<Color theme module.> Color themes are put in modules under
  C<Color::Theme::Themes::> (configurable using C<color_theme_module_prefix>
  attribute). Each color theme modules can contain one or more color themes. The
  module must define a package global variable named C<%color_themes> that contain
  color themes keyed by their names. Example:
  
   package MyProject::ColorThemes::Default;
  
   our %color_themes = (
       no_color => {
           v => 1.1,
           summary => 'Special theme that means no color',
           colors => {
           },
           no_color => 1,
       },
  
       default => {
           v => 1.1,
           summary => 'Default color theme',
           colors => {
           },
       },
   );
  
  =head1 ATTRIBUTES
  
  =head2 color_theme => HASH
  
  Get/set color theme.
  
  =head2 color_theme_args => HASH
  
  Get/set arguments for color theme. This can be
  
  =head2 color_theme_module_prefix => STR (default: CLASS + C<::ColorTheme::>)
  
  Each project should have its own class prefix. For example, L<Text::ANSITable>
  has its color themes in C<Text::ANSITable::ColorTheme::> namespace,
  L<Data::Dump::Color> has them in C<Data::Dump::Color::ColorTheme::> and so on.
  
  =head1 METHODS
  
  =head2 $cl->list_color_themes($detail) => array
  
  Will search packages under C<color_theme_module_prefix> for color theme modules,
  then list all color themes for each module. If, for example, the color theme
  modules found are C<MyProject::ColorTheme::Default> and
  C<MyProject::ColorTheme::Extras>, will return something like:
  
   ['Default::theme1', 'Default::theme2', 'Extras::extra3', 'Extras::extra4']
  
  =head2 $cl->get_color_theme($name) => hash
  
  Get color theme hash data structure by name. Note that name must be prefixed by
  color theme module name (minus the C<color_theme_module_prefix>).
  
  =head2 $cl->get_theme_color($item_name) => str
  
  Get an item's color value from the current color theme (will get from the color
  theme's C<colors> hash, then the C<$item_name> key from that hash). If color
  value is a coderef, it will be
  
  =head2 $cl->get_theme_color_as_rgb($item_name, \%args) => str|hash
  
  Like C<get_theme_color>, but if the resulting color value is a coderef, will
  call that coderef, passing C<%args> to it and returning the value.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Color-Theme-Role>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Color-Theme-Role>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Color-Theme-Role>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Color::Theme>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
COLOR_THEME_ROLE

$fatpacked{"Color/Theme/Role/ANSI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COLOR_THEME_ROLE_ANSI';
  package Color::Theme::Role::ANSI;
  
  our $DATE = '2018-02-25'; # DATE
  our $VERSION = '0.020'; # VERSION
  
  use 5.010001;
  use Moo::Role;
  
  use Color::ANSI::Util ();
  with 'Color::Theme::Role';
  with 'Term::App::Role::Attrs';
  
  sub theme_color_to_ansi {
      my ($self, $c, $args, $is_bg) = @_;
  
      # empty? skip
      return '' if !defined($c) || !length($c);
  
      # resolve coderef color
      if (ref($c) eq 'CODE') {
          $args //= {};
          $c = $c->($self, %$args);
      }
  
      my $coldepth = $self->color_depth;
  
      if ($coldepth >= 2**24) {
          if (ref $c) {
              my $ansifg = $c->{ansi_fg};
              $ansifg //= Color::ANSI::Util::ansi24bfg($c->{fg})
                  if defined $c->{fg};
              $ansifg //= "";
              my $ansibg = $c->{ansi_bg};
              $ansibg //= Color::ANSI::Util::ansi24bbg($c->{bg})
                  if defined $c->{bg};
              $ansibg //= "";
              $c = $ansifg . $ansibg;
          } else {
              $c = $is_bg ? Color::ANSI::Util::ansi24bbg($c) :
                  Color::ANSI::Util::ansi24bfg($c);
          }
      } elsif ($coldepth >= 256) {
          if (ref $c) {
              my $ansifg = $c->{ansi_fg};
              $ansifg //= Color::ANSI::Util::ansi256fg($c->{fg})
                  if defined $c->{fg};
              $ansifg //= "";
              my $ansibg = $c->{ansi_bg};
              $ansibg //= Color::ANSI::Util::ansi256bg($c->{bg})
                  if defined $c->{bg};
              $ansibg //= "";
              $c = $ansifg . $ansibg;
          } else {
              $c = $is_bg ? Color::ANSI::Util::ansi256bg($c) :
                  Color::ANSI::Util::ansi256fg($c);
          }
      } else {
          if (ref $c) {
              my $ansifg = $c->{ansi_fg};
              $ansifg //= Color::ANSI::Util::ansi16fg($c->{fg})
                  if defined $c->{fg};
              $ansifg //= "";
              my $ansibg = $c->{ansi_bg};
              $ansibg //= Color::ANSI::Util::ansi16bg($c->{bg})
                  if defined $c->{bg};
              $ansibg //= "";
              $c = $ansifg . $ansibg;
          } else {
              $c = $is_bg ? Color::ANSI::Util::ansi16bg($c) :
                  Color::ANSI::Util::ansi16fg($c);
          }
      }
      $c;
  }
  
  sub get_theme_color_as_ansi {
      my ($self, $item_name, $args) = @_;
      $self->theme_color_to_ansi(
          $self->get_theme_color($item_name),
          {name=>$item_name, %{ $args // {} }},
          $item_name =~ /_bg$/,
      );
  }
  
  1;
  # ABSTRACT: Role for class wanting to support color themes (ANSI support)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Color::Theme::Role::ANSI - Role for class wanting to support color themes (ANSI support)
  
  =head1 VERSION
  
  This document describes version 0.020 of Color::Theme::Role::ANSI (from Perl distribution Color-Theme-Role), released on 2018-02-25.
  
  =head1 DESCRIPTION
  
  This role consumes L<Color::Theme::Role> and L<Term::App::Role::Attrs>.
  
  =head1 METHODS
  
  =head2 $cl->theme_color_to_ansi($color) => str
  
  =head2 $cl->get_theme_color_as_ansi($item_name, \%args) => str
  
  Like C<get_theme_color>, but if the resulting color value is a coderef, will
  call that coderef, passing C<%args> to it and returning the value. Also, will
  convert color theme to ANSI color escape codes.
  
  When converting to ANSI code, will consult C<color_depth> from
  L<Term::App::Role::Attr>.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Color-Theme-Role>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Color-Theme-Role>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Color-Theme-Role>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
COLOR_THEME_ROLE_ANSI

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.14';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Log/ger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER';
  package Log::ger;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  our $re_addr = qr/\(0x([0-9a-f]+)/o;
  
  our %Levels = (
      fatal   => 10,
      error   => 20,
      warn    => 30,
      info    => 40,
      debug   => 50,
      trace   => 60,
  );
  
  our %Level_Aliases = (
      off     => 0,
      warning => 30,
  );
  
  our $Current_Level = 30;
  
  our $Caller_Depth_Offset = 0;
  
  # a flag that can be used by null output to skip using formatter
  our $_logger_is_null;
  
  our $_dumper;
  
  our %Global_Hooks;
  
  # in Log/ger/Heavy.pm
  # our %Default_Hooks = (
  
  our %Package_Targets; # key = package name, value = \%init_args
  our %Per_Package_Hooks; # key = package name, value = { phase => hooks, ... }
  
  our %Hash_Targets; # key = hash address, value = [$hashref, \%init_args]
  our %Per_Hash_Hooks; # key = hash address, value = { phase => hooks, ... }
  
  our %Object_Targets; # key = object address, value = [$obj, \%init_args]
  our %Per_Object_Hooks; # key = object address, value = { phase => hooks, ... }
  
  my $sub0 = sub {0};
  my $sub1 = sub {1};
  my $default_null_routines;
  
  sub install_routines {
      my ($target, $target_arg, $routines) = @_;
  
      if ($target eq 'package') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              #print "D:installing $name to package $target_arg\n";
              *{"$target_arg\::$name"} = $code;
          }
      } elsif ($target eq 'object') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          my $pkg = ref $target_arg;
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_method\z/;
              *{"$pkg\::$name"} = $code;
          }
      } elsif ($target eq 'hash') {
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              $target_arg->{$name} = $code;
          }
      }
  }
  
  sub add_target {
      my ($target, $target_arg, $args, $replace) = @_;
      $replace = 1 unless defined $replace;
  
      if ($target eq 'package') {
          unless ($replace) { return if $Package_Targets{$target_arg} }
          $Package_Targets{$target_arg} = $args;
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Object_Targets{$addr} }
          $Object_Targets{$addr} = [$target_arg, $args];
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Hash_Targets{$addr} }
          $Hash_Targets{$addr} = [$target_arg, $args];
      }
  }
  
  sub _set_default_null_routines {
      $default_null_routines ||= [
          (map {(
              [$sub0, "log_$_", $Levels{$_}, 'log_sub'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "log_is_$_", $Levels{$_}, 'is_sub'],
              [$sub0, $_, $Levels{$_}, 'log_method'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "is_$_", $Levels{$_}, 'is_method'],
          )} keys %Levels),
      ];
  }
  
  sub get_logger {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      my $obj = []; $obj =~ $re_addr;
      my $pkg = "Log::ger::Obj$1"; bless $obj, $pkg;
      add_target(object => $obj, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(object => $obj, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(object => $obj, $default_null_routines);
      }
      $obj; # XXX add DESTROY to remove from list of targets
  }
  
  sub import {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      add_target(package => $caller, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(package => $caller, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(package => $caller, $default_null_routines);
      }
  }
  
  1;
  # ABSTRACT: A lightweight, flexible logging framework
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger - A lightweight, flexible logging framework
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  In your module (producer):
  
   package Foo;
   use Log::ger; # will import some logging methods e.g. log_warn, log_error
  
   sub foo {
       ...
       # produce some logs
       log_error "an error occurred: %03d - %s", $errcode, $errmsg;
       ...
       log_debug "http response: %s", $http; # automatic dumping of data
   }
   1;
  
  In your application (consumer/listener):
  
   use Foo;
   use Log::ger::Output 'Screen';
  
   foo();
  
  =head1 DESCRIPTION
  
  Log::ger is yet another logging framework with the following features:
  
  =over
  
  =item * Separation of producers and consumers/listeners
  
  Like L<Log::Any>, this offers a very easy way for modules to produce some logs
  without having to configure anything. Configuring output, level, etc can be done
  in the application as log consumers/listeners. To read more about this, see the
  documentation of L<Log::Any> or L<Log::ger::Manual> (but nevertheless see
  L<Log::ger::Manual> on why you might prefer Log::ger to Log::Any).
  
  =item * Lightweight and fast
  
  B<Slim distribution.> No non-core dependencies, extra functionalities are
  provided in separate distributions to be pulled as needed.
  
  B<Low startup overhead.> Only ~0.5-1ms. For comparison, L<strict> ~0.2-0.5ms,
  L<warnings> ~2ms, L<Log::Any> 0.15 ~2-3ms, Log::Any 1.049 ~8-10ms,
  L<Log::Log4perl> ~35ms. This is measured on a 2014-2015 PC and before doing any
  output configuration. For more benchmarks, see L<Bencher::Scenarios::LogGer> or
  try yourself e.g. with L<bencher-code>:
  
   % bencher-code 'use Log::ger' 'use Log::Any' --startup
  
  B<Fast>. Low null-/stealth-logging overhead, about 1.5x faster than Log::Any, 3x
  faster than Log4perl, and 5x faster than L<Log::Fast>.
  
  B<Conditional compilation.> There is a plugin to optimize away unneeded logging
  statements, like assertion/conditional compilation, so they have zero runtime
  performance cost. See L<Log::ger::Plugin::OptAway>.
  
  Being lightweight means the module can be used more universally, from CLI to
  long-running daemons to inside routines with tight loops.
  
  =item * Flexible
  
  B<Customizable levels and routine/method names.> Can be used in a procedural or
  OO style. Log::ger can mimic the interface of L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, or some other popular logging frameworks, to ease migration or
  adjust with your personal style.
  
  B<Per-package settings.> Each importer package can use its own format/layout,
  output. For example, some modules that are migrated from Log::Any uses
  Log::Any-style logging, while another uses native Log::ger style, and yet some
  other uses block formatting like Log::Contextual. This eases code migration and
  teamwork. Each module author can preserve her own logging style, if wanted, and
  all the modules still use the same framework.
  
  B<Dynamic.> Outputs and levels can be changed anytime during run-time and
  logging routines will be updated automatically. This is useful in situation like
  a long-running server application: you can turn on tracing logs temporarily to
  debug problems, then turn them off again, without restarting your server.
  
  B<Interoperability.> There are modules to interop with Log::Any, either consume
  Log::Any logs (see L<Log::Any::Adapter::LogGer>) or produce logs to be consumed
  by Log::Any (see L<Log::ger::Output::LogAny>).
  
  B<Many output modules and plugins.> See C<Log::ger::Output::*>,
  C<Log::ger::Format::*>, C<Log::ger::Layout::*>, C<Log::ger::Plugin::*>. Writing
  an output module in Log::ger is easier than writing a Log::Any::Adapter::*.
  
  =back
  
  For more documentation, start with L<Log::ger::Manual>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  Some other popular logging frameworks: L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, L<Log::Dispatch>, L<Log::Dispatchouli>.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER

$fatpacked{"Log/ger/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT';
  package Log::ger::Format;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  sub _import_sets_for_current_package { 1 }
  
  1;
  # ABSTRACT: Use a format plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format - Use a format plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set for current package only:
  
   use Log::ger::Format 'Block';
  
  or:
  
   use Log::ger::Format;
   Log::ger::Format->set_for_current_package('Block');
  
  To set globally:
  
   use Log::ger::Format;
   Log::ger::Format->set('Block');
  
  =head1 DESCRIPTION
  
  Note: Since format plugins affect log-producing code, the import syntax defaults
  to setting for current package instead of globally.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT

$fatpacked{"Log/ger/Format/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT_NONE';
  package Log::ger::Format::None;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_formatter => [
              __PACKAGE__, 50,
              sub {
                  [sub {shift}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Perform no formatting on the message
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format::None - Perform no formatting on the message
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Format 'None';
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT_NONE

$fatpacked{"Log/ger/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_HEAVY';
  package Log::ger::Heavy;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  package
      Log::ger;
  
  #IFUNBUILT
  # use vars qw(
  #                $re_addr
  #                %Levels
  #                %Level_Aliases
  #                $Current_Level
  #                $Caller_Depth_Offset
  #                $_logger_is_null
  #                $_dumper
  #                %Global_Hooks
  #                %Package_Targets
  #                %Per_Package_Hooks
  #                %Hash_Targets
  #                %Per_Hash_Hooks
  #                %Object_Targets
  #                %Per_Object_Hooks
  #        );
  #END IFUNBUILT
  
  # key = phase, value = [ [key, prio, coderef], ... ]
  our %Default_Hooks = (
      create_formatter => [
          [__PACKAGE__, 90,
           # the default formatter is sprintf-style that dumps data structures
           # arguments as well as undef as '<undef>'.
           sub {
               my %args = @_;
  
               my $formatter = sub {
                   return $_[0] if @_ < 2;
                   my $fmt = shift;
                   my @args;
                   for (@_) {
                       if (!defined($_)) {
                           push @args, '<undef>';
                       } elsif (ref $_) {
                           require Log::ger::Util unless $_dumper;
                           push @args, Log::ger::Util::_dump($_);
                       } else {
                           push @args, $_;
                       }
                   }
                   sprintf $fmt, @args;
               };
               [$formatter];
           }],
      ],
  
      create_layouter => [],
  
      create_routine_names => [
          [__PACKAGE__, 90,
           # the default names are log_LEVEL() and log_is_LEVEL() for subroutine
           # names, or LEVEL() and is_LEVEL() for method names
           sub {
               my %args = @_;
  
               my $levels = [keys %Levels];
  
               return [{
                   log_subs    => [map { ["log_$_", $_]    } @$levels],
                   is_subs     => [map { ["log_is_$_", $_] } @$levels],
                   # used when installing to hash or object
                   log_methods => [map { ["$_", $_]        } @$levels],
                   is_methods  => [map { ["is_$_", $_]     } @$levels],
               }, 1];
           }],
      ],
  
      create_log_routine => [
          [__PACKAGE__, 10,
           # the default behavior is to create a null routine for levels that are
           # too high than the global level ($Current_Level). since we run at high
           # priority (10), this block typical output plugins at normal priority
           # (50). this is a convenience so normally a plugin does not have to
           # deal with level checking.
           sub {
               my %args = @_;
               my $level = $args{level};
               if (defined($level) && (
                   $Current_Level < $level ||
                       # there's only us
                       @{ $Global_Hooks{create_log_routine} } == 1)
               ) {
                   $_logger_is_null = 1;
                   return [sub {0}];
               }
               [undef]; # decline
           }],
      ],
  
      create_logml_routine => [],
  
      create_is_routine => [
          [__PACKAGE__, 90,
           # the default behavior is to compare to global level. normally this
           # behavior suffices. we run at low priority (90) so normal plugins
           # which typically use priority 50 can override us.
           sub {
               my %args = @_;
               my $level = $args{level};
               [sub { $Current_Level >= $level }];
           }],
      ],
  
      before_install_routines => [],
  
      after_install_routines => [],
  );
  
  for my $phase (keys %Default_Hooks) {
      $Global_Hooks{$phase} = [@{ $Default_Hooks{$phase} }];
  }
  
  # if flow_control is 1, stops after the first hook that gives non-undef result.
  # flow_control can also be a coderef that will be called after each hook with
  # ($hook, $hook_res) and can return 1 to mean stop.
  sub run_hooks {
      my ($phase, $hook_args, $flow_control,
          $target, $target_arg) = @_;
      #print "D: running hooks for phase $phase\n";
  
      $Global_Hooks{$phase} or die "Unknown phase '$phase'";
      my @hooks = @{ $Global_Hooks{$phase} };
  
      if ($target eq 'package') {
          unshift @hooks, @{ $Per_Package_Hooks{$target_arg}{$phase} || [] };
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Hash_Hooks{$addr}{$phase} || [] };
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Object_Hooks{$addr}{$phase} || [] };
      }
  
      my $res;
      for my $hook (sort {$a->[1] <=> $b->[1]} @hooks)  {
          my $hook_res = $hook->[2]->(%$hook_args);
          if (defined $hook_res->[0]) {
              $res = $hook_res->[0];
              #print "D:   got result from hook $res\n";
              if (ref $flow_control eq 'CODE') {
                  last if $flow_control->($hook, $hook_res);
              } else {
                  last if $flow_control;
              }
          }
          last if $hook_res->[1];
      }
      return $res;
  }
  
  sub init_target {
      my ($target, $target_arg, $init_args) = @_;
  
      #print "D:init_target($target, $target_arg, ...)\n";
      my %hook_args = (
          target     => $target,
          target_arg => $target_arg,
          init_args  => $init_args,
      );
  
      my %formatters;
      run_hooks(
          'create_formatter', \%hook_args,
          # collect formatters, until a hook instructs to stop
          sub {
              my ($hook, $hook_res) = @_;
              my ($formatter, $flow_control, $fmtname) = @$hook_res;
              $fmtname = 'default' if !defined($fmtname);
              $formatters{$fmtname} ||= $formatter;
              $flow_control;
          },
          $target, $target_arg);
  
      my $layouter =
          run_hooks('create_layouter', \%hook_args, 1, $target, $target_arg);
  
      my $routine_names = {};
      run_hooks(
          'create_routine_names', \%hook_args,
          # collect routine names, until a hook instructs to stop.
          sub {
              my ($hook, $hook_res) = @_;
              my ($rn, $flow_control) = @$hook_res;
              $rn or return;
              for (keys %$rn) {
                  push @{ $routine_names->{$_} }, @{ $rn->{$_} };
              }
              $flow_control;
          },
          $target, $target_arg);
  
      my @routines;
      my $object = $target eq 'object';
  
    CREATE_LOG_ROUTINES:
      {
          my @rn;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{log_subs} || [] };
              push @rn, @{ $routine_names->{logml_subs} || [] };
          } else {
              push @rn, @{ $routine_names->{log_methods} || [] };
              push @rn, @{ $routine_names->{logml_methods} || [] };
          }
          my $mllogger0;
          for my $rn (@rn) {
              my ($rname, $lname, $fmtname) = @$rn;
              my $lnum; $lnum = $Levels{$lname} if defined $lname;
              my $routine_name_is_ml = !defined($lname);
              $fmtname = 'default' if !defined($fmtname);
  
              my $logger;
              my ($logger0, $logger0_is_ml);
              $_logger_is_null = 0;
              for my $phase (qw/create_logml_routine create_log_routine/) {
                  local $hook_args{name} = $rname;
                  local $hook_args{level} = $lnum;
                  local $hook_args{str_level} = $lname;
                  $logger0_is_ml = $phase eq 'create_logml_routine';
                  if ($mllogger0) {
                      # we reuse the same multilevel logger0 for all log routines,
                      # since it can handle different levels
                      $logger0 = $mllogger0;
                      last;
                  }
                  $logger0 = run_hooks(
                      $phase, \%hook_args, 1, $target, $target_arg)
                      or next;
                  if ($logger0_is_ml) {
                      $mllogger0 = $logger0;
                  }
                  last;
              }
              # this can happen if there is no create_logml_routine hook but
              # routine name is a logml routine
              unless ($logger0) {
                  $_logger_is_null = 1;
                  $logger0 = sub {0};
              }
  
              require Log::ger::Util if !$logger0_is_ml && $routine_name_is_ml;
  
              {
                  if ($_logger_is_null) {
                      # if logger is a null logger (sub {0}) we don't need to
                      # format message, layout message, or care about the logger
                      # being a subroutine/object
                      $logger = $logger0;
                      last;
                  }
  
                  my $formatter = $formatters{$fmtname}
                      or die "Formatter named '$fmtname' not available";
                  if ($formatter) {
                      if ($layouter) {
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          }
                      } else { # no layouter
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              }
                          }
                      }
                  } else { # no formatter
                      { # no layouter, just to align
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) }; }
                              } else { # routine name not multiple-lvl
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,                          @_                             ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) }; }
                              } else {
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                                 @_                             ) }; }
                              }
                          }
                      }
                  }
              }
            L1:
              my $type = $routine_name_is_ml ?
                  ($object ? 'logml_method' : 'logml_sub') :
                  ($object ? 'log_method' : 'log_sub');
              push @routines, [$logger, $rname, $lnum, $type];
          }
      }
    CREATE_IS_ROUTINES:
      {
          my @rn;
          my $type;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{is_subs} || [] };
              $type = 'is_sub';
          } else {
              push @rn, @{ $routine_names->{is_methods} || [] };
              $type = 'is_method';
          }
          for my $rn (@rn) {
              my ($rname, $lname) = @$rn;
              my $lnum = $Levels{$lname};
  
              local $hook_args{name} = $rname;
              local $hook_args{level} = $lnum;
              local $hook_args{str_level} = $lname;
  
              my $code_is =
                  run_hooks('create_is_routine', \%hook_args, 1,
                            $target, $target_arg);
              next unless $code_is;
              push @routines, [$code_is, $rname, $lnum, $type];
          }
      }
  
      {
          local $hook_args{routines} = \@routines;
          local $hook_args{formatters} = \%formatters;
          local $hook_args{layouter} = $layouter;
          run_hooks('before_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  
      install_routines($target, $target_arg, \@routines);
  
      {
          local $hook_args{routines} = \@routines;
          run_hooks('after_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  }
  
  1;
  # ABSTRACT: The bulk of the implementation of Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Heavy - The bulk of the implementation of Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This module contains the bulk of the implementation of Log::ger, to keep
  Log::ger superslim.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_HEAVY

$fatpacked{"Log/ger/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_LAYOUT';
  package Log::ger::Layout;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Layout::/ }
  
  1;
  # ABSTRACT: Use a layout plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Layout - Use a layout plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Layout;
   Log::ger::Layout->set('Pattern');
  
  or:
  
   use Log::ger::Layout 'Pattern';
  
  To set for current package only:
  
   use Log::ger::Layout;
   Log::ger::Layout->set_for_current_package('Pattern');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  L<Log::ger::Format>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_LAYOUT

$fatpacked{"Log/ger/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT';
  package Log::ger::Output;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent 'Log::ger::Plugin';
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Output::/ }
  
  1;
  # ABSTRACT: Set logging output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output - Set logging output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Output;
   Log::ger::Output->set(Screen => (
       use_color => 1,
       ...
   );
  
  or:
  
   use Log::ger::Output 'Screen', (
       use_color=>1,
       ...
   );
  
  To set for current package only:
  
   use Log::ger::Output;
   Log::ger::Output->set_for_current_package(Screen => (
       use_color => 1,
       ...
   );
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT

$fatpacked{"Log/ger/Output/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAY';
  package Log::ger::Output::Array;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
  
                  my $logger = sub {
                      my ($ctx, $msg) = @_;
                      push @{$conf{array}}, $msg;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Array - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output Array => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAY

$fatpacked{"Log/ger/Output/ArrayML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAYML';
  package Log::ger::Output::ArrayML;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_logml_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $logger = sub {
                      my $level = Log::ger::Util::numeric_level($_[1]);
                      return if $level > $Log::ger::Current_Level;
                      push @{$conf{array}}, $_[2];
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::ArrayML - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output ArrayML => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  This output is just like L<Log::ger::Output::Array> except that it provides a
  C<create_logml_routine> hook instead of C<create_log_routine>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAYML

$fatpacked{"Log/ger/Output/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_NULL';
  package Log::ger::Output::Null;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  $Log::ger::_logger_is_null = 1;
                  [sub {0}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Null output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Null - Null output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger;
   use Log::ger::Output 'Null';
  
   log_warn "blah...";
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_NULL

$fatpacked{"Log/ger/Output/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_STRING';
  package Log::ger::Output::String;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{string} or die "Please specify string";
  
      my $formatter = $conf{formatter};
      my $append_newline = $conf{append_newline};
      $append_newline = 1 unless defined $append_newline;
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $level = $args{level};
                  my $logger = sub {
                      my $msg = $_[1];
                      if ($formatter) {
                          $msg = $formatter->($msg);
                      }
                      ${ $conf{string} } .= $msg;
                      ${ $conf{string} } .= "\n"
                          unless !$append_newline || $msg =~ /\R\z/;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Set output to a string
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::String - Set output to a string
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use var '$str';
   use Log::ger::Output 'String' => (
       string => \$str,
       # append_newline => 0, # default is true, to mimic Log::ger::Output::Screen
   );
   use Log::ger;
  
   log_warn "warn ...";
   log_error "debug ...";
  
  C<$str> will contain "warn ...\n".
  
  =head1 DESCRIPTION
  
  For testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 string => scalarref
  
  Required.
  
  =head2 formatter => coderef
  
  Optional.
  
  =head2 append_newline => bool (default: 1)
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_STRING

$fatpacked{"Log/ger/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN';
  package Log::ger::Plugin;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub set {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      $args{prefix} ||= $pkg . '::';
      $args{replace_package_regex} = $pkg->_replace_package_regex;
      Log::ger::Util::set_plugin(%args);
  }
  
  sub set_for_current_package {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      my $caller = caller(0);
      $args{target} = 'package';
      $args{target_arg} = $caller;
  
      set($pkg, \%args);
  }
  
  sub _import_sets_for_current_package { 0 }
  
  sub _replace_package_regex { undef }
  
  sub import {
      if (@_ > 1) {
          if ($_[0]->_import_sets_for_current_package) {
              goto &set_for_current_package;
          } else {
              goto &set;
          }
      }
  }
  
  1;
  # ABSTRACT: Use a plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin - Use a plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set('OptAway');
  
  or:
  
   use Log::ger::Plugin 'OptAway';
  
  To set for current package only:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set_for_current_package('OptAway');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN

$fatpacked{"Log/ger/Plugin/MultilevelLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN_MULTILEVELLOG';
  package Log::ger::Plugin::MultilevelLog;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      return {
          create_routine_names => [
              __PACKAGE__, 50,
              sub {
                  return [{
                      logml_subs    => [[$conf{sub_name}    || 'log', undef]],
                      logml_methods => [[$conf{method_name} || 'log', undef]],
                  }];
              },
          ],
      };
  }
  
  1;
  # ABSTRACT: Create a log($LEVEL, ...) subroutine/method
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin::MultilevelLog - Create a log($LEVEL, ...) subroutine/method
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Plugin MultilevelLog => (
       sub_name => 'log',    # optional
       method_name => 'log', # optional
   );
   use Log::ger;
  
  =head1 DESCRIPTION
  
  The default way is to create separate C<log_LEVEL> subroutine (or C<LEVEL>
  methods) for each level, e.g. C<log_trace> subroutine (or C<trace> method),
  C<log_warn> (or C<warn>), and so on. But sometimes you might want a log routine
  that takes $level as the first argument, e.g. instead of:
  
   log_warn('blah ...');
  
  or:
  
   $log->debug('Blah: %s', $data);
  
  you prefer:
  
   log('warn', 'blah ...');
  
  or:
  
   $log->log('debug', 'Blah: %s', $data);
  
  This plugin can create such log routine for you.
  
  Note: the multilevel log is slower because of extra argument and additional
  string level -> numeric level conversion.
  
  Note: the individual separate C<log_LEVEL> subroutines (or C<LEVEL> methods) are
  still installed.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 sub_name => str (default: "log")
  
  =head2 method_name => str (default: "log")
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN_MULTILEVELLOG

$fatpacked{"Log/ger/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_UTIL';
  package Log::ger::Util;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  require Log::ger;
  require Log::ger::Heavy;
  
  sub _dump {
      unless ($Log::ger::_dumper) {
          eval {
              no warnings 'once';
              require Data::Dmp;
              $Data::Dmp::OPT_REMOVE_PRAGMAS = 1;
              1;
          };
          if ($@) {
              no warnings 'once';
              require Data::Dumper;
              $Log::ger::_dumper = sub {
                  local $Data::Dumper::Terse = 1;
                  local $Data::Dumper::Indent = 0;
                  local $Data::Dumper::Useqq = 1;
                  local $Data::Dumper::Deparse = 1;
                  local $Data::Dumper::Quotekeys = 0;
                  local $Data::Dumper::Sortkeys = 1;
                  local $Data::Dumper::Trailingcomma = 1;
                  Data::Dumper::Dumper($_[0]);
              };
          } else {
              $Log::ger::_dumper = sub { Data::Dmp::dmp($_[0]) };
          }
      }
      $Log::ger::_dumper->($_[0]);
  }
  
  sub numeric_level {
      my $level = shift;
      return $level if $level =~ /\A\d+\z/;
      return $Log::ger::Levels{$level}
          if defined $Log::ger::Levels{$level};
      return $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      die "Unknown level '$level'";
  }
  
  sub string_level {
      my $level = shift;
      return $level if defined $Log::ger::Levels{$level};
      $level = $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      for (keys %Log::ger::Levels) {
          my $v = $Log::ger::Levels{$_};
          return $_ if $v == $level;
      }
      die "Unknown level '$level'";
  }
  
  sub set_level {
      no warnings 'once';
      $Log::ger::Current_Level = numeric_level(shift);
      reinit_all_targets();
  }
  
  sub _action_on_hooks {
      no warnings 'once';
  
      my ($action, $target, $target_arg, $phase) = splice @_, 0, 4;
  
      my $hooks = $Log::ger::Global_Hooks{$phase} or die "Unknown phase '$phase'";
      if ($target eq 'package') {
          $hooks = ($Log::ger::Per_Package_Hooks{$target_arg}{$phase} ||= []);
      } elsif ($target eq 'object') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Object_Hooks{$addr}{$phase} ||= []);
      } elsif ($target eq 'hash') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Hash_Hooks{$addr}{$phase} ||= []);
      }
  
      if ($action eq 'add') {
          my $hook = shift;
          # XXX remove duplicate key
          # my $key = $hook->[0];
          unshift @$hooks, $hook;
      } elsif ($action eq 'remove') {
          my $code = shift;
          for my $i (reverse 0..$#{$hooks}) {
              splice @$hooks, $i, 1 if $code->($hooks->[$i]);
          }
      } elsif ($action eq 'reset') {
          my $saved = [@$hooks];
          splice @$hooks, 0, scalar(@$hooks),
              @{ $Log::ger::Default_Hooks{$phase} };
          return $saved;
      } elsif ($action eq 'empty') {
          my $saved = [@$hooks];
          splice @$hooks, 0;
          return $saved;
      } elsif ($action eq 'save') {
          return [@$hooks];
      } elsif ($action eq 'restore') {
          my $saved = shift;
          splice @$hooks, 0, scalar(@$hooks), @$saved;
          return $saved;
      }
  }
  
  sub add_hook {
      my ($phase, $hook) = @_;
      _action_on_hooks('add', '', undef, $phase, $hook);
  }
  
  sub add_per_target_hook {
      my ($target, $target_arg, $phase, $hook) = @_;
      _action_on_hooks('add', $target, $target_arg, $phase, $hook);
  }
  
  sub remove_hook {
      my ($phase, $code) = @_;
      _action_on_hooks('remove', '', undef, $phase, $code);
  }
  
  sub remove_per_target_hook {
      my ($target, $target_arg, $phase, $code) = @_;
      _action_on_hooks('remove', $target, $target_arg, $phase, $code);
  }
  
  sub reset_hooks {
      my ($phase) = @_;
      _action_on_hooks('reset', '', undef, $phase);
  }
  
  sub reset_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('reset', $target, $target_arg, $phase);
  }
  
  sub empty_hooks {
      my ($phase) = @_;
      _action_on_hooks('empty', '', undef, $phase);
  }
  
  sub empty_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('empty', $target, $target_arg, $phase);
  }
  
  sub save_hooks {
      my ($phase) = @_;
      _action_on_hooks('save', '', undef, $phase);
  }
  
  sub save_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('save', $target, $target_arg, $phase);
  }
  
  sub restore_hooks {
      my ($phase, $saved) = @_;
      _action_on_hooks('restore', '', undef, $phase, $saved);
  }
  
  sub restore_per_target_hooks {
      my ($target, $target_arg, $phase, $saved) = @_;
      _action_on_hooks('restore', $target, $target_arg, $phase, $saved);
  }
  
  sub reinit_target {
      my ($target, $target_arg) = @_;
  
      # adds target if not already exists
      Log::ger::add_target($target, $target_arg, {}, 0);
  
      if ($target eq 'package') {
          my $init_args = $Log::ger::Package_Targets{$target_arg};
          Log::ger::init_target(package => $target_arg, $init_args);
      } elsif ($target eq 'object') {
          my ($obj_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid object '$target_arg': not a reference";
          my $v = $Log::ger::Object_Targets{$obj_addr}
              or die "Unknown object target '$target_arg'";
          Log::ger::init_target(object => $v->[0], $v->[1]);
      } elsif ($target eq 'hash') {
          my ($hash_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid hashref '$target_arg': not a reference";
          my $v = $Log::ger::Hash_Targets{$hash_addr}
              or die "Unknown hash target '$target_arg'";
          Log::ger::init_target(hash => $v->[0], $v->[1]);
      } else {
          die "Unknown target '$target'";
      }
  }
  
  sub reinit_all_targets {
      for my $pkg (keys %Log::ger::Package_Targets) {
          Log::ger::init_target(
              package => $pkg, $Log::ger::Package_Targets{$pkg});
      }
      for my $k (keys %Log::ger::Object_Targets) {
          my ($obj, $init_args) = @{ $Log::ger::Object_Targets{$k} };
          Log::ger::init_target(object => $obj, $init_args);
      }
      for my $k (keys %Log::ger::Hash_Targets) {
          my ($hash, $init_args) = @{ $Log::ger::Hash_Targets{$k} };
          Log::ger::init_target(hash => $hash, $init_args);
      }
  }
  
  sub set_plugin {
      my %args = @_;
  
      my $hooks;
      if ($args{hooks}) {
          $hooks = $args{hooks};
      } else {
          no strict 'refs';
          my $prefix = $args{prefix} || 'Log::ger::Plugin::';
          my $mod = $args{name};
          $mod = $prefix . $mod unless index($mod, $prefix) == 0;
          (my $mod_pm = "$mod.pm") =~ s!::!/!g;
          require $mod_pm;
          $hooks = &{"$mod\::get_hooks"}(%{ $args{conf} || {} });
      }
  
      {
          last unless $args{replace_package_regex};
          my $all_hooks;
          if (!$args{target}) {
              $all_hooks = \%Log::ger::Global_Hooks;
          } elsif ($args{target} eq 'package') {
              $all_hooks = $Log::ger::Per_Package_Hooks{ $args{target_arg} };
          } elsif ($args{target} eq 'object') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Object_Hooks{$addr};
          } elsif ($args{target} eq 'hash') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Hash_Hooks{$addr};
          }
          last unless $all_hooks;
          for my $phase (keys %$all_hooks) {
              my $hooks = $all_hooks->{$phase};
              for my $i (reverse 0..$#{$hooks}) {
                  splice @$hooks, $i, 1
                      if $hooks->[$i][0] =~ $args{replace_package_regex};
              }
          }
      }
  
      for my $phase (keys %$hooks) {
          my $hook = $hooks->{$phase};
          if (defined $args{target}) {
              add_per_target_hook(
                  $args{target}, $args{target_arg}, $phase, $hook);
          } else {
              add_hook($phase, $hook);
          }
      }
  
      my $reinit = $args{reinit};
      $reinit = 1 unless defined $reinit;
      if ($reinit) {
          if (defined $args{target}) {
              reinit_target($args{target}, $args{target_arg});
          } else {
              reinit_all_targets();
          }
      }
  }
  
  1;
  # ABSTRACT: Utility routines for Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Util - Utility routines for Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This package is created to keep Log::ger as minimalist as possible.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_UTIL

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use Moo::_strictures;
  use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);
  use Scalar::Util 'blessed';
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Moo::_Utils) }
  BEGIN {
    *_CAN_WEAKEN_READONLY = (
      "$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583}
    ) ? sub(){0} : sub(){1};
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  BEGIN {
    package
      Method::Generate::Accessor::_Generated;
    $Carp::Internal{+__PACKAGE__} = 1;
  }
  
  my $module_name_only = qr/\A$Module::Runtime::module_name_rx\z/;
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    croak "You cannot overwrite a locally defined method ($method) with "
      . ( $type || 'an accessor' );
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $quote_opts = {
      no_defer => 1,
      package => 'Method::Generate::Accessor::_Generated',
      %{ $quote_opts||{} },
    };
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    croak "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      croak "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      croak "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ $module_name_only;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
    if (($spec->{coerce}||0) eq 1) {
      my $isa = $spec->{isa};
      if (blessed $isa and $isa->can('coercion')) {
        $spec->{coerce} = $isa->coercion;
      } elsif (blessed $isa and $isa->can('coerce')) {
        $spec->{coerce} = sub { $isa->coerce(@_) };
      } else {
        croak "Invalid coercion for $into->$name - no appropriate type constraint";
      }
    }
  
    foreach my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name",
          'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      foreach my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$pred} =
          quote_sub "${into}::${pred}"
            => $self->_generate_simple_has('$_[0]', $name, $spec)."\n"
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $builder = delete $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $builder );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
      $self->{captures} = {};
      $methods{$cl} =
        quote_sub "${into}::${cl}"
          => $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
          => delete $self->{captures}
          => $quote_opts
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          require Moo::Role;
          _load_module $hspec;
          map [ $_ => $_ ], Moo::Role->methods_provided_by($hspec)
        } else {
          croak "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}"
            => $self->_generate_delegation($asserter, $target, \@args)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      _die_overwrite($into, $asserter, 'an asserter')
        if !$spec->{allow_overwrite} && defined &{"${into}::${asserter}"};
      local $self->{captures} = {};
      $methods{$asserter} =
        quote_sub "${into}::${asserter}"
          => $self->_generate_asserter($name, $spec)
          => delete $self->{captures}
          => $quote_opts
        ;
    }
    \%methods;
  }
  
  sub merge_specs {
    my ($self, @specs) = @_;
    my $spec = shift @specs;
    for my $old_spec (@specs) {
      foreach my $key (keys %$old_spec) {
        if ($key eq 'handles') {
        }
        elsif ($key eq 'moosify') {
          $spec->{$key} = [
            map { ref $_ eq 'ARRAY' ? @$_ : $_ }
            grep defined,
            ($old_spec->{$key}, $spec->{$key})
          ];
        }
        elsif (!exists $spec->{$key}) {
          $spec->{$key} = $old_spec->{$key};
        }
      }
    }
    $spec;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_default {
    my ($self, $name, $spec) = @_;
    $spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\quotify $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\quotify $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa} ?
         "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
    );
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : quotify $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_simple_get(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    my ($me, $source) = ('$_[0]', '$_[1]');
    if ($self->is_simple_set($name, $spec)) {
      return $self->_generate_simple_set($me, $name, $spec, $source);
    }
  
    my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
    if ($coerce) {
      $source = $self->_generate_coerce($name, $source, $coerce);
    }
    if ($isa_check) {
      'scalar do { my $value = '.$source.";\n"
      .'  ('.$self->_generate_isa_check($name, '$value', $isa_check)."),\n"
      .'  ('.$self->_generate_simple_set($me, $name, $spec, '$value')."),\n"
      .($trigger
        ? '('.$self->_generate_trigger($name, $me, '$value', $trigger)."),\n"
        : '')
      .'  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
      ."}";
    }
    elsif ($trigger) {
      my $set = $self->_generate_simple_set($me, $name, $spec, $source);
      "scalar (\n"
      . '  ('.$self->_generate_trigger($name, $me, "($set)", $trigger)."),\n"
      . '  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
      . ")";
    }
    else {
      '('.$self->_generate_simple_set($me, $name, $spec, $source).')';
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return quotify($name) if !defined($init_arg) or $init_arg eq $name;
    return quotify($name).' (constructor argument: '.quotify($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce),
      1,
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _wrap_attr_exception {
    my ($self, $name, $step, $arg, $code, $want_return) = @_;
    my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
    .'    init_arg => '.quotify($arg).",\n"
    .'    name     => '.quotify($name).",\n"
    .'    step     => '.quotify($step).",\n"
    ."  };\n"
    .($want_return ? '  (my $_return),'."\n" : '')
    .'  (my $_error), (my $_old_error = $@);'."\n"
    ."  (eval {\n"
    .'    ($@ = $_old_error),'."\n"
    .'    ('
    .($want_return ? '$_return ='."\n" : '')
    .$code."),\n"
    ."    1\n"
    ."  } or\n"
    .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n"
    .'  ($@ = $_old_error),'."\n"
    .'  (defined $_error and CORE::die $_error);'."\n"
    .($want_return ? '  $_return;'."\n" : '')
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.sanitize_identifier($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify($code, $values,
          Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.sanitize_identifier($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name { sanitize_identifier($_[1]) }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
  
    my $has_default = $self->has_eager_default($name, $spec);
    if (!($has_default || $test)) {
      return '';
    }
    if ($has_default) {
      my $get_default = $self->_generate_get_default($me, $name, $spec);
      $source =
        $test
          ? "(\n  ${test}\n"
              ."   ? ${source}\n   : "
              .$get_default
              .")"
          : $get_default;
    }
    if ($spec->{coerce}) {
      $source = $self->_generate_coerce(
        $name, $source,
        $spec->{coerce}, $init_arg
      )
    }
    if ($spec->{isa}) {
      $source = 'scalar do { my $value = '.$source.";\n"
      .'  ('.$self->_generate_isa_check(
          $name, '$value', $spec->{isa}, $init_arg
        )."),\n"
      ."  \$value\n"
      ."}\n";
    }
    my $set = $self->_generate_simple_set($me, $name, $spec, $source);
    my $trigger = $spec->{trigger} ? $self->_generate_trigger(
      $name, $me, $self->_generate_simple_get($me, $name, $spec),
      $spec->{trigger}
    ) : undef;
    if ($has_default) {
      "($set)," . ($trigger && $test ? "($test and $trigger)," : '') . "\n";
    }
    else {
      "($test and ($set)" . ($trigger ? ", ($trigger)" : '') . "),\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      # &Internals::SvREADONLY($foo, 0);
      # Scalar::Util::weaken($foo);
      # &Internals::SvREADONLY($foo, 1);
      #
      # but requires Internal functions and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = _CAN_WEAKEN_READONLY
        ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }"
        : <<"EOC"
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
    my $name_str = quotify($name);
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  ".$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
     ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using quotify
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
  
    my $error;
  
    if (blessed $value) {
      local $@;
      no warnings 'void';
      eval { \&$value; 1 }
        and return 1;
      $error = "could not be converted to a coderef: $@";
    }
    elsif (ref $value eq 'CODE') {
      return 1;
    }
    else {
      $error = 'is not a coderef or code-convertible object';
    }
  
    croak "Invalid $setting '"
      . ($INC{'overload.pm'} ? overload::StrVal($value) : $value)
      . "' for $into " . $error
      . ($appended ? " $appended" : '');
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils qw(_getglob);
  use Moo::_mro;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL"
      => join('',
        $self->_handle_subbuild($into),
        qq{    my \$self = shift;\n},
        $self->buildall_body_for($into, '$self', '@_'),
        qq{    return \$self\n},
      )
      => {}
      => { no_defer => 1 }
    ;
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{mro::get_linear_isa($into)};
    '    (('.$args.')[0]->{__no_BUILD__} or ('."\n"
    .join('', map qq{      ${me}->${_}(${args}),\n}, @builds)
    ."    )),\n";
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use Moo::_strictures;
  use Sub::Quote qw(quote_sub quotify);
  use Sub::Defer;
  use Moo::_Utils qw(_getstash _getglob);
  use Moo::_mro;
  use Scalar::Util qw(weaken);
  use Carp qw(croak);
  use Carp::Heavy ();
  BEGIN { our @CARP_NOT = qw(Sub::Defer) }
  BEGIN {
    local $Moo::sification::disabled = 1;
    require Moo;
    Moo->import;
  }
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    $self->assert_constructor;
    my $specs = $self->{attribute_specs}||={};
    my $ag = $self->accessor_generator;
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        croak "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        $ag->merge_specs($new_spec, $old_spec);
      }
      if ($new_spec->{required}
        && !(
          $ag->has_default($name, $new_spec)
          || !exists $new_spec->{init_arg}
          || defined $new_spec->{init_arg}
        )
      ) {
        croak "You cannot have a required attribute (${name})"
          . " without a default, builder, or an init_arg";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    $self->assert_constructor;
    my $package = $self->{package};
    my (undef, @isa) = @{mro::get_linear_isa($package)};
    my $isa = join ',', @isa;
    my (undef, $from_file, $from_line) = caller(Carp::short_error_loc());
    my $constructor = defer_sub "${package}::new" => sub {
      my (undef, @new_isa) = @{mro::get_linear_isa($package)};
      if (join(',', @new_isa) ne $isa) {
        my ($expected_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa;
        my ($found_new) = grep { *{_getglob($_.'::new')}{CODE} } @new_isa;
        if (($found_new||'') ne ($expected_new||'')) {
          $found_new ||= 'none';
          $expected_new ||= 'none';
          croak "Expected parent constructor of $package to be"
          . " $expected_new, but found $found_new: changing the inheritance"
          . " chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported";
        }
      }
  
      my $constructor = $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1, no_defer => 1 }
      );
      $self->{inlined} = 1;
      weaken($self->{constructor} = $constructor);
      $constructor;
    };
    $self->{inlined} = 0;
    weaken($self->{constructor} = $constructor);
    $self;
  }
  
  sub current_constructor {
    my ($self, $package) = @_;
    return *{_getglob("${package}::new")}{CODE};
  }
  
  sub assert_constructor {
    my ($self) = @_;
    my $package = $self->{package} or return 1;
    my $current = $self->current_constructor($package)
      or return 1;
    my $constructor = $self->{constructor}
      or croak "Unknown constructor for $package already exists";
    croak "Constructor for $package has been replaced with an unknown sub"
      if $constructor != $current;
    croak "Constructor for $package has been inlined and cannot be updated"
      if $self->{inlined};
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $quote_opts = {
      %{$quote_opts||{}},
      package => $into,
    };
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
  
    my $into_buildargs = $into->can('BUILDARGS');
  
    my $body
      = '    my $invoker = CORE::shift();'."\n"
      . '    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n"
      . $self->_handle_subconstructor($into, $name)
      . ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS
        ? $self->_generate_args_via_buildargs
        : $self->_generate_args
      )
      . $self->_check_required($spec)
      . '    my $new = '.$self->construction_string.";\n"
      . $self->_assign_new($spec)
      . ( $into->can('BUILD')
        ? $self->buildall_generator->buildall_body_for( $into, '$new', '$args' )
        : ''
      )
      . '    return $new;'."\n";
  
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.quotify($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg = $test{$_};
      my $arg_key = quotify($arg);
      my $test = defined $arg ? "exists \$args->{$arg_key}" : undef;
      my $source = defined $arg ? "\$args->{$arg_key}" : undef;
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $arg,
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my $s = $spec->{$_}; # ignore required if default or builder set
          $s->{required} and not($s->{builder} or exists $s->{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, '
      .join(', ', map quotify($_), @required_init).') {'."\n"
      .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n"
      ."    }\n";
  }
  
  # bootstrap our own constructor
  sub new {
    my $class = shift;
    delete _getstash(__PACKAGE__)->{new};
    bless $class->BUILDARGS(@_), $class;
  }
  Moo->_constructor_maker_for(__PACKAGE__)
  ->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'bare' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'bare' },
  );
  if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
    Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__);
  }
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils qw(_getglob);
  use Moo::_mro;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{mro::get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use Moo::_strictures;
  use Moo::_mro;
  use Moo::_Utils qw(
    _getglob
    _getstash
    _install_coderef
    _install_modifier
    _load_module
    _set_loaded
    _unimport_coderefs
  );
  use Scalar::Util qw(reftype);
  use Carp qw(croak);
  BEGIN {
    our @CARP_NOT = qw(
      Method::Generate::Constructor
      Method::Generate::Accessor
      Moo::sification
      Moo::_Utils
      Moo::Role
    );
  }
  
  our $VERSION = '2.003004';
  $VERSION =~ tr/_//d;
  
  require Moo::sification;
  Moo::sification->import;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
  
    strict->import;
    warnings->import;
  
    if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
      croak "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        croak "Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_;
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map +(
      !ref($_) ? *$_{CODE}||() : reftype($_) eq 'CODE' ? $_ : ()
    ), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
        croak "Can't extend role '$superclass'";
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      $old->assert_constructor;
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              require Sub::Defer;
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
  
      my %construct_opts = (
        package => $target,
        accessor_generator => $class->_accessor_maker_for($target),
        subconstructor_handler => (
          '      if ($Moo::MAKERS{$class}) {'."\n"
          .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
          .'          package '.$target.';'."\n"
          .'          return $invoker->SUPER::new(@_);'."\n"
          .'        }'."\n"
          .'        '.$class.'->_constructor_maker_for($class);'."\n"
          .'        return $invoker->new(@_)'.";\n"
          .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
          .'        return $meta->new_object('."\n"
          .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
          .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
          .'        );'."\n"
          .'      }'."\n"
        ),
      );
  
      my $con;
      my @isa = @{mro::get_linear_isa($target)};
      shift @isa;
      no strict 'refs';
      if (my ($parent_new) = grep +(defined &{$_.'::new'}), @isa) {
        if ($parent_new eq 'Moo::Object') {
          # no special constructor needed
        }
        elsif (my $makers = $MAKERS{$parent_new}) {
          $con = $makers->{constructor};
          $construct_opts{construction_string} = $con->construction_string
            if $con;
        }
        elsif ($parent_new->can('BUILDALL')) {
          $construct_opts{construction_builder} = sub {
            my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
            'do {'
            .'  my $args = $class->'.$inv.'BUILDARGS(@_);'
            .'  $args->{__no_BUILD__} = 1;'
            .'  $invoker->'.$target.'::SUPER::new($args);'
            .'}'
          };
        }
        else {
          $construct_opts{construction_builder} = sub {
            '$invoker->'.$target.'::SUPER::new('
              .($target->can('FOREIGNBUILDARGS') ?
                '$class->FOREIGNBUILDARGS(@_)' : '@_')
              .')'
          };
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(%construct_opts)
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $class) = @_;
    my $makers = $MAKERS{$class};
    # grab class symbol table
    my $stash = _getstash($class);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${class}::$_"} ? \&{"${class}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || reftype($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
    package Cat::Food;
  
    use Moo;
    use strictures 2;
    use namespace::clean;
  
    sub feed_lion {
      my $self = shift;
      my $amount = shift || 1;
  
      $self->pounds( $self->pounds - $amount );
    }
  
    has taste => (
      is => 'ro',
    );
  
    has brand => (
      is  => 'ro',
      isa => sub {
        die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
      },
    );
  
    has pounds => (
      is  => 'rw',
      isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
    );
  
    1;
  
  And elsewhere:
  
    my $full = Cat::Food->new(
        taste  => 'DELICIOUS.',
        brand  => 'SWEET-TREATZ',
        pounds => 10,
    );
  
    $full->feed_lion;
  
    say $full->pounds;
  
  =head1 DESCRIPTION
  
  C<Moo> is an extremely light-weight Object Orientation system. It allows one to
  concisely define objects and roles with a convenient syntax that avoids the
  details of Perl's object system.  C<Moo> contains a subset of L<Moose> and is
  optimised for rapid startup.
  
  C<Moo> avoids depending on any XS modules to allow for simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite --
  two thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead to provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  But if you don't want to use L<Moose>, you may not want "less metaprotocol"
  like L<Mouse> offers, but you probably want "no metaprotocol", which is what
  Moo provides. C<Moo> is ideal for some situations where deployment or startup
  time precludes using L<Moose> and L<Mouse>:
  
  =over 2
  
  =item a command line or CGI script where fast startup is essential
  
  =item code designed to be deployed as a single file via L<App::FatPacker>
  
  =item a CPAN module that may be used by others in the above situations
  
  =back
  
  C<Moo> maintains transparent compatibility with L<Moose> so if you install and
  load L<Moose> you can use Moo classes and roles in L<Moose> code without
  modification.
  
  Moo -- Minimal Object Orientation -- aims to make it smooth to upgrade to
  L<Moose> when you need more than the minimal features offered by Moo.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without modification.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  L<Moo> classes and roles, so that in Moose classes C<< isa => 'MyMooClass' >>
  and C<< isa => 'MyMooRole' >> work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  Extending a L<Mouse> class or consuming a L<Mouse::Role> will also work. But
  note that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  global and turns the mechanism off entirely so don't put this in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it will be used
  to generate simple accessors, readers, and writers for better performance.
  Simple accessors are those without lazy defaults, type checks/coercions, or
  triggers.  Simple readers are those without lazy defaults. Readers and writers
  generated by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 PUBLIC METHODS
  
  Moo provides several methods to any class using it.
  
  =head2 new
  
    Foo::Bar->new( attr1 => 3 );
  
  or
  
    Foo::Bar->new({ attr1 => 3 });
  
  The constructor for the class.  By default it will accept attributes either as a
  hashref, or a list of key value pairs.  This can be customized with the
  L</BUILDARGS> method.
  
  =head2 does
  
    if ($foo->does('Some::Role1')) {
      ...
    }
  
  Returns true if the object composes in the passed role.
  
  =head2 DOES
  
    if ($foo->DOES('Some::Role1') || $foo->DOES('Some::Class1')) {
      ...
    }
  
  Similar to L</does>, but will also return true for both composed roles and
  superclasses.
  
  =head2 meta
  
    my $meta = Foo::Bar->meta;
    my @methods = $meta->get_method_list;
  
  Returns an object that will behave as if it is a
  L<Moose metaclass|Moose::Meta::Class> object for the class. If you call
  anything other than C<make_immutable> on it, the object will be transparently
  upgraded to a genuine L<Moose::Meta::Class> instance, loading Moose in the
  process if required. C<make_immutable> itself is a no-op, since we generate
  metaclasses that are already immutable, and users converting from Moose had
  an unfortunate tendency to accidentally load Moose by calling it.
  
  =head1 LIFECYCLE METHODS
  
  There are several methods that you can define in your class to control
  construction and destruction of objects.  They should be used rather than trying
  to modify C<new> or C<DESTROY> yourself.
  
  =head2 BUILDARGS
  
    around BUILDARGS => sub {
      my ( $orig, $class, @args ) = @_;
  
      return { attr1 => $args[0] }
        if @args == 1 && !ref $args[0];
  
      return $class->$orig(@args);
    };
  
    Foo::Bar->new( 3 );
  
  This class method is used to transform the arguments to C<new> into a hash
  reference of attribute values.
  
  The default implementation accepts a hash or hash reference of named parameters.
  If it receives a single argument that isn't a hash reference it will throw an
  error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
    sub FOREIGNBUILDARGS {
      my ( $class, $options ) = @_;
      return $options->{foo};
    }
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as L</BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
    sub BUILD {
      my ($self, $args) = @_;
      die "foo and bar cannot be used at the same time"
        if exists $args->{foo} && exists $args->{bar};
    }
  
  On object creation, any C<BUILD> methods in the class's inheritance hierarchy
  will be called on the object and given the results of L</BUILDARGS>.  They each
  will be called in order from the parent classes down to the child, and thus
  should not themselves call the parent's method.  Typically this is used for
  object validation or possibly logging.
  
  =head2 DEMOLISH
  
    sub DEMOLISH {
      my ($self, $in_global_destruction) = @_;
      ...
    }
  
  When an object is destroyed, any C<DEMOLISH> methods in the inheritance
  hierarchy will be called on the object.  They are given boolean to inform them
  if global destruction is in progress, and are called from the child class upwards
  to the parent.  This is similar to L</BUILD> methods but in the opposite order.
  
  Note that this is implemented by a C<DESTROY> method, which is only created on
  on the first construction of an object of your class.  This saves on overhead for
  classes that are never instantiated or those without C<DEMOLISH> methods.  If you
  try to define your own C<DESTROY>, this will cause undefined results.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
    extends 'Parent::Class';
  
  Declares a base class. Multiple superclasses can be passed for multiple
  inheritance but please consider using L<roles|Moo::Role> instead.  The class
  will be loaded but no errors will be triggered if the class can't be found and
  there are already subs in the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
    with 'Some::Role1';
  
  or
  
    with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles cannot be composed because they
  have conflicting method definitions.  The roles will be loaded using the same
  mechanism as C<extends> uses.
  
  =head2 has
  
    has attr => (
      is => 'ro',
    );
  
  Declares an attribute for the class.
  
    package Foo;
    use Moo;
    has 'attr' => (
      is => 'ro'
    );
  
    package Bar;
    use Moo;
    extends 'Foo';
    has '+attr' => (
      default => sub { "blah" },
    );
  
  Using the C<+> notation, it's possible to override an attribute.
  
    has [qw(attr1 attr2 attr3)] => (
      is => 'ro',
    );
  
  Using an arrayref with multiple attribute names, it's possible to declare
  multiple attributes with the same options.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item C<is>
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> stands for "read-only" and generates an accessor that dies if you attempt
  to write to it - i.e.  a getter only - by defaulting C<reader> to the name of
  the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> stands for "read-write protected" and generates a reader like C<ro>, but
  also sets C<writer> to C<_set_${attribute_name}> for attributes that are
  designed to be written from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> stands for "read-write" and generates a normal getter/setter by
  defaulting the C<accessor> to the name of the attribute specified.
  
  =item C<isa>
  
  Takes a coderef which is used to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
    use Scalar::Util qw(looks_like_number);
    ...
    isa => sub {
      die "$_[0] is not a number!" unless looks_like_number $_[0]
    },
  
  Note that the return value for C<isa> is discarded. Only if the sub dies does
  type validation fail.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<Moose> compatible or L<MooseX::Types> style named types, look at
  L<Type::Tiny>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item C<coerce>
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always execute your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  If the C<isa> option is a blessed object providing a C<coerce> or
  C<coercion> method, then the C<coerce> option may be set to just C<1>.
  
  =item C<handles>
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a L<role|Moo::Role> that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
    handles => [ qw( one two ) ]
  
  Takes a hashref
  
    handles => {
      un => 'one',
    }
  
  =item C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. The coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item C<default>
  
  Takes a coderef which will get called with $self as its only argument to
  populate an attribute if no value for that attribute was supplied to the
  constructor. Alternatively, if the attribute is lazy, C<default> executes when
  the attribute is first retrieved if no value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  B<NOTE:> If the attribute is C<lazy>, it will be regenerated from C<default> or
  C<builder> the next time it is accessed. If it is not lazy, it will be C<undef>.
  
  =item C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on object instantiation.
  
  =item C<reader>
  
  The name of the method that returns the value of the attribute.  If you like
  Java style methods, you might set this to C<get_foo>
  
  =item C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened. Use this when circular references, which cause memory leaks, are
  possible.
  
  =item C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
    before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 around
  
    around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 after
  
    after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... }; >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
    package Record;
  
    use Digest::MD5 qw(md5_hex);
  
    use Moo;
    use namespace::clean;
  
    has name => (is => 'ro', required => 1);
    has id => (is => 'lazy');
    sub _build_id {
      my ($self) = @_;
      return md5_hex($self->name);
    }
  
    1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> Older versions of L<namespace::autoclean> would
  inflate Moo classes to full L<Moose> classes, losing the benefits of Moo.  If
  you want to use L<namespace::autoclean> with a Moo class, make sure you are
  using version 0.16 or newer.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, L<Type::Tiny> can provide types, type libraries, and
  will work seamlessly with both L<Moo> and L<Moose>.  L<Type::Tiny> can be
  considered the successor to L<MooseX::Types> and provides a similar API, so
  that you can write
  
    use Types::Standard qw(Int);
    has days_to_live => (is => 'ro', isa => Int);
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you need
  L<Moose> - Moo is small because it explicitly does not provide a metaprotocol.
  However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and
  L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  Handling of warnings: when you C<use Moo> we enable strict and warnings, in a
  similar way to Moose. The authors recommend the use of C<strictures>, which
  enables FATAL warnings, and several extra pragmas when used in development:
  L<indirect>, L<multidimensional>, and L<bareword::filehandles>.
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
    package MyClass;
    use Moo;
    use strictures 2;
  
  The nearest L<Moose> invocation would be:
  
    package MyClass;
  
    use Moose;
    use warnings FATAL => "all";
    use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
    package MyClass;
  
    use Moose;
    use MooseX::NonMoose;
    use warnings FATAL => "all";
    use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
    __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  bubaflub - Bob Kuo (cpan:BUBAFLUB) <bubaflub@cpan.org>
  
  ether = Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2015 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  use Moo::_strictures;
  use Moo::_Utils qw(_getstash);
  use Sub::Quote qw(quotify);
  use Carp qw(croak);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    croak "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', keys %Moo::MAKERS;
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
    @Moo::HandleMoose::FakeMeta::ISA = 'Moose::Meta::Method::Meta';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    require Sub::Defer;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $am_class, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, 0, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, 1, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, 0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    {
      local $DID_INJECT{$name} = 1;
      foreach my $spec (values %$attr_specs) {
        if (my $inflators = delete $spec->{moosify}) {
          $_->($spec) for @$inflators;
        }
      }
  
      my %methods
        = %{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};
  
      # if stuff gets added afterwards, _maybe_reset_handlemoose should
      # trigger the recreation of the metaclass but we need to ensure the
      # Moo::Role cache is cleared so we don't confuse Moo itself.
      if (my $info = $Moo::Role::INFO{$name}) {
        delete $info->{methods};
      }
  
      # needed to ensure the method body is stable and get things named
      $methods{$_} = Sub::Defer::undefer_sub($methods{$_})
        for
          grep $_ ne 'new',
          keys %methods;
      my @attrs;
      {
        # This local is completely not required for roles but harmless
        local @{_getstash($name)}{keys %methods};
        my %seen_name;
        foreach my $attr_name (@$attr_order) {
          $seen_name{$attr_name} = 1;
          my %spec = %{$attr_specs->{$attr_name}};
          my %spec_map = (
            map { $_->name => $_->init_arg||$_->name }
            (
              (grep { $_->has_init_arg }
                $meta->attribute_metaclass->meta->get_all_attributes),
              grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
              map {
                my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                            ->meta;
                map $meta->get_attribute($_), $meta->get_attribute_list
              }  @{$spec{traits}||[]}
            )
          );
          # have to hard code this because Moose's role meta-model is lacking
          $spec_map{traits} ||= 'traits';
  
          $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
          my $coerce = $spec{coerce};
          if (my $isa = $spec{isa}) {
            my $tc = $spec{isa} = do {
              if (my $mapped = $TYPE_MAP{$isa}) {
                my $type = $mapped->();
                unless ( Scalar::Util::blessed($type)
                    && $type->isa("Moose::Meta::TypeConstraint") ) {
                  croak "error inflating attribute '$attr_name' for package '$name': "
                    ."\$TYPE_MAP{$isa} did not return a valid type constraint'";
                }
                $coerce ? $type->create_child_type(name => $type->name) : $type;
              } else {
                Moose::Meta::TypeConstraint->new(
                  constraint => sub { eval { &$isa; 1 } }
                );
              }
            };
            if ($coerce) {
              $tc->coercion(Moose::Meta::TypeCoercion->new)
                ->_compiled_type_coercion($coerce);
              $spec{coerce} = 1;
            }
          } elsif ($coerce) {
            my $attr = quotify($attr_name);
            my $tc = Moose::Meta::TypeConstraint->new(
                      constraint => sub { die "This is not going to work" },
                      inlined => sub {
                          'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                      },
                    );
            $tc->coercion(Moose::Meta::TypeCoercion->new)
              ->_compiled_type_coercion($coerce);
            $spec{isa} = $tc;
            $spec{coerce} = 1;
          }
          %spec =
            map { $spec_map{$_} => $spec{$_} }
            grep { exists $spec_map{$_} }
            keys %spec;
          push @attrs, $meta->add_attribute($attr_name => %spec);
        }
        foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
          foreach my $attr ($mouse->get_all_attributes) {
            my %spec = %{$attr};
            delete @spec{qw(
              associated_class associated_methods __METACLASS__
              provides curries
            )};
            my $attr_name = delete $spec{name};
            next if $seen_name{$attr_name}++;
            push @attrs, $meta->add_attribute($attr_name => %spec);
          }
        }
      }
      foreach my $meth_name (keys %methods) {
        my $meth_code = $methods{$meth_name};
        $meta->add_method($meth_name, $meth_code);
      }
  
      if ($am_role) {
        my $info = $Moo::Role::INFO{$name};
        $meta->add_required_methods(@{$info->{requires}});
        foreach my $modifier (@{$info->{modifiers}}) {
          my ($type, @args) = @$modifier;
          my $code = pop @args;
          $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
        }
      }
      elsif ($am_class) {
        foreach my $attr (@attrs) {
          foreach my $method (@{$attr->associated_methods}) {
            $method->{body} = $name->can($method->name);
          }
        }
        bless(
          $meta->find_method_by_name('new'),
          'Moo::HandleMoose::FakeConstructor',
        );
        my $meta_meth;
        if (
          $meta_meth = $meta->find_method_by_name('meta')
          and $meta_meth->body == \&Moo::Object::meta
        ) {
          bless($meta_meth, 'Moo::HandleMoose::FakeMeta');
        }
        # a combination of Moo and Moose may bypass a Moo constructor but still
        # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
        # global destruction.
        require Method::Generate::DemolishAll;
      }
      $meta->add_role(Class::MOP::class_of($_))
        for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
          keys %{$Moo::Role::APPLIED_TO{$name}}
    }
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  use Moo::_strictures;
  use Carp ();
  BEGIN { our @CARP_NOT = qw(Moo::HandleMoose) }
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    my $self = shift;
    Carp::croak "Can't call $meth without object instance"
      if !ref $self;
    Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)
  }
  sub can {
    my $self = shift;
    return $self->SUPER::can(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)
  }
  sub isa {
    my $self = shift;
    return $self->SUPER::isa(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use Moo::_strictures;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  use Config;
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/) {
      my $type = $1;
      my $id = do { no warnings 'portable'; hex "$2" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref or Scalar::Util::reftype($ref) ne $type) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  if ($Config{useithreads}) {
    my @types = %TYPE_MAP;
    tie %TYPE_MAP, __PACKAGE__;
    %TYPE_MAP = @types;
  }
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use Moo::_strictures;
  use Carp ();
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    my $proto = $class->BUILDARGS(@_);
    $NO_BUILD{$class} and
      return bless({}, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({}, $class)
      : bless({}, $class)->BUILDALL($proto);
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
    my $class = shift;
    scalar @_ == 1
      ? ref $_[0] eq 'HASH'
        ? { %{ $_[0] } }
        : Carp::croak("Single parameters to new() must be a HASH ref"
            . " data => ". $_[0])
      : @_ % 2
        ? Carp::croak("The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments")
        : {@_}
    ;
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    return !!0
      unless ($INC{'Moose/Role.pm'} || $INC{'Role/Tiny.pm'});
    require Moo::Role;
    my $does = Moo::Role->can("does_role");
    { no warnings 'redefine'; *does = $does }
    goto &$does;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use Moo::_strictures;
  use Moo::_Utils qw(
    _getglob
    _getstash
    _install_coderef
    _install_modifier
    _load_module
    _name_coderef
    _set_loaded
    _unimport_coderefs
  );
  use Carp qw(croak);
  use Role::Tiny ();
  BEGIN { our @ISA = qw(Role::Tiny) }
  BEGIN {
    our @CARP_NOT = qw(
      Method::Generate::Accessor
      Method::Generate::Constructor
      Moo::sification
      Moo::_Utils
    );
  }
  
  our $VERSION = '2.003004';
  $VERSION =~ tr/_//d;
  
  require Moo::sification;
  Moo::sification->import;
  
  BEGIN {
      *INFO = \%Role::Tiny::INFO;
      *APPLIED_TO = \%Role::Tiny::APPLIED_TO;
      *COMPOSED = \%Role::Tiny::COMPOSED;
      *ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
  }
  
  our %INFO;
  our %APPLIED_TO;
  our %APPLY_DEFAULTS;
  our %COMPOSED;
  our @ON_ROLE_CREATE;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      croak "Cannot import Moo::Role into a Moo class";
    }
    _set_loaded(caller);
    goto &Role::Tiny::import;
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    *{_getglob("${target}::meta")} = $me->can('meta');
  }
  
  push @ON_ROLE_CREATE, sub {
    my $target = shift;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  };
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    _load_module($role);
    $self->_inhale_if_moose($role);
    croak "${role} is not a Moo::Role" unless $self->is_role($role);
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub is_role {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    $self->SUPER::is_role($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    my $meta;
    if (!$self->SUPER::is_role($role)
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
            require Sub::Quote;
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
            my $tc_var = '$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);
  
            $spec->{isa} = Sub::Quote::quote_sub(
              qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },
              { $tc_var => \$check },
              {
                package => $role,
              },
            );
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub _undefer_subs {
    my ($self, $target, $role) = @_;
    if ($INC{'Sub/Defer.pm'}) {
      Sub::Defer::undefer_package($role);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _undefer_subs _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      croak "${role} is not a Moo::Role" unless $me->is_role($role);
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    _load_module($role);
    $me->_inhale_if_moose($role);
    croak "${role} is not a Moo::Role" unless $me->is_role($role);
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      croak "${role} is not a Moo::Role" unless $me->is_role($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      @{*{_getglob("${new_name}::ISA")}{ARRAY}} = ($superclass);
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->apply_roles_to_package($new_name, @roles);
    }
    else {
      $me->SUPER::create_class_with_roles($superclass, @roles);
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->_handle_constructor($new_name, $_) for @roles;
    }
  
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($new_name);
    }
    $COMPOSED{class}{$new_name} = 1;
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    my $class = ref $new;
    _set_loaded($class, (caller)[1]);
  
    my $apply_defaults = exists $APPLY_DEFAULTS{$class} ? $APPLY_DEFAULTS{$class}
      : $APPLY_DEFAULTS{$class} = do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for($class)
          and my $m = Moo->_accessor_maker_for($class)) {
  
        my $specs = $con_gen->all_attribute_specs;
  
        my %captures;
        my $code = join('',
          ( map {
            my $name = $_;
            my $spec = $specs->{$name};
            if ($m->has_eager_default($name, $spec)) {
              my ($has, $has_cap)
                = $m->generate_simple_has('$_[0]', $name, $spec);
              my ($set, $pop_cap)
                = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
              @captures{keys %$has_cap, keys %$pop_cap}
                = (values %$has_cap, values %$pop_cap);
              "($set),";
            }
            else {
              ();
            }
          } sort keys %attrs ),
        );
        if ($code) {
          require Sub::Quote;
          Sub::Quote::quote_sub(
            "${class}::_apply_defaults",
            "no warnings 'void';\n$code",
            \%captures,
            {
              package => $class,
              no_install => 1,
            }
          );
        }
        else {
          0;
        }
      }
      else {
        0;
      }
    };
    if ($apply_defaults) {
      local $Carp::Internal{+__PACKAGE__} = 1;
      local $Carp::Internal{$class} = 1;
      $new->$apply_defaults;
    }
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _install_does {
      my ($me, $to) = @_;
  
      # If Role::Tiny actually installed the DOES, give it a name
      my $new = $me->SUPER::_install_does($to) or return;
      return _name_coderef("${to}::DOES", $new);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return 1
      if Role::Tiny::does_role($proto, $role);
    my $meta;
    if ($INC{'Moose.pm'}
        and $meta = Class::MOP::class_of($proto)
        and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
        and $meta->can('does_role')
    ) {
      return $meta->does_role($role);
    }
    return 0;
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    my $info = $INFO{$to};
    my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
    my %existing
      = $info ? @{$info->{attributes} || []}
      : $con  ? %{$con->all_attribute_specs || {}}
      : ();
  
    my @attr_info =
      map { @{$attr_info}[$_, $_+1] }
      grep { ! $existing{$attr_info->[$_]} }
      map { 2 * $_ } 0..@$attr_info/2-1;
  
    if ($info) {
      push @{$info->{attributes}||=[]}, @attr_info;
    }
    elsif ($con) {
      # shallow copy of the specs since the constructor will assign an index
      $con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
    package My::Role;
  
    use Moo::Role;
    use strictures 2;
  
    sub foo { ... }
  
    sub bar { ... }
  
    has baz => (
      is => 'ro',
    );
  
    1;
  
  And elsewhere:
  
    package Some::Class;
  
    use Moo;
    use strictures 2;
  
    # bar gets imported, but not foo
    with('My::Role');
  
    sub foo { ... }
  
    1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
    has attr => (
      is => 'ro',
    );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
    package My::Role::ID;
  
    use Digest::MD5 qw(md5_hex);
    use Moo::Role;
    use Digest::SHA qw(sha1_hex);
  
    requires 'name';
  
    sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
    sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
    1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  use Moo::_strictures;
  
  {
    no strict 'refs';
    sub _getglob { \*{$_[0]} }
    sub _getstash { \%{"$_[0]::"} }
  }
  
  BEGIN {
    my ($su, $sn);
    $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname
      or $sn = $INC{'Sub/Name.pm'}
      or $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname
      or $sn = eval { require Sub::Name; };
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_CAN_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use Exporter qw(import);
  use Config;
  use Carp qw(croak);
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _getstash _install_coderef _name_coderef
      _unimport_coderefs _set_loaded
  );
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if ($INC{'Sub/Defer.pm'} and my $to_modify = $into->can($name)) { # CMM will throw for us if not
      Sub::Defer::undefer_sub($to_modify);
    }
  
    require Class::Method::Modifiers;
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  sub _load_module {
    my $module = $_[0];
    my $file = eval { module_notional_filename($module) } or croak $@;
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(ref($_) || *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    croak $error;
  }
  
  our %MAYBE_LOADED;
  sub _maybe_load_module {
    my $module = $_[0];
    return $MAYBE_LOADED{$module}
      if exists $MAYBE_LOADED{$module};
    if(! eval { use_package_optimistically($module) }) {
      warn "$module exists but failed to load with error: $@";
    }
    elsif ( $INC{module_notional_filename($module)} ) {
      return $MAYBE_LOADED{$module} = 1;
    }
    return $MAYBE_LOADED{$module} = 0;
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    _CAN_SUBNAME ? _subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  use Moo::_strictures;
  
  if ("$]" >= 5.010_000) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;
  use strict;
  use warnings;
  
  sub import {
    if ($ENV{MOO_FATAL_WARNINGS}) {
      require strictures;
      strictures->VERSION(2);
      @_ = ('strictures');
      goto &strictures::import;
    }
    else {
      strict->import;
      warnings->import;
      warnings->unimport('once');
    }
  }
  
  1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use Moo::_strictures;
  no warnings 'once';
  use Devel::GlobalDestruction qw(in_global_destruction);
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Moo::HandleMoose) }
  
  sub unimport {
    croak "Can't disable Moo::sification after inflation has been done"
      if $Moo::HandleMoose::SETUP_DONE;
    our $disabled = 1;
  }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disabled or in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  sub import {
    return
      if our $setup_done;
    if ($INC{"Moose.pm"}) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    } else {
      $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
    }
    $setup_done = 1;
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION =~ tr/_//d;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_WORK_AROUND_HINT_LEAKAGE
      = "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
        ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub croak {
    require Carp;
    no warnings 'redefine';
    *croak = \&Carp::croak;
    goto &Carp::croak;
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    my ($module) = @_;
    (my $file = "$module.pm") =~ s{::}{/}g;
    return 1
      if $INC{$file};
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1
      if grep !/::\z/, keys %{_getstash($module)};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $file ], 'Role::Tiny::__GUARD__');
    local %^H if _WORK_AROUND_HINT_LEAKAGE;
    require $file;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    $me->_install_subs($target);
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = map +(ref $_ eq 'CODE' ? $_ : ref $_ ? () : *$_{CODE}||()), values %$stash;
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    foreach my $hook (@ON_ROLE_CREATE) {
      $hook->($target);
    }
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    return if $me->is_role($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    croak "This is apply_role_to_package" if ref($to);
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    croak "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    croak "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      if (my @dupes = grep 1 == $seen{$_}++, @roles) {
        croak "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join("' and '", sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      croak $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      croak $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || ref($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    my $info = $INFO{$to};
    my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
    my @modifiers = grep {
      my $modifier = $_;
      !grep $_ == $modifier, @$existing;
    } @{$modifiers||[]};
    push @$existing, @modifiers;
  
    if (!$info) {
      foreach my $modifier (@modifiers) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval {
        require Class::Method::Modifiers;
        Class::Method::Modifiers->VERSION(1.05);
        1;
      } ? 0 : $@;
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... };
  
   1;
  
  elsewhere
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role. A method inherited by a class gets overridden by the role's
  method of the same name, though.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly. Object is reblessed into the
  resulting class. Note that the object's methods get overridden by the role's
  ones with the same names.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to other copies of the object.
  
  =item * On perl 5.16 and earlier, applying a role to a class won't apply any
  overloads from the role to any existing instances of the class.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  use strict;
  use warnings;
  use Exporter qw(import);
  use Scalar::Util qw(weaken);
  use Carp qw(croak);
  
  our $VERSION = '2.005001';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  our @EXPORT_OK = qw(undefer_package defer_info);
  
  our %DEFERRED;
  
  sub _getglob { no strict 'refs'; \*{$_[0]} }
  
  BEGIN {
    my $no_subname;
    *_subname
      = defined &Sub::Util::set_subname ? \&Sub::Util::set_subname
      : defined &Sub::Name::subname     ? \&Sub::Name::subname
      : (eval { require Sub::Util } && defined &Sub::Util::set_subname) ? \&Sub::Util::set_subname
      : (eval { require Sub::Name } && defined &Sub::Name::subname    ) ? \&Sub::Name::subname
      : ($no_subname = 1, sub { $_[1] });
    *_CAN_SUBNAME = $no_subname ? sub(){0} : sub(){1};
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    _CAN_SUBNAME ? _subname(@_) : $_[1];
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub undefer_sub {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred} or return $deferred;
    my ($target, $maker, $options, $undeferred_ref, $deferred_sub) = @$info;
  
    if (!(
      $deferred_sub && $deferred eq $deferred_sub
      || ${$undeferred_ref} && $deferred eq ${$undeferred_ref}
    )) {
      return $deferred;
    }
  
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    my $undefer_info = [ $target, $maker, $options, \$$undeferred_ref ];
    $info->[5] = $DEFERRED{$made} = $undefer_info;
    weaken ${$undefer_info->[3]};
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub undefer_package {
    my $package = shift;
    undefer_sub($_)
      for grep {
        my $name = $DEFERRED{$_} && $DEFERRED{$_}[0];
        $name && $name =~ /^${package}::[^:]+$/
      } keys %DEFERRED;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred||''} or return undef;
  
    my ($target, $maker, $options, $undeferred_ref, $deferred_sub) = @$info;
    if (!(
      $deferred_sub && $deferred eq $deferred_sub
      || ${$undeferred_ref} && $deferred eq ${$undeferred_ref}
    )) {
      delete $DEFERRED{$deferred};
      return undef;
    }
    [
      $target, $maker, $options,
      ( $undeferred_ref && $$undeferred_ref ? $$undeferred_ref : ()),
    ];
  }
  
  sub defer_sub {
    my ($target, $maker, $options) = @_;
    my $package;
    my $subname;
    ($package, $subname) = $target =~ /^(.*)::([^:]+)$/
      or croak "$target is not a fully qualified sub name!"
      if $target;
    $package ||= $options && $options->{package} || caller;
    my @attributes = @{$options && $options->{attributes} || []};
    if (@attributes) {
      /\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
        for @attributes;
    }
    my $deferred;
    my $undeferred;
    my $deferred_info = [ $target, $maker, $options, \$undeferred ];
    if (@attributes || $target && !_CAN_SUBNAME) {
      my $code
        =  q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n]
        . qq[package $package;\n]
        . ($target ? "sub $subname" : '+sub') . join('', map " :$_", @attributes)
        . q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[4]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n"
        . ($target ? "\\&$subname" : '');
      my $e;
      $deferred = do {
        no warnings qw(redefine closure);
        local $@;
        eval $code or $e = $@; # uncoverable branch true
      };
      die $e if defined $e; # uncoverable branch true
    }
    else {
      # duplicated from above
      $deferred = sub {
        $undeferred ||= undefer_sub($deferred_info->[4]);
        goto &$undeferred;
      };
      _install_coderef($target, $deferred)
        if $target;
    }
    weaken($deferred_info->[4] = $deferred);
    weaken($DEFERRED{$deferred} = $deferred_info);
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map {
      defined $_ ? (
          $_->[4] ? ($_->[4] => $_)
        : ($_->[3] && ${$_->[3]}) ? (${$_->[3]} => $_)
        : ()
      ) : ()
    } values %DEFERRED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - Defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... }, \%options;
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  Exported by default.
  
  =head3 Options
  
  A hashref of options can optionally be specified.
  
  =over 4
  
  =item package
  
  The package to generate the sub in.  Will be overridden by a fully qualified
  C<$name> option.  If not specified, will default to the caller's package.
  
  =item attributes
  
  The L<perlsub/Subroutine Attributes> to apply to the sub generated.  Should be
  specified as an array reference.
  
  =back
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  Exported by default.
  
  =head2 defer_info
  
   my $data = defer_info $sub;
   my ($name, $generator, $options, $undeferred_sub) = @$data;
  
  Returns original arguments to defer_sub, plus the undeferred version if this
  sub has already been undeferred.
  
  Note that $sub can be either the original deferred version or the undeferred
  version for convenience.
  
  Not exported by default.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all deferred subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.  Note this may bake the behavior of some subs that were intended to
  calculate their behavior later, so it shouldn't be used midway through a
  module load or class definition.
  
  Exported by default.
  
  =head2 undefer_package
  
    undefer_package($package);
  
  This undefers all deferred subs in a package.
  
  Not exported by default.
  
  =head1 SUPPORT
  
  See L<Sub::Quote> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Sub::Quote> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Sub::Quote> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  $Sub::Exporter::Progressive::VERSION = '0.001013';
  use strict;
  use warnings;
  
  # ABSTRACT: Only use Sub::Exporter if you need it
  
  sub _croak {
    require Carp;
    &Carp::croak;
  }
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     no warnings 'once';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if ( grep {
           length ref $_
              or
           $_ !~ / \A [:-]? \w+ \z /xm
        } @args ) {
           _croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif ( defined( (my ($num) = grep { m/^\d/ } @args)[0] ) ) {
           _croak "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ( ($setup||'') eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              _croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              _croak $too_complicated if grep { length ref $_ } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 _croak $too_complicated if grep {
                    length ref $_
                       or
                    $_ =~ / \A - (?! all \b ) /x
                 } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              _croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        _croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 VERSION
  
  version 0.001013
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 AUTHOR
  
  Arthur Axel "fREW" Schmidt <Sub-Exporter-Progressive@afoolishmanifesto.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Arthur Axel "fREW" Schmidt.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  sub _clean_eval { eval $_[0] }
  
  use strict;
  use warnings;
  
  use Sub::Defer qw(defer_sub);
  use Scalar::Util qw(weaken);
  use Exporter qw(import);
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Sub::Defer) }
  use B ();
  BEGIN {
    *_HAVE_IS_UTF8 = defined &utf8::is_utf8 ? sub(){1} : sub(){0};
    *_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.005001';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
  our @EXPORT_OK = qw(quotify capture_unroll inlinify sanitize_identifier);
  
  our %QUOTED;
  
  sub quotify {
    my $value = $_[0];
    no warnings 'numeric';
    ! defined $value     ? 'undef()'
    # numeric detection
    : (!(_HAVE_IS_UTF8 && utf8::is_utf8($value))
      && length( (my $dummy = '') & $value )
      && 0 + $value eq $value
      && $value * 0 == 0
    ) ? $value
    : _HAVE_PERLSTRING  ? B::perlstring($value)
    : qq["\Q$value\E"];
  }
  
  sub sanitize_identifier {
    my $name = shift;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or croak "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms) {
      my ($pre, $indent, $code_args) = ($1, $2, $3);
      $do .= $pre;
      if ($code_args ne $args) {
        $do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    if ($name) {
      my $subname = $name;
      my $package = $subname =~ s/(.*)::// ? $1 : caller;
      $name = join '::', $package, $subname;
      croak qq{package name "$package" too long!}
        if length $package > 252;
      croak qq{package name "$package" is not valid!}
        unless $package =~ /^[^\d\W]\w*(?:::\w+)*$/;
      croak qq{sub name "$subname" too long!}
        if length $subname > 252;
      croak qq{sub name "$subname" is not valid!}
        unless $subname =~ /^[^\d\W]\w*$/;
    }
    my @caller = caller(0);
    my ($attributes, $file, $line) = @{$options}{qw(attributes file line)};
    if ($attributes) {
      /\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
        for @$attributes;
    }
    my $quoted_info = {
      name     => $name,
      code     => $code,
      captures => $captures,
      package      => (exists $options->{package}      ? $options->{package}      : $caller[0]),
      hints        => (exists $options->{hints}        ? $options->{hints}        : $caller[8]),
      warning_bits => (exists $options->{warning_bits} ? $options->{warning_bits} : $caller[9]),
      hintshash    => (exists $options->{hintshash}    ? $options->{hintshash}    : $caller[10]),
      ($attributes ? (attributes => $attributes) : ()),
      ($file       ? (file => $file) : ()),
      ($line       ? (line => $line) : ()),
    };
    my $unquoted;
    weaken($quoted_info->{unquoted} = \$unquoted);
    if ($options->{no_defer}) {
      my $fake = \my $var;
      local $QUOTED{$fake} = $quoted_info;
      my $sub = unquote_sub($fake);
      Sub::Defer::_install_coderef($name, $sub) if $name && !$options->{no_install};
      return $sub;
    }
    else {
      my $deferred = defer_sub(
        ($options->{no_install} ? undef : $name),
        sub {
          $unquoted if 0;
          unquote_sub($quoted_info->{deferred});
        },
        {
          ($attributes ? ( attributes => $attributes ) : ()),
          ($name ? () : ( package => $quoted_info->{package} )),
        },
      );
      weaken($quoted_info->{deferred} = $deferred);
      weaken($QUOTED{$deferred} = $quoted_info);
      return $deferred;
    }
  }
  
  sub _context {
    my $info = shift;
    $info->{context} ||= do {
      my ($package, $hints, $warning_bits, $hintshash, $file, $line)
        = @{$info}{qw(package hints warning_bits hintshash file line)};
  
      $line ||= 1
        if $file;
  
      my $line_mark = '';
      if ($line) {
        $line_mark = "#line ".($line-1);
        if ($file) {
          $line_mark .= qq{ "$file"};
        }
        $line_mark .= "\n";
      }
  
      $info->{context}
        ="# BEGIN quote_sub PRELUDE\n"
        ."package $package;\n"
        ."BEGIN {\n"
        ."  \$^H = ".quotify($hints).";\n"
        ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n"
        ."  \%^H = (\n"
        . join('', map
        "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",
          keys %$hintshash)
        ."  );\n"
        ."}\n"
        .$line_mark
        ."# END quote_sub PRELUDE\n";
    };
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub||''} or return undef;
    my ($name, $code, $captures, $unquoted, $deferred)
      = @{$quoted_info}{qw(name code captures unquoted deferred)};
    $code = _context($quoted_info) . $code;
    $unquoted &&= $$unquoted;
    if (($deferred && $deferred eq $sub)
        || ($unquoted && $unquoted eq $sub)) {
      return [ $name, $code, $captures, $unquoted, $deferred ];
    }
    return undef;
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub} or return undef;
    my $unquoted = $quoted_info->{unquoted};
    unless ($unquoted && $$unquoted) {
      my ($name, $code, $captures, $package, $attributes)
        = @{$quoted_info}{qw(name code captures package attributes)};
  
      ($package, $name) = $name =~ /(.*)::(.*)/
        if $name;
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_UNQUOTED'} = \$unquoted;
      $captures{'$_QUOTED'} = \$quoted_info;
  
      my $make_sub
        = "{\n"
        . capture_unroll("\$_[1]", \%captures, 2)
        . "  package ${package};\n"
        . (
          $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
            ? "  no warnings 'closure';\n  sub ${name} "
            : "  \$\$_UNQUOTED = sub "
        )
        . ($attributes ? join('', map ":$_ ", @$attributes) : '') . "{\n"
        . "  (\$_QUOTED,\$_UNQUOTED) if 0;\n"
        . _context($quoted_info)
        . $code
        . "  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '') . ";\n"
        . "}\n"
        . "1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{"${package}::${name}"} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          my $space = length($make_sub =~ tr/\n//);
          my $line = 0;
          $make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;
          croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
        weaken($QUOTED{$$unquoted} = $quoted_info);
      }
    }
    $$unquoted;
  }
  
  sub qsub ($) {
    goto &quote_sub;
  }
  
  sub CLONE {
    my @quoted = map { defined $_ ? (
      $_->{unquoted} && ${$_->{unquoted}} ? (${ $_->{unquoted} } => $_) : (),
      $_->{deferred} ? ($_->{deferred} => $_) : (),
    ) : () } values %QUOTED;
    %QUOTED = @quoted;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Sub::Quote - Efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  Exported by default.
  
  =head3 options
  
  =over 2
  
  =item C<no_install>
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =item C<no_defer>
  
  B<Boolean>.  Prevents a Sub::Defer wrapper from being generated for the quoted
  sub.  If the sub will most likely be called at some point, setting this is a
  good idea.  For a sub that will most likely be inlined, it is not recommended.
  
  =item C<package>
  
  The package that the quoted sub will be evaluated in.  If not specified, the
  package from sub calling C<quote_sub> will be used.
  
  =item C<hints>
  
  The value of L<< C<$^H> | perlvar/$^H >> to use for the code being evaluated.
  This captures the settings of the L<strict> pragma.  If not specified, the value
  from the calling code will be used.
  
  =item C<warning_bits>
  
  The value of L<< C<${^WARNING_BITS}> | perlvar/${^WARNING_BITS} >> to use for
  the code being evaluated.  This captures the L<warnings> set.  If not specified,
  the warnings from the calling code will be used.
  
  =item C<%^H>
  
  The value of L<< C<%^H> | perlvar/%^H >> to use for the code being evaluated.
  This captures additional pragma settings.  If not specified, the value from the
  calling code will be used if possible (on perl 5.10+).
  
  =item C<attributes>
  
  The L<perlsub/Subroutine Attributes> to apply to the sub generated.  Should be
  specified as an array reference.  The attributes will be applied to both the
  generated sub and the deferred wrapper, if one is used.
  
  =item C<file>
  
  The apparent filename to use for the code being evaluated.
  
  =item C<line>
  
  The apparent line number
  to use for the code being evaluated.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  Exported by default.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  Exported by default.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 quotify
  
   my $quoted_value = quotify $value;
  
  Quotes a single (non-reference) scalar value for use in a code string.  Numbers
  aren't treated specially and will be quoted as strings, but undef will quoted as
  C<undef()>.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head2 qsub
  
   my $hash = {
    coderef => qsub q{ print "hello"; },
    other   => 5,
   };
  
  Arguments: $code
  
  Works exactly like L</quote_sub>, but includes a prototype to only accept a
  single parameter.  This makes it easier to include in hash structures or lists.
  
  Exported by default.
  
  =head2 sanitize_identifier
  
   my $var_name = '$variable_for_' . sanitize_identifier('@name');
   quote_sub qq{ print \$${var_name} }, { $var_name => \$value };
  
  Arguments: $identifier
  
  Sanitizes a value so that it can be used in an identifier.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few
  caveats apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Sub-Quote>
  
  Git repository: L<git://github.com/moose/Sub-Quote.git>
  
  Git browser: L<https://github.com/moose/Sub-Quote>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  dolmen - Olivier Mengu (cpan:DOLMEN) <dolmen@cpan.org>
  
  alexbio - Alessandro Ghedini (cpan:ALEXBIO) <alexbio@cpan.org>
  
  getty - Torsten Raudssus (cpan:GETTY) <torsten@raudss.us>
  
  arcanez - Justin Hunter (cpan:ARCANEZ) <justin.d.hunter@gmail.com>
  
  kanashiro - Lucas Kanashiro (cpan:KANASHIRO) <kanashiro.duarte@gmail.com>
  
  djerius - Diab Jerius (cpan:DJERIUS) <djerius@cfa.harvard.edu>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2016 the Sub::Quote L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
SUB_QUOTE

$fatpacked{"Term/App/Role/Attrs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_APP_ROLE_ATTRS';
  package Term::App::Role::Attrs;
  
  our $DATE = '2014-12-10'; # DATE
  our $VERSION = '0.01'; # VERSION
  
  use 5.010001;
  use Moo::Role;
  
  my $dt_cache;
  sub detect_terminal {
      my $self = shift;
  
      if (!$dt_cache) {
          require Term::Detect::Software;
          $dt_cache = Term::Detect::Software::detect_terminal_cached();
          #use Data::Dump; dd $dt_cache;
      }
      $dt_cache;
  }
  
  my $termw_cache;
  my $termh_cache;
  sub _term_size {
      my $self = shift;
  
      if (defined $termw_cache) {
          return ($termw_cache, $termh_cache);
      }
  
      ($termw_cache, $termh_cache) = (0, 0);
      if (eval { require Term::Size; 1 }) {
          ($termw_cache, $termh_cache) = Term::Size::chars();
      }
      ($termw_cache, $termh_cache);
  }
  
  # return undef if fail to parse
  sub __parse_color_depth {
      my $val = shift;
      if ($val =~ /\A\d+\z/) {
          return $val;
      } elsif ($val =~ /\A(\d+)[ _-]?(?:bit|b)\z/) {
          return 2**$val;
      } else {
          # IDEA: parse 'high color', 'true color'?
          return undef;
      }
  }
  
  has interactive => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          if (defined $ENV{INTERACTIVE}) {
              $self->{_term_attrs_debug_info}{interactive_from} =
                  'INTERACTIVE env';
              return $ENV{INTERACTIVE};
          } else {
              $self->{_term_attrs_debug_info}{interactive_from} =
                  '-t STDOUT';
              return (-t STDOUT);
          }
      },
  );
  
  has use_color => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          if (defined $ENV{COLOR}) {
              $self->{_term_attrs_debug_info}{use_color_from} =
                  'COLOR env';
              return $ENV{COLOR};
          } elsif (defined $ENV{COLOR_DEPTH}) {
              $self->{_term_attrs_debug_info}{use_color_from} =
                  'COLOR_DEPTH env';
              my $val = __parse_color_depth($ENV{COLOR_DEPTH}) //
                  $ENV{COLOR_DEPTH};
              return $val ? 1:0;
          } else {
              $self->{_term_attrs_debug_info}{use_color_from} =
                  'interactive + color_deth';
              return $self->interactive && $self->color_depth > 0;
          }
      },
      trigger => sub {
          my ($self, $val) = @_;
          return if !defined($val) || $val =~ /\A(|1|0)\z/;
          my $pval = __parse_color_depth($val);
          $self->{color_depth} = $pval if defined $pval;
      },
  );
  
  has color_depth => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          my $pval;
          if (defined($ENV{COLOR_DEPTH}) &&
                  defined($pval = __parse_color_depth($ENV{COLOR_DEPTH}))) {
              $self->{_term_attrs_debug_info}{color_depth_from} =
                  'COLOR_DEPTH env';
              return $pval;
          } elsif (defined($ENV{COLOR}) && $ENV{COLOR} !~ /^(|0|1)$/ &&
                       defined($pval = __parse_color_depth($ENV{COLOR}))) {
                  $self->{_term_attrs_debug_info}{color_depth_from} =
                      'COLOR env';
              return $pval;
          } elsif (defined(my $cd = $self->detect_terminal->{color_depth})) {
              $self->{_term_attrs_debug_info}{color_depth_from} =
                  'detect_terminal';
              return $cd;
          } else {
              $self->{_term_attrs_debug_info}{color_depth_from} =
                  'hardcoded default';
              return 16;
          }
      },
      trigger => sub {
          my ($self, $val) = @_;
          if (defined(my $pval = __parse_color_depth($val))) {
              $self->{color_depth} = $val = $pval;
          }
          if ($val) {
              $self->{use_color} = 1;
          } else {
              $self->{use_color} = 0;
          }
      },
  );
  
  has use_box_chars => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          if (defined $ENV{BOX_CHARS}) {
              $self->{_term_attrs_debug_info}{use_box_chars_from} =
                  'BOX_CHARS env';
              return $ENV{BOX_CHARS};
          } elsif (!$self->interactive) {
              # most pager including 'less -R' does not support interpreting
              # boxchar escape codes.
              $self->{_term_attrs_debug_info}{use_box_chars_from} =
                  '(not) interactive';
              return 0;
          } elsif (defined(my $bc = $self->detect_terminal->{box_chars})) {
              $self->{_term_attrs_debug_info}{use_box_chars_from} =
                  'detect_terminal';
              return $bc;
          } else {
              $self->{_term_attrs_debug_info}{use_box_chars_from} =
                  'hardcoded default';
              return 0;
          }
      },
  );
  
  has use_utf8 => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          if (defined $ENV{UTF8}) {
              $self->{_term_attrs_debug_info}{use_utf8_from} =
                  'UTF8 env';
              return $ENV{UTF8};
          } elsif (defined(my $termuni = $self->detect_terminal->{unicode})) {
              $self->{_term_attrs_debug_info}{use_utf8_from} =
                  'detect_terminal + LANG/LANGUAGE env must include "utf8"';
              return $termuni &&
                  (($ENV{LANG} || $ENV{LANGUAGE} || "") =~ /utf-?8/i ? 1:0);
          } else {
              $self->{_term_attrs_debug_info}{use_utf8_from} =
                  'hardcoded default';
              return 0;
          }
      },
  );
  
  has _term_attrs_debug_info => (is => 'rw', default=>sub{ {} });
  
  has term_width => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          if ($ENV{COLUMNS}) {
              $self->{_term_attrs_debug_info}{term_width_from} = 'COLUMNS env';
              return $ENV{COLUMNS};
          }
          my ($termw, undef) = $self->_term_size;
          if ($termw) {
              $self->{_term_attrs_debug_info}{term_width_from} = 'term_size';
          } else {
              # sane default, on windows printing to rightmost column causes
              # cursor to move to the next line.
              $self->{_term_attrs_debug_info}{term_width_from} =
                  'hardcoded default';
              $termw = $^O =~ /Win/ ? 79 : 80;
          }
          $termw;
      },
  );
  
  has term_height => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          if ($ENV{LINES}) {
              $self->{_term_attrs_debug_info}{term_height_from} = 'LINES env';
              return $ENV{LINES};
          }
          my (undef, $termh) = $self->_term_size;
          if ($termh) {
              $self->{_term_attrs_debug_info}{term_height_from} = 'term_size';
          } else {
              $self->{_term_attrs_debug_info}{term_height_from} = 'default';
              # sane default
              $termh = 25;
          }
          $termh;
      },
  );
  
  1;
  #ABSTRACT: Role for terminal-related attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Term::App::Role::Attrs - Role for terminal-related attributes
  
  =head1 VERSION
  
  This document describes version 0.01 of Term::App::Role::Attrs (from Perl distribution Term-App-Roles), released on 2014-12-10.
  
  =head1 DESCRIPTION
  
  This role gives several options to turn on/off terminal-oriented features like
  whether to use UTF8 characters, whether to use colors, and color depth. Defaults
  are set from environment variables or by detecting terminal
  software/capabilities.
  
  =head1 ATTRIBUTES
  
  =head2 use_utf8 => BOOL (default: from env, or detected from terminal)
  
  The default is retrieved from environment: if C<UTF8> is set, it is used.
  Otherwise, the default is on if terminal emulator software supports Unicode
  I<and> language (LANG/LANGUAGE) setting has /utf-?8/i in it.
  
  =head2 use_box_chars => BOOL (default: from env, or detected from OS)
  
  Default is 0 for Windows.
  
  =head2 interactive => BOOL (default: from env, or detected from terminal)
  
  =head2 use_color => BOOL (default: from env, or detected from terminal)
  
  For convenience, this attribute is "linked" with C<color_depth>. Setting
  C<use_color> will also set C<color_depth> when the value is not ''/1/0 and
  matches color depth pattern. For example, setting C<use_color> to 256 or '8bit'
  will also set C<color_depth> to 256.
  
  =head2 color_depth => INT (or STR, default: from env, or detected from terminal)
  
  Get/set color depth. When setting, you can use string like '8 bit' or '24b' and
  it will be converted to 256 (2**8) or 16777216 (2**24).
  
  For convenience, this attribute is "linked" with C<use_color>. Setting
  C<color_depth> to non-zero value will enable C<use_color>, while setting it to 0
  will disable C<use_color>.
  
  =head2 term_width => INT (default: from env, or detected from terminal)
  
  =head2 term_height => INT (default: from env, or detected from terminal)
  
  =head1 METHODS
  
  =head2 detect_terminal() => HASH
  
  Call L<Term::Detect::Software>'s C<detect_terminal_cached>.
  
  =head1 ENVIRONMENT
  
  =over
  
  =item * UTF8 => BOOL
  
  Can be used to set C<use_utf8>.
  
  =item * INTERACTIVE => BOOL
  
  Can be used to set C<interactive>.
  
  =item * COLOR => BOOL (or INT or STR)
  
  Can be used to set C<use_color>. Can also be used to set C<color_depth> (if
  C<COLOR_DEPTH> is not defined).
  
  =item * COLOR_DEPTH => INT (or STR)
  
  Can be used to set C<color_depth>. Can also be used to enable/disable
  C<use_color>.
  
  =item * BOX_CHARS => BOOL
  
  Can be used to set C<use_box_chars>.
  
  =item * COLUMNS => INT
  
  Can be used to set C<term_width>.
  
  =item * LINES => INT
  
  Can be used to set C<term_height>.
  
  =back
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Term-App-Roles>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Term-App-Roles>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Term-App-Roles>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TERM_APP_ROLE_ATTRS

$fatpacked{"Term/App/Roles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_APP_ROLES';
  package Term::App::Roles;
  
  our $DATE = '2014-12-10'; # DATE
  our $VERSION = '0.01'; # VERSION
  
  1;
  #ABSTRACT: Collection of roles for terminal-based application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Term::App::Roles - Collection of roles for terminal-based application
  
  =head1 VERSION
  
  This document describes version 0.01 of Term::App::Roles (from Perl distribution Term-App-Roles), released on 2014-12-10.
  
  =head1 DESCRIPTION
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Term-App-Roles>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Term-App-Roles>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Term-App-Roles>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TERM_APP_ROLES

$fatpacked{"Text/ANSITable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_ANSITABLE';
  package Text::ANSITable;
  
  our $DATE = '2018-05-31'; # DATE
  our $VERSION = '0.500'; # VERSION
  
  use 5.010001;
  use Carp;
  use Log::ger;
  use Moo;
  use experimental 'smartmatch';
  
  #use List::Util qw(first);
  use Scalar::Util 'looks_like_number';
  require Win32::Console::ANSI if $^O =~ /Win/;
  
  my $ATTRS = [qw(
  
                    use_color color_depth use_box_chars use_utf8 columns rows
                    column_filter row_filter show_row_separator show_header
                    show_header cell_width cell_height cell_pad cell_lpad
                    cell_rpad cell_vpad cell_tpad cell_bpad cell_fgcolor
                    cell_bgcolor cell_align cell_valign header_align header_valign
                    header_vpad header_tpad header_bpad header_fgcolor
                    header_bgcolor color_theme_args border_style_args
  
            )];
  my $STYLES = $ATTRS;
  my $COLUMN_STYLES = [qw(
  
                            type width align valign pad lpad rpad formats fgcolor
                            bgcolor wrap
  
                    )];
  my $ROW_STYLES = [qw(
  
                         height align valign vpad tpad bpad fgcolor bgcolor
  
                 )];
  my $CELL_STYLES = [qw(
  
                          align valign formats fgcolor bgcolor
  
                  )];
  
  has columns => (
      is      => 'rw',
      default => sub { [] },
      trigger => sub {
          my $self = shift;
          $self->{_columns_set}++;
      },
  );
  has rows => (
      is      => 'rw',
      default => sub { [] },
      trigger => sub {
          my ($self, $rows) = @_;
          $self->_set_default_cols($rows->[0]);
      },
  );
  has column_filter => (
      is => 'rw',
  );
  has column_wrap => (
      is => 'rw',
  );
  has row_filter => (
      is => 'rw',
  );
  has _row_separators => ( # [index after which sep should be drawn, ...] sorted
      is      => 'rw',
      default => sub { [] },
  );
  has show_row_separator => (
      is      => 'rw',
      default => sub { 2 },
  );
  has show_header => (
      is      => 'rw',
      default => sub { 1 },
  );
  
  has _column_styles => ( # store per-column styles
      is      => 'rw',
      default => sub { [] },
  );
  has _row_styles => ( # store per-row styles
      is      => 'rw',
      default => sub { [] },
  );
  has _cell_styles => ( # store per-cell styles
      is      => 'rw',
      default => sub { [] },
  );
  
  # each element of _cond_*styles is a two-element [$cond, ], where $cond is code
  # (str|coderef) and the second element is a hashref containing styles.
  
  has _cond_column_styles => ( # store conditional column styles
      is      => 'rw',
      default => sub { [] },
  );
  has _cond_row_styles => ( # store conditional row styles
      is      => 'rw',
      default => sub { [] },
  );
  has _cond_cell_styles => ( # store conditional cell styles
      is      => 'rw',
      default => sub { [] },
  );
  
  has cell_width => (
      is      => 'rw',
  );
  has cell_height => (
      is      => 'rw',
  );
  has cell_pad => (
      is      => 'rw',
      default => sub { 1 },
  );
  has cell_lpad => (
      is      => 'rw',
  );
  has cell_rpad => (
      is      => 'rw',
  );
  has cell_vpad => (
      is      => 'rw',
      default => sub { 0 },
  );
  has cell_tpad => (
      is      => 'rw',
  );
  has cell_bpad => (
      is      => 'rw',
  );
  has cell_fgcolor => (
      is => 'rw',
  );
  has cell_bgcolor => (
      is => 'rw',
  );
  has cell_align => (
      is => 'rw',
  );
  has cell_valign => (
      is => 'rw',
  );
  
  has header_align => (
      is      => 'rw',
  );
  has header_valign => (
      is      => 'rw',
  );
  has header_vpad => (
      is      => 'rw',
  );
  has header_tpad => (
      is      => 'rw',
  );
  has header_bpad => (
      is      => 'rw',
  );
  has header_fgcolor => (
      is      => 'rw',
  );
  has header_bgcolor => (
      is      => 'rw',
  );
  
  with 'Border::Style::Role';
  with 'Color::Theme::Role::ANSI';
  with 'Term::App::Role::Attrs';
  
  sub BUILD {
      my ($self, $args) = @_;
  
      if ($ENV{ANSITABLE_STYLE_SETS}) {
          require JSON::MaybeXS;
          my $sets = JSON::MaybeXS::decode_json($ENV{ANSITABLE_STYLE_SETS});
          croak "ANSITABLE_STYLE_SETS must be an array"
              unless ref($sets) eq 'ARRAY';
          for my $set (@$sets) {
              if (ref($set) eq 'ARRAY') {
                  $self->apply_style_set($set->[0], $set->[1]);
              } else {
                  $self->apply_style_set($set);
              }
          }
      }
  
      if ($ENV{ANSITABLE_STYLE}) {
          require JSON::MaybeXS;
          my $s = JSON::MaybeXS::decode_json($ENV{ANSITABLE_STYLE});
          for my $k (keys %$s) {
              my $v = $s->{$k};
              croak "Unknown table style '$k' in ANSITABLE_STYLE environment, ".
                  "please use one of [".join(", ", @$STYLES)."]"
                      unless $k ~~ $STYLES;
              $self->{$k} = $v;
          }
      }
  
      # set "pseudo"-attributes, they are not declared using 'has' so Moo doesn't
      # set them and we need to set them manually
      if ($args->{border_style}) { $self->border_style($args->{border_style}) }
      if ($args->{color_theme}) { $self->color_theme($args->{color_theme}) }
  
      # pick a default border style
      unless ($self->{border_style}) {
          my $bs;
  
          my $use_utf8 = $self->use_utf8;
  
          # even though Term::Detect::Software decides that linux virtual console
          # does not support unicode, it actually can display some uni characters
          # like single borders, so we use it as the default here instead of
          # singleo_ascii (linux vc doesn't seem to support box_chars).
          my $emu_eng  = $self->detect_terminal->{emulator_engine} // '';
          my $linux_vc = $emu_eng eq 'linux' && !defined($ENV{UTF8});
          if ($linux_vc) {
              $use_utf8 = 1;
              $bs = 'Default::singleo_utf8';
          }
          # use statement modifier style to avoid block and make local work
          local $self->{use_utf8} = 1 if $linux_vc;
  
          # we only default to utf8 border if user has set something like
          # binmode(STDOUT, ":utf8") to avoid 'Wide character in print' warning.
          unless (defined $ENV{UTF8}) {
              require PerlIO;
              my @layers = PerlIO::get_layers(STDOUT);
              $use_utf8 = 0 unless 'utf8' ~~ @layers;
          }
  
          if (defined $ENV{ANSITABLE_BORDER_STYLE}) {
              $bs = $ENV{ANSITABLE_BORDER_STYLE};
          } elsif ($use_utf8) {
              $bs //= 'Default::bricko';
          } elsif ($self->use_box_chars) {
              $bs = 'Default::singleo_boxchar';
          } else {
              $bs = 'Default::singleo_ascii';
          }
  
          $self->border_style($bs);
      }
  
      # pick a default color theme
      unless ($self->{color_theme}) {
          my $ct;
          if (defined $ENV{ANSITABLE_COLOR_THEME}) {
              $ct = $ENV{ANSITABLE_COLOR_THEME};
          } elsif ($self->use_color) {
              my $bg = $self->detect_terminal->{default_bgcolor} // '';
              if ($self->color_depth >= 2**24) {
                  $ct = 'Default::default_gradation' .
                      ($bg eq 'ffffff' ? '_whitebg' : '');
              } else {
                  $ct = 'Default::default_nogradation' .
                      ($bg eq 'ffffff' ? '_whitebg' : '');;
              }
          } else {
              $ct = 'Default::no_color';
          }
          $self->color_theme($ct);
      }
  
      unless (defined $self->{wide}) {
          $self->{wide} = eval { require Text::ANSI::WideUtil; 1 } ? 1:0;
      }
      require Text::ANSI::Util;
      $self->{_func_add_color_resets} = \&Text::ANSI::Util::ta_add_color_resets;
      if ($self->{wide}) {
          require Text::ANSI::WideUtil;
          $self->{_func_length_height} = \&Text::ANSI::WideUtil::ta_mbswidth_height;
          $self->{_func_pad}           = \&Text::ANSI::WideUtil::ta_mbpad;
          $self->{_func_wrap}          = \&Text::ANSI::WideUtil::ta_mbwrap;
      } else {
          $self->{_func_length_height} = \&Text::ANSI::Util::ta_length_height;
          $self->{_func_pad}           = \&Text::ANSI::Util::ta_pad;
          $self->{_func_wrap}          = \&Text::ANSI::Util::ta_wrap;
      }
  }
  
  sub _set_default_cols {
      my ($self, $row) = @_;
      return if $self->{_columns_set}++;
      $self->columns([map {"col$_"} 0..@$row-1]) if $row;
  }
  
  sub add_row {
      my ($self, $row, $styles) = @_;
      croak "Row must be arrayref" unless ref($row) eq 'ARRAY';
      push @{ $self->{rows} }, $row;
      $self->_set_default_cols($row) unless $self->{_columns_set}++;
      if ($styles) {
          my $i = @{ $self->{rows} }-1;
          for my $s (keys %$styles) {
              $self->set_row_style($i, $s, $styles->{$s});
          }
      }
      $self;
  }
  
  sub add_row_separator {
      my ($self) = @_;
      my $idx = ~~@{$self->{rows}}-1;
      # ignore duplicate separators
      push @{ $self->{_row_separators} }, $idx
          unless @{ $self->{_row_separators} } &&
              $self->{_row_separators}[-1] == $idx;
      $self;
  }
  
  sub add_rows {
      my ($self, $rows, $styles) = @_;
      croak "Rows must be arrayref" unless ref($rows) eq 'ARRAY';
      $self->add_row($_, $styles) for @$rows;
      $self;
  }
  
  sub _colnum {
      my $self = shift;
      my $colname = shift;
  
      return $colname if looks_like_number($colname);
      my $cols = $self->{columns};
      for my $i (0..@$cols-1) {
          return $i if $cols->[$i] eq $colname;
      }
      croak "Unknown column name '$colname'";
  }
  
  sub get_cell {
      my ($self, $row_num, $col) = @_;
  
      $col = $self->_colnum($col);
  
      $self->{rows}[$row_num][$col];
  }
  
  sub set_cell {
      my ($self, $row_num, $col, $val) = @_;
  
      $col = $self->_colnum($col);
  
      my $oldval = $self->{rows}[$row_num][$col];
      $self->{rows}[$row_num][$col] = $val;
      $oldval;
  }
  
  sub get_column_style {
      my ($self, $col, $style) = @_;
  
      $col = $self->_colnum($col);
      $self->{_column_styles}[$col]{$style};
  }
  
  sub set_column_style {
      my $self = shift;
      my $col  = shift;
  
      $col = $self->_colnum($col);
  
      my %sets = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
      for my $style (keys %sets) {
          my $val = $sets{$style};
          croak "Unknown per-column style '$style', please use one of [".
              join(", ", @$COLUMN_STYLES) . "]" unless $style ~~ $COLUMN_STYLES;
          $self->{_column_styles}[$col]{$style} = $val;
      }
  }
  
  sub get_cond_column_styles {
      my $self = shift;
      $self->{_cond_column_styles};
  }
  
  #sub set_cond_column_style {
  #    my ($self, $styles) = @_;
  #    $self->{_cond_column_styles} = $styles;
  #}
  
  sub add_cond_column_style {
      my $self = shift;
      my $cond = shift;
      if (ref($cond) ne 'CODE') {
          croak "cond must be a coderef";
      }
  
      my $styles;
      if (ref($_[0]) eq 'HASH') {
          $styles = shift;
      } else {
          $styles = { @_ };
      }
  
      for my $style (keys %$styles) {
          croak "Unknown per-column style '$style', please use one of [".
              join(", ", @$COLUMN_STYLES) . "]" unless $style ~~ $COLUMN_STYLES;
      }
  
      push @{ $self->{_cond_column_styles} }, [$cond, $styles];
  }
  
  #sub clear_cond_column_styles {
  #    my $self = shift;
  #    $self->{_cond_column_styles} = [];
  #}
  
  sub get_eff_column_style {
      my ($self, $col, $style) = @_;
  
      $col = $self->_colnum($col);
  
      # the result of calculation is cached here
      if (defined $self->{_draw}{eff_column_styles}[$col]) {
          return $self->{_draw}{eff_column_styles}[$col]{$style};
      }
  
      my $cols = $self->{columns};
      my %styles;
  
      # apply conditional styles
    COND:
      for my $ei (0..@{ $self->{_cond_column_styles} }-1) {
          my $e = $self->{_cond_column_styles}[$ei];
          local $_ = $col;
          my $res = $e->[0]->(
              $self,
              col     => $col,
              colname => $cols->[$col],
          );
          next COND unless $res;
          if (ref($res) eq 'HASH') {
              $styles{$_} = $res->{$_} for keys %$res;
          }
          $styles{$_} = $e->[1]{$_} for keys %{ $e->[1] };
      }
  
      # apply per-column styles
      my $rss = $self->{_column_styles}[$col];
      if ($rss) {
          $styles{$_} = $rss->{$_} for keys %$rss;
      }
  
      $self->{_draw}{eff_column_styles}[$col] = \%styles;
  
      $styles{$style};
  }
  
  sub get_row_style {
      my ($self, $row, $style) = @_;
  
      $self->{_row_styles}[$row]{$style};
  }
  
  sub set_row_style {
      my $self = shift;
      my $row  = shift;
  
      my %sets = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
      for my $style (keys %sets) {
          my $val = $sets{$style};
          croak "Unknown per-row style '$style', please use one of [".
              join(", ", @$ROW_STYLES) . "]" unless $style ~~ $ROW_STYLES;
          $self->{_row_styles}[$row]{$style} = $val;
      }
  }
  
  sub get_cond_row_styles {
      my $self = shift;
      $self->{_cond_row_styles};
  }
  
  #sub set_cond_row_style {
  #    my ($self, $styles) = @_;
  #    $self->{_cond_row_styles} = $styles;
  #}
  
  sub add_cond_row_style {
      my $self = shift;
      my $cond = shift;
      if (ref($cond) ne 'CODE') {
          croak "cond must be a coderef";
      }
  
      my $styles;
      if (ref($_[0]) eq 'HASH') {
          $styles = shift;
      } else {
          $styles = { @_ };
      }
  
      for my $style (keys %$styles) {
          croak "Unknown per-row style '$style', please use one of [".
              join(", ", @$ROW_STYLES) . "]" unless $style ~~ $ROW_STYLES;
      }
  
      push @{ $self->{_cond_row_styles} }, [$cond, $styles];
  }
  
  #sub clear_cond_row_styles {
  #    my $self = shift;
  #    $self->{_cond_row_styles} = [];
  #}
  
  sub get_eff_row_style {
      my ($self, $row, $style) = @_;
  
      # the result of calculation is cached here
      if (defined $self->{_draw}{eff_row_styles}[$row]) {
          return $self->{_draw}{eff_row_styles}[$row]{$style};
      }
  
      my $rows = $self->{rows};
      my %styles;
  
      # apply conditional styles
    COND:
      for my $ei (0..@{ $self->{_cond_row_styles} }-1) {
          my $e = $self->{_cond_row_styles}[$ei];
          local $_ = $row;
          my $res = $e->[0]->(
              $self,
              row      => $row,
              row_data => $rows->[$row],
          );
          next COND unless $res;
          if (ref($res) eq 'HASH') {
              $styles{$_} = $res->{$_} for keys %$res;
          }
          $styles{$_} = $e->[1]{$_} for keys %{ $e->[1] };
      }
  
      # apply per-row styles
      my $rss = $self->{_row_styles}[$row];
      if ($rss) {
          $styles{$_} = $rss->{$_} for keys %$rss;
      }
  
      $self->{_draw}{eff_row_styles}[$row] = \%styles;
  
      $styles{$style};
  }
  
  sub get_cell_style {
      my ($self, $row, $col, $style) = @_;
  
      $col = $self->_colnum($col);
      $self->{_cell_styles}[$row][$col]{$style};
  }
  
  sub set_cell_style {
      my $self = shift;
      my $row  = shift;
      my $col  = shift;
  
      $col = $self->_colnum($col);
  
      my %sets = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
      for my $style (keys %sets) {
          my $val = $sets{$style};
          croak "Unknown per-cell style '$style', please use one of [".
              join(", ", @$CELL_STYLES) . "]" unless $style ~~ $CELL_STYLES;
          $self->{_cell_styles}[$row][$col]{$style} = $val;
      }
  }
  
  sub get_cond_cell_styles {
      my $self = shift;
      $self->{_cond_cell_styles};
  }
  
  #sub set_cond_cell_style {
  #    my ($self, $styles) = @_;
  #    $self->{_cond_cell_styles} = $styles;
  #}
  
  sub add_cond_cell_style {
      my $self = shift;
      my $cond = shift;
      if (ref($cond) ne 'CODE') {
          croak "cond must be a coderef";
      }
  
      my $styles;
      if (ref($_[0]) eq 'HASH') {
          $styles = shift;
      } else {
          $styles = { @_ };
      }
  
      for my $style (keys %$styles) {
          croak "Unknown per-cell style '$style', please use one of [".
              join(", ", @$CELL_STYLES) . "]" unless $style ~~ $CELL_STYLES;
      }
  
      push @{ $self->{_cond_cell_styles} }, [$cond, $styles];
  }
  
  #sub clear_cond_cell_styles {
  #    my $self = shift;
  #    $self->{_cond_cell_styles} = [];
  #}
  
  sub get_eff_cell_style {
      my ($self, $row, $col, $style) = @_;
  
      # the result of calculation is cached here
      if (defined $self->{_draw}{eff_cell_styles}[$row][$col]) {
          return $self->{_draw}{eff_cell_styles}[$row][$col]{$style};
      }
  
      my $rows = $self->{rows};
      my %styles;
  
      # apply conditional styles
    COND:
      for my $ei (0..@{ $self->{_cond_cell_styles} }-1) {
          my $e = $self->{_cond_cell_styles}[$ei];
          local $_ = $rows->[$row][$col];
          my $res = $e->[0]->(
              $self,
              content  => $_,
              col      => $col,
              row      => $row,
              row_data => $rows->[$row],
          );
          next COND unless $res;
          if (ref($res) eq 'HASH') {
              $styles{$_} = $res->{$_} for keys %$res;
          }
          $styles{$_} = $e->[1]{$_} for keys %{ $e->[1] };
      }
  
      # apply per-cell styles
      my $css = $self->{_cell_styles}[$row][$col];
      if ($css) {
          $styles{$_} = $css->{$_} for keys %$css;
      }
  
      $self->{_draw}{eff_cell_styles}[$row][$col] = \%styles;
  
      $styles{$style};
  }
  
  sub apply_style_set {
      my $self = shift;
      my $name = shift;
      $name =~ /\A[A-Za-z0-9_]+(?:::[A-Za-z0-9_]+)*\z/
          or croak "Invalid style set name, please use alphanums only";
      {
          my $name = $name;
          $name =~ s!::!/!g;
          require "Text/ANSITable/StyleSet/$name.pm";
      }
      my %args = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
      my $obj = "Text::ANSITable::StyleSet::$name"->new(%args);
      $obj->apply($self);
  }
  
  sub list_style_sets {
      require Module::List;
      require Module::Load;
      require Package::MoreUtil;
  
      my ($self, $detail) = @_;
  
      my $prefix = (ref($self) ? ref($self) : $self ) .
          '::StyleSet'; # XXX allow override
      my $all_sets = $self->{_all_style_sets};
  
      if (!$all_sets) {
          my $mods = Module::List::list_modules("$prefix\::",
                                                {list_modules=>1, recurse=>1});
          $all_sets = {};
          for my $mod (sort keys %$mods) {
              #$log->tracef("Loading style set module '%s' ...", $mod);
              Module::Load::load($mod);
              my $name = $mod; $name =~ s/\A\Q$prefix\:://;
              my $summary = $mod->summary;
              # we don't have meta, so dig it ourselves
              my %ct = Package::MoreUtil::list_package_contents($mod);
              my $args = [sort grep {!/\W/ && !/\A(new|summary|apply)\z/}
                              keys %ct];
              $all_sets->{$name} = {name=>$name, summary=>$summary, args=>$args};
          }
          $self->{_all_style_sets} = $all_sets;
      }
  
      if ($detail) {
          return $all_sets;
      } else {
          return (sort keys %$all_sets);
      }
  }
  
  # read environment variables for style, this will only be done once per object
  sub _read_style_envs {
      my $self = shift;
  
      next if $self->{_read_style_envs}++;
  
      if ($ENV{ANSITABLE_COLUMN_STYLES}) {
          require JSON::MaybeXS;
          my $ss = JSON::MaybeXS::decode_json($ENV{ANSITABLE_COLUMN_STYLES});
          croak "ANSITABLE_COLUMN_STYLES must be a hash"
              unless ref($ss) eq 'HASH';
          for my $col (keys %$ss) {
              my $ci = $self->_colnum($col);
              my $s = $ss->{$col};
              for my $k (keys %$s) {
                  my $v = $s->{$k};
              croak "Unknown column style '$k' (for column $col) in ".
                  "ANSITABLE_COLUMN_STYLES environment, ".
                      "please use one of [".join(", ", @$COLUMN_STYLES)."]"
                          unless $k ~~ $COLUMN_STYLES;
                  $self->{_column_styles}[$ci]{$k} //= $v;
              }
          }
      }
  
      if ($ENV{ANSITABLE_ROW_STYLES}) {
          require JSON::MaybeXS;
          my $ss = JSON::MaybeXS::decode_json($ENV{ANSITABLE_ROW_STYLES});
          croak "ANSITABLE_ROW_STYLES must be a hash"
              unless ref($ss) eq 'HASH';
          for my $row (keys %$ss) {
              my $s = $ss->{$row};
              for my $k (keys %$s) {
                  my $v = $s->{$k};
              croak "Unknown row style '$k' (for row $row) in ".
                  "ANSITABLE_ROW_STYLES environment, ".
                      "please use one of [".join(", ", @$ROW_STYLES)."]"
                          unless $k ~~ $ROW_STYLES;
                  $self->{_row_styles}[$row]{$k} //= $v;
              }
          }
      }
  
      if ($ENV{ANSITABLE_CELL_STYLES}) {
          require JSON::MaybeXS;
          my $ss = JSON::MaybeXS::decode_json($ENV{ANSITABLE_CELL_STYLES});
          croak "ANSITABLE_CELL_STYLES must be a hash"
              unless ref($ss) eq 'HASH';
          for my $cell (keys %$ss) {
              croak "Invalid cell specification in ANSITABLE_CELL_STYLES: ".
                  "$cell, please use 'row,col'"
                      unless $cell =~ /^(.+),(.+)$/;
              my $row = $1;
              my $col = $2;
              my $ci = $self->_colnum($col);
              my $s = $ss->{$cell};
              for my $k (keys %$s) {
                  my $v = $s->{$k};
              croak "Unknown cell style '$k' (for cell $row,$col) in ".
                  "ANSITABLE_CELL_STYLES environment, ".
                      "please use one of [".join(", ", @$CELL_STYLES)."]"
                          unless $k ~~ $CELL_STYLES;
                  $self->{_cell_styles}[$row][$ci]{$k} //= $v;
              }
          }
      }
  }
  
  # determine which columns to show (due to column_filter)
  sub _calc_fcols {
      my $self = shift;
  
      my $cols = $self->{columns};
      my $cf   = $self->{column_filter};
  
      my $fcols;
      if (ref($cf) eq 'CODE') {
          $fcols = [grep {$cf->($_)} @$cols];
      } elsif (ref($cf) eq 'ARRAY') {
          $fcols = [grep {defined} map {looks_like_number($_) ?
                                            $cols->[$_] : $_} @$cf];
      } else {
          $fcols = $cols;
      }
      $self->{_draw}{fcols} = $fcols;
  }
  
  # calculate widths/heights of header, store width settings, column [lr]pads
  sub _calc_header_height {
      my $self = shift;
  
      my $cols  = $self->{columns};
      my $fcols = $self->{_draw}{fcols};
  
      my $fcol_widths = []; # index = [colnum]
      my $header_height = 1;
      my $fcol_lpads  = []; # index = [colnum]
      my $fcol_rpads  = []; # ditto
      my $fcol_setwidths  = []; # index = [colnum], from cell_width/col width
      my $frow_setheights = []; # index = [frownum], from cell_height/row height
  
      my %seen;
      my $lpad = $self->{cell_lpad} // $self->{cell_pad}; # tbl-lvl leftp
      my $rpad = $self->{cell_rpad} // $self->{cell_pad}; # tbl-lvl rightp
      for my $i (0..@$cols-1) {
          next unless $cols->[$i] ~~ $fcols;
          next if $seen{$cols->[$i]}++;
  
          $fcol_setwidths->[$i] = $self->get_eff_column_style($i, 'width') //
              $self->{cell_width};
          my $wh = $self->_opt_calc_cell_width_height(undef, $i, $cols->[$i]);
          $fcol_widths->[$i] = $wh->[0];
          $header_height = $wh->[1]
              if !defined($header_height) || $header_height < $wh->[1];
          $fcol_lpads->[$i] = $self->get_eff_column_style($i, 'lpad') //
              $self->get_eff_column_style($i, 'pad') // $lpad;
          $fcol_rpads->[$i] = $self->get_eff_column_style($i, 'rpad') //
              $self->get_eff_column_style($i, 'pad') // $rpad;
      }
  
      $self->{_draw}{header_height}   = $header_height;
      $self->{_draw}{fcol_lpads}      = $fcol_lpads;
      $self->{_draw}{fcol_rpads}      = $fcol_rpads;
      $self->{_draw}{fcol_setwidths}  = $fcol_setwidths;
      $self->{_draw}{frow_setheights} = $frow_setheights;
      $self->{_draw}{fcol_widths}     = $fcol_widths;
  }
  
  # determine which rows to show, calculate vertical paddings of data rows, store
  # height settings
  sub _calc_frows {
      my $self = shift;
  
      my $rows = $self->{rows};
      my $rf   = $self->{row_filter};
      my $frow_setheights = $self->{_draw}{frow_setheights};
  
      my $frow_tpads  = []; # index = [frownum]
      my $frow_bpads  = []; # ditto
      my $frows = [];
      my $frow_separators = [];
      my $frow_orig_indices = []; # needed when accessing original row data
  
      my $tpad = $self->{cell_tpad} // $self->{cell_vpad}; # tbl-lvl top pad
      my $bpad = $self->{cell_bpad} // $self->{cell_vpad}; # tbl-lvl botom pad
      my $i = -1;
      my $j = -1;
      for my $row (@$rows) {
          $i++;
          if (ref($rf) eq 'CODE') {
              next unless $rf->($row, $i);
          } elsif ($rf) {
              next unless $i ~~ $rf;
          }
          $j++;
          push @$frow_setheights, $self->get_eff_row_style($i, 'height') //
              $self->{cell_height};
          push @$frows, [@$row]; # 1-level clone, for storing formatted values
          push @$frow_separators, $j if $i ~~ $self->{_row_separators};
          push @$frow_tpads, $self->get_eff_row_style($i, 'tpad') //
              $self->get_eff_row_style($i, 'vpad') // $tpad;
          push @$frow_bpads, $self->get_eff_row_style($i, 'bpad') //
              $self->get_eff_row_style($i, 'vpad') // $bpad;
          push @$frow_orig_indices, $i;
      }
  
      $self->{_draw}{frows}             = $frows;
      $self->{_draw}{frow_separators}   = $frow_separators;
      $self->{_draw}{frow_tpads}        = $frow_tpads;
      $self->{_draw}{frow_bpads}        = $frow_bpads;
      $self->{_draw}{frow_orig_indices} = $frow_orig_indices;
  }
  
  # detect column type from data/header name. assign default column align, valign,
  # fgcolor, bgcolor, formats.
  sub _detect_column_types {
      my $self = shift;
  
      my $cols = $self->{columns};
      my $rows = $self->{rows};
      my $ct   = $self->{color_theme};
  
      my $fcol_detect = [];
      my %seen;
      for my $i (0..@$cols-1) {
          my $col = $cols->[$i];
          my $res = {};
          $fcol_detect->[$i] = $res;
  
          # optim: skip detecting columns we're not showing
          next unless $col ~~ $self->{_draw}{fcols};
  
          # but detect from all rows, not just ones we're showing
          my $type = $self->get_eff_column_style($col, 'type');
          my $subtype;
        DETECT:
          {
              last DETECT if $type;
              if ($col =~ /^(can|is|has|does)_|\?$/) {
                  $type = 'bool';
                  last DETECT;
              }
  
              require Parse::VarName;
              my @words = map {lc} @{ Parse::VarName::split_varname_words(
                  varname=>$col) };
              for (qw/date time ctime mtime utime atime stime/) {
                  if ($_ ~~ @words) {
                      $type = 'date';
                      last DETECT;
                  }
              }
  
              my $pass = 1;
              for my $j (0..@$rows) {
                  my $v = $rows->[$j][$i];
                  next unless defined($v);
                  do { $pass=0; last } unless looks_like_number($v);
              }
              if ($pass) {
                  $type = 'num';
                  if ($col =~ /(pct|percent(?:age))\b|\%/) {
                      $subtype = 'pct';
                  }
                  last DETECT;
              }
              $type = 'str';
          } # DETECT
  
          $res->{type} = $type;
          if ($type eq 'bool') {
              $res->{align}   = 'center';
              $res->{valign}  = 'center';
              $res->{fgcolor} = $ct->{colors}{bool_data};
              $res->{formats} = [[bool => {style => $self->{use_utf8} ?
                                               "check_cross" : "Y_N"}]];
          } elsif ($type eq 'date') {
              $res->{align}   = 'middle';
              $res->{fgcolor} = $ct->{colors}{date_data};
              $res->{formats} = [['date' => {}]];
          } elsif ($type =~ /\A(num|float|int)\z/) {
              $res->{align}   = 'right';
              $res->{fgcolor} = $ct->{colors}{num_data};
              if (($subtype//"") eq 'pct') {
                  $res->{formats} = [[num => {style=>'percent'}]];
              }
          } else {
              $res->{fgcolor} = $ct->{colors}{str_data};
              $res->{wrap}    = $ENV{WRAP} // 1;
          }
      }
  
      #use Data::Dump; print "D:fcol_detect: "; dd $fcol_detect;
      $self->{_draw}{fcol_detect} = $fcol_detect;
  }
  
  # calculate width and height of a cell, but skip calculating (to save some
  # cycles) if width is already set by frow_setheights / fcol_setwidths.
  sub _opt_calc_cell_width_height {
      my ($self, $frow_num, $col, $text) = @_;
  
      $col = $self->_colnum($col);
      my $setw  = $self->{_draw}{fcol_setwidths}[$col];
      my $calcw = !defined($setw) || $setw < 0;
      my $seth  = defined($frow_num) ?
          $self->{_draw}{frow_setheights}[$frow_num] : undef;
      my $calch = !defined($seth) || $seth < 0;
  
      my $wh;
      if ($calcw) {
          $wh = $self->{_func_length_height}->($text);
          $wh->[0] = -$setw if defined($setw) && $setw<0 && $wh->[0] < -$setw;
          $wh->[1] = $seth if !$calch;
          $wh->[1] = -$seth if defined($seth) && $seth<0 && $wh->[1] < -$seth;
      } elsif ($calch) {
          my $h = 1; $h++ while $text =~ /\n/go;
          $h = -$seth if defined($seth) && $seth<0 && $h < -$seth;
          $wh = [$setw, $h];
      } else {
          $wh = [$setw, $seth];
      }
      #say "D:_opt_calc_cell_width_height(", $frow_num//"undef", ", $col) = $wh->[0], $wh->[1]";
      $wh;
  }
  
  sub _apply_column_formats {
      my $self = shift;
  
      my $cols  = $self->{columns};
      my $frows = $self->{_draw}{frows};
      my $fcols = $self->{_draw}{fcols};
      my $fcol_detect = $self->{_draw}{fcol_detect};
  
      my %seen;
      for my $i (0..@$cols-1) {
          next unless $cols->[$i] ~~ $fcols;
          next if $seen{$cols->[$i]}++;
          my @fmts = @{ $self->get_eff_column_style($i, 'formats') //
                            $fcol_detect->[$i]{formats} // [] };
          if (@fmts) {
              require Data::Unixish::Apply;
              my $res = Data::Unixish::Apply::apply(
                  in => [map {$frows->[$_][$i]} 0..@$frows-1],
                  functions => \@fmts,
              );
              croak "Can't format column $cols->[$i]: $res->[0] - $res->[1]"
                  unless $res->[0] == 200;
              $res = $res->[2];
              for (0..@$frows-1) { $frows->[$_][$i] = $res->[$_] // "" }
          } else {
              # change null to ''
              for (0..@$frows-1) { $frows->[$_][$i] //= "" }
          }
      }
  }
  
  sub _apply_cell_formats {
      my $self = shift;
  
      my $cols  = $self->{columns};
      my $rows  = $self->{rows};
      my $fcols = $self->{_draw}{fcols};
      my $frows = $self->{_draw}{frows};
      my $frow_orig_indices = $self->{_draw}{frow_orig_indices};
  
      for my $i (0..@$frows-1) {
          my %seen;
          my $origi = $frow_orig_indices->[$i];
          for my $j (0..@$cols-1) {
              next unless $cols->[$j] ~~ $fcols;
              next if $seen{$cols->[$j]}++;
  
              my $fmts = $self->get_eff_cell_style($origi, $j, 'formats');
              if (defined $fmts) {
                  require Data::Unixish::Apply;
                  my $res = Data::Unixish::Apply::apply(
                      in => [ $frows->[$i][$j] ],
                      functions => $fmts,
                  );
                  croak "Can't format cell ($origi, $cols->[$j]): ".
                      "$res->[0] - $res->[1]" unless $res->[0] == 200;
                  $frows->[$i][$j] = $res->[2][0] // "";
              }
          } # col
      }
  }
  
  sub _calc_row_widths_heights {
      my $self = shift;
  
      my $cols  = $self->{columns};
      my $fcols = $self->{_draw}{fcols};
      my $frows = $self->{_draw}{frows};
  
      my $frow_heights = [];
      my $fcol_widths  = $self->{_draw}{fcol_widths};
      my $frow_orig_indices = $self->{_draw}{frow_orig_indices};
  
      my $height = $self->{cell_height};
      my $tpad = $self->{cell_tpad} // $self->{cell_vpad}; # tbl-lvl tpad
      my $bpad = $self->{cell_bpad} // $self->{cell_vpad}; # tbl-lvl bpad
      my $cswidths = [map {$self->get_eff_column_style($_, 'width')} 0..@$cols-1];
      for my $i (0..@$frows-1) {
          my %seen;
          my $origi = $frow_orig_indices->[$i];
          my $rsheight = $self->get_eff_row_style($origi, 'height');
          for my $j (0..@$cols-1) {
              next unless $cols->[$j] ~~ $fcols;
              next if $seen{$cols->[$j]}++;
  
              my $wh = $self->_opt_calc_cell_width_height($i,$j,$frows->[$i][$j]);
  
              $fcol_widths->[$j]  = $wh->[0] if $fcol_widths->[$j] < $wh->[0];
              $frow_heights->[$i] = $wh->[1] if !defined($frow_heights->[$i])
                  || $frow_heights->[$i] < $wh->[1];
          } # col
      }
      $self->{_draw}{frow_heights}  = $frow_heights;
  }
  
  sub _wrap_wrappable_columns {
      my $self = shift;
  
      my $cols  = $self->{columns};
      my $fcols = $self->{_draw}{fcols};
      my $frows = $self->{_draw}{frows};
      my $fcol_detect    = $self->{_draw}{fcol_detect};
      my $fcol_setwidths = $self->{_draw}{fcol_setwidths};
  
      my %seen;
      for my $i (0..@$cols-1) {
          next unless $cols->[$i] ~~ $fcols;
          next if $seen{$cols->[$i]}++;
  
          if (($self->get_eff_column_style($i, 'wrap') // $self->{column_wrap} //
                   $fcol_detect->[$i]{wrap}) &&
                       defined($fcol_setwidths->[$i]) &&
                           $fcol_setwidths->[$i]>0) {
              for (0..@$frows-1) {
                  $frows->[$_][$i] = $self->{_func_wrap}->(
                      $frows->[$_][$i], $fcol_setwidths->[$i]);
              }
          }
      }
  }
  
  sub _calc_table_width_height {
      my $self = shift;
  
      my $cols  = $self->{columns};
      my $fcols = $self->{_draw}{fcols};
      my $frows = $self->{_draw}{frows};
      my $fcol_widths  = $self->{_draw}{fcol_widths};
      my $fcol_lpads   = $self->{_draw}{fcol_lpads};
      my $fcol_rpads   = $self->{_draw}{fcol_rpads};
      my $frow_tpads   = $self->{_draw}{frow_tpads};
      my $frow_bpads   = $self->{_draw}{frow_bpads};
      my $frow_heights = $self->{_draw}{frow_heights};
  
      my $w = 0;
      $w += 1 if length($self->get_border_char(3, 0));
      my $has_vsep = length($self->get_border_char(3, 1));
      for my $i (0..@$cols-1) {
          next unless $cols->[$i] ~~ $fcols;
          $w += $fcol_lpads->[$i] + $fcol_widths->[$i] + $fcol_rpads->[$i];
          if ($i < @$cols-1) {
              $w += 1 if $has_vsep;
          }
      }
      $w += 1 if length($self->get_border_char(3, 2));
      $self->{_draw}{table_width}  = $w;
  
      my $h = 0;
      $h += 1 if length($self->get_border_char(0, 0)); # top border line
      $h += $self->{header_tpad} // $self->{header_vpad} //
          $self->{cell_tpad} // $self->{cell_vpad};
      $h += $self->{_draw}{header_height} // 0;
      $h += $self->{header_bpad} // $self->{header_vpad} //
          $self->{cell_bpad} // $self->{cell_vpad};
      $h += 1 if length($self->get_border_char(2, 0));
      for my $i (0..@$frows-1) {
          $h += ($frow_tpads->[$i] // 0) +
              ($frow_heights->[$i] // 0) +
                  ($frow_bpads->[$i] // 0);
          $h += 1 if $self->_should_draw_row_separator($i);
      }
      $h += 1 if length($self->get_border_char(5, 0));
      $self->{_draw}{table_height}  = $h;
  }
  
  # if there are text columns with no width set, and the column width is wider
  # than terminal, try to adjust widths so it fit into the terminal, if possible.
  # return 1 if widths (fcol_widths) adjusted.
  sub _adjust_column_widths {
      my $self = shift;
  
      # try to find wrappable columns that do not have their widths set. currently
      # the algorithm is not proper, it just targets columns which are wider than
      # a hard-coded value (30). it should take into account the longest word in
      # the content/header, but this will require another pass at the text to
      # analyze it.
  
      my $fcols = $self->{_draw}{fcols};
      my $frows = $self->{_draw}{frows};
      my $fcol_setwidths = $self->{_draw}{fcol_setwidths};
      my $fcol_detect    = $self->{_draw}{fcol_detect};
      my $fcol_widths    = $self->{_draw}{fcol_widths};
      my %acols;
      my %origw;
      for my $i (0..@$fcols-1) {
          my $ci = $self->_colnum($fcols->[$i]);
          next if defined($fcol_setwidths->[$ci]) && $fcol_setwidths->[$ci]>0;
          next if $fcol_widths->[$ci] < 30;
          next unless $self->get_eff_column_style($ci, 'wrap') //
              $self->{column_wrap} // $fcol_detect->[$ci]{wrap};
          $acols{$ci}++;
          $origw{$ci} = $fcol_widths->[$ci];
      }
      return 0 unless %acols;
  
      # only do this if table width exceeds terminal width
      my $termw = $self->term_width;
      return 0 unless $termw > 0;
      my $excess = $self->{_draw}{table_width} - $termw;
      return 0 unless $excess > 0;
  
      # reduce text columns proportionally
      my $w = 0; # total width of all to-be-adjusted columns
      $w += $fcol_widths->[$_] for keys %acols;
      return 0 unless $w > 0;
      my $reduced = 0;
    REDUCE:
      while (1) {
          my $has_reduced;
          for my $ci (keys %acols) {
              last REDUCE if $reduced >= $excess;
              if ($fcol_widths->[$ci] > 30) {
                  $fcol_widths->[$ci]--;
                  $reduced++;
                  $has_reduced++;
              }
          }
          last if !$has_reduced;
      }
  
      # reset widths
      for my $ci (keys %acols) {
          $fcol_setwidths->[$ci] = $fcol_widths->[$ci];
          $fcol_widths->[$ci] = 0; # reset
      }
  
      # wrap and set setwidths so it doesn't grow again during recalculate
      for my $ci (keys %acols) {
          next unless $origw{$ci} != $fcol_widths->[$ci];
          for (0..@$frows-1) {
              $frows->[$_][$ci] = $self->{_func_wrap}->(
                  $frows->[$_][$ci], $fcol_setwidths->[$ci]);
          }
      }
  
      # recalculate column widths
      $self->_calc_row_widths_heights;
      $self->_calc_table_width_height;
      1;
  }
  
  # filter columns & rows, calculate widths/paddings, format data, put the results
  # in _draw (draw data) attribute.
  sub _prepare_draw {
      my $self = shift;
  
      $self->{_draw} = {};
  
      $self->_read_style_envs;
      $self->_calc_fcols;
      $self->_calc_header_height;
      $self->_calc_frows;
      $self->_detect_column_types;
      $self->_apply_column_formats;
      $self->_apply_cell_formats;
      $self->_wrap_wrappable_columns;
      $self->_calc_row_widths_heights;
      $self->_calc_table_width_height;
      $self->_adjust_column_widths;
  }
  
  # push string into the drawing buffer. also updates "cursor" position.
  sub draw_str {
      my $self = shift;
      # currently x position is not recorded because this involves doing
      # ta_mbswidth() (or ta_mbswidth_height()) for every string, which is rather
      # expensive. so only the y position is recorded by counting newlines.
  
      for (@_) {
          my $num_nl = 0;
          $num_nl++ while /\r?\n/og;
          push @{$self->{_draw}{buf}}, $_;
          $self->{_draw}{y} += $num_nl;
      }
      $self;
  }
  
  sub draw_theme_color {
      my $self = shift;
      my $c = $self->get_theme_color_as_ansi(@_);
      $self->draw_str($c) if length($c);
  }
  
  sub get_color_reset {
      my $self = shift;
      return "" if $self->{color_theme}{no_color};
      "\e[0m";
  }
  
  sub draw_color_reset {
      my $self = shift;
      my $c = $self->get_color_reset;
      $self->draw_str($c) if length($c);
  }
  
  # draw border character(s). drawing border character involves setting border
  # color, setting drawing mode (for boxchar styles), aside from drawing the
  # actual characters themselves. arguments are list of (y, x, n) tuples where y
  # and x are the row and col number of border character, n is the number of
  # characters to print. n defaults to 1 if not specified.
  sub draw_border_char {
      my $self = shift;
      my $args; $args = shift if ref($_[0]) eq 'HASH';
  
      $self->draw_str($self->{_draw}{set_line_draw_mode});
      while (my ($y, $x, $n) = splice @_, 0, 3) {
          $n //= 1;
          if (!$self->{use_color}) {
              # save some CPU cycles
          } elsif ($args) {
              $self->draw_theme_color('border',
                                      {border=>[$y, $x, $n], %$args});
          } else {
              $self->draw_theme_color('border',
                                      {border=>[$y, $x, $n]});
          }
          $self->draw_str($self->get_border_char($y, $x, $n));
          $self->draw_color_reset;
      }
      $self->draw_str($self->{_draw}{reset_line_draw_mode});
  }
  
  sub _should_draw_row_separator {
      my ($self, $i) = @_;
  
      return $i < @{$self->{_draw}{frows}}-1 &&
          (($self->{show_row_separator}==2 && $i~~$self->{_draw}{frow_separators})
               || $self->{show_row_separator}==1);
  }
  
  # apply align/valign, apply padding, apply default fgcolor/bgcolor to text,
  # truncate to specified cell's width & height
  sub _get_cell_lines {
      my $self = shift;
      #say "D: get_cell_lines ".join(", ", map{$_//""} @_);
      my ($text, $width, $height, $align, $valign,
          $lpad, $rpad, $tpad, $bpad, $color) = @_;
  
      my @lines;
      push @lines, "" for 1..$tpad;
      my @dlines = split(/\r?\n/, $text);
      @dlines = ("") unless @dlines;
      my ($la, $lb);
      $valign //= 'top';
      if ($valign =~ /^[Bb]/o) { # bottom
          $la = $height-@dlines;
          $lb = 0;
      } elsif ($valign =~ /^[MmCc]/o) { # middle/center
          $la = int(($height-@dlines)/2);
          $lb = $height-@dlines-$la;
      } else { # top
          $la = 0;
          $lb = $height-@dlines;
      }
      push @lines, "" for 1..$la;
      push @lines, @dlines;
      push @lines, "" for 1..$lb;
      push @lines, "" for 1..$bpad;
  
      $align //= 'left';
      my $pad = $align =~ /^[Ll]/o ? "right" :
          ($align =~ /^[Rr]/o ? "left" : "center");
  
      for (@lines) {
          $_ = (" "x$lpad) . $self->{_func_pad}->($_, $width, $pad, " ", 1) . (" "x$rpad);
          if ($self->{use_color}) {
              # add default color
              s/\e\[0m(?=.)/\e[0m$color/g if length($color);
              $_ = $color . $_;
          }
      }
  
      \@lines;
  }
  
  sub _get_header_cell_lines {
      my ($self, $i) = @_;
  
      my $ct = $self->{color_theme};
  
      my $fgcolor;
      if (defined $self->{header_fgcolor}) {
          $fgcolor = $self->theme_color_to_ansi($self->{header_fgcolor});
      } elsif (defined $self->{cell_fgcolor}) {
          $fgcolor = $self->theme_color_to_ansi($self->{cell_fgcolor});
      #} elsif (defined $self->{_draw}{fcol_detect}[$i]{fgcolor}) {
      #    $fgcolor = $self->themecol2ansi($self->{_draw}{fcol_detect}[$i]{fgcolor});
      } elsif (defined $ct->{colors}{header}) {
          $fgcolor = $self->get_theme_color_as_ansi('header');
      } elsif (defined $ct->{colors}{cell}) {
          $fgcolor = $self->get_theme_color_as_ansi('cell');
      } else {
          $fgcolor = "";
      }
  
      my $bgcolor;
      if (defined $self->{header_bgcolor}) {
          $bgcolor = $self->theme_color_to_ansi($self->{header_bgcolor},
                                                undef, 1);
      } elsif (defined $self->{cell_bgcolor}) {
          $bgcolor = $self->theme_color_to_ansi($self->{cell_bgcolor},
                                                undef, 1);
      } elsif (defined $self->{_draw}{fcol_detect}[$i]{bgcolor}) {
          $fgcolor = $self->theme_color_to_ansi($self->{_draw}{fcol_detect}[$i]{bgcolor},
                                                undef, 1);
      } elsif (defined $ct->{colors}{header_bg}) {
          $bgcolor = $self->get_theme_color_as_ansi('header_bg');
      } elsif (defined $ct->{colors}{cell_bg}) {
          $bgcolor = $self->get_theme_color_as_ansi('cell_bg');
      } else {
          $bgcolor = "";
      }
  
      my $align =
          $self->{header_align} //
              $self->{cell_align} //
                  $self->{_draw}{fcol_detect}[$i]{align} //
                      'left';
      my $valign =
          $self->{header_valign} //
              $self->{cell_valign} //
                  $self->{_draw}{fcol_detect}[$i]{valign} //
                      'top';
  
      my $lpad = $self->{_draw}{fcol_lpads}[$i];
      my $rpad = $self->{_draw}{fcol_rpads}[$i];
      my $tpad = $self->{header_tpad} // $self->{header_vpad} // 0;
      my $bpad = $self->{header_bpad} // $self->{header_vpad} // 0;
  
      #use Data::Dump; print "D:header cell: "; dd {i=>$i, col=>$self->{columns}[$i], fgcolor=>$fgcolor, bgcolor=>$bgcolor};
      my $res = $self->_get_cell_lines(
          $self->{columns}[$i],            # text
          $self->{_draw}{fcol_widths}[$i], # width
          $self->{_draw}{header_height},   # height
          $align, $valign,                 # aligns
          $lpad, $rpad, $tpad, $bpad,      # paddings
          $fgcolor . $bgcolor);
      #use Data::Dump; print "D:res: "; dd $res;
      $res;
  }
  
  sub _get_data_cell_lines {
      my ($self, $y, $x) = @_;
  
      my $ct   = $self->{color_theme};
      my $oy   = $self->{_draw}{frow_orig_indices}[$y];
      my $cell = $self->{_draw}{frows}[$y][$x];
      my $args = {row_num=>$y, col_num=>$x, data=>$cell,
                  orig_data=>$self->{rows}[$oy][$x]};
  
      my $tmp;
      my $fgcolor;
      if (defined ($tmp = $self->get_eff_cell_style($oy, $x, 'fgcolor'))) {
          $fgcolor = $self->theme_color_to_ansi($tmp, $args);
      } elsif (defined ($tmp = $self->get_eff_row_style($oy, 'fgcolor'))) {
          $fgcolor = $self->theme_color_to_ansi($tmp, $args);
      } elsif (defined ($tmp = $self->get_eff_column_style($x, 'fgcolor'))) {
          $fgcolor = $self->theme_color_to_ansi($tmp, $args);
      } elsif (defined ($tmp = $self->{cell_fgcolor})) {
          $fgcolor = $self->theme_color_to_ansi($tmp, $args);
      } elsif (defined ($tmp = $self->{_draw}{fcol_detect}[$x]{fgcolor})) {
          $fgcolor = $self->theme_color_to_ansi($tmp, $args);
      } elsif (defined $ct->{colors}{cell}) {
          $fgcolor = $self->get_theme_color_as_ansi('cell', $args);
      } else {
          $fgcolor = "";
      }
  
      my $bgcolor;
      if (defined ($tmp = $self->get_eff_cell_style($oy, $x, 'bgcolor'))) {
          $bgcolor = $self->theme_color_to_ansi($tmp, $args, 1);
      } elsif (defined ($tmp = $self->get_eff_row_style($oy, 'bgcolor'))) {
          $bgcolor = $self->theme_color_to_ansi($tmp, $args, 1);
      } elsif (defined ($tmp = $self->get_eff_column_style($x, 'bgcolor'))) {
          $bgcolor = $self->theme_color_to_ansi($tmp, $args, 1);
      } elsif (defined ($tmp = $self->{cell_bgcolor})) {
          $bgcolor = $self->theme_color_to_ansi($tmp, $args, 1);
      } elsif (defined ($tmp = $self->{_draw}{fcol_detect}[$x]{bgcolor})) {
          $bgcolor = $self->theme_color_to_ansi($tmp, $args, 1);
      } elsif (defined $ct->{colors}{cell_bg}) {
          $bgcolor = $self->get_theme_color_as_ansi('cell_bg', $args);
      } else {
          $bgcolor = "";
      }
  
      my $align =
          $self->get_eff_cell_style($oy, $x, 'align') //
              $self->get_eff_row_style($oy, 'align') //
                  $self->get_eff_column_style($x, 'align') //
                      $self->{cell_align} //
                          $self->{_draw}{fcol_detect}[$x]{align} //
                              'left';
      my $valign =
          $self->get_eff_cell_style($oy, $x, 'valign') //
              $self->get_eff_row_style($oy, 'valign') //
                  $self->get_eff_column_style($x, 'valign') //
                      $self->{cell_valign} //
                          $self->{_draw}{fcol_detect}[$x]{valign} //
                              'top';
      #say "D:y=$y, x=$x, align=$align, valign=$valign";
  
      my $lpad = $self->{_draw}{fcol_lpads}[$x];
      my $rpad = $self->{_draw}{fcol_rpads}[$x];
      my $tpad = $self->{_draw}{frow_tpads}[$y];
      my $bpad = $self->{_draw}{frow_bpads}[$y];
  
      my $res = $self->_get_cell_lines(
          $cell,                            # text
          $self->{_draw}{fcol_widths}[$x],  # width
          $self->{_draw}{frow_heights}[$y], # height
          $align, $valign,                  # aligns
          $lpad, $rpad, $tpad, $bpad,       # paddings
          $fgcolor . $bgcolor);
      $res;
  }
  
  sub draw {
      my ($self) = @_;
  
      $self->_prepare_draw;
  
      $self->{_draw}{buf} = []; # output buffer
      $self->{_draw}{y} = 0; # current line
  
      # ansi codes to set and reset line-drawing mode.
      {
          my $bs = $self->{border_style};
          $self->{_draw}{set_line_draw_mode}   = $bs->{box_chars} ? "\e(0" : "";
          $self->{_draw}{reset_line_draw_mode} = $bs->{box_chars} ? "\e(B" : "";
      }
  
      my $cols  = $self->{columns};
      my $fcols = $self->{_draw}{fcols};
      my $frows = $self->{_draw}{frows};
      my $frow_heights    = $self->{_draw}{frow_heights};
      my $frow_tpads      = $self->{_draw}{frow_tpads};
      my $frow_bpads      = $self->{_draw}{frow_bpads};
      my $fcol_lpads      = $self->{_draw}{fcol_lpads};
      my $fcol_rpads      = $self->{_draw}{fcol_rpads};
      my $fcol_widths     = $self->{_draw}{fcol_widths};
  
      # draw border top line
      {
          last unless length($self->get_border_char(0, 0));
          my @b;
          push @b, 0, 0, 1;
          for my $i (0..@$fcols-1) {
              my $ci = $self->_colnum($fcols->[$i]);
              push @b, 0, 1,
                  $fcol_lpads->[$ci] + $fcol_widths->[$ci] + $fcol_rpads->[$ci];
              push @b, 0, 2, 1 if $i < @$fcols-1;
          }
          push @b, 0, 3, 1;
          $self->draw_border_char(@b);
          $self->draw_str("\n");
      }
  
      # draw header
      if ($self->{show_header}) {
          my %seen;
          my $hcell_lines = []; # index = [fcolnum]
          if (@$fcols) {
              for my $i (0..@$fcols-1) {
                  my $ci = $self->_colnum($fcols->[$i]);
                  if (defined($seen{$i})) {
                      $hcell_lines->[$i] = $hcell_lines->[$seen{$i}];
                  }
                  $seen{$i} = $ci;
                  $hcell_lines->[$i] = $self->_get_header_cell_lines($ci);
              }
          } else {
              # so we can still draw header
              $hcell_lines->[0] = [""];
          }
          #use Data::Dump; print "D:hcell_lines: "; dd $hcell_lines;
          for my $l (0..@{ $hcell_lines->[0] }-1) {
              $self->draw_border_char(1, 0);
              for my $i (0..@$fcols-1) {
                  $self->draw_str($hcell_lines->[$i][$l]);
                  $self->draw_color_reset;
                  $self->draw_border_char(1, 1) unless $i == @$fcols-1;
              }
              $self->draw_border_char(1, 2);
              $self->draw_str("\n");
          }
      }
  
      # draw header-data row separator
      if ($self->{show_header} && length($self->get_border_char(2, 0))) {
          my @b;
          push @b, 2, 0, 1;
          for my $i (0..@$fcols-1) {
              my $ci = $self->_colnum($fcols->[$i]);
              push @b, 2, 1,
                  $fcol_lpads->[$ci] + $fcol_widths->[$ci] + $fcol_rpads->[$ci];
              push @b, 2, 2, 1 unless $i==@$fcols-1;
          }
          push @b, 2, 3, 1;
          $self->draw_border_char(@b);
          $self->draw_str("\n");
      }
  
      # draw data rows
      {
          for my $r (0..@$frows-1) {
              #$self->draw_str("r$r");
              my $dcell_lines = []; # index = [fcolnum]
              my %seen;
              if (@$fcols) {
                  for my $i (0..@$fcols-1) {
                      my $ci = $self->_colnum($fcols->[$i]);
                      if (defined($seen{$i})) {
                          $dcell_lines->[$i] = $dcell_lines->[$seen{$i}];
                      }
                      $seen{$i} = $ci;
                      $dcell_lines->[$i] = $self->_get_data_cell_lines($r, $ci);
                  }
              } else {
                  # so we can still print row
                  $dcell_lines->[0] = [" "];
              }
              #use Data::Dump; print "TMP: dcell_lines: "; dd $dcell_lines;
              for my $l (0..@{ $dcell_lines->[0] }-1) {
                  $self->draw_border_char({row_num=>$r}, 3, 0);
                  for my $i (0..@$fcols-1) {
                      $self->draw_str($dcell_lines->[$i][$l]);
                      $self->draw_color_reset;
                      $self->draw_border_char({row_num=>$r}, 3, 1)
                          unless $i == @$fcols-1;
                  }
                  $self->draw_border_char({row_num=>$r}, 3, 2);
                  $self->draw_str("\n");
              }
  
              # draw separators between row
              if ($self->_should_draw_row_separator($r)) {
                  my @b;
                  push @b, 4, 0, 1;
                  for my $i (0..@$fcols-1) {
                      my $ci = $self->_colnum($fcols->[$i]);
                      push @b, 4, 1,
                          $fcol_lpads->[$ci] + $fcol_widths->[$ci] +
                              $fcol_rpads->[$ci];
                      push @b, 4, $i==@$fcols-1 ? 3:2, 1;
                  }
                  $self->draw_border_char({row_num=>$r}, @b);
                  $self->draw_str("\n");
              }
          } # for frow
      }
  
      # draw border bottom line
      {
          last unless length($self->get_border_char(5, 0));
          my @b;
          push @b, 5, 0, 1;
          for my $i (0..@$fcols-1) {
              my $ci = $self->_colnum($fcols->[$i]);
              push @b, 5, 1,
                  $fcol_lpads->[$ci] + $fcol_widths->[$ci] + $fcol_rpads->[$ci];
              push @b, 5, 2, 1 unless $i == @$fcols-1;
          }
          push @b, 5, 3, 1;
          $self->draw_border_char(@b);
          $self->draw_str("\n");
      }
  
      join "", @{$self->{_draw}{buf}};
  }
  
  1;
  # ABSTRACT: Create nice formatted tables using extended ASCII and ANSI colors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Text::ANSITable - Create nice formatted tables using extended ASCII and ANSI colors
  
  =head1 VERSION
  
  This document describes version 0.500 of Text::ANSITable (from Perl distribution Text-ANSITable), released on 2018-05-31.
  
  =head1 SYNOPSIS
  
   use 5.010;
   use Text::ANSITable;
  
   # don't forget this if you want to output utf8 characters
   binmode(STDOUT, ":utf8");
  
   my $t = Text::ANSITable->new;
  
   # set styles
   $t->border_style('Default::bold');  # if not, a nice default is picked
   $t->color_theme('Default::sepia');  # if not, a nice default is picked
  
   # fill data
   $t->columns(["name"       , "color" , "price"]);
   $t->add_row(["chiki"      , "yellow",    2000]);
   $t->add_row(["lays"       , "green" ,    7000]);
   $t->add_row(["tao kae noi", "blue"  ,   18500]);
  
   # draw it!
   print $t->draw;
  
  Samples of output:
  
  =head1 DESCRIPTION
  
  This module is yet another text table formatter module like L<Text::ASCIITable>
  or L<Text::SimpleTable>, with the following differences:
  
  =over
  
  =item * Colors and color themes
  
  ANSI color codes will be used by default (even 256 and 24bit colors), but will
  degrade to lower color depth and black/white according to terminal support.
  
  =item * Box-drawing characters
  
  Box-drawing characters will be used by default, but will degrade to using normal
  ASCII characters if terminal does not support them.
  
  =item * Unicode and wide character support
  
  Border styles using Unicode characters (double lines, bold/heavy lines, brick
  style, etc). Columns containing wide characters stay aligned. (Note: support for
  wide characters requires L<Text::ANSI::WideUtil> which is currently set as an
  optional prereq, so you'll need to install it explicitly or set your CPAN client
  to install 'recommends' prereq).
  
  =back
  
  Compared to Text::ASCIITable, it uses C<lower_case> method/attr names instead of
  C<CamelCase>, and it uses arrayref for C<columns> and C<add_row>. When
  specifying border styles, the order of characters are slightly different. More
  fine-grained options to customize appearance.
  
  =for Pod::Coverage ^(BUILD|draw_.+|get_color_reset|get_border_char)$
  
  =begin HTML
  
  <p><img src="http://blogs.perl.org/users/steven_haryanto/ansitable1.png" /></p>
  
  <p><img src="http://blogs.perl.org/users/steven_haryanto/ansitable2.png" /></p>
  
  <p><img src="http://blogs.perl.org/users/steven_haryanto/ansitable3.png" /></p>
  
  <p><img src="http://blogs.perl.org/users/steven_haryanto/ansitable4.png" /></p>
  
  <p><img src="http://blogs.perl.org/users/steven_haryanto/ansitable5.png" /></p>
  
  =end HTML
  
  =head1 BORDER STYLES
  
  To list available border styles:
  
   say $_ for $t->list_border_styles;
  
  Or you can also try out borders using the provided
  L<ansitable-list-border-styles> script. Or, you can also view the documentation
  for the C<Text::ANSITable::BorderStyle::*> modules, where border styles are
  searched.
  
  To choose border style, either set the C<border_style> attribute to an available
  border style or a border specification directly.
  
   $t->border_style("Default::singleh_boxchar");
   $t->border_style("Foo::bar");   # dies, no such border style
   $t->border_style({ ... }); # set specification directly
  
  If no border style is selected explicitly, a nice default will be chosen. You
  can also set the C<ANSITABLE_BORDER_STYLE> environment variable to set the
  default.
  
  To create a new border style, create a module under
  C<Text::ANSITable::BorderStyle::>. Please see one of the existing border style
  modules for example, like L<Text::ANSITable::BorderStyle::Default>. For more
  about border styles, refer to L<Border::Style::Role>.
  
  =head1 COLOR THEMES
  
  To list available color themes:
  
   say $_ for $t->list_color_themes;
  
  Or you can also run the provided L<ansitable-list-color-themes> script. Or you
  can view the documentation for the C<Text::ANSITable::ColorTheme::*> modules
  where color themes are searched.
  
  To choose a color theme, either set the C<color_theme> attribute to an available
  color theme or a color theme specification directly.
  
   $t->color_theme("Default::default_nogradation");
   $t->color_theme("Foo::bar");    # dies, no such color theme
   $t->color_theme({ ... });  # set specification directly
  
  If no color theme is selected explicitly, a nice default will be chosen. You can
  also set the C<ANSITABLE_COLOR_THEME> environment variable to set the default.
  
  To create a new color theme, create a module under
  C<Text::ANSITable::ColorTheme::>. Please see one of the existing color theme
  modules for example, like L<Text::ANSITable::ColorTheme::Default>. For more
  about color themes, refer to L<Color::Theme::Role>.
  
  =head1 COLUMN WIDTHS
  
  By default column width is set just so it is enough to show the widest data.
  This can be customized in the following ways (in order of precedence, from
  lowest):
  
  =over
  
  =item * table-level C<cell_width> attribute
  
  This sets width for all columns.
  
  =item * conditional column styles
  
  The example below sets column width to 10 for columns whose names matching
  C</[acm]time/>, else sets the column width to 20.
  
   $t->add_cond_column_style(sub {  /[acm]time/ }, width => 10);
   $t->add_cond_column_style(sub { !/[acm]time/ }, width => 20);
  
  =item * per-column C<width> style
  
   $t->set_column_style('colname', width => 20);
  
  =back
  
  You can use negative number to mean I<minimum> width.
  
  =head1 ROW HEIGHTS
  
  This can be customized in the following ways (in order of precedence, from
  lowest):
  
  =over
  
  =item * table-level C<cell_height> attribute
  
  This sets height for all rows.
  
  =item * conditional row styles
  
  The example below sets row height to 2 for every odd rows, and 1 for even rows.
  
   $t->add_cond_row_style(sub { $_ % 2 == 0 }, height => 2);
   $t->add_cond_row_style(sub { $_ % 2      }, height => 1);
  
  =item * per-row C<height> style
  
   $t->set_row_style(1, height => 2);
  
  =back
  
  You can use negative number to mean I<minimum> height.
  
  =head1 CELL (HORIZONTAL) PADDING
  
  By default cell (horizontal) padding is 1. This can be customized in the
  following ways (in order of precedence, from lowest):
  
  =over
  
  =item * table-level C<cell_pad> attribute
  
  This sets left and right padding for all columns.
  
  =item * table-level C<cell_lpad> and C<cell_rpad> attributes
  
  They set left and right padding for all columns, respectively.
  
  =item * conditional column C<pad> style
  
   $t->add_cond_column_style($cond, pad => 0);
  
  =item * conditional column C<lpad>/C<rpad> style
  
   $t->add_cond_column_style($cond, lpad => 1, rpad => 2);
  
  =item * per-column C<pad> style
  
   $t->set_column_style($colname, pad => 0);
  
  =item * per-column C<lpad>/C<rpad> style
  
   $t->set_column_style($colname, lpad => 1);
   $t->set_column_style($colname, rpad => 2);
  
  =back
  
  =head1 ROW VERTICAL PADDING
  
  Default vertical padding is 0. This can be changed in the following ways (in
  order of precedence, from lowest):
  
  =over
  
  =item * table-level C<cell_vpad> attribute
  
  This sets top and bottom padding for all rows.
  
  =item * table-level C<cell_tpad>/C<cell_bpad> attributes
  
  They set top/bottom padding separately for all rows.
  
  =item * conditional row C<vpad> style
  
  Example:
  
   $t->add_cond_row_style($cond, vpad => 1);
  
  =item * per-row C<vpad> style
  
  Example:
  
   $t->set_row_style($rownum, vpad => 1);
  
  When adding row:
  
   $t->add_row($rownum, {vpad=>1});
  
  =item * per-row C<tpad>/C<bpad> style
  
  Example:
  
   $t->set_row_style($row_num, tpad => 1);
   $t->set_row_style($row_num, bpad => 2);
  
  When adding row:
  
   $t->add_row($row, {tpad=>1, bpad=>2});
  
  =back
  
  =head1 CELL COLORS
  
  By default data format colors are used, e.g. cyan/green for text (using the
  default color scheme, items C<num_data>, C<bool_data>, etc). In absense of that,
  C<cell_fgcolor> and C<cell_bgcolor> from the color scheme are used. You can
  customize colors in the following ways (ordered by precedence, from lowest):
  
  =over
  
  =item * table-level C<cell_fgcolor> and C<cell_bgcolor> attributes
  
  Sets all cells' colors. Color should be specified using 6-hexdigit RGB which
  will be converted to the appropriate terminal color.
  
  Can also be set to a coderef which will receive ($rownum, $colname) and should
  return an RGB color.
  
  =item * conditional column C<fgcolor> and C<bgcolor> style
  
  Example:
  
   $t->add_cond_column_style($cond, fgcolor => 'fa8888', bgcolor => '202020');
  
  =item * per-column C<fgcolor> and C<bgcolor> styles
  
  Example:
  
   $t->set_column_style('colname', fgcolor => 'fa8888');
   $t->set_column_style('colname', bgcolor => '202020');
  
  =item * conditional row C<fgcolor> and C<bgcolor> style
  
  Example:
  
   $t->add_cond_row_style($cond, fgcolor => 'fa8888', bgcolor => '202020');
  
  =item * per-row C<fgcolor> and C<bgcolor> styles
  
  Example:
  
   $t->set_row_style($rownum, {fgcolor => 'fa8888', bgcolor => '202020'});
  
  When adding row/rows:
  
   $t->add_row($row, {fgcolor=>..., bgcolor=>...});
   $t->add_rows($rows, {bgcolor=>...});
  
  =item * conditional cell C<fgcolor> and C<bgcolor> style
  
   $t->add_cond_cell_style($cond, fgcolor=>..., bgcolor=>...);
  
  =item * per-cell C<fgcolor> and C<bgcolor> styles
  
  Example:
  
   $t->set_cell_style($rownum, $colname, fgcolor => 'fa8888');
   $t->set_cell_style($rownum, $colname, bgcolor => '202020');
  
  =back
  
  For flexibility, all colors can be specified as coderef. See L</"COLOR THEMES">
  for more details.
  
  =head1 CELL (HORIZONTAL AND VERTICAL) ALIGNMENT
  
  By default, numbers are right-aligned, dates and bools are centered, and the
  other data types (text including) are left-aligned. All data are top-valigned.
  This can be customized in the following ways (in order of precedence, from
  lowest):
  
  =over
  
  =item * table-level C<cell_align> and C<cell_valign> attribute
  
  =item * conditional column C<align> and <valign> styles
  
   $t->add_cond_column_style($cond, align=>..., valign=>...);
  
  =item * per-column C<align> and C<valign> styles
  
  Example:
  
   $t->set_column_style($colname, align  => 'middle'); # or left, or right
   $t->set_column_style($colname, valign => 'top');    # or bottom, or middle
  
  =item * conditional row C<align> and <valign> styles
  
   $t->add_cond_row_style($cond, align=>..., valign=>...);
  
  =item * per-row C<align> and C<valign> styles
  
  =item * conditional cell C<align> and <valign> styles
  
   $t->add_cond_cell_style($cond, align=>..., valign=>...);
  
  =item * per-cell C<align> and C<valign> styles
  
   $t->set_cell_style($rownum, $colname, align  => 'middle');
   $t->set_cell_style($rownum, $colname, valign => 'top');
  
  =back
  
  =head1 CELL FORMATS
  
  The per-column- and per-cell- C<formats> style regulates how to format data. The
  value for this style setting will be passed to L<Data::Unixish::Apply>'s
  C<apply()>, as the C<functions> argument. So it should be a single string (like
  C<date>) or an array (like C<< ['date', ['centerpad', {width=>20}]] >>).
  
  L<Data::Unixish::Apply> is an optional prerequisite, so you will need to install
  it separately if you need this feature.
  
  To see what functions are available, install L<App::dux> and then run C<dux -l>.
  Functions of interest to formatting data include: C<bool>, C<num>, C<sprintf>,
  C<sprintfn>, C<wrap>, C<ANSI::*> (in L<Data::Unixish::ANSI> distribution),
  (among others).
  
  =head1 CONDITIONAL STYLES
  
  As an alternative to setting styles for specific {column,row,cell}, you can also
  create conditional styles. You specify a Perl code for the condition, then if
  the condition evaluates to true, the corresponding styles are applied to the
  corresponding {column,row,cell}.
  
  To add a conditional style, use the C<add_cond_{column,row,cell}_style> methods.
  These methods accept condition code as its first argument and one or more styles
  in the subsequent argument(s). For example:
  
   $t->add_cond_row_style(sub { $_ % 2 }, bgcolor=>'202020');
  
  The above example will set row bgcolor for odd rows. You can add more
  conditional styles:
  
   $t->add_cond_row_style(sub { $_ % 2 == 0 }, bgcolor=>'404040');
  
  All the conditions will be evaluated and the applicable styles will be merged
  together. For example, if we add a third conditional row style:
  
   $t->add_cond_row_style(sub { $_ % 10 == 0 }, height=>2, fgcolor=>'ffff00');
  
  then every tenth row will have its height set to 2, fgcolor set to ffff00, and
  bgcolor set to 404040 (from the second conditional).
  
  Condition coderef will be called with these arguments:
  
   ($self, %args)
  
  Available keys in C<%args> for conditional column styles: C<col> (int, column
  index), C<colname> (str, column name). Additionally, C<$_> will be set locally
  to the column index.
  
  Available keys in C<%args> for conditional row styles: C<row> (int, row index),
  C<row_data> (array). Additionally, C<$_> will be set locally to the row index.
  
  Available keys in C<%args> for conditional cell styles: C<content> (str), C<col>
  (int, column index), C<row> (int, row index). Additionally, C<$_> will be set
  locally to the cell content.
  
  Coderef should return boolean indicating whether style should be applied to a
  particular column/row/cell. When returning a true value, coderef can also return
  a hashref to return additional styles that will be merged/applied too.
  
  =head1 STYLE SETS
  
  A style set is just a collection of style settings that can be applied.
  Organizing styles into style sets makes applying the styles simpler and more
  reusable.
  
  More than one style sets can be applied.
  
  Style set module accepts arguments.
  
  For example, the L<Text::ANSITable::StyleSet::AltRow> style set defines this:
  
   has odd_bgcolor  => (is => 'rw');
   has even_bgcolor => (is => 'rw');
   has odd_fgcolor  => (is => 'rw');
   has even_fgcolor => (is => 'rw');
  
   sub apply {
       my ($self, $table) = @_;
  
       $table->add_cond_row_style(sub {
           my ($t, %args) = @_;
           my %styles;
           if ($_ % 2) {
               $styles{bgcolor} = $self->odd_bgcolor
                   if defined $self->odd_bgcolor;
               $styles{fgcolor} = $self->odd_fgcolor
                   if defined $self->odd_bgcolor;
           } else {
               $styles{bgcolor} = $self->even_bgcolor
                   if defined $self->even_bgcolor;
               $styles{fgcolor} = $self->even_fgcolor
                   if defined $self->even_bgcolor;
           }
           \%styles;
       });
   }
  
  To apply this style set:
  
   $t->apply_style_set("AltRow", odd_bgcolor=>"003300", even_bgcolor=>"000000");
  
  To create a new style set, create a module under C<Text::ANSITable::StyleSet::>
  like the above example. Please see the other existing style set modules for more
  examples.
  
  =head1 ATTRIBUTES
  
  =head2 columns => ARRAY OF STR
  
  Store column names. Note that when drawing, you can omit some columns, reorder
  them, or display some more than once (see C<column_filter> attribute).
  
  Caveat: Since, for convenience, a column can be referred to using its name or
  position, weird/unecxpected thing can happen if you name a column with a number
  (e.g. 0, 1, 2, ...). So don't do that.
  
  =head2 rows => ARRAY OF ARRAY OF STR
  
  Store row data. You can set this attribute directly, or add rows incrementally
  using C<add_row()> and C<add_rows()> methods.
  
  =head2 row_filter => CODE|ARRAY OF INT
  
  When drawing, only show rows that match this. Can be an array containing indices
  of rows which should be shown, or a coderef which will be called for each row
  with arguments C<< ($row, $row_num) >> and should return a bool value indicating
  whether that row should be displayed.
  
  Internal note: During drawing, rows will be filtered and put into C<<
  $t->{_draw}{frows} >>.
  
  =head2 column_filter => CODE|ARRAY OF STR
  
  When drawing, only show columns that match this. Can be an array containing
  names of columns that should be displayed (column names can be in different
  order or duplicate, column can also be referred to with its numeric index). Can
  also be a coderef which will be called with C<< ($col_name, $col_num) >> for
  every column and should return a bool value indicating whether that column
  should be displayed. The coderef version is more limited in that it cannot
  reorder the columns or instruct for the same column to be displayed more than
  once.
  
  Internal note: During drawing, column names will be filtered and put into C<<
  $t->{_draw}{fcols} >>.
  
  =head2 column_wrap => BOOL
  
  Set column wrapping for all columns. Can be overriden by per-column C<wrap>
  style. By default column wrapping will only be done for text columns and when
  width is explicitly set to a positive value.
  
  =head2 use_color => BOOL
  
  Whether to output color. Default is taken from C<COLOR> environment variable, or
  detected via C<(-t STDOUT)>. If C<use_color> is set to 0, an attempt to use a
  colored color theme (i.e. anything that is not the C<no_color> theme) will
  result in an exception.
  
  (In the future, setting C<use_color> to 0 might opt the module to use
  normal/plain string routines instead of the slower ta_* functions from
  L<Text::ANSI::Util>; this also means that the module won't handle ANSI escape
  codes in the content text.)
  
  =head2 color_depth => INT
  
  Terminal's color depth. Either 16, 256, or 2**24 (16777216). Default will be
  retrieved from C<COLOR_DEPTH> environment or detected using L<Term::Detect>.
  
  =head2 use_box_chars => BOOL
  
  Whether to use box drawing characters. Drawing box drawing characters can be
  problematic in some places because it uses ANSI escape codes to switch to (and
  back from) line drawing mode (C<"\e(0"> and C<"\e(B">, respectively).
  
  Default is taken from C<BOX_CHARS> environment variable, or 1. If
  C<use_box_chars> is set to 0, an attempt to use a border style that uses box
  drawing chararacters will result in an exception.
  
  =head2 use_utf8 => BOOL
  
  Whether to use Unicode (UTF8) characters. Default is taken from C<UTF8>
  environment variable, or detected using L<Term::Detect>, or guessed via L<LANG>
  environment variable. If C<use_utf8> is set to 0, an attempt to select a border
  style that uses Unicode characters will result in an exception.
  
  (In the future, setting C<use_utf8> to 0 might opt the module to use the
  non-"mb_*" version of functions from L<Text::ANSI::Util>, e.g. C<ta_wrap()>
  instead of C<ta_mbwrap()>, and so on).
  
  =head2 wide => BOOL
  
  Whether to support wide characters. The default is to check for the existence of
  L<Text::ANSI::WideUtil> (an optional prereq). You can explicitly enable or
  disable wide-character support here.
  
  =head2 border_style => HASH
  
  Border style specification to use.
  
  You can set this attribute's value with a specification or border style name.
  See L<"/BORDER STYLES"> for more details.
  
  =head2 border_style_args => HASH
  
  Some border styles can accept arguments. You can set it here. See the
  corresponding border style's documentation for information on what arguments it
  accepts.
  
  =head2 color_theme => HASH
  
  Color theme specification to use.
  
  You can set this attribute's value with a specification or color theme name. See
  L<"/COLOR THEMES"> for more details.
  
  =head2 color_theme_args => HASH
  
  Some color themes can accept arguments. You can set it here. See the
  corresponding color theme's documentation for information on what arguments it
  accepts.
  
  =head2 show_header => BOOL (default: 1)
  
  When drawing, whether to show header.
  
  =head2 show_row_separator => INT (default: 2)
  
  When drawing, whether to show separator lines between rows. The default (2) is
  to only show separators drawn using C<add_row_separator()>. If you set this to
  1, lines will be drawn after every data row. If you set this attribute to 0, no
  lines will be drawn whatsoever.
  
  =head2 cell_width => INT
  
  Set width for all cells. Can be overriden by per-column C<width> style.
  
  =head2 cell_height => INT
  
  Set height for all cell. Can be overriden by per-row C<height> style.
  
  =head2 cell_align => STR
  
  Set (horizontal) alignment for all cells. Either C<left>, C<middle>, or
  C<right>. Can be overriden by per-column/per-row/per-cell C<align> style.
  
  =head2 cell_valign => STR
  
  Set (horizontal) alignment for all cells. Either C<top>, C<middle>, or
  C<bottom>. Can be overriden by per-column/per-row/per-cell C<align> style.
  
  =head2 cell_pad => INT
  
  Set (horizontal) padding for all cells. Can be overriden by per-column C<pad>
  style.
  
  =head2 cell_lpad => INT
  
  Set left padding for all cells. Overrides the C<cell_pad> attribute. Can be
  overriden by per-column C<lpad> style.
  
  =head2 cell_rpad => INT
  
  Set right padding for all cells. Overrides the C<cell_pad> attribute. Can be
  overriden by per-column C<rpad> style.
  
  =head2 cell_vpad => INT
  
  Set vertical padding for all cells. Can be overriden by per-row C<vpad> style.
  
  =head2 cell_tpad => INT
  
  Set top padding for all cells. Overrides the C<cell_vpad> attribute. Can be
  overriden by per-row C<tpad> style.
  
  =head2 cell_bpad => INT
  
  Set bottom padding for all cells. Overrides the C<cell_vpad> attribute. Can be
  overriden by per-row C<bpad> style.
  
  =head2 cell_fgcolor => RGB|CODE
  
  Set foreground color for all cells. Value should be 6-hexdigit RGB. Can also be
  a coderef that will receive %args (e.g. row_num, col_name, col_num) and should
  return an RGB color. Can be overriden by per-cell C<fgcolor> style.
  
  =head2 cell_bgcolor => RGB|CODE
  
  Like C<cell_fgcolor> but for background color.
  
  =head2 header_fgcolor => RGB|CODE
  
  Set foreground color for all headers. Overrides C<cell_fgcolor> for headers.
  Value should be a 6-hexdigit RGB. Can also be a coderef that will receive %args
  (e.g. col_name, col_num) and should return an RGB color.
  
  =head2 header_bgcolor => RGB|CODE
  
  Like C<header_fgcolor> but for background color.
  
  =head2 header_align => STR
  
  =head2 header_valign => STR
  
  =head2 header_vpad => INT
  
  =head2 header_tpad => INT
  
  =head2 header_bpad => INT
  
  =head1 METHODS
  
  =head2 $t = Text::ANSITable->new(%attrs) => OBJ
  
  Constructor.
  
  =head2 $t->list_border_styles => LIST
  
  Return the names of available border styles. Border styles will be searched in
  C<Text::ANSITable::BorderStyle::*> modules.
  
  =head2 $t->list_color_themes => LIST
  
  Return the names of available color themes. Color themes will be searched in
  C<Text::ANSITable::ColorTheme::*> modules.
  
  =head2 $t->list_style_sets => LIST
  
  Return the names of available style sets. Style set names are retrieved by
  listing modules under C<Text::ANSITable::StyleSet::*> namespace.
  
  =head2 $t->get_border_style($name) => HASH
  
  Can also be called as a static method: C<<
  Text::ANSITable->get_border_style($name) >>.
  
  =head2 $t->get_color_theme($name) => HASH
  
  Can also be called as a static method: C<<
  Text::ANSITable->get_color_theme($name) >>.
  
  =head2 $t->add_row(\@row[, \%styles]) => OBJ
  
  Add a row. Note that row data is not copied, only referenced.
  
  Can also add per-row styles (which can also be done using C<row_style()>).
  
  =head2 $t->add_rows(\@rows[, \%styles]) => OBJ
  
  Add multiple rows. Note that row data is not copied, only referenced.
  
  Can also add per-row styles (which can also be done using C<row_style()>).
  
  =head2 $t->add_row_separator() => OBJ
  
  Add a row separator line.
  
  =head2 $t->get_cell($row_num, $col) => VAL
  
  Get cell value at row #C<$row_num> (starts from zero) and column named/numbered
  C<$col>.
  
  =head2 $t->set_cell($row_num, $col, $newval) => VAL
  
  Set cell value at row #C<$row_num> (starts from zero) and column named/numbered
  C<$col>. Return old value.
  
  =head2 $t->get_column_style($col, $style) => VAL
  
  Get per-column style for column named/numbered C<$col>.
  
  =head2 $t->set_column_style($col, $style=>$val[, $style2=>$val2, ...])
  
  Set per-column style(s) for column named/numbered C<$col>. Available values for
  C<$style>: C<align>, C<valign>, C<pad>, C<lpad>, C<rpad>, C<width>, C<formats>,
  C<fgcolor>, C<bgcolor>, C<type>, C<wrap>.
  
  =head2 $t->get_cond_column_styles => ARRAY
  
  Get all the conditional column styles set so far.
  
  =head2 $t->add_cond_column_style($cond, $style=>$val[, $style2=>$val2 ...])
  
  Add a new conditional column style. See L</"CONDITIONAL STYLES"> for more
  details on conditional style.
  
  =for comment | =head2 $t->clear_cond_column_styles | Clear all the conditional column styles.
  
  =head2 $t->get_eff_column_style($col, $style) => VAL
  
  Get "effective" column style named C<$style> for a particular column. Effective
  column style is calculated from all the conditional column styles and the
  per-column styles then merged together. This is the per-column style actually
  applied.
  
  =head2 $t->get_row_style($row_num) => VAL
  
  Get per-row style for row numbered C<$row_num>.
  
  =head2 $t->set_row_style($row_num, $style=>$newval[, $style2=>$newval2, ...])
  
  Set per-row style(s) for row numbered C<$row_num>. Available values for
  C<$style>: C<align>, C<valign>, C<height>, C<vpad>, C<tpad>, C<bpad>,
  C<fgcolor>, C<bgcolor>.
  
  =head2 $t->get_cond_row_styles => ARRAY
  
  Get all the conditional row styles set so far.
  
  =head2 $t->add_cond_row_style($cond, $style=>$val[, $style2=>$val2 ...])
  
  Add a new conditional row style. See L</"CONDITIONAL STYLES"> for more details
  on conditional style.
  
  =for comment | =head2 $t->clear_cond_row_styles | Clear all the conditional row styles.
  
  =head2 $t->get_eff_row_style($row_num, $style) => VAL
  
  Get "effective" row style named C<$style> for a particular row. Effective row
  style is calculated from all the conditional row styles and the per-row styles
  then merged together. This is the per-row style actually applied.
  
  =head2 $t->get_cell_style($row_num, $col, $style) => VAL
  
  Get per-cell style named C<$style> for a particular cell. Return undef if there
  is no per-cell style with that name.
  
  =head2 $t->set_cell_style($row_num, $col, $style=>$newval[, $style2=>$newval2, ...])
  
  Set per-cell style(s). Available values for C<$style>: C<align>, C<valign>,
  C<formats>, C<fgcolor>, C<bgcolor>.
  
  =head2 $t->get_cond_cell_styles => ARRAY
  
  Get all the conditional cell styles set so far.
  
  =head2 $t->add_cond_cell_style($cond, $style=>$val[, $style2=>$val2 ...])
  
  Add a new conditional cell style. See L</"CONDITIONAL STYLES"> for more details
  on conditional style.
  
  =for comment | =head2 $t->clear_cond_cell_styles | Clear all the conditional cell styles.
  
  =head2 $t->get_eff_cell_style($row_num, $col, $style) => VAL
  
  Get "effective" cell style named C<$style> for a particular cell. Effective cell
  style is calculated from all the conditional cell styles and the per-cell styles
  then merged together. This is the per-cell style actually applied.
  
  =head2 $t->apply_style_set($name, %args)
  
  Apply a style set. See L</"STYLE SETS"> for more details.
  
  =head2 $t->draw => STR
  
  Render table.
  
  =head1 FAQ
  
  =head2 General
  
  =head3 Output is too fancy! I just want to generate some plain (Text::ASCIITable-like) output to be copy-pasted to my document.
  
   $t->use_utf8(0);
   $t->use_box_chars(0);
   $t->use_color(0);
   $t->border_style('Default::single_ascii');
  
  and you're good to go. Alternatively you can set environment UTF8=0,
  BOX_CHARS=0, COLOR=0, and ANSITABLE_BORDER_STYLE=Default::single_ascii.
  
  =head3 Why am I getting 'Wide character in print' warning?
  
  You are probably using a utf8 border style, and you haven't done something like
  this to your output:
  
   binmode(STDOUT, ":utf8");
  
  =head3 My table looks garbled when viewed through pager like B<less>!
  
  That's because B<less> by default escapes ANSI color and box_char codes. Try
  using C<-R> option of B<less> to display ANSI color codes raw.
  
  Or, try not using colors and box_char border styles:
  
   $t->use_color(0);
   $t->use_box_chars(0);
  
  Note that as of this writing, B<less -R> does not interpret box_char codes so
  you'll need to avoid using box_char border styles if you want your output to
  display properly under B<less>.
  
  =head3 How do I hide some columns/rows when drawing?
  
  Use the C<column_filter> and C<row_filter> attributes. For example, given this
  table:
  
   my $t = Text::ANSITable->new;
   $t->columns([qw/one two three/]);
   $t->add_row([$_, $_, $_]) for 1..10;
  
  Doing this:
  
   $t->row_filter([0, 1, 4]);
   print $t->draw;
  
  will show:
  
    one | two | three
   -----+-----+-------
      1 |   1 |     1
      2 |   2 |     2
      5 |   5 |     5
  
  Doing this:
  
   $t->row_filter(sub { my ($row, $idx) = @_; $row->[0] % 2 }
  
  will display:
  
    one | two | three
   -----+-----+-------
      1 |   1 |     1
      3 |   3 |     3
      5 |   5 |     5
      7 |   7 |     7
      9 |   9 |     9
  
  Doing this:
  
   $t->column_filter([qw/two one 0/]);
  
  will display:
  
    two | one | one
   -----+-----+-----
      1 |   1 |   1
      2 |   2 |   2
      3 |   3 |   3
      4 |   4 |   4
      5 |   5 |   5
      6 |   6 |   6
      7 |   7 |   7
      8 |   8 |   8
      9 |   9 |   9
     10 |  10 |  10
  
  Doing this:
  
   $t->column_filter(sub { my ($colname, $idx) = @_; $colname =~ /t/ });
  
  will display:
  
    two | three
   -----+-------
      1 |     1
      2 |     2
      3 |     3
      4 |     4
      5 |     5
      6 |     6
      7 |     7
      8 |     8
      9 |     9
     10 |    10
  
  =head2 Formatting data
  
  =head3 How do I format data?
  
  Use the C<formats> per-column style or per-cell style. For example:
  
   $t->set_column_style('available', formats => [[bool=>{style=>'check_cross'}],
                                                 [centerpad=>{width=>10}]]);
   $t->set_column_style('amount'   , formats => [[num=>{decimal_digits=>2}]]);
   $t->set_column_style('size'     , formats => [[num=>{style=>'kilo'}]]);
  
  See L<Data::Unixish::Apply> and L<Data::Unixish> for more details on the
  available formatting functions.
  
  =head3 How does the module determine column data type?
  
  Currently: if column name has the word C<date> or C<time> in it, the column is
  assumed to contain B<date> data. If column name has C<?> in it, the column is
  assumed to be B<bool>. If a column contains only numbers (or undefs), it is
  B<num>. Otherwise, it is B<str>.
  
  =head3 How does the module format data types?
  
  Currently: B<num> will be right aligned and applied C<num_data> color (cyan in
  the default theme). B<date> will be centered and applied C<date_data> color
  (gold in the default theme). B<bool> will be centered and formatted as
  check/cross symbol and applied C<bool_data> color (red/green depending on
  whether the data is false/true). B<str> will be applied C<str_data> color (no
  color in the default theme).
  
  Other color themes might use different colors.
  
  =head3 How do I force column to be of a certain data type?
  
  For example, you have a column named C<deleted> but want to display it as
  B<bool>. You can do:
  
   $t->set_column_style(deleted => type => 'bool');
  
  =head3 How do I wrap long text?
  
  The C<wrap> dux function can be used to wrap text (see: L<Data::Unixish::wrap>).
  You'll want to set C<ansi> and C<mb> both to 1 to handle ANSI escape codes and
  wide characters in your text (unless you are sure that your text does not
  contain those):
  
   $t->set_column_style('description', formats=>[[wrap => {width=>60, ansi=>1, mb=>1}]]);
  
  =head3 How do I highlight text with color?
  
  The C<ansi::highlight> dux function can be used to highlight text (see:
  L<Data::Unixish::ANSI::highlight>).
  
   $t->set_column_style(2, formats => [[highlight => {pattern=>$pat}]]);
  
  =head3 I want to change the default bool cross/check sign representation!
  
  By default, bool columns are shown as cross/check sign. This can be changed,
  e.g.:
  
   $t->set_column_style($colname, type    => 'bool',
                                  formats => [[bool => {style=>"Y_N"}]]);
  
  See L<Data::Unixish::bool> for more details.
  
  =head3 How do I do conditional cell formatting?
  
  There are several ways.
  
  First, you can use the C<cond> dux function through C<formats> style. For
  example, if the cell contains the string "Cuti", you want to color the cell
  yellow. Otherwise, you want to color the cell red:
  
   $t->set_column_style($colname, formats => [
       [cond => {
           if   => sub { $_ =~ /Cuti/ },
           then => ["ansi::color", {color=>"yellow"}],
           else => ["ansi::color", {color=>"red"}],
       }]
   ]);
  
  Another way is to use the C<add_cond_{cell,row,column}> methods. See
  L</"CONDITIONAL STYLES"> for more details. An example:
  
   $t->add_cond_row_style(sub {
       my %args = @_;
       $args{colname} =~ /Cuti/ ? {bgcolor=>"ffff00"} : {bgcolor=>"ff0000"};
   });
  
  And another way is to use (or create) style set, which is basically a packaging
  of the above ways. An advantage of using style set is, because you do not
  specify coderef directly, you can specify it from the environment variable. See
  L</"STYLE SETS"> for more details.
  
  =head2 Border
  
  =head3 How to hide borders?
  
  There is currently no C<show_border> attribute. Choose border styles like
  C<Default::space_ascii> or C<Default::none_utf8>:
  
   $t->border_style("Default::none");
  
  =head3 Why are there 'none_ascii' as well 'none_utf8' and 'none_boxchar' border styles?
  
  Because of the row separator, that can still be drawn if C<add_row_separator()>
  is used. See next question.
  
  =head3 I want to hide borders, and I do not want row separators to be shown!
  
  The default is for separator lines to be drawn if drawn using
  C<add_row_separator()>, e.g.:
  
   $t->add_row(['row1']);
   $t->add_row(['row2']);
   $t->add_row_separator;
   $t->add_row(['row3']);
  
  The result will be:
  
     row1
     row2
   --------
     row3
  
  However, if you set C<show_row_separator> to 0, no separator lines will be drawn
  whatsoever:
  
     row1
     row2
     row3
  
  =head3 I want to separate each row with a line!
  
  Set C<show_row_separator> to 1, or alternatively, set
  C<ANSITABLE_STYLE='{"show_row_separator":1}>.
  
  =head2 Color
  
  =head3 How to disable colors?
  
  Set C<use_color> attribute or C<COLOR> environment to 0.
  
  =head3 How to specify colors using names (e.g. red, 'navy blue') instead of RGB?
  
  Use modules like L<Graphics::ColorNames>.
  
  =head3 I'm not seeing colors when output is piped (e.g. to a pager)!
  
  The default is to disable colors when (-t STDOUT) is false. You can force-enable
  colors by setting C<use_color> attribute or C<COLOR> environment to 1.
  
  =head3 How to enable 256 colors? I'm seeing only 16 colors.
  
  Use terminal emulators that support 256 colors, e.g. Konsole, xterm,
  gnome-terminal, PuTTY/pterm (but the last one has minimal Unicode support).
  Better yet, use Konsole or Konsole-based emulators which supports 24bit colors.
  
  =head3 How to enable 24bit colors (true color)?
  
  Currently only B<Konsole> and the Konsole-based B<Yakuake> terminal emulator
  software support 24bit colors.
  
  =head3 How to force lower color depth? (e.g. I use Konsole but want 16 colors)
  
  Set C<COLOR_DEPTH> to 16.
  
  =head3 How to change border gradation color?
  
  The default color theme applies vertical color gradation to borders from white
  (ffffff) to gray (444444). To change this, set C<border1> and C<border2> theme
  arguments:
  
   $t->color_theme_args({border1=>'ff0000', border2=>'00ff00'}); # red to green
  
  =head3 I'm using terminal emulator with white background, the texts are not very visible!
  
  Try using the "*_whitebg" themes, as the other themes are geared towards
  terminal emulators with black background.
  
  =head3 How to set different background colors for odd/even rows?
  
  Aside from doing C<< $t->set_row_style($row_num, bgcolor=>...) >> for each row,
  you can also do this:
  
   $t->cell_bgcolor(sub { my ($self, %args) = @_; $args{row_num} % 2 ? '202020' : undef });
  
  Or, you can use conditional row styles:
  
   $t->add_cond_row_style(sub { $_ % 2 }, {bgcolor=>'202020'});
  
  Or, you can use the L<Text::ANSITable::StyleSet::AltRow> style set:
  
   $t->apply_style_set(AltRow => {even_bgcolor=>'202020'});
  
  =head1 ENVIRONMENT
  
  =head2 COLOR => BOOL
  
  Can be used to set default value for the C<color> attribute.
  
  =head2 COLOR_DEPTH => INT
  
  Can be used to set default value for the C<color_depth> attribute.
  
  =head2 BOX_CHARS => BOOL
  
  Can be used to set default value for the C<box_chars> attribute.
  
  =head2 UTF8 => BOOL
  
  Can be used to set default value for the C<utf8> attribute.
  
  =head2 COLUMNS => INT
  
  Can be used to override terminal width detection.
  
  =head2 ANSITABLE_BORDER_STYLE => STR
  
  Can be used to set default value for C<border_style> attribute.
  
  =head2 ANSITABLE_COLOR_THEME => STR
  
  Can be used to set default value for C<border_style> attribute.
  
  =head2 ANSITABLE_STYLE => str(json)
  
  Can be used to set table's most attributes. Value should be a JSON-encoded hash
  of C<< attr => val >> pairs. Example:
  
   % ANSITABLE_STYLE='{"show_row_separator":1}' ansitable-list-border-styles
  
  will display table with row separator lines after every row.
  
  =head2 WRAP => BOOL
  
  Can be used to set default value for the C<wrap> column style.
  
  =head2 ANSITABLE_COLUMN_STYLES => str(json)
  
  Can be used to set per-column styles. Interpreted right before draw(). Value
  should be a JSON-encoded hash of C<< col => {style => val, ...} >> pairs.
  Example:
  
   % ANSITABLE_COLUMN_STYLES='{"2":{"type":"num"},"3":{"type":"str"}}' ansitable-list-border-styles
  
  will display the bool columns as num and str instead.
  
  =head2 ANSITABLE_ROW_STYLES => str(json)
  
  Can be used to set per-row styles. Interpreted right before draw(). Value should
  be a JSON-encoded a hash of C<< row_num => {style => val, ...} >> pairs.
  Example:
  
   % ANSITABLE_ROW_STYLES='{"0":{"bgcolor":"000080","vpad":1}}' ansitable-list-border-styles
  
  will display the first row with blue background color and taller height.
  
  =head2 ANSITABLE_CELL_STYLES => str(json)
  
  Can be used to set per-cell styles. Interpreted right before draw(). Value
  should be a JSON-encoded a hash of C<< "row_num,col" => {style => val, ...} >>
  pairs. Example:
  
   % ANSITABLE_CELL_STYLES='{"1,1":{"bgcolor":"008000"}}' ansitable-list-border-styles
  
  will display the second-on-the-left, second-on-the-top cell with green
  background color.
  
  =head2 ANSITABLE_STYLE_SETS => str(json)
  
  Can be used to apply style sets. Value should be a JSON-encoded array. Each
  element must be a style set name or a 2-element array containing style set name
  and its arguments (C<< [$name, \%args] >>). Example:
  
   % ANSITABLE_STYLE_SETS='[["AltRow",{"odd_bgcolor":"003300"}]]'
  
  will display table with row separator lines after every row.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Text-ANSITable>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Text-ANSITable>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Text-ANSITable>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  =head2 Related to Text::ANSITable family
  
  For collections of border styles, search for C<Text::ANSITable::BorderStyle::*>
  modules.
  
  For collections of color themes, search for C<Text::ANSITable::ColorTheme::*>
  modules.
  
  =head2 Other table-formatting CPAN modules
  
  L<Text::ASCIITable> is one of the most popular table-formatting module. There
  are a couple of "extensions" for Text::ASCIITable: L<Text::ASCIITable::TW>,
  L<Text::ASCIITable::Wrap>; Text::ANSITable can be an alternative for all those
  modules since it can already handle wide-characters, multiline text in cells.
  
  L<Text::TabularDisplay>
  
  L<Text::Table>
  
  L<Text::SimpleTable>
  
  L<Text::UnicodeTable::Simple>
  
  L<Table::Simple>
  
  =head2 Other
  
  Unix command B<column> (e.g. C<column -t>).
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEXT_ANSITABLE

$fatpacked{"Text/ANSITable/BorderStyle/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_ANSITABLE_BORDERSTYLE_DEFAULT';
  package Text::ANSITable::BorderStyle::Default;
  
  our $DATE = '2018-05-31'; # DATE
  our $VERSION = '0.500'; # VERSION
  
  use 5.010;
  use strict;
  use utf8;
  use warnings;
  
  our %border_styles = (
  
      # none
  
      none_ascii => {
          summary => 'No border',
          chars => [
              ['','','',''],     # 0
              ['','',''],        # 1
              ['','','',''],     # 2
              ['','',''],        # 3
              [' ','-','-',' '], # 4
              ['','','',''],     # 5
          ],
      },
  
      none_boxchar => {
          summary => 'No border',
          chars => [
              ['','','',''],     # 0
              ['','',''],        # 1
              ['','','',''],     # 2
              ['','',''],        # 3
              ['','q','q',''],   # 4
              ['','','',''],     # 5
          ],
          box_chars => 1,
      },
  
      none_utf8 => {
          summary => 'No border',
          chars => [
              ['','','',''],     # 0
              ['','',''],        # 1
              ['','','',''],     # 2
              ['','',''],        # 3
              ['','','',''],   # 4
              ['','','',''],     # 5
          ],
          utf8 => 1,
      },
  
  
      # space
  
      space_ascii => {
          summary => 'Space as border',
          chars => [
              [' ',' ',' ',' '], # 0
              [' ',' ',' '],     # 1
              [' ',' ',' ',' '], # 2
              [' ',' ',' '],     # 3
              [' ','-','-',' '], # 4
              [' ',' ',' ',' '], # 5
          ],
      },
  
      space_boxchar => {
          summary => 'Space as border',
          chars => [
              [' ',' ',' ',' '], # 0
              [' ',' ',' '],     # 1
              [' ',' ',' ',' '], # 2
              [' ',' ',' '],     # 3
              [' ','q','q',' '], # 4
              [' ',' ',' ',' '], # 5
          ],
          box_chars => 1,
      },
  
      space_utf8 => {
          summary => 'Space as border',
          chars => [
              [' ',' ',' ',' '], # 0
              [' ',' ',' '],     # 1
              [' ',' ',' ',' '], # 2
              [' ',' ',' '],     # 3
              [' ','','',' '], # 4
              [' ',' ',' ',' '], # 5
          ],
          utf8 => 1,
      },
  
      spacei_ascii => {
          summary => 'Space, inner-only',
          chars => [
              ['','','',''],   # 0
              ['',' ',''],     # 1
              ['',' ',' ',''], # 2
              ['',' ',''],     # 3
              ['','-','-',''], # 4
              ['','','',''],   # 5
          ],
      },
  
      spacei_boxchar => {
          summary => 'Space, inner-only',
          chars => [
              ['','','',''],   # 0
              ['',' ',''],     # 1
              ['',' ',' ',''], # 2
              ['',' ',''],     # 3
              ['','q','q',''], # 4
              ['','','',''],   # 5
          ],
          box_chars => 1,
      },
  
      spacei_utf8 => {
          summary => 'Space, inner-only',
          chars => [
              ['','','',''],   # 0
              ['',' ',''],     # 1
              ['',' ',' ',''], # 2
              ['',' ',''],     # 3
              ['','','',''], # 4
              ['','','',''],   # 5
          ],
          utf8 => 1,
      },
  
      # single
  
      single_ascii => {
          summary => 'Single',
          chars => [
              ['.','-','+','.'], # 0
              ['|','|','|'],     # 1
              ['+','-','+','+'], # 2
              ['|','|','|'],     # 3
              ['+','-','+','+'], # 4
              ['`','-','+',"'"], # 5
          ],
      },
  
      single_boxchar => {
          summary => 'Single',
          chars => [
              ['l','q','w','k'], # 0
              ['x','x','x'],     # 1
              ['t','q','n','u'], # 2
              ['x','x','x'],     # 3
              ['t','q','n','u'], # 4
              ['m','q','v','j'], # 5
          ],
          box_chars => 1,
      },
  
      single_utf8 => {
          summary => 'Single',
          chars => [
              ['','','',''], # 0
              ['','',''],     # 1
              ['','','',''], # 2
              ['','',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      # single, horizontal only
  
      singleh_ascii => {
          summary => 'Single, horizontal only',
          chars => [
              ['-','-','-','-'], # 0
              [' ',' ',' '],     # 1
              ['-','-','-','-'], # 2
              [' ',' ',' '],     # 3
              ['-','-','-','-'], # 4
              ['-','-','-','-'], # 5
          ],
      },
  
      singleh_boxchar => {
          summary => 'Single, horizontal only',
          chars => [
              ['q','q','q','q'], # 0
              [' ',' ',' '],     # 1
              ['q','q','q','q'], # 2
              [' ',' ',' '],     # 3
              ['q','q','q','q'], # 4
              ['q','q','q','q'], # 5
          ],
          box_chars => 1,
      },
  
      singleh_utf8 => {
          summary => 'Single, horizontal only',
          chars => [
              ['','','',''], # 0
              [' ',' ',' '],     # 1
              ['','','',''], # 2
              [' ',' ',' '],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      # single, vertical only
  
      singlev_ascii => {
          summary => 'Single border, only vertical',
          chars => [
              ['|',' ','|','|'], # 0
              ['|','|','|'],     # 1
              ['|',' ','|','|'], # 2
              ['|','|','|'],     # 3
              ['|','-','|','|'], # 4
              ['|',' ','|','|'], # 5
          ],
      },
  
      singlev_boxchar => {
          summary => 'Single, vertical only',
          chars => [
              ['x',' ','x','x'], # 0
              ['x','x','x'],     # 1
              ['x',' ','x','x'], # 2
              ['x','x','x'],     # 3
              ['x','q','x','x'], # 4
              ['x',' ','x','x'], # 5
          ],
          box_chars => 1,
      },
  
      singlev_utf8 => {
          summary => 'Single, vertical only',
          chars => [
              ['',' ','',''], # 0
              ['','',''],     # 1
              ['',' ','',''], # 2
              ['','',''],     # 3
              ['','','',''], # 4
              ['',' ','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      # single, inner only
  
      singlei_ascii => {
          summary => 'Single, inner only (like in psql command-line client)',
          chars => [
              ['','','',''],     # 0
              [' ','|',' '],     # 1
              [' ','-','+',' '], # 2
              [' ','|',' '],     # 3
              [' ','-','+',' '], # 4
              ['','','',''],     # 5
          ],
      },
  
      singlei_boxchar => {
          summary => 'Single, inner only (like in psql command-line client)',
          chars => [
              ['','','',''],     # 0
              [' ','x',' '],     # 1
              [' ','q','n',' '], # 2
              [' ','x',' '],     # 3
              [' ','q','n',' '], # 4
              ['','','',''],     # 5
          ],
          box_chars => 1,
      },
  
      singlei_utf8 => {
          summary => 'Single, inner only (like in psql command-line client)',
          chars => [
              ['','','',''],     # 0
              [' ','',' '],     # 1
              [' ','','',' '], # 2
              [' ','',' '],     # 3
              [' ','','',' '], # 4
              ['','','',''],     # 5
          ],
          utf8 => 1,
      },
  
  
      # single, outer only
  
      singleo_ascii => {
          summary => 'Single, outer only',
          chars => [
              ['.','-','-','.'], # 0
              ['|',' ','|'],     # 1
              ['|',' ',' ','|'], # 2
              ['|',' ','|'],     # 3
              ['+','-','-','+'], # 4
              ['`','-','-',"'"], # 5
          ],
      },
  
      singleo_boxchar => {
          summary => 'Single, outer only',
          chars => [
              ['l','q','q','k'], # 0
              ['x',' ','x'],     # 1
              ['x',' ',' ','x'], # 2
              ['x',' ','x'],     # 3
              ['t','q','q','u'], # 4
              ['m','q','q','j'], # 5
          ],
          box_chars => 1,
      },
  
      singleo_utf8 => {
          summary => 'Single, outer only',
          chars => [
              ['','','',''], # 0
              ['',' ',''],     # 1
              ['',' ',' ',''], # 2
              ['',' ',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      # curved single
  
      csingle => {
          summary => 'Curved single',
          chars => [
              ['','','',''], # 0
              ['','',''],     # 1
              ['','','',''], # 2
              ['','',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      # bold single
  
      bold => {
          summary => 'Bold',
          chars => [
              ['','','',''], # 0
              ['','',''],     # 1
              ['','','',''], # 2
              ['','',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      #boldv => {
      #    summary => 'Vertically-bold',
      #},
  
  
      #boldh => {
      #    summary => 'Horizontally-bold',
      #},
  
  
      # double
  
      double => {
          summary => 'Double',
          chars => [
              ['','','',''], # 0
              ['','',''],     # 1
              ['','','',''], # 2
              ['','',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  
      # brick
  
      brick => {
          summary => 'Single, bold on bottom right to give illusion of depth',
          chars => [
              ['','','',''], # 0
              ['','',''],     # 1
              ['','','',''], # 2
              ['','',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
      bricko => {
          summary => 'Single, outer only, '.
              'bold on bottom right to give illusion of depth',
          chars => [
              ['','','',''], # 0
              ['',' ',''],     # 1
              ['',' ',' ',''], # 2
              ['',' ',''],     # 3
              ['','','',''], # 4
              ['','','',''], # 5
          ],
          utf8 => 1,
      },
  
  );
  
  1;
  # ABSTRACT: Default border styles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Text::ANSITable::BorderStyle::Default - Default border styles
  
  =head1 VERSION
  
  This document describes version 0.500 of Text::ANSITable::BorderStyle::Default (from Perl distribution Text-ANSITable), released on 2018-05-31.
  
  =head1 BORDER STYLES
  
  Below are the border styles included in this package:
  
  =head2 Default::bold
  
  Bold (utf8: yes, box_chars: no).
  
   
    column1  column2 
   
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
   
  
  
  =head2 Default::brick
  
  Single, bold on bottom right to give illusion of depth (utf8: yes, box_chars: no).
  
   
    column1  column2 
   
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
   
  
  
  =head2 Default::bricko
  
  Single, outer only, bold on bottom right to give illusion of depth (utf8: yes, box_chars: no).
  
   
    column1   column2 
                      
    row1.1    row1.2  
    row2.1    row3.2  
   
    row3.1    row3.2  
   
  
  
  =head2 Default::csingle
  
  Curved single (utf8: yes, box_chars: no).
  
   
    column1  column2 
   
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
   
  
  
  =head2 Default::double
  
  Double (utf8: yes, box_chars: no).
  
   
    column1  column2 
   
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
   
  
  
  =head2 Default::none_ascii
  
  No border (utf8: no, box_chars: no).
  
    column1  column2 
    row1.1   row1.2  
    row2.1   row3.2  
    ------------------- 
    row3.1   row3.2  
  
  
  =head2 Default::none_boxchar
  
  No border (utf8: no, box_chars: yes).
  
  =head2 Default::none_utf8
  
  No border (utf8: yes, box_chars: no).
  
    column1  column2 
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
  
  
  =head2 Default::single_ascii
  
  Single (utf8: no, box_chars: no).
  
   .---------+---------.
   | column1 | column2 |
   +---------+---------+
   | row1.1  | row1.2  |
   | row2.1  | row3.2  |
   +---------+---------+
   | row3.1  | row3.2  |
   `---------+---------'
  
  
  =head2 Default::single_boxchar
  
  Single (utf8: no, box_chars: yes).
  
  =head2 Default::single_utf8
  
  Single (utf8: yes, box_chars: no).
  
   
    column1  column2 
   
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
   
  
  
  =head2 Default::singleh_ascii
  
  Single, horizontal only (utf8: no, box_chars: no).
  
   ---------------------
     column1   column2  
   ---------------------
     row1.1    row1.2   
     row2.1    row3.2   
   ---------------------
     row3.1    row3.2   
   ---------------------
  
  
  =head2 Default::singleh_boxchar
  
  Single, horizontal only (utf8: no, box_chars: yes).
  
  =head2 Default::singleh_utf8
  
  Single, horizontal only (utf8: yes, box_chars: no).
  
   
     column1   column2  
   
     row1.1    row1.2   
     row2.1    row3.2   
   
     row3.1    row3.2   
   
  
  
  =head2 Default::singlei_ascii
  
  Single, inner only (like in psql command-line client) (utf8: no, box_chars: no).
  
     column1 | column2  
    ---------+--------- 
     row1.1  | row1.2   
     row2.1  | row3.2   
    ---------+--------- 
     row3.1  | row3.2   
  
  
  =head2 Default::singlei_boxchar
  
  Single, inner only (like in psql command-line client) (utf8: no, box_chars: yes).
  
  =head2 Default::singlei_utf8
  
  Single, inner only (like in psql command-line client) (utf8: yes, box_chars: no).
  
     column1  column2  
     
     row1.1   row1.2   
     row2.1   row3.2   
     
     row3.1   row3.2   
  
  
  =head2 Default::singleo_ascii
  
  Single, outer only (utf8: no, box_chars: no).
  
   .-------------------.
   | column1   column2 |
   |                   |
   | row1.1    row1.2  |
   | row2.1    row3.2  |
   +-------------------+
   | row3.1    row3.2  |
   `-------------------'
  
  
  =head2 Default::singleo_boxchar
  
  Single, outer only (utf8: no, box_chars: yes).
  
  =head2 Default::singleo_utf8
  
  Single, outer only (utf8: yes, box_chars: no).
  
   
    column1   column2 
                      
    row1.1    row1.2  
    row2.1    row3.2  
   
    row3.1    row3.2  
   
  
  
  =head2 Default::singlev_ascii
  
  Single border, only vertical (utf8: no, box_chars: no).
  
   |         |         |
   | column1 | column2 |
   |         |         |
   | row1.1  | row1.2  |
   | row2.1  | row3.2  |
   |---------|---------|
   | row3.1  | row3.2  |
   |         |         |
  
  
  =head2 Default::singlev_boxchar
  
  Single, vertical only (utf8: no, box_chars: yes).
  
  =head2 Default::singlev_utf8
  
  Single, vertical only (utf8: yes, box_chars: no).
  
                     
    column1  column2 
                     
    row1.1   row1.2  
    row2.1   row3.2  
   
    row3.1   row3.2  
                     
  
  
  =head2 Default::space_ascii
  
  Space as border (utf8: no, box_chars: no).
  
                        
     column1   column2  
                        
     row1.1    row1.2   
     row2.1    row3.2   
    ------------------- 
     row3.1    row3.2   
                        
  
  
  =head2 Default::space_boxchar
  
  Space as border (utf8: no, box_chars: yes).
  
  =head2 Default::space_utf8
  
  Space as border (utf8: yes, box_chars: no).
  
                        
     column1   column2  
                        
     row1.1    row1.2   
     row2.1    row3.2   
     
     row3.1    row3.2   
                        
  
  
  =head2 Default::spacei_ascii
  
  Space, inner-only (utf8: no, box_chars: no).
  
    column1   column2 
    row1.1    row1.2  
    row2.1    row3.2  
   -------------------
    row3.1    row3.2  
  
  
  =head2 Default::spacei_boxchar
  
  Space, inner-only (utf8: no, box_chars: yes).
  
  =head2 Default::spacei_utf8
  
  Space, inner-only (utf8: yes, box_chars: no).
  
    column1   column2 
    row1.1    row1.2  
    row2.1    row3.2  
   
    row3.1    row3.2  
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Text-ANSITable>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Text-ANSITable>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Text-ANSITable>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEXT_ANSITABLE_BORDERSTYLE_DEFAULT

$fatpacked{"Text/ANSITable/ColorTheme/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_ANSITABLE_COLORTHEME_DEFAULT';
  package Text::ANSITable::ColorTheme::Default;
  
  our $DATE = '2018-05-31'; # DATE
  our $VERSION = '0.500'; # VERSION
  
  use 5.010;
  use strict;
  use warnings;
  
  use Color::RGB::Util qw(mix_2_rgb_colors);
  use Function::Fallback::CoreOrPP qw(clone);
  
  our %color_themes = (
  
      no_color => {
          v => 1.1,
          summary => 'Special theme that means no color',
          colors => {
          },
          no_color => 1,
      },
  
      #default_16 => {
      #    v => 1.1,
      #    summary => 'Default for 16-color terminal',
      #    colors => {
      #    },
      #},
  
      #default_256 => {
      default_gradation => {
          v => 1.1,
          summary => 'Default (for terminal with black background)',
          description => <<'_',
  
  Border color has gradation from top to bottom. Accept arguments C<border1> and
  C<border2> to set first (top) and second (bottom) foreground RGB colors. Colors
  will fade from the top color to bottom color. Also accept C<border1_bg> and
  C<border2_bg> to set background RGB colors.
  
  _
          colors => {
              border      => sub {
                  my ($self, %args) = @_;
  
                  my $pct = ($self->{_draw}{y}+1) / $self->{_draw}{table_height};
  
                  my $rgbf1 = $self->{color_theme_args}{border1} // $self->{color_theme}{data}{default_border1} // 'ffffff';
                  my $rgbf2 = $self->{color_theme_args}{border2} // $self->{color_theme}{data}{default_border2} // '444444';
                  my $rgbf  = mix_2_rgb_colors($rgbf1, $rgbf2, $pct);
  
                  my $rgbb1 = $self->{color_theme_args}{border1_bg};
                  my $rgbb2 = $self->{color_theme_args}{border2_bg};
                  my $rgbb;
                  if ($rgbb1 && $rgbb2) {
                      $rgbb = mix_2_rgb_colors($rgbb1, $rgbb2, $pct);
                  }
  
                  #say "D:$rgbf, $rgbb";
                  {fg=>$rgbf, bg=>$rgbb};
              },
  
              header      => '808080',
              header_bg   => undef,
              cell        => undef,
              cell_bg     => undef,
  
              num_data    => '66ffff',
              str_data    => undef,
              date_data   => 'aaaa00',
              bool_data   => sub {
                  my ($self, %args) = @_;
  
                  $args{orig_data} ? '00ff00' : 'ff0000';
              },
          },
      },
  
  );
  
  {
      my $ct = clone($color_themes{default_gradation});
      $ct->{summary} = 'Default (for terminal with white background)';
      $ct->{colors}{header_bg} = 'cccccc';
      $ct->{data}{default_border1} = '000000';
      $ct->{data}{default_border2} = 'cccccc';
      $ct->{colors}{num_data}  = '006666';
      $ct->{colors}{date_data} = '666600';
      $ct->{colors}{bool_data} = sub {
          my ($self, %args) = @_;
          $args{orig_data} ? '00cc00' : 'cc0000';
      };
      $color_themes{default_gradation_whitebg} = $ct;
  }
  
  
  {
      my $ct = clone($color_themes{default_gradation});
      $ct->{colors}{border} = '666666';
      delete $ct->{description};
      $color_themes{default_nogradation} = $ct;
  }
  
  {
      my $ct = clone($color_themes{default_gradation_whitebg});
      $ct->{colors}{border} = '666666';
      delete $ct->{description};
      $color_themes{default_nogradation_whitebg} = $ct;
  }
  
  1;
  # ABSTRACT: Default color themes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Text::ANSITable::ColorTheme::Default - Default color themes
  
  =head1 VERSION
  
  This document describes version 0.500 of Text::ANSITable::ColorTheme::Default (from Perl distribution Text-ANSITable), released on 2018-05-31.
  
  =head1 COLOR THEMES
  
  Below are the color themes included in this package:
  
  =head2 Default::default_gradation
  
  Default (for terminal with black background).
  
  
  Border color has gradation from top to bottom. Accept arguments C<border1> and
  C<border2> to set first (top) and second (bottom) foreground RGB colors. Colors
  will fade from the top color to bottom color. Also accept C<border1_bg> and
  C<border2_bg> to set background RGB colors.
  
  
  
  =head2 Default::default_gradation_whitebg
  
  Default (for terminal with white background).
  
  
  Border color has gradation from top to bottom. Accept arguments C<border1> and
  C<border2> to set first (top) and second (bottom) foreground RGB colors. Colors
  will fade from the top color to bottom color. Also accept C<border1_bg> and
  C<border2_bg> to set background RGB colors.
  
  
  
  =head2 Default::default_nogradation
  
  Default (for terminal with black background).
  
  =head2 Default::default_nogradation_whitebg
  
  Default (for terminal with white background).
  
  =head2 Default::no_color
  
  Special theme that means no color.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Text-ANSITable>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Text-ANSITable>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Text-ANSITable>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEXT_ANSITABLE_COLORTHEME_DEFAULT

$fatpacked{"Text/ANSITable/StyleSet/AltRow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_ANSITABLE_STYLESET_ALTROW';
  package Text::ANSITable::StyleSet::AltRow;
  
  our $DATE = '2018-05-31'; # DATE
  our $VERSION = '0.500'; # VERSION
  
  use 5.010;
  use Moo;
  use namespace::clean;
  
  has odd_bgcolor  => (is => 'rw');
  has even_bgcolor => (is => 'rw');
  has odd_fgcolor  => (is => 'rw');
  has even_fgcolor => (is => 'rw');
  
  sub summary {
      "Set different foreground and/or background color for odd/even rows";
  }
  
  sub apply {
      my ($self, $table) = @_;
  
      $table->add_cond_row_style(
          sub {
              my ($t, %args) = @_;
              my %styles;
              # because we count from 0
              if ($_ % 2 == 0) {
                  $styles{bgcolor} = $self->odd_bgcolor
                      if defined $self->odd_bgcolor;
                  $styles{fgcolor}=$self->odd_fgcolor
                      if defined $self->odd_fgcolor;
              } else {
                  $styles{bgcolor} = $self->even_bgcolor
                      if defined $self->even_bgcolor;
                  $styles{fgcolor} = $self->even_fgcolor
                      if defined $self->even_fgcolor;
              }
              \%styles;
          },
      );
  }
  
  1;
  
  # ABSTRACT: Set different foreground and/or background color for odd/even rows";
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Text::ANSITable::StyleSet::AltRow - Set different foreground and/or background color for odd/even rows";
  
  =head1 VERSION
  
  This document describes version 0.500 of Text::ANSITable::StyleSet::AltRow (from Perl distribution Text-ANSITable), released on 2018-05-31.
  
  =for Pod::Coverage ^(summary|apply)$
  
  =head1 ATTRIBUTES
  
  =head2 odd_bgcolor
  
  =head2 odd_fgcolor
  
  =head2 even_bgcolor
  
  =head2 even_fgcolor
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Text-ANSITable>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Text-ANSITable>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Text-ANSITable>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEXT_ANSITABLE_STYLESET_ALTROW

$fatpacked{"darwin-2level/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_NAME';
  package Sub::Name; # git description: v0.20-2-gc0a0e62
  # ABSTRACT: (Re)name a sub
  # KEYWORDS: subroutine function utility name rename symbol
  
  #pod =pod
  #pod
  #pod =head1 SYNOPSIS
  #pod
  #pod     use Sub::Name;
  #pod
  #pod     subname $name, $subref;
  #pod
  #pod     $subref = subname foo => sub { ... };
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module has only one function, which is also exported by default:
  #pod
  #pod =for stopwords subname
  #pod
  #pod =head2 subname NAME, CODEREF
  #pod
  #pod Assigns a new name to referenced sub.  If package specification is omitted in
  #pod the name, then the current package is used.  The return value is the sub.
  #pod
  #pod The name is only used for informative routines (caller, Carp, etc).  You won't
  #pod be able to actually invoke the sub by the given name.  To allow that, you need
  #pod to do glob-assignment yourself.
  #pod
  #pod Note that for anonymous closures (subs that reference lexicals declared outside
  #pod the sub itself) you can name each instance of the closure differently, which
  #pod can be very useful for debugging.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<Sub::Identify> - for getting information about subs
  #pod * L<Sub::Util> - set_subname is another implementation of C<subname>
  #pod
  #pod =for stopwords cPanel
  #pod
  #pod =head1 COPYRIGHT AND LICENSE
  #pod
  #pod This software is copyright (c) 2004, 2008 by Matthijs van Duin, all rights reserved;
  #pod copyright (c) 2014 cPanel Inc., all rights reserved.
  #pod
  #pod This program is free software; you can redistribute it and/or modify
  #pod it under the same terms as Perl itself.
  #pod
  #pod =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.21';
  
  use Exporter 5.57 'import';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      $VERSION,
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Name - (Re)name a sub
  
  =head1 VERSION
  
  version 0.21
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =for stopwords subname
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't
  be able to actually invoke the sub by the given name.  To allow that, you need
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside
  the sub itself) you can name each instance of the closure differently, which
  can be very useful for debugging.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Sub::Identify> - for getting information about subs
  
  =item *
  
  L<Sub::Util> - set_subname is another implementation of C<subname>
  
  =back
  
  =for stopwords cPanel
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Sub-Name>
  (or L<bug-Sub-Name@rt.cpan.org|mailto:bug-Sub-Name@rt.cpan.org>).
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Leon Timmermans Florian Ragwitz Reini Urban Matthijs van Duin gfx Dagfinn Ilmari Mannsker Aristotle Pagaltzis J.R. Mash Alexander Bluhm
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Reini Urban <rurban@cpanel.net>
  
  =item *
  
  Matthijs van Duin <xmath-no-spam@nospam.cpan.org>
  
  =item *
  
  gfx <gfuji@cpan.org>
  
  =item *
  
  Dagfinn Ilmari Mannsker <ilmari@ilmari.org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  J.R. Mash <jmash.code@gmail.com>
  
  =item *
  
  Alexander Bluhm <alexander.bluhm@gmx.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2004, 2008 by Matthijs van Duin, all rights reserved;
  copyright (c) 2014 cPanel Inc., all rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SUB_NAME

$fatpacked{"darwin-2level/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
DARWIN-2LEVEL_VERSION

$fatpacked{"darwin-2level/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
DARWIN-2LEVEL_VERSION_REGEX

$fatpacked{"darwin-2level/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
DARWIN-2LEVEL_VERSION_VPP

$fatpacked{"darwin-2level/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
DARWIN-2LEVEL_VERSION_VXS

$fatpacked{"experimental.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPERIMENTAL';
  package experimental;
  $experimental::VERSION = '0.020';
  use strict;
  use warnings;
  use version ();
  
  BEGIN { eval { require feature } };
  use Carp qw/croak carp/;
  
  my %warnings = map { $_ => 1 } grep { /^experimental::/ } keys %warnings::Offsets;
  my %features = map { $_ => 1 } $] > 5.015006 ? keys %feature::feature : do {
  	my @features;
  	if ($] >= 5.010) {
  		push @features, qw/switch say state/;
  		push @features, 'unicode_strings' if $] > 5.011002;
  	}
  	@features;
  };
  
  my %min_version = (
  	array_base      => '5',
  	autoderef       => '5.14.0',
  	bitwise         => '5.22.0',
  	const_attr      => '5.22.0',
  	current_sub     => '5.16.0',
  	declared_refs   => '5.26.0',
  	evalbytes       => '5.16.0',
  	fc              => '5.16.0',
  	lexical_topic   => '5.10.0',
  	lexical_subs    => '5.18.0',
  	postderef       => '5.20.0',
  	postderef_qq    => '5.20.0',
  	refaliasing     => '5.22.0',
  	regex_sets      => '5.18.0',
  	say             => '5.10.0',
  	smartmatch      => '5.10.0',
  	signatures      => '5.20.0',
  	state           => '5.10.0',
  	switch          => '5.10.0',
  	unicode_eval    => '5.16.0',
  	unicode_strings => '5.12.0',
  );
  my %max_version = (
  	autoderef       => '5.23.1',
  	lexical_topic   => '5.23.4',
  );
  
  $_ = version->new($_) for values %min_version;
  $_ = version->new($_) for values %max_version;
  
  my %additional = (
  	postderef     => ['postderef_qq'],
  	switch        => ['smartmatch'],
  	declared_refs => ['refaliasing'],
  );
  
  sub _enable {
  	my $pragma = shift;
  	if ($warnings{"experimental::$pragma"}) {
  		warnings->unimport("experimental::$pragma");
  		feature->import($pragma) if exists $features{$pragma};
  		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif ($features{$pragma}) {
  		feature->import($pragma);
  		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif (not exists $min_version{$pragma}) {
  		croak "Can't enable unknown feature $pragma";
  	}
  	elsif ($] < $min_version{$pragma}) {
  		my $stable = $min_version{$pragma};
  		if ($stable->{version}[1] % 2) {
  			$stable = version->new(
  				"5.".($stable->{version}[1]+1).'.0'
  			);
  		}
  		croak "Need perl $stable or later for feature $pragma";
  	}
  	elsif ($] >= ($max_version{$pragma} || 7)) {
  		croak "Experimental feature $pragma has been removed from perl in version $max_version{$pragma}";
  	}
  }
  
  sub import {
  	my ($self, @pragmas) = @_;
  
  	for my $pragma (@pragmas) {
  		_enable($pragma);
  	}
  	return;
  }
  
  sub _disable {
  	my $pragma = shift;
  	if ($warnings{"experimental::$pragma"}) {
  		warnings->import("experimental::$pragma");
  		feature->unimport($pragma) if exists $features{$pragma};
  		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif ($features{$pragma}) {
  		feature->unimport($pragma);
  		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif (not exists $min_version{$pragma}) {
  		carp "Can't disable unknown feature $pragma, ignoring";
  	}
  }
  
  sub unimport {
  	my ($self, @pragmas) = @_;
  
  	for my $pragma (@pragmas) {
  		_disable($pragma);
  	}
  	return;
  }
  
  1;
  
  #ABSTRACT: Experimental features made easy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  experimental - Experimental features made easy
  
  =head1 VERSION
  
  version 0.020
  
  =head1 SYNOPSIS
  
   use experimental 'lexical_subs', 'smartmatch';
   my sub foo { $_[0] ~~ 1 }
  
  =head1 DESCRIPTION
  
  This pragma provides an easy and convenient way to enable or disable
  experimental features.
  
  Every version of perl has some number of features present but considered
  "experimental."  For much of the life of Perl 5, this was only a designation
  found in the documentation.  Starting in Perl v5.10.0, and more aggressively in
  v5.18.0, experimental features were placed behind pragmata used to enable the
  feature and disable associated warnings.
  
  The C<experimental> pragma exists to combine the required incantations into a
  single interface stable across releases of perl.  For every experimental
  feature, this should enable the feature and silence warnings for the enclosing
  lexical scope:
  
    use experimental 'feature-name';
  
  To disable the feature and, if applicable, re-enable any warnings, use:
  
    no experimental 'feature-name';
  
  The supported features, documented further below, are:
  
  =over 4
  
  =item * C<array_base> - allow the use of C<$[> to change the starting index of C<@array>.
  
  This is supported on all versions of perl.
  
  =item * C<autoderef> - allow push, each, keys, and other built-ins on references.
  
  This was added in perl 5.14.0 and removed in perl 5.23.1.
  
  =item * C<bitwise> - allow the new stringwise bit operators
  
  This was added in perl 5.22.0.
  
  =item * C<const_attr> - allow the :const attribute on subs
  
  This was added in perl 5.22.0.
  
  =item * C<lexical_topic> - allow the use of lexical C<$_> via C<my $_>.
  
  This was added in perl 5.10.0 and removed in perl 5.23.4.
  
  =item * C<lexical_subs> - allow the use of lexical subroutines.
  
  This was added in 5.18.0.
  
  =item * C<postderef> - allow the use of postfix dereferencing expressions,
  including in interpolating strings
  
  This was added in perl 5.20.0.
  
  =item * C<re_strict> - enables strict mode in regular expressions
  
  This was added in perl 5.22.0.
  
  =item * C<refaliasing> - allow aliasing via C<\$x = \$y>
  
  This was added in perl 5.22.0.
  
  =item * C<regex_sets> - allow extended bracketed character classes in regexps
  
  This was added in perl 5.18.0.
  
  =item * C<signatures> - allow subroutine signatures (for named arguments)
  
  This was added in perl 5.20.0.
  
  =item * C<smartmatch> - allow the use of C<~~>
  
  This was added in perl 5.10.0, but it should be noted there are significant
  incompatibilities between 5.10.0 and 5.10.1.
  
  =item * C<switch> - allow the use of C<~~>, given, and when
  
  This was added in perl 5.10.0.
  
  =item * C<win32_perlio> - allows the use of the :win32 IO layer.
  
  This was added on perl 5.22.0.
  
  =back
  
  =head2 Ordering matters
  
  Using this pragma to 'enable an experimental feature' is another way of saying
  that this pragma will disable the warnings which would result from using that
  feature.  Therefore, the order in which pragmas are applied is important.  In
  particular, you probably want to enable experimental features I<after> you
  enable warnings:
  
    use warnings;
    use experimental 'smartmatch';
  
  You also need to take care with modules that enable warnings for you.  A common
  example being Moose.  In this example, warnings for the 'smartmatch' feature are
  first turned on by the warnings pragma, off by the experimental pragma and back
  on again by the Moose module (fix is to switch the last two lines):
  
    use warnings;
    use experimental 'smartmatch';
    use Moose;
  
  =head2 Disclaimer
  
  Because of the nature of the features it enables, forward compatibility can not
  be guaranteed in any way.
  
  =head1 SEE ALSO
  
  L<perlexperimental|perlexperimental> contains more information about experimental features.
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXPERIMENTAL

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use Moo::_strictures;
  use Moo::_Utils qw(_load_module);
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  oo - syntactic sugar for Moo oneliners
  
  =head1 SYNOPSIS
  
    perl -Moo=Foo -e 'has bar => ( is => q[ro], default => q[baz] ); print Foo->new->bar'
  
    # loads an existing class and re-"opens" the package definition
    perl -Moo=+My::Class -e 'print __PACKAGE__->new->bar'
  
  =head1 DESCRIPTION
  
  oo.pm is a simple source filter that adds C<package $name; use Moo;> to the
  beginning of your script, intended for use on the command line via the -M
  option.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
OO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


our $DATE = '2018-05-31'; # DATE
our $VERSION = '0.500'; # VERSION

use 5.010;
use strict;
use warnings;

use Text::ANSITable;

binmode(STDOUT, ":encoding(utf8)");

my $t = Text::ANSITable->new;

if ($ARGV[0]) {
    $t->border_style($ARGV[0]);
}

my $all_bs = $t->list_border_styles(1);

$t->columns(['Name', 'Summary', 'box_chars?', 'utf8?']);
my $utf8; # we sort by not utf8 and then utf8, just to demonstrate add_row_separator
for my $name (sort {($all_bs->{$a}{utf8} ? 1:0)<=>($all_bs->{$b}{utf8} ? 1:0) || $a cmp $b} keys %$all_bs) {
    my $bs = $all_bs->{$name};
    my $selected = $name eq $t->border_style->{name};
    $t->add_row(
        [$name . ($selected ? " (*)" : ""), $bs->{summary}, $bs->{box_chars} ? 1:0, $bs->{utf8} ? 1:0],
        {fgcolor=>$selected && $t->use_color ? "aaaa00" : undef});

    if (!$utf8 && $bs->{utf8}) {
        $t->add_row_separator;
        $utf8++;
    }
}

say "Tip: you can run me with border style name as argument to try it out.";
print $t->draw;

#use Data::Dump; dd $t->{_row_separators}; dd $t->{_draw}{frow_separators};

# ABSTRACT: List available border styles for Text::ANSITable
# PODNAME: ansitable-list-border-styles

__END__

=pod

=encoding UTF-8

=head1 NAME

ansitable-list-border-styles - List available border styles for Text::ANSITable

=head1 VERSION

This document describes version 0.500 of ansitable-list-border-styles (from Perl distribution Text-ANSITable), released on 2018-05-31.

=head1 SYNOPSIS

 % ansitable-list-border-styles

Sample output:

 Tip: you can run me with border style name as argument to try it out.
 .----------------------------------------------------------------------------------------------------------------------.
 | Name                         Summary                                                              box_chars?   utf8? |
 |                                                                                                                      |
 | Default::none_ascii          No border                                                                N          N   |
 | Default::none_boxchar        No border                                                                Y          N   |
 | Default::single_ascii        Single                                                                   N          N   |
 | Default::single_boxchar      Single                                                                   Y          N   |
 | Default::singleh_ascii       Single, horizontal only                                                  N          N   |
 | Default::singleh_boxchar     Single, horizontal only                                                  Y          N   |
 | Default::singlei_ascii       Single, inner only (like in psql command-line client)                    N          N   |
 | Default::singlei_boxchar     Single, inner only (like in psql command-line client)                    Y          N   |
 | Default::singleo_ascii (*)   Single, outer only                                                       N          N   |
 | Default::singleo_boxchar     Single, outer only                                                       Y          N   |
 | Default::singlev_ascii       Single border, only vertical                                             N          N   |
 | Default::singlev_boxchar     Single, vertical only                                                    Y          N   |
 | Default::space_ascii         Space as border                                                          N          N   |
 | Default::space_boxchar       Space as border                                                          Y          N   |
 | Default::spacei_ascii        Space, inner-only                                                        N          N   |
 | Default::spacei_boxchar      Space, inner-only                                                        Y          N   |
 | Demo::demo_custom_char       Demoes coderef in chars                                                  N          N   |
 | Default::bold                Bold                                                                     N          Y   |
 +----------------------------------------------------------------------------------------------------------------------+
 | Default::brick               Single, bold on bottom right to give illusion of depth                   N          Y   |
 | Default::bricko              Single, outer only, bold on bottom right to give illusion of depth       N          Y   |
 | Default::csingle             Curved single                                                            N          Y   |
 | Default::double              Double                                                                   N          Y   |
 | Default::none_utf8           No border                                                                N          Y   |
 | Default::single_utf8         Single                                                                   N          Y   |
 | Default::singleh_utf8        Single, horizontal only                                                  N          Y   |
 | Default::singlei_utf8        Single, inner only (like in psql command-line client)                    N          Y   |
 | Default::singleo_utf8        Single, outer only                                                       N          Y   |
 | Default::singlev_utf8        Single, vertical only                                                    N          Y   |
 | Default::space_utf8          Space as border                                                          N          Y   |
 | Default::spacei_utf8         Space, inner-only                                                        N          Y   |
 | Extra::dash2                 Dash 2                                                                   N          Y   |
 | Extra::dash3                 Dash 3                                                                   N          Y   |
 | Extra::hboldh_dsingle        Horizontally-bold for header, single for data                            N          Y   |
 | Extra::hdoubleh_dsingle      Horizontally-double for header, single for data                          N          Y   |
 `----------------------------------------------------------------------------------------------------------------------'

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/Text-ANSITable>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-Text-ANSITable>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Text-ANSITable>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2018, 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
