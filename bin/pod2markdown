#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Pod/Markdown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MARKDOWN';
  # vim: set ts=2 sts=2 sw=2 expandtab smarttab:
  #
  # This file is part of Pod-Markdown
  #
  # This software is copyright (c) 2011 by Randy Stauner.
  #
  # This is free software; you can redistribute it and/or modify it under
  # the same terms as the Perl 5 programming language system itself.
  #
  use 5.008;
  use strict;
  use warnings;
  
  package Pod::Markdown;
  # git description: v3.004-0-g69a7b15
  
  our $AUTHORITY = 'cpan:RWSTAUNER';
  # ABSTRACT: Convert POD to Markdown
  $Pod::Markdown::VERSION = '3.005';
  use Pod::Simple 3.27 (); # detected_encoding and keep_encoding bug fix
  use parent qw(Pod::Simple::Methody);
  use Encode ();
  
  our %URL_PREFIXES = (
    sco      => 'http://search.cpan.org/perldoc?',
    metacpan => 'https://metacpan.org/pod/',
    man      => 'http://man.he.net/man',
  );
  $URL_PREFIXES{perldoc} = $URL_PREFIXES{metacpan};
  
  #{
    our $HAS_HTML_ENTITIES;
  
    # Stolen from Pod::Simple::XHTML 3.28. {{{
  
    BEGIN {
      $HAS_HTML_ENTITIES = eval "require HTML::Entities; 1";
    }
  
    my %entities = (
      q{>} => 'gt',
      q{<} => 'lt',
      q{'} => '#39',
      q{"} => 'quot',
      q{&} => 'amp',
    );
  
    sub encode_entities {
      my $self = shift;
      my $ents = $self->html_encode_chars;
      return HTML::Entities::encode_entities( $_[0], $ents ) if $HAS_HTML_ENTITIES;
      if (defined $ents) {
          $ents =~ s,(?<!\\)([]/]),\\$1,g;
          $ents =~ s,(?<!\\)\\\z,\\\\,;
      } else {
          $ents = join '', keys %entities;
      }
      my $str = $_[0];
      $str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;
      return $str;
    }
  
    # }}}
  
    # Add a few very common ones for consistency and readability
    # (in case HTML::Entities isn't available).
    %entities = (
      # Pod::Markdown has always required 5.8 so unicode_to_native will be available.
      chr(utf8::unicode_to_native(0xA0)) => 'nbsp',
      chr(utf8::unicode_to_native(0xA9)) => 'copy',
      %entities
    );
  
    sub __entity_encode_ord_he {
      my $chr = chr $_[0];
      # Skip the encode_entities() logic and go straight for the substitution
      # since we already have the char we know we want replaced.
      # Both the hash and the function are documented as exportable (so should be reliable).
      return $HTML::Entities::char2entity{ $chr } || HTML::Entities::num_entity( $chr );
    }
    sub __entity_encode_ord_basic {
      return '&' . ($entities{chr $_[0]} || sprintf '#x%X', $_[0]) . ';';
    }
  
    # From HTML::Entities 3.69
    my $DEFAULT_ENTITY_CHARS = '^\n\r\t !\#\$%\(-;=?-~';
  
  #}
  
  # Use hash for simple "exists" check in `new` (much more accurate than `->can`).
  my %attributes = map { ($_ => 1) }
    qw(
      html_encode_chars
      match_encoding
      output_encoding
      man_url_prefix
      perldoc_url_prefix
      perldoc_fragment_format
      markdown_fragment_format
      include_meta_tags
    );
  
  
  sub new {
    my $class = shift;
    my %args = @_;
  
    my $self = $class->SUPER::new();
    $self->preserve_whitespace(1);
    $self->nbsp_for_S(1);
    $self->accept_targets(qw( markdown html ));
  
    while( my ($attr, $val) = each %args ){
      # NOTE: Checking exists on a private var means we don't allow Pod::Simple
      # attributes to be set this way.  It's not very consistent, but I think
      # I'm ok with that for now since there probably aren't many Pod::Simple attributes
      # being changed besides `output_*` which feel like API rather than attributes.
      # We'll see.
      # This is currently backward-compatible as we previously just put the attribute
      # into the private stash so anything unknown was silently ignored.
      # We could open this up to `$self->can($attr)` in the future if that seems better
      # but it tricked me when I was testing a misspelled attribute name
      # which also happened to be a Pod::Simple method.
  
      exists $attributes{ $attr } or
        # Provide a more descriptive message than "Can't locate object method".
        warn("Unknown argument to ${class}->new(): '$attr'"), next;
  
      # Call setter.
      $self->$attr($val);
    }
  
      # TODO: move this logic to setter (and call _prepare_fragment_format).
      for my $type ( qw( perldoc man ) ){
          my $attr  = $type . '_url_prefix';
          # Use provided argument or default alias.
          my $url = $self->$attr || $type;
          # Expand alias if defined (otherwise use url as is).
          $self->$attr( $URL_PREFIXES{ $url } || $url );
      }
  
      $self->_prepare_fragment_formats;
  
    return $self;
  }
  
  ## Attribute accessors ##
  
  
  sub html_encode_chars {
    my $self  = shift;
    my $stash = $self->_private;
  
    # Setter.
    if( @_ ){
      # If false ('', 0, undef), disable.
      if( !$_[0] ){
        delete $stash->{html_encode_chars};
        $stash->{encode_amp}  = 1;
        $stash->{encode_lt}   = 1;
      }
      else {
        # Special case boolean '1' to mean "all".
        # If we have HTML::Entities, undef will use the default.
        # Without it, we need to specify so that we use the same list (for consistency).
        $stash->{html_encode_chars} = $_[0] eq '1' ? ($HAS_HTML_ENTITIES ? undef : $DEFAULT_ENTITY_CHARS) : $_[0];
  
        # If [char] doesn't get encoded, we need to do it ourselves.
        $stash->{encode_amp}  = ($self->encode_entities('&') eq '&');
        $stash->{encode_lt}   = ($self->encode_entities('<') eq '<');
      }
      return;
    }
  
    # Getter.
    return $stash->{html_encode_chars};
  }
  
  
  # I prefer ro-accessors (immutability!) but it can be confusing
  # to not support the same API as other Pod::Simple classes.
  
  # NOTE: Pod::Simple::_accessorize is not a documented public API.
  # Skip any that have already been defined.
  __PACKAGE__->_accessorize(grep { !__PACKAGE__->can($_) } keys %attributes);
  
  sub _prepare_fragment_formats {
    my ($self) = @_;
  
    foreach my $attr ( keys %attributes ){
      next unless $attr =~ /^(\w+)_fragment_format/;
      my $type = $1;
      my $format = $self->$attr;
  
      # If one was provided.
      if( $format ){
        # If the attribute is a coderef just use it.
        next if ref($format) eq 'CODE';
      }
      # Else determine a default.
      else {
        if( $type eq 'perldoc' ){
          # Choose a default that matches the destination url.
          my $target = $self->perldoc_url_prefix;
          foreach my $alias ( qw( metacpan sco ) ){
            if( $target eq $URL_PREFIXES{ $alias } ){
              $format = $alias;
            }
          }
          # This seems like a reasonable fallback.
          $format ||= 'pod_simple_xhtml';
        }
        else {
          $format = $type;
        }
      }
  
      # The short name should become a method name with the prefix prepended.
      my $prefix = 'format_fragment_';
      $format =~ s/^$prefix//;
      die "Unknown fragment format '$format'"
        unless $self->can($prefix . $format);
  
      # Save it.
      $self->$attr($format);
    }
  
    return;
  }
  
  ## Backward compatible API ##
  
  # For backward compatibility (previously based on Pod::Parser):
  # While Pod::Simple provides a parse_from_file() method
  # it's primarily for Pod::Parser compatibility.
  # When called without an output handle it will print to STDOUT
  # but the old Pod::Markdown never printed to a handle
  # so we don't want to start now.
  sub parse_from_file {
    my ($self, $file) = @_;
  
    # TODO: Check that all dependent cpan modules use the Pod::Simple API
    # then add a deprecation warning here to avoid confusion.
  
    $self->output_string(\($self->{_as_markdown_}));
    $self->parse_file($file);
  }
  
  # Likewise, though Pod::Simple doesn't define this method at all.
  sub parse_from_filehandle { shift->parse_from_file(@_) }
  
  
  ## Document state ##
  
  sub _private {
    my ($self) = @_;
    $self->{_Pod_Markdown_} ||= {
      indent      => 0,
      stacks      => [],
      states      => [{}],
      link        => [],
      encode_amp  => 1,
      encode_lt   => 1,
    };
  }
  
  sub _increase_indent {
    ++$_[0]->_private->{indent} >= 1
      or die 'Invalid state: indent < 0';
  }
  sub _decrease_indent {
    --$_[0]->_private->{indent} >= 0
      or die 'Invalid state: indent < 0';
  }
  
  sub _new_stack {
    push @{ $_[0]->_private->{stacks} }, [];
    push @{ $_[0]->_private->{states} }, {};
  }
  
  sub _last_string {
    $_[0]->_private->{stacks}->[-1][-1];
  }
  
  sub _pop_stack_text {
    $_[0]->_private->{last_state} = pop @{ $_[0]->_private->{states} };
    join '', @{ pop @{ $_[0]->_private->{stacks} } };
  }
  
  sub _stack_state {
    $_[0]->_private->{states}->[-1];
  }
  
  sub _save {
    my ($self, $text) = @_;
    push @{ $self->_private->{stacks}->[-1] }, $text;
    # return $text; # DEBUG
  }
  
  sub _save_line {
    my ($self, $text) = @_;
  
    $text = $self->_process_escapes($text);
  
    $self->_save($text . $/);
  }
  
  # For paragraphs, etc.
  sub _save_block {
    my ($self, $text) = @_;
  
    $self->_stack_state->{blocks}++;
  
    $self->_save_line($self->_indent($text) . $/);
  }
  
  ## Formatting ##
  
  sub _chomp_all {
    my ($self, $text) = @_;
    1 while chomp $text;
    return $text;
  }
  
  sub _indent {
    my ($self, $text) = @_;
    my $level = $self->_private->{indent};
  
    if( $level ){
      my $indent = ' ' x ($level * 4);
  
      # Capture text on the line so that we don't indent blank lines (/^\x20{4}$/).
      $text =~ s/^(.+)/$indent$1/mg;
    }
  
    return $text;
  }
  
  # as_markdown() exists solely for backward compatibility
  # and requires having called parse_from_file() to be useful.
  
  
  sub as_markdown {
      my ($parser, %args) = @_;
      my @header;
      # Don't add meta tags again if we've already done it.
      if( $args{with_meta} && !$parser->include_meta_tags ){
          @header = $parser->_build_markdown_head;
      }
      return join("\n" x 2, @header, $parser->{_as_markdown_});
  }
  
  sub _build_markdown_head {
      my $parser    = shift;
      my $data      = $parser->_private;
      return join "\n",
          map  { qq![[meta \l$_="$data->{$_}"]]! }
          grep { defined $data->{$_} }
          qw( Title Author );
  }
  
  ## Escaping ##
  
  # http://daringfireball.net/projects/markdown/syntax#backslash
  # Markdown provides backslash escapes for the following characters:
  #
  # \   backslash
  # `   backtick
  # *   asterisk
  # _   underscore
  # {}  curly braces
  # []  square brackets
  # ()  parentheses
  # #   hash mark
  # +   plus sign
  # -   minus sign (hyphen)
  # .   dot
  # !   exclamation mark
  
  # However some of those only need to be escaped in certain places:
  # * Backslashes *do* need to be escaped or they may be swallowed by markdown.
  # * Word-surrounding characters (/[`*_]/) *do* need to be escaped mid-word
  # because the markdown spec explicitly allows mid-word em*pha*sis.
  # * I don't actually see anything that curly braces are used for.
  # * Escaping square brackets is enough to avoid accidentally
  # creating links and images (so we don't need to escape plain parentheses
  # or exclamation points as that would generate a lot of unnecesary noise).
  # Parentheses will be escaped in urls (&end_L) to avoid premature termination.
  # * We don't need a backslash for every hash mark or every hyphen found mid-word,
  # just the ones that start a line (likewise for plus and dot).
  # (Those will all be handled by _escape_paragraph_markdown).
  
  
  # Backslash escape markdown characters to avoid having them interpreted.
  sub _escape_inline_markdown {
    local $_ = $_[1];
  
  # s/([\\`*_{}\[\]()#+-.!])/\\$1/g; # See comments above.
    s/([\\`*_\[\]])/\\$1/g;
  
    return $_;
  }
  
  # Escape markdown characters that would be interpreted
  # at the start of a line.
  sub _escape_paragraph_markdown {
      local $_ = $_[1];
  
      # Escape headings, horizontal rules, (unordered) lists, and blockquotes.
      s/^([-+#>])/\\$1/mg;
  
      # Markdown doesn't support backslash escapes for equal signs
      # even though they can be used to underline a header.
      # So use html to escape them to avoid having them interpreted.
      s/^([=])/sprintf '&#x%x;', ord($1)/mge;
  
      # Escape the dots that would wrongfully create numbered lists.
      s/^( (?:>\s+)? \d+ ) (\.\x20)/$1\\$2/xgm;
  
      return $_;
  }
  
  
  # Additionally Markdown allows inline html so we need to escape things that look like it.
  # While _some_ Markdown processors handle backslash-escaped html,
  # [Daring Fireball](http://daringfireball.net/projects/markdown/syntax) states distinctly:
  # > In HTML, there are two characters that demand special treatment: < and &...
  # > If you want to use them as literal characters, you must escape them as entities, e.g. &lt;, and &amp;.
  
  # It goes on to say:
  # > Markdown allows you to use these characters naturally,
  # > taking care of all the necessary escaping for you.
  # > If you use an ampersand as part of an HTML entity,
  # > it remains unchanged; otherwise it will be translated into &amp;.
  # > Similarly, because Markdown supports inline HTML,
  # > if you use angle brackets as delimiters for HTML tags, Markdown will treat them as such.
  
  # In order to only encode the occurrences that require it (something that
  # could be interpreted as an entity) we escape them all so that we can do the
  # suffix test later after the string is complete (since we don't know what
  # strings might come after this one).
  
  my %_escape =
    map {
      my ($k, $v) = split /:/;
      # Put the "code" marker before the char instead of after so that it doesn't
      # get confused as the $2 (which is what requires us to entity-encode it).
      # ( "XsX", "XcsX", "X(c?)sX" )
      my ($s, $code, $re) = map { "\0$_$v\0" } '', map { ($_, '('.$_.'?)') } 'c';
  
      (
        $k         => $s,
        $k.'_code' => $code,
        $k.'_re'   => qr/$re/,
      )
    }
      qw( amp:& lt:< );
  
  # Make the values of this private var available to the tests.
  sub __escape_sequences { %_escape }
  
  
  # HTML-entity encode any characters configured by the user.
  # If that doesn't include [&<] then we escape those chars so we can decide
  # later if we will entity-encode them or put them back verbatim.
  sub _encode_or_escape_entities {
    my $self  = $_[0];
    my $stash = $self->_private;
    local $_  = $_[1];
  
    if( $stash->{encode_amp} ){
      if( exists($stash->{html_encode_chars}) ){
        # Escape all amps for later processing.
        # Pass intermediate strings to entity encoder so that it doesn't
        # process any of the characters of our escape sequences.
        # Use -1 to get "as many fields as possible" so that we keep leading and
        # trailing (possibly empty) fields.
        $_ = join $_escape{amp}, map { $self->encode_entities($_) } split /&/, $_, -1;
      }
      else {
        s/&/$_escape{amp}/g;
      }
    }
    elsif( exists($stash->{html_encode_chars}) ){
      $_ = $self->encode_entities($_);
    }
  
    s/</$_escape{lt}/g
      if $stash->{encode_lt};
  
    return $_;
  }
  
  # From Markdown.pl version 1.0.1 line 1172 (_DoAutoLinks).
  my $EMAIL_MARKER = qr{
  #   <                  # Opening token is in parent regexp.
          (?:mailto:)?
      (
        [-.\w]+
        \@
        [-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+
      )
      >
  }x;
  
  # Process any escapes we put in the text earlier,
  # now that the text is complete (end of a block).
  sub _process_escapes {
    my $self  = $_[0];
    my $stash = $self->_private;
    local $_  = $_[1];
  
    # The patterns below are taken from Markdown.pl 1.0.1 _EncodeAmpsAndAngles().
    # In this case we only want to encode the ones that Markdown won't.
    # This is overkill but produces nicer looking text (less escaped entities).
    # If it proves insufficent then we'll just encode them all.
  
    # $1: If the escape was in a code sequence, simply replace the original.
    # $2: If the unescaped value would be followed by characters
    #     that could be interpreted as html, entity-encode it.
    # else: The character is safe to leave bare.
  
    # Neither currently allows $2 to contain '0' so bool tests are sufficient.
  
    if( $stash->{encode_amp} ){
      # Encode & if succeeded by chars that look like an html entity.
      s,$_escape{amp_re}((?:#?[xX]?(?:[0-9a-fA-F]+|\w+);)?),
        $1 ? '&'.$2 : $2 ? '&amp;'.$2 : '&',egos;
    }
  
    if( $stash->{encode_lt} ){
      # Encode < if succeeded by chars that look like an html tag.
      # Leave email addresses (<foo@bar.com>) for Markdown to process.
      s,$_escape{lt_re}((?=$EMAIL_MARKER)|(?:[a-z/?\$!])?),
        $1 ? '<'.$2 : $2 ?  '&lt;'.$2 : '<',egos;
    }
  
    return $_;
  }
  
  
  ## Parsing ##
  
  sub handle_text {
    my $self  = $_[0];
    my $stash = $self->_private;
    local $_  = $_[1];
  
    # Unless we're in a code span, verbatim block, or formatted region.
    unless( $stash->{no_escape} ){
  
      # We could, in theory, alter what gets escaped according to context
      # (for example, escape square brackets (but not parens) inside link text).
      # The markdown produced might look slightly nicer but either way you're
      # at the whim of the markdown processor to interpret things correctly.
      # For now just escape everything.
  
      # Don't let literal characters be interpreted as markdown.
      $_ = $self->_escape_inline_markdown($_);
  
      # Entity-encode (or escape for later processing) necessary/desired chars.
      $_ = $self->_encode_or_escape_entities($_);
  
    }
    # If this _is_ a code section, do limited/specific handling.
    else {
      # Always escaping these chars ensures that we won't mangle the text
      # in the unlikely event that a sequence matching our escape occurred in the
      # input stream (since we're going to escape it and then unescape it).
      s/&/$_escape{amp_code}/gos if $stash->{encode_amp};
      s/</$_escape{lt_code}/gos  if $stash->{encode_lt};
    }
  
    $self->_save($_);
  }
  
  sub start_Document {
    my ($self) = @_;
    $self->_new_stack;
  }
  
  sub   end_Document {
    my ($self) = @_;
    $self->_check_search_header;
    my $end = pop @{ $self->_private->{stacks} };
  
    @{ $self->_private->{stacks} } == 0
      or die 'Document ended with stacks remaining';
  
    my @doc = $self->_chomp_all(join('', @$end)) . $/;
  
    if( $self->include_meta_tags ){
      unshift @doc, $self->_build_markdown_head, ($/ x 2);
    }
  
    if( my $encoding = $self->_get_output_encoding ){
      # Do the check outside the loop(s) for efficiency.
      my $ents = $HAS_HTML_ENTITIES ? \&__entity_encode_ord_he : \&__entity_encode_ord_basic;
      # Iterate indices to avoid copying large strings.
      for my $i ( 0 .. $#doc ){
        print { $self->{output_fh} } Encode::encode($encoding, $doc[$i], $ents);
      }
    }
    else {
      print { $self->{output_fh} } @doc;
    }
  }
  
  sub _get_output_encoding {
    my ($self) = @_;
  
    # If 'match_encoding' is set we need to return an encoding.
    # If pod has no =encoding, Pod::Simple will guess if it sees a high-bit char.
    # If there are no high-bit chars, encoding is undef.
    # Use detected_encoding() rather than encoding() because if Pod::Simple
    # can't use whatever encoding was specified, we probably can't either.
    # Fallback to 'o_e' if no match is found.  This gives the user the choice,
    # since otherwise there would be no reason to specify 'o_e' *and* 'm_e'.
    # Fallback to UTF-8 since it is a reasonable default these days.
  
    return $self->detected_encoding || $self->output_encoding || 'UTF-8'
      if $self->match_encoding;
  
    # If output encoding wasn't specified, return false.
    return $self->output_encoding;
  }
  
  ## Blocks ##
  
  sub start_Verbatim {
    my ($self) = @_;
    $self->_new_stack;
    $self->_private->{no_escape} = 1;
  }
  
  sub end_Verbatim {
    my ($self) = @_;
  
    my $text = $self->_pop_stack_text;
  
    $text = $self->_indent_verbatim($text);
  
    $self->_private->{no_escape} = 0;
  
    # Verbatim blocks do not generate a separate "Para" event.
    $self->_save_block($text);
  }
  
  sub _indent_verbatim {
    my ($self, $paragraph) = @_;
  
      # NOTE: Pod::Simple expands the tabs for us (as suggested by perlpodspec).
      # Pod::Simple also has a 'strip_verbatim_indent' attribute
      # but it doesn't sound like it gains us anything over this method.
  
      # POD verbatim can start with any number of spaces (or tabs)
      # markdown should be 4 spaces (or a tab)
      # so indent any paragraphs so that all lines start with at least 4 spaces
      my @lines = split /\n/, $paragraph;
      my $indent = ' ' x 4;
      foreach my $line ( @lines ){
          next unless $line =~ m/^( +)/;
          # find the smallest indentation
          $indent = $1 if length($1) < length($indent);
      }
      if( (my $smallest = length($indent)) < 4 ){
          # invert to get what needs to be prepended
          $indent = ' ' x (4 - $smallest);
  
          # Prepend indent to each line.
          # We could check /\S/ to only indent non-blank lines,
          # but it's backward compatible to respect the whitespace.
          # Additionally, both pod and markdown say they ignore blank lines
          # so it shouldn't hurt to leave them in.
          $paragraph = join "\n", map { length($_) ? $indent . $_ : '' } @lines;
      }
  
    return $paragraph;
  }
  
  sub start_Para {
    $_[0]->_new_stack;
  }
  
  sub   end_Para {
    my ($self) = @_;
    my $text = $self->_pop_stack_text;
  
    $text = $self->_escape_paragraph_markdown($text);
  
    $self->_save_block($text);
  }
  
  
  ## Headings ##
  
  sub start_head1 { $_[0]->_start_head(1) }
  sub   end_head1 { $_[0]->_end_head(1) }
  sub start_head2 { $_[0]->_start_head(2) }
  sub   end_head2 { $_[0]->_end_head(2) }
  sub start_head3 { $_[0]->_start_head(3) }
  sub   end_head3 { $_[0]->_end_head(3) }
  sub start_head4 { $_[0]->_start_head(4) }
  sub   end_head4 { $_[0]->_end_head(4) }
  
  sub _check_search_header {
    my ($self) = @_;
    # Save the text since the last heading if we want it for metadata.
    if( my $last = $self->_private->{search_header} ){
      for( $self->_private->{$last} = $self->_last_string ){
        s/\A\s+//;
        s/\s+\z//;
      }
    }
  }
  sub _start_head {
    my ($self) = @_;
    $self->_check_search_header;
    $self->_new_stack;
  }
  
  sub   _end_head {
    my ($self, $num) = @_;
    my $h = '#' x $num;
  
    my $text = $self->_pop_stack_text;
    $self->_private->{search_header} =
        $text =~ /NAME/   ? 'Title'
      : $text =~ /AUTHOR/ ? 'Author'
      : undef;
  
    # TODO: option for $h suffix
    # TODO: put a name="" if $self->{embed_anchor_tags}; ?
    # https://rt.cpan.org/Ticket/Display.html?id=57776
    $self->_save_block(join(' ', $h, $text));
  }
  
  ## Lists ##
  
  # With Pod::Simple->parse_empty_lists(1) there could be an over_empty event,
  # but what would you do with that?
  
  sub _start_list {
    my ($self) = @_;
    $self->_new_stack;
  
    # Nest again b/c start_item will pop this to look for preceding content.
    $self->_increase_indent;
    $self->_new_stack;
  }
  
  sub   _end_list {
    my ($self) = @_;
    $self->_handle_between_item_content;
  
    # Finish the list.
  
    # All the child elements should be blocks,
    # but don't end with a double newline.
    my $text = $self->_chomp_all($self->_pop_stack_text);
  
    $_[0]->_save_line($text . $/);
  }
  
  sub _handle_between_item_content {
    my ($self) = @_;
  
    # This might be empty (if the list item had no additional content).
    if( my $text = $self->_pop_stack_text ){
      # Else it's a sub-document.
      # If there are blocks we need to separate with blank lines.
      if( $self->_private->{last_state}->{blocks} ){
        $text = $/ . $text;
      }
      # If not, we can condense the text.
      # In this module's history there was a patch contributed to specifically
      # produce "huddled" lists so we'll try to maintain that functionality.
      else {
        $text = $self->_chomp_all($text) . $/;
      }
      $self->_save($text)
    }
  
    $self->_decrease_indent;
  }
  
  sub _start_item {
    my ($self) = @_;
    $self->_handle_between_item_content;
    $self->_new_stack;
  }
  
  sub   _end_item {
    my ($self, $marker) = @_;
    my $text = $self->_pop_stack_text;
    $self->_save_line($self->_indent($marker .
      # Add a space only if there is text after the marker.
      (defined($text) && length($text) ? ' ' . $text : '')
    ));
  
    # Store any possible contents in a new stack (like a sub-document).
    $self->_increase_indent;
    $self->_new_stack;
  }
  
  sub start_over_bullet { $_[0]->_start_list }
  sub   end_over_bullet { $_[0]->_end_list }
  
  sub start_item_bullet { $_[0]->_start_item }
  sub   end_item_bullet { $_[0]->_end_item('-') }
  
  sub start_over_number { $_[0]->_start_list }
  sub   end_over_number { $_[0]->_end_list }
  
  sub start_item_number {
    $_[0]->_start_item;
    # It seems like this should be a stack,
    # but from testing it appears that the corresponding 'end' event
    # comes right after the text (it doesn't surround any embedded content).
    # See t/nested.t which shows start-item, text, end-item, para, start-item....
    $_[0]->_private->{item_number} = $_[1]->{number};
  }
  
  sub   end_item_number {
    my ($self) = @_;
    $self->_end_item($self->_private->{item_number} . '.');
  }
  
  # Markdown doesn't support definition lists
  # so do regular (unordered) lists with indented paragraphs.
  sub start_over_text { $_[0]->_start_list }
  sub   end_over_text { $_[0]->_end_list }
  
  sub start_item_text { $_[0]->_start_item }
  sub   end_item_text { $_[0]->_end_item('-')}
  
  
  # perlpodspec equates an over/back region with no items to a blockquote.
  sub start_over_block {
    # NOTE: We don't actually need to indent for a blockquote.
    $_[0]->_new_stack;
  }
  
  sub   end_over_block {
    my ($self) = @_;
  
    # Chomp first to avoid prefixing a blank line with a `>`.
    my $text = $self->_chomp_all($self->_pop_stack_text);
  
    # NOTE: Paragraphs will already be escaped.
  
    # I don't really like either of these implementations
    # but the join/map/split seems a little better and benches a little faster.
    # You would lose the last newline but we've already chomped.
    #$text =~ s{^(.)?}{'>' . (defined($1) && length($1) ? (' ' . $1) : '')}mge;
    $text = join $/, map { length($_) ? '> ' . $_ : '>' } split qr-$/-, $text;
  
    $self->_save_block($text);
  }
  
  ## Custom Formats ##
  
  sub start_for {
    my ($self, $attr) = @_;
    $self->_new_stack;
  
    if( $attr->{target} eq 'html' ){
      # Use another stack so we can indent
      # (not syntactily necessary but seems appropriate).
      $self->_new_stack;
      $self->_increase_indent;
      $self->_private->{no_escape} = 1;
      # Mark this so we know to undo it.
      $self->_stack_state->{for_html} = 1;
    }
  }
  
  sub end_for {
    my ($self) = @_;
    # Data gets saved as a block (which will handle indents),
    # but if there was html we'll alter this, so chomp and save a block again.
    my $text = $self->_chomp_all($self->_pop_stack_text);
  
    if( $self->_private->{last_state}->{for_html} ){
      $self->_private->{no_escape} = 0;
      # Save it to the next stack up so we can pop it again (we made two stacks).
      $self->_save($text);
      $self->_decrease_indent;
      $text = join "\n", '<div>', $self->_chomp_all($self->_pop_stack_text), '</div>';
    }
  
    $self->_save_block($text);
  }
  
  # Data events will be emitted for any formatted regions that have been enabled
  # (by default, `markdown` and `html`).
  
  sub start_Data {
    my ($self) = @_;
    # TODO: limit this to what's in attr?
    $self->_private->{no_escape}++;
    $self->_new_stack;
  }
  
  sub   end_Data {
    my ($self) = @_;
    my $text = $self->_pop_stack_text;
    $self->_private->{no_escape}--;
    $self->_save_block($text);
  }
  
  ## Codes ##
  
  sub start_B { $_[0]->_save('**') }
  sub   end_B { $_[0]->start_B()   }
  
  sub start_I { $_[0]->_save('_') }
  sub   end_I { $_[0]->start_I()  }
  
  sub start_C {
    my ($self) = @_;
    $self->_new_stack;
    $self->_private->{no_escape}++;
  }
  
  sub   end_C {
    my ($self) = @_;
    $self->_private->{no_escape}--;
    $self->_save( $self->_wrap_code_span($self->_pop_stack_text) );
  }
  
  # Use code spans for F<>.
  sub start_F { shift->start_C(@_); }
  sub   end_F { shift  ->end_C(@_); }
  
  sub start_L {
    my ($self, $flags) = @_;
    $self->_new_stack;
    push @{ $self->_private->{link} }, $flags;
  }
  
  sub   end_L {
    my ($self) = @_;
    my $flags = pop @{ $self->_private->{link} }
      or die 'Invalid state: link end with no link start';
  
    my ($type, $to, $section) = @{$flags}{qw( type to section )};
  
    my $url = (
      $type eq 'url' ? $to
        : $type eq 'man' ? $self->format_man_url($to, $section)
        : $type eq 'pod' ? $self->format_perldoc_url($to, $section)
        :                  undef
    );
  
    my $text = $self->_pop_stack_text;
  
    # NOTE: I don't think the perlpodspec says what to do with L<|blah>
    # but it seems like a blank link text just doesn't make sense
    if( !length($text) ){
      $text =
        $section ?
          $to ? sprintf('"%s" in %s', $section, $to)
          : ('"' . $section . '"')
        : $to;
    }
  
    # FIXME: What does Pod::Simple::X?HTML do for this?
    # if we don't know how to handle the url just print the pod back out
    if (!$url) {
      $self->_save(sprintf 'L<%s>', $flags->{raw});
      return;
    }
  
    # In the url we need to escape quotes and parentheses lest markdown
    # break the url (cut it short and/or wrongfully interpret a title).
  
    # Backslash escapes do not work for the space and quotes.
    # URL-encoding the space is not sufficient
    # (the quotes confuse some parsers and produce invalid html).
    # I've arbitratily chosen HTML encoding to hide them from markdown
    # while mangling the url as litle as possible.
    $url =~ s/([ '"])/sprintf '&#x%x;', ord($1)/ge;
  
    # We also need to double any backslashes that may be present
    # (lest they be swallowed up) and stop parens from breaking the url.
    $url =~ s/([\\()])/\\$1/g;
  
    # TODO: put section name in title if not the same as $text
    $self->_save('[' . $text . '](' . $url . ')');
  }
  
  sub start_X {
    $_[0]->_new_stack;
  }
  
  sub   end_X {
    my ($self) = @_;
    my $text = $self->_pop_stack_text;
    # TODO: mangle $text?
    # TODO: put <a name="$text"> if configured
  }
  
  # A code span can be delimited by multiple backticks (and a space)
  # similar to pod codes (C<< code >>), so ensure we use a big enough
  # delimiter to not have it broken by embedded backticks.
  sub _wrap_code_span {
    my ($self, $arg) = @_;
    my $longest = 0;
    while( $arg =~ /([`]+)/g ){
      my $len = length($1);
      $longest = $len if $longest < $len;
    }
    my $delim = '`' x ($longest + 1);
    my $pad = $longest > 0 ? ' ' : '';
    return $delim . $pad . $arg . $pad . $delim;
  }
  
  ## Link Formatting (TODO: Move this to another module) ##
  
  
  sub format_man_url {
      my ($self, $to) = @_;
      my ($page, $part) = ($to =~ /^ ([^(]+) (?: \( (\S+) \) )? /x);
      return $self->man_url_prefix . ($part || 1) . '/' . ($page || $to);
  }
  
  
  sub format_perldoc_url {
    my ($self, $name, $section) = @_;
  
    my $url_prefix = $self->perldoc_url_prefix;
    my $url = '';
  
    # If the link is to another module (external link).
    if ($name) {
      $url = $url_prefix . $name;
    }
  
    # See https://rt.cpan.org/Ticket/Display.html?id=57776
    # for a discussion on the need to mangle the section.
    if ($section){
  
      my $method = $url
        # If we already have a prefix on the url it's external.
        ? $self->perldoc_fragment_format
        # Else an internal link points to this markdown doc.
        : $self->markdown_fragment_format;
  
      $method = 'format_fragment_' . $method
        unless ref($method);
  
      {
        # Set topic to enable code refs to be simple.
        local $_ = $section;
        $section = $self->$method($section);
      }
  
      $url .= '#' . $section;
    }
  
    return $url;
  }
  
  
  # TODO: simple, pandoc, etc?
  
  sub format_fragment_markdown {
    my ($self, $section) = @_;
  
    # If this is an internal link (to another section in this doc)
    # we can't be sure what the heading id's will look like
    # (it depends on what is rendering the markdown to html)
    # but we can try to follow popular conventions.
  
    # http://johnmacfarlane.net/pandoc/demo/example9/pandocs-markdown.html#header-identifiers-in-html-latex-and-context
    #$section =~ s/(?![-_.])[[:punct:]]//g;
    #$section =~ s/\s+/-/g;
    $section =~ s/\W+/-/g;
    $section =~ s/-+$//;
    $section =~ s/^-+//;
    $section = lc $section;
    #$section =~ s/^[^a-z]+//;
    $section ||= 'section';
  
    return $section;
  }
  
  
  {
    # From Pod::Simple::XHTML 3.28.
    # The strings gets passed through encode_entities() before idify().
    # If we don't do it here the substitutions below won't operate consistently.
  
    sub format_fragment_pod_simple_xhtml {
      my ($self, $t) = @_;
  
      # encode_entities {
        # We need to use the defaults in case html_encode_chars has been customized
        # (since the purpose is to match what external sources are doing).
  
        local $self->_private->{html_encode_chars};
        $t = $self->encode_entities($t);
      # }
  
      # idify {
        for ($t) {
            s/<[^>]+>//g;            # Strip HTML.
            s/&[^;]+;//g;            # Strip entities.
            s/^\s+//; s/\s+$//;      # Strip white space.
            s/^([^a-zA-Z]+)$/pod$1/; # Prepend "pod" if no valid chars.
            s/^[^a-zA-Z]+//;         # First char must be a letter.
            s/[^-a-zA-Z0-9_:.]+/-/g; # All other chars must be valid.
            s/[-:.]+$//;             # Strip trailing punctuation.
        }
      # }
  
      return $t;
    }
  }
  
  
  sub format_fragment_pod_simple_html {
    my ($self, $section) = @_;
  
    # From Pod::Simple::HTML 3.28.
  
    # section_name_tidy {
      $section =~ s/^\s+//;
      $section =~ s/\s+$//;
      $section =~ tr/ /_/;
      $section =~ tr/\x00-\x1F\x80-\x9F//d if 'A' eq chr(65); # drop crazy characters
  
      #$section = $self->unicode_escape_url($section);
        # unicode_escape_url {
        $section =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;
          #  Turn char 1234 into "(1234)"
        # }
  
      $section = '_' unless length $section;
      return $section;
    # }
  }
  
  
  sub format_fragment_metacpan { shift->format_fragment_pod_simple_xhtml(@_); }
  sub format_fragment_sco      { shift->format_fragment_pod_simple_html(@_);  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =for :stopwords Marcel Gruenauer Victor Moral Ryan C. Thompson <rct at thompsonclan d0t
  org> Aristotle Pagaltzis Randy Stauner ACKNOWLEDGEMENTS html cpan
  testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto
  metadata placeholders metacpan
  
  =head1 NAME
  
  Pod::Markdown - Convert POD to Markdown
  
  =head1 VERSION
  
  version 3.005
  
  =for test_synopsis my ($pod_string);
  
  =head1 SYNOPSIS
  
    # Pod::Simple API is supported.
  
    # Command line usage: Parse a pod file and print to STDOUT:
    # $ perl -MPod::Markdown -e 'Pod::Markdown->new->filter(@ARGV)' path/to/POD/file > README.md
  
    # Work with strings:
    my $markdown;
    my $parser = Pod::Markdown->new;
    $parser->output_string(\$markdown);
    $parser->parse_string_document($pod_string);
  
    # See Pod::Simple docs for more.
  
  =head1 DESCRIPTION
  
  This module uses L<Pod::Simple> to convert POD to Markdown.
  
  Literal characters in Pod that are special in Markdown
  (like *asterisks*) are backslash-escaped when appropriate.
  
  By default C<markdown> and C<html> formatted regions are accepted.
  Regions of C<markdown> will be passed through unchanged.
  Regions of C<html> will be placed inside a C<< E<lt>divE<gt> >> tag
  so that markdown characters won't be processed.
  Regions of C<:markdown> or C<:html> will be processed as POD and included.
  To change which regions are accepted use the L<Pod::Simple> API:
  
    my $parser = Pod::Markdown->new;
    $parser->unaccept_targets(qw( markdown html ));
  
  =head2 A note on encoding and escaping
  
  The common L<Pod::Simple> API returns a character string.
  If you want Pod::Markdown to return encoded octets, there are two attributes
  to assist: L</match_encoding> and L</output_encoding>.
  
  When an output encoding is requested any characters that are not valid
  for that encoding will be escaped as HTML entities.
  
  This is not 100% safe, however.
  
  Markdown escapes all ampersands inside of code spans, so escaping a character
  as an HTML entity inside of a code span will not be correct.
  However, with pod's C<S> and C<E> sequences it is possible
  to end up with high-bit characters inside of code spans.
  
  So, while C<< output_encoding => 'ascii' >> can work, it is not recommended.
  For these reasons (and more), C<UTF-8> is the default, fallback encoding (when one is required).
  
  If you prefer HTML entities over literal characters you can use
  L</html_encode_chars> which will only operate outside of code spans (where it is safe).
  
  =head1 METHODS
  
  =head2 new
  
    Pod::Markdown->new(%options);
  
  The constructor accepts the following named arguments:
  
  =over 4
  
  =item *
  
  C<man_url_prefix>
  
  Alters the man page urls that are created from C<< LE<lt>E<gt> >> codes.
  
  The default is C<http://man.he.net/man>.
  
  =item *
  
  C<perldoc_url_prefix>
  
  Alters the perldoc urls that are created from C<< LE<lt>E<gt> >> codes.
  Can be:
  
  =over 4
  
  =item *
  
  C<metacpan> (shortcut for C<https://metacpan.org/pod/>)
  
  =item *
  
  C<sco> (shortcut for C<http://search.cpan.org/perldoc?>)
  
  =item *
  
  any url
  
  =back
  
  The default is C<metacpan>.
  
      Pod::Markdown->new(perldoc_url_prefix => 'http://localhost/perl/pod');
  
  =item *
  
  C<perldoc_fragment_format>
  
  Alters the format of the url fragment for any C<< LE<lt>E<gt> >> links
  that point to a section of an external document (C<< L<name/section> >>).
  The default will be chosen according to the destination L</perldoc_url_prefix>.
  Alternatively you can specify one of the following:
  
  =over 4
  
  =item *
  
  C<metacpan>
  
  =item *
  
  C<sco>
  
  =item *
  
  C<pod_simple_xhtml>
  
  =item *
  
  C<pod_simple_html>
  
  =item *
  
  A code ref
  
  =back
  
  The code ref can expect to receive two arguments:
  the parser object (C<$self>) and the section text.
  For convenience the topic variable (C<$_>) is also set to the section text:
  
    perldoc_fragment_format => sub { s/\W+/-/g; }
  
  =item *
  
  C<markdown_fragment_format>
  
  Alters the format of the url fragment for any C<< LE<lt>E<gt> >> links
  that point to an internal section of this document (C<< L</section> >>).
  
  Unfortunately the format of the id attributes produced
  by whatever system translates the markdown into html is unknown at the time
  the markdown is generated so we do some simple clean up.
  
  B<Note:> C<markdown_fragment_format> and C<perldoc_fragment_format> accept
  the same values: a (shortcut to a) method name or a code ref.
  
  =item *
  
  C<include_meta_tags>
  
  Specifies whether or not to print author/title meta tags at the top of the document.
  Default is false.
  
  =back
  
  =head2 html_encode_chars
  
  A string of characters to encode as html entities
  (using L<HTML::Entities/encode_entities> if available, falling back to numeric entities if not).
  
  Possible values:
  
  =over 4
  
  =item *
  
  A value of C<1> will use the default set of characters from L<HTML::Entities> (control chars, high-bit chars, and C<< <&>"' >>).
  
  =item *
  
  A false value will disable.
  
  =item *
  
  Any other value is used as a string of characters (like a regular expression character class).
  
  =back
  
  By default this is disabled and literal characters will be in the output stream.
  If you specify a desired L</output_encoding> any characters not valid for that encoding will be HTML entity encoded.
  
  B<Note> that Markdown requires ampersands (C<< & >>) and left angle brackets (C<< < >>)
  to be entity-encoded if they could otherwise be interpreted as html entities.
  If this attribute is configured to encode those characters, they will always be encoded.
  If not, the module will make an effort to only encode the ones required,
  so there will be less html noise in the output.
  
  =head2 match_encoding
  
  Boolean: If true, use the C<< =encoding >> of the input pod
  as the encoding for the output.
  
  If no encoding is specified, L<Pod::Simple> will guess the encoding
  if it sees a high-bit character.
  
  If no encoding is guessed (or the specified encoding is unusable),
  L</output_encoding> will be used if it was specified.
  Otherwise C<UTF-8> will be used.
  
  This attribute is not recommended
  but is provided for consistency with other pod converters.
  
  Defaults to false.
  
  =head2 output_encoding
  
  The encoding to use when writing to the output file handle.
  
  If neither this nor L</match_encoding> are specified,
  a character string will be returned in whatever L<Pod::Simple> output method you specified.
  
  =head2 man_url_prefix
  
  Returns the url prefix in use for man pages.
  
  =head2 perldoc_url_prefix
  
  Returns the url prefix in use (after resolving shortcuts to urls).
  
  =head2 perldoc_fragment_format
  
  Returns the coderef or format name used to format a url fragment
  to a section in an external document.
  
  =head2 markdown_fragment_format
  
  Returns the coderef or format name used to format a url fragment
  to an internal section in this document.
  
  =head2 include_meta_tags
  
  Returns the boolean value indicating
  whether or not meta tags will be printed.
  
  =head2 format_man_url
  
  Used internally to create a url (using L</man_url_prefix>)
  from a string like C<man(1)>.
  
  =head2 format_perldoc_url
  
      # With $name and section being the two parts of L<name/section>.
      my $url = $parser->format_perldoc_url($name, $section);
  
  Used internally to create a url from
  the name (of a module or script)
  and a possible section (heading).
  
  The format of the url fragment (when pointing to a section in a document)
  varies depending on the destination url
  so L</perldoc_fragment_format> is used (which can be customized).
  
  If the module name portion of the link is blank
  then the section is treated as an internal fragment link
  (to a section of the generated markdown document)
  and L</markdown_fragment_format> is used (which can be customized).
  
  =head2 format_fragment_markdown
  
  Format url fragment for an internal link
  by replacing non-word characters with dashes.
  
  =head2 format_fragment_pod_simple_xhtml
  
  Format url fragment like L<Pod::Simple::XHTML/idify>.
  
  =head2 format_fragment_pod_simple_html
  
  Format url fragment like L<Pod::Simple::HTML/section_name_tidy>.
  
  =head2 format_fragment_metacpan
  
  Format fragment for L<metacpan.org>
  (uses L</format_fragment_pod_simple_xhtml>).
  
  =head2 format_fragment_sco
  
  Format fragment for L<search.cpan.org>
  (uses L</format_fragment_pod_simple_html>).
  
  =for Pod::Coverage parse_from_file
  parse_from_filehandle
  
  =for Pod::Coverage as_markdown
  
  =for Pod::Coverage handle_text
  end_.+
  start_.+
  encode_entities
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<pod2markdown> - script included for command line usage
  
  =item *
  
  L<Pod::Simple> - Super class that handles Pod parsing
  
  =item *
  
  L<perlpod> - For writing POD
  
  =item *
  
  L<perlpodspec> - For parsing POD
  
  =item *
  
  L<http://daringfireball.net/projects/markdown/syntax> - Markdown spec
  
  =back
  
  =head1 SUPPORT
  
  =head2 Perldoc
  
  You can find documentation for this module with the perldoc command.
  
    perldoc Pod::Markdown
  
  =head2 Websites
  
  The following websites have more information about this module, and may be of help to you. As always,
  in addition to those websites please use your favorite search engine to discover more resources.
  
  =over 4
  
  =item *
  
  MetaCPAN
  
  A modern, open-source CPAN search engine, useful to view POD in HTML format.
  
  L<http://metacpan.org/release/Pod-Markdown>
  
  =back
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests by email to C<bug-pod-markdown at rt.cpan.org>, or through
  the web interface at L<https://rt.cpan.org/Public/Bug/Report.html?Queue=Pod-Markdown>. You will be automatically notified of any
  progress on the request by the system.
  
  =head2 Source Code
  
  
  L<https://github.com/rwstauner/Pod-Markdown>
  
    git clone https://github.com/rwstauner/Pod-Markdown.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Marcel Gruenauer <marcel@cpan.org>
  
  =item *
  
  Victor Moral <victor@taquiones.net>
  
  =item *
  
  Ryan C. Thompson <rct at thompsonclan d0t org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Randy Stauner <rwstauner@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Aristotle Pagaltzis Cindy Wang (CindyLinz) Graham Ollis Mike Covington motemen moznion Peter Vereshagin Ryan C. Thompson Yasutaka ATARASHI
  
  =over 4
  
  =item *
  
  Aristotle Pagaltzis <aristotle@cpan.org>
  
  =item *
  
  Cindy Wang (CindyLinz) <cindylinz@gmail.com>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Mike Covington <mfcovington@gmail.com>
  
  =item *
  
  motemen <motemen@cpan.org>
  
  =item *
  
  moznion <moznion@cpan.org>
  
  =item *
  
  Peter Vereshagin <veresc@cpan.org>
  
  =item *
  
  Ryan C. Thompson <rthompson@cpan.org>
  
  =item *
  
  Yasutaka ATARASHI <yakex@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Randy Stauner.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
POD_MARKDOWN

$fatpacked{"Pod/Perldoc/ToMarkdown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOMARKDOWN';
  #
  # This file is part of Pod-Markdown
  #
  # This software is copyright (c) 2011 by Randy Stauner.
  #
  # This is free software; you can redistribute it and/or modify it under
  # the same terms as the Perl 5 programming language system itself.
  #
  use strict;
  use warnings;
  
  package Pod::Perldoc::ToMarkdown;
  our $AUTHORITY = 'cpan:RWSTAUNER';
  $Pod::Perldoc::ToMarkdown::VERSION = '3.005';
  # ABSTRACT: Enable `perldoc -o Markdown`
  
  use parent qw(Pod::Markdown);
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(
      # Pod::Perldoc does not pass any options by default
      # but will call setters if attributes are passed on command line.
      # I don't know what encoding it expects, but it needs one, so default to UTF-8.
      output_encoding => 'UTF-8',
      @_,
    );
    return $self;
  }
  
  sub parse_from_file {
    my $self = shift;
    # Instantiate if called as a class method.
    $self = $self->new if !ref $self;
  
    # Skip over SUPER's override and go up to grandpa's method.
    $self->Pod::Simple::parse_from_file(@_);
  }
  
  # There are several other methods that we could implement that Pod::Perldoc
  # finds interesting:
  # * output_is_binary
  # * name
  # * output_extension
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =for :stopwords Marcel Gruenauer Victor Moral Ryan C. Thompson <rct at thompsonclan d0t
  org> Aristotle Pagaltzis Randy Stauner ACKNOWLEDGEMENTS
  
  =head1 NAME
  
  Pod::Perldoc::ToMarkdown - Enable `perldoc -o Markdown`
  
  =head1 VERSION
  
  version 3.005
  
  =for test_synopsis 1;
  __END__
  
  =head1 SYNOPSIS
  
    perldoc -o Markdown Some::Module
  
  =head1 DESCRIPTION
  
  Pod::Perldoc expects a Pod::Parser compatible module,
  however Pod::Markdown did not historically provide an entirely Pod::Parser
  compatible interface.
  
  This module bridges the gap.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Marcel Gruenauer <marcel@cpan.org>
  
  =item *
  
  Victor Moral <victor@taquiones.net>
  
  =item *
  
  Ryan C. Thompson <rct at thompsonclan d0t org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Randy Stauner <rwstauner@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Randy Stauner.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
POD_PERLDOC_TOMARKDOWN

$fatpacked{"darwin-2level/HTML/Entities.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_ENTITIES';
  package HTML::Entities;
  
  =encoding utf8
  
  =head1 NAME
  
  HTML::Entities - Encode or decode strings with HTML entities
  
  =head1 SYNOPSIS
  
   use HTML::Entities;
  
   $a = "V&aring;re norske tegn b&oslash;r &#230res";
   decode_entities($a);
   encode_entities($a, "\200-\377");
  
  For example, this:
  
   $input = "vis-à-vis Beyoncé's naïve\npapier-mâché résumé";
   print encode_entities($input), "\n"
  
  Prints this out:
  
   vis-&agrave;-vis Beyonc&eacute;'s na&iuml;ve
   papier-m&acirc;ch&eacute; r&eacute;sum&eacute;
  
  =head1 DESCRIPTION
  
  This module deals with encoding and decoding of strings with HTML
  character entities.  The module provides the following functions:
  
  =over 4
  
  =item decode_entities( $string, ... )
  
  This routine replaces HTML entities found in the $string with the
  corresponding Unicode character.  Unrecognized entities are left alone.
  
  If multiple strings are provided as argument they are each decoded
  separately and the same number of strings are returned.
  
  If called in void context the arguments are decoded in-place.
  
  This routine is exported by default.
  
  =item _decode_entities( $string, \%entity2char )
  
  =item _decode_entities( $string, \%entity2char, $expand_prefix )
  
  This will in-place replace HTML entities in $string.  The %entity2char
  hash must be provided.  Named entities not found in the %entity2char
  hash are left alone.  Numeric entities are expanded unless their value
  overflow.
  
  The keys in %entity2char are the entity names to be expanded and their
  values are what they should expand into.  The values do not have to be
  single character strings.  If a key has ";" as suffix,
  then occurrences in $string are only expanded if properly terminated
  with ";".  Entities without ";" will be expanded regardless of how
  they are terminated for compatibility with how common browsers treat
  entities in the Latin-1 range.
  
  If $expand_prefix is TRUE then entities without trailing ";" in
  %entity2char will even be expanded as a prefix of a longer
  unrecognized name.  The longest matching name in %entity2char will be
  used. This is mainly present for compatibility with an MSIE
  misfeature.
  
     $string = "foo&nbspbar";
     _decode_entities($string, { nb => "@", nbsp => "\xA0" }, 1);
     print $string;  # will print "foo bar"
  
  This routine is exported by default.
  
  =item encode_entities( $string )
  
  =item encode_entities( $string, $unsafe_chars )
  
  This routine replaces unsafe characters in $string with their entity
  representation. A second argument can be given to specify which characters to
  consider unsafe.  The unsafe characters is specified using the regular
  expression character class syntax (what you find within brackets in regular
  expressions).
  
  The default set of characters to encode are control chars, high-bit chars, and
  the C<< < >>, C<< & >>, C<< > >>, C<< ' >> and C<< " >> characters.  But this,
  for example, would encode I<just> the C<< < >>, C<< & >>, C<< > >>, and C<< "
  >> characters:
  
    $encoded = encode_entities($input, '<>&"');
  
  and this would only encode non-plain ascii:
  
    $encoded = encode_entities($input, '^\n\x20-\x25\x27-\x7e');
  
  This routine is exported by default.
  
  =item encode_entities_numeric( $string )
  
  =item encode_entities_numeric( $string, $unsafe_chars )
  
  This routine works just like encode_entities, except that the replacement
  entities are always C<&#xI<hexnum>;> and never C<&I<entname>;>.  For
  example, C<encode_entities("r\xF4le")> returns "r&ocirc;le", but
  C<encode_entities_numeric("r\xF4le")> returns "r&#xF4;le".
  
  This routine is I<not> exported by default.  But you can always
  export it with C<use HTML::Entities qw(encode_entities_numeric);>
  or even C<use HTML::Entities qw(:DEFAULT encode_entities_numeric);>
  
  =back
  
  All these routines modify the string passed as the first argument, if
  called in a void context.  In scalar and array contexts, the encoded or
  decoded string is returned (without changing the input string).
  
  If you prefer not to import these routines into your namespace, you can
  call them as:
  
    use HTML::Entities ();
    $decoded = HTML::Entities::decode($a);
    $encoded = HTML::Entities::encode($a);
    $encoded = HTML::Entities::encode_numeric($a);
  
  The module can also export the %char2entity and the %entity2char
  hashes, which contain the mapping from all characters to the
  corresponding entities (and vice versa, respectively).
  
  =head1 COPYRIGHT
  
  Copyright 1995-2006 Gisle Aas. All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  use vars qw(%entity2char %char2entity);
  
  require 5.004;
  require Exporter;
  @ISA = qw(Exporter);
  
  @EXPORT = qw(encode_entities decode_entities _decode_entities);
  @EXPORT_OK = qw(%entity2char %char2entity encode_entities_numeric);
  
  $VERSION = "3.69";
  sub Version { $VERSION; }
  
  require HTML::Parser;  # for fast XS implemented decode_entities
  
  
  %entity2char = (
   # Some normal chars that have special meaning in SGML context
   amp    => '&',  # ampersand 
  'gt'    => '>',  # greater than
  'lt'    => '<',  # less than
   quot   => '"',  # double quote
   apos   => "'",  # single quote
  
   # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML
   AElig	=> chr(198),  # capital AE diphthong (ligature)
   Aacute	=> chr(193),  # capital A, acute accent
   Acirc	=> chr(194),  # capital A, circumflex accent
   Agrave	=> chr(192),  # capital A, grave accent
   Aring	=> chr(197),  # capital A, ring
   Atilde	=> chr(195),  # capital A, tilde
   Auml	=> chr(196),  # capital A, dieresis or umlaut mark
   Ccedil	=> chr(199),  # capital C, cedilla
   ETH	=> chr(208),  # capital Eth, Icelandic
   Eacute	=> chr(201),  # capital E, acute accent
   Ecirc	=> chr(202),  # capital E, circumflex accent
   Egrave	=> chr(200),  # capital E, grave accent
   Euml	=> chr(203),  # capital E, dieresis or umlaut mark
   Iacute	=> chr(205),  # capital I, acute accent
   Icirc	=> chr(206),  # capital I, circumflex accent
   Igrave	=> chr(204),  # capital I, grave accent
   Iuml	=> chr(207),  # capital I, dieresis or umlaut mark
   Ntilde	=> chr(209),  # capital N, tilde
   Oacute	=> chr(211),  # capital O, acute accent
   Ocirc	=> chr(212),  # capital O, circumflex accent
   Ograve	=> chr(210),  # capital O, grave accent
   Oslash	=> chr(216),  # capital O, slash
   Otilde	=> chr(213),  # capital O, tilde
   Ouml	=> chr(214),  # capital O, dieresis or umlaut mark
   THORN	=> chr(222),  # capital THORN, Icelandic
   Uacute	=> chr(218),  # capital U, acute accent
   Ucirc	=> chr(219),  # capital U, circumflex accent
   Ugrave	=> chr(217),  # capital U, grave accent
   Uuml	=> chr(220),  # capital U, dieresis or umlaut mark
   Yacute	=> chr(221),  # capital Y, acute accent
   aacute	=> chr(225),  # small a, acute accent
   acirc	=> chr(226),  # small a, circumflex accent
   aelig	=> chr(230),  # small ae diphthong (ligature)
   agrave	=> chr(224),  # small a, grave accent
   aring	=> chr(229),  # small a, ring
   atilde	=> chr(227),  # small a, tilde
   auml	=> chr(228),  # small a, dieresis or umlaut mark
   ccedil	=> chr(231),  # small c, cedilla
   eacute	=> chr(233),  # small e, acute accent
   ecirc	=> chr(234),  # small e, circumflex accent
   egrave	=> chr(232),  # small e, grave accent
   eth	=> chr(240),  # small eth, Icelandic
   euml	=> chr(235),  # small e, dieresis or umlaut mark
   iacute	=> chr(237),  # small i, acute accent
   icirc	=> chr(238),  # small i, circumflex accent
   igrave	=> chr(236),  # small i, grave accent
   iuml	=> chr(239),  # small i, dieresis or umlaut mark
   ntilde	=> chr(241),  # small n, tilde
   oacute	=> chr(243),  # small o, acute accent
   ocirc	=> chr(244),  # small o, circumflex accent
   ograve	=> chr(242),  # small o, grave accent
   oslash	=> chr(248),  # small o, slash
   otilde	=> chr(245),  # small o, tilde
   ouml	=> chr(246),  # small o, dieresis or umlaut mark
   szlig	=> chr(223),  # small sharp s, German (sz ligature)
   thorn	=> chr(254),  # small thorn, Icelandic
   uacute	=> chr(250),  # small u, acute accent
   ucirc	=> chr(251),  # small u, circumflex accent
   ugrave	=> chr(249),  # small u, grave accent
   uuml	=> chr(252),  # small u, dieresis or umlaut mark
   yacute	=> chr(253),  # small y, acute accent
   yuml	=> chr(255),  # small y, dieresis or umlaut mark
  
   # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
   copy   => chr(169),  # copyright sign
   reg    => chr(174),  # registered sign
   nbsp   => chr(160),  # non breaking space
  
   # Additional ISO-8859/1 entities listed in rfc1866 (section 14)
   iexcl  => chr(161),
   cent   => chr(162),
   pound  => chr(163),
   curren => chr(164),
   yen    => chr(165),
   brvbar => chr(166),
   sect   => chr(167),
   uml    => chr(168),
   ordf   => chr(170),
   laquo  => chr(171),
  'not'   => chr(172),    # not is a keyword in perl
   shy    => chr(173),
   macr   => chr(175),
   deg    => chr(176),
   plusmn => chr(177),
   sup1   => chr(185),
   sup2   => chr(178),
   sup3   => chr(179),
   acute  => chr(180),
   micro  => chr(181),
   para   => chr(182),
   middot => chr(183),
   cedil  => chr(184),
   ordm   => chr(186),
   raquo  => chr(187),
   frac14 => chr(188),
   frac12 => chr(189),
   frac34 => chr(190),
   iquest => chr(191),
  'times' => chr(215),    # times is a keyword in perl
   divide => chr(247),
  
   ( $] > 5.007 ? (
    'OElig;'    => chr(338),
    'oelig;'    => chr(339),
    'Scaron;'   => chr(352),
    'scaron;'   => chr(353),
    'Yuml;'     => chr(376),
    'fnof;'     => chr(402),
    'circ;'     => chr(710),
    'tilde;'    => chr(732),
    'Alpha;'    => chr(913),
    'Beta;'     => chr(914),
    'Gamma;'    => chr(915),
    'Delta;'    => chr(916),
    'Epsilon;'  => chr(917),
    'Zeta;'     => chr(918),
    'Eta;'      => chr(919),
    'Theta;'    => chr(920),
    'Iota;'     => chr(921),
    'Kappa;'    => chr(922),
    'Lambda;'   => chr(923),
    'Mu;'       => chr(924),
    'Nu;'       => chr(925),
    'Xi;'       => chr(926),
    'Omicron;'  => chr(927),
    'Pi;'       => chr(928),
    'Rho;'      => chr(929),
    'Sigma;'    => chr(931),
    'Tau;'      => chr(932),
    'Upsilon;'  => chr(933),
    'Phi;'      => chr(934),
    'Chi;'      => chr(935),
    'Psi;'      => chr(936),
    'Omega;'    => chr(937),
    'alpha;'    => chr(945),
    'beta;'     => chr(946),
    'gamma;'    => chr(947),
    'delta;'    => chr(948),
    'epsilon;'  => chr(949),
    'zeta;'     => chr(950),
    'eta;'      => chr(951),
    'theta;'    => chr(952),
    'iota;'     => chr(953),
    'kappa;'    => chr(954),
    'lambda;'   => chr(955),
    'mu;'       => chr(956),
    'nu;'       => chr(957),
    'xi;'       => chr(958),
    'omicron;'  => chr(959),
    'pi;'       => chr(960),
    'rho;'      => chr(961),
    'sigmaf;'   => chr(962),
    'sigma;'    => chr(963),
    'tau;'      => chr(964),
    'upsilon;'  => chr(965),
    'phi;'      => chr(966),
    'chi;'      => chr(967),
    'psi;'      => chr(968),
    'omega;'    => chr(969),
    'thetasym;' => chr(977),
    'upsih;'    => chr(978),
    'piv;'      => chr(982),
    'ensp;'     => chr(8194),
    'emsp;'     => chr(8195),
    'thinsp;'   => chr(8201),
    'zwnj;'     => chr(8204),
    'zwj;'      => chr(8205),
    'lrm;'      => chr(8206),
    'rlm;'      => chr(8207),
    'ndash;'    => chr(8211),
    'mdash;'    => chr(8212),
    'lsquo;'    => chr(8216),
    'rsquo;'    => chr(8217),
    'sbquo;'    => chr(8218),
    'ldquo;'    => chr(8220),
    'rdquo;'    => chr(8221),
    'bdquo;'    => chr(8222),
    'dagger;'   => chr(8224),
    'Dagger;'   => chr(8225),
    'bull;'     => chr(8226),
    'hellip;'   => chr(8230),
    'permil;'   => chr(8240),
    'prime;'    => chr(8242),
    'Prime;'    => chr(8243),
    'lsaquo;'   => chr(8249),
    'rsaquo;'   => chr(8250),
    'oline;'    => chr(8254),
    'frasl;'    => chr(8260),
    'euro;'     => chr(8364),
    'image;'    => chr(8465),
    'weierp;'   => chr(8472),
    'real;'     => chr(8476),
    'trade;'    => chr(8482),
    'alefsym;'  => chr(8501),
    'larr;'     => chr(8592),
    'uarr;'     => chr(8593),
    'rarr;'     => chr(8594),
    'darr;'     => chr(8595),
    'harr;'     => chr(8596),
    'crarr;'    => chr(8629),
    'lArr;'     => chr(8656),
    'uArr;'     => chr(8657),
    'rArr;'     => chr(8658),
    'dArr;'     => chr(8659),
    'hArr;'     => chr(8660),
    'forall;'   => chr(8704),
    'part;'     => chr(8706),
    'exist;'    => chr(8707),
    'empty;'    => chr(8709),
    'nabla;'    => chr(8711),
    'isin;'     => chr(8712),
    'notin;'    => chr(8713),
    'ni;'       => chr(8715),
    'prod;'     => chr(8719),
    'sum;'      => chr(8721),
    'minus;'    => chr(8722),
    'lowast;'   => chr(8727),
    'radic;'    => chr(8730),
    'prop;'     => chr(8733),
    'infin;'    => chr(8734),
    'ang;'      => chr(8736),
    'and;'      => chr(8743),
    'or;'       => chr(8744),
    'cap;'      => chr(8745),
    'cup;'      => chr(8746),
    'int;'      => chr(8747),
    'there4;'   => chr(8756),
    'sim;'      => chr(8764),
    'cong;'     => chr(8773),
    'asymp;'    => chr(8776),
    'ne;'       => chr(8800),
    'equiv;'    => chr(8801),
    'le;'       => chr(8804),
    'ge;'       => chr(8805),
    'sub;'      => chr(8834),
    'sup;'      => chr(8835),
    'nsub;'     => chr(8836),
    'sube;'     => chr(8838),
    'supe;'     => chr(8839),
    'oplus;'    => chr(8853),
    'otimes;'   => chr(8855),
    'perp;'     => chr(8869),
    'sdot;'     => chr(8901),
    'lceil;'    => chr(8968),
    'rceil;'    => chr(8969),
    'lfloor;'   => chr(8970),
    'rfloor;'   => chr(8971),
    'lang;'     => chr(9001),
    'rang;'     => chr(9002),
    'loz;'      => chr(9674),
    'spades;'   => chr(9824),
    'clubs;'    => chr(9827),
    'hearts;'   => chr(9829),
    'diams;'    => chr(9830),
   ) : ())
  );
  
  
  # Make the opposite mapping
  while (my($entity, $char) = each(%entity2char)) {
      $entity =~ s/;\z//;
      $char2entity{$char} = "&$entity;";
  }
  delete $char2entity{"'"};  # only one-way decoding
  
  # Fill in missing entities
  for (0 .. 255) {
      next if exists $char2entity{chr($_)};
      $char2entity{chr($_)} = "&#$_;";
  }
  
  my %subst;  # compiled encoding regexps
  
  sub encode_entities
  {
      return undef unless defined $_[0];
      my $ref;
      if (defined wantarray) {
  	my $x = $_[0];
  	$ref = \$x;     # copy
      } else {
  	$ref = \$_[0];  # modify in-place
      }
      if (defined $_[1] and length $_[1]) {
  	unless (exists $subst{$_[1]}) {
  	    # Because we can't compile regex we fake it with a cached sub
  	    my $chars = $_[1];
  	    $chars =~ s,(?<!\\)([]/]),\\$1,g;
  	    $chars =~ s,(?<!\\)\\\z,\\\\,;
  	    my $code = "sub {\$_[0] =~ s/([$chars])/\$char2entity{\$1} || num_entity(\$1)/ge; }";
  	    $subst{$_[1]} = eval $code;
  	    die( $@ . " while trying to turn range: \"$_[1]\"\n "
  	      . "into code: $code\n "
  	    ) if $@;
  	}
  	&{$subst{$_[1]}}($$ref);
      } else {
  	# Encode control chars, high bit chars and '<', '&', '>', ''' and '"'
  	$$ref =~ s/([^\n\r\t !\#\$%\(-;=?-~])/$char2entity{$1} || num_entity($1)/ge;
      }
      $$ref;
  }
  
  sub encode_entities_numeric {
      local %char2entity;
      return &encode_entities;   # a goto &encode_entities wouldn't work
  }
  
  
  sub num_entity {
      sprintf "&#x%X;", ord($_[0]);
  }
  
  # Set up aliases
  *encode = \&encode_entities;
  *encode_numeric = \&encode_entities_numeric;
  *encode_numerically = \&encode_entities_numeric;
  *decode = \&decode_entities;
  
  1;
DARWIN-2LEVEL_HTML_ENTITIES

$fatpacked{"darwin-2level/HTML/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_FILTER';
  package HTML::Filter;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require HTML::Parser;
  @ISA=qw(HTML::Parser);
  
  $VERSION = "3.72";
  
  sub declaration { $_[0]->output("<!$_[1]>")     }
  sub process     { $_[0]->output($_[2])          }
  sub comment     { $_[0]->output("<!--$_[1]-->") }
  sub start       { $_[0]->output($_[4])          }
  sub end         { $_[0]->output($_[2])          }
  sub text        { $_[0]->output($_[1])          }
  
  sub output      { print $_[1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTML::Filter - Filter HTML text through the parser
  
  =head1 NOTE
  
  B<This module is deprecated.> The C<HTML::Parser> now provides the
  functionally of C<HTML::Filter> much more efficiently with the
  C<default> handler.
  
  =head1 SYNOPSIS
  
   require HTML::Filter;
   $p = HTML::Filter->new->parse_file("index.html");
  
  =head1 DESCRIPTION
  
  C<HTML::Filter> is an HTML parser that by default prints the
  original text of each HTML element (a slow version of cat(1) basically).
  The callback methods may be overridden to modify the filtering for some
  HTML elements and you can override output() method which is called to
  print the HTML text.
  
  C<HTML::Filter> is a subclass of C<HTML::Parser>. This means that
  the document should be given to the parser by calling the $p->parse()
  or $p->parse_file() methods.
  
  =head1 EXAMPLES
  
  The first example is a filter that will remove all comments from an
  HTML file.  This is achieved by simply overriding the comment method
  to do nothing.
  
    package CommentStripper;
    require HTML::Filter;
    @ISA=qw(HTML::Filter);
    sub comment { }  # ignore comments
  
  The second example shows a filter that will remove any E<lt>TABLE>s
  found in the HTML file.  We specialize the start() and end() methods
  to count table tags and then make output not happen when inside a
  table.
  
    package TableStripper;
    require HTML::Filter;
    @ISA=qw(HTML::Filter);
    sub start
    {
       my $self = shift;
       $self->{table_seen}++ if $_[0] eq "table";
       $self->SUPER::start(@_);
    }
  
    sub end
    {
       my $self = shift;
       $self->SUPER::end(@_);
       $self->{table_seen}-- if $_[0] eq "table";
    }
  
    sub output
    {
        my $self = shift;
        unless ($self->{table_seen}) {
  	  $self->SUPER::output(@_);
        }
    }
  
  If you want to collect the parsed text internally you might want to do
  something like this:
  
    package FilterIntoString;
    require HTML::Filter;
    @ISA=qw(HTML::Filter);
    sub output { push(@{$_[0]->{fhtml}}, $_[1]) }
    sub filtered_html { join("", @{$_[0]->{fhtml}}) }
  
  =head1 SEE ALSO
  
  L<HTML::Parser>
  
  =head1 COPYRIGHT
  
  Copyright 1997-1999 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTML_FILTER

$fatpacked{"darwin-2level/HTML/HeadParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_HEADPARSER';
  package HTML::HeadParser;
  
  =head1 NAME
  
  HTML::HeadParser - Parse <HEAD> section of a HTML document
  
  =head1 SYNOPSIS
  
   require HTML::HeadParser;
   $p = HTML::HeadParser->new;
   $p->parse($text) and  print "not finished";
  
   $p->header('Title')          # to access <title>....</title>
   $p->header('Content-Base')   # to access <base href="http://...">
   $p->header('Foo')            # to access <meta http-equiv="Foo" content="...">
   $p->header('X-Meta-Author')  # to access <meta name="author" content="...">
   $p->header('X-Meta-Charset') # to access <meta charset="...">
  
  =head1 DESCRIPTION
  
  The C<HTML::HeadParser> is a specialized (and lightweight)
  C<HTML::Parser> that will only parse the E<lt>HEAD>...E<lt>/HEAD>
  section of an HTML document.  The parse() method
  will return a FALSE value as soon as some E<lt>BODY> element or body
  text are found, and should not be called again after this.
  
  Note that the C<HTML::HeadParser> might get confused if raw undecoded
  UTF-8 is passed to the parse() method.  Make sure the strings are
  properly decoded before passing them on.
  
  The C<HTML::HeadParser> keeps a reference to a header object, and the
  parser will update this header object as the various elements of the
  E<lt>HEAD> section of the HTML document are recognized.  The following
  header fields are affected:
  
  =over 4
  
  =item Content-Base:
  
  The I<Content-Base> header is initialized from the E<lt>base
  href="..."> element.
  
  =item Title:
  
  The I<Title> header is initialized from the E<lt>title>...E<lt>/title>
  element.
  
  =item Isindex:
  
  The I<Isindex> header will be added if there is a E<lt>isindex>
  element in the E<lt>head>.  The header value is initialized from the
  I<prompt> attribute if it is present.  If no I<prompt> attribute is
  given it will have '?' as the value.
  
  =item X-Meta-Foo:
  
  All E<lt>meta> elements containing a C<name> attribute will result in
  headers using the prefix C<X-Meta-> appended with the value of the
  C<name> attribute as the name of the header, and the value of the
  C<content> attribute as the pushed header value.
  
  E<lt>meta> elements containing a C<http-equiv> attribute will result
  in headers as in above, but without the C<X-Meta-> prefix in the
  header name.
  
  E<lt>meta> elements containing a C<charset> attribute will result in
  an C<X-Meta-Charset> header, using the value of the C<charset>
  attribute as the pushed header value.
  
  The ':' character can't be represented in header field names, so
  if the meta element contains this char it's substituted with '-'
  before forming the field name.
  
  =back
  
  =head1 METHODS
  
  The following methods (in addition to those provided by the
  superclass) are available:
  
  =over 4
  
  =cut
  
  
  require HTML::Parser;
  @ISA = qw(HTML::Parser);
  
  use HTML::Entities ();
  
  use strict;
  use vars qw($VERSION $DEBUG);
  #$DEBUG = 1;
  $VERSION = "3.71";
  
  =item $hp = HTML::HeadParser->new
  
  =item $hp = HTML::HeadParser->new( $header )
  
  The object constructor.  The optional $header argument should be a
  reference to an object that implement the header() and push_header()
  methods as defined by the C<HTTP::Headers> class.  Normally it will be
  of some class that is a or delegates to the C<HTTP::Headers> class.
  
  If no $header is given C<HTML::HeadParser> will create an
  C<HTTP::Headers> object by itself (initially empty).
  
  =cut
  
  sub new
  {
      my($class, $header) = @_;
      unless ($header) {
  	require HTTP::Headers;
  	$header = HTTP::Headers->new;
      }
  
      my $self = $class->SUPER::new(api_version => 3,
  				  start_h => ["start", "self,tagname,attr"],
  				  end_h   => ["end",   "self,tagname"],
  				  text_h  => ["text",  "self,text"],
  				  ignore_elements => [qw(script style)],
  				 );
      $self->{'header'} = $header;
      $self->{'tag'} = '';   # name of active element that takes textual content
      $self->{'text'} = '';  # the accumulated text associated with the element
      $self;
  }
  
  =item $hp->header;
  
  Returns a reference to the header object.
  
  =item $hp->header( $key )
  
  Returns a header value.  It is just a shorter way to write
  C<$hp-E<gt>header-E<gt>header($key)>.
  
  =cut
  
  sub header
  {
      my $self = shift;
      return $self->{'header'} unless @_;
      $self->{'header'}->header(@_);
  }
  
  sub as_string    # legacy
  {
      my $self = shift;
      $self->{'header'}->as_string;
  }
  
  sub flush_text   # internal
  {
      my $self = shift;
      my $tag  = $self->{'tag'};
      my $text = $self->{'text'};
      $text =~ s/^\s+//;
      $text =~ s/\s+$//;
      $text =~ s/\s+/ /g;
      print "FLUSH $tag => '$text'\n"  if $DEBUG;
      if ($tag eq 'title') {
  	my $decoded;
  	$decoded = utf8::decode($text) if $self->utf8_mode && defined &utf8::decode;
  	HTML::Entities::decode($text);
  	utf8::encode($text) if $decoded;
  	$self->{'header'}->push_header(Title => $text);
      }
      $self->{'tag'} = $self->{'text'} = '';
  }
  
  # This is an quote from the HTML3.2 DTD which shows which elements
  # that might be present in a <HEAD>...</HEAD>.  Also note that the
  # <HEAD> tags themselves might be missing:
  #
  # <!ENTITY % head.content "TITLE & ISINDEX? & BASE? & STYLE? &
  #                            SCRIPT* & META* & LINK*">
  #
  # <!ELEMENT HEAD O O  (%head.content)>
  #
  # From HTML 4.01:
  #
  # <!ENTITY % head.misc "SCRIPT|STYLE|META|LINK|OBJECT">
  # <!ENTITY % head.content "TITLE & BASE?">
  # <!ELEMENT HEAD O O (%head.content;) +(%head.misc;)>
  #
  # From HTML 5 as of WD-html5-20090825:
  #
  # One or more elements of metadata content, [...]
  # => base, command, link, meta, noscript, script, style, title
  
  sub start
  {
      my($self, $tag, $attr) = @_;  # $attr is reference to a HASH
      print "START[$tag]\n" if $DEBUG;
      $self->flush_text if $self->{'tag'};
      if ($tag eq 'meta') {
  	my $key = $attr->{'http-equiv'};
  	if (!defined($key) || !length($key)) {
  	    if ($attr->{name}) {
  		$key = "X-Meta-\u$attr->{name}";
  	    } elsif ($attr->{charset}) { # HTML 5 <meta charset="...">
  		$key = "X-Meta-Charset";
  		$self->{header}->push_header($key => $attr->{charset});
  		return;
  	    } else {
  		return;
  	    }
  	}
  	$key =~ s/:/-/g;
  	$self->{'header'}->push_header($key => $attr->{content});
      } elsif ($tag eq 'base') {
  	return unless exists $attr->{href};
  	(my $base = $attr->{href}) =~ s/^\s+//; $base =~ s/\s+$//; # HTML5
  	$self->{'header'}->push_header('Content-Base' => $base);
      } elsif ($tag eq 'isindex') {
  	# This is a non-standard header.  Perhaps we should just ignore
  	# this element
  	$self->{'header'}->push_header(Isindex => $attr->{prompt} || '?');
      } elsif ($tag =~ /^(?:title|noscript|object|command)$/) {
  	# Just remember tag.  Initialize header when we see the end tag.
  	$self->{'tag'} = $tag;
      } elsif ($tag eq 'link') {
  	return unless exists $attr->{href};
  	# <link href="http:..." rel="xxx" rev="xxx" title="xxx">
  	my $href = delete($attr->{href});
  	$href =~ s/^\s+//; $href =~ s/\s+$//; # HTML5
  	my $h_val = "<$href>";
  	for (sort keys %{$attr}) {
  	    next if $_ eq "/";  # XHTML junk
  	    $h_val .= qq(; $_="$attr->{$_}");
  	}
  	$self->{'header'}->push_header(Link => $h_val);
      } elsif ($tag eq 'head' || $tag eq 'html') {
  	# ignore
      } else {
  	 # stop parsing
  	$self->eof;
      }
  }
  
  sub end
  {
      my($self, $tag) = @_;
      print "END[$tag]\n" if $DEBUG;
      $self->flush_text if $self->{'tag'};
      $self->eof if $tag eq 'head';
  }
  
  sub text
  {
      my($self, $text) = @_;
      print "TEXT[$text]\n" if $DEBUG;
      unless ($self->{first_chunk}) {
  	# drop Unicode BOM if found
  	if ($self->utf8_mode) {
  	    $text =~ s/^\xEF\xBB\xBF//;
  	}
  	else {
  	    $text =~ s/^\x{FEFF}//;
  	}
  	$self->{first_chunk}++;
      }
      my $tag = $self->{tag};
      if (!$tag && $text =~ /\S/) {
  	# Normal text means start of body
          $self->eof;
  	return;
      }
      return if $tag ne 'title';
      $self->{'text'} .= $text;
  }
  
  BEGIN {
      *utf8_mode = sub { 1 } unless HTML::Entities::UNICODE_SUPPORT;
  }
  
  1;
  
  __END__
  
  =back
  
  =head1 EXAMPLE
  
   $h = HTTP::Headers->new;
   $p = HTML::HeadParser->new($h);
   $p->parse(<<EOT);
   <title>Stupid example</title>
   <base href="http://www.linpro.no/lwp/">
   Normal text starts here.
   EOT
   undef $p;
   print $h->title;   # should print "Stupid example"
  
  =head1 SEE ALSO
  
  L<HTML::Parser>, L<HTTP::Headers>
  
  The C<HTTP::Headers> class is distributed as part of the
  I<libwww-perl> package.  If you don't have that distribution installed
  you need to provide the $header argument to the C<HTML::HeadParser>
  constructor with your own object that implements the documented
  protocol.
  
  =head1 COPYRIGHT
  
  Copyright 1996-2001 Gisle Aas. All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
DARWIN-2LEVEL_HTML_HEADPARSER

$fatpacked{"darwin-2level/HTML/LinkExtor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_LINKEXTOR';
  package HTML::LinkExtor;
  
  require HTML::Parser;
  @ISA = qw(HTML::Parser);
  $VERSION = "3.69";
  
  =head1 NAME
  
  HTML::LinkExtor - Extract links from an HTML document
  
  =head1 SYNOPSIS
  
   require HTML::LinkExtor;
   $p = HTML::LinkExtor->new(\&cb, "http://www.perl.org/");
   sub cb {
       my($tag, %links) = @_;
       print "$tag @{[%links]}\n";
   }
   $p->parse_file("index.html");
  
  =head1 DESCRIPTION
  
  I<HTML::LinkExtor> is an HTML parser that extracts links from an
  HTML document.  The I<HTML::LinkExtor> is a subclass of
  I<HTML::Parser>. This means that the document should be given to the
  parser by calling the $p->parse() or $p->parse_file() methods.
  
  =cut
  
  use strict;
  use HTML::Tagset ();
  
  # legacy (some applications grabs this hash directly)
  use vars qw(%LINK_ELEMENT);
  *LINK_ELEMENT = \%HTML::Tagset::linkElements;
  
  =over 4
  
  =item $p = HTML::LinkExtor->new
  
  =item $p = HTML::LinkExtor->new( $callback )
  
  =item $p = HTML::LinkExtor->new( $callback, $base )
  
  The constructor takes two optional arguments. The first is a reference
  to a callback routine. It will be called as links are found. If a
  callback is not provided, then links are just accumulated internally
  and can be retrieved by calling the $p->links() method.
  
  The $base argument is an optional base URL used to absolutize all URLs found.
  You need to have the I<URI> module installed if you provide $base.
  
  The callback is called with the lowercase tag name as first argument,
  and then all link attributes as separate key/value pairs.  All
  non-link attributes are removed.
  
  =cut
  
  sub new
  {
      my($class, $cb, $base) = @_;
      my $self = $class->SUPER::new(
                      start_h => ["_start_tag", "self,tagname,attr"],
  		    report_tags => [keys %HTML::Tagset::linkElements],
  	       );
      $self->{extractlink_cb} = $cb;
      if ($base) {
  	require URI;
  	$self->{extractlink_base} = URI->new($base);
      }
      $self;
  }
  
  sub _start_tag
  {
      my($self, $tag, $attr) = @_;
  
      my $base = $self->{extractlink_base};
      my $links = $HTML::Tagset::linkElements{$tag};
      $links = [$links] unless ref $links;
  
      my @links;
      my $a;
      for $a (@$links) {
  	next unless exists $attr->{$a};
  	(my $link = $attr->{$a}) =~ s/^\s+//; $link =~ s/\s+$//; # HTML5
  	push(@links, $a, $base ? URI->new($link, $base)->abs($base) : $link);
      }
      return unless @links;
      $self->_found_link($tag, @links);
  }
  
  sub _found_link
  {
      my $self = shift;
      my $cb = $self->{extractlink_cb};
      if ($cb) {
  	&$cb(@_);
      } else {
  	push(@{$self->{'links'}}, [@_]);
      }
  }
  
  =item $p->links
  
  Returns a list of all links found in the document.  The returned
  values will be anonymous arrays with the following elements:
  
    [$tag, $attr => $url1, $attr2 => $url2,...]
  
  The $p->links method will also truncate the internal link list.  This
  means that if the method is called twice without any parsing
  between them the second call will return an empty list.
  
  Also note that $p->links will always be empty if a callback routine
  was provided when the I<HTML::LinkExtor> was created.
  
  =cut
  
  sub links
  {
      my $self = shift;
      exists($self->{'links'}) ? @{delete $self->{'links'}} : ();
  }
  
  # We override the parse_file() method so that we can clear the links
  # before we start a new file.
  sub parse_file
  {
      my $self = shift;
      delete $self->{'links'};
      $self->SUPER::parse_file(@_);
  }
  
  =back
  
  =head1 EXAMPLE
  
  This is an example showing how you can extract links from a document
  received using LWP:
  
    use LWP::UserAgent;
    use HTML::LinkExtor;
    use URI::URL;
  
    $url = "http://www.perl.org/";  # for instance
    $ua = LWP::UserAgent->new;
  
    # Set up a callback that collect image links
    my @imgs = ();
    sub callback {
       my($tag, %attr) = @_;
       return if $tag ne 'img';  # we only look closer at <img ...>
       push(@imgs, values %attr);
    }
  
    # Make the parser.  Unfortunately, we don't know the base yet
    # (it might be different from $url)
    $p = HTML::LinkExtor->new(\&callback);
  
    # Request document and parse it as it arrives
    $res = $ua->request(HTTP::Request->new(GET => $url),
                        sub {$p->parse($_[0])});
  
    # Expand all image URLs to absolute ones
    my $base = $res->base;
    @imgs = map { $_ = url($_, $base)->abs; } @imgs;
  
    # Print them out
    print join("\n", @imgs), "\n";
  
  =head1 SEE ALSO
  
  L<HTML::Parser>, L<HTML::Tagset>, L<LWP>, L<URI::URL>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
DARWIN-2LEVEL_HTML_LINKEXTOR

$fatpacked{"darwin-2level/HTML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_PARSER';
  package HTML::Parser;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = "3.72";
  
  require HTML::Entities;
  
  require XSLoader;
  XSLoader::load('HTML::Parser', $VERSION);
  
  sub new
  {
      my $class = shift;
      my $self = bless {}, $class;
      return $self->init(@_);
  }
  
  
  sub init
  {
      my $self = shift;
      $self->_alloc_pstate;
  
      my %arg = @_;
      my $api_version = delete $arg{api_version} || (@_ ? 3 : 2);
      if ($api_version >= 4) {
  	require Carp;
  	Carp::croak("API version $api_version not supported " .
  		    "by HTML::Parser $VERSION");
      }
  
      if ($api_version < 3) {
  	# Set up method callbacks compatible with HTML-Parser-2.xx
  	$self->handler(text    => "text",    "self,text,is_cdata");
  	$self->handler(end     => "end",     "self,tagname,text");
  	$self->handler(process => "process", "self,token0,text");
  	$self->handler(start   => "start",
  		                  "self,tagname,attr,attrseq,text");
  
  	$self->handler(comment =>
  		       sub {
  			   my($self, $tokens) = @_;
  			   for (@$tokens) {
  			       $self->comment($_);
  			   }
  		       }, "self,tokens");
  
  	$self->handler(declaration =>
  		       sub {
  			   my $self = shift;
  			   $self->declaration(substr($_[0], 2, -1));
  		       }, "self,text");
      }
  
      if (my $h = delete $arg{handlers}) {
  	$h = {@$h} if ref($h) eq "ARRAY";
  	while (my($event, $cb) = each %$h) {
  	    $self->handler($event => @$cb);
  	}
      }
  
      # In the end we try to assume plain attribute or handler
      while (my($option, $val) = each %arg) {
  	if ($option =~ /^(\w+)_h$/) {
  	    $self->handler($1 => @$val);
  	}
          elsif ($option =~ /^(text|start|end|process|declaration|comment)$/) {
  	    require Carp;
  	    Carp::croak("Bad constructor option '$option'");
          }
  	else {
  	    $self->$option($val);
  	}
      }
  
      return $self;
  }
  
  
  sub parse_file
  {
      my($self, $file) = @_;
      my $opened;
      if (!ref($file) && ref(\$file) ne "GLOB") {
          # Assume $file is a filename
          local(*F);
          open(F, "<", $file) || return undef;
  	binmode(F);  # should we? good for byte counts
          $opened++;
          $file = *F;
      }
      my $chunk = '';
      while (read($file, $chunk, 512)) {
  	$self->parse($chunk) || last;
      }
      close($file) if $opened;
      $self->eof;
  }
  
  
  sub netscape_buggy_comment  # legacy
  {
      my $self = shift;
      require Carp;
      Carp::carp("netscape_buggy_comment() is deprecated.  " .
  	       "Please use the strict_comment() method instead");
      my $old = !$self->strict_comment;
      $self->strict_comment(!shift) if @_;
      return $old;
  }
  
  # set up method stubs
  sub text { }
  *start       = \&text;
  *end         = \&text;
  *comment     = \&text;
  *declaration = \&text;
  *process     = \&text;
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  HTML::Parser - HTML parser class
  
  =head1 SYNOPSIS
  
   use HTML::Parser ();
  
   # Create parser object
   $p = HTML::Parser->new( api_version => 3,
                           start_h => [\&start, "tagname, attr"],
                           end_h   => [\&end,   "tagname"],
                           marked_sections => 1,
                         );
  
   # Parse document text chunk by chunk
   $p->parse($chunk1);
   $p->parse($chunk2);
   #...
   $p->eof;                 # signal end of document
  
   # Parse directly from file
   $p->parse_file("foo.html");
   # or
   open(my $fh, "<:utf8", "foo.html") || die;
   $p->parse_file($fh);
  
  =head1 DESCRIPTION
  
  Objects of the C<HTML::Parser> class will recognize markup and
  separate it from plain text (alias data content) in HTML
  documents.  As different kinds of markup and text are recognized, the
  corresponding event handlers are invoked.
  
  C<HTML::Parser> is not a generic SGML parser.  We have tried to
  make it able to deal with the HTML that is actually "out there", and
  it normally parses as closely as possible to the way the popular web
  browsers do it instead of strictly following one of the many HTML
  specifications from W3C.  Where there is disagreement, there is often
  an option that you can enable to get the official behaviour.
  
  The document to be parsed may be supplied in arbitrary chunks.  This
  makes on-the-fly parsing as documents are received from the network
  possible.
  
  If event driven parsing does not feel right for your application, you
  might want to use C<HTML::PullParser>.  This is an C<HTML::Parser>
  subclass that allows a more conventional program structure.
  
  
  =head1 METHODS
  
  The following method is used to construct a new C<HTML::Parser> object:
  
  =over
  
  =item $p = HTML::Parser->new( %options_and_handlers )
  
  This class method creates a new C<HTML::Parser> object and
  returns it.  Key/value argument pairs may be provided to assign event
  handlers or initialize parser options.  The handlers and parser
  options can also be set or modified later by the method calls described below.
  
  If a top level key is in the form "<event>_h" (e.g., "text_h") then it
  assigns a handler to that event, otherwise it initializes a parser
  option. The event handler specification value must be an array
  reference.  Multiple handlers may also be assigned with the 'handlers
  => [%handlers]' option.  See examples below.
  
  If new() is called without any arguments, it will create a parser that
  uses callback methods compatible with version 2 of C<HTML::Parser>.
  See the section on "version 2 compatibility" below for details.
  
  The special constructor option 'api_version => 2' can be used to
  initialize version 2 callbacks while still setting other options and
  handlers.  The 'api_version => 3' option can be used if you don't want
  to set any options and don't want to fall back to v2 compatible
  mode.
  
  Examples:
  
   $p = HTML::Parser->new(api_version => 3,
                          text_h => [ sub {...}, "dtext" ]);
  
  This creates a new parser object with a text event handler subroutine
  that receives the original text with general entities decoded.
  
   $p = HTML::Parser->new(api_version => 3,
  			start_h => [ 'my_start', "self,tokens" ]);
  
  This creates a new parser object with a start event handler method
  that receives the $p and the tokens array.
  
   $p = HTML::Parser->new(api_version => 3,
  		        handlers => { text => [\@array, "event,text"],
                                        comment => [\@array, "event,text"],
                                      });
  
  This creates a new parser object that stores the event type and the
  original text in @array for text and comment events.
  
  =back
  
  The following methods feed the HTML document
  to the C<HTML::Parser> object:
  
  =over
  
  =item $p->parse( $string )
  
  Parse $string as the next chunk of the HTML document.  Handlers invoked should
  not attempt to modify the $string in-place until $p->parse returns.
  
  If an invoked event handler aborts parsing by calling $p->eof, then $p->parse()
  will return a FALSE value.  Otherwise the return value is a reference to the
  parser object ($p).
  
  =item $p->parse( $code_ref )
  
  If a code reference is passed as the argument to be parsed, then the
  chunks to be parsed are obtained by invoking this function repeatedly.
  Parsing continues until the function returns an empty (or undefined)
  result.  When this happens $p->eof is automatically signaled.
  
  Parsing will also abort if one of the event handlers calls $p->eof.
  
  The effect of this is the same as:
  
   while (1) {
      my $chunk = &$code_ref();
      if (!defined($chunk) || !length($chunk)) {
          $p->eof;
          return $p;
      }
      $p->parse($chunk) || return undef;
   }
  
  But it is more efficient as this loop runs internally in XS code.
  
  =item $p->parse_file( $file )
  
  Parse text directly from a file.  The $file argument can be a
  filename, an open file handle, or a reference to an open file
  handle.
  
  If $file contains a filename and the file can't be opened, then the
  method returns an undefined value and $! tells why it failed.
  Otherwise the return value is a reference to the parser object.
  
  If a file handle is passed as the $file argument, then the file will
  normally be read until EOF, but not closed.
  
  If an invoked event handler aborts parsing by calling $p->eof,
  then $p->parse_file() may not have read the entire file.
  
  On systems with multi-byte line terminators, the values passed for the
  offset and length argspecs may be too low if parse_file() is called on
  a file handle that is not in binary mode.
  
  If a filename is passed in, then parse_file() will open the file in
  binary mode.
  
  =item $p->eof
  
  Signals the end of the HTML document.  Calling the $p->eof method
  outside a handler callback will flush any remaining buffered text
  (which triggers the C<text> event if there is any remaining text).
  
  Calling $p->eof inside a handler will terminate parsing at that point
  and cause $p->parse to return a FALSE value.  This also terminates
  parsing by $p->parse_file().
  
  After $p->eof has been called, the parse() and parse_file() methods
  can be invoked to feed new documents with the parser object.
  
  The return value from eof() is a reference to the parser object.
  
  =back
  
  
  Most parser options are controlled by boolean attributes.
  Each boolean attribute is enabled by calling the corresponding method
  with a TRUE argument and disabled with a FALSE argument.  The
  attribute value is left unchanged if no argument is given.  The return
  value from each method is the old attribute value.
  
  Methods that can be used to get and/or set parser options are:
  
  =over
  
  =item $p->attr_encoded
  
  =item $p->attr_encoded( $bool )
  
  By default, the C<attr> and C<@attr> argspecs will have general
  entities for attribute values decoded.  Enabling this attribute leaves
  entities alone.
  
  =item $p->backquote
  
  =item $p->backquote( $bool )
  
  By default, only ' and " are recognized as quote characters around
  attribute values.  MSIE also recognizes backquotes for some reason.
  Enabling this attribute provides compatibility with this behaviour.
  
  =item $p->boolean_attribute_value( $val )
  
  This method sets the value reported for boolean attributes inside HTML
  start tags.  By default, the name of the attribute is also used as its
  value.  This affects the values reported for C<tokens> and C<attr>
  argspecs.
  
  =item $p->case_sensitive
  
  =item $p->case_sensitive( $bool )
  
  By default, tagnames and attribute names are down-cased.  Enabling this
  attribute leaves them as found in the HTML source document.
  
  =item $p->closing_plaintext
  
  =item $p->closing_plaintext( $bool )
  
  By default, "plaintext" element can never be closed. Everything up to
  the end of the document is parsed in CDATA mode.  This historical
  behaviour is what at least MSIE does.  Enabling this attribute makes
  closing "</plaintext>" tag effective and the parsing process will resume
  after seeing this tag.  This emulates early gecko-based browsers.
  
  =item $p->empty_element_tags
  
  =item $p->empty_element_tags( $bool )
  
  By default, empty element tags are not recognized as such and the "/"
  before ">" is just treated like a normal name character (unless
  C<strict_names> is enabled).  Enabling this attribute make
  C<HTML::Parser> recognize these tags.
  
  Empty element tags look like start tags, but end with the character
  sequence "/>" instead of ">".  When recognized by C<HTML::Parser> they
  cause an artificial end event in addition to the start event.  The
  C<text> for the artificial end event will be empty and the C<tokenpos>
  array will be undefined even though the token array will have one
  element containing the tag name.
  
  =item $p->marked_sections
  
  =item $p->marked_sections( $bool )
  
  By default, section markings like <![CDATA[...]]> are treated like
  ordinary text.  When this attribute is enabled section markings are
  honoured.
  
  There are currently no events associated with the marked section
  markup, but the text can be returned as C<skipped_text>.
  
  =item $p->strict_comment
  
  =item $p->strict_comment( $bool )
  
  By default, comments are terminated by the first occurrence of "-->".
  This is the behaviour of most popular browsers (like Mozilla, Opera and
  MSIE), but it is not correct according to the official HTML
  standard.  Officially, you need an even number of "--" tokens before
  the closing ">" is recognized and there may not be anything but
  whitespace between an even and an odd "--".
  
  The official behaviour is enabled by enabling this attribute.
  
  Enabling of 'strict_comment' also disables recognizing these forms as
  comments:
  
    </ comment>
    <! comment>
  
  
  =item $p->strict_end
  
  =item $p->strict_end( $bool )
  
  By default, attributes and other junk are allowed to be present on end tags in a
  manner that emulates MSIE's behaviour.
  
  The official behaviour is enabled with this attribute.  If enabled,
  only whitespace is allowed between the tagname and the final ">".
  
  =item $p->strict_names
  
  =item $p->strict_names( $bool )
  
  By default, almost anything is allowed in tag and attribute names.
  This is the behaviour of most popular browsers and allows us to parse
  some broken tags with invalid attribute values like:
  
     <IMG SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0>
  
  By default, "LIST]" is parsed as a boolean attribute, not as
  part of the ALT value as was clearly intended.  This is also what
  Mozilla sees.
  
  The official behaviour is enabled by enabling this attribute.  If
  enabled, it will cause the tag above to be reported as text
  since "LIST]" is not a legal attribute name.
  
  =item $p->unbroken_text
  
  =item $p->unbroken_text( $bool )
  
  By default, blocks of text are given to the text handler as soon as
  possible (but the parser takes care always to break text at a
  boundary between whitespace and non-whitespace so single words and
  entities can always be decoded safely).  This might create breaks that
  make it hard to do transformations on the text. When this attribute is
  enabled, blocks of text are always reported in one piece.  This will
  delay the text event until the following (non-text) event has been
  recognized by the parser.
  
  Note that the C<offset> argspec will give you the offset of the first
  segment of text and C<length> is the combined length of the segments.
  Since there might be ignored tags in between, these numbers can't be
  used to directly index in the original document file.
  
  =item $p->utf8_mode
  
  =item $p->utf8_mode( $bool )
  
  Enable this option when parsing raw undecoded UTF-8.  This tells the
  parser that the entities expanded for strings reported by C<attr>,
  C<@attr> and C<dtext> should be expanded as decoded UTF-8 so they end
  up compatible with the surrounding text.
  
  If C<utf8_mode> is enabled then it is an error to pass strings
  containing characters with code above 255 to the parse() method, and
  the parse() method will croak if you try.
  
  Example: The Unicode character "\x{2665}" is "\xE2\x99\xA5" when UTF-8
  encoded.  The character can also be represented by the entity
  "&hearts;" or "&#x2665".  If we feed the parser:
  
    $p->parse("\xE2\x99\xA5&hearts;");
  
  then C<dtext> will be reported as "\xE2\x99\xA5\x{2665}" without
  C<utf8_mode> enabled, but as "\xE2\x99\xA5\xE2\x99\xA5" when enabled.
  The later string is what you want.
  
  This option is only available with perl-5.8 or better.
  
  =item $p->xml_mode
  
  =item $p->xml_mode( $bool )
  
  Enabling this attribute changes the parser to allow some XML
  constructs.  This enables the behaviour controlled by individually by
  the C<case_sensitive>, C<empty_element_tags>, C<strict_names> and
  C<xml_pic> attributes and also suppresses special treatment of
  elements that are parsed as CDATA for HTML.
  
  =item $p->xml_pic
  
  =item $p->xml_pic( $bool )
  
  By default, I<processing instructions> are terminated by ">". When
  this attribute is enabled, processing instructions are terminated by
  "?>" instead.
  
  =back
  
  As markup and text is recognized, handlers are invoked.  The following
  method is used to set up handlers for different events:
  
  =over
  
  =item $p->handler( event => \&subroutine, $argspec )
  
  =item $p->handler( event => $method_name, $argspec )
  
  =item $p->handler( event => \@accum, $argspec )
  
  =item $p->handler( event => "" );
  
  =item $p->handler( event => undef );
  
  =item $p->handler( event );
  
  This method assigns a subroutine, method, or array to handle an event.
  
  Event is one of C<text>, C<start>, C<end>, C<declaration>, C<comment>,
  C<process>, C<start_document>, C<end_document> or C<default>.
  
  The C<\&subroutine> is a reference to a subroutine which is called to handle
  the event.
  
  The C<$method_name> is the name of a method of $p which is called to handle
  the event.
  
  The C<@accum> is an array that will hold the event information as
  sub-arrays.
  
  If the second argument is "", the event is ignored.
  If it is undef, the default handler is invoked for the event.
  
  The C<$argspec> is a string that describes the information to be reported
  for the event.  Any requested information that does not apply to a
  specific event is passed as C<undef>.  If argspec is omitted, then it
  is left unchanged.
  
  The return value from $p->handler is the old callback routine or a
  reference to the accumulator array.
  
  Any return values from handler callback routines/methods are always
  ignored.  A handler callback can request parsing to be aborted by
  invoking the $p->eof method.  A handler callback is not allowed to
  invoke the $p->parse() or $p->parse_file() method.  An exception will
  be raised if it tries.
  
  Examples:
  
      $p->handler(start =>  "start", 'self, attr, attrseq, text' );
  
  This causes the "start" method of object $p to be called for 'start' events.
  The callback signature is $p->start(\%attr, \@attr_seq, $text).
  
      $p->handler(start =>  \&start, 'attr, attrseq, text' );
  
  This causes subroutine start() to be called for 'start' events.
  The callback signature is start(\%attr, \@attr_seq, $text).
  
      $p->handler(start =>  \@accum, '"S", attr, attrseq, text' );
  
  This causes 'start' event information to be saved in @accum.
  The array elements will be ['S', \%attr, \@attr_seq, $text].
  
     $p->handler(start => "");
  
  This causes 'start' events to be ignored.  It also suppresses
  invocations of any default handler for start events.  It is in most
  cases equivalent to $p->handler(start => sub {}), but is more
  efficient.  It is different from the empty-sub-handler in that
  C<skipped_text> is not reset by it.
  
     $p->handler(start => undef);
  
  This causes no handler to be associated with start events.
  If there is a default handler it will be invoked.
  
  =back
  
  Filters based on tags can be set up to limit the number of events
  reported.  The main bottleneck during parsing is often the huge number
  of callbacks made from the parser.  Applying filters can improve
  performance significantly.
  
  The following methods control filters:
  
  =over
  
  =item $p->ignore_elements( @tags )
  
  Both the C<start> event and the C<end> event as well as any events that
  would be reported in between are suppressed.  The ignored elements can
  contain nested occurrences of itself.  Example:
  
     $p->ignore_elements(qw(script style));
  
  The C<script> and C<style> tags will always nest properly since their
  content is parsed in CDATA mode.  For most other tags
  C<ignore_elements> must be used with caution since HTML is often not
  I<well formed>.
  
  =item $p->ignore_tags( @tags )
  
  Any C<start> and C<end> events involving any of the tags given are
  suppressed.  To reset the filter (i.e. don't suppress any C<start> and
  C<end> events), call C<ignore_tags> without an argument.
  
  =item $p->report_tags( @tags )
  
  Any C<start> and C<end> events involving any of the tags I<not> given
  are suppressed.  To reset the filter (i.e. report all C<start> and
  C<end> events), call C<report_tags> without an argument.
  
  =back
  
  Internally, the system has two filter lists, one for C<report_tags>
  and one for C<ignore_tags>, and both filters are applied.  This
  effectively gives C<ignore_tags> precedence over C<report_tags>.
  
  Examples:
  
     $p->ignore_tags(qw(style));
     $p->report_tags(qw(script style));
  
  results in only C<script> events being reported.
  
  =head2 Argspec
  
  Argspec is a string containing a comma-separated list that describes
  the information reported by the event.  The following argspec
  identifier names can be used:
  
  =over
  
  =item C<attr>
  
  Attr causes a reference to a hash of attribute name/value pairs to be
  passed.
  
  Boolean attributes' values are either the value set by
  $p->boolean_attribute_value, or the attribute name if no value has been
  set by $p->boolean_attribute_value.
  
  This passes undef except for C<start> events.
  
  Unless C<xml_mode> or C<case_sensitive> is enabled, the attribute
  names are forced to lower case.
  
  General entities are decoded in the attribute values and
  one layer of matching quotes enclosing the attribute values is removed.
  
  The Unicode character set is assumed for entity decoding.
  
  =item C<@attr>
  
  Basically the same as C<attr>, but keys and values are passed as
  individual arguments and the original sequence of the attributes is
  kept.  The parameters passed will be the same as the @attr calculated
  here:
  
     @attr = map { $_ => $attr->{$_} } @$attrseq;
  
  assuming $attr and $attrseq here are the hash and array passed as the
  result of C<attr> and C<attrseq> argspecs.
  
  This passes no values for events besides C<start>.
  
  =item C<attrseq>
  
  Attrseq causes a reference to an array of attribute names to be
  passed.  This can be useful if you want to walk the C<attr> hash in
  the original sequence.
  
  This passes undef except for C<start> events.
  
  Unless C<xml_mode> or C<case_sensitive> is enabled, the attribute
  names are forced to lower case.
  
  =item C<column>
  
  Column causes the column number of the start of the event to be passed.
  The first column on a line is 0.
  
  =item C<dtext>
  
  Dtext causes the decoded text to be passed.  General entities are
  automatically decoded unless the event was inside a CDATA section or
  was between literal start and end tags (C<script>, C<style>,
  C<xmp>, C<iframe>, C<title>, C<textarea> and C<plaintext>).
  
  The Unicode character set is assumed for entity decoding.  With Perl
  version 5.6 or earlier only the Latin-1 range is supported, and
  entities for characters outside the range 0..255 are left unchanged.
  
  This passes undef except for C<text> events.
  
  =item C<event>
  
  Event causes the event name to be passed.
  
  The event name is one of C<text>, C<start>, C<end>, C<declaration>,
  C<comment>, C<process>, C<start_document> or C<end_document>.
  
  =item C<is_cdata>
  
  Is_cdata causes a TRUE value to be passed if the event is inside a CDATA
  section or between literal start and end tags (C<script>,
  C<style>, C<xmp>, C<iframe>, C<title>, C<textarea> and C<plaintext>).
  
  if the flag is FALSE for a text event, then you should normally
  either use C<dtext> or decode the entities yourself before the text is
  processed further.
  
  =item C<length>
  
  Length causes the number of bytes of the source text of the event to
  be passed.
  
  =item C<line>
  
  Line causes the line number of the start of the event to be passed.
  The first line in the document is 1.  Line counting doesn't start
  until at least one handler requests this value to be reported.
  
  =item C<offset>
  
  Offset causes the byte position in the HTML document of the start of
  the event to be passed.  The first byte in the document has offset 0.
  
  =item C<offset_end>
  
  Offset_end causes the byte position in the HTML document of the end of
  the event to be passed.  This is the same as C<offset> + C<length>.
  
  =item C<self>
  
  Self causes the current object to be passed to the handler.  If the
  handler is a method, this must be the first element in the argspec.
  
  An alternative to passing self as an argspec is to register closures
  that capture $self by themselves as handlers.  Unfortunately this
  creates circular references which prevent the HTML::Parser object
  from being garbage collected.  Using the C<self> argspec avoids this
  problem.
  
  =item C<skipped_text>
  
  Skipped_text returns the concatenated text of all the events that have
  been skipped since the last time an event was reported.  Events might
  be skipped because no handler is registered for them or because some
  filter applies.  Skipped text also includes marked section markup,
  since there are no events that can catch it.
  
  If an C<"">-handler is registered for an event, then the text for this
  event is not included in C<skipped_text>.  Skipped text both before
  and after the C<"">-event is included in the next reported
  C<skipped_text>.
  
  =item C<tag>
  
  Same as C<tagname>, but prefixed with "/" if it belongs to an C<end>
  event and "!" for a declaration.  The C<tag> does not have any prefix
  for C<start> events, and is in this case identical to C<tagname>.
  
  =item C<tagname>
  
  This is the element name (or I<generic identifier> in SGML jargon) for
  start and end tags.  Since HTML is case insensitive, this name is
  forced to lower case to ease string matching.
  
  Since XML is case sensitive, the tagname case is not changed when
  C<xml_mode> is enabled.  The same happens if the C<case_sensitive> attribute
  is set.
  
  The declaration type of declaration elements is also passed as a tagname,
  even if that is a bit strange.
  In fact, in the current implementation tagname is
  identical to C<token0> except that the name may be forced to lower case.
  
  =item C<token0>
  
  Token0 causes the original text of the first token string to be
  passed.  This should always be the same as $tokens->[0].
  
  For C<declaration> events, this is the declaration type.
  
  For C<start> and C<end> events, this is the tag name.
  
  For C<process> and non-strict C<comment> events, this is everything
  inside the tag.
  
  This passes undef if there are no tokens in the event.
  
  =item C<tokenpos>
  
  Tokenpos causes a reference to an array of token positions to be
  passed.  For each string that appears in C<tokens>, this array
  contains two numbers.  The first number is the offset of the start of
  the token in the original C<text> and the second number is the length
  of the token.
  
  Boolean attributes in a C<start> event will have (0,0) for the
  attribute value offset and length.
  
  This passes undef if there are no tokens in the event (e.g., C<text>)
  and for artificial C<end> events triggered by empty element tags.
  
  If you are using these offsets and lengths to modify C<text>, you
  should either work from right to left, or be very careful to calculate
  the changes to the offsets.
  
  =item C<tokens>
  
  Tokens causes a reference to an array of token strings to be passed.
  The strings are exactly as they were found in the original text,
  no decoding or case changes are applied.
  
  For C<declaration> events, the array contains each word, comment, and
  delimited string starting with the declaration type.
  
  For C<comment> events, this contains each sub-comment.  If
  $p->strict_comments is disabled, there will be only one sub-comment.
  
  For C<start> events, this contains the original tag name followed by
  the attribute name/value pairs.  The values of boolean attributes will
  be either the value set by $p->boolean_attribute_value, or the
  attribute name if no value has been set by
  $p->boolean_attribute_value.
  
  For C<end> events, this contains the original tag name (always one token).
  
  For C<process> events, this contains the process instructions (always one
  token).
  
  This passes C<undef> for C<text> events.
  
  =item C<text>
  
  Text causes the source text (including markup element delimiters) to be
  passed.
  
  =item C<undef>
  
  Pass an undefined value.  Useful as padding where the same handler
  routine is registered for multiple events.
  
  =item C<'...'>
  
  A literal string of 0 to 255 characters enclosed
  in single (') or double (") quotes is passed as entered.
  
  =back
  
  The whole argspec string can be wrapped up in C<'@{...}'> to signal
  that the resulting event array should be flattened.  This only makes a
  difference if an array reference is used as the handler target.
  Consider this example:
  
     $p->handler(text => [], 'text');
     $p->handler(text => [], '@{text}']);
  
  With two text events; C<"foo">, C<"bar">; then the first example will end
  up with [["foo"], ["bar"]] and the second with ["foo", "bar"] in
  the handler target array.
  
  
  =head2 Events
  
  Handlers for the following events can be registered:
  
  =over
  
  =item C<comment>
  
  This event is triggered when a markup comment is recognized.
  
  Example:
  
    <!-- This is a comment -- -- So is this -->
  
  =item C<declaration>
  
  This event is triggered when a I<markup declaration> is recognized.
  
  For typical HTML documents, the only declaration you are
  likely to find is <!DOCTYPE ...>.
  
  Example:
  
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
  
  DTDs inside <!DOCTYPE ...> will confuse HTML::Parser.
  
  =item C<default>
  
  This event is triggered for events that do not have a specific
  handler.  You can set up a handler for this event to catch stuff you
  did not want to catch explicitly.
  
  =item C<end>
  
  This event is triggered when an end tag is recognized.
  
  Example:
  
    </A>
  
  =item C<end_document>
  
  This event is triggered when $p->eof is called and after any remaining
  text is flushed.  There is no document text associated with this event.
  
  =item C<process>
  
  This event is triggered when a processing instructions markup is
  recognized.
  
  The format and content of processing instructions are system and
  application dependent.
  
  Examples:
  
    <? HTML processing instructions >
    <? XML processing instructions ?>
  
  =item C<start>
  
  This event is triggered when a start tag is recognized.
  
  Example:
  
    <A HREF="http://www.perl.com/">
  
  =item C<start_document>
  
  This event is triggered before any other events for a new document.  A
  handler for it can be used to initialize stuff.  There is no document
  text associated with this event.
  
  =item C<text>
  
  This event is triggered when plain text (characters) is recognized.
  The text may contain multiple lines.  A sequence of text may be broken
  between several text events unless $p->unbroken_text is enabled.
  
  The parser will make sure that it does not break a word or a sequence
  of whitespace between two text events.
  
  =back
  
  =head2 Unicode
  
  C<HTML::Parser> can parse Unicode strings when running under
  perl-5.8 or better.  If Unicode is passed to $p->parse() then chunks
  of Unicode will be reported to the handlers.  The offset and length
  argspecs will also report their position in terms of characters.
  
  It is safe to parse raw undecoded UTF-8 if you either avoid decoding
  entities and make sure to not use I<argspecs> that do, or enable the
  C<utf8_mode> for the parser.  Parsing of undecoded UTF-8 might be
  useful when parsing from a file where you need the reported offsets
  and lengths to match the byte offsets in the file.
  
  If a filename is passed to $p->parse_file() then the file will be read
  in binary mode.  This will be fine if the file contains only ASCII or
  Latin-1 characters.  If the file contains UTF-8 encoded text then care
  must be taken when decoding entities as described in the previous
  paragraph, but better is to open the file with the UTF-8 layer so that
  it is decoded properly:
  
     open(my $fh, "<:utf8", "index.html") || die "...: $!";
     $p->parse_file($fh);
  
  If the file contains text encoded in a charset besides ASCII, Latin-1
  or UTF-8 then decoding will always be needed.
  
  =head1 VERSION 2 COMPATIBILITY
  
  When an C<HTML::Parser> object is constructed with no arguments, a set
  of handlers is automatically provided that is compatible with the old
  HTML::Parser version 2 callback methods.
  
  This is equivalent to the following method calls:
  
     $p->handler(start   => "start",   "self, tagname, attr, attrseq, text");
     $p->handler(end     => "end",     "self, tagname, text");
     $p->handler(text    => "text",    "self, text, is_cdata");
     $p->handler(process => "process", "self, token0, text");
     $p->handler(comment =>
               sub {
  		 my($self, $tokens) = @_;
  		 for (@$tokens) {$self->comment($_);}},
               "self, tokens");
     $p->handler(declaration =>
               sub {
  		 my $self = shift;
  		 $self->declaration(substr($_[0], 2, -1));},
               "self, text");
  
  Setting up these handlers can also be requested with the "api_version =>
  2" constructor option.
  
  =head1 SUBCLASSING
  
  The C<HTML::Parser> class is subclassable.  Parser objects are plain
  hashes and C<HTML::Parser> reserves only hash keys that start with
  "_hparser".  The parser state can be set up by invoking the init()
  method, which takes the same arguments as new().
  
  =head1 EXAMPLES
  
  The first simple example shows how you might strip out comments from
  an HTML document.  We achieve this by setting up a comment handler that
  does nothing and a default handler that will print out anything else:
  
    use HTML::Parser;
    HTML::Parser->new(default_h => [sub { print shift }, 'text'],
                      comment_h => [""],
                     )->parse_file(shift || die) || die $!;
  
  An alternative implementation is:
  
    use HTML::Parser;
    HTML::Parser->new(end_document_h => [sub { print shift },
                                         'skipped_text'],
                      comment_h      => [""],
                     )->parse_file(shift || die) || die $!;
  
  This will in most cases be much more efficient since only a single
  callback will be made.
  
  The next example prints out the text that is inside the <title>
  element of an HTML document.  Here we start by setting up a start
  handler.  When it sees the title start tag it enables a text handler
  that prints any text found and an end handler that will terminate
  parsing as soon as the title end tag is seen:
  
    use HTML::Parser ();
  
    sub start_handler
    {
      return if shift ne "title";
      my $self = shift;
      $self->handler(text => sub { print shift }, "dtext");
      $self->handler(end  => sub { shift->eof if shift eq "title"; },
  		           "tagname,self");
    }
  
    my $p = HTML::Parser->new(api_version => 3);
    $p->handler( start => \&start_handler, "tagname,self");
    $p->parse_file(shift || die) || die $!;
    print "\n";
  
  More examples are found in the F<eg/> directory of the C<HTML-Parser>
  distribution: the program C<hrefsub> shows how you can edit all links
  found in a document; the program C<htextsub> shows how to edit the text only; the
  program C<hstrip> shows how you can strip out certain tags/elements
  and/or attributes; and the program C<htext> show how to obtain the
  plain text, but not any script/style content.
  
  You can browse the F<eg/> directory online from the I<[Browse]> link on
  the http://search.cpan.org/~gaas/HTML-Parser/ page.
  
  =head1 BUGS
  
  The <style> and <script> sections do not end with the first "</", but
  need the complete corresponding end tag.  The standard behaviour is
  not really practical.
  
  When the I<strict_comment> option is enabled, we still recognize
  comments where there is something other than whitespace between even
  and odd "--" markers.
  
  Once $p->boolean_attribute_value has been set, there is no way to
  restore the default behaviour.
  
  There is currently no way to get both quote characters
  into the same literal argspec.
  
  Empty tags, e.g. "<>" and "</>", are not recognized.  SGML allows them
  to repeat the previous start tag or close the previous start tag
  respectively.
  
  NET tags, e.g. "code/.../" are not recognized.  This is SGML
  shorthand for "<code>...</code>".
  
  Unclosed start or end tags, e.g. "<tt<b>...</b</tt>" are not
  recognized.
  
  =head1 DIAGNOSTICS
  
  The following messages may be produced by HTML::Parser.  The notation
  in this listing is the same as used in L<perldiag>:
  
  =over
  
  =item Not a reference to a hash
  
  (F) The object blessed into or subclassed from HTML::Parser is not a
  hash as required by the HTML::Parser methods.
  
  =item Bad signature in parser state object at %p
  
  (F) The _hparser_xs_state element does not refer to a valid state structure.
  Something must have changed the internal value
  stored in this hash element, or the memory has been overwritten.
  
  =item _hparser_xs_state element is not a reference
  
  (F) The _hparser_xs_state element has been destroyed.
  
  =item Can't find '_hparser_xs_state' element in HTML::Parser hash
  
  (F) The _hparser_xs_state element is missing from the parser hash.
  It was either deleted, or not created when the object was created.
  
  =item API version %s not supported by HTML::Parser %s
  
  (F) The constructor option 'api_version' with an argument greater than
  or equal to 4 is reserved for future extensions.
  
  =item Bad constructor option '%s'
  
  (F) An unknown constructor option key was passed to the new() or
  init() methods.
  
  =item Parse loop not allowed
  
  (F) A handler invoked the parse() or parse_file() method.
  This is not permitted.
  
  =item marked sections not supported
  
  (F) The $p->marked_sections() method was invoked in a HTML::Parser
  module that was compiled without support for marked sections.
  
  =item Unknown boolean attribute (%d)
  
  (F) Something is wrong with the internal logic that set up aliases for
  boolean attributes.
  
  =item Only code or array references allowed as handler
  
  (F) The second argument for $p->handler must be either a subroutine
  reference, then name of a subroutine or method, or a reference to an
  array.
  
  =item No handler for %s events
  
  (F) The first argument to $p->handler must be a valid event name; i.e. one
  of "start", "end", "text", "process", "declaration" or "comment".
  
  =item Unrecognized identifier %s in argspec
  
  (F) The identifier is not a known argspec name.
  Use one of the names mentioned in the argspec section above.
  
  =item Literal string is longer than 255 chars in argspec
  
  (F) The current implementation limits the length of literals in
  an argspec to 255 characters.  Make the literal shorter.
  
  =item Backslash reserved for literal string in argspec
  
  (F) The backslash character "\" is not allowed in argspec literals.
  It is reserved to permit quoting inside a literal in a later version.
  
  =item Unterminated literal string in argspec
  
  (F) The terminating quote character for a literal was not found.
  
  =item Bad argspec (%s)
  
  (F) Only identifier names, literals, spaces and commas
  are allowed in argspecs.
  
  =item Missing comma separator in argspec
  
  (F) Identifiers in an argspec must be separated with ",".
  
  =item Parsing of undecoded UTF-8 will give garbage when decoding entities
  
  (W) The first chunk parsed appears to contain undecoded UTF-8 and one
  or more argspecs that decode entities are used for the callback
  handlers.
  
  The result of decoding will be a mix of encoded and decoded characters
  for any entities that expand to characters with code above 127.  This
  is not a good thing.
  
  The recommended solution is to apply Encode::decode_utf8() on the data before
  feeding it to the $p->parse().  For $p->parse_file() pass a file that has been
  opened in ":utf8" mode.
  
  The alternative solution is to enable the C<utf8_mode> and not decode before
  passing strings to $p->parse().  The parser can process raw undecoded UTF-8
  sanely if the C<utf8_mode> is enabled, or if the "attr", "@attr" or "dtext"
  argspecs are avoided.
  
  =item Parsing string decoded with wrong endianness
  
  (W) The first character in the document is U+FFFE.  This is not a
  legal Unicode character but a byte swapped BOM.  The result of parsing
  will likely be garbage.
  
  =item Parsing of undecoded UTF-32
  
  (W) The parser found the Unicode UTF-32 BOM signature at the start
  of the document.  The result of parsing will likely be garbage.
  
  =item Parsing of undecoded UTF-16
  
  (W) The parser found the Unicode UTF-16 BOM signature at the start of
  the document.  The result of parsing will likely be garbage.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTML::Entities>, L<HTML::PullParser>, L<HTML::TokeParser>, L<HTML::HeadParser>,
  L<HTML::LinkExtor>, L<HTML::Form>
  
  L<HTML::TreeBuilder> (part of the I<HTML-Tree> distribution)
  
  L<http://www.w3.org/TR/html4/>
  
  More information about marked sections and processing instructions may
  be found at L<http://www.is-thought.co.uk/book/sgml-8.htm>.
  
  =head1 COPYRIGHT
  
   Copyright 1996-2016 Gisle Aas. All rights reserved.
   Copyright 1999-2000 Michael A. Chase.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTML_PARSER

$fatpacked{"darwin-2level/HTML/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_PULLPARSER';
  package HTML::PullParser;
  
  require HTML::Parser;
  @ISA=qw(HTML::Parser);
  $VERSION = "3.57";
  
  use strict;
  use Carp ();
  
  sub new
  {
      my($class, %cnf) = @_;
  
      # Construct argspecs for the various events
      my %argspec;
      for (qw(start end text declaration comment process default)) {
  	my $tmp = delete $cnf{$_};
  	next unless defined $tmp;
  	$argspec{$_} = $tmp;
      }
      Carp::croak("Info not collected for any events")
  	  unless %argspec;
  
      my $file = delete $cnf{file};
      my $doc  = delete $cnf{doc};
      Carp::croak("Can't parse from both 'doc' and 'file' at the same time")
  	  if defined($file) && defined($doc);
      Carp::croak("No 'doc' or 'file' given to parse from")
  	  unless defined($file) || defined($doc);
  
      # Create object
      $cnf{api_version} = 3;
      my $self = $class->SUPER::new(%cnf);
  
      my $accum = $self->{pullparser_accum} = [];
      while (my($event, $argspec) = each %argspec) {
  	$self->SUPER::handler($event => $accum, $argspec);
      }
  
      if (defined $doc) {
  	$self->{pullparser_str_ref} = ref($doc) ? $doc : \$doc;
  	$self->{pullparser_str_pos} = 0;
      }
      else {
  	if (!ref($file) && ref(\$file) ne "GLOB") {
  	    require IO::File;
  	    $file = IO::File->new($file, "r") || return;
  	}
  
  	$self->{pullparser_file} = $file;
      }
      $self;
  }
  
  
  sub handler
  {
      Carp::croak("Can't set handlers for HTML::PullParser");
  }
  
  
  sub get_token
  {
      my $self = shift;
      while (!@{$self->{pullparser_accum}} && !$self->{pullparser_eof}) {
  	if (my $f = $self->{pullparser_file}) {
  	    # must try to parse more from the file
  	    my $buf;
  	    if (read($f, $buf, 512)) {
  		$self->parse($buf);
  	    } else {
  		$self->eof;
  		$self->{pullparser_eof}++;
  		delete $self->{pullparser_file};
  	    }
  	}
  	elsif (my $sref = $self->{pullparser_str_ref}) {
  	    # must try to parse more from the scalar
  	    my $pos = $self->{pullparser_str_pos};
  	    my $chunk = substr($$sref, $pos, 512);
  	    $self->parse($chunk);
  	    $pos += length($chunk);
  	    if ($pos < length($$sref)) {
  		$self->{pullparser_str_pos} = $pos;
  	    }
  	    else {
  		$self->eof;
  		$self->{pullparser_eof}++;
  		delete $self->{pullparser_str_ref};
  		delete $self->{pullparser_str_pos};
  	    }
  	}
  	else {
  	    die;
  	}
      }
      shift @{$self->{pullparser_accum}};
  }
  
  
  sub unget_token
  {
      my $self = shift;
      unshift @{$self->{pullparser_accum}}, @_;
      $self;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTML::PullParser - Alternative HTML::Parser interface
  
  =head1 SYNOPSIS
  
   use HTML::PullParser;
  
   $p = HTML::PullParser->new(file => "index.html",
                              start => 'event, tagname, @attr',
                              end   => 'event, tagname',
                              ignore_elements => [qw(script style)],
                             ) || die "Can't open: $!";
   while (my $token = $p->get_token) {
       #...do something with $token
   }
  
  =head1 DESCRIPTION
  
  The HTML::PullParser is an alternative interface to the HTML::Parser class.
  It basically turns the HTML::Parser inside out.  You associate a file
  (or any IO::Handle object or string) with the parser at construction time and
  then repeatedly call $parser->get_token to obtain the tags and text
  found in the parsed document.
  
  The following methods are provided:
  
  =over 4
  
  =item $p = HTML::PullParser->new( file => $file, %options )
  
  =item $p = HTML::PullParser->new( doc => \$doc, %options )
  
  A C<HTML::PullParser> can be made to parse from either a file or a
  literal document based on whether the C<file> or C<doc> option is
  passed to the parser's constructor.
  
  The C<file> passed in can either be a file name or a file handle
  object.  If a file name is passed, and it can't be opened for reading,
  then the constructor will return an undefined value and $!  will tell
  you why it failed.  Otherwise the argument is taken to be some object
  that the C<HTML::PullParser> can read() from when it needs more data.
  The stream will be read() until EOF, but not closed.
  
  A C<doc> can be passed plain or as a reference
  to a scalar.  If a reference is passed then the value of this scalar
  should not be changed before all tokens have been extracted.
  
  Next the information to be returned for the different token types must
  be set up.  This is done by simply associating an argspec (as defined
  in L<HTML::Parser>) with the events you have an interest in.  For
  instance, if you want C<start> tokens to be reported as the string
  C<'S'> followed by the tagname and the attributes you might pass an
  C<start>-option like this:
  
     $p = HTML::PullParser->new(
            doc   => $document_to_parse,
            start => '"S", tagname, @attr',
            end   => '"E", tagname',
          );
  
  At last other C<HTML::Parser> options, like C<ignore_tags>, and
  C<unbroken_text>, can be passed in.  Note that you should not use the
  I<event>_h options to set up parser handlers.  That would confuse the
  inner logic of C<HTML::PullParser>.
  
  =item $token = $p->get_token
  
  This method will return the next I<token> found in the HTML document,
  or C<undef> at the end of the document.  The token is returned as an
  array reference.  The content of this array match the argspec set up
  during C<HTML::PullParser> construction.
  
  =item $p->unget_token( @tokens )
  
  If you find out you have read too many tokens you can push them back,
  so that they are returned again the next time $p->get_token is called.
  
  =back
  
  =head1 EXAMPLES
  
  The 'eg/hform' script shows how we might parse the form section of
  HTML::Documents using HTML::PullParser.
  
  =head1 SEE ALSO
  
  L<HTML::Parser>, L<HTML::TokeParser>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTML_PULLPARSER

$fatpacked{"darwin-2level/HTML/TokeParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_HTML_TOKEPARSER';
  package HTML::TokeParser;
  
  require HTML::PullParser;
  @ISA=qw(HTML::PullParser);
  $VERSION = "3.69";
  
  use strict;
  use Carp ();
  use HTML::Entities qw(decode_entities);
  use HTML::Tagset ();
  
  my %ARGS =
  (
   start       => "'S',tagname,attr,attrseq,text",
   end         => "'E',tagname,text",
   text        => "'T',text,is_cdata",
   process     => "'PI',token0,text",
   comment     => "'C',text",
   declaration => "'D',text",
  
   # options that default on
   unbroken_text => 1,
  );
  
  
  sub new
  {
      my $class = shift;
      my %cnf;
  
      if (@_ == 1) {
  	my $type = (ref($_[0]) eq "SCALAR") ? "doc" : "file";
  	%cnf = ($type => $_[0]);
      }
      else {
  	unshift @_, (ref($_[0]) eq "SCALAR") ? "doc" : "file" if(scalar(@_) % 2 == 1);
  	%cnf = @_;
      }
  
      my $textify = delete $cnf{textify} || {img => "alt", applet => "alt"};
  
      my $self = $class->SUPER::new(%ARGS, %cnf) || return undef;
  
      $self->{textify} = $textify;
      $self;
  }
  
  
  sub get_tag
  {
      my $self = shift;
      my $token;
      while (1) {
  	$token = $self->get_token || return undef;
  	my $type = shift @$token;
  	next unless $type eq "S" || $type eq "E";
  	substr($token->[0], 0, 0) = "/" if $type eq "E";
  	return $token unless @_;
  	for (@_) {
  	    return $token if $token->[0] eq $_;
  	}
      }
  }
  
  
  sub _textify {
      my($self, $token) = @_;
      my $tag = $token->[1];
      return undef unless exists $self->{textify}{$tag};
  
      my $alt = $self->{textify}{$tag};
      my $text;
      if (ref($alt)) {
  	$text = &$alt(@$token);
      } else {
  	$text = $token->[2]{$alt || "alt"};
  	$text = "[\U$tag]" unless defined $text;
      }
      return $text;
  }
  
  
  sub get_text
  {
      my $self = shift;
      my @text;
      while (my $token = $self->get_token) {
  	my $type = $token->[0];
  	if ($type eq "T") {
  	    my $text = $token->[1];
  	    decode_entities($text) unless $token->[2];
  	    push(@text, $text);
  	} elsif ($type =~ /^[SE]$/) {
  	    my $tag = $token->[1];
  	    if ($type eq "S") {
  		if (defined(my $text = _textify($self, $token))) {
  		    push(@text, $text);
  		    next;
  		}
  	    } else {
  		$tag = "/$tag";
  	    }
  	    if (!@_ || grep $_ eq $tag, @_) {
  		 $self->unget_token($token);
  		 last;
  	    }
  	    push(@text, " ")
  		if $tag eq "br" || !$HTML::Tagset::isPhraseMarkup{$token->[1]};
  	}
      }
      join("", @text);
  }
  
  
  sub get_trimmed_text
  {
      my $self = shift;
      my $text = $self->get_text(@_);
      $text =~ s/^\s+//; $text =~ s/\s+$//; $text =~ s/\s+/ /g;
      $text;
  }
  
  sub get_phrase {
      my $self = shift;
      my @text;
      while (my $token = $self->get_token) {
  	my $type = $token->[0];
  	if ($type eq "T") {
  	    my $text = $token->[1];
  	    decode_entities($text) unless $token->[2];
  	    push(@text, $text);
  	} elsif ($type =~ /^[SE]$/) {
  	    my $tag = $token->[1];
  	    if ($type eq "S") {
  		if (defined(my $text = _textify($self, $token))) {
  		    push(@text, $text);
  		    next;
  		}
  	    }
  	    if (!$HTML::Tagset::isPhraseMarkup{$tag}) {
  		$self->unget_token($token);
  		last;
  	    }
  	    push(@text, " ") if $tag eq "br";
  	}
      }
      my $text = join("", @text);
      $text =~ s/^\s+//; $text =~ s/\s+$//; $text =~ s/\s+/ /g;
      $text;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTML::TokeParser - Alternative HTML::Parser interface
  
  =head1 SYNOPSIS
  
   require HTML::TokeParser;
   $p = HTML::TokeParser->new("index.html") ||
        die "Can't open: $!";
   $p->empty_element_tags(1);  # configure its behaviour
  
   while (my $token = $p->get_token) {
       #...
   }
  
  =head1 DESCRIPTION
  
  The C<HTML::TokeParser> is an alternative interface to the
  C<HTML::Parser> class.  It is an C<HTML::PullParser> subclass with a
  predeclared set of token types.  If you wish the tokens to be reported
  differently you probably want to use the C<HTML::PullParser> directly.
  
  The following methods are available:
  
  =over 4
  
  =item $p = HTML::TokeParser->new( $filename, %opt );
  
  =item $p = HTML::TokeParser->new( $filehandle, %opt );
  
  =item $p = HTML::TokeParser->new( \$document, %opt );
  
  The object constructor argument is either a file name, a file handle
  object, or the complete document to be parsed.  Extra options can be
  provided as key/value pairs and are processed as documented by the base
  classes.
  
  If the argument is a plain scalar, then it is taken as the name of a
  file to be opened and parsed.  If the file can't be opened for
  reading, then the constructor will return C<undef> and $! will tell
  you why it failed.
  
  If the argument is a reference to a plain scalar, then this scalar is
  taken to be the literal document to parse.  The value of this
  scalar should not be changed before all tokens have been extracted.
  
  Otherwise the argument is taken to be some object that the
  C<HTML::TokeParser> can read() from when it needs more data.  Typically
  it will be a filehandle of some kind.  The stream will be read() until
  EOF, but not closed.
  
  A newly constructed C<HTML::TokeParser> differ from its base classes
  by having the C<unbroken_text> attribute enabled by default. See
  L<HTML::Parser> for a description of this and other attributes that
  influence how the document is parsed. It is often a good idea to enable
  C<empty_element_tags> behaviour.
  
  Note that the parsing result will likely not be valid if raw undecoded
  UTF-8 is used as a source.  When parsing UTF-8 encoded files turn
  on UTF-8 decoding:
  
     open(my $fh, "<:utf8", "index.html") || die "Can't open 'index.html': $!";
     my $p = HTML::TokeParser->new( $fh );
     # ...
  
  If a $filename is passed to the constructor the file will be opened in
  raw mode and the parsing result will only be valid if its content is
  Latin-1 or pure ASCII.
  
  If parsing from an UTF-8 encoded string buffer decode it first:
  
     utf8::decode($document);
     my $p = HTML::TokeParser->new( \$document );
     # ...
  
  =item $p->get_token
  
  This method will return the next I<token> found in the HTML document,
  or C<undef> at the end of the document.  The token is returned as an
  array reference.  The first element of the array will be a string
  denoting the type of this token: "S" for start tag, "E" for end tag,
  "T" for text, "C" for comment, "D" for declaration, and "PI" for
  process instructions.  The rest of the token array depend on the type
  like this:
  
    ["S",  $tag, $attr, $attrseq, $text]
    ["E",  $tag, $text]
    ["T",  $text, $is_data]
    ["C",  $text]
    ["D",  $text]
    ["PI", $token0, $text]
  
  where $attr is a hash reference, $attrseq is an array reference and
  the rest are plain scalars.  The L<HTML::Parser/Argspec> explains the
  details.
  
  =item $p->unget_token( @tokens )
  
  If you find you have read too many tokens you can push them back,
  so that they are returned the next time $p->get_token is called.
  
  =item $p->get_tag
  
  =item $p->get_tag( @tags )
  
  This method returns the next start or end tag (skipping any other
  tokens), or C<undef> if there are no more tags in the document.  If
  one or more arguments are given, then we skip tokens until one of the
  specified tag types is found.  For example:
  
     $p->get_tag("font", "/font");
  
  will find the next start or end tag for a font-element.
  
  The tag information is returned as an array reference in the same form
  as for $p->get_token above, but the type code (first element) is
  missing. A start tag will be returned like this:
  
    [$tag, $attr, $attrseq, $text]
  
  The tagname of end tags are prefixed with "/", i.e. end tag is
  returned like this:
  
    ["/$tag", $text]
  
  =item $p->get_text
  
  =item $p->get_text( @endtags )
  
  This method returns all text found at the current position. It will
  return a zero length string if the next token is not text. Any
  entities will be converted to their corresponding character.
  
  If one or more arguments are given, then we return all text occurring
  before the first of the specified tags found. For example:
  
     $p->get_text("p", "br");
  
  will return the text up to either a paragraph of linebreak element.
  
  The text might span tags that should be I<textified>.  This is
  controlled by the $p->{textify} attribute, which is a hash that
  defines how certain tags can be treated as text.  If the name of a
  start tag matches a key in this hash then this tag is converted to
  text.  The hash value is used to specify which tag attribute to obtain
  the text from.  If this tag attribute is missing, then the upper case
  name of the tag enclosed in brackets is returned, e.g. "[IMG]".  The
  hash value can also be a subroutine reference.  In this case the
  routine is called with the start tag token content as its argument and
  the return value is treated as the text.
  
  The default $p->{textify} value is:
  
    {img => "alt", applet => "alt"}
  
  This means that <IMG> and <APPLET> tags are treated as text, and that
  the text to substitute can be found in the ALT attribute.
  
  =item $p->get_trimmed_text
  
  =item $p->get_trimmed_text( @endtags )
  
  Same as $p->get_text above, but will collapse any sequences of white
  space to a single space character.  Leading and trailing white space is
  removed.
  
  =item $p->get_phrase
  
  This will return all text found at the current position ignoring any
  phrasal-level tags.  Text is extracted until the first non
  phrasal-level tag.  Textification of tags is the same as for
  get_text().  This method will collapse white space in the same way as
  get_trimmed_text() does.
  
  The definition of <i>phrasal-level tags</i> is obtained from the
  HTML::Tagset module.
  
  =back
  
  =head1 EXAMPLES
  
  This example extracts all links from a document.  It will print one
  line for each link, containing the URL and the textual description
  between the <A>...</A> tags:
  
    use HTML::TokeParser;
    $p = HTML::TokeParser->new(shift||"index.html");
  
    while (my $token = $p->get_tag("a")) {
        my $url = $token->[1]{href} || "-";
        my $text = $p->get_trimmed_text("/a");
        print "$url\t$text\n";
    }
  
  This example extract the <TITLE> from the document:
  
    use HTML::TokeParser;
    $p = HTML::TokeParser->new(shift||"index.html");
    if ($p->get_tag("title")) {
        my $title = $p->get_trimmed_text;
        print "Title: $title\n";
    }
  
  =head1 SEE ALSO
  
  L<HTML::PullParser>, L<HTML::Parser>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_HTML_TOKEPARSER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#
# This file is part of Pod-Markdown
#
# This software is copyright (c) 2011 by Randy Stauner.
#
# This is free software; you can redistribute it and/or modify it under
# the same terms as the Perl 5 programming language system itself.
#
use 5.008;
use strict;
use warnings;
# PODNAME: pod2markdown
# ABSTRACT: Convert POD text to Markdown

use Pod::Markdown;
use Getopt::Long;
use Pod::Usage;

my %opts = (
  # Since we're writing to a file the module needs to know that it has to do
  # some kind of encoding.  Default to UTF-8.
  output_encoding => 'UTF-8',
);

GetOptions(\%opts, qw(
  help|h
  html_encode_chars|html-encode-chars=s
  match_encoding|match-encoding|m
  output_encoding|output-encoding|e=s
  utf8|utf-8|u
)) or pod2usage(2);
pod2usage(1) if $opts{help};

# TODO: Test PERL_UNICODE and/or layers on the handle?

# Expand alias (-u is an alias for -e UTF-8).
$opts{output_encoding} = 'UTF-8' if delete $opts{utf8};

# TODO: Pod::Simple::parse_from_file(@ARGV[0,1]);

my $in_fh  = get_handle(shift(@ARGV), '<', \*STDIN);
my $out_fh = get_handle(shift(@ARGV), '>', \*STDOUT);

# Undo any PERL_UNICODE effects.
# Pod::Simple expects to receive bytes, and we're going to return bytes.
binmode($_, ':bytes') for ($in_fh, $out_fh);

convert($in_fh, $out_fh);

sub convert {
    my ($in_file, $out_file) = @_;
    my $parser = Pod::Markdown->new(%opts);
    $parser->output_fh($out_file);
    $parser->parse_file($in_file);
}

sub get_handle {
  my ($path, $op, $default) = @_;
  (!defined($path) || $path eq '-') ? $default : do {
    open(my $fh, $op, $path)
      or die "Failed to open '$path': $!\n";
    $fh;
  };
}

__END__

=pod

=encoding UTF-8

=for :stopwords Marcel Gruenauer Victor Moral Ryan C. Thompson <rct at thompsonclan d0t
org> Aristotle Pagaltzis Randy Stauner ACKNOWLEDGEMENTS html

=head1 NAME

pod2markdown - Convert POD text to Markdown

=head1 VERSION

version 3.005

=head1 SYNOPSIS

    # parse STDIN, print to STDOUT
    $ pod2markdown < POD_File > Markdown_File

    # parse file, print to STDOUT
    $ pod2markdown input.pod

    # parse file, print to file
    $ pod2markdown input.pod output.mkdn

    # parse STDIN, print to file
    $ pod2markdown - output.mkdn

=head1 DESCRIPTION

This program uses L<Pod::Markdown> to convert POD into Markdown sources.

UTF-8 is the default output encoding
if no encoding options are specified (see L</OPTIONS>).

It accepts two optional arguments:

=over 4

=item *

input pod file (defaults to C<STDIN>)

=item *

output markdown file (defaults to C<STDOUT>)

=back

=head1 OPTIONS

=over

=item --html-encode-chars

A list of characters to encode as HTML entities.
Pass a regexp character class, or C<1> to mean control chars, high-bit chars, and C<< <&>"' >>.

See L<Pod::Markdown/html_encode_chars> for more information.

=item --match-encoding (-m)

Use the same C<< =encoding >> as the input pod for the output file.

=item --output-encoding (-e)

Specify the encoding for the output file.

=item --utf8 (-u)

Alias for C<< -e UTF-8 >>.

=back

=head1 SEE ALSO

This program is strongly based on C<pod2mdwn> from L<Module::Build::IkiWiki>.

=head1 AUTHORS

=over 4

=item *

Marcel Gruenauer <marcel@cpan.org>

=item *

Victor Moral <victor@taquiones.net>

=item *

Ryan C. Thompson <rct at thompsonclan d0t org>

=item *

Aristotle Pagaltzis <pagaltzis@gmx.de>

=item *

Randy Stauner <rwstauner@cpan.org>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2011 by Randy Stauner.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
