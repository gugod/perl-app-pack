#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Pod/Markdown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MARKDOWN';
  # vim: set ts=2 sts=2 sw=2 expandtab smarttab:
  #
  # This file is part of Pod-Markdown
  #
  # This software is copyright (c) 2011 by Randy Stauner.
  #
  # This is free software; you can redistribute it and/or modify it under
  # the same terms as the Perl 5 programming language system itself.
  #
  use 5.008;
  use strict;
  use warnings;
  
  package Pod::Markdown;
  # git description: v3.004-0-g69a7b15
  
  our $AUTHORITY = 'cpan:RWSTAUNER';
  # ABSTRACT: Convert POD to Markdown
  $Pod::Markdown::VERSION = '3.005';
  use Pod::Simple 3.27 (); # detected_encoding and keep_encoding bug fix
  use parent qw(Pod::Simple::Methody);
  use Encode ();
  
  our %URL_PREFIXES = (
    sco      => 'http://search.cpan.org/perldoc?',
    metacpan => 'https://metacpan.org/pod/',
    man      => 'http://man.he.net/man',
  );
  $URL_PREFIXES{perldoc} = $URL_PREFIXES{metacpan};
  
  #{
    our $HAS_HTML_ENTITIES;
  
    # Stolen from Pod::Simple::XHTML 3.28. {{{
  
    BEGIN {
      $HAS_HTML_ENTITIES = eval "require HTML::Entities; 1";
    }
  
    my %entities = (
      q{>} => 'gt',
      q{<} => 'lt',
      q{'} => '#39',
      q{"} => 'quot',
      q{&} => 'amp',
    );
  
    sub encode_entities {
      my $self = shift;
      my $ents = $self->html_encode_chars;
      return HTML::Entities::encode_entities( $_[0], $ents ) if $HAS_HTML_ENTITIES;
      if (defined $ents) {
          $ents =~ s,(?<!\\)([]/]),\\$1,g;
          $ents =~ s,(?<!\\)\\\z,\\\\,;
      } else {
          $ents = join '', keys %entities;
      }
      my $str = $_[0];
      $str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;
      return $str;
    }
  
    # }}}
  
    # Add a few very common ones for consistency and readability
    # (in case HTML::Entities isn't available).
    %entities = (
      # Pod::Markdown has always required 5.8 so unicode_to_native will be available.
      chr(utf8::unicode_to_native(0xA0)) => 'nbsp',
      chr(utf8::unicode_to_native(0xA9)) => 'copy',
      %entities
    );
  
    sub __entity_encode_ord_he {
      my $chr = chr $_[0];
      # Skip the encode_entities() logic and go straight for the substitution
      # since we already have the char we know we want replaced.
      # Both the hash and the function are documented as exportable (so should be reliable).
      return $HTML::Entities::char2entity{ $chr } || HTML::Entities::num_entity( $chr );
    }
    sub __entity_encode_ord_basic {
      return '&' . ($entities{chr $_[0]} || sprintf '#x%X', $_[0]) . ';';
    }
  
    # From HTML::Entities 3.69
    my $DEFAULT_ENTITY_CHARS = '^\n\r\t !\#\$%\(-;=?-~';
  
  #}
  
  # Use hash for simple "exists" check in `new` (much more accurate than `->can`).
  my %attributes = map { ($_ => 1) }
    qw(
      html_encode_chars
      match_encoding
      output_encoding
      man_url_prefix
      perldoc_url_prefix
      perldoc_fragment_format
      markdown_fragment_format
      include_meta_tags
    );
  
  
  sub new {
    my $class = shift;
    my %args = @_;
  
    my $self = $class->SUPER::new();
    $self->preserve_whitespace(1);
    $self->nbsp_for_S(1);
    $self->accept_targets(qw( markdown html ));
  
    while( my ($attr, $val) = each %args ){
      # NOTE: Checking exists on a private var means we don't allow Pod::Simple
      # attributes to be set this way.  It's not very consistent, but I think
      # I'm ok with that for now since there probably aren't many Pod::Simple attributes
      # being changed besides `output_*` which feel like API rather than attributes.
      # We'll see.
      # This is currently backward-compatible as we previously just put the attribute
      # into the private stash so anything unknown was silently ignored.
      # We could open this up to `$self->can($attr)` in the future if that seems better
      # but it tricked me when I was testing a misspelled attribute name
      # which also happened to be a Pod::Simple method.
  
      exists $attributes{ $attr } or
        # Provide a more descriptive message than "Can't locate object method".
        warn("Unknown argument to ${class}->new(): '$attr'"), next;
  
      # Call setter.
      $self->$attr($val);
    }
  
      # TODO: move this logic to setter (and call _prepare_fragment_format).
      for my $type ( qw( perldoc man ) ){
          my $attr  = $type . '_url_prefix';
          # Use provided argument or default alias.
          my $url = $self->$attr || $type;
          # Expand alias if defined (otherwise use url as is).
          $self->$attr( $URL_PREFIXES{ $url } || $url );
      }
  
      $self->_prepare_fragment_formats;
  
    return $self;
  }
  
  ## Attribute accessors ##
  
  
  sub html_encode_chars {
    my $self  = shift;
    my $stash = $self->_private;
  
    # Setter.
    if( @_ ){
      # If false ('', 0, undef), disable.
      if( !$_[0] ){
        delete $stash->{html_encode_chars};
        $stash->{encode_amp}  = 1;
        $stash->{encode_lt}   = 1;
      }
      else {
        # Special case boolean '1' to mean "all".
        # If we have HTML::Entities, undef will use the default.
        # Without it, we need to specify so that we use the same list (for consistency).
        $stash->{html_encode_chars} = $_[0] eq '1' ? ($HAS_HTML_ENTITIES ? undef : $DEFAULT_ENTITY_CHARS) : $_[0];
  
        # If [char] doesn't get encoded, we need to do it ourselves.
        $stash->{encode_amp}  = ($self->encode_entities('&') eq '&');
        $stash->{encode_lt}   = ($self->encode_entities('<') eq '<');
      }
      return;
    }
  
    # Getter.
    return $stash->{html_encode_chars};
  }
  
  
  # I prefer ro-accessors (immutability!) but it can be confusing
  # to not support the same API as other Pod::Simple classes.
  
  # NOTE: Pod::Simple::_accessorize is not a documented public API.
  # Skip any that have already been defined.
  __PACKAGE__->_accessorize(grep { !__PACKAGE__->can($_) } keys %attributes);
  
  sub _prepare_fragment_formats {
    my ($self) = @_;
  
    foreach my $attr ( keys %attributes ){
      next unless $attr =~ /^(\w+)_fragment_format/;
      my $type = $1;
      my $format = $self->$attr;
  
      # If one was provided.
      if( $format ){
        # If the attribute is a coderef just use it.
        next if ref($format) eq 'CODE';
      }
      # Else determine a default.
      else {
        if( $type eq 'perldoc' ){
          # Choose a default that matches the destination url.
          my $target = $self->perldoc_url_prefix;
          foreach my $alias ( qw( metacpan sco ) ){
            if( $target eq $URL_PREFIXES{ $alias } ){
              $format = $alias;
            }
          }
          # This seems like a reasonable fallback.
          $format ||= 'pod_simple_xhtml';
        }
        else {
          $format = $type;
        }
      }
  
      # The short name should become a method name with the prefix prepended.
      my $prefix = 'format_fragment_';
      $format =~ s/^$prefix//;
      die "Unknown fragment format '$format'"
        unless $self->can($prefix . $format);
  
      # Save it.
      $self->$attr($format);
    }
  
    return;
  }
  
  ## Backward compatible API ##
  
  # For backward compatibility (previously based on Pod::Parser):
  # While Pod::Simple provides a parse_from_file() method
  # it's primarily for Pod::Parser compatibility.
  # When called without an output handle it will print to STDOUT
  # but the old Pod::Markdown never printed to a handle
  # so we don't want to start now.
  sub parse_from_file {
    my ($self, $file) = @_;
  
    # TODO: Check that all dependent cpan modules use the Pod::Simple API
    # then add a deprecation warning here to avoid confusion.
  
    $self->output_string(\($self->{_as_markdown_}));
    $self->parse_file($file);
  }
  
  # Likewise, though Pod::Simple doesn't define this method at all.
  sub parse_from_filehandle { shift->parse_from_file(@_) }
  
  
  ## Document state ##
  
  sub _private {
    my ($self) = @_;
    $self->{_Pod_Markdown_} ||= {
      indent      => 0,
      stacks      => [],
      states      => [{}],
      link        => [],
      encode_amp  => 1,
      encode_lt   => 1,
    };
  }
  
  sub _increase_indent {
    ++$_[0]->_private->{indent} >= 1
      or die 'Invalid state: indent < 0';
  }
  sub _decrease_indent {
    --$_[0]->_private->{indent} >= 0
      or die 'Invalid state: indent < 0';
  }
  
  sub _new_stack {
    push @{ $_[0]->_private->{stacks} }, [];
    push @{ $_[0]->_private->{states} }, {};
  }
  
  sub _last_string {
    $_[0]->_private->{stacks}->[-1][-1];
  }
  
  sub _pop_stack_text {
    $_[0]->_private->{last_state} = pop @{ $_[0]->_private->{states} };
    join '', @{ pop @{ $_[0]->_private->{stacks} } };
  }
  
  sub _stack_state {
    $_[0]->_private->{states}->[-1];
  }
  
  sub _save {
    my ($self, $text) = @_;
    push @{ $self->_private->{stacks}->[-1] }, $text;
    # return $text; # DEBUG
  }
  
  sub _save_line {
    my ($self, $text) = @_;
  
    $text = $self->_process_escapes($text);
  
    $self->_save($text . $/);
  }
  
  # For paragraphs, etc.
  sub _save_block {
    my ($self, $text) = @_;
  
    $self->_stack_state->{blocks}++;
  
    $self->_save_line($self->_indent($text) . $/);
  }
  
  ## Formatting ##
  
  sub _chomp_all {
    my ($self, $text) = @_;
    1 while chomp $text;
    return $text;
  }
  
  sub _indent {
    my ($self, $text) = @_;
    my $level = $self->_private->{indent};
  
    if( $level ){
      my $indent = ' ' x ($level * 4);
  
      # Capture text on the line so that we don't indent blank lines (/^\x20{4}$/).
      $text =~ s/^(.+)/$indent$1/mg;
    }
  
    return $text;
  }
  
  # as_markdown() exists solely for backward compatibility
  # and requires having called parse_from_file() to be useful.
  
  
  sub as_markdown {
      my ($parser, %args) = @_;
      my @header;
      # Don't add meta tags again if we've already done it.
      if( $args{with_meta} && !$parser->include_meta_tags ){
          @header = $parser->_build_markdown_head;
      }
      return join("\n" x 2, @header, $parser->{_as_markdown_});
  }
  
  sub _build_markdown_head {
      my $parser    = shift;
      my $data      = $parser->_private;
      return join "\n",
          map  { qq![[meta \l$_="$data->{$_}"]]! }
          grep { defined $data->{$_} }
          qw( Title Author );
  }
  
  ## Escaping ##
  
  # http://daringfireball.net/projects/markdown/syntax#backslash
  # Markdown provides backslash escapes for the following characters:
  #
  # \   backslash
  # `   backtick
  # *   asterisk
  # _   underscore
  # {}  curly braces
  # []  square brackets
  # ()  parentheses
  # #   hash mark
  # +   plus sign
  # -   minus sign (hyphen)
  # .   dot
  # !   exclamation mark
  
  # However some of those only need to be escaped in certain places:
  # * Backslashes *do* need to be escaped or they may be swallowed by markdown.
  # * Word-surrounding characters (/[`*_]/) *do* need to be escaped mid-word
  # because the markdown spec explicitly allows mid-word em*pha*sis.
  # * I don't actually see anything that curly braces are used for.
  # * Escaping square brackets is enough to avoid accidentally
  # creating links and images (so we don't need to escape plain parentheses
  # or exclamation points as that would generate a lot of unnecesary noise).
  # Parentheses will be escaped in urls (&end_L) to avoid premature termination.
  # * We don't need a backslash for every hash mark or every hyphen found mid-word,
  # just the ones that start a line (likewise for plus and dot).
  # (Those will all be handled by _escape_paragraph_markdown).
  
  
  # Backslash escape markdown characters to avoid having them interpreted.
  sub _escape_inline_markdown {
    local $_ = $_[1];
  
  # s/([\\`*_{}\[\]()#+-.!])/\\$1/g; # See comments above.
    s/([\\`*_\[\]])/\\$1/g;
  
    return $_;
  }
  
  # Escape markdown characters that would be interpreted
  # at the start of a line.
  sub _escape_paragraph_markdown {
      local $_ = $_[1];
  
      # Escape headings, horizontal rules, (unordered) lists, and blockquotes.
      s/^([-+#>])/\\$1/mg;
  
      # Markdown doesn't support backslash escapes for equal signs
      # even though they can be used to underline a header.
      # So use html to escape them to avoid having them interpreted.
      s/^([=])/sprintf '&#x%x;', ord($1)/mge;
  
      # Escape the dots that would wrongfully create numbered lists.
      s/^( (?:>\s+)? \d+ ) (\.\x20)/$1\\$2/xgm;
  
      return $_;
  }
  
  
  # Additionally Markdown allows inline html so we need to escape things that look like it.
  # While _some_ Markdown processors handle backslash-escaped html,
  # [Daring Fireball](http://daringfireball.net/projects/markdown/syntax) states distinctly:
  # > In HTML, there are two characters that demand special treatment: < and &...
  # > If you want to use them as literal characters, you must escape them as entities, e.g. &lt;, and &amp;.
  
  # It goes on to say:
  # > Markdown allows you to use these characters naturally,
  # > taking care of all the necessary escaping for you.
  # > If you use an ampersand as part of an HTML entity,
  # > it remains unchanged; otherwise it will be translated into &amp;.
  # > Similarly, because Markdown supports inline HTML,
  # > if you use angle brackets as delimiters for HTML tags, Markdown will treat them as such.
  
  # In order to only encode the occurrences that require it (something that
  # could be interpreted as an entity) we escape them all so that we can do the
  # suffix test later after the string is complete (since we don't know what
  # strings might come after this one).
  
  my %_escape =
    map {
      my ($k, $v) = split /:/;
      # Put the "code" marker before the char instead of after so that it doesn't
      # get confused as the $2 (which is what requires us to entity-encode it).
      # ( "XsX", "XcsX", "X(c?)sX" )
      my ($s, $code, $re) = map { "\0$_$v\0" } '', map { ($_, '('.$_.'?)') } 'c';
  
      (
        $k         => $s,
        $k.'_code' => $code,
        $k.'_re'   => qr/$re/,
      )
    }
      qw( amp:& lt:< );
  
  # Make the values of this private var available to the tests.
  sub __escape_sequences { %_escape }
  
  
  # HTML-entity encode any characters configured by the user.
  # If that doesn't include [&<] then we escape those chars so we can decide
  # later if we will entity-encode them or put them back verbatim.
  sub _encode_or_escape_entities {
    my $self  = $_[0];
    my $stash = $self->_private;
    local $_  = $_[1];
  
    if( $stash->{encode_amp} ){
      if( exists($stash->{html_encode_chars}) ){
        # Escape all amps for later processing.
        # Pass intermediate strings to entity encoder so that it doesn't
        # process any of the characters of our escape sequences.
        # Use -1 to get "as many fields as possible" so that we keep leading and
        # trailing (possibly empty) fields.
        $_ = join $_escape{amp}, map { $self->encode_entities($_) } split /&/, $_, -1;
      }
      else {
        s/&/$_escape{amp}/g;
      }
    }
    elsif( exists($stash->{html_encode_chars}) ){
      $_ = $self->encode_entities($_);
    }
  
    s/</$_escape{lt}/g
      if $stash->{encode_lt};
  
    return $_;
  }
  
  # From Markdown.pl version 1.0.1 line 1172 (_DoAutoLinks).
  my $EMAIL_MARKER = qr{
  #   <                  # Opening token is in parent regexp.
          (?:mailto:)?
      (
        [-.\w]+
        \@
        [-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+
      )
      >
  }x;
  
  # Process any escapes we put in the text earlier,
  # now that the text is complete (end of a block).
  sub _process_escapes {
    my $self  = $_[0];
    my $stash = $self->_private;
    local $_  = $_[1];
  
    # The patterns below are taken from Markdown.pl 1.0.1 _EncodeAmpsAndAngles().
    # In this case we only want to encode the ones that Markdown won't.
    # This is overkill but produces nicer looking text (less escaped entities).
    # If it proves insufficent then we'll just encode them all.
  
    # $1: If the escape was in a code sequence, simply replace the original.
    # $2: If the unescaped value would be followed by characters
    #     that could be interpreted as html, entity-encode it.
    # else: The character is safe to leave bare.
  
    # Neither currently allows $2 to contain '0' so bool tests are sufficient.
  
    if( $stash->{encode_amp} ){
      # Encode & if succeeded by chars that look like an html entity.
      s,$_escape{amp_re}((?:#?[xX]?(?:[0-9a-fA-F]+|\w+);)?),
        $1 ? '&'.$2 : $2 ? '&amp;'.$2 : '&',egos;
    }
  
    if( $stash->{encode_lt} ){
      # Encode < if succeeded by chars that look like an html tag.
      # Leave email addresses (<foo@bar.com>) for Markdown to process.
      s,$_escape{lt_re}((?=$EMAIL_MARKER)|(?:[a-z/?\$!])?),
        $1 ? '<'.$2 : $2 ?  '&lt;'.$2 : '<',egos;
    }
  
    return $_;
  }
  
  
  ## Parsing ##
  
  sub handle_text {
    my $self  = $_[0];
    my $stash = $self->_private;
    local $_  = $_[1];
  
    # Unless we're in a code span, verbatim block, or formatted region.
    unless( $stash->{no_escape} ){
  
      # We could, in theory, alter what gets escaped according to context
      # (for example, escape square brackets (but not parens) inside link text).
      # The markdown produced might look slightly nicer but either way you're
      # at the whim of the markdown processor to interpret things correctly.
      # For now just escape everything.
  
      # Don't let literal characters be interpreted as markdown.
      $_ = $self->_escape_inline_markdown($_);
  
      # Entity-encode (or escape for later processing) necessary/desired chars.
      $_ = $self->_encode_or_escape_entities($_);
  
    }
    # If this _is_ a code section, do limited/specific handling.
    else {
      # Always escaping these chars ensures that we won't mangle the text
      # in the unlikely event that a sequence matching our escape occurred in the
      # input stream (since we're going to escape it and then unescape it).
      s/&/$_escape{amp_code}/gos if $stash->{encode_amp};
      s/</$_escape{lt_code}/gos  if $stash->{encode_lt};
    }
  
    $self->_save($_);
  }
  
  sub start_Document {
    my ($self) = @_;
    $self->_new_stack;
  }
  
  sub   end_Document {
    my ($self) = @_;
    $self->_check_search_header;
    my $end = pop @{ $self->_private->{stacks} };
  
    @{ $self->_private->{stacks} } == 0
      or die 'Document ended with stacks remaining';
  
    my @doc = $self->_chomp_all(join('', @$end)) . $/;
  
    if( $self->include_meta_tags ){
      unshift @doc, $self->_build_markdown_head, ($/ x 2);
    }
  
    if( my $encoding = $self->_get_output_encoding ){
      # Do the check outside the loop(s) for efficiency.
      my $ents = $HAS_HTML_ENTITIES ? \&__entity_encode_ord_he : \&__entity_encode_ord_basic;
      # Iterate indices to avoid copying large strings.
      for my $i ( 0 .. $#doc ){
        print { $self->{output_fh} } Encode::encode($encoding, $doc[$i], $ents);
      }
    }
    else {
      print { $self->{output_fh} } @doc;
    }
  }
  
  sub _get_output_encoding {
    my ($self) = @_;
  
    # If 'match_encoding' is set we need to return an encoding.
    # If pod has no =encoding, Pod::Simple will guess if it sees a high-bit char.
    # If there are no high-bit chars, encoding is undef.
    # Use detected_encoding() rather than encoding() because if Pod::Simple
    # can't use whatever encoding was specified, we probably can't either.
    # Fallback to 'o_e' if no match is found.  This gives the user the choice,
    # since otherwise there would be no reason to specify 'o_e' *and* 'm_e'.
    # Fallback to UTF-8 since it is a reasonable default these days.
  
    return $self->detected_encoding || $self->output_encoding || 'UTF-8'
      if $self->match_encoding;
  
    # If output encoding wasn't specified, return false.
    return $self->output_encoding;
  }
  
  ## Blocks ##
  
  sub start_Verbatim {
    my ($self) = @_;
    $self->_new_stack;
    $self->_private->{no_escape} = 1;
  }
  
  sub end_Verbatim {
    my ($self) = @_;
  
    my $text = $self->_pop_stack_text;
  
    $text = $self->_indent_verbatim($text);
  
    $self->_private->{no_escape} = 0;
  
    # Verbatim blocks do not generate a separate "Para" event.
    $self->_save_block($text);
  }
  
  sub _indent_verbatim {
    my ($self, $paragraph) = @_;
  
      # NOTE: Pod::Simple expands the tabs for us (as suggested by perlpodspec).
      # Pod::Simple also has a 'strip_verbatim_indent' attribute
      # but it doesn't sound like it gains us anything over this method.
  
      # POD verbatim can start with any number of spaces (or tabs)
      # markdown should be 4 spaces (or a tab)
      # so indent any paragraphs so that all lines start with at least 4 spaces
      my @lines = split /\n/, $paragraph;
      my $indent = ' ' x 4;
      foreach my $line ( @lines ){
          next unless $line =~ m/^( +)/;
          # find the smallest indentation
          $indent = $1 if length($1) < length($indent);
      }
      if( (my $smallest = length($indent)) < 4 ){
          # invert to get what needs to be prepended
          $indent = ' ' x (4 - $smallest);
  
          # Prepend indent to each line.
          # We could check /\S/ to only indent non-blank lines,
          # but it's backward compatible to respect the whitespace.
          # Additionally, both pod and markdown say they ignore blank lines
          # so it shouldn't hurt to leave them in.
          $paragraph = join "\n", map { length($_) ? $indent . $_ : '' } @lines;
      }
  
    return $paragraph;
  }
  
  sub start_Para {
    $_[0]->_new_stack;
  }
  
  sub   end_Para {
    my ($self) = @_;
    my $text = $self->_pop_stack_text;
  
    $text = $self->_escape_paragraph_markdown($text);
  
    $self->_save_block($text);
  }
  
  
  ## Headings ##
  
  sub start_head1 { $_[0]->_start_head(1) }
  sub   end_head1 { $_[0]->_end_head(1) }
  sub start_head2 { $_[0]->_start_head(2) }
  sub   end_head2 { $_[0]->_end_head(2) }
  sub start_head3 { $_[0]->_start_head(3) }
  sub   end_head3 { $_[0]->_end_head(3) }
  sub start_head4 { $_[0]->_start_head(4) }
  sub   end_head4 { $_[0]->_end_head(4) }
  
  sub _check_search_header {
    my ($self) = @_;
    # Save the text since the last heading if we want it for metadata.
    if( my $last = $self->_private->{search_header} ){
      for( $self->_private->{$last} = $self->_last_string ){
        s/\A\s+//;
        s/\s+\z//;
      }
    }
  }
  sub _start_head {
    my ($self) = @_;
    $self->_check_search_header;
    $self->_new_stack;
  }
  
  sub   _end_head {
    my ($self, $num) = @_;
    my $h = '#' x $num;
  
    my $text = $self->_pop_stack_text;
    $self->_private->{search_header} =
        $text =~ /NAME/   ? 'Title'
      : $text =~ /AUTHOR/ ? 'Author'
      : undef;
  
    # TODO: option for $h suffix
    # TODO: put a name="" if $self->{embed_anchor_tags}; ?
    # https://rt.cpan.org/Ticket/Display.html?id=57776
    $self->_save_block(join(' ', $h, $text));
  }
  
  ## Lists ##
  
  # With Pod::Simple->parse_empty_lists(1) there could be an over_empty event,
  # but what would you do with that?
  
  sub _start_list {
    my ($self) = @_;
    $self->_new_stack;
  
    # Nest again b/c start_item will pop this to look for preceding content.
    $self->_increase_indent;
    $self->_new_stack;
  }
  
  sub   _end_list {
    my ($self) = @_;
    $self->_handle_between_item_content;
  
    # Finish the list.
  
    # All the child elements should be blocks,
    # but don't end with a double newline.
    my $text = $self->_chomp_all($self->_pop_stack_text);
  
    $_[0]->_save_line($text . $/);
  }
  
  sub _handle_between_item_content {
    my ($self) = @_;
  
    # This might be empty (if the list item had no additional content).
    if( my $text = $self->_pop_stack_text ){
      # Else it's a sub-document.
      # If there are blocks we need to separate with blank lines.
      if( $self->_private->{last_state}->{blocks} ){
        $text = $/ . $text;
      }
      # If not, we can condense the text.
      # In this module's history there was a patch contributed to specifically
      # produce "huddled" lists so we'll try to maintain that functionality.
      else {
        $text = $self->_chomp_all($text) . $/;
      }
      $self->_save($text)
    }
  
    $self->_decrease_indent;
  }
  
  sub _start_item {
    my ($self) = @_;
    $self->_handle_between_item_content;
    $self->_new_stack;
  }
  
  sub   _end_item {
    my ($self, $marker) = @_;
    my $text = $self->_pop_stack_text;
    $self->_save_line($self->_indent($marker .
      # Add a space only if there is text after the marker.
      (defined($text) && length($text) ? ' ' . $text : '')
    ));
  
    # Store any possible contents in a new stack (like a sub-document).
    $self->_increase_indent;
    $self->_new_stack;
  }
  
  sub start_over_bullet { $_[0]->_start_list }
  sub   end_over_bullet { $_[0]->_end_list }
  
  sub start_item_bullet { $_[0]->_start_item }
  sub   end_item_bullet { $_[0]->_end_item('-') }
  
  sub start_over_number { $_[0]->_start_list }
  sub   end_over_number { $_[0]->_end_list }
  
  sub start_item_number {
    $_[0]->_start_item;
    # It seems like this should be a stack,
    # but from testing it appears that the corresponding 'end' event
    # comes right after the text (it doesn't surround any embedded content).
    # See t/nested.t which shows start-item, text, end-item, para, start-item....
    $_[0]->_private->{item_number} = $_[1]->{number};
  }
  
  sub   end_item_number {
    my ($self) = @_;
    $self->_end_item($self->_private->{item_number} . '.');
  }
  
  # Markdown doesn't support definition lists
  # so do regular (unordered) lists with indented paragraphs.
  sub start_over_text { $_[0]->_start_list }
  sub   end_over_text { $_[0]->_end_list }
  
  sub start_item_text { $_[0]->_start_item }
  sub   end_item_text { $_[0]->_end_item('-')}
  
  
  # perlpodspec equates an over/back region with no items to a blockquote.
  sub start_over_block {
    # NOTE: We don't actually need to indent for a blockquote.
    $_[0]->_new_stack;
  }
  
  sub   end_over_block {
    my ($self) = @_;
  
    # Chomp first to avoid prefixing a blank line with a `>`.
    my $text = $self->_chomp_all($self->_pop_stack_text);
  
    # NOTE: Paragraphs will already be escaped.
  
    # I don't really like either of these implementations
    # but the join/map/split seems a little better and benches a little faster.
    # You would lose the last newline but we've already chomped.
    #$text =~ s{^(.)?}{'>' . (defined($1) && length($1) ? (' ' . $1) : '')}mge;
    $text = join $/, map { length($_) ? '> ' . $_ : '>' } split qr-$/-, $text;
  
    $self->_save_block($text);
  }
  
  ## Custom Formats ##
  
  sub start_for {
    my ($self, $attr) = @_;
    $self->_new_stack;
  
    if( $attr->{target} eq 'html' ){
      # Use another stack so we can indent
      # (not syntactily necessary but seems appropriate).
      $self->_new_stack;
      $self->_increase_indent;
      $self->_private->{no_escape} = 1;
      # Mark this so we know to undo it.
      $self->_stack_state->{for_html} = 1;
    }
  }
  
  sub end_for {
    my ($self) = @_;
    # Data gets saved as a block (which will handle indents),
    # but if there was html we'll alter this, so chomp and save a block again.
    my $text = $self->_chomp_all($self->_pop_stack_text);
  
    if( $self->_private->{last_state}->{for_html} ){
      $self->_private->{no_escape} = 0;
      # Save it to the next stack up so we can pop it again (we made two stacks).
      $self->_save($text);
      $self->_decrease_indent;
      $text = join "\n", '<div>', $self->_chomp_all($self->_pop_stack_text), '</div>';
    }
  
    $self->_save_block($text);
  }
  
  # Data events will be emitted for any formatted regions that have been enabled
  # (by default, `markdown` and `html`).
  
  sub start_Data {
    my ($self) = @_;
    # TODO: limit this to what's in attr?
    $self->_private->{no_escape}++;
    $self->_new_stack;
  }
  
  sub   end_Data {
    my ($self) = @_;
    my $text = $self->_pop_stack_text;
    $self->_private->{no_escape}--;
    $self->_save_block($text);
  }
  
  ## Codes ##
  
  sub start_B { $_[0]->_save('**') }
  sub   end_B { $_[0]->start_B()   }
  
  sub start_I { $_[0]->_save('_') }
  sub   end_I { $_[0]->start_I()  }
  
  sub start_C {
    my ($self) = @_;
    $self->_new_stack;
    $self->_private->{no_escape}++;
  }
  
  sub   end_C {
    my ($self) = @_;
    $self->_private->{no_escape}--;
    $self->_save( $self->_wrap_code_span($self->_pop_stack_text) );
  }
  
  # Use code spans for F<>.
  sub start_F { shift->start_C(@_); }
  sub   end_F { shift  ->end_C(@_); }
  
  sub start_L {
    my ($self, $flags) = @_;
    $self->_new_stack;
    push @{ $self->_private->{link} }, $flags;
  }
  
  sub   end_L {
    my ($self) = @_;
    my $flags = pop @{ $self->_private->{link} }
      or die 'Invalid state: link end with no link start';
  
    my ($type, $to, $section) = @{$flags}{qw( type to section )};
  
    my $url = (
      $type eq 'url' ? $to
        : $type eq 'man' ? $self->format_man_url($to, $section)
        : $type eq 'pod' ? $self->format_perldoc_url($to, $section)
        :                  undef
    );
  
    my $text = $self->_pop_stack_text;
  
    # NOTE: I don't think the perlpodspec says what to do with L<|blah>
    # but it seems like a blank link text just doesn't make sense
    if( !length($text) ){
      $text =
        $section ?
          $to ? sprintf('"%s" in %s', $section, $to)
          : ('"' . $section . '"')
        : $to;
    }
  
    # FIXME: What does Pod::Simple::X?HTML do for this?
    # if we don't know how to handle the url just print the pod back out
    if (!$url) {
      $self->_save(sprintf 'L<%s>', $flags->{raw});
      return;
    }
  
    # In the url we need to escape quotes and parentheses lest markdown
    # break the url (cut it short and/or wrongfully interpret a title).
  
    # Backslash escapes do not work for the space and quotes.
    # URL-encoding the space is not sufficient
    # (the quotes confuse some parsers and produce invalid html).
    # I've arbitratily chosen HTML encoding to hide them from markdown
    # while mangling the url as litle as possible.
    $url =~ s/([ '"])/sprintf '&#x%x;', ord($1)/ge;
  
    # We also need to double any backslashes that may be present
    # (lest they be swallowed up) and stop parens from breaking the url.
    $url =~ s/([\\()])/\\$1/g;
  
    # TODO: put section name in title if not the same as $text
    $self->_save('[' . $text . '](' . $url . ')');
  }
  
  sub start_X {
    $_[0]->_new_stack;
  }
  
  sub   end_X {
    my ($self) = @_;
    my $text = $self->_pop_stack_text;
    # TODO: mangle $text?
    # TODO: put <a name="$text"> if configured
  }
  
  # A code span can be delimited by multiple backticks (and a space)
  # similar to pod codes (C<< code >>), so ensure we use a big enough
  # delimiter to not have it broken by embedded backticks.
  sub _wrap_code_span {
    my ($self, $arg) = @_;
    my $longest = 0;
    while( $arg =~ /([`]+)/g ){
      my $len = length($1);
      $longest = $len if $longest < $len;
    }
    my $delim = '`' x ($longest + 1);
    my $pad = $longest > 0 ? ' ' : '';
    return $delim . $pad . $arg . $pad . $delim;
  }
  
  ## Link Formatting (TODO: Move this to another module) ##
  
  
  sub format_man_url {
      my ($self, $to) = @_;
      my ($page, $part) = ($to =~ /^ ([^(]+) (?: \( (\S+) \) )? /x);
      return $self->man_url_prefix . ($part || 1) . '/' . ($page || $to);
  }
  
  
  sub format_perldoc_url {
    my ($self, $name, $section) = @_;
  
    my $url_prefix = $self->perldoc_url_prefix;
    my $url = '';
  
    # If the link is to another module (external link).
    if ($name) {
      $url = $url_prefix . $name;
    }
  
    # See https://rt.cpan.org/Ticket/Display.html?id=57776
    # for a discussion on the need to mangle the section.
    if ($section){
  
      my $method = $url
        # If we already have a prefix on the url it's external.
        ? $self->perldoc_fragment_format
        # Else an internal link points to this markdown doc.
        : $self->markdown_fragment_format;
  
      $method = 'format_fragment_' . $method
        unless ref($method);
  
      {
        # Set topic to enable code refs to be simple.
        local $_ = $section;
        $section = $self->$method($section);
      }
  
      $url .= '#' . $section;
    }
  
    return $url;
  }
  
  
  # TODO: simple, pandoc, etc?
  
  sub format_fragment_markdown {
    my ($self, $section) = @_;
  
    # If this is an internal link (to another section in this doc)
    # we can't be sure what the heading id's will look like
    # (it depends on what is rendering the markdown to html)
    # but we can try to follow popular conventions.
  
    # http://johnmacfarlane.net/pandoc/demo/example9/pandocs-markdown.html#header-identifiers-in-html-latex-and-context
    #$section =~ s/(?![-_.])[[:punct:]]//g;
    #$section =~ s/\s+/-/g;
    $section =~ s/\W+/-/g;
    $section =~ s/-+$//;
    $section =~ s/^-+//;
    $section = lc $section;
    #$section =~ s/^[^a-z]+//;
    $section ||= 'section';
  
    return $section;
  }
  
  
  {
    # From Pod::Simple::XHTML 3.28.
    # The strings gets passed through encode_entities() before idify().
    # If we don't do it here the substitutions below won't operate consistently.
  
    sub format_fragment_pod_simple_xhtml {
      my ($self, $t) = @_;
  
      # encode_entities {
        # We need to use the defaults in case html_encode_chars has been customized
        # (since the purpose is to match what external sources are doing).
  
        local $self->_private->{html_encode_chars};
        $t = $self->encode_entities($t);
      # }
  
      # idify {
        for ($t) {
            s/<[^>]+>//g;            # Strip HTML.
            s/&[^;]+;//g;            # Strip entities.
            s/^\s+//; s/\s+$//;      # Strip white space.
            s/^([^a-zA-Z]+)$/pod$1/; # Prepend "pod" if no valid chars.
            s/^[^a-zA-Z]+//;         # First char must be a letter.
            s/[^-a-zA-Z0-9_:.]+/-/g; # All other chars must be valid.
            s/[-:.]+$//;             # Strip trailing punctuation.
        }
      # }
  
      return $t;
    }
  }
  
  
  sub format_fragment_pod_simple_html {
    my ($self, $section) = @_;
  
    # From Pod::Simple::HTML 3.28.
  
    # section_name_tidy {
      $section =~ s/^\s+//;
      $section =~ s/\s+$//;
      $section =~ tr/ /_/;
      $section =~ tr/\x00-\x1F\x80-\x9F//d if 'A' eq chr(65); # drop crazy characters
  
      #$section = $self->unicode_escape_url($section);
        # unicode_escape_url {
        $section =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;
          #  Turn char 1234 into "(1234)"
        # }
  
      $section = '_' unless length $section;
      return $section;
    # }
  }
  
  
  sub format_fragment_metacpan { shift->format_fragment_pod_simple_xhtml(@_); }
  sub format_fragment_sco      { shift->format_fragment_pod_simple_html(@_);  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =for :stopwords Marcel Gruenauer Victor Moral Ryan C. Thompson <rct at thompsonclan d0t
  org> Aristotle Pagaltzis Randy Stauner ACKNOWLEDGEMENTS html cpan
  testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto
  metadata placeholders metacpan
  
  =head1 NAME
  
  Pod::Markdown - Convert POD to Markdown
  
  =head1 VERSION
  
  version 3.005
  
  =for test_synopsis my ($pod_string);
  
  =head1 SYNOPSIS
  
    # Pod::Simple API is supported.
  
    # Command line usage: Parse a pod file and print to STDOUT:
    # $ perl -MPod::Markdown -e 'Pod::Markdown->new->filter(@ARGV)' path/to/POD/file > README.md
  
    # Work with strings:
    my $markdown;
    my $parser = Pod::Markdown->new;
    $parser->output_string(\$markdown);
    $parser->parse_string_document($pod_string);
  
    # See Pod::Simple docs for more.
  
  =head1 DESCRIPTION
  
  This module uses L<Pod::Simple> to convert POD to Markdown.
  
  Literal characters in Pod that are special in Markdown
  (like *asterisks*) are backslash-escaped when appropriate.
  
  By default C<markdown> and C<html> formatted regions are accepted.
  Regions of C<markdown> will be passed through unchanged.
  Regions of C<html> will be placed inside a C<< E<lt>divE<gt> >> tag
  so that markdown characters won't be processed.
  Regions of C<:markdown> or C<:html> will be processed as POD and included.
  To change which regions are accepted use the L<Pod::Simple> API:
  
    my $parser = Pod::Markdown->new;
    $parser->unaccept_targets(qw( markdown html ));
  
  =head2 A note on encoding and escaping
  
  The common L<Pod::Simple> API returns a character string.
  If you want Pod::Markdown to return encoded octets, there are two attributes
  to assist: L</match_encoding> and L</output_encoding>.
  
  When an output encoding is requested any characters that are not valid
  for that encoding will be escaped as HTML entities.
  
  This is not 100% safe, however.
  
  Markdown escapes all ampersands inside of code spans, so escaping a character
  as an HTML entity inside of a code span will not be correct.
  However, with pod's C<S> and C<E> sequences it is possible
  to end up with high-bit characters inside of code spans.
  
  So, while C<< output_encoding => 'ascii' >> can work, it is not recommended.
  For these reasons (and more), C<UTF-8> is the default, fallback encoding (when one is required).
  
  If you prefer HTML entities over literal characters you can use
  L</html_encode_chars> which will only operate outside of code spans (where it is safe).
  
  =head1 METHODS
  
  =head2 new
  
    Pod::Markdown->new(%options);
  
  The constructor accepts the following named arguments:
  
  =over 4
  
  =item *
  
  C<man_url_prefix>
  
  Alters the man page urls that are created from C<< LE<lt>E<gt> >> codes.
  
  The default is C<http://man.he.net/man>.
  
  =item *
  
  C<perldoc_url_prefix>
  
  Alters the perldoc urls that are created from C<< LE<lt>E<gt> >> codes.
  Can be:
  
  =over 4
  
  =item *
  
  C<metacpan> (shortcut for C<https://metacpan.org/pod/>)
  
  =item *
  
  C<sco> (shortcut for C<http://search.cpan.org/perldoc?>)
  
  =item *
  
  any url
  
  =back
  
  The default is C<metacpan>.
  
      Pod::Markdown->new(perldoc_url_prefix => 'http://localhost/perl/pod');
  
  =item *
  
  C<perldoc_fragment_format>
  
  Alters the format of the url fragment for any C<< LE<lt>E<gt> >> links
  that point to a section of an external document (C<< L<name/section> >>).
  The default will be chosen according to the destination L</perldoc_url_prefix>.
  Alternatively you can specify one of the following:
  
  =over 4
  
  =item *
  
  C<metacpan>
  
  =item *
  
  C<sco>
  
  =item *
  
  C<pod_simple_xhtml>
  
  =item *
  
  C<pod_simple_html>
  
  =item *
  
  A code ref
  
  =back
  
  The code ref can expect to receive two arguments:
  the parser object (C<$self>) and the section text.
  For convenience the topic variable (C<$_>) is also set to the section text:
  
    perldoc_fragment_format => sub { s/\W+/-/g; }
  
  =item *
  
  C<markdown_fragment_format>
  
  Alters the format of the url fragment for any C<< LE<lt>E<gt> >> links
  that point to an internal section of this document (C<< L</section> >>).
  
  Unfortunately the format of the id attributes produced
  by whatever system translates the markdown into html is unknown at the time
  the markdown is generated so we do some simple clean up.
  
  B<Note:> C<markdown_fragment_format> and C<perldoc_fragment_format> accept
  the same values: a (shortcut to a) method name or a code ref.
  
  =item *
  
  C<include_meta_tags>
  
  Specifies whether or not to print author/title meta tags at the top of the document.
  Default is false.
  
  =back
  
  =head2 html_encode_chars
  
  A string of characters to encode as html entities
  (using L<HTML::Entities/encode_entities> if available, falling back to numeric entities if not).
  
  Possible values:
  
  =over 4
  
  =item *
  
  A value of C<1> will use the default set of characters from L<HTML::Entities> (control chars, high-bit chars, and C<< <&>"' >>).
  
  =item *
  
  A false value will disable.
  
  =item *
  
  Any other value is used as a string of characters (like a regular expression character class).
  
  =back
  
  By default this is disabled and literal characters will be in the output stream.
  If you specify a desired L</output_encoding> any characters not valid for that encoding will be HTML entity encoded.
  
  B<Note> that Markdown requires ampersands (C<< & >>) and left angle brackets (C<< < >>)
  to be entity-encoded if they could otherwise be interpreted as html entities.
  If this attribute is configured to encode those characters, they will always be encoded.
  If not, the module will make an effort to only encode the ones required,
  so there will be less html noise in the output.
  
  =head2 match_encoding
  
  Boolean: If true, use the C<< =encoding >> of the input pod
  as the encoding for the output.
  
  If no encoding is specified, L<Pod::Simple> will guess the encoding
  if it sees a high-bit character.
  
  If no encoding is guessed (or the specified encoding is unusable),
  L</output_encoding> will be used if it was specified.
  Otherwise C<UTF-8> will be used.
  
  This attribute is not recommended
  but is provided for consistency with other pod converters.
  
  Defaults to false.
  
  =head2 output_encoding
  
  The encoding to use when writing to the output file handle.
  
  If neither this nor L</match_encoding> are specified,
  a character string will be returned in whatever L<Pod::Simple> output method you specified.
  
  =head2 man_url_prefix
  
  Returns the url prefix in use for man pages.
  
  =head2 perldoc_url_prefix
  
  Returns the url prefix in use (after resolving shortcuts to urls).
  
  =head2 perldoc_fragment_format
  
  Returns the coderef or format name used to format a url fragment
  to a section in an external document.
  
  =head2 markdown_fragment_format
  
  Returns the coderef or format name used to format a url fragment
  to an internal section in this document.
  
  =head2 include_meta_tags
  
  Returns the boolean value indicating
  whether or not meta tags will be printed.
  
  =head2 format_man_url
  
  Used internally to create a url (using L</man_url_prefix>)
  from a string like C<man(1)>.
  
  =head2 format_perldoc_url
  
      # With $name and section being the two parts of L<name/section>.
      my $url = $parser->format_perldoc_url($name, $section);
  
  Used internally to create a url from
  the name (of a module or script)
  and a possible section (heading).
  
  The format of the url fragment (when pointing to a section in a document)
  varies depending on the destination url
  so L</perldoc_fragment_format> is used (which can be customized).
  
  If the module name portion of the link is blank
  then the section is treated as an internal fragment link
  (to a section of the generated markdown document)
  and L</markdown_fragment_format> is used (which can be customized).
  
  =head2 format_fragment_markdown
  
  Format url fragment for an internal link
  by replacing non-word characters with dashes.
  
  =head2 format_fragment_pod_simple_xhtml
  
  Format url fragment like L<Pod::Simple::XHTML/idify>.
  
  =head2 format_fragment_pod_simple_html
  
  Format url fragment like L<Pod::Simple::HTML/section_name_tidy>.
  
  =head2 format_fragment_metacpan
  
  Format fragment for L<metacpan.org>
  (uses L</format_fragment_pod_simple_xhtml>).
  
  =head2 format_fragment_sco
  
  Format fragment for L<search.cpan.org>
  (uses L</format_fragment_pod_simple_html>).
  
  =for Pod::Coverage parse_from_file
  parse_from_filehandle
  
  =for Pod::Coverage as_markdown
  
  =for Pod::Coverage handle_text
  end_.+
  start_.+
  encode_entities
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<pod2markdown> - script included for command line usage
  
  =item *
  
  L<Pod::Simple> - Super class that handles Pod parsing
  
  =item *
  
  L<perlpod> - For writing POD
  
  =item *
  
  L<perlpodspec> - For parsing POD
  
  =item *
  
  L<http://daringfireball.net/projects/markdown/syntax> - Markdown spec
  
  =back
  
  =head1 SUPPORT
  
  =head2 Perldoc
  
  You can find documentation for this module with the perldoc command.
  
    perldoc Pod::Markdown
  
  =head2 Websites
  
  The following websites have more information about this module, and may be of help to you. As always,
  in addition to those websites please use your favorite search engine to discover more resources.
  
  =over 4
  
  =item *
  
  MetaCPAN
  
  A modern, open-source CPAN search engine, useful to view POD in HTML format.
  
  L<http://metacpan.org/release/Pod-Markdown>
  
  =back
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests by email to C<bug-pod-markdown at rt.cpan.org>, or through
  the web interface at L<https://rt.cpan.org/Public/Bug/Report.html?Queue=Pod-Markdown>. You will be automatically notified of any
  progress on the request by the system.
  
  =head2 Source Code
  
  
  L<https://github.com/rwstauner/Pod-Markdown>
  
    git clone https://github.com/rwstauner/Pod-Markdown.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Marcel Gruenauer <marcel@cpan.org>
  
  =item *
  
  Victor Moral <victor@taquiones.net>
  
  =item *
  
  Ryan C. Thompson <rct at thompsonclan d0t org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Randy Stauner <rwstauner@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Aristotle Pagaltzis Cindy Wang (CindyLinz) Graham Ollis Mike Covington motemen moznion Peter Vereshagin Ryan C. Thompson Yasutaka ATARASHI
  
  =over 4
  
  =item *
  
  Aristotle Pagaltzis <aristotle@cpan.org>
  
  =item *
  
  Cindy Wang (CindyLinz) <cindylinz@gmail.com>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Mike Covington <mfcovington@gmail.com>
  
  =item *
  
  motemen <motemen@cpan.org>
  
  =item *
  
  moznion <moznion@cpan.org>
  
  =item *
  
  Peter Vereshagin <veresc@cpan.org>
  
  =item *
  
  Ryan C. Thompson <rthompson@cpan.org>
  
  =item *
  
  Yasutaka ATARASHI <yakex@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Randy Stauner.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
POD_MARKDOWN

$fatpacked{"Pod/Perldoc/ToMarkdown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PERLDOC_TOMARKDOWN';
  #
  # This file is part of Pod-Markdown
  #
  # This software is copyright (c) 2011 by Randy Stauner.
  #
  # This is free software; you can redistribute it and/or modify it under
  # the same terms as the Perl 5 programming language system itself.
  #
  use strict;
  use warnings;
  
  package Pod::Perldoc::ToMarkdown;
  our $AUTHORITY = 'cpan:RWSTAUNER';
  $Pod::Perldoc::ToMarkdown::VERSION = '3.005';
  # ABSTRACT: Enable `perldoc -o Markdown`
  
  use parent qw(Pod::Markdown);
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(
      # Pod::Perldoc does not pass any options by default
      # but will call setters if attributes are passed on command line.
      # I don't know what encoding it expects, but it needs one, so default to UTF-8.
      output_encoding => 'UTF-8',
      @_,
    );
    return $self;
  }
  
  sub parse_from_file {
    my $self = shift;
    # Instantiate if called as a class method.
    $self = $self->new if !ref $self;
  
    # Skip over SUPER's override and go up to grandpa's method.
    $self->Pod::Simple::parse_from_file(@_);
  }
  
  # There are several other methods that we could implement that Pod::Perldoc
  # finds interesting:
  # * output_is_binary
  # * name
  # * output_extension
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =for :stopwords Marcel Gruenauer Victor Moral Ryan C. Thompson <rct at thompsonclan d0t
  org> Aristotle Pagaltzis Randy Stauner ACKNOWLEDGEMENTS
  
  =head1 NAME
  
  Pod::Perldoc::ToMarkdown - Enable `perldoc -o Markdown`
  
  =head1 VERSION
  
  version 3.005
  
  =for test_synopsis 1;
  __END__
  
  =head1 SYNOPSIS
  
    perldoc -o Markdown Some::Module
  
  =head1 DESCRIPTION
  
  Pod::Perldoc expects a Pod::Parser compatible module,
  however Pod::Markdown did not historically provide an entirely Pod::Parser
  compatible interface.
  
  This module bridges the gap.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Marcel Gruenauer <marcel@cpan.org>
  
  =item *
  
  Victor Moral <victor@taquiones.net>
  
  =item *
  
  Ryan C. Thompson <rct at thompsonclan d0t org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Randy Stauner <rwstauner@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Randy Stauner.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
POD_PERLDOC_TOMARKDOWN

$fatpacked{"x86_64-linux/HTML/Entities.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_ENTITIES';
  package HTML::Entities;
  
  =encoding utf8
  
  =head1 NAME
  
  HTML::Entities - Encode or decode strings with HTML entities
  
  =head1 SYNOPSIS
  
   use HTML::Entities;
  
   $a = "V&aring;re norske tegn b&oslash;r &#230res";
   decode_entities($a);
   encode_entities($a, "\200-\377");
  
  For example, this:
  
   $input = "vis-à-vis Beyoncé's naïve\npapier-mâché résumé";
   print encode_entities($input), "\n"
  
  Prints this out:
  
   vis-&agrave;-vis Beyonc&eacute;'s na&iuml;ve
   papier-m&acirc;ch&eacute; r&eacute;sum&eacute;
  
  =head1 DESCRIPTION
  
  This module deals with encoding and decoding of strings with HTML
  character entities.  The module provides the following functions:
  
  =over 4
  
  =item decode_entities( $string, ... )
  
  This routine replaces HTML entities found in the $string with the
  corresponding Unicode character.  Unrecognized entities are left alone.
  
  If multiple strings are provided as argument they are each decoded
  separately and the same number of strings are returned.
  
  If called in void context the arguments are decoded in-place.
  
  This routine is exported by default.
  
  =item _decode_entities( $string, \%entity2char )
  
  =item _decode_entities( $string, \%entity2char, $expand_prefix )
  
  This will in-place replace HTML entities in $string.  The %entity2char
  hash must be provided.  Named entities not found in the %entity2char
  hash are left alone.  Numeric entities are expanded unless their value
  overflow.
  
  The keys in %entity2char are the entity names to be expanded and their
  values are what they should expand into.  The values do not have to be
  single character strings.  If a key has ";" as suffix,
  then occurrences in $string are only expanded if properly terminated
  with ";".  Entities without ";" will be expanded regardless of how
  they are terminated for compatibility with how common browsers treat
  entities in the Latin-1 range.
  
  If $expand_prefix is TRUE then entities without trailing ";" in
  %entity2char will even be expanded as a prefix of a longer
  unrecognized name.  The longest matching name in %entity2char will be
  used. This is mainly present for compatibility with an MSIE
  misfeature.
  
     $string = "foo&nbspbar";
     _decode_entities($string, { nb => "@", nbsp => "\xA0" }, 1);
     print $string;  # will print "foo bar"
  
  This routine is exported by default.
  
  =item encode_entities( $string )
  
  =item encode_entities( $string, $unsafe_chars )
  
  This routine replaces unsafe characters in $string with their entity
  representation. A second argument can be given to specify which characters to
  consider unsafe.  The unsafe characters is specified using the regular
  expression character class syntax (what you find within brackets in regular
  expressions).
  
  The default set of characters to encode are control chars, high-bit chars, and
  the C<< < >>, C<< & >>, C<< > >>, C<< ' >> and C<< " >> characters.  But this,
  for example, would encode I<just> the C<< < >>, C<< & >>, C<< > >>, and C<< "
  >> characters:
  
    $encoded = encode_entities($input, '<>&"');
  
  and this would only encode non-plain ascii:
  
    $encoded = encode_entities($input, '^\n\x20-\x25\x27-\x7e');
  
  This routine is exported by default.
  
  =item encode_entities_numeric( $string )
  
  =item encode_entities_numeric( $string, $unsafe_chars )
  
  This routine works just like encode_entities, except that the replacement
  entities are always C<&#xI<hexnum>;> and never C<&I<entname>;>.  For
  example, C<encode_entities("r\xF4le")> returns "r&ocirc;le", but
  C<encode_entities_numeric("r\xF4le")> returns "r&#xF4;le".
  
  This routine is I<not> exported by default.  But you can always
  export it with C<use HTML::Entities qw(encode_entities_numeric);>
  or even C<use HTML::Entities qw(:DEFAULT encode_entities_numeric);>
  
  =back
  
  All these routines modify the string passed as the first argument, if
  called in a void context.  In scalar and array contexts, the encoded or
  decoded string is returned (without changing the input string).
  
  If you prefer not to import these routines into your namespace, you can
  call them as:
  
    use HTML::Entities ();
    $decoded = HTML::Entities::decode($a);
    $encoded = HTML::Entities::encode($a);
    $encoded = HTML::Entities::encode_numeric($a);
  
  The module can also export the %char2entity and the %entity2char
  hashes, which contain the mapping from all characters to the
  corresponding entities (and vice versa, respectively).
  
  =head1 COPYRIGHT
  
  Copyright 1995-2006 Gisle Aas. All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  use vars qw(%entity2char %char2entity);
  
  require 5.004;
  require Exporter;
  @ISA = qw(Exporter);
  
  @EXPORT = qw(encode_entities decode_entities _decode_entities);
  @EXPORT_OK = qw(%entity2char %char2entity encode_entities_numeric);
  
  $VERSION = "3.69";
  sub Version { $VERSION; }
  
  require HTML::Parser;  # for fast XS implemented decode_entities
  
  
  %entity2char = (
   # Some normal chars that have special meaning in SGML context
   amp    => '&',  # ampersand 
  'gt'    => '>',  # greater than
  'lt'    => '<',  # less than
   quot   => '"',  # double quote
   apos   => "'",  # single quote
  
   # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML
   AElig	=> chr(198),  # capital AE diphthong (ligature)
   Aacute	=> chr(193),  # capital A, acute accent
   Acirc	=> chr(194),  # capital A, circumflex accent
   Agrave	=> chr(192),  # capital A, grave accent
   Aring	=> chr(197),  # capital A, ring
   Atilde	=> chr(195),  # capital A, tilde
   Auml	=> chr(196),  # capital A, dieresis or umlaut mark
   Ccedil	=> chr(199),  # capital C, cedilla
   ETH	=> chr(208),  # capital Eth, Icelandic
   Eacute	=> chr(201),  # capital E, acute accent
   Ecirc	=> chr(202),  # capital E, circumflex accent
   Egrave	=> chr(200),  # capital E, grave accent
   Euml	=> chr(203),  # capital E, dieresis or umlaut mark
   Iacute	=> chr(205),  # capital I, acute accent
   Icirc	=> chr(206),  # capital I, circumflex accent
   Igrave	=> chr(204),  # capital I, grave accent
   Iuml	=> chr(207),  # capital I, dieresis or umlaut mark
   Ntilde	=> chr(209),  # capital N, tilde
   Oacute	=> chr(211),  # capital O, acute accent
   Ocirc	=> chr(212),  # capital O, circumflex accent
   Ograve	=> chr(210),  # capital O, grave accent
   Oslash	=> chr(216),  # capital O, slash
   Otilde	=> chr(213),  # capital O, tilde
   Ouml	=> chr(214),  # capital O, dieresis or umlaut mark
   THORN	=> chr(222),  # capital THORN, Icelandic
   Uacute	=> chr(218),  # capital U, acute accent
   Ucirc	=> chr(219),  # capital U, circumflex accent
   Ugrave	=> chr(217),  # capital U, grave accent
   Uuml	=> chr(220),  # capital U, dieresis or umlaut mark
   Yacute	=> chr(221),  # capital Y, acute accent
   aacute	=> chr(225),  # small a, acute accent
   acirc	=> chr(226),  # small a, circumflex accent
   aelig	=> chr(230),  # small ae diphthong (ligature)
   agrave	=> chr(224),  # small a, grave accent
   aring	=> chr(229),  # small a, ring
   atilde	=> chr(227),  # small a, tilde
   auml	=> chr(228),  # small a, dieresis or umlaut mark
   ccedil	=> chr(231),  # small c, cedilla
   eacute	=> chr(233),  # small e, acute accent
   ecirc	=> chr(234),  # small e, circumflex accent
   egrave	=> chr(232),  # small e, grave accent
   eth	=> chr(240),  # small eth, Icelandic
   euml	=> chr(235),  # small e, dieresis or umlaut mark
   iacute	=> chr(237),  # small i, acute accent
   icirc	=> chr(238),  # small i, circumflex accent
   igrave	=> chr(236),  # small i, grave accent
   iuml	=> chr(239),  # small i, dieresis or umlaut mark
   ntilde	=> chr(241),  # small n, tilde
   oacute	=> chr(243),  # small o, acute accent
   ocirc	=> chr(244),  # small o, circumflex accent
   ograve	=> chr(242),  # small o, grave accent
   oslash	=> chr(248),  # small o, slash
   otilde	=> chr(245),  # small o, tilde
   ouml	=> chr(246),  # small o, dieresis or umlaut mark
   szlig	=> chr(223),  # small sharp s, German (sz ligature)
   thorn	=> chr(254),  # small thorn, Icelandic
   uacute	=> chr(250),  # small u, acute accent
   ucirc	=> chr(251),  # small u, circumflex accent
   ugrave	=> chr(249),  # small u, grave accent
   uuml	=> chr(252),  # small u, dieresis or umlaut mark
   yacute	=> chr(253),  # small y, acute accent
   yuml	=> chr(255),  # small y, dieresis or umlaut mark
  
   # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
   copy   => chr(169),  # copyright sign
   reg    => chr(174),  # registered sign
   nbsp   => chr(160),  # non breaking space
  
   # Additional ISO-8859/1 entities listed in rfc1866 (section 14)
   iexcl  => chr(161),
   cent   => chr(162),
   pound  => chr(163),
   curren => chr(164),
   yen    => chr(165),
   brvbar => chr(166),
   sect   => chr(167),
   uml    => chr(168),
   ordf   => chr(170),
   laquo  => chr(171),
  'not'   => chr(172),    # not is a keyword in perl
   shy    => chr(173),
   macr   => chr(175),
   deg    => chr(176),
   plusmn => chr(177),
   sup1   => chr(185),
   sup2   => chr(178),
   sup3   => chr(179),
   acute  => chr(180),
   micro  => chr(181),
   para   => chr(182),
   middot => chr(183),
   cedil  => chr(184),
   ordm   => chr(186),
   raquo  => chr(187),
   frac14 => chr(188),
   frac12 => chr(189),
   frac34 => chr(190),
   iquest => chr(191),
  'times' => chr(215),    # times is a keyword in perl
   divide => chr(247),
  
   ( $] > 5.007 ? (
    'OElig;'    => chr(338),
    'oelig;'    => chr(339),
    'Scaron;'   => chr(352),
    'scaron;'   => chr(353),
    'Yuml;'     => chr(376),
    'fnof;'     => chr(402),
    'circ;'     => chr(710),
    'tilde;'    => chr(732),
    'Alpha;'    => chr(913),
    'Beta;'     => chr(914),
    'Gamma;'    => chr(915),
    'Delta;'    => chr(916),
    'Epsilon;'  => chr(917),
    'Zeta;'     => chr(918),
    'Eta;'      => chr(919),
    'Theta;'    => chr(920),
    'Iota;'     => chr(921),
    'Kappa;'    => chr(922),
    'Lambda;'   => chr(923),
    'Mu;'       => chr(924),
    'Nu;'       => chr(925),
    'Xi;'       => chr(926),
    'Omicron;'  => chr(927),
    'Pi;'       => chr(928),
    'Rho;'      => chr(929),
    'Sigma;'    => chr(931),
    'Tau;'      => chr(932),
    'Upsilon;'  => chr(933),
    'Phi;'      => chr(934),
    'Chi;'      => chr(935),
    'Psi;'      => chr(936),
    'Omega;'    => chr(937),
    'alpha;'    => chr(945),
    'beta;'     => chr(946),
    'gamma;'    => chr(947),
    'delta;'    => chr(948),
    'epsilon;'  => chr(949),
    'zeta;'     => chr(950),
    'eta;'      => chr(951),
    'theta;'    => chr(952),
    'iota;'     => chr(953),
    'kappa;'    => chr(954),
    'lambda;'   => chr(955),
    'mu;'       => chr(956),
    'nu;'       => chr(957),
    'xi;'       => chr(958),
    'omicron;'  => chr(959),
    'pi;'       => chr(960),
    'rho;'      => chr(961),
    'sigmaf;'   => chr(962),
    'sigma;'    => chr(963),
    'tau;'      => chr(964),
    'upsilon;'  => chr(965),
    'phi;'      => chr(966),
    'chi;'      => chr(967),
    'psi;'      => chr(968),
    'omega;'    => chr(969),
    'thetasym;' => chr(977),
    'upsih;'    => chr(978),
    'piv;'      => chr(982),
    'ensp;'     => chr(8194),
    'emsp;'     => chr(8195),
    'thinsp;'   => chr(8201),
    'zwnj;'     => chr(8204),
    'zwj;'      => chr(8205),
    'lrm;'      => chr(8206),
    'rlm;'      => chr(8207),
    'ndash;'    => chr(8211),
    'mdash;'    => chr(8212),
    'lsquo;'    => chr(8216),
    'rsquo;'    => chr(8217),
    'sbquo;'    => chr(8218),
    'ldquo;'    => chr(8220),
    'rdquo;'    => chr(8221),
    'bdquo;'    => chr(8222),
    'dagger;'   => chr(8224),
    'Dagger;'   => chr(8225),
    'bull;'     => chr(8226),
    'hellip;'   => chr(8230),
    'permil;'   => chr(8240),
    'prime;'    => chr(8242),
    'Prime;'    => chr(8243),
    'lsaquo;'   => chr(8249),
    'rsaquo;'   => chr(8250),
    'oline;'    => chr(8254),
    'frasl;'    => chr(8260),
    'euro;'     => chr(8364),
    'image;'    => chr(8465),
    'weierp;'   => chr(8472),
    'real;'     => chr(8476),
    'trade;'    => chr(8482),
    'alefsym;'  => chr(8501),
    'larr;'     => chr(8592),
    'uarr;'     => chr(8593),
    'rarr;'     => chr(8594),
    'darr;'     => chr(8595),
    'harr;'     => chr(8596),
    'crarr;'    => chr(8629),
    'lArr;'     => chr(8656),
    'uArr;'     => chr(8657),
    'rArr;'     => chr(8658),
    'dArr;'     => chr(8659),
    'hArr;'     => chr(8660),
    'forall;'   => chr(8704),
    'part;'     => chr(8706),
    'exist;'    => chr(8707),
    'empty;'    => chr(8709),
    'nabla;'    => chr(8711),
    'isin;'     => chr(8712),
    'notin;'    => chr(8713),
    'ni;'       => chr(8715),
    'prod;'     => chr(8719),
    'sum;'      => chr(8721),
    'minus;'    => chr(8722),
    'lowast;'   => chr(8727),
    'radic;'    => chr(8730),
    'prop;'     => chr(8733),
    'infin;'    => chr(8734),
    'ang;'      => chr(8736),
    'and;'      => chr(8743),
    'or;'       => chr(8744),
    'cap;'      => chr(8745),
    'cup;'      => chr(8746),
    'int;'      => chr(8747),
    'there4;'   => chr(8756),
    'sim;'      => chr(8764),
    'cong;'     => chr(8773),
    'asymp;'    => chr(8776),
    'ne;'       => chr(8800),
    'equiv;'    => chr(8801),
    'le;'       => chr(8804),
    'ge;'       => chr(8805),
    'sub;'      => chr(8834),
    'sup;'      => chr(8835),
    'nsub;'     => chr(8836),
    'sube;'     => chr(8838),
    'supe;'     => chr(8839),
    'oplus;'    => chr(8853),
    'otimes;'   => chr(8855),
    'perp;'     => chr(8869),
    'sdot;'     => chr(8901),
    'lceil;'    => chr(8968),
    'rceil;'    => chr(8969),
    'lfloor;'   => chr(8970),
    'rfloor;'   => chr(8971),
    'lang;'     => chr(9001),
    'rang;'     => chr(9002),
    'loz;'      => chr(9674),
    'spades;'   => chr(9824),
    'clubs;'    => chr(9827),
    'hearts;'   => chr(9829),
    'diams;'    => chr(9830),
   ) : ())
  );
  
  
  # Make the opposite mapping
  while (my($entity, $char) = each(%entity2char)) {
      $entity =~ s/;\z//;
      $char2entity{$char} = "&$entity;";
  }
  delete $char2entity{"'"};  # only one-way decoding
  
  # Fill in missing entities
  for (0 .. 255) {
      next if exists $char2entity{chr($_)};
      $char2entity{chr($_)} = "&#$_;";
  }
  
  my %subst;  # compiled encoding regexps
  
  sub encode_entities
  {
      return undef unless defined $_[0];
      my $ref;
      if (defined wantarray) {
  	my $x = $_[0];
  	$ref = \$x;     # copy
      } else {
  	$ref = \$_[0];  # modify in-place
      }
      if (defined $_[1] and length $_[1]) {
  	unless (exists $subst{$_[1]}) {
  	    # Because we can't compile regex we fake it with a cached sub
  	    my $chars = $_[1];
  	    $chars =~ s,(?<!\\)([]/]),\\$1,g;
  	    $chars =~ s,(?<!\\)\\\z,\\\\,;
  	    my $code = "sub {\$_[0] =~ s/([$chars])/\$char2entity{\$1} || num_entity(\$1)/ge; }";
  	    $subst{$_[1]} = eval $code;
  	    die( $@ . " while trying to turn range: \"$_[1]\"\n "
  	      . "into code: $code\n "
  	    ) if $@;
  	}
  	&{$subst{$_[1]}}($$ref);
      } else {
  	# Encode control chars, high bit chars and '<', '&', '>', ''' and '"'
  	$$ref =~ s/([^\n\r\t !\#\$%\(-;=?-~])/$char2entity{$1} || num_entity($1)/ge;
      }
      $$ref;
  }
  
  sub encode_entities_numeric {
      local %char2entity;
      return &encode_entities;   # a goto &encode_entities wouldn't work
  }
  
  
  sub num_entity {
      sprintf "&#x%X;", ord($_[0]);
  }
  
  # Set up aliases
  *encode = \&encode_entities;
  *encode_numeric = \&encode_entities_numeric;
  *encode_numerically = \&encode_entities_numeric;
  *decode = \&decode_entities;
  
  1;
X86_64-LINUX_HTML_ENTITIES

$fatpacked{"x86_64-linux/HTML/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_FILTER';
  package HTML::Filter;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require HTML::Parser;
  @ISA=qw(HTML::Parser);
  
  $VERSION = "3.72";
  
  sub declaration { $_[0]->output("<!$_[1]>")     }
  sub process     { $_[0]->output($_[2])          }
  sub comment     { $_[0]->output("<!--$_[1]-->") }
  sub start       { $_[0]->output($_[4])          }
  sub end         { $_[0]->output($_[2])          }
  sub text        { $_[0]->output($_[1])          }
  
  sub output      { print $_[1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTML::Filter - Filter HTML text through the parser
  
  =head1 NOTE
  
  B<This module is deprecated.> The C<HTML::Parser> now provides the
  functionally of C<HTML::Filter> much more efficiently with the
  C<default> handler.
  
  =head1 SYNOPSIS
  
   require HTML::Filter;
   $p = HTML::Filter->new->parse_file("index.html");
  
  =head1 DESCRIPTION
  
  C<HTML::Filter> is an HTML parser that by default prints the
  original text of each HTML element (a slow version of cat(1) basically).
  The callback methods may be overridden to modify the filtering for some
  HTML elements and you can override output() method which is called to
  print the HTML text.
  
  C<HTML::Filter> is a subclass of C<HTML::Parser>. This means that
  the document should be given to the parser by calling the $p->parse()
  or $p->parse_file() methods.
  
  =head1 EXAMPLES
  
  The first example is a filter that will remove all comments from an
  HTML file.  This is achieved by simply overriding the comment method
  to do nothing.
  
    package CommentStripper;
    require HTML::Filter;
    @ISA=qw(HTML::Filter);
    sub comment { }  # ignore comments
  
  The second example shows a filter that will remove any E<lt>TABLE>s
  found in the HTML file.  We specialize the start() and end() methods
  to count table tags and then make output not happen when inside a
  table.
  
    package TableStripper;
    require HTML::Filter;
    @ISA=qw(HTML::Filter);
    sub start
    {
       my $self = shift;
       $self->{table_seen}++ if $_[0] eq "table";
       $self->SUPER::start(@_);
    }
  
    sub end
    {
       my $self = shift;
       $self->SUPER::end(@_);
       $self->{table_seen}-- if $_[0] eq "table";
    }
  
    sub output
    {
        my $self = shift;
        unless ($self->{table_seen}) {
  	  $self->SUPER::output(@_);
        }
    }
  
  If you want to collect the parsed text internally you might want to do
  something like this:
  
    package FilterIntoString;
    require HTML::Filter;
    @ISA=qw(HTML::Filter);
    sub output { push(@{$_[0]->{fhtml}}, $_[1]) }
    sub filtered_html { join("", @{$_[0]->{fhtml}}) }
  
  =head1 SEE ALSO
  
  L<HTML::Parser>
  
  =head1 COPYRIGHT
  
  Copyright 1997-1999 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_HTML_FILTER

$fatpacked{"x86_64-linux/HTML/HeadParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_HEADPARSER';
  package HTML::HeadParser;
  
  =head1 NAME
  
  HTML::HeadParser - Parse <HEAD> section of a HTML document
  
  =head1 SYNOPSIS
  
   require HTML::HeadParser;
   $p = HTML::HeadParser->new;
   $p->parse($text) and  print "not finished";
  
   $p->header('Title')          # to access <title>....</title>
   $p->header('Content-Base')   # to access <base href="http://...">
   $p->header('Foo')            # to access <meta http-equiv="Foo" content="...">
   $p->header('X-Meta-Author')  # to access <meta name="author" content="...">
   $p->header('X-Meta-Charset') # to access <meta charset="...">
  
  =head1 DESCRIPTION
  
  The C<HTML::HeadParser> is a specialized (and lightweight)
  C<HTML::Parser> that will only parse the E<lt>HEAD>...E<lt>/HEAD>
  section of an HTML document.  The parse() method
  will return a FALSE value as soon as some E<lt>BODY> element or body
  text are found, and should not be called again after this.
  
  Note that the C<HTML::HeadParser> might get confused if raw undecoded
  UTF-8 is passed to the parse() method.  Make sure the strings are
  properly decoded before passing them on.
  
  The C<HTML::HeadParser> keeps a reference to a header object, and the
  parser will update this header object as the various elements of the
  E<lt>HEAD> section of the HTML document are recognized.  The following
  header fields are affected:
  
  =over 4
  
  =item Content-Base:
  
  The I<Content-Base> header is initialized from the E<lt>base
  href="..."> element.
  
  =item Title:
  
  The I<Title> header is initialized from the E<lt>title>...E<lt>/title>
  element.
  
  =item Isindex:
  
  The I<Isindex> header will be added if there is a E<lt>isindex>
  element in the E<lt>head>.  The header value is initialized from the
  I<prompt> attribute if it is present.  If no I<prompt> attribute is
  given it will have '?' as the value.
  
  =item X-Meta-Foo:
  
  All E<lt>meta> elements containing a C<name> attribute will result in
  headers using the prefix C<X-Meta-> appended with the value of the
  C<name> attribute as the name of the header, and the value of the
  C<content> attribute as the pushed header value.
  
  E<lt>meta> elements containing a C<http-equiv> attribute will result
  in headers as in above, but without the C<X-Meta-> prefix in the
  header name.
  
  E<lt>meta> elements containing a C<charset> attribute will result in
  an C<X-Meta-Charset> header, using the value of the C<charset>
  attribute as the pushed header value.
  
  The ':' character can't be represented in header field names, so
  if the meta element contains this char it's substituted with '-'
  before forming the field name.
  
  =back
  
  =head1 METHODS
  
  The following methods (in addition to those provided by the
  superclass) are available:
  
  =over 4
  
  =cut
  
  
  require HTML::Parser;
  @ISA = qw(HTML::Parser);
  
  use HTML::Entities ();
  
  use strict;
  use vars qw($VERSION $DEBUG);
  #$DEBUG = 1;
  $VERSION = "3.71";
  
  =item $hp = HTML::HeadParser->new
  
  =item $hp = HTML::HeadParser->new( $header )
  
  The object constructor.  The optional $header argument should be a
  reference to an object that implement the header() and push_header()
  methods as defined by the C<HTTP::Headers> class.  Normally it will be
  of some class that is a or delegates to the C<HTTP::Headers> class.
  
  If no $header is given C<HTML::HeadParser> will create an
  C<HTTP::Headers> object by itself (initially empty).
  
  =cut
  
  sub new
  {
      my($class, $header) = @_;
      unless ($header) {
  	require HTTP::Headers;
  	$header = HTTP::Headers->new;
      }
  
      my $self = $class->SUPER::new(api_version => 3,
  				  start_h => ["start", "self,tagname,attr"],
  				  end_h   => ["end",   "self,tagname"],
  				  text_h  => ["text",  "self,text"],
  				  ignore_elements => [qw(script style)],
  				 );
      $self->{'header'} = $header;
      $self->{'tag'} = '';   # name of active element that takes textual content
      $self->{'text'} = '';  # the accumulated text associated with the element
      $self;
  }
  
  =item $hp->header;
  
  Returns a reference to the header object.
  
  =item $hp->header( $key )
  
  Returns a header value.  It is just a shorter way to write
  C<$hp-E<gt>header-E<gt>header($key)>.
  
  =cut
  
  sub header
  {
      my $self = shift;
      return $self->{'header'} unless @_;
      $self->{'header'}->header(@_);
  }
  
  sub as_string    # legacy
  {
      my $self = shift;
      $self->{'header'}->as_string;
  }
  
  sub flush_text   # internal
  {
      my $self = shift;
      my $tag  = $self->{'tag'};
      my $text = $self->{'text'};
      $text =~ s/^\s+//;
      $text =~ s/\s+$//;
      $text =~ s/\s+/ /g;
      print "FLUSH $tag => '$text'\n"  if $DEBUG;
      if ($tag eq 'title') {
  	my $decoded;
  	$decoded = utf8::decode($text) if $self->utf8_mode && defined &utf8::decode;
  	HTML::Entities::decode($text);
  	utf8::encode($text) if $decoded;
  	$self->{'header'}->push_header(Title => $text);
      }
      $self->{'tag'} = $self->{'text'} = '';
  }
  
  # This is an quote from the HTML3.2 DTD which shows which elements
  # that might be present in a <HEAD>...</HEAD>.  Also note that the
  # <HEAD> tags themselves might be missing:
  #
  # <!ENTITY % head.content "TITLE & ISINDEX? & BASE? & STYLE? &
  #                            SCRIPT* & META* & LINK*">
  #
  # <!ELEMENT HEAD O O  (%head.content)>
  #
  # From HTML 4.01:
  #
  # <!ENTITY % head.misc "SCRIPT|STYLE|META|LINK|OBJECT">
  # <!ENTITY % head.content "TITLE & BASE?">
  # <!ELEMENT HEAD O O (%head.content;) +(%head.misc;)>
  #
  # From HTML 5 as of WD-html5-20090825:
  #
  # One or more elements of metadata content, [...]
  # => base, command, link, meta, noscript, script, style, title
  
  sub start
  {
      my($self, $tag, $attr) = @_;  # $attr is reference to a HASH
      print "START[$tag]\n" if $DEBUG;
      $self->flush_text if $self->{'tag'};
      if ($tag eq 'meta') {
  	my $key = $attr->{'http-equiv'};
  	if (!defined($key) || !length($key)) {
  	    if ($attr->{name}) {
  		$key = "X-Meta-\u$attr->{name}";
  	    } elsif ($attr->{charset}) { # HTML 5 <meta charset="...">
  		$key = "X-Meta-Charset";
  		$self->{header}->push_header($key => $attr->{charset});
  		return;
  	    } else {
  		return;
  	    }
  	}
  	$key =~ s/:/-/g;
  	$self->{'header'}->push_header($key => $attr->{content});
      } elsif ($tag eq 'base') {
  	return unless exists $attr->{href};
  	(my $base = $attr->{href}) =~ s/^\s+//; $base =~ s/\s+$//; # HTML5
  	$self->{'header'}->push_header('Content-Base' => $base);
      } elsif ($tag eq 'isindex') {
  	# This is a non-standard header.  Perhaps we should just ignore
  	# this element
  	$self->{'header'}->push_header(Isindex => $attr->{prompt} || '?');
      } elsif ($tag =~ /^(?:title|noscript|object|command)$/) {
  	# Just remember tag.  Initialize header when we see the end tag.
  	$self->{'tag'} = $tag;
      } elsif ($tag eq 'link') {
  	return unless exists $attr->{href};
  	# <link href="http:..." rel="xxx" rev="xxx" title="xxx">
  	my $href = delete($attr->{href});
  	$href =~ s/^\s+//; $href =~ s/\s+$//; # HTML5
  	my $h_val = "<$href>";
  	for (sort keys %{$attr}) {
  	    next if $_ eq "/";  # XHTML junk
  	    $h_val .= qq(; $_="$attr->{$_}");
  	}
  	$self->{'header'}->push_header(Link => $h_val);
      } elsif ($tag eq 'head' || $tag eq 'html') {
  	# ignore
      } else {
  	 # stop parsing
  	$self->eof;
      }
  }
  
  sub end
  {
      my($self, $tag) = @_;
      print "END[$tag]\n" if $DEBUG;
      $self->flush_text if $self->{'tag'};
      $self->eof if $tag eq 'head';
  }
  
  sub text
  {
      my($self, $text) = @_;
      print "TEXT[$text]\n" if $DEBUG;
      unless ($self->{first_chunk}) {
  	# drop Unicode BOM if found
  	if ($self->utf8_mode) {
  	    $text =~ s/^\xEF\xBB\xBF//;
  	}
  	else {
  	    $text =~ s/^\x{FEFF}//;
  	}
  	$self->{first_chunk}++;
      }
      my $tag = $self->{tag};
      if (!$tag && $text =~ /\S/) {
  	# Normal text means start of body
          $self->eof;
  	return;
      }
      return if $tag ne 'title';
      $self->{'text'} .= $text;
  }
  
  BEGIN {
      *utf8_mode = sub { 1 } unless HTML::Entities::UNICODE_SUPPORT;
  }
  
  1;
  
  __END__
  
  =back
  
  =head1 EXAMPLE
  
   $h = HTTP::Headers->new;
   $p = HTML::HeadParser->new($h);
   $p->parse(<<EOT);
   <title>Stupid example</title>
   <base href="http://www.linpro.no/lwp/">
   Normal text starts here.
   EOT
   undef $p;
   print $h->title;   # should print "Stupid example"
  
  =head1 SEE ALSO
  
  L<HTML::Parser>, L<HTTP::Headers>
  
  The C<HTTP::Headers> class is distributed as part of the
  I<libwww-perl> package.  If you don't have that distribution installed
  you need to provide the $header argument to the C<HTML::HeadParser>
  constructor with your own object that implements the documented
  protocol.
  
  =head1 COPYRIGHT
  
  Copyright 1996-2001 Gisle Aas. All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
X86_64-LINUX_HTML_HEADPARSER

$fatpacked{"x86_64-linux/HTML/LinkExtor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_LINKEXTOR';
  package HTML::LinkExtor;
  
  require HTML::Parser;
  @ISA = qw(HTML::Parser);
  $VERSION = "3.69";
  
  =head1 NAME
  
  HTML::LinkExtor - Extract links from an HTML document
  
  =head1 SYNOPSIS
  
   require HTML::LinkExtor;
   $p = HTML::LinkExtor->new(\&cb, "http://www.perl.org/");
   sub cb {
       my($tag, %links) = @_;
       print "$tag @{[%links]}\n";
   }
   $p->parse_file("index.html");
  
  =head1 DESCRIPTION
  
  I<HTML::LinkExtor> is an HTML parser that extracts links from an
  HTML document.  The I<HTML::LinkExtor> is a subclass of
  I<HTML::Parser>. This means that the document should be given to the
  parser by calling the $p->parse() or $p->parse_file() methods.
  
  =cut
  
  use strict;
  use HTML::Tagset ();
  
  # legacy (some applications grabs this hash directly)
  use vars qw(%LINK_ELEMENT);
  *LINK_ELEMENT = \%HTML::Tagset::linkElements;
  
  =over 4
  
  =item $p = HTML::LinkExtor->new
  
  =item $p = HTML::LinkExtor->new( $callback )
  
  =item $p = HTML::LinkExtor->new( $callback, $base )
  
  The constructor takes two optional arguments. The first is a reference
  to a callback routine. It will be called as links are found. If a
  callback is not provided, then links are just accumulated internally
  and can be retrieved by calling the $p->links() method.
  
  The $base argument is an optional base URL used to absolutize all URLs found.
  You need to have the I<URI> module installed if you provide $base.
  
  The callback is called with the lowercase tag name as first argument,
  and then all link attributes as separate key/value pairs.  All
  non-link attributes are removed.
  
  =cut
  
  sub new
  {
      my($class, $cb, $base) = @_;
      my $self = $class->SUPER::new(
                      start_h => ["_start_tag", "self,tagname,attr"],
  		    report_tags => [keys %HTML::Tagset::linkElements],
  	       );
      $self->{extractlink_cb} = $cb;
      if ($base) {
  	require URI;
  	$self->{extractlink_base} = URI->new($base);
      }
      $self;
  }
  
  sub _start_tag
  {
      my($self, $tag, $attr) = @_;
  
      my $base = $self->{extractlink_base};
      my $links = $HTML::Tagset::linkElements{$tag};
      $links = [$links] unless ref $links;
  
      my @links;
      my $a;
      for $a (@$links) {
  	next unless exists $attr->{$a};
  	(my $link = $attr->{$a}) =~ s/^\s+//; $link =~ s/\s+$//; # HTML5
  	push(@links, $a, $base ? URI->new($link, $base)->abs($base) : $link);
      }
      return unless @links;
      $self->_found_link($tag, @links);
  }
  
  sub _found_link
  {
      my $self = shift;
      my $cb = $self->{extractlink_cb};
      if ($cb) {
  	&$cb(@_);
      } else {
  	push(@{$self->{'links'}}, [@_]);
      }
  }
  
  =item $p->links
  
  Returns a list of all links found in the document.  The returned
  values will be anonymous arrays with the following elements:
  
    [$tag, $attr => $url1, $attr2 => $url2,...]
  
  The $p->links method will also truncate the internal link list.  This
  means that if the method is called twice without any parsing
  between them the second call will return an empty list.
  
  Also note that $p->links will always be empty if a callback routine
  was provided when the I<HTML::LinkExtor> was created.
  
  =cut
  
  sub links
  {
      my $self = shift;
      exists($self->{'links'}) ? @{delete $self->{'links'}} : ();
  }
  
  # We override the parse_file() method so that we can clear the links
  # before we start a new file.
  sub parse_file
  {
      my $self = shift;
      delete $self->{'links'};
      $self->SUPER::parse_file(@_);
  }
  
  =back
  
  =head1 EXAMPLE
  
  This is an example showing how you can extract links from a document
  received using LWP:
  
    use LWP::UserAgent;
    use HTML::LinkExtor;
    use URI::URL;
  
    $url = "http://www.perl.org/";  # for instance
    $ua = LWP::UserAgent->new;
  
    # Set up a callback that collect image links
    my @imgs = ();
    sub callback {
       my($tag, %attr) = @_;
       return if $tag ne 'img';  # we only look closer at <img ...>
       push(@imgs, values %attr);
    }
  
    # Make the parser.  Unfortunately, we don't know the base yet
    # (it might be different from $url)
    $p = HTML::LinkExtor->new(\&callback);
  
    # Request document and parse it as it arrives
    $res = $ua->request(HTTP::Request->new(GET => $url),
                        sub {$p->parse($_[0])});
  
    # Expand all image URLs to absolute ones
    my $base = $res->base;
    @imgs = map { $_ = url($_, $base)->abs; } @imgs;
  
    # Print them out
    print join("\n", @imgs), "\n";
  
  =head1 SEE ALSO
  
  L<HTML::Parser>, L<HTML::Tagset>, L<LWP>, L<URI::URL>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
X86_64-LINUX_HTML_LINKEXTOR

$fatpacked{"x86_64-linux/HTML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_PARSER';
  package HTML::Parser;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = "3.72";
  
  require HTML::Entities;
  
  require XSLoader;
  XSLoader::load('HTML::Parser', $VERSION);
  
  sub new
  {
      my $class = shift;
      my $self = bless {}, $class;
      return $self->init(@_);
  }
  
  
  sub init
  {
      my $self = shift;
      $self->_alloc_pstate;
  
      my %arg = @_;
      my $api_version = delete $arg{api_version} || (@_ ? 3 : 2);
      if ($api_version >= 4) {
  	require Carp;
  	Carp::croak("API version $api_version not supported " .
  		    "by HTML::Parser $VERSION");
      }
  
      if ($api_version < 3) {
  	# Set up method callbacks compatible with HTML-Parser-2.xx
  	$self->handler(text    => "text",    "self,text,is_cdata");
  	$self->handler(end     => "end",     "self,tagname,text");
  	$self->handler(process => "process", "self,token0,text");
  	$self->handler(start   => "start",
  		                  "self,tagname,attr,attrseq,text");
  
  	$self->handler(comment =>
  		       sub {
  			   my($self, $tokens) = @_;
  			   for (@$tokens) {
  			       $self->comment($_);
  			   }
  		       }, "self,tokens");
  
  	$self->handler(declaration =>
  		       sub {
  			   my $self = shift;
  			   $self->declaration(substr($_[0], 2, -1));
  		       }, "self,text");
      }
  
      if (my $h = delete $arg{handlers}) {
  	$h = {@$h} if ref($h) eq "ARRAY";
  	while (my($event, $cb) = each %$h) {
  	    $self->handler($event => @$cb);
  	}
      }
  
      # In the end we try to assume plain attribute or handler
      while (my($option, $val) = each %arg) {
  	if ($option =~ /^(\w+)_h$/) {
  	    $self->handler($1 => @$val);
  	}
          elsif ($option =~ /^(text|start|end|process|declaration|comment)$/) {
  	    require Carp;
  	    Carp::croak("Bad constructor option '$option'");
          }
  	else {
  	    $self->$option($val);
  	}
      }
  
      return $self;
  }
  
  
  sub parse_file
  {
      my($self, $file) = @_;
      my $opened;
      if (!ref($file) && ref(\$file) ne "GLOB") {
          # Assume $file is a filename
          local(*F);
          open(F, "<", $file) || return undef;
  	binmode(F);  # should we? good for byte counts
          $opened++;
          $file = *F;
      }
      my $chunk = '';
      while (read($file, $chunk, 512)) {
  	$self->parse($chunk) || last;
      }
      close($file) if $opened;
      $self->eof;
  }
  
  
  sub netscape_buggy_comment  # legacy
  {
      my $self = shift;
      require Carp;
      Carp::carp("netscape_buggy_comment() is deprecated.  " .
  	       "Please use the strict_comment() method instead");
      my $old = !$self->strict_comment;
      $self->strict_comment(!shift) if @_;
      return $old;
  }
  
  # set up method stubs
  sub text { }
  *start       = \&text;
  *end         = \&text;
  *comment     = \&text;
  *declaration = \&text;
  *process     = \&text;
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  HTML::Parser - HTML parser class
  
  =head1 SYNOPSIS
  
   use HTML::Parser ();
  
   # Create parser object
   $p = HTML::Parser->new( api_version => 3,
                           start_h => [\&start, "tagname, attr"],
                           end_h   => [\&end,   "tagname"],
                           marked_sections => 1,
                         );
  
   # Parse document text chunk by chunk
   $p->parse($chunk1);
   $p->parse($chunk2);
   #...
   $p->eof;                 # signal end of document
  
   # Parse directly from file
   $p->parse_file("foo.html");
   # or
   open(my $fh, "<:utf8", "foo.html") || die;
   $p->parse_file($fh);
  
  =head1 DESCRIPTION
  
  Objects of the C<HTML::Parser> class will recognize markup and
  separate it from plain text (alias data content) in HTML
  documents.  As different kinds of markup and text are recognized, the
  corresponding event handlers are invoked.
  
  C<HTML::Parser> is not a generic SGML parser.  We have tried to
  make it able to deal with the HTML that is actually "out there", and
  it normally parses as closely as possible to the way the popular web
  browsers do it instead of strictly following one of the many HTML
  specifications from W3C.  Where there is disagreement, there is often
  an option that you can enable to get the official behaviour.
  
  The document to be parsed may be supplied in arbitrary chunks.  This
  makes on-the-fly parsing as documents are received from the network
  possible.
  
  If event driven parsing does not feel right for your application, you
  might want to use C<HTML::PullParser>.  This is an C<HTML::Parser>
  subclass that allows a more conventional program structure.
  
  
  =head1 METHODS
  
  The following method is used to construct a new C<HTML::Parser> object:
  
  =over
  
  =item $p = HTML::Parser->new( %options_and_handlers )
  
  This class method creates a new C<HTML::Parser> object and
  returns it.  Key/value argument pairs may be provided to assign event
  handlers or initialize parser options.  The handlers and parser
  options can also be set or modified later by the method calls described below.
  
  If a top level key is in the form "<event>_h" (e.g., "text_h") then it
  assigns a handler to that event, otherwise it initializes a parser
  option. The event handler specification value must be an array
  reference.  Multiple handlers may also be assigned with the 'handlers
  => [%handlers]' option.  See examples below.
  
  If new() is called without any arguments, it will create a parser that
  uses callback methods compatible with version 2 of C<HTML::Parser>.
  See the section on "version 2 compatibility" below for details.
  
  The special constructor option 'api_version => 2' can be used to
  initialize version 2 callbacks while still setting other options and
  handlers.  The 'api_version => 3' option can be used if you don't want
  to set any options and don't want to fall back to v2 compatible
  mode.
  
  Examples:
  
   $p = HTML::Parser->new(api_version => 3,
                          text_h => [ sub {...}, "dtext" ]);
  
  This creates a new parser object with a text event handler subroutine
  that receives the original text with general entities decoded.
  
   $p = HTML::Parser->new(api_version => 3,
  			start_h => [ 'my_start', "self,tokens" ]);
  
  This creates a new parser object with a start event handler method
  that receives the $p and the tokens array.
  
   $p = HTML::Parser->new(api_version => 3,
  		        handlers => { text => [\@array, "event,text"],
                                        comment => [\@array, "event,text"],
                                      });
  
  This creates a new parser object that stores the event type and the
  original text in @array for text and comment events.
  
  =back
  
  The following methods feed the HTML document
  to the C<HTML::Parser> object:
  
  =over
  
  =item $p->parse( $string )
  
  Parse $string as the next chunk of the HTML document.  Handlers invoked should
  not attempt to modify the $string in-place until $p->parse returns.
  
  If an invoked event handler aborts parsing by calling $p->eof, then $p->parse()
  will return a FALSE value.  Otherwise the return value is a reference to the
  parser object ($p).
  
  =item $p->parse( $code_ref )
  
  If a code reference is passed as the argument to be parsed, then the
  chunks to be parsed are obtained by invoking this function repeatedly.
  Parsing continues until the function returns an empty (or undefined)
  result.  When this happens $p->eof is automatically signaled.
  
  Parsing will also abort if one of the event handlers calls $p->eof.
  
  The effect of this is the same as:
  
   while (1) {
      my $chunk = &$code_ref();
      if (!defined($chunk) || !length($chunk)) {
          $p->eof;
          return $p;
      }
      $p->parse($chunk) || return undef;
   }
  
  But it is more efficient as this loop runs internally in XS code.
  
  =item $p->parse_file( $file )
  
  Parse text directly from a file.  The $file argument can be a
  filename, an open file handle, or a reference to an open file
  handle.
  
  If $file contains a filename and the file can't be opened, then the
  method returns an undefined value and $! tells why it failed.
  Otherwise the return value is a reference to the parser object.
  
  If a file handle is passed as the $file argument, then the file will
  normally be read until EOF, but not closed.
  
  If an invoked event handler aborts parsing by calling $p->eof,
  then $p->parse_file() may not have read the entire file.
  
  On systems with multi-byte line terminators, the values passed for the
  offset and length argspecs may be too low if parse_file() is called on
  a file handle that is not in binary mode.
  
  If a filename is passed in, then parse_file() will open the file in
  binary mode.
  
  =item $p->eof
  
  Signals the end of the HTML document.  Calling the $p->eof method
  outside a handler callback will flush any remaining buffered text
  (which triggers the C<text> event if there is any remaining text).
  
  Calling $p->eof inside a handler will terminate parsing at that point
  and cause $p->parse to return a FALSE value.  This also terminates
  parsing by $p->parse_file().
  
  After $p->eof has been called, the parse() and parse_file() methods
  can be invoked to feed new documents with the parser object.
  
  The return value from eof() is a reference to the parser object.
  
  =back
  
  
  Most parser options are controlled by boolean attributes.
  Each boolean attribute is enabled by calling the corresponding method
  with a TRUE argument and disabled with a FALSE argument.  The
  attribute value is left unchanged if no argument is given.  The return
  value from each method is the old attribute value.
  
  Methods that can be used to get and/or set parser options are:
  
  =over
  
  =item $p->attr_encoded
  
  =item $p->attr_encoded( $bool )
  
  By default, the C<attr> and C<@attr> argspecs will have general
  entities for attribute values decoded.  Enabling this attribute leaves
  entities alone.
  
  =item $p->backquote
  
  =item $p->backquote( $bool )
  
  By default, only ' and " are recognized as quote characters around
  attribute values.  MSIE also recognizes backquotes for some reason.
  Enabling this attribute provides compatibility with this behaviour.
  
  =item $p->boolean_attribute_value( $val )
  
  This method sets the value reported for boolean attributes inside HTML
  start tags.  By default, the name of the attribute is also used as its
  value.  This affects the values reported for C<tokens> and C<attr>
  argspecs.
  
  =item $p->case_sensitive
  
  =item $p->case_sensitive( $bool )
  
  By default, tagnames and attribute names are down-cased.  Enabling this
  attribute leaves them as found in the HTML source document.
  
  =item $p->closing_plaintext
  
  =item $p->closing_plaintext( $bool )
  
  By default, "plaintext" element can never be closed. Everything up to
  the end of the document is parsed in CDATA mode.  This historical
  behaviour is what at least MSIE does.  Enabling this attribute makes
  closing "</plaintext>" tag effective and the parsing process will resume
  after seeing this tag.  This emulates early gecko-based browsers.
  
  =item $p->empty_element_tags
  
  =item $p->empty_element_tags( $bool )
  
  By default, empty element tags are not recognized as such and the "/"
  before ">" is just treated like a normal name character (unless
  C<strict_names> is enabled).  Enabling this attribute make
  C<HTML::Parser> recognize these tags.
  
  Empty element tags look like start tags, but end with the character
  sequence "/>" instead of ">".  When recognized by C<HTML::Parser> they
  cause an artificial end event in addition to the start event.  The
  C<text> for the artificial end event will be empty and the C<tokenpos>
  array will be undefined even though the token array will have one
  element containing the tag name.
  
  =item $p->marked_sections
  
  =item $p->marked_sections( $bool )
  
  By default, section markings like <![CDATA[...]]> are treated like
  ordinary text.  When this attribute is enabled section markings are
  honoured.
  
  There are currently no events associated with the marked section
  markup, but the text can be returned as C<skipped_text>.
  
  =item $p->strict_comment
  
  =item $p->strict_comment( $bool )
  
  By default, comments are terminated by the first occurrence of "-->".
  This is the behaviour of most popular browsers (like Mozilla, Opera and
  MSIE), but it is not correct according to the official HTML
  standard.  Officially, you need an even number of "--" tokens before
  the closing ">" is recognized and there may not be anything but
  whitespace between an even and an odd "--".
  
  The official behaviour is enabled by enabling this attribute.
  
  Enabling of 'strict_comment' also disables recognizing these forms as
  comments:
  
    </ comment>
    <! comment>
  
  
  =item $p->strict_end
  
  =item $p->strict_end( $bool )
  
  By default, attributes and other junk are allowed to be present on end tags in a
  manner that emulates MSIE's behaviour.
  
  The official behaviour is enabled with this attribute.  If enabled,
  only whitespace is allowed between the tagname and the final ">".
  
  =item $p->strict_names
  
  =item $p->strict_names( $bool )
  
  By default, almost anything is allowed in tag and attribute names.
  This is the behaviour of most popular browsers and allows us to parse
  some broken tags with invalid attribute values like:
  
     <IMG SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0>
  
  By default, "LIST]" is parsed as a boolean attribute, not as
  part of the ALT value as was clearly intended.  This is also what
  Mozilla sees.
  
  The official behaviour is enabled by enabling this attribute.  If
  enabled, it will cause the tag above to be reported as text
  since "LIST]" is not a legal attribute name.
  
  =item $p->unbroken_text
  
  =item $p->unbroken_text( $bool )
  
  By default, blocks of text are given to the text handler as soon as
  possible (but the parser takes care always to break text at a
  boundary between whitespace and non-whitespace so single words and
  entities can always be decoded safely).  This might create breaks that
  make it hard to do transformations on the text. When this attribute is
  enabled, blocks of text are always reported in one piece.  This will
  delay the text event until the following (non-text) event has been
  recognized by the parser.
  
  Note that the C<offset> argspec will give you the offset of the first
  segment of text and C<length> is the combined length of the segments.
  Since there might be ignored tags in between, these numbers can't be
  used to directly index in the original document file.
  
  =item $p->utf8_mode
  
  =item $p->utf8_mode( $bool )
  
  Enable this option when parsing raw undecoded UTF-8.  This tells the
  parser that the entities expanded for strings reported by C<attr>,
  C<@attr> and C<dtext> should be expanded as decoded UTF-8 so they end
  up compatible with the surrounding text.
  
  If C<utf8_mode> is enabled then it is an error to pass strings
  containing characters with code above 255 to the parse() method, and
  the parse() method will croak if you try.
  
  Example: The Unicode character "\x{2665}" is "\xE2\x99\xA5" when UTF-8
  encoded.  The character can also be represented by the entity
  "&hearts;" or "&#x2665".  If we feed the parser:
  
    $p->parse("\xE2\x99\xA5&hearts;");
  
  then C<dtext> will be reported as "\xE2\x99\xA5\x{2665}" without
  C<utf8_mode> enabled, but as "\xE2\x99\xA5\xE2\x99\xA5" when enabled.
  The later string is what you want.
  
  This option is only available with perl-5.8 or better.
  
  =item $p->xml_mode
  
  =item $p->xml_mode( $bool )
  
  Enabling this attribute changes the parser to allow some XML
  constructs.  This enables the behaviour controlled by individually by
  the C<case_sensitive>, C<empty_element_tags>, C<strict_names> and
  C<xml_pic> attributes and also suppresses special treatment of
  elements that are parsed as CDATA for HTML.
  
  =item $p->xml_pic
  
  =item $p->xml_pic( $bool )
  
  By default, I<processing instructions> are terminated by ">". When
  this attribute is enabled, processing instructions are terminated by
  "?>" instead.
  
  =back
  
  As markup and text is recognized, handlers are invoked.  The following
  method is used to set up handlers for different events:
  
  =over
  
  =item $p->handler( event => \&subroutine, $argspec )
  
  =item $p->handler( event => $method_name, $argspec )
  
  =item $p->handler( event => \@accum, $argspec )
  
  =item $p->handler( event => "" );
  
  =item $p->handler( event => undef );
  
  =item $p->handler( event );
  
  This method assigns a subroutine, method, or array to handle an event.
  
  Event is one of C<text>, C<start>, C<end>, C<declaration>, C<comment>,
  C<process>, C<start_document>, C<end_document> or C<default>.
  
  The C<\&subroutine> is a reference to a subroutine which is called to handle
  the event.
  
  The C<$method_name> is the name of a method of $p which is called to handle
  the event.
  
  The C<@accum> is an array that will hold the event information as
  sub-arrays.
  
  If the second argument is "", the event is ignored.
  If it is undef, the default handler is invoked for the event.
  
  The C<$argspec> is a string that describes the information to be reported
  for the event.  Any requested information that does not apply to a
  specific event is passed as C<undef>.  If argspec is omitted, then it
  is left unchanged.
  
  The return value from $p->handler is the old callback routine or a
  reference to the accumulator array.
  
  Any return values from handler callback routines/methods are always
  ignored.  A handler callback can request parsing to be aborted by
  invoking the $p->eof method.  A handler callback is not allowed to
  invoke the $p->parse() or $p->parse_file() method.  An exception will
  be raised if it tries.
  
  Examples:
  
      $p->handler(start =>  "start", 'self, attr, attrseq, text' );
  
  This causes the "start" method of object $p to be called for 'start' events.
  The callback signature is $p->start(\%attr, \@attr_seq, $text).
  
      $p->handler(start =>  \&start, 'attr, attrseq, text' );
  
  This causes subroutine start() to be called for 'start' events.
  The callback signature is start(\%attr, \@attr_seq, $text).
  
      $p->handler(start =>  \@accum, '"S", attr, attrseq, text' );
  
  This causes 'start' event information to be saved in @accum.
  The array elements will be ['S', \%attr, \@attr_seq, $text].
  
     $p->handler(start => "");
  
  This causes 'start' events to be ignored.  It also suppresses
  invocations of any default handler for start events.  It is in most
  cases equivalent to $p->handler(start => sub {}), but is more
  efficient.  It is different from the empty-sub-handler in that
  C<skipped_text> is not reset by it.
  
     $p->handler(start => undef);
  
  This causes no handler to be associated with start events.
  If there is a default handler it will be invoked.
  
  =back
  
  Filters based on tags can be set up to limit the number of events
  reported.  The main bottleneck during parsing is often the huge number
  of callbacks made from the parser.  Applying filters can improve
  performance significantly.
  
  The following methods control filters:
  
  =over
  
  =item $p->ignore_elements( @tags )
  
  Both the C<start> event and the C<end> event as well as any events that
  would be reported in between are suppressed.  The ignored elements can
  contain nested occurrences of itself.  Example:
  
     $p->ignore_elements(qw(script style));
  
  The C<script> and C<style> tags will always nest properly since their
  content is parsed in CDATA mode.  For most other tags
  C<ignore_elements> must be used with caution since HTML is often not
  I<well formed>.
  
  =item $p->ignore_tags( @tags )
  
  Any C<start> and C<end> events involving any of the tags given are
  suppressed.  To reset the filter (i.e. don't suppress any C<start> and
  C<end> events), call C<ignore_tags> without an argument.
  
  =item $p->report_tags( @tags )
  
  Any C<start> and C<end> events involving any of the tags I<not> given
  are suppressed.  To reset the filter (i.e. report all C<start> and
  C<end> events), call C<report_tags> without an argument.
  
  =back
  
  Internally, the system has two filter lists, one for C<report_tags>
  and one for C<ignore_tags>, and both filters are applied.  This
  effectively gives C<ignore_tags> precedence over C<report_tags>.
  
  Examples:
  
     $p->ignore_tags(qw(style));
     $p->report_tags(qw(script style));
  
  results in only C<script> events being reported.
  
  =head2 Argspec
  
  Argspec is a string containing a comma-separated list that describes
  the information reported by the event.  The following argspec
  identifier names can be used:
  
  =over
  
  =item C<attr>
  
  Attr causes a reference to a hash of attribute name/value pairs to be
  passed.
  
  Boolean attributes' values are either the value set by
  $p->boolean_attribute_value, or the attribute name if no value has been
  set by $p->boolean_attribute_value.
  
  This passes undef except for C<start> events.
  
  Unless C<xml_mode> or C<case_sensitive> is enabled, the attribute
  names are forced to lower case.
  
  General entities are decoded in the attribute values and
  one layer of matching quotes enclosing the attribute values is removed.
  
  The Unicode character set is assumed for entity decoding.
  
  =item C<@attr>
  
  Basically the same as C<attr>, but keys and values are passed as
  individual arguments and the original sequence of the attributes is
  kept.  The parameters passed will be the same as the @attr calculated
  here:
  
     @attr = map { $_ => $attr->{$_} } @$attrseq;
  
  assuming $attr and $attrseq here are the hash and array passed as the
  result of C<attr> and C<attrseq> argspecs.
  
  This passes no values for events besides C<start>.
  
  =item C<attrseq>
  
  Attrseq causes a reference to an array of attribute names to be
  passed.  This can be useful if you want to walk the C<attr> hash in
  the original sequence.
  
  This passes undef except for C<start> events.
  
  Unless C<xml_mode> or C<case_sensitive> is enabled, the attribute
  names are forced to lower case.
  
  =item C<column>
  
  Column causes the column number of the start of the event to be passed.
  The first column on a line is 0.
  
  =item C<dtext>
  
  Dtext causes the decoded text to be passed.  General entities are
  automatically decoded unless the event was inside a CDATA section or
  was between literal start and end tags (C<script>, C<style>,
  C<xmp>, C<iframe>, C<title>, C<textarea> and C<plaintext>).
  
  The Unicode character set is assumed for entity decoding.  With Perl
  version 5.6 or earlier only the Latin-1 range is supported, and
  entities for characters outside the range 0..255 are left unchanged.
  
  This passes undef except for C<text> events.
  
  =item C<event>
  
  Event causes the event name to be passed.
  
  The event name is one of C<text>, C<start>, C<end>, C<declaration>,
  C<comment>, C<process>, C<start_document> or C<end_document>.
  
  =item C<is_cdata>
  
  Is_cdata causes a TRUE value to be passed if the event is inside a CDATA
  section or between literal start and end tags (C<script>,
  C<style>, C<xmp>, C<iframe>, C<title>, C<textarea> and C<plaintext>).
  
  if the flag is FALSE for a text event, then you should normally
  either use C<dtext> or decode the entities yourself before the text is
  processed further.
  
  =item C<length>
  
  Length causes the number of bytes of the source text of the event to
  be passed.
  
  =item C<line>
  
  Line causes the line number of the start of the event to be passed.
  The first line in the document is 1.  Line counting doesn't start
  until at least one handler requests this value to be reported.
  
  =item C<offset>
  
  Offset causes the byte position in the HTML document of the start of
  the event to be passed.  The first byte in the document has offset 0.
  
  =item C<offset_end>
  
  Offset_end causes the byte position in the HTML document of the end of
  the event to be passed.  This is the same as C<offset> + C<length>.
  
  =item C<self>
  
  Self causes the current object to be passed to the handler.  If the
  handler is a method, this must be the first element in the argspec.
  
  An alternative to passing self as an argspec is to register closures
  that capture $self by themselves as handlers.  Unfortunately this
  creates circular references which prevent the HTML::Parser object
  from being garbage collected.  Using the C<self> argspec avoids this
  problem.
  
  =item C<skipped_text>
  
  Skipped_text returns the concatenated text of all the events that have
  been skipped since the last time an event was reported.  Events might
  be skipped because no handler is registered for them or because some
  filter applies.  Skipped text also includes marked section markup,
  since there are no events that can catch it.
  
  If an C<"">-handler is registered for an event, then the text for this
  event is not included in C<skipped_text>.  Skipped text both before
  and after the C<"">-event is included in the next reported
  C<skipped_text>.
  
  =item C<tag>
  
  Same as C<tagname>, but prefixed with "/" if it belongs to an C<end>
  event and "!" for a declaration.  The C<tag> does not have any prefix
  for C<start> events, and is in this case identical to C<tagname>.
  
  =item C<tagname>
  
  This is the element name (or I<generic identifier> in SGML jargon) for
  start and end tags.  Since HTML is case insensitive, this name is
  forced to lower case to ease string matching.
  
  Since XML is case sensitive, the tagname case is not changed when
  C<xml_mode> is enabled.  The same happens if the C<case_sensitive> attribute
  is set.
  
  The declaration type of declaration elements is also passed as a tagname,
  even if that is a bit strange.
  In fact, in the current implementation tagname is
  identical to C<token0> except that the name may be forced to lower case.
  
  =item C<token0>
  
  Token0 causes the original text of the first token string to be
  passed.  This should always be the same as $tokens->[0].
  
  For C<declaration> events, this is the declaration type.
  
  For C<start> and C<end> events, this is the tag name.
  
  For C<process> and non-strict C<comment> events, this is everything
  inside the tag.
  
  This passes undef if there are no tokens in the event.
  
  =item C<tokenpos>
  
  Tokenpos causes a reference to an array of token positions to be
  passed.  For each string that appears in C<tokens>, this array
  contains two numbers.  The first number is the offset of the start of
  the token in the original C<text> and the second number is the length
  of the token.
  
  Boolean attributes in a C<start> event will have (0,0) for the
  attribute value offset and length.
  
  This passes undef if there are no tokens in the event (e.g., C<text>)
  and for artificial C<end> events triggered by empty element tags.
  
  If you are using these offsets and lengths to modify C<text>, you
  should either work from right to left, or be very careful to calculate
  the changes to the offsets.
  
  =item C<tokens>
  
  Tokens causes a reference to an array of token strings to be passed.
  The strings are exactly as they were found in the original text,
  no decoding or case changes are applied.
  
  For C<declaration> events, the array contains each word, comment, and
  delimited string starting with the declaration type.
  
  For C<comment> events, this contains each sub-comment.  If
  $p->strict_comments is disabled, there will be only one sub-comment.
  
  For C<start> events, this contains the original tag name followed by
  the attribute name/value pairs.  The values of boolean attributes will
  be either the value set by $p->boolean_attribute_value, or the
  attribute name if no value has been set by
  $p->boolean_attribute_value.
  
  For C<end> events, this contains the original tag name (always one token).
  
  For C<process> events, this contains the process instructions (always one
  token).
  
  This passes C<undef> for C<text> events.
  
  =item C<text>
  
  Text causes the source text (including markup element delimiters) to be
  passed.
  
  =item C<undef>
  
  Pass an undefined value.  Useful as padding where the same handler
  routine is registered for multiple events.
  
  =item C<'...'>
  
  A literal string of 0 to 255 characters enclosed
  in single (') or double (") quotes is passed as entered.
  
  =back
  
  The whole argspec string can be wrapped up in C<'@{...}'> to signal
  that the resulting event array should be flattened.  This only makes a
  difference if an array reference is used as the handler target.
  Consider this example:
  
     $p->handler(text => [], 'text');
     $p->handler(text => [], '@{text}']);
  
  With two text events; C<"foo">, C<"bar">; then the first example will end
  up with [["foo"], ["bar"]] and the second with ["foo", "bar"] in
  the handler target array.
  
  
  =head2 Events
  
  Handlers for the following events can be registered:
  
  =over
  
  =item C<comment>
  
  This event is triggered when a markup comment is recognized.
  
  Example:
  
    <!-- This is a comment -- -- So is this -->
  
  =item C<declaration>
  
  This event is triggered when a I<markup declaration> is recognized.
  
  For typical HTML documents, the only declaration you are
  likely to find is <!DOCTYPE ...>.
  
  Example:
  
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
  
  DTDs inside <!DOCTYPE ...> will confuse HTML::Parser.
  
  =item C<default>
  
  This event is triggered for events that do not have a specific
  handler.  You can set up a handler for this event to catch stuff you
  did not want to catch explicitly.
  
  =item C<end>
  
  This event is triggered when an end tag is recognized.
  
  Example:
  
    </A>
  
  =item C<end_document>
  
  This event is triggered when $p->eof is called and after any remaining
  text is flushed.  There is no document text associated with this event.
  
  =item C<process>
  
  This event is triggered when a processing instructions markup is
  recognized.
  
  The format and content of processing instructions are system and
  application dependent.
  
  Examples:
  
    <? HTML processing instructions >
    <? XML processing instructions ?>
  
  =item C<start>
  
  This event is triggered when a start tag is recognized.
  
  Example:
  
    <A HREF="http://www.perl.com/">
  
  =item C<start_document>
  
  This event is triggered before any other events for a new document.  A
  handler for it can be used to initialize stuff.  There is no document
  text associated with this event.
  
  =item C<text>
  
  This event is triggered when plain text (characters) is recognized.
  The text may contain multiple lines.  A sequence of text may be broken
  between several text events unless $p->unbroken_text is enabled.
  
  The parser will make sure that it does not break a word or a sequence
  of whitespace between two text events.
  
  =back
  
  =head2 Unicode
  
  C<HTML::Parser> can parse Unicode strings when running under
  perl-5.8 or better.  If Unicode is passed to $p->parse() then chunks
  of Unicode will be reported to the handlers.  The offset and length
  argspecs will also report their position in terms of characters.
  
  It is safe to parse raw undecoded UTF-8 if you either avoid decoding
  entities and make sure to not use I<argspecs> that do, or enable the
  C<utf8_mode> for the parser.  Parsing of undecoded UTF-8 might be
  useful when parsing from a file where you need the reported offsets
  and lengths to match the byte offsets in the file.
  
  If a filename is passed to $p->parse_file() then the file will be read
  in binary mode.  This will be fine if the file contains only ASCII or
  Latin-1 characters.  If the file contains UTF-8 encoded text then care
  must be taken when decoding entities as described in the previous
  paragraph, but better is to open the file with the UTF-8 layer so that
  it is decoded properly:
  
     open(my $fh, "<:utf8", "index.html") || die "...: $!";
     $p->parse_file($fh);
  
  If the file contains text encoded in a charset besides ASCII, Latin-1
  or UTF-8 then decoding will always be needed.
  
  =head1 VERSION 2 COMPATIBILITY
  
  When an C<HTML::Parser> object is constructed with no arguments, a set
  of handlers is automatically provided that is compatible with the old
  HTML::Parser version 2 callback methods.
  
  This is equivalent to the following method calls:
  
     $p->handler(start   => "start",   "self, tagname, attr, attrseq, text");
     $p->handler(end     => "end",     "self, tagname, text");
     $p->handler(text    => "text",    "self, text, is_cdata");
     $p->handler(process => "process", "self, token0, text");
     $p->handler(comment =>
               sub {
  		 my($self, $tokens) = @_;
  		 for (@$tokens) {$self->comment($_);}},
               "self, tokens");
     $p->handler(declaration =>
               sub {
  		 my $self = shift;
  		 $self->declaration(substr($_[0], 2, -1));},
               "self, text");
  
  Setting up these handlers can also be requested with the "api_version =>
  2" constructor option.
  
  =head1 SUBCLASSING
  
  The C<HTML::Parser> class is subclassable.  Parser objects are plain
  hashes and C<HTML::Parser> reserves only hash keys that start with
  "_hparser".  The parser state can be set up by invoking the init()
  method, which takes the same arguments as new().
  
  =head1 EXAMPLES
  
  The first simple example shows how you might strip out comments from
  an HTML document.  We achieve this by setting up a comment handler that
  does nothing and a default handler that will print out anything else:
  
    use HTML::Parser;
    HTML::Parser->new(default_h => [sub { print shift }, 'text'],
                      comment_h => [""],
                     )->parse_file(shift || die) || die $!;
  
  An alternative implementation is:
  
    use HTML::Parser;
    HTML::Parser->new(end_document_h => [sub { print shift },
                                         'skipped_text'],
                      comment_h      => [""],
                     )->parse_file(shift || die) || die $!;
  
  This will in most cases be much more efficient since only a single
  callback will be made.
  
  The next example prints out the text that is inside the <title>
  element of an HTML document.  Here we start by setting up a start
  handler.  When it sees the title start tag it enables a text handler
  that prints any text found and an end handler that will terminate
  parsing as soon as the title end tag is seen:
  
    use HTML::Parser ();
  
    sub start_handler
    {
      return if shift ne "title";
      my $self = shift;
      $self->handler(text => sub { print shift }, "dtext");
      $self->handler(end  => sub { shift->eof if shift eq "title"; },
  		           "tagname,self");
    }
  
    my $p = HTML::Parser->new(api_version => 3);
    $p->handler( start => \&start_handler, "tagname,self");
    $p->parse_file(shift || die) || die $!;
    print "\n";
  
  More examples are found in the F<eg/> directory of the C<HTML-Parser>
  distribution: the program C<hrefsub> shows how you can edit all links
  found in a document; the program C<htextsub> shows how to edit the text only; the
  program C<hstrip> shows how you can strip out certain tags/elements
  and/or attributes; and the program C<htext> show how to obtain the
  plain text, but not any script/style content.
  
  You can browse the F<eg/> directory online from the I<[Browse]> link on
  the http://search.cpan.org/~gaas/HTML-Parser/ page.
  
  =head1 BUGS
  
  The <style> and <script> sections do not end with the first "</", but
  need the complete corresponding end tag.  The standard behaviour is
  not really practical.
  
  When the I<strict_comment> option is enabled, we still recognize
  comments where there is something other than whitespace between even
  and odd "--" markers.
  
  Once $p->boolean_attribute_value has been set, there is no way to
  restore the default behaviour.
  
  There is currently no way to get both quote characters
  into the same literal argspec.
  
  Empty tags, e.g. "<>" and "</>", are not recognized.  SGML allows them
  to repeat the previous start tag or close the previous start tag
  respectively.
  
  NET tags, e.g. "code/.../" are not recognized.  This is SGML
  shorthand for "<code>...</code>".
  
  Unclosed start or end tags, e.g. "<tt<b>...</b</tt>" are not
  recognized.
  
  =head1 DIAGNOSTICS
  
  The following messages may be produced by HTML::Parser.  The notation
  in this listing is the same as used in L<perldiag>:
  
  =over
  
  =item Not a reference to a hash
  
  (F) The object blessed into or subclassed from HTML::Parser is not a
  hash as required by the HTML::Parser methods.
  
  =item Bad signature in parser state object at %p
  
  (F) The _hparser_xs_state element does not refer to a valid state structure.
  Something must have changed the internal value
  stored in this hash element, or the memory has been overwritten.
  
  =item _hparser_xs_state element is not a reference
  
  (F) The _hparser_xs_state element has been destroyed.
  
  =item Can't find '_hparser_xs_state' element in HTML::Parser hash
  
  (F) The _hparser_xs_state element is missing from the parser hash.
  It was either deleted, or not created when the object was created.
  
  =item API version %s not supported by HTML::Parser %s
  
  (F) The constructor option 'api_version' with an argument greater than
  or equal to 4 is reserved for future extensions.
  
  =item Bad constructor option '%s'
  
  (F) An unknown constructor option key was passed to the new() or
  init() methods.
  
  =item Parse loop not allowed
  
  (F) A handler invoked the parse() or parse_file() method.
  This is not permitted.
  
  =item marked sections not supported
  
  (F) The $p->marked_sections() method was invoked in a HTML::Parser
  module that was compiled without support for marked sections.
  
  =item Unknown boolean attribute (%d)
  
  (F) Something is wrong with the internal logic that set up aliases for
  boolean attributes.
  
  =item Only code or array references allowed as handler
  
  (F) The second argument for $p->handler must be either a subroutine
  reference, then name of a subroutine or method, or a reference to an
  array.
  
  =item No handler for %s events
  
  (F) The first argument to $p->handler must be a valid event name; i.e. one
  of "start", "end", "text", "process", "declaration" or "comment".
  
  =item Unrecognized identifier %s in argspec
  
  (F) The identifier is not a known argspec name.
  Use one of the names mentioned in the argspec section above.
  
  =item Literal string is longer than 255 chars in argspec
  
  (F) The current implementation limits the length of literals in
  an argspec to 255 characters.  Make the literal shorter.
  
  =item Backslash reserved for literal string in argspec
  
  (F) The backslash character "\" is not allowed in argspec literals.
  It is reserved to permit quoting inside a literal in a later version.
  
  =item Unterminated literal string in argspec
  
  (F) The terminating quote character for a literal was not found.
  
  =item Bad argspec (%s)
  
  (F) Only identifier names, literals, spaces and commas
  are allowed in argspecs.
  
  =item Missing comma separator in argspec
  
  (F) Identifiers in an argspec must be separated with ",".
  
  =item Parsing of undecoded UTF-8 will give garbage when decoding entities
  
  (W) The first chunk parsed appears to contain undecoded UTF-8 and one
  or more argspecs that decode entities are used for the callback
  handlers.
  
  The result of decoding will be a mix of encoded and decoded characters
  for any entities that expand to characters with code above 127.  This
  is not a good thing.
  
  The recommended solution is to apply Encode::decode_utf8() on the data before
  feeding it to the $p->parse().  For $p->parse_file() pass a file that has been
  opened in ":utf8" mode.
  
  The alternative solution is to enable the C<utf8_mode> and not decode before
  passing strings to $p->parse().  The parser can process raw undecoded UTF-8
  sanely if the C<utf8_mode> is enabled, or if the "attr", "@attr" or "dtext"
  argspecs are avoided.
  
  =item Parsing string decoded with wrong endianness
  
  (W) The first character in the document is U+FFFE.  This is not a
  legal Unicode character but a byte swapped BOM.  The result of parsing
  will likely be garbage.
  
  =item Parsing of undecoded UTF-32
  
  (W) The parser found the Unicode UTF-32 BOM signature at the start
  of the document.  The result of parsing will likely be garbage.
  
  =item Parsing of undecoded UTF-16
  
  (W) The parser found the Unicode UTF-16 BOM signature at the start of
  the document.  The result of parsing will likely be garbage.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTML::Entities>, L<HTML::PullParser>, L<HTML::TokeParser>, L<HTML::HeadParser>,
  L<HTML::LinkExtor>, L<HTML::Form>
  
  L<HTML::TreeBuilder> (part of the I<HTML-Tree> distribution)
  
  L<http://www.w3.org/TR/html4/>
  
  More information about marked sections and processing instructions may
  be found at L<http://www.is-thought.co.uk/book/sgml-8.htm>.
  
  =head1 COPYRIGHT
  
   Copyright 1996-2016 Gisle Aas. All rights reserved.
   Copyright 1999-2000 Michael A. Chase.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_HTML_PARSER

$fatpacked{"x86_64-linux/HTML/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_PULLPARSER';
  package HTML::PullParser;
  
  require HTML::Parser;
  @ISA=qw(HTML::Parser);
  $VERSION = "3.57";
  
  use strict;
  use Carp ();
  
  sub new
  {
      my($class, %cnf) = @_;
  
      # Construct argspecs for the various events
      my %argspec;
      for (qw(start end text declaration comment process default)) {
  	my $tmp = delete $cnf{$_};
  	next unless defined $tmp;
  	$argspec{$_} = $tmp;
      }
      Carp::croak("Info not collected for any events")
  	  unless %argspec;
  
      my $file = delete $cnf{file};
      my $doc  = delete $cnf{doc};
      Carp::croak("Can't parse from both 'doc' and 'file' at the same time")
  	  if defined($file) && defined($doc);
      Carp::croak("No 'doc' or 'file' given to parse from")
  	  unless defined($file) || defined($doc);
  
      # Create object
      $cnf{api_version} = 3;
      my $self = $class->SUPER::new(%cnf);
  
      my $accum = $self->{pullparser_accum} = [];
      while (my($event, $argspec) = each %argspec) {
  	$self->SUPER::handler($event => $accum, $argspec);
      }
  
      if (defined $doc) {
  	$self->{pullparser_str_ref} = ref($doc) ? $doc : \$doc;
  	$self->{pullparser_str_pos} = 0;
      }
      else {
  	if (!ref($file) && ref(\$file) ne "GLOB") {
  	    require IO::File;
  	    $file = IO::File->new($file, "r") || return;
  	}
  
  	$self->{pullparser_file} = $file;
      }
      $self;
  }
  
  
  sub handler
  {
      Carp::croak("Can't set handlers for HTML::PullParser");
  }
  
  
  sub get_token
  {
      my $self = shift;
      while (!@{$self->{pullparser_accum}} && !$self->{pullparser_eof}) {
  	if (my $f = $self->{pullparser_file}) {
  	    # must try to parse more from the file
  	    my $buf;
  	    if (read($f, $buf, 512)) {
  		$self->parse($buf);
  	    } else {
  		$self->eof;
  		$self->{pullparser_eof}++;
  		delete $self->{pullparser_file};
  	    }
  	}
  	elsif (my $sref = $self->{pullparser_str_ref}) {
  	    # must try to parse more from the scalar
  	    my $pos = $self->{pullparser_str_pos};
  	    my $chunk = substr($$sref, $pos, 512);
  	    $self->parse($chunk);
  	    $pos += length($chunk);
  	    if ($pos < length($$sref)) {
  		$self->{pullparser_str_pos} = $pos;
  	    }
  	    else {
  		$self->eof;
  		$self->{pullparser_eof}++;
  		delete $self->{pullparser_str_ref};
  		delete $self->{pullparser_str_pos};
  	    }
  	}
  	else {
  	    die;
  	}
      }
      shift @{$self->{pullparser_accum}};
  }
  
  
  sub unget_token
  {
      my $self = shift;
      unshift @{$self->{pullparser_accum}}, @_;
      $self;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTML::PullParser - Alternative HTML::Parser interface
  
  =head1 SYNOPSIS
  
   use HTML::PullParser;
  
   $p = HTML::PullParser->new(file => "index.html",
                              start => 'event, tagname, @attr',
                              end   => 'event, tagname',
                              ignore_elements => [qw(script style)],
                             ) || die "Can't open: $!";
   while (my $token = $p->get_token) {
       #...do something with $token
   }
  
  =head1 DESCRIPTION
  
  The HTML::PullParser is an alternative interface to the HTML::Parser class.
  It basically turns the HTML::Parser inside out.  You associate a file
  (or any IO::Handle object or string) with the parser at construction time and
  then repeatedly call $parser->get_token to obtain the tags and text
  found in the parsed document.
  
  The following methods are provided:
  
  =over 4
  
  =item $p = HTML::PullParser->new( file => $file, %options )
  
  =item $p = HTML::PullParser->new( doc => \$doc, %options )
  
  A C<HTML::PullParser> can be made to parse from either a file or a
  literal document based on whether the C<file> or C<doc> option is
  passed to the parser's constructor.
  
  The C<file> passed in can either be a file name or a file handle
  object.  If a file name is passed, and it can't be opened for reading,
  then the constructor will return an undefined value and $!  will tell
  you why it failed.  Otherwise the argument is taken to be some object
  that the C<HTML::PullParser> can read() from when it needs more data.
  The stream will be read() until EOF, but not closed.
  
  A C<doc> can be passed plain or as a reference
  to a scalar.  If a reference is passed then the value of this scalar
  should not be changed before all tokens have been extracted.
  
  Next the information to be returned for the different token types must
  be set up.  This is done by simply associating an argspec (as defined
  in L<HTML::Parser>) with the events you have an interest in.  For
  instance, if you want C<start> tokens to be reported as the string
  C<'S'> followed by the tagname and the attributes you might pass an
  C<start>-option like this:
  
     $p = HTML::PullParser->new(
            doc   => $document_to_parse,
            start => '"S", tagname, @attr',
            end   => '"E", tagname',
          );
  
  At last other C<HTML::Parser> options, like C<ignore_tags>, and
  C<unbroken_text>, can be passed in.  Note that you should not use the
  I<event>_h options to set up parser handlers.  That would confuse the
  inner logic of C<HTML::PullParser>.
  
  =item $token = $p->get_token
  
  This method will return the next I<token> found in the HTML document,
  or C<undef> at the end of the document.  The token is returned as an
  array reference.  The content of this array match the argspec set up
  during C<HTML::PullParser> construction.
  
  =item $p->unget_token( @tokens )
  
  If you find out you have read too many tokens you can push them back,
  so that they are returned again the next time $p->get_token is called.
  
  =back
  
  =head1 EXAMPLES
  
  The 'eg/hform' script shows how we might parse the form section of
  HTML::Documents using HTML::PullParser.
  
  =head1 SEE ALSO
  
  L<HTML::Parser>, L<HTML::TokeParser>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_HTML_PULLPARSER

$fatpacked{"x86_64-linux/HTML/TokeParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_HTML_TOKEPARSER';
  package HTML::TokeParser;
  
  require HTML::PullParser;
  @ISA=qw(HTML::PullParser);
  $VERSION = "3.69";
  
  use strict;
  use Carp ();
  use HTML::Entities qw(decode_entities);
  use HTML::Tagset ();
  
  my %ARGS =
  (
   start       => "'S',tagname,attr,attrseq,text",
   end         => "'E',tagname,text",
   text        => "'T',text,is_cdata",
   process     => "'PI',token0,text",
   comment     => "'C',text",
   declaration => "'D',text",
  
   # options that default on
   unbroken_text => 1,
  );
  
  
  sub new
  {
      my $class = shift;
      my %cnf;
  
      if (@_ == 1) {
  	my $type = (ref($_[0]) eq "SCALAR") ? "doc" : "file";
  	%cnf = ($type => $_[0]);
      }
      else {
  	unshift @_, (ref($_[0]) eq "SCALAR") ? "doc" : "file" if(scalar(@_) % 2 == 1);
  	%cnf = @_;
      }
  
      my $textify = delete $cnf{textify} || {img => "alt", applet => "alt"};
  
      my $self = $class->SUPER::new(%ARGS, %cnf) || return undef;
  
      $self->{textify} = $textify;
      $self;
  }
  
  
  sub get_tag
  {
      my $self = shift;
      my $token;
      while (1) {
  	$token = $self->get_token || return undef;
  	my $type = shift @$token;
  	next unless $type eq "S" || $type eq "E";
  	substr($token->[0], 0, 0) = "/" if $type eq "E";
  	return $token unless @_;
  	for (@_) {
  	    return $token if $token->[0] eq $_;
  	}
      }
  }
  
  
  sub _textify {
      my($self, $token) = @_;
      my $tag = $token->[1];
      return undef unless exists $self->{textify}{$tag};
  
      my $alt = $self->{textify}{$tag};
      my $text;
      if (ref($alt)) {
  	$text = &$alt(@$token);
      } else {
  	$text = $token->[2]{$alt || "alt"};
  	$text = "[\U$tag]" unless defined $text;
      }
      return $text;
  }
  
  
  sub get_text
  {
      my $self = shift;
      my @text;
      while (my $token = $self->get_token) {
  	my $type = $token->[0];
  	if ($type eq "T") {
  	    my $text = $token->[1];
  	    decode_entities($text) unless $token->[2];
  	    push(@text, $text);
  	} elsif ($type =~ /^[SE]$/) {
  	    my $tag = $token->[1];
  	    if ($type eq "S") {
  		if (defined(my $text = _textify($self, $token))) {
  		    push(@text, $text);
  		    next;
  		}
  	    } else {
  		$tag = "/$tag";
  	    }
  	    if (!@_ || grep $_ eq $tag, @_) {
  		 $self->unget_token($token);
  		 last;
  	    }
  	    push(@text, " ")
  		if $tag eq "br" || !$HTML::Tagset::isPhraseMarkup{$token->[1]};
  	}
      }
      join("", @text);
  }
  
  
  sub get_trimmed_text
  {
      my $self = shift;
      my $text = $self->get_text(@_);
      $text =~ s/^\s+//; $text =~ s/\s+$//; $text =~ s/\s+/ /g;
      $text;
  }
  
  sub get_phrase {
      my $self = shift;
      my @text;
      while (my $token = $self->get_token) {
  	my $type = $token->[0];
  	if ($type eq "T") {
  	    my $text = $token->[1];
  	    decode_entities($text) unless $token->[2];
  	    push(@text, $text);
  	} elsif ($type =~ /^[SE]$/) {
  	    my $tag = $token->[1];
  	    if ($type eq "S") {
  		if (defined(my $text = _textify($self, $token))) {
  		    push(@text, $text);
  		    next;
  		}
  	    }
  	    if (!$HTML::Tagset::isPhraseMarkup{$tag}) {
  		$self->unget_token($token);
  		last;
  	    }
  	    push(@text, " ") if $tag eq "br";
  	}
      }
      my $text = join("", @text);
      $text =~ s/^\s+//; $text =~ s/\s+$//; $text =~ s/\s+/ /g;
      $text;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTML::TokeParser - Alternative HTML::Parser interface
  
  =head1 SYNOPSIS
  
   require HTML::TokeParser;
   $p = HTML::TokeParser->new("index.html") ||
        die "Can't open: $!";
   $p->empty_element_tags(1);  # configure its behaviour
  
   while (my $token = $p->get_token) {
       #...
   }
  
  =head1 DESCRIPTION
  
  The C<HTML::TokeParser> is an alternative interface to the
  C<HTML::Parser> class.  It is an C<HTML::PullParser> subclass with a
  predeclared set of token types.  If you wish the tokens to be reported
  differently you probably want to use the C<HTML::PullParser> directly.
  
  The following methods are available:
  
  =over 4
  
  =item $p = HTML::TokeParser->new( $filename, %opt );
  
  =item $p = HTML::TokeParser->new( $filehandle, %opt );
  
  =item $p = HTML::TokeParser->new( \$document, %opt );
  
  The object constructor argument is either a file name, a file handle
  object, or the complete document to be parsed.  Extra options can be
  provided as key/value pairs and are processed as documented by the base
  classes.
  
  If the argument is a plain scalar, then it is taken as the name of a
  file to be opened and parsed.  If the file can't be opened for
  reading, then the constructor will return C<undef> and $! will tell
  you why it failed.
  
  If the argument is a reference to a plain scalar, then this scalar is
  taken to be the literal document to parse.  The value of this
  scalar should not be changed before all tokens have been extracted.
  
  Otherwise the argument is taken to be some object that the
  C<HTML::TokeParser> can read() from when it needs more data.  Typically
  it will be a filehandle of some kind.  The stream will be read() until
  EOF, but not closed.
  
  A newly constructed C<HTML::TokeParser> differ from its base classes
  by having the C<unbroken_text> attribute enabled by default. See
  L<HTML::Parser> for a description of this and other attributes that
  influence how the document is parsed. It is often a good idea to enable
  C<empty_element_tags> behaviour.
  
  Note that the parsing result will likely not be valid if raw undecoded
  UTF-8 is used as a source.  When parsing UTF-8 encoded files turn
  on UTF-8 decoding:
  
     open(my $fh, "<:utf8", "index.html") || die "Can't open 'index.html': $!";
     my $p = HTML::TokeParser->new( $fh );
     # ...
  
  If a $filename is passed to the constructor the file will be opened in
  raw mode and the parsing result will only be valid if its content is
  Latin-1 or pure ASCII.
  
  If parsing from an UTF-8 encoded string buffer decode it first:
  
     utf8::decode($document);
     my $p = HTML::TokeParser->new( \$document );
     # ...
  
  =item $p->get_token
  
  This method will return the next I<token> found in the HTML document,
  or C<undef> at the end of the document.  The token is returned as an
  array reference.  The first element of the array will be a string
  denoting the type of this token: "S" for start tag, "E" for end tag,
  "T" for text, "C" for comment, "D" for declaration, and "PI" for
  process instructions.  The rest of the token array depend on the type
  like this:
  
    ["S",  $tag, $attr, $attrseq, $text]
    ["E",  $tag, $text]
    ["T",  $text, $is_data]
    ["C",  $text]
    ["D",  $text]
    ["PI", $token0, $text]
  
  where $attr is a hash reference, $attrseq is an array reference and
  the rest are plain scalars.  The L<HTML::Parser/Argspec> explains the
  details.
  
  =item $p->unget_token( @tokens )
  
  If you find you have read too many tokens you can push them back,
  so that they are returned the next time $p->get_token is called.
  
  =item $p->get_tag
  
  =item $p->get_tag( @tags )
  
  This method returns the next start or end tag (skipping any other
  tokens), or C<undef> if there are no more tags in the document.  If
  one or more arguments are given, then we skip tokens until one of the
  specified tag types is found.  For example:
  
     $p->get_tag("font", "/font");
  
  will find the next start or end tag for a font-element.
  
  The tag information is returned as an array reference in the same form
  as for $p->get_token above, but the type code (first element) is
  missing. A start tag will be returned like this:
  
    [$tag, $attr, $attrseq, $text]
  
  The tagname of end tags are prefixed with "/", i.e. end tag is
  returned like this:
  
    ["/$tag", $text]
  
  =item $p->get_text
  
  =item $p->get_text( @endtags )
  
  This method returns all text found at the current position. It will
  return a zero length string if the next token is not text. Any
  entities will be converted to their corresponding character.
  
  If one or more arguments are given, then we return all text occurring
  before the first of the specified tags found. For example:
  
     $p->get_text("p", "br");
  
  will return the text up to either a paragraph of linebreak element.
  
  The text might span tags that should be I<textified>.  This is
  controlled by the $p->{textify} attribute, which is a hash that
  defines how certain tags can be treated as text.  If the name of a
  start tag matches a key in this hash then this tag is converted to
  text.  The hash value is used to specify which tag attribute to obtain
  the text from.  If this tag attribute is missing, then the upper case
  name of the tag enclosed in brackets is returned, e.g. "[IMG]".  The
  hash value can also be a subroutine reference.  In this case the
  routine is called with the start tag token content as its argument and
  the return value is treated as the text.
  
  The default $p->{textify} value is:
  
    {img => "alt", applet => "alt"}
  
  This means that <IMG> and <APPLET> tags are treated as text, and that
  the text to substitute can be found in the ALT attribute.
  
  =item $p->get_trimmed_text
  
  =item $p->get_trimmed_text( @endtags )
  
  Same as $p->get_text above, but will collapse any sequences of white
  space to a single space character.  Leading and trailing white space is
  removed.
  
  =item $p->get_phrase
  
  This will return all text found at the current position ignoring any
  phrasal-level tags.  Text is extracted until the first non
  phrasal-level tag.  Textification of tags is the same as for
  get_text().  This method will collapse white space in the same way as
  get_trimmed_text() does.
  
  The definition of <i>phrasal-level tags</i> is obtained from the
  HTML::Tagset module.
  
  =back
  
  =head1 EXAMPLES
  
  This example extracts all links from a document.  It will print one
  line for each link, containing the URL and the textual description
  between the <A>...</A> tags:
  
    use HTML::TokeParser;
    $p = HTML::TokeParser->new(shift||"index.html");
  
    while (my $token = $p->get_tag("a")) {
        my $url = $token->[1]{href} || "-";
        my $text = $p->get_trimmed_text("/a");
        print "$url\t$text\n";
    }
  
  This example extract the <TITLE> from the document:
  
    use HTML::TokeParser;
    $p = HTML::TokeParser->new(shift||"index.html");
    if ($p->get_tag("title")) {
        my $title = $p->get_trimmed_text;
        print "Title: $title\n";
    }
  
  =head1 SEE ALSO
  
  L<HTML::PullParser>, L<HTML::Parser>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_HTML_TOKEPARSER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl

eval 'exec /home/gugod/perl5/perlbrew/perls/v18/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
#
# This file is part of Pod-Markdown
#
# This software is copyright (c) 2011 by Randy Stauner.
#
# This is free software; you can redistribute it and/or modify it under
# the same terms as the Perl 5 programming language system itself.
#
use 5.008;
use strict;
use warnings;
# PODNAME: pod2markdown
# ABSTRACT: Convert POD text to Markdown

use Pod::Markdown;
use Getopt::Long;
use Pod::Usage;

my %opts = (
  # Since we're writing to a file the module needs to know that it has to do
  # some kind of encoding.  Default to UTF-8.
  output_encoding => 'UTF-8',
);

GetOptions(\%opts, qw(
  help|h
  html_encode_chars|html-encode-chars=s
  match_encoding|match-encoding|m
  output_encoding|output-encoding|e=s
  utf8|utf-8|u
)) or pod2usage(2);
pod2usage(1) if $opts{help};

# TODO: Test PERL_UNICODE and/or layers on the handle?

# Expand alias (-u is an alias for -e UTF-8).
$opts{output_encoding} = 'UTF-8' if delete $opts{utf8};

# TODO: Pod::Simple::parse_from_file(@ARGV[0,1]);

my $in_fh  = get_handle(shift(@ARGV), '<', \*STDIN);
my $out_fh = get_handle(shift(@ARGV), '>', \*STDOUT);

# Undo any PERL_UNICODE effects.
# Pod::Simple expects to receive bytes, and we're going to return bytes.
binmode($_, ':bytes') for ($in_fh, $out_fh);

convert($in_fh, $out_fh);

sub convert {
    my ($in_file, $out_file) = @_;
    my $parser = Pod::Markdown->new(%opts);
    $parser->output_fh($out_file);
    $parser->parse_file($in_file);
}

sub get_handle {
  my ($path, $op, $default) = @_;
  (!defined($path) || $path eq '-') ? $default : do {
    open(my $fh, $op, $path)
      or die "Failed to open '$path': $!\n";
    $fh;
  };
}

__END__

=pod

=encoding UTF-8

=for :stopwords Marcel Gruenauer Victor Moral Ryan C. Thompson <rct at thompsonclan d0t
org> Aristotle Pagaltzis Randy Stauner ACKNOWLEDGEMENTS html

=head1 NAME

pod2markdown - Convert POD text to Markdown

=head1 VERSION

version 3.005

=head1 SYNOPSIS

    # parse STDIN, print to STDOUT
    $ pod2markdown < POD_File > Markdown_File

    # parse file, print to STDOUT
    $ pod2markdown input.pod

    # parse file, print to file
    $ pod2markdown input.pod output.mkdn

    # parse STDIN, print to file
    $ pod2markdown - output.mkdn

=head1 DESCRIPTION

This program uses L<Pod::Markdown> to convert POD into Markdown sources.

UTF-8 is the default output encoding
if no encoding options are specified (see L</OPTIONS>).

It accepts two optional arguments:

=over 4

=item *

input pod file (defaults to C<STDIN>)

=item *

output markdown file (defaults to C<STDOUT>)

=back

=head1 OPTIONS

=over

=item --html-encode-chars

A list of characters to encode as HTML entities.
Pass a regexp character class, or C<1> to mean control chars, high-bit chars, and C<< <&>"' >>.

See L<Pod::Markdown/html_encode_chars> for more information.

=item --match-encoding (-m)

Use the same C<< =encoding >> as the input pod for the output file.

=item --output-encoding (-e)

Specify the encoding for the output file.

=item --utf8 (-u)

Alias for C<< -e UTF-8 >>.

=back

=head1 SEE ALSO

This program is strongly based on C<pod2mdwn> from L<Module::Build::IkiWiki>.

=head1 AUTHORS

=over 4

=item *

Marcel Gruenauer <marcel@cpan.org>

=item *

Victor Moral <victor@taquiones.net>

=item *

Ryan C. Thompson <rct at thompsonclan d0t org>

=item *

Aristotle Pagaltzis <pagaltzis@gmx.de>

=item *

Randy Stauner <rwstauner@cpan.org>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2011 by Randy Stauner.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
