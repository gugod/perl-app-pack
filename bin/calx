#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Color/ANSI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COLOR_ANSI_UTIL';
  package Color::ANSI::Util;
  
  our $DATE = '2017-12-03'; # DATE
  our $VERSION = '0.160'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
                         ansi16_to_rgb
                         rgb_to_ansi16
                         rgb_to_ansi16_fg_code
                         ansi16fg
                         rgb_to_ansi16_bg_code
                         ansi16bg
  
                         ansi256_to_rgb
                         rgb_to_ansi256
                         rgb_to_ansi256_fg_code
                         ansi256fg
                         rgb_to_ansi256_bg_code
                         ansi256bg
  
                         rgb_to_ansi24b_fg_code
                         ansi24bfg
                         rgb_to_ansi24b_bg_code
                         ansi24bbg
  
                         rgb_to_ansi_fg_code
                         ansifg
                         rgb_to_ansi_bg_code
                         ansibg
                 );
  
  our %SPEC;
  
  my %ansi16 = (
      0  => '000000',
      1  => '800000',
      2  => '008000',
      3  => '808000',
      4  => '000080',
      5  => '800080',
      6  => '008080',
      7  => 'c0c0c0',
      8  => '808080',
      9  => 'ff0000',
      10 => '00ff00',
      11 => 'ffff00',
      12 => '0000ff',
      13 => 'ff00ff',
      14 => '00ffff',
      15 => 'ffffff',
  );
  my @revansi16;
  for (sort {$a<=>$b} keys %ansi16) {
      $ansi16{$_} =~ /(..)(..)(..)/;
      push @revansi16, [hex($1), hex($2), hex($3), $_];
  }
  
  my %ansi256 = (
      %ansi16,
  
      16 => '000000',  17 => '00005f',  18 => '000087',  19 => '0000af',  20 => '0000d7',  21 => '0000ff',
      22 => '005f00',  23 => '005f5f',  24 => '005f87',  25 => '005faf',  26 => '005fd7',  27 => '005fff',
      28 => '008700',  29 => '00875f',  30 => '008787',  31 => '0087af',  32 => '0087d7',  33 => '0087ff',
      34 => '00af00',  35 => '00af5f',  36 => '00af87',  37 => '00afaf',  38 => '00afd7',  39 => '00afff',
      40 => '00d700',  41 => '00d75f',  42 => '00d787',  43 => '00d7af',  44 => '00d7d7',  45 => '00d7ff',
      46 => '00ff00',  47 => '00ff5f',  48 => '00ff87',  49 => '00ffaf',  50 => '00ffd7',  51 => '00ffff',
      52 => '5f0000',  53 => '5f005f',  54 => '5f0087',  55 => '5f00af',  56 => '5f00d7',  57 => '5f00ff',
      58 => '5f5f00',  59 => '5f5f5f',  60 => '5f5f87',  61 => '5f5faf',  62 => '5f5fd7',  63 => '5f5fff',
      64 => '5f8700',  65 => '5f875f',  66 => '5f8787',  67 => '5f87af',  68 => '5f87d7',  69 => '5f87ff',
      70 => '5faf00',  71 => '5faf5f',  72 => '5faf87',  73 => '5fafaf',  74 => '5fafd7',  75 => '5fafff',
      76 => '5fd700',  77 => '5fd75f',  78 => '5fd787',  79 => '5fd7af',  80 => '5fd7d7',  81 => '5fd7ff',
      82 => '5fff00',  83 => '5fff5f',  84 => '5fff87',  85 => '5fffaf',  86 => '5fffd7',  87 => '5fffff',
      88 => '870000',  89 => '87005f',  90 => '870087',  91 => '8700af',  92 => '8700d7',  93 => '8700ff',
      94 => '875f00',  95 => '875f5f',  96 => '875f87',  97 => '875faf',  98 => '875fd7',  99 => '875fff',
      100 => '878700', 101 => '87875f', 102 => '878787', 103 => '8787af', 104 => '8787d7', 105 => '8787ff',
      106 => '87af00', 107 => '87af5f', 108 => '87af87', 109 => '87afaf', 110 => '87afd7', 111 => '87afff',
      112 => '87d700', 113 => '87d75f', 114 => '87d787', 115 => '87d7af', 116 => '87d7d7', 117 => '87d7ff',
      118 => '87ff00', 119 => '87ff5f', 120 => '87ff87', 121 => '87ffaf', 122 => '87ffd7', 123 => '87ffff',
      124 => 'af0000', 125 => 'af005f', 126 => 'af0087', 127 => 'af00af', 128 => 'af00d7', 129 => 'af00ff',
      130 => 'af5f00', 131 => 'af5f5f', 132 => 'af5f87', 133 => 'af5faf', 134 => 'af5fd7', 135 => 'af5fff',
      136 => 'af8700', 137 => 'af875f', 138 => 'af8787', 139 => 'af87af', 140 => 'af87d7', 141 => 'af87ff',
      142 => 'afaf00', 143 => 'afaf5f', 144 => 'afaf87', 145 => 'afafaf', 146 => 'afafd7', 147 => 'afafff',
      148 => 'afd700', 149 => 'afd75f', 150 => 'afd787', 151 => 'afd7af', 152 => 'afd7d7', 153 => 'afd7ff',
      154 => 'afff00', 155 => 'afff5f', 156 => 'afff87', 157 => 'afffaf', 158 => 'afffd7', 159 => 'afffff',
      160 => 'd70000', 161 => 'd7005f', 162 => 'd70087', 163 => 'd700af', 164 => 'd700d7', 165 => 'd700ff',
      166 => 'd75f00', 167 => 'd75f5f', 168 => 'd75f87', 169 => 'd75faf', 170 => 'd75fd7', 171 => 'd75fff',
      172 => 'd78700', 173 => 'd7875f', 174 => 'd78787', 175 => 'd787af', 176 => 'd787d7', 177 => 'd787ff',
      178 => 'd7af00', 179 => 'd7af5f', 180 => 'd7af87', 181 => 'd7afaf', 182 => 'd7afd7', 183 => 'd7afff',
      184 => 'd7d700', 185 => 'd7d75f', 186 => 'd7d787', 187 => 'd7d7af', 188 => 'd7d7d7', 189 => 'd7d7ff',
      190 => 'd7ff00', 191 => 'd7ff5f', 192 => 'd7ff87', 193 => 'd7ffaf', 194 => 'd7ffd7', 195 => 'd7ffff',
      196 => 'ff0000', 197 => 'ff005f', 198 => 'ff0087', 199 => 'ff00af', 200 => 'ff00d7', 201 => 'ff00ff',
      202 => 'ff5f00', 203 => 'ff5f5f', 204 => 'ff5f87', 205 => 'ff5faf', 206 => 'ff5fd7', 207 => 'ff5fff',
      208 => 'ff8700', 209 => 'ff875f', 210 => 'ff8787', 211 => 'ff87af', 212 => 'ff87d7', 213 => 'ff87ff',
      214 => 'ffaf00', 215 => 'ffaf5f', 216 => 'ffaf87', 217 => 'ffafaf', 218 => 'ffafd7', 219 => 'ffafff',
      220 => 'ffd700', 221 => 'ffd75f', 222 => 'ffd787', 223 => 'ffd7af', 224 => 'ffd7d7', 225 => 'ffd7ff',
      226 => 'ffff00', 227 => 'ffff5f', 228 => 'ffff87', 229 => 'ffffaf', 230 => 'ffffd7', 231 => 'ffffff',
  
      232 => '080808', 233 => '121212', 234 => '1c1c1c', 235 => '262626', 236 => '303030', 237 => '3a3a3a',
      238 => '444444', 239 => '4e4e4e', 240 => '585858', 241 => '606060', 242 => '666666', 243 => '767676',
      244 => '808080', 245 => '8a8a8a', 246 => '949494', 247 => '9e9e9e', 248 => 'a8a8a8', 249 => 'b2b2b2',
      250 => 'bcbcbc', 251 => 'c6c6c6', 252 => 'd0d0d0', 253 => 'dadada', 254 => 'e4e4e4', 255 => 'eeeeee',
  );
  my @revansi256;
  for (sort {$a<=>$b} keys %ansi256) {
      $ansi256{$_} =~ /(..)(..)(..)/;
      push @revansi256, [hex($1), hex($2), hex($3), $_];
  }
  
  $SPEC{ansi16_to_rgb} = {
      v => 1.1,
      summary => 'Convert ANSI-16 color to RGB',
      description => <<'_',
  
  Returns 6-hexdigit, e.g. 'ff00cc'.
  
  _
      args => {
          color => {
              schema => 'color::ansi16*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::rgb24*',
      },
      result_naked => 1,
  };
  sub ansi16_to_rgb {
      my ($input) = @_;
  
      if ($input =~ /^\d+$/) {
          if ($input >= 0 && $input <= 15) {
              return $ansi16{$input + 0}; # to remove prefix zero e.g. "06"
          } else {
              die "Invalid ANSI 16-color number '$input'";
          }
      } elsif ($input =~ /^(?:(bold|bright) \s )?(black|red|green|yellow|blue|magenta|cyan|white)$/ix) {
          my ($bold, $col) = (lc($1 // ""), lc($2));
          my $i;
          if ($col eq 'black') {
              $i = 0;
          } elsif ($col eq 'red') {
              $i = 1;
          } elsif ($col eq 'green') {
              $i = 2;
          } elsif ($col eq 'yellow') {
              $i = 3;
          } elsif ($col eq 'blue') {
              $i = 4;
          } elsif ($col eq 'magenta') {
              $i = 5;
          } elsif ($col eq 'cyan') {
              $i = 6;
          } elsif ($col eq 'white') {
              $i = 7;
          }
          $i += 8 if $bold;
          return $ansi16{$i};
      } else {
          die "Invalid ANSI 16-color name '$input'";
      }
  }
  
  sub _rgb_to_indexed {
      my ($rgb, $table) = @_;
  
      $rgb =~ /^#?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
          or die "Invalid RGB input '$rgb'";
      my $r = hex($1);
      my $g = hex($2);
      my $b = hex($3);
  
      my ($minsqdist, $res);
      for my $e (@$table) {
          my $sqdist =
              abs($e->[0]-$r)**2 + abs($e->[1]-$g)**2 + abs($e->[2]-$b)**2;
          # exact match, return immediately
          return $e->[3] if $sqdist == 0;
          if (!defined($minsqdist) || $minsqdist > $sqdist) {
              #say "D:sqdist=$sqdist";
              $minsqdist = $sqdist;
              $res = $e->[3];
          }
      }
      return $res;
  }
  
  $SPEC{ansi256_to_rgb} = {
      v => 1.1,
      summary => 'Convert ANSI-256 color to RGB',
      args => {
          color => {
              schema => 'color::ansi256*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::rgb24',
      },
      result_naked => 1,
  };
  sub ansi256_to_rgb {
      my ($input) = @_;
  
      $input += 0;
      exists($ansi256{$input}) or die "Invalid ANSI 256-color index '$input'";
      $ansi256{$input};
  }
  
  $SPEC{rgb_to_ansi16} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-16 color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::ansi16*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi16 {
      my ($input) = @_;
      _rgb_to_indexed($input, \@revansi16);
  }
  
  $SPEC{rgb_to_ansi256} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-256 color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'color::ansi256*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi256 {
      my ($input) = @_;
      _rgb_to_indexed($input, \@revansi256);
  }
  
  $SPEC{rgb_to_ansi16_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-16 color escape sequence to change foreground color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi16_fg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[" . ($res >= 8 ? ($res+30-8) . ";1" : ($res+30)) . "m";
  }
  
  sub ansi16fg  { goto &rgb_to_ansi16_fg_code  }
  
  $SPEC{rgb_to_ansi16_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-16 color escape sequence to change background color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi16_bg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[" . ($res >= 8 ? ($res+40-8) : ($res+40)) . "m";
  }
  
  sub ansi16bg  { goto &rgb_to_ansi16_bg_code  }
  
  $SPEC{rgb_to_ansi256_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-256 color escape sequence to change foreground color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi256_fg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[38;5;${res}m";
  }
  
  sub ansi256fg { goto &rgb_to_ansi256_fg_code }
  
  $SPEC{rgb_to_ansi256_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI-256 color escape sequence to change background color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi256_bg_code {
      my ($input) = @_;
  
      my $res = _rgb_to_indexed($input, \@revansi16);
      return "\e[48;5;${res}m";
  }
  
  sub ansi256bg { goto &rgb_to_ansi256_bg_code }
  
  $SPEC{rgb_to_ansi24b_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI 24bit-color escape sequence to change foreground color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi24b_fg_code {
      my ($rgb) = @_;
  
      return sprintf("\e[38;2;%d;%d;%dm",
                     hex(substr($rgb, 0, 2)),
                     hex(substr($rgb, 2, 2)),
                     hex(substr($rgb, 4, 2)));
  }
  
  sub ansi24bfg { goto &rgb_to_ansi24b_fg_code }
  
  $SPEC{rgb_to_ansi24b_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI 24bit-color escape sequence to change background color',
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi24b_bg_code {
      my ($rgb) = @_;
  
      return sprintf("\e[48;2;%d;%d;%dm",
                     hex(substr($rgb, 0, 2)),
                     hex(substr($rgb, 2, 2)),
                     hex(substr($rgb, 4, 2)));
  }
  
  sub ansi24bbg { goto &rgb_to_ansi24b_bg_code }
  
  our $_use_termdetsw = 1;
  our $_color_depth; # cache, can be set during testing
  sub _color_depth {
      unless (defined $_color_depth) {
          {
              if (defined $ENV{COLOR} && !$ENV{COLOR}) {
                  $_color_depth = 0;
                  last;
              }
              if (defined $ENV{COLOR_DEPTH}) {
                  $_color_depth = $ENV{COLOR_DEPTH};
                  last;
              }
              if ($_use_termdetsw) {
                  eval { require Term::Detect::Software };
                  if (!$@) {
                      $_color_depth = Term::Detect::Software::detect_terminal_cached()->{color_depth};
                      last;
                  }
              }
              # simple heuristic
              if ($ENV{KONSOLE_DBUS_SERVICE}) {
                  $_color_depth = 2**24;
                  last;
              }
              # safe value
              $_color_depth = 16;
          }
      };
      $_color_depth;
  }
  
  $SPEC{rgb_to_ansi_fg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI color escape sequence to change foreground color',
      description => <<'_',
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Color depth used is determined by `COLOR_DEPTH` environment setting or from
  <pm:Term::Detect::Software> if that module is available. In other words, this
  function automatically chooses rgb_to_ansi{24b,256,16}_fg_code().
  
  _
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi_fg_code {
      my ($rgb) = @_;
      my $cd = _color_depth();
      if ($cd >= 2**24) {
          rgb_to_ansi24b_fg_code($rgb);
      } elsif ($cd >= 256) {
          rgb_to_ansi256_fg_code($rgb);
      } elsif ($cd >= 16) {
          rgb_to_ansi16_fg_code($rgb);
      } else {
          "";
      }
  }
  
  sub ansifg { goto &rgb_to_ansi_fg_code }
  
  $SPEC{rgb_to_ansi_bg_code} = {
      v => 1.1,
      summary => 'Convert RGB to ANSI color escape sequence to change background color',
      description => <<'_',
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Which color depth used is determined by `COLOR_DEPTH` environment setting or
  from <pm:Term::Detect::Software> if that module is available). In other words,
  this function automatically chooses rgb_to_ansi{24b,256,16}_bg_code().
  
  _
      args => {
          color => {
              schema => 'color::rgb24*',
              req => 1,
              pos => 0,
          },
      },
      args_as => 'array',
      result => {
          schema => 'str*',
      },
      result_naked => 1,
  };
  sub rgb_to_ansi_bg_code {
      my ($rgb) = @_;
      my $cd = _color_depth();
      if ($cd >= 2**24) {
          rgb_to_ansi24b_bg_code($rgb);
      } elsif ($cd >= 256) {
          rgb_to_ansi256_bg_code($rgb);
      } else {
          rgb_to_ansi16_bg_code($rgb);
      }
  }
  
  sub ansibg { goto &rgb_to_ansi_bg_code }
  
  1;
  # ABSTRACT: Routines for dealing with ANSI colors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Color::ANSI::Util - Routines for dealing with ANSI colors
  
  =head1 VERSION
  
  This document describes version 0.160 of Color::ANSI::Util (from Perl distribution Color-ANSI-Util), released on 2017-12-03.
  
  =head1 SYNOPSIS
  
   use Color::ANSI::Util qw(
       ansifg
       ansibg
   );
  
   say ansifg("f0c010"); # => "\e[33;1m" (on 16-color terminal)
                         # => "\e[38;5;11m" (on 256-color terminal)
                         # => "\e[38;2;240;192;16m" (on 24-bit-color terminal)
  
   say ansibg("ff5f87"); # => "\e[47m" (on 16-color terminal)
                         # => "\e[48;5;7m" (on 256-color terminal)
                         # => "\e[48;2;255;95;135m" (on 24-bit-color terminal)
  
  There are a bunch of other exportable functions too, mostly for converting
  between RGB and ANSI color (16/256/24bit color depth).
  
  =head1 DESCRIPTION
  
  This module provides routines for dealing with ANSI colors. The two main
  functions are C<ansifg> and C<ansibg>. With those functions, you can specify
  colors in RGB and let it output the correct ANSI color escape code according to
  the color depth support of the terminal (whether 16-color, 256-color, or 24bit).
  There are other functions to convert RGB to ANSI in specific color depths, or
  reverse functions to convert from ANSI to RGB codes.
  
  Keywords: xterm, xterm-256color, terminal
  
  =head1 BUGS/NOTES
  
  Algorithm for finding closest indexed color from RGB color currently not very
  efficient. Probably can add some threshold square distance, below which we can
  shortcut to the final answer.
  
  =head1 FUNCTIONS
  
  
  =head2 ansi16_to_rgb
  
  Usage:
  
   ansi16_to_rgb($color) -> color::rgb24
  
  Convert ANSI-16 color to RGB.
  
  Returns 6-hexdigit, e.g. 'ff00cc'.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::ansi16>
  
  =back
  
  Return value:  (color::rgb24)
  
  
  =head2 ansi256_to_rgb
  
  Usage:
  
   ansi256_to_rgb($color) -> color::rgb24
  
  Convert ANSI-256 color to RGB.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::ansi256>
  
  =back
  
  Return value:  (color::rgb24)
  
  
  =head2 rgb_to_ansi16
  
  Usage:
  
   rgb_to_ansi16($color) -> color::ansi16
  
  Convert RGB to ANSI-16 color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (color::ansi16)
  
  
  =head2 rgb_to_ansi16_bg_code
  
  Usage:
  
   rgb_to_ansi16_bg_code($color) -> str
  
  Convert RGB to ANSI-16 color escape sequence to change background color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi16_fg_code
  
  Usage:
  
   rgb_to_ansi16_fg_code($color) -> str
  
  Convert RGB to ANSI-16 color escape sequence to change foreground color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi24b_bg_code
  
  Usage:
  
   rgb_to_ansi24b_bg_code($color) -> str
  
  Convert RGB to ANSI 24bit-color escape sequence to change background color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi24b_fg_code
  
  Usage:
  
   rgb_to_ansi24b_fg_code($color) -> str
  
  Convert RGB to ANSI 24bit-color escape sequence to change foreground color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi256
  
  Usage:
  
   rgb_to_ansi256($color) -> color::ansi256
  
  Convert RGB to ANSI-256 color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (color::ansi256)
  
  
  =head2 rgb_to_ansi256_bg_code
  
  Usage:
  
   rgb_to_ansi256_bg_code($color) -> str
  
  Convert RGB to ANSI-256 color escape sequence to change background color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi256_fg_code
  
  Usage:
  
   rgb_to_ansi256_fg_code($color) -> str
  
  Convert RGB to ANSI-256 color escape sequence to change foreground color.
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi_bg_code
  
  Usage:
  
   rgb_to_ansi_bg_code($color) -> str
  
  Convert RGB to ANSI color escape sequence to change background color.
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Which color depth used is determined by C<COLOR_DEPTH> environment setting or
  from L<Term::Detect::Software> if that module is available). In other words,
  this function automatically chooses rgb_to_ansi{24b,256,16}I<bg>code().
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  
  =head2 rgb_to_ansi_fg_code
  
  Usage:
  
   rgb_to_ansi_fg_code($color) -> str
  
  Convert RGB to ANSI color escape sequence to change foreground color.
  
  Autodetect terminal capability and can return either empty string, 16-color,
  256-color, or 24bit-code.
  
  Color depth used is determined by C<COLOR_DEPTH> environment setting or from
  L<Term::Detect::Software> if that module is available. In other words, this
  function automatically chooses rgb_to_ansi{24b,256,16}I<fg>code().
  
  This function is not exported by default, but exportable.
  
  Arguments ('*' denotes required arguments):
  
  =over 4
  
  =item * B<$color>* => I<color::rgb24>
  
  =back
  
  Return value:  (str)
  
  =head2 ansi16fg($rgb) => STR
  
  Alias for rgb_to_ansi16_fg_code().
  
  =head2 ansi16bg($rgb) => STR
  
  Alias for rgb_to_ansi16_bg_code().
  
  =head2 ansi256fg($rgb) => STR
  
  Alias for rgb_to_ansi256_fg_code().
  
  =head2 ansi256bg($rgb) => STR
  
  Alias for rgb_to_ansi256_bg_code().
  
  =head2 ansi24bfg($rgb) => STR
  
  Alias for rgb_to_ansi24b_fg_code().
  
  =head2 ansi24bbg($rgb) => STR
  
  Alias for rgb_to_ansi24b_bg_code().
  
  =head2 rgb_to_ansi_fg_code($rgb) => STR
  
  =head2 ansifg($rgb) => STR
  
  Alias for rgb_to_ansi_fg_code().
  
  =head2 ansibg($rgb) => STR
  
  Alias for rgb_to_ansi_bg_code().
  
  =head1 ENVIRONMENT
  
  =head2 COLOR => bool
  
  Can be used to explicitly disable color by setting it to 0.
  
  Observed by: ansi{fg,bg}.
  
  =head2 COLOR_DEPTH => INT
  
  Can be used to explicitly set color depth instead of trying to detect
  appropriate color depth.
  
  Observed by: ansi{fg,bg}.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Color-ANSI-Util>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/sharyanto/perl-Color-ANSI-Util>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Color-ANSI-Util>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Term::ANSIColor>
  
  L<http://en.wikipedia.org/wiki/ANSI_escape_code>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017, 2016, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
COLOR_ANSI_UTIL

$fatpacked{"Color/RGB/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COLOR_RGB_UTIL';
  package Color::RGB::Util;
  
  our $DATE = '2018-10-05'; # DATE
  our $VERSION = '0.593'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  
  #use List::Util qw(min);
  
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(
                         mix_2_rgb_colors
                         mix_rgb_colors
                         rand_rgb_color
                         reverse_rgb_color
                         rgb2grayscale
                         rgb2sepia
                         rgb_luminance
                         tint_rgb_color
                         rgb_distance
                         rgb_diff
                         rgb_is_dark
                         rgb_is_light
                 );
  
  my $re_rgb = qr/\A#?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})\z/;
  
  sub mix_2_rgb_colors {
      my ($rgb1, $rgb2, $pct) = @_;
  
      $pct //= 0.5;
  
      my ($r1, $g1, $b1) =
          $rgb1 =~ $re_rgb or die "Invalid rgb1 color, must be in 'ffffff' form";
      my ($r2, $g2, $b2) =
          $rgb2 =~ $re_rgb or die "Invalid rgb2 color, must be in 'ffffff' form";
      for ($r1, $g1, $b1, $r2, $g2, $b2) { $_ = hex $_ }
  
      return sprintf("%02x%02x%02x",
                     $r1 + $pct*($r2-$r1),
                     $g1 + $pct*($g2-$g1),
                     $b1 + $pct*($b2-$b1),
                 );
  }
  
  sub mix_rgb_colors {
  
      my (@weights, @r, @g, @b);
  
      while (@_ >= 2) {
          my ($rgb, $weight) = splice @_, 0, 2;
          my ($r, $g, $b) = $rgb =~ $re_rgb
              or die "Invalid rgb color '$rgb', must be in 'ffffff' form";
          push @r, hex $r;
          push @g, hex $g;
          push @b, hex $b;
          push @weights, $weight;
      }
      my $tot_r = 0; for (0..$#r) { $tot_r += $r[$_]*$weights[$_] }
      my $tot_g = 0; for (0..$#g) { $tot_g += $g[$_]*$weights[$_] }
      my $tot_b = 0; for (0..$#b) { $tot_b += $b[$_]*$weights[$_] }
      my $tot_weight = 0; $tot_weight += $_ for @weights;
      die "Zero/negative total weight" unless $tot_weight > 0;
  
      return sprintf("%02x%02x%02x",
                     $tot_r / $tot_weight,
                     $tot_g / $tot_weight,
                     $tot_b / $tot_weight,
                 );
  }
  
  sub rand_rgb_color {
      my ($rgb1, $rgb2) = @_;
  
      $rgb1 //= '000000';
      my ($r1, $g1, $b1) =
          $rgb1 =~ $re_rgb or die "Invalid rgb1 color, must be in 'ffffff' form";
      $rgb2 //= 'ffffff';
      my ($r2, $g2, $b2) =
          $rgb2 =~ $re_rgb or die "Invalid rgb2 color, must be in 'ffffff' form";
      for ($r1, $g1, $b1, $r2, $g2, $b2) { $_ = hex $_ }
  
      return sprintf("%02x%02x%02x",
                     $r1 + rand()*($r2-$r1+1),
                     $g1 + rand()*($g2-$g1+1),
                     $b1 + rand()*($b2-$b1+1),
                 );
  }
  
  sub rgb2grayscale {
      my ($rgb) = @_;
  
      my ($r, $g, $b) =
          $rgb =~ $re_rgb or die "Invalid rgb color, must be in 'ffffff' form";
      for ($r, $g, $b) { $_ = hex $_ }
  
      # basically we just average the R, G, B
      my $avg = int(($r + $g + $b)/3);
      return sprintf("%02x%02x%02x", $avg, $avg, $avg);
  }
  
  sub rgb2sepia {
      my ($rgb) = @_;
  
      my ($r, $g, $b) =
          $rgb =~ $re_rgb or die "Invalid rgb color, must be in 'ffffff' form";
      for ($r, $g, $b) { $_ = hex $_ }
  
      # reference: http://www.techrepublic.com/blog/howdoi/how-do-i-convert-images-to-grayscale-and-sepia-tone-using-c/120
      my $or = ($r*0.393) + ($g*0.769) + ($b*0.189);
      my $og = ($r*0.349) + ($g*0.686) + ($b*0.168);
      my $ob = ($r*0.272) + ($g*0.534) + ($b*0.131);
      for ($or, $og, $ob) { $_ = 255 if $_ > 255 }
      return sprintf("%02x%02x%02x", $or, $og, $ob);
  }
  
  sub reverse_rgb_color {
      my ($rgb) = @_;
  
      my ($r, $g, $b) =
          $rgb =~ $re_rgb or die "Invalid rgb color, must be in 'ffffff' form";
      for ($r, $g, $b) { $_ = hex $_ }
  
      return sprintf("%02x%02x%02x", 255-$r, 255-$g, 255-$b);
  }
  
  sub _rgb_luminance {
      my ($r, $g, $b) = @_;
      0.2126*$r/255 + 0.7152*$g/255 + 0.0722*$b/255;
  }
  
  sub rgb_luminance {
      my ($rgb) = @_;
  
      my ($r, $g, $b) =
          $rgb =~ $re_rgb or die "Invalid rgb color, must be in 'ffffff' form";
      for ($r, $g, $b) { $_ = hex $_ }
  
      return _rgb_luminance($r, $g, $b);
  }
  
  sub tint_rgb_color {
      my ($rgb1, $rgb2, $pct) = @_;
  
      $pct //= 0.5;
  
      my ($r1, $g1, $b1) =
          $rgb1 =~ $re_rgb or die "Invalid rgb1 color, must be in 'ffffff' form";
      my ($r2, $g2, $b2) =
          $rgb2 =~ $re_rgb or die "Invalid rgb2 color, must be in 'ffffff' form";
      for ($r1, $g1, $b1, $r2, $g2, $b2) { $_ = hex $_ }
  
      my $lum = _rgb_luminance($r1, $g1, $b1);
  
      return sprintf("%02x%02x%02x",
                     $r1 + $pct*($r2-$r1)*$lum,
                     $g1 + $pct*($g2-$g1)*$lum,
                     $b1 + $pct*($b2-$b1)*$lum,
                 );
  }
  
  sub rgb_distance {
      my ($rgb1, $rgb2) = @_;
  
      my ($r1, $g1, $b1) =
          $rgb1 =~ $re_rgb or die "Invalid rgb1 color, must be in 'ffffff' form";
      my ($r2, $g2, $b2) =
          $rgb2 =~ $re_rgb or die "Invalid rgb2 color, must be in 'ffffff' form";
      for ($r1, $g1, $b1, $r2, $g2, $b2) { $_ = hex $_ }
  
      (($r1-$r2)**2 + ($g1-$g2)**2 + ($b1-$b2)**2)**0.5;
  }
  
  sub rgb_diff {
      my ($rgb1, $rgb2, $algo) = @_;
  
      $algo //= 'euclidean';
  
      my ($r1, $g1, $b1) =
          $rgb1 =~ $re_rgb or die "Invalid rgb1 color, must be in 'ffffff' form";
      my ($r2, $g2, $b2) =
          $rgb2 =~ $re_rgb or die "Invalid rgb2 color, must be in 'ffffff' form";
      for ($r1, $g1, $b1, $r2, $g2, $b2) { $_ = hex $_ }
  
      my $dr2 = ($r1-$r2)**2;
      my $dg2 = ($g1-$g2)**2;
      my $db2 = ($b1-$b2)**2;
  
      if ($algo eq 'approx1') {
          my $rm = ($r1 + $r2)/2;
          (2*$dr2 + 4*$dg2 + 3*$db2 + $rm*($dr2 - $db2)/256 )**0.5;
      } else {
          # euclidean
          ($dr2 + $dg2 + $db2)**0.5;
      }
  }
  
  sub rgb_is_dark {
      my ($rgb) = @_;
      rgb_distance($rgb, "000000") < rgb_distance($rgb, "ffffff") ? 1:0;
  }
  
  sub rgb_is_light {
      my ($rgb) = @_;
      rgb_distance($rgb, "000000") > rgb_distance($rgb, "ffffff") ? 1:0;
  }
  
  1;
  # ABSTRACT: Utilities related to RGB colors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Color::RGB::Util - Utilities related to RGB colors
  
  =head1 VERSION
  
  This document describes version 0.593 of Color::RGB::Util (from Perl distribution Color-RGB-Util), released on 2018-10-05.
  
  =head1 SYNOPSIS
  
   use Color::RGB::Util qw(
       mix_2_rgb_colors
       mix_rgb_colors
       rand_rgb_color
       rgb2grayscale
       rgb2sepia
       reverse_rgb_color
       rgb_luminance
       tint_rgb_color
       rgb_distance
       rgb_diff
       rgb_is_light
       rgb_is_dark
   );
  
   say mix_2_rgb_colors('#ff0000', '#ffffff');     # pink (red + white)
   say mix_2_rgb_colors('ff0000', 'ffffff', 0.75); # pink with a whiter shade
  
   say mix_rgb_colors('ff0000', 1, 'ffffff', 1);   # pink (red + white 1 : 1)
   say mix_rgb_colors('ff0000', 1, 'ffffff', 3);   # pink with a whiter shade (red + white 1 : 3)
   say mix_rgb_colors('ff0000', 1, 'ffffff', 1, '0000ff', 0.5);   # bluish pink
  
   say rand_rgb_color();
   say rand_rgb_color('000000', '333333');         # limit range
  
   say rgb2grayscale('0033CC');                    # => 555555
  
   say rgb2sepia('0033CC');                        # => 4d4535
  
   say reverse_rgb_color('0033CC');                # => ffcc33
  
   say rgb_luminance('d090aa');                    # => ffcc33
  
   say tint_rgb_color('#ff8800', '#0033cc');       # => b36e3c
  
   say rgb_distance('000000', '000000')            # => 0
   say rgb_distance('01f000', '04f400')            # => 5
   say rgb_distance('ffff00', 'ffffff')            # => 255
  
   say rgb_is_dark('404040');                      # => 1
   say rgb_is_dark('a0a0a0');                      # => 0
   say rgb_is_light('404040');                     # => 0
   say rgb_is_light('a0a0a0');                     # => 1
  
   say rgb_diff('000000', '000000');               # => 0
   say rgb_diff('01f000', '04f400');               # => 5
   say rgb_diff('ffff00', 'ffffff');               # => 255
  
   say rgb_diff('000000', '000000', 'approx1');    # => 0
   say rgb_diff('01f000', '04f400', 'approx1');    # => 9.06
   say rgb_diff('ffff00', 'ffffff', 'approx1');    # => 360.98
  
  =head1 DESCRIPTION
  
  =head1 FUNCTIONS
  
  None are exported by default, but they are exportable.
  
  =head2 mix_2_rgb_colors
  
  Usage:
  
   my $mixed_rgb = mix_2_rgb_colors($rgb1, $rgb2, $pct);
  
  Mix 2 RGB colors. C<$pct> is a number between 0 and 1, by default 0.5 (halfway),
  the closer to 1 the closer the resulting color to C<$rgb2>.
  
  =head2 mix_rgb_colors
  
  Usage:
  
   my $mixed_rgb = mix_rgb_colors($color1, $weight1, $color2, $weight2, ...);
  
  Mix several RGB colors.
  
  =head2 rand_rgb_color
  
  Usage:
  
   my $rgb = rand_rgb_color([ $low_limit [ , $high_limit ] ]);
  
  Generate a random RGB color. You can specify the limit. Otherwise, they default
  to the full range (000000 to ffffff).
  
  =head2 rgb2grayscale
  
  Usage:
  
   my $rgb_gs = rgb2grayscale($rgb);
  
  Convert C<$rgb> to grayscale RGB value.
  
  =head2 rgb2sepia
  
  Usage:
  
   my $rgb_sepia = rgb2sepia($rgb);
  
  Convert C<$rgb> to sepia tone RGB value.
  
  =head2 reverse_rgb_color
  
  Usage:
  
   my $reversed = reverse_rgb_color($rgb);
  
  Reverse C<$rgb>.
  
  =head2 rgb_luminance
  
  Usage:
  
   my $luminance = rgb_luminance($rgb);
  
  Calculate standard/objective luminance from RGB value using this formula:
  
   (0.2126*R) + (0.7152*G) + (0.0722*B)
  
  where R, G, and B range from 0 to 1. Return a number from 0 to 1.
  
  =head2 tint_rgb_color
  
  Usage:
  
   my $new_rgb = tint_rgb_color($rgb, $tint_rgb, $pct)
  
  Tint C<$rgb> with C<$tint_rgb>. $pct is by default 0.5. It is similar to mixing,
  but the less luminance the color is the less it is tinted with the tint color.
  This has the effect of black color still being black instead of becoming tinted.
  
  =head2 rgb_distance
  
  Usage:
  
   my $dist = rgb_distance($rgb1, $rgb2)
  
  Calculate the euclidean RGB distance, using this formula:
  
   ( (R1-R2)**2 + (G1-G2)**2 + (B1-B2)**2 )**0.5
  
  For example, the distance between "000000" and "ffffff" is ~441.67, while the
  distance between "ffff00" and "ffffff" is 255.
  
  =head2 rgb_diff
  
  Usage:
  
   my $dist = rgb_diff($rgb1, $rgb2[ , $algo ])
  
  Calculate difference between two RGB colors, using one of several algorithms.
  The default ("euclidean") simply calculates the distance as:
  
   ( (R1-R2)**2 + (G1-G2)**2 + (B1-B2)**2 )**0.5
  
  which is the same as what L</"rgb_distance">() would produce. Another algorithm
  ("approx1") uses the following formula:
  
   ( 2*(R1-R2)**2 + 4*(G1-G2)**2 + 3*(B1-B2)**2 + Rm*((R1-R2)**2 - (B1-B2)**2)/256 )**0.5
  
  where, Rm or "R mean" is (R1+R2)/2.
  
  For more details about color difference, refer to
  L<https://en.wikipedia.org/wiki/Color_difference>.
  
  =head2 rgb_is_dark
  
  Usage:
  
   my $is_dark = rgb_is_dark($rgb)
  
  Return true if C<$rgb> is a "dark" color, which is determined by checking if the
  RGB distance to "000000" is smaller than to "ffffff".
  
  =head2 rgb_is_light
  
  Usage:
  
   my $is_light = rgb_is_light($rgb)
  
  Return true if C<$rgb> is a "light" color, which is determined by checking if
  the RGB distance to "000000" is larger than to "ffffff".
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Color-RGB-Util>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Color-RGB-Util>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Color-RGB-Util>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Color::ANSI::Util>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018, 2015, 2014, 2013 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
COLOR_RGB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


our $DATE = '2019-03-26'; # DATE
our $VERSION = '0.005'; # VERSION

use 5.010001;
use strict;
use warnings;

use App::calx;
use DateTime;
use Getopt::Long qw(:config gnu_getopt no_ignore_case);

my %args = (
    months => 1,
    caldates_modules => [],
);

GetOptions(
    'h'   => sub { $args{highlight_today} = 0 },
    '1'   => sub { $args{months} = 1  },
    '3'   => sub { $args{months} = 3  },
    'y'   => sub { $args{months} = 12 },
    'c=s' => $args{caldates_modules},
    'a'   => sub {
        require PERLANCAR::Module::List;

        my $mods = PERLANCAR::Module::List::list_modules(
            "Calendar::Dates::", {list_modules=>1, recurse=>1});
        my @res = sort keys %$mods;
        for (@res) { s/\ACalendar::Dates::// }
        $args{caldates_modules} = \@res;
    },
);

my $dt = DateTime->now;

if (@ARGV == 1) {
    $args{year}   = $ARGV[0];
    $args{months} = 12;
} elsif (@ARGV == 2) {
    $args{month} = $ARGV[0];
    $args{year}  = $ARGV[1];
} else {
    $args{month} = $dt->month;
    $args{year}  = $dt->year;
}

if ($args{months} == 3) {
    $dt = DateTime->new(year=>$args{year}, month=>$args{month}//1, day=>1);
    $dt->subtract(months=>1);
    $args{month} = $dt->month;
    $args{year}  = $dt->year;
}

my $res = App::calx::gen_calendar(%args);
die $res->[1] unless $res->[0] == 200;
say $res->[2];

1;
# ABSTRACT: Display calendar
# PODNAME: calx

__END__

=pod

=encoding UTF-8

=head1 NAME

calx - Display calendar

=head1 VERSION

This document describes version 0.005 of calx (from Perl distribution App-calx), released on 2019-03-26.

=head1 SYNOPSIS

 # show calendar for the current month, with dates from Calendar::Dates::ID::Holiday
 % calx -c ID::Holiday

 # show calendar for the current month, with dates from Calendar::Dates::ID::Holiday and Calendar::Dates::SG::Holiday
 % calx -c ID::Holiday -c SD::Holiday

 # show calendar for the current month, with dates from all installed Calendar::Dates::* modules
 % calx -a

 # show calendar for the whole year
 % calx 2019 -c ID::Holiday

 # show calendar for a certain month and year
 % calx 2 2019 -c ID::Holiday

=head1 DESCRIPTION

This command provides a subset of B<cal> functionality for displaying ASCII
calendar on the command-line. It currently starts the week at Monday and
highlights (and lists) dates from one or more L<Calendar::Dates>::* modules.

=head1 OPTIONS

 % calx [opts] [[month] year]

Most options follow B<cal>. Not all options from B<cal> are
supported/recognized. Some options are specific to B<calx>.

=head2 -1

Show a single month of calendar (the default).

=head2 -3

Show three months of calendar (previous, current, next).

=head2 -h

Turn off highlighting of today.

=head2 -y

Show one year (12 months) of calendar (the default if only year is specified).

=head2 -c MODULE+

Get dates from a L<Calendar::Dates> module (value is name of module without the
"Calendar::Dates::" prefix). Can be specified multiple times.

=head2 -a

Get dates from all installed C<Calendar::Dates::*> modules.

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/App-calx>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-App-calx>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-calx>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 SEE ALSO

B<cal> Unix utility

L<Calendar::Dates>

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2019 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
