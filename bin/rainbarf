#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
# vim:fenc=utf-8:ft=perl:et:sw=4:ts=4:sts=4
use 5.008;
use strict;
use warnings qw(all);

use List::Util qw(max sum);
use Storable qw(lock_retrieve lock_store);

## no critic (ProhibitBacktickOperators ProhibitComplexRegexes ProhibitInteractiveTest)
our $VERSION = q(1.4);

my %rgb = (
    black   => [qw[0 0 0]],
    red     => [qw[1 0 0]],
    green   => [qw[0 1 0]],
    yellow  => [qw[1 1 0]],
    blue    => [qw[0 0 1]],
    magenta => [qw[1 0 1]],
    cyan    => [qw[0 1 1]],
    white   => [qw[1 1 1]],
);

my @ticks = map { chr 0x2580 + $_ } 1 .. 8;
binmode \*STDOUT => q(encoding(utf8));

my $order   = '';
my $screen  = 0;
my $tmux    = not -t \*STDOUT;
my $rgb     = 0;
my $skip    = 0;

my ($help, $show_battery, $remaining, $bolt, $chart_bg, $chart_fg,
    $bright, $loadavg, $swap, $threshold, $width, $history);

# parse the options file
parse_config();

if (@ARGV) {
    require Getopt::Long;
    Getopt::Long::GetOptions(
        q(help)         => \$help,
        q(battery!)     => \$show_battery,
        q(remaining!)   => \$remaining,
        q(bolt!)        => \$bolt,
        q(bg=s)         => \$chart_bg,
        q(fg=s)         => \$chart_fg,
        q(bright!)      => \$bright,
        q(loadavg!)     => \$loadavg,
        q(swap!)        => \$swap,
        q(max=i)        => \$threshold,
        q(order=s)      => \$order,
        q(screen)       => \$screen,
        q(tmux!)        => \$tmux,
        q(rgb!)         => \$rgb,
        q(width=i)      => \$width,
        q(datfile=s)    => \$history,
        q(skip=i)       => \$skip,
    ) or help(-verbose => 1);
}

defaults();

my $chart = eval { lock_retrieve $history };
$chart = [ (0) x $width ] unless defined $chart;

my %top;
my $cpu = $loadavg ? load() : usage();

push @$chart => $cpu;
splice @$chart => 0, @$chart - $width if @$chart > $width;
lock_store $chart => $history
    if time - ((stat $history)[9] || 0) >= $skip;

unshift @$chart => (0) x ($width - @$chart);

# Ordering from Activity Monitor.app
my %colors = (
    f   => [ green  => 1 ], # free
    w   => [ red    => 2 ], # wired
    a   => [ yellow => 3 ], # active
    i   => [ blue   => 4 ], # inactive
    c   => [ cyan   => 5 ], # cached
    b   => [ cyan   => 5 ], # buf (FreeBSD)
    x   => [ magenta=> 6 ], # swap
);

# Custom ordering
my @order = split //x => lc $order;
for my $i (0 .. $#order) {
    my $color = $order[$i];
    $colors{$color}->[1] = $i + 1
        if exists $colors{$color};
}

my %memory = memory();
delete $memory{x} unless $swap;

my $scale = @$chart / sum values %memory;
my $norm = $#ticks / max @$chart => $threshold;
my $c = 0;
for my $type (sort { $colors{$a}->[1] <=> $colors{$b}->[1] } keys %memory) {
    print my_color(
        map { defined $_ ? $_ : $colors{$type}->[0] }
        $chart_fg => $chart_bg
    );

    for (1 .. max(1 => sprintf q(%.0f) => $scale * $memory{$type})) {
        last if $c++ >= $width;
        print $ticks[$norm * shift @$chart];
    }
}
print $ticks[$norm * $cpu] if $c < $width;

battery() if $show_battery or $remaining;
my_reset(1);

# For dependencies linting
#printf qq(%-20s\t%s\n), $_ => $INC{$_} for sort keys %INC;

sub parse_config {
    my $rcname = exists($ENV{RAINBARF})
        ? $ENV{RAINBARF}
        : qq($ENV{HOME}/.rainbarf.conf);
    if (open(my $rcfile, q(<), $rcname)) {
        while (<$rcfile>) {
            s/\#.*$//x;
            s/\s+//gx;
            if (/^(?:\-{2})?(\w+(?:=\w+)?)$/x) {
                unshift @ARGV => q(--) . $1;
            }
        }
        close $rcfile;
    }

    return;
}

sub help {
    my (@args) = @_;
    require Pod::Usage;
    return Pod::Usage::pod2usage(-noperldoc => 1, @args);
}

sub defaults {
    help(-verbose => 99)    if $help;
    $show_battery   = 1     unless defined $show_battery;
    $loadavg        = 0     unless defined $loadavg;
    $swap           = 0     unless defined $swap;
    $threshold      = 1     unless defined $threshold;
    $width          = 38    unless defined $width;
    $bright         = 0     unless defined $bright;
    $remaining      = 0     unless defined $remaining;
    $bolt           = (defined $bolt and $bolt) ? chr 0x26a1 : q(|);
    require Term::ANSIColor if not $tmux and not $screen;

    $history        = qq($ENV{HOME}/.rainbarf.dat)
                            unless defined $history;

    return;
}

sub color_idx {
    my ($color, $brightness) = @_;
    return unless defined $color;
    my ($r, $g, $b) = map { $_ * $brightness } @{$rgb{$color}};
    return q(colour) . (16 + (6 * 6 * $r) + (6 * $g) + $b);
}

sub color_rgb {
    my ($color, $brightness) = @_;
    return unless defined $color;
    return q(rgb) . join '' => map { $_ * $brightness } @{$rgb{$color}};
}

sub my_color {
    my ($fg, $bg) = @_;
    my $out;

    if ($screen) {
        $out = qq(\5{);
        $out .= defined($bg)
            ? chr ord $bg
            : q(.);
        $out .= $bright
            ? uc chr ord $fg
            : chr ord $fg;
        $out .= q(});
    } elsif ($tmux) {
        if ($rgb) {
            $fg = color_idx($fg => 5);
            $bg = color_idx($bg => 2);
        } else {
            $fg .= q(,bright) if $bright;
        }
        $out = defined($bg) ? qq(#[fg=$fg,bg=$bg]) : qq(#[fg=$fg]);
    } else {
        my ($old_fg, $old_bg) = ($fg, $bg);
        if ($rgb) {
            $fg = color_rgb($fg => 5);
            $bg = color_rgb($bg => 2);
        } else {
            $fg = qq(bright_$fg) if $bright;
        }
        my $color = defined($bg) ? qq($fg on_$bg) : $fg;
        $out = eval { Term::ANSIColor::color($color) };
        if (not defined $out or $@) {
            if ($@ =~ /bright/x) {
                $bright = 0;
                print STDERR qq(Term::ANSIColor < 3.00 does not support the "bright" attribute!\n);
                $color =~ s/,?bright_?//x;
            } elsif ($@ =~ /\brgb\d+\b/x) {
                $rgb = 0;
                print STDERR qq(Term::ANSIColor < 4.00 does not support the 256-color palette!\n);
                $color = qq($old_fg on_$old_bg);
            } else {
                die qq(Unknown error: $@\n);
            }
            $out = Term::ANSIColor::color($color);
        }
    }

    return $out;
}

sub my_reset {
    my ($eof) = @_;
    if ($screen) {
        print qq(\5{= dd});
    } elsif ($tmux) {
        print q(#[fg=default,bg=default]);
    } else {
        print Term::ANSIColor::color(q(reset));
    }
    print qq(\n) if defined $eof;
    return;
}

sub top {
    if (not %top and -x q{/usr/bin/top}) {
        my @top;
        if ($^O eq q(darwin)) {
            @top = qx{/usr/bin/top -R -F -l1 -n0 -s0 -S};
        } elsif ($^O eq q(freebsd)) {
            @top = qx{/usr/bin/top -b -d2 -I -s1 -z};
        }
        for (@top) {
            my ($key, $value) = /^([\w\s]+)\s*:\s*(.+)/x;
            next unless defined $key;
            $key =~ y/A-Z /a-z_/;
            $top{$key} = $value;
        }
        $top{cpu_usage} = delete $top{cpu} unless exists $top{cpu_usage};
        $top{physmem}   = delete $top{mem} unless exists $top{physmem};
    }
    return scalar keys %top;
}

sub load {
    my @l = qw(0 0 0);
    if (open my $loadavg, q{<}, q{/proc/loadavg}) {
        @l = (split /\s+/x, <$loadavg>)[0 .. 2];
        close $loadavg;
    } elsif (top() and exists $top{load_avg}) {
        @l = split /\s*,\s*/x, $top{load_avg};
    } elsif (-x q{/usr/bin/uptime}) {
        # fallback
        @l = (split /\s+/x, qx{/usr/bin/uptime})[-3 .. -1];
    }
    return $l[0];
}

sub usage {
    if (-e q{/proc/stat}) {
        my ($diff_usage, $prev_idle, $prev_total) = qw(-1 0 0);
        for my $i (reverse 0 .. 1) {
            my $fh;
            unless (open $fh, q{<}, q{/proc/stat}) {
                close $fh;
                return 0;
            }
            while (<$fh>) {
                next unless /^cpu\s+\d+/x;
                my @cpu = split /\s+/x;
                shift @cpu;

                my $idle = $cpu[3];
                my $total = sum(@cpu);

                my $diff_idle = $idle - $prev_idle;
                my $diff_total = $total - $prev_total;
                $diff_usage = ($diff_total - $diff_idle) / $diff_total;

                $prev_idle = $idle;
                $prev_total = $total;

                last;
            }
            close $fh;
            ## no critic (ProhibitSleepViaSelect)
            select(undef, undef, undef, $i / 10);
        }
        return $diff_usage;
    } elsif (top()) {
        my %usage =
            map { (/([\d\.]+)%\s+(\w+)/x) [1, 0] }
            split /\s*,\s*/x, $top{cpu_usage};
        return 1 - $usage{idle} / 100;
    }
}

sub memory {
    my %m;
    my %n = (K => 1/2**10, M => 1, G => 2**10);
    if (exists $top{physmem} and $top{physmem} !~ /\bunused\b/ix) {
        %m =
            map { lc $_->[2] => $_->[0] * $n{$_->[1]} }
            map { [(/(\d+)([KMG])\s+(\w)/x)] }
            split /\s*,\s*/x, $top{physmem};
        delete $m{u};
    } elsif (open my $meminfo, q{<}, q{/proc/meminfo}) {
        %m = map {
            /\b(Mem|Swap)?(Free|Cached|Active|Inactive|Total):\s*(\d+)/ix
                ? (($1 and $1 eq q(Swap))
                    ? (q(s) . lc chr ord $2 => $3)
                    : (       lc chr ord $2 => $3)
                ) : ();
        } <$meminfo>;
        close $meminfo;
        $m{c} -= delete $m{sc} || 0;
        delete $m{c} if $m{c} < 0;
        my $x = delete($m{st}) - delete($m{sf});
        $m{w} = delete($m{t}) - sum values %m;
        $m{x} = $x;
    } elsif (-x q{/usr/bin/vm_stat}) {
        # fallback
        %m = map {
            /\bPages\s+(free|active|inactive|speculative|wired\s+down):\s*(\d+)/ix
                ? (chr ord $1 => $2 << 2)
                : ();
        } qx{/usr/bin/vm_stat};
        $m{f} += delete $m{s};
    }
    if ($top{swap} and $top{swap} =~ /(\d+)([KMG])\s+(?:\+|Used,?)/ix) {
        $m{x} = $1 * $n{$2};
    }
    return %m;
}

sub battery_osx {
    my %battery = map {
        /"(TimeRemaining|(?:Max|Current)Capacity|FullyCharged|ExternalConnected)"\s*=\s*(\d+|Yes|No)/ix
            ? (lc chr ord $1 => $2)
            : ()
    } qx{/usr/sbin/ioreg -n AppleSmartBattery -r};
    return () if 5 != keys %battery;

    my $time;
    if ($battery{f} eq q(No)
        || ($battery{f} eq q(No) && $battery{e} eq q(Yes))
        || ($battery{f} eq q(Yes) && $battery{e} eq q(No))) {
        $time = $battery{t};
    }
    my $charging = ($battery{e} =~ /^y/ix);
    my $battery = eval { $battery{c} / $battery{m} };

    return ($battery, $charging, $time);
}

sub battery_acpi {
    my ($acpi_info, $acpi_state, %battery) = ('') x 2;
    return () unless grep {
        -d $_
        and -e ($acpi_info  ||= qq($_/info))
        and -e ($acpi_state ||= qq($_/state))
    } sort glob q(/proc/acpi/battery/{BAT,CMB}[0-9]);

    for my $file ($acpi_info, $acpi_state) {
        my $fh;
        if (open $fh, q(<), $file) {
            while (<$fh>) {
                my ($key, $value) = /^([\w\s]+)\s*:\s*(\w+)/x;
                next unless defined $key;
                $key =~ y/A-Z /a-z_/;
                $battery{$key} = $value;
            }
        }
        close $fh;
    }

    my $charging = $battery{charging_state} ne q(discharging);
    my $time;
    $time = eval { ($battery{remaining_capacity} / $battery{present_rate}) * 60 }
        if not $charging
        and defined $battery{present_rate}
        and $battery{present_rate} =~ /^\d+$/x;
    my $battery = eval { $battery{remaining_capacity} / $battery{last_full_capacity} };
    return ($battery, $charging, $time);
}

sub battery_sys {
    my ($uevent, %battery) = ('');
    return () unless grep {
        -d $_
        and ( ( -e qq($_/energy_full) and -e qq($_/energy_now) ) or
              ( -e qq($_/charge_now) and -e qq($_/current_now) ) )
        and -e ($uevent ||= qq($_/uevent))
    } sort glob q(/sys/class/power_supply/{BAT,CMB}[0-9]);

    my $fh;
    if (open $fh, q(<), $uevent) {
        while (<$fh>) {
            my ($key, $value) = /^POWER_SUPPLY_([^=]+)=(.*)$/x;
            next unless defined $key;
            $key =~ y/A-Z/a-z/;
            $battery{$key} = $value;
        }
    }
    close $fh;

    my $charging = $battery{status} ne q(Discharging);
    my $time;
    if (not $charging) {
        if (defined $battery{power_now} and $battery{power_now} =~ /^\d+$/x) {
            $time = eval { ($battery{energy_now} * 60 / $battery{power_now}) }
        } elsif (defined $battery{charge_now} and $battery{charge_now} =~ /^\d+$/x) {
            $time = eval { (60 * ($battery{charge_now} / 1000) / ($battery{current_now} / 1000)) }
        }
    }
    my $battery = $battery{capacity} / 100;
    return ($battery, $charging, $time);
}

sub battery_freebsd {
    my $battery = qx{/sbin/sysctl -n hw.acpi.battery.life 2>/dev/null} or return;
    my $charging = qx,/sbin/sysctl -n hw.acpi.battery.state,;
    my $time = qx,/sbin/sysctl -n hw.acpi.battery.time,;

    $battery /= 100;

    if ($charging == 2) {
        $charging = 1;
    } elsif ($charging == 7) { # Battery absent
        return;
    } else {
        $charging = 0;
    }

    return ($battery, $charging, $time);
}

sub battery {
    my @battery;
    if (-x q{/usr/sbin/ioreg}) {
        @battery = battery_osx();
    } elsif (-d q(/proc/acpi/battery)) {
        @battery = battery_acpi();
    } elsif (-d q(/sys/class/power_supply)) {
        @battery = battery_sys();
    } elsif ($^O eq q(freebsd)) {
        @battery = battery_freebsd();
    }

    battery_print(@battery);
    return;
}

sub battery_print {
    my ($battery, $charging, $time) = @_;
    if (defined $battery) {
        my_reset();
        print my_color(($charging ? q(green) : q(red)));
        if ($show_battery) {
            print $bolt;
            if ($rgb and not $screen) {
                my @color;
                if ($battery > 0.5) {
                    # green => yellow
                    @color = (int((1 - $battery) * 12), 5, 0);
                } else {
                    # yellow => red
                    @color = (5, int($battery * 12), 0);
                }
                if ($tmux) {
                    print q(#[fg=colour) . (16 + (6 * 6 * $color[0]) + (6 * $color[1]) + $color[2]) . q(]);
                } else {
                    print Term::ANSIColor::color(q(rgb) . join '' => @color);
                }
            } else {
                if ($battery < 0.333) {
                    print my_color(q(red));
                } elsif ($battery < 0.666) {
                    print my_color(q(yellow));
                } else {
                    print my_color(q(green));
                }
            }
            print $ticks[$#ticks * $battery];
        }
    }
    if ($remaining and defined $time) {
        my $sec = $time * 60;
        print q( ) . (($sec / (60 * 60)) % 24) . q(h) . (($sec / 60) % 60) . q(m);
    }
    return;
}

__DATA__
=pod

=head1 NAME

rainbarf - CPU/RAM/battery stats chart bar for tmux (and GNU screen)

=head1 VERSION

version 1.4

=head1 SYNOPSIS

 rainbarf --tmux --width 40 --no-battery

=head1 DESCRIPTION

Fancy resource usage charts to put into the L<tmux|http://tmux.sourceforge.net/> status line.
The CPU utilization history chart is tinted with the following colors to reflect the system memory allocation:

=over 4

=item * B<green>: free memory;

=item * B<yellow>: active memory;

=item * B<blue>: inactive memory;

=item * B<red>: wired memory on I<Mac OS X> / I<FreeBSD>; "unaccounted" memory on I<Linux>;

=item * B<cyan>: cached memory on I<Linux>, buf on I<FreeBSD>.

=item * B<magenta>: used swap memory.

=back

If available, battery charge is displayed on the right.

Just go to L<https://github.com/creaktive/rainbarf> to see some screenshots.

=head1 USAGE

=head2 Installation

=over 4

=item *

Traditional way:

 perl Build.PL
 ./Build test
 ./Build install

=item *

L<Homebrew|http://brew.sh/> way:

 brew install rainbarf

=item *

L<MacPorts|http://www.macports.org/> way:

 port install rainbarf

=item *

CPAN way:

 cpan -i App::rainbarf

=item *

Modern Perl way:

 cpanm git://github.com/creaktive/rainbarf.git

=back

=head2 Configuration

Add the following line to your F<~/.tmux.conf> file:

 set-option -g status-utf8 on
 set -g status-right '#(rainbarf)'

Or, under I<GNOME Terminal>:

 set-option -g status-utf8 on
 set -g status-right '#(rainbarf --rgb)'

Reload the tmux config by running C<tmux source-file ~/.tmux.conf>.

=head1 CONFIGURATION FILE

C<~/.rainbarf.conf> can be used to persistently store L</OPTIONS>:

 # example configuration file
 width=20   # widget width
 bolt       # fancy charging character
 remaining  # display remaining battery
 rgb        # 256-colored palette

L</OPTIONS> specified via command line override that values.
Configuration file can be specified via C<RAINBARF> environment variable:

 RAINBARF=~/.rainbarf.conf rainbarf

=head1 OPTIONS

=over 4

=item C<--help>

This.

=item C<--[no]battery>

Display the battery charge indicator.
Enabled by default.

=item C<--[no]remaining>

Display the time remaining until the battery is fully charged/empty. See L</CAVEAT>.
Disabled by default.

=item C<--[no]bolt>

Display even fancier battery indicator.
Disabled by default.

=item C<--[no]bright>

Tricky one. Disabled by default. See L</CAVEAT>.

=item C<--[no]rgb>

Use the B<RGB> palette instead of the system colors.
Also disabled by default, for the same reasons as above.

=item C<--fg COLOR_NAME>

Force chart foreground color.

=item C<--bg COLOR_NAME>

Force chart background color.

=item C<--[no]loadavg>

Use L<load average|https://en.wikipedia.org/wiki/Load_(computing)> metric instead of CPU utilization.
You might want to set the C<--max> threshold since this is an absolute value and has varying ranges on different systems.
Disabled by default.

=item C<--[no]swap>

Display the swap usage.
Used swap amount is added to the total amount, but the free swap amount is not!
Disabled by default.

=item C<--max NUMBER>

Maximum C<loadavg> you expect before rescaling the chart. Default is 1.

=item C<--order INDEXES>

Specify the memory usage bar order.
The default is C<fwaic> ( B<f>ree, B<w>ired, B<a>ctive, B<i>nactive & B<c>ached ).

=item C<--[no]tmux>

Force C<tmux> colors mode.
By default, L<rainbarf> detects automatically if it is being called from C<tmux> or from the interactive shell.

=item C<--screen>

L<screen(1)|http://manpages.ubuntu.com/manpages/hardy/man1/screen.1.html> colors mode. B<Experimental>. See L</CAVEAT>.

=item C<--width NUMBER>

Chart width. Default is 38, so both the chart and the battery indicator fit the C<tmux> status line.
Higher values may require disabling the battery indicator or raising the C<status-right-length> value in F<~/.tmux.conf>.

=item C<--datfile FILENAME>

Specify the file to log CPU stats to.
Default: F<$HOME/.rainbarf.dat>

=item C<--skip NUMBER>

Do not write CPU stats if file already exists and is newer than this many seconds.
Useful if you refresh C<tmux> status quite frequently.

=back

=head1 CAVEAT

=head2 Time remaining

If the C<--remaining> option is present but you do not see the time in your status bar, you may need to increase the value of C<status-right-length> to 48.

=head2 Color scheme

If you only see the memory usage bars but no CPU utilization chart, that's because your terminal's color scheme need an explicit distinction between foreground and background colors.
For instance, "red on red background" will be displayed as a red block on such terminals.
Thus, you may need the ANSI B<bright> attribute for greater contrast, or maybe consider switching to the 256-color palette.
There are some issues with that, though:

=over 4

=item 1.

Other color schemes (notably, L<solarized|http://ethanschoonover.com/solarized>) have different meaning for the ANSI B<bright> attribute.
So using it will result in a quite psychedelic appearance.
256-color pallette, activated by the C<--rgb> flag, is unaffected by that.

=item 2.

The older versions of L<Term::ANSIColor> dependency do not recognize bright/RGB settings, falling back to the default behavior (plain 16 colors).
However, the whole L<Term::ANSIColor> is optional, it is only required to preview the effects of the L</OPTIONS> via command line before actually editing the F<~/.tmux.conf>.
That is, C<rainbarf --bright --tmux> B<is guaranteed to work> despite the outdated L<Term::ANSIColor>!

=back

Another option is skipping the system colors altogether and use the B<RGB> palette (C<rainbarf --rgb>).
This fixes the I<issue 1>, but doesn't affect the I<issue 2>.
It still looks better, though.

=head2 Persistent storage

CPU utilization stats are persistently stored in the F<~/.rainbarf.dat> file.
Every L<rainbarf> execution will update and rotate that file.
Since C<tmux> calls L<rainbarf> periodically (every 15 seconds, by default), the chart will display CPU utilization for the last ~9.5 minutes (15 * 38).
Thus, several C<tmux> instances running simultaneously for the same user will result in a faster chart scrolling.

=head2 screen

Stable C<screen> version unfortunately has a broken UTF-8 handling specifically for the status bar.
Thus, I have only tested the L<rainbarf> with the variant from L<git://git.savannah.gnu.org/screen.git>.
My F<~/.screenrc> contents:

 backtick 1 15 15 rainbarf --bright --screen
 hardstatus string "%1`"
 hardstatus lastline

=head1 REFERENCES

=over 4

=item *

L<top(1)|http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/top.1.html> is used to get the CPU/RAM stats if no F</proc> filesystem is available.

=item *

L<ioreg(8)|http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/ioreg.8.html> is used to get the battery status on I<Mac OS X>.

=item *

L<ACPI|http://www.tldp.org/howto/acpi-howto/usingacpi.html> is used to get the battery status on I<Linux>.

=item *

L<Battery|https://github.com/Goles/Battery> was a source of inspiration.

=item *

L<Spark|http://zachholman.com/spark/> was another source of inspiration.

=back

=head1 AUTHOR

Stanislaw Pusep <stas@sysd.org>

=head1 CONTRIBUTORS

=over 4

=item *

L<Chris Knadler|https://github.com/cknadler>

=item *

L<cinaeco|https://github.com/cinaeco>

=item *

L<Clemens Hammacher|https://github.com/hammacher>

=item *

L<H.Merijn Brand|https://github.com/Tux>

=item *

L<Henrik Hodne|https://github.com/henrikhodne>

=item *

L<Joe Hassick|https://github.com/jh3>

=item *

L<Josh Matthews|https://github.com/jmatth>

=item *

L<Lars Engels|https://github.com/larsengels>

=item *

L<Sergey Romanov|https://github.com/sergeyromanov>

=item *

L<Tom Cammann|https://github.com/takac>

=item *

L<Tuomas Jormola|https://github.com/tjormola>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2016 by Stanislaw Pusep <stas@sysd.org>.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
