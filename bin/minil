#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Config/Identity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_IDENTITY';
  package Config::Identity;
  # ABSTRACT: Load (and optionally decrypt via GnuPG) user/pass identity information 
  $Config::Identity::VERSION = '0.0018';
  
  use strict;
  use warnings;
  
  use Carp;
  use IPC::Run qw/ start finish /;
  use File::HomeDir();
  use File::Spec;
  
  our $home = File::HomeDir->home;
  {
      my $gpg;
      sub GPG() { $ENV{CI_GPG} || ( $gpg ||= do {
          require File::Which;
          $gpg = File::Which::which( $_ ) and last for qw/ gpg gpg2 /;
          $gpg;
      } ) }
  }
  sub GPG_ARGUMENTS() { $ENV{CI_GPG_ARGUMENTS} || '' }
  
  # TODO Do not even need to do this, since the file is on disk already...
  sub decrypt {
      my $self = shift;
      my $file = shift;
  
      my $gpg = GPG or croak "Missing gpg";
      my $gpg_arguments = GPG_ARGUMENTS;
      my $run;
      # Old versions, please ignore
      #$run = "$gpg $gpg_arguments -qd --no-tty --command-fd 0 --status-fd 1";
      #$run = "$gpg $gpg_arguments -qd --no-tty --command-fd 0";
      $run = "$gpg $gpg_arguments -qd --no-tty";
      my @run = split m/\s+/, $run;
      push @run, $file;
      my $process = start( \@run, '>pipe', \*OUT, '2>pipe', \*ERR );
      my $output = join '', <OUT>;
      my $_error = join '', <ERR>;
      finish $process;
      return ( $output, $_error );
  }
  
  sub best {
      my $self = shift;
      my $stub = shift;
      my $base = shift;
      $base = $home unless defined $base;
  
      croak "Missing stub" unless defined $stub && length $stub;
  
      for my $i0 ( ".$stub-identity", ".$stub" ) {
          for my $i1 ( "." ) {
              my $path = File::Spec->catfile( $base, $i1, $i0 );
              return $path if -f $path;
          }
      }
  
      return '';
  }
  
  sub read {
      my $self = shift;
      my $file = shift;
  
      croak "Missing file" unless -f $file;
      croak "Cannot read file ($file)" unless -r $file;
  
      my $binary = -B $file;
  
      open my $handle, $file or croak $!;
      binmode $handle if $binary;
      local $/ = undef;
      my $content = <$handle>;
      close $handle or warn $!;
  
      if ( $binary || $content =~ m/----BEGIN PGP MESSAGE----/ ) {
          my ( $_content, $error ) = $self->decrypt( $file );
          if ( $error ) {
              carp "Error during decryption of content" . $binary ? '' : "\n$content";
              croak "Error during decryption of $file:\n$error";
          }
          $content = $_content;
      }
      
      return $content;
  }
  
  sub parse {
      my $self = shift;
      my $content = shift;
  
      return unless $content;
      my %content;
      for ( split m/\n/, $content ) {
          next if /^\s*#/;
          next unless m/\S/;
          next unless my ($key, $value) = /^\s*(\w+)\s+(.+)$/;
          $content{$key} = $value;
      }
      return %content;
  }
  
  sub load_best {
      my $self = shift;
      my $stub = shift;
  
      die "Unable to find .$stub-identity or .$stub" unless my $path = $self->best( $stub );
      return $self->load( $path );
  }
  
  sub try_best {
      my $self = shift;
      my $stub = shift;
  
      return unless my $path = $self->best( $stub );
      return $self->load( $path );
  }
  
  sub load {
      my $self = shift;
      my $file = shift;
  
      return $self->parse( $self->read( $file ) );
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Identity - Load (and optionally decrypt via GnuPG) user/pass identity information 
  
  =head1 VERSION
  
  version 0.0018
  
  =head1 SYNOPSIS
  
  PAUSE:
  
      use Config::Identity::PAUSE;
  
      # 1. Find either $HOME/.pause-identity or $HOME/.pause
      # 2. Decrypt the found file (if necessary), read, and parse it
      # 3. Throw an exception unless  %identity has 'user' and 'password' defined
  
      my %identity = Config::Identity::PAUSE->load;
      print "user: $identity{user} password: $identity{password}\n";
  
  GitHub API:
  
      use Config::Identity::GitHub;
  
      # 1. Find either $HOME/.github-identity or $HOME/.github
      # 2. Decrypt the found file (if necessary) read, and parse it
      # 3. Throw an exception unless %identity has 'login' and 'token' defined
  
      my %identity = Config::Identity::PAUSE->load;
      print "login: $identity{login} token: $identity{token}\n";
  
  =head1 DESCRIPTION
  
  Config::Identity is a tool for loadiing (and optionally decrypting via GnuPG) user/pass identity information
  
  For GitHub API access, an identity is a C<login>/C<token> pair
  
  For PAUSE access, an identity is a C<user>/C<password> pair
  
  =head1 USAGE
  
  =head2 %identity = Config::Identity->load_best( <stub> )
  
  First attempt to load an identity from $HOME/.<stub>-identity
  
  If that file does not exist, then attempt to load an identity from $HOME/.<stub>
  
  The file may be optionally GnuPG encrypted
  
  %identity will be populated like so:
  
      <key> <value>
  
  For example:
  
      username alice
      password hunter2
  
  =head1 Using a custom C<gpg> or passing custom arguments
  
  You can specify a custom C<gpg> executable by setting the CI_GPG environment variable
  
      export CI_GPG="$HOME/bin/gpg"
  
  You can pass custom arguments by setting the CI_GPG_ARGUMENTS environment variable
  
      export CI_GPG_ARGUMENTS="--no-secmem-warning"
  
  =head1 Encrypting your identity information with GnuPG
  
  If you've never used GnuPG before, first initialize it:
  
      # Follow the prompts to create a new key for yourself
      gpg --gen-key 
  
  To encrypt your GitHub identity with GnuPG using the above key:
  
      # Follow the prompts, using the above key as the "recipient"
      # Use ^D once you've finished typing out your authentication information
      gpg -ea > $HOME/.github
  
  =head1 Caching your GnuPG secret key via gpg-agent
  
  Put the following in your .*rc
  
      if which gpg-agent 1>/dev/null
      then
          if test -f $HOME/.gpg-agent-info && \
              kill -0 `cut -d: -f 2 $HOME/.gpg-agent-info` 2>/dev/null
          then
              . "${HOME}/.gpg-agent-info"
              export GPG_AGENT_INFO
          else
              eval `gpg-agent --daemon --write-env-file "${HOME}/.gpg-agent-info"`
          fi
      else
      fi
  
  =head1 PAUSE identity format
  
      user <user>
      password <password>
  
  C<username> can also be used as alias for C<user>
  
  =head1 GitHub identity format
  
      login <login>
      token <token>
  
  =head1 AUTHOR
  
  Robert Krimen <robertkrimen@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Robert Krimen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CONFIG_IDENTITY

$fatpacked{"Config/Identity/GitHub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_IDENTITY_GITHUB';
  package Config::Identity::GitHub;
  
  use strict;
  use warnings;
  
  use Config::Identity;
  use Carp;
  
  our $STUB = 'github';
  sub STUB { defined $_ and return $_ for $ENV{CI_GITHUB_STUB}, $STUB }
  
  sub load {
      my $self = shift;
      return Config::Identity->try_best( $self->STUB );
  }
  
  sub check {
      my $self = shift;
      my %identity = @_;
      my @missing;
      defined $identity{$_} && length $identity{$_}
          or push @missing, $_ for qw/ login token /;
      croak "Missing ", join ' and ', @missing if @missing;
  }
  
  sub load_check {
      my $self = shift;
      my %identity = $self->load;
      $self->check( %identity );
      return %identity;
  }
  
  1;
  
CONFIG_IDENTITY_GITHUB

$fatpacked{"Config/Identity/PAUSE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_IDENTITY_PAUSE';
  package Config::Identity::PAUSE;
  
  use strict;
  use warnings;
  
  use Config::Identity;
  use Carp;
  
  our $STUB = 'pause';
  sub STUB { defined $_ and return $_ for $ENV{CI_PAUSE_STUB}, $STUB }
  
  sub load {
      my $self = shift;
      my %identity =  Config::Identity->try_best( $self->STUB );
      $identity{user} = $identity{username} if exists $identity{username} && ! exists $identity{user};
      $identity{username} = $identity{user} if exists $identity{user} && ! exists $identity{username};
      return %identity;
  }
  
  sub check {
      my $self = shift;
      my %identity = @_;
      my @missing;
      defined $identity{$_} && length $identity{$_}
          or push @missing, $_ for qw/ user password /;
      croak "Missing ", join ' and ', @missing if @missing;
  }
  
  sub load_check {
      my $self = shift;
      my %identity = $self->load;
      $self->check( %identity );
      return %identity;
  }
  
  1;
CONFIG_IDENTITY_PAUSE

$fatpacked{"Data/Section/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_SECTION_SIMPLE';
  package Data::Section::Simple;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.07';
  
  use base qw(Exporter);
  our @EXPORT_OK = qw(get_data_section);
  
  sub new {
      my($class, $pkg) = @_;
      bless { package => $pkg || caller }, $class;
  }
  
  sub get_data_section {
      my $self = ref $_[0] ? shift : __PACKAGE__->new(scalar caller);
  
      if (@_) {
          my $all = $self->get_data_section;
          return unless $all;
          return $all->{$_[0]};
      } else {
          my $d = do { no strict 'refs'; \*{$self->{package}."::DATA"} };
          return unless defined fileno $d;
  
          seek $d, 0, 0;
          my $content = join '', <$d>;
          $content =~ s/^.*\n__DATA__\n/\n/s; # for win32
          $content =~ s/\n__END__\n.*$/\n/s;
  
          my @data = split /^@@\s+(.+?)\s*\r?\n/m, $content;
          shift @data; # trailing whitespaces
  
          my $all = {};
          while (@data) {
              my ($name, $content) = splice @data, 0, 2;
              $all->{$name} = $content;
          }
  
          return $all;
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Data::Section::Simple - Read data from __DATA__
  
  =head1 SYNOPSIS
  
    use Data::Section::Simple qw(get_data_section);
  
    # Functional interface -- reads from caller package __DATA__
    my $all = get_data_section; # All data in hash reference
    my $foo = get_data_section('foo.html');
  
    # OO - allows reading from other packages
    my $reader = Data::Section::Simple->new($package);
    my $all = $reader->get_data_section;
  
    __DATA__
  
    @@ foo.html
    <html>
     <body>Hello</body>
    </html>
  
    @@ bar.tt
    [% IF true %]
      Foo
    [% END %]
  
  =head1 DESCRIPTION
  
  Data::Section::Simple is a simple module to extract data from
  C<__DATA__> section of the file.
  
  =head1 LIMITATIONS
  
  As the name suggests, this module is a simpler version of the
  excellent L<Data::Section>. If you want more functionalities such as
  merging data sections or changing header patterns, use
  L<Data::Section> instead.
  
  This module does not implement caching (yet) which means in every
  C<get_data_section> or C<< get_data_section($name) >> this module
  seeks and re-reads the data section. If you want to avoid doing so for
  the better performance, you should implement caching in your own
  caller code.
  
  =head1 BUGS
  
  =head2 __DATA__ appearing elsewhere
  
  If you data section has literal C<__DATA__> in the data section, this
  module might be tricked by that. Although since its pattern match is
  greedy, C<__DATA__> appearing I<before> the actual data section
  (i.e. in the code) might be okay.
  
  This is by design -- in theory you can C<tell> the DATA handle before
  reading it, but then reloading the data section of the file (handy for
  developing inline templates with PSGI web applications) would fail
  because the pos would be changed.
  
  If you don't like this design, again, use the superior
  L<Data::Section>.
  
  =head2 utf8 pragma
  
  If you enable L<utf8> pragma in the caller's package (or the package
  you're inspecting with the OO interface), the data retrieved via
  C<get_data_section> is decoded, but otherwise undecoded. There's no
  reliable way for this module to programmatically know whether utf8
  pragma is enabled or not: it's your responsibility to handle them
  correctly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2010- Tatsuhiko Miyagawa
  
  The code to read DATA section is based on Mojo::Command get_all_data:
  Copyright 2008-2010 Sebastian Riedel
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Data::Section> L<Inline::Files>
  
  =cut
DATA_SECTION_SIMPLE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.13';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.00503;
  use strict;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};
  BEGIN {
  	$VERSION = '1.00';
  
  	# Inherit manually
  	require Exporter;
  	@ISA       = qw{ Exporter };
  	@EXPORT    = qw{ home     };
  	@EXPORT_OK = qw{
  		home
  		my_home
  		my_desktop
  		my_documents
  		my_music
  		my_pictures
  		my_videos
  		my_data
  		my_dist_config
  		my_dist_data
  		users_home
  		users_desktop
  		users_documents
  		users_music
  		users_pictures
  		users_videos
  		users_data
  	};
  
  	# %~ doesn't need (and won't take) exporting, as it's a magic
  	# symbol name that's always looked for in package 'main'.
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ( $IMPLEMENTED_BY ) {
  	# Allow for custom HomeDir classes
  	# Leave it as the existing value
  } elsif ( $^O eq 'MSWin32' ) {
  	# All versions of Windows
  	$IMPLEMENTED_BY = 'File::HomeDir::Windows';
  } elsif ( $^O eq 'darwin') {
  	# 1st: try Mac::SystemDirectory by chansen
  	if ( eval { require Mac::SystemDirectory; 1 } ) {
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
  	} elsif ( eval { require Mac::Files; 1 } ) {
  		# 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
  	} else {
  		# 3rd: fallback: pure perl
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin';
  	}
  } elsif ( $^O eq 'MacOS' ) {
  	# Legacy Mac OS
  	$IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  } elsif ( File::Which::which('xdg-user-dir') ) {
  	# freedesktop unixes
  	$IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  } else {
  	# Default to Unix semantics
  	$IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  unless ( _DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver') ) {
  	Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	$IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop {
  	$IMPLEMENTED_BY->can('my_desktop')
  		? $IMPLEMENTED_BY->my_desktop
  		: Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents {
  	$IMPLEMENTED_BY->can('my_documents')
  		? $IMPLEMENTED_BY->my_documents
  		: Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music {
  	$IMPLEMENTED_BY->can('my_music')
  		? $IMPLEMENTED_BY->my_music
  		: Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures {
  	$IMPLEMENTED_BY->can('my_pictures')
  		? $IMPLEMENTED_BY->my_pictures
  		: Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos {
  	$IMPLEMENTED_BY->can('my_videos')
  		? $IMPLEMENTED_BY->my_videos
  		: Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data {
  	$IMPLEMENTED_BY->can('my_data')
  		? $IMPLEMENTED_BY->my_data
  		: Carp::croak("The my_data method is not implemented on this platform");
  }
  
  
  sub my_dist_data {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_data method requires an argument");
  	my $data   = my_data();
  
          # If datadir is not defined, there's nothing we can do: bail out
          # and return nothing...	
  	return undef unless defined $data;
  
          # On traditional unixes, hide the top-level directory
  	my $var = $data eq home()
  		? File::Spec->catdir( $data, '.perl', 'dist', $dist )
  		: File::Spec->catdir( $data, 'Perl',  'dist', $dist );
  
  	# directory exists: return it
  	return $var if -d $var;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $var );
  	return $var;
  }
  
  sub my_dist_config {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_config method requires an argument");
  
  	# not all platforms support a specific my_config() method
  	my $config = $IMPLEMENTED_BY->can('my_config')
  		? $IMPLEMENTED_BY->my_config
  		: $IMPLEMENTED_BY->my_documents;
  
  	# If neither configdir nor my_documents is defined, there's
  	# nothing we can do: bail out and return nothing...	
  	return undef unless defined $config;
  
  	# On traditional unixes, hide the top-level dir
  	my $etc = $config eq home()
  		? File::Spec->catdir( $config, '.perl', $dist )
  		: File::Spec->catdir( $config, 'Perl',  $dist );
  
  	# directory exists: return it
  	return $etc if -d $etc;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $etc );
  	return $etc;
  }
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	$IMPLEMENTED_BY->can('users_home')
  		? $IMPLEMENTED_BY->users_home( $_[-1] )
  		: Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop {
  	$IMPLEMENTED_BY->can('users_desktop')
  		? $IMPLEMENTED_BY->users_desktop( $_[-1] )
  		: Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents {
  	$IMPLEMENTED_BY->can('users_documents')
  		? $IMPLEMENTED_BY->users_documents( $_[-1] )
  		: Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music {
  	$IMPLEMENTED_BY->can('users_music')
  		? $IMPLEMENTED_BY->users_music( $_[-1] )
  		: Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures {
  	$IMPLEMENTED_BY->can('users_pictures')
  		? $IMPLEMENTED_BY->users_pictures( $_[-1] )
  		: Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos {
  	$IMPLEMENTED_BY->can('users_videos')
  		? $IMPLEMENTED_BY->users_videos( $_[-1] )
  		: Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data {
  	$IMPLEMENTED_BY->can('users_data')
  		? $IMPLEMENTED_BY->users_data( $_[-1] )
  		: Carp::croak("The users_data method is not implemented on this platform");
  }
  
  
  
  
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$) {
  	# Allow to be called as a method
  	if ( $_[0] and $_[0] eq 'File::HomeDir' ) {
  		shift();
  	}
  
  	# No params means my home
  	return my_home() unless @_;
  
  	# Check the param
  	my $name = shift;
  	if ( ! defined $name ) {
  		Carp::croak("Can't use undef as a username");
  	}
  	if ( ! length $name ) {
  		Carp::croak("Can't use empty-string (\"\") as a username");
  	}
  
  	# A dot also means my home
  	### Is this meant to mean File::Spec->curdir?
  	if ( $name eq '.' ) {
  		return my_home();
  	}
  
  	# Now hand off to the implementor
  	$IMPLEMENTED_BY->users_home($name);
  }
  
  
  
  
  
  #####################################################################
  # Tie-Based Interface
  
  # Okay, things below this point get scary
  
  CLASS: {
  	# Make the class for the %~ tied hash:
  	package File::HomeDir::TIE;
  
  	# Make the singleton object.
  	# (We don't use the hash for anything, though)
  	### THEN WHY MAKE IT???
  	my $SINGLETON = bless {};
  
  	sub TIEHASH { $SINGLETON }
  
  	sub FETCH {
  		# Catch a bad username
  		unless ( defined $_[1] ) {
  			Carp::croak("Can't use undef as a username");
  		}
  
  		# Get our homedir
  		unless ( length $_[1] ) {
  			return File::HomeDir::my_home();
  		}
  
  		# Get a named user's homedir
  		Carp::carp("The tied %~ hash has been deprecated");
  		return File::HomeDir::home($_[1]);
  	}
  
  	sub STORE    { _bad('STORE')    }
  	sub EXISTS   { _bad('EXISTS')   }
  	sub DELETE   { _bad('DELETE')   }
  	sub CLEAR    { _bad('CLEAR')    }
  	sub FIRSTKEY { _bad('FIRSTKEY') }
  	sub NEXTKEY  { _bad('NEXTKEY')  }
  
  	sub _bad ($) {
  		Carp::croak("You can't $_[0] with the %~ hash")
  	}
  }
  
  # Do the actual tie of the global %~ variable
  tie %~, 'File::HomeDir::TIE';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typicaly your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  This module provides two main interfaces.
  
  The first is a modern L<File::Spec>-style interface with a consistent
  OO API and different implementation modules to support various
  platforms. You are B<strongly> recommended to use this interface.
  
  The second interface is for legacy support of the original 0.07 interface
  that exported a C<home()> function by default and tied the C<%~> variable.
  
  It is generally not recommended that you use this interface, but due to
  back-compatibility reasons they will remain supported until at least 2010.
  
  The C<%~> interface has been deprecated. Documentation was removed in 2009,
  Unit test were removed in 2011, usage will issue warnings from 2012, and the
  interface will be removed entirely in 2015  (in line with the general Perl
  toolchain convention of a 10 year support period for legacy APIs that
  are potentially or actually in common use).
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementions required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalisation. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should stored their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's homedir,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's homedir, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single param and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no param, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jérôme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.00503;
  use strict;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	my $home = (getpwuid($<))[7];
  	return $home if $home && -d $home;
  
  	return undef;
  }
  
  sub _my_home {
  	my($class, $path) = @_;
  	my $home = $class->my_home;
  	return undef unless defined $home;
  
  	my $folder = "$home/$path";
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  sub my_desktop {
  	my $class = shift;
  	$class->_my_home('Desktop');
  }
  
  sub my_documents {
  	my $class = shift;
  	$class->_my_home('Documents');
  }
  
  sub my_data {
  	my $class = shift;
  	$class->_my_home('Library/Application Support');
  }
  
  sub my_music {
  	my $class = shift;
  	$class->_my_home('Music');
  }
  
  sub my_pictures {
  	my $class = shift;
  	$class->_my_home('Pictures');
  }
  
  sub my_videos {
  	my $class = shift;
  	$class->_my_home('Movies');
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  
  	# This is only a child class of the pure Perl darwin
  	# class so that we can do homedir detection of all three
  	# drivers at one via ->isa.
  	@ISA = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kCurrentUserFolderType(),
  	);
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDesktopFolderType(),
  	);
  }
  
  sub my_documents {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDocumentsFolderType(),
  	);
  }
  
  sub my_data {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kApplicationSupportFolderType(),
  	);
  }
  
  sub my_music {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMusicDocumentsFolderType(),
  	);
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kPictureDocumentsFolderType(),
  	);
  }
  
  sub my_videos {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMovieDocumentsFolderType(),
  	);
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::Files;
  	my $folder = Mac::Files::FindFolder(
  		Mac::Files::kUserDomain(),
  		$name,
  	);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::SystemDirectory'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::SystemDirectory;
  	return Mac::SystemDirectory::HomeDirectory();
  }
  
  # from 10.4
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())
  	}
  	||
  	$class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())
  	}
  	||
  	$class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())
  	}
  	||
  	$class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())
  	}
  	||
  	$class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())
  	}
  	||
  	$class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())
  	}
  	||
  	$class->SUPER::my_videos;
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::SystemDirectory;
  	my $folder = Mac::SystemDirectory::FindDirectory($name);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.00503;
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.00';
  }
  
  sub my_home {
  	Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.00503;
  use strict;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my {
  	# No quoting because input is hard-coded and only comes from this module
  	my $thingy = qx($xdgprog $_[1]);
  	chomp $thingy;
  	return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP')   }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC')     }
  sub my_pictures  { shift->_my('PICTURES')  }
  sub my_videos    { shift->_my('VIDEOS')    }
  
  sub my_data {
  	$ENV{XDG_DATA_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .local share }
  	);
  }
  
  sub my_config {
  	$ENV{XDG_CONFIG_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .config }
  	);
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD')    }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES')   }
  
  sub my_cache {
      $ENV{XDG_CACHE_HOME}
      ||
      File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.');   }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.');     }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.');  }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.');    }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.');      }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;
    $docs    = File::HomeDir->my_documents;
    $music   = File::HomeDir->my_music;
    $pics    = File::HomeDir->my_pictures;
    $videos  = File::HomeDir->my_videos;
    $data    = File::HomeDir->my_data;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE: {
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# Try for $ENV{HOME} if we have it
  	if ( defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	### DESPERATION SETS IN
  
  	# We could use the desktop
  	SCOPE: {
  		local $@;
  		eval {
  			my $home = $class->my_desktop;
  			return $home if $home and -d $home;
  		};
  	}
  
  	# Desperation on any platform
  	SCOPE: {
  		# On some platforms getpwuid dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# Find the desktop via Mac::Files
  	local $SIG{'__DIE__'} = '';
  	require Mac::Files;
  	my $home = Mac::Files::FindFolder(
  		Mac::Files::kOnSystemDisk(),
  		Mac::Files::kDesktopFolderType(),
  		);
  	return $home if $home and -d $home;
  
  	Carp::croak("Could not locate current user's desktop");
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	SCOPE: {
  		# On some platforms getpwnam dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwnam($name))[7];
  		return $home if defined $home and -d $home;
  	}
  
  	Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macs
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA %DIR $ENABLED};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  	%DIR     = ();
  	$ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import {
  	my $class = shift;
  	die "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
  	# Fill the test directories
  	my $BASE  = File::Temp::tempdir( CLEANUP => 1 );
  	%DIR = map { $_ => File::Spec->catdir( $BASE, $_ ) } qw{
  		my_home
  		my_desktop
  		my_documents
  		my_data
  		my_music
  		my_pictures
  		my_videos
  	};
  
  	# Hijack HOME to the home directory
  	$ENV{HOME} = $DIR{my_home};
  
  	# Make File::HomeDir load us instead of the native driver
  	$File::HomeDir::IMPLEMENTED_BY = # Prevent a warning
  	$File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
  	# Ready to go
  	$ENABLED = 1;
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	mkdir($DIR{my_home}, 0755) unless -d $DIR{my_home};
  	return $DIR{my_home};
  }
  
  sub my_desktop {
  	mkdir($DIR{my_desktop}, 0755) unless -d $DIR{my_desktop};
  	return $DIR{my_desktop};
  }
  
  sub my_documents {
  	mkdir($DIR{my_documents}, 0755) unless -f $DIR{my_documents};
  	return $DIR{my_documents};
  }
  
  sub my_data {
  	mkdir($DIR{my_data}, 0755) unless -d $DIR{my_data};
  	return $DIR{my_data};
  }
  
  sub my_music {
  	mkdir($DIR{my_music}, 0755) unless -d $DIR{my_music};
  	return $DIR{my_music};
  }
  
  sub my_pictures {
  	mkdir($DIR{my_pictures}, 0755) unless -d $DIR{my_pictures};
  	return $DIR{my_pictures};
  }
  
  sub my_videos {
  	mkdir($DIR{my_videos}, 0755) unless -d $DIR{my_videos};
  	return $DIR{my_videos};
  }
  
  sub users_home {
  	return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  	my $home  = $class->_my_home(@_);
  
  	# On Unix in general, a non-existant home means "no home"
  	# For example, "nobody"-like users might use /nonexistant
  	if ( defined $home and ! -d $home ) {
  		$home = undef;
  	}
  
  	return $home;
  }
  
  sub _my_home {
  	my $class = shift;
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# This is from the original code, but I'm guessing
  	# it means "login directory" and exists on some Unixes.
  	if ( exists $ENV{LOGDIR} and $ENV{LOGDIR} ) {
  		return $ENV{LOGDIR};
  	}
  
  	### More-desperate methods
  
  	# Light desperation on any (Unixish) platform
  	SCOPE: {
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop {
  	shift->my_home;
  }
  
  sub my_documents {
  	shift->my_home;
  }
  
  sub my_data {
  	shift->my_home;
  }
  
  sub my_music {
  	shift->my_home;
  }
  
  sub my_pictures {
  	shift->my_home;
  }
  
  sub my_videos {
  	shift->my_home;
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	# IF and only if we have getpwuid support, and the
  	# name of the user is our own, shortcut to my_home.
  	# This is needed to handle HOME environment settings.
  	if ( $name eq getpwuid($<) ) {
  		return $class->my_home;
  	}
  
  	SCOPE: {
  		my $home = (getpwnam($name))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  sub users_desktop {
  	shift->users_home(@_);
  }
  
  sub users_documents {
  	shift->users_home(@_);
  }
  
  sub users_data {
  	shift->users_home(@_);
  }
  
  sub users_music {
  	shift->users_home(@_);
  }
  
  sub users_pictures {
  	shift->users_home(@_);
  }
  
  sub users_videos {
  	shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  sub CREATE () { 1 }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# Do we have a user profile?
  	if ( exists $ENV{USERPROFILE} and $ENV{USERPROFILE} ) {
  		return $ENV{USERPROFILE};
  	}
  
  	# Some Windows use something like $ENV{HOME}
  	if ( exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH} ) {
  		return File::Spec->catpath(
  			$ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',
  		);
  	}
  
  	return undef;
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# The most correct way to find the desktop
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	# MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
  	foreach my $e ( 'USERPROFILE', 'WINDIR' ) {
  		next unless $ENV{$e};
  		my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
  		return $desktop if $desktop and $class->_d($desktop);
  	}
  
  	# As a last resort, try some hard-wired values
  	foreach my $fixed (
  		# The reason there are both types of slash here is because
  		# this set of paths has been kept from thethe original version
  		# of File::HomeDir::Win32 (before it was rewritten).
  		# I can only assume this is Cygwin-related stuff.
  		"C:\\windows\\desktop",
  		"C:\\win95\\desktop",
  		"C:/win95/desktop",
  		"C:/windows/desktop",
  	) {
  		return $fixed if $class->_d($fixed);
  	}
  
  	return undef;
  }
  
  sub my_documents {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_data {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_music {
  	my $class = shift;
  
  	# The most correct way to find my music
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	# The most correct way to find my pictures
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_videos {
  	my $class = shift;
  
  	# The most correct way to find my videos
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  # Special case version of -d
  sub _d {
  	my $self = shift;
  	my $path = shift;
  
  	# Window can legally return a UNC path from GetFolderPath.
  	# Not only is the meaning of -d complicated in this situation,
  	# but even on a local network calling -d "\\\\cifs\\path" can
  	# take several seconds. UNC can also do even weirder things,
  	# like launching processes and such.
  	# To avoid various crazy bugs caused by this, we do NOT attempt
  	# to validate UNC paths at all so that the code that is calling
  	# us has an opportunity to take special actions without our 
  	# blundering getting in the way.
  	if ( $path =~ /\\\\/ ) {
  		return 1;
  	}
  
  	# Otherwise do a stat as normal
  	return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organisations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use strict;
  use warnings;
  use Exporter   ();
  use File::Spec ();
  
  # ABSTRACT: Perl implementation of the which utility as an API
  our $VERSION = '1.19'; # VERSION
  
  
  our @ISA       = 'Exporter';
  our @EXPORT    = 'which';
  our @EXPORT_OK = 'where';
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  use constant IS_CYG => ($^O eq 'cygwin');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
    # WinNT. PATHEXT might be set on Cygwin, but not used.
    if ( $ENV{PATHEXT} ) {
      push @PATHEXT, split ';', $ENV{PATHEXT};
    } else {
      # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
      push @PATHEXT, qw{.com .exe .bat};
    }
  } elsif ( IS_VMS ) {
    push @PATHEXT, qw{.exe .com};
  } elsif ( IS_CYG ) {
    # See this for more info
    # http://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-exe
    push @PATHEXT, qw{.exe .com};
  }
  
  
  sub which {
    my ($exec) = @_;
  
    return undef unless $exec;
  
    my $all = wantarray;
    my @results = ();
  
    # check for aliases first
    if ( IS_VMS ) {
      my $symbol = `SHOW SYMBOL $exec`;
      chomp($symbol);
      unless ( $? ) {
        return $symbol unless $all;
        push @results, $symbol;
      }
    }
    if ( IS_MAC ) {
      my @aliases = split /\,/, $ENV{Aliases};
      foreach my $alias ( @aliases ) {
        # This has not been tested!!
        # PPT which says MPW-Perl cannot resolve `Alias $alias`,
        # let's just hope it's fixed
        if ( lc($alias) eq lc($exec) ) {
          chomp(my $file = `Alias $alias`);
          last unless $file;  # if it failed, just go on the normal way
          return $file unless $all;
          push @results, $file;
          # we can stop this loop as if it finds more aliases matching,
          # it'll just be the same result anyway
          last;
        }
      }
    }
  
    return $exec
            if !IS_VMS and !IS_MAC and !IS_DOS and $exec =~ /\// and -f $exec and -x $exec;
  
    my @path = File::Spec->path;
    if ( IS_DOS or IS_VMS or IS_MAC ) {
      unshift @path, File::Spec->curdir;
    }
  
    foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
      for my $ext ( @PATHEXT ) {
        my $file = $base.$ext;
  
        # We don't want dirs (as they are -x)
        next if -d $file;
  
        if (
          # Executable, normal case
          -x _
          or (
            # MacOS doesn't mark as executable so we check -e
            IS_MAC
            ||
            (
              ( IS_DOS or IS_CYG )
              and
              grep {
                $file =~ /$_\z/i
              } @PATHEXT[1..$#PATHEXT]
            )
            # DOSish systems don't pass -x on
            # non-exe/bat/com files. so we check -e.
            # However, we don't want to pass -e on files
            # that aren't in PATHEXT, like README.
            and -e _
          )
        ) {
          return $file unless $all;
          push @results, $file;
        }
      }
    }
  
    if ( $all ) {
      return @results;
    } else {
      return undef;
    }
  }
  
  
  sub where {
    # force wantarray
    my @res = which($_[0]);
    return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Which - Perl implementation of the which utility as an API
  
  =head1 VERSION
  
  version 1.19
  
  =head1 SYNOPSIS
  
   use File::Which;                  # exports which()
   use File::Which qw(which where);  # exports which() and where()
   
   my $exe_path = which 'perldoc';
   
   my @paths = where 'perl';
   # Or
   my @paths = which 'perl'; # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  L<File::Which> finds the full or relative paths to executable programs on
  the system.  This is normally the function of C<which> utility.  C<which> is
  typically implemented as either a program or a built in shell command.  On
  some platforms, such as Microsoft Windows it is not provided as part of the
  core operating system.  This module provides a consistent API to this
  functionality regardless of the underlying platform.
  
  The focus of this module is correctness and portability.  As a consequence
  platforms where the current directory is implicitly part of the search path
  such as Microsoft Windows will find executables in the current directory,
  whereas on platforms such as UNIX where this is not the case executables 
  in the current directory will only be found if the current directory is
  explicitly added to the path.
  
  If you need a portable C<which> on the command line in an environment that
  does not provide it, install L<App::pwhich> which provides a command line
  interface to this API.
  
  =head2 Implementations
  
  L<File::Which> searches the directories of the user's C<PATH> (the current
  implementation uses L<File::Spec#path> to determine the correct C<PATH>),
  looking for executable files having the name specified as a parameter to
  L</which>. Under Win32 systems, which do not have a notion of directly
  executable files, but uses special extensions such as C<.exe> and C<.bat>
  to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head3 Linux, *BSD and other UNIXes
  
  There should not be any surprises here.  The current directory will not be
  searched unless it is explicitly added to the path.
  
  =head3 Modern Windows (including NT, XP, Vista, 7, 8, 10 etc)
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head3 Cygwin
  
  Cygwin provides a Unix-like environment for Microsoft Windows users.  In most
  ways it works like other Unix and Unix-like environments, but in a few key
  aspects it works like Windows.  As with other Unix environments, the current
  directory is not included in the search unless it is explicitly included in
  the search path.  Like on Windows, files with C<.EXE> or <.BAT> extensions will
  be discovered even if they are not part of the query.  C<.COM> or extensions
  specified using the C<PATHEXT> environment variable will NOT be discovered
  without the fully qualified name, however.
  
  =head3 Windows 95, 98, ME, MS-DOS, OS/2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  As of 2015 none of these platforms are tested frequently (or perhaps ever),
  but the current maintainer is determined not to intentionally remove support
  for older operating systems.
  
  =head3 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  As of 2015 the current maintainer does not test on VMS, and is in fact not
  certain it has ever been tested on VMS.  If this platform is important to you
  and you can help me verify and or support it on that platform please contact
  me.
  
  =head1 FUNCTIONS
  
  =head2 which
  
   my $path = which $short_exe_name;
   my @paths = which $short_exe_name;
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where
  
   my @paths = where $short_exe_name;
  
  Not exported by default.
  
  Same as L</which> in array context. Same as the
  C<where> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 CAVEATS
  
  This module has no non-core requirements for Perl 5.6.2 and better.
  
  This module is fully supported back to Perl 5.8.1.  It may work on 5.8.0.  
  It should work on Perl 5.6.x and I may even test on 5.6.2.  I will accept
  patches to maintain compatibility for such older Perls, but you may
  need to fix it on 5.6.x / 5.8.0 and send me a patch.
  
  Not tested on VMS although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  =head1 SUPPORT
  
  Bugs should be reported via the GitHub issue tracker
  
  L<https://github.com/plicease/File-Which/issues>
  
  For other issues, contact the maintainer.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<pwhich>, L<App::pwhich>
  
  Command line interface to this module.
  
  =item L<IPC::Cmd>
  
  Comes with a C<can_run> function with slightly different semantics that
  the traditional UNIX where.  It will find executables in the current
  directory, even though the current directory is not searched for by
  default on Unix.
  
  =item L<Devel::CheckBin>
  
  This module purports to "check that a command is available", but does not
  provide any documentation on how you might use it.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Per Einar Ellefsen <pereinar@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2002 by Per Einar Ellefsen <pereinar@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;
  use warnings;
  
  package File::pushd;
  # ABSTRACT: change directory temporarily for a limited scope
  our $VERSION = '1.009'; # VERSION
  
  our @EXPORT = qw( pushd tempd );
  our @ISA    = qw( Exporter );
  
  use Exporter;
  use Carp;
  use Cwd qw( getcwd abs_path );
  use File::Path qw( rmtree );
  use File::Temp qw();
  use File::Spec;
  
  use overload
    q{""}    => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
    fallback => 1;
  
  #--------------------------------------------------------------------------#
  # pushd()
  #--------------------------------------------------------------------------#
  
  sub pushd {
      my ( $target_dir, $options ) = @_;
      $options->{untaint_pattern} ||= qr{^([-+@\w./]+)$};
  
      $target_dir = "." unless defined $target_dir;
      croak "Can't locate directory $target_dir" unless -d $target_dir;
  
      my $tainted_orig = getcwd;
      my $orig;
      if ( $tainted_orig =~ $options->{untaint_pattern} ) {
          $orig = $1;
      }
      else {
          $orig = $tainted_orig;
      }
  
      my $tainted_dest;
      eval { $tainted_dest = $target_dir ? abs_path($target_dir) : $orig };
      croak "Can't locate absolute path for $target_dir: $@" if $@;
  
      my $dest;
      if ( $tainted_dest =~ $options->{untaint_pattern} ) {
          $dest = $1;
      }
      else {
          $dest = $tainted_dest;
      }
  
      if ( $dest ne $orig ) {
          chdir $dest or croak "Can't chdir to $dest\: $!";
      }
  
      my $self = bless {
          _pushd    => $dest,
          _original => $orig
        },
        __PACKAGE__;
  
      return $self;
  }
  
  #--------------------------------------------------------------------------#
  # tempd()
  #--------------------------------------------------------------------------#
  
  sub tempd {
      my ($options) = @_;
      my $dir;
      eval { $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ), $options ) };
      croak $@ if $@;
      $dir->{_tempd} = 1;
      return $dir;
  }
  
  #--------------------------------------------------------------------------#
  # preserve()
  #--------------------------------------------------------------------------#
  
  sub preserve {
      my $self = shift;
      return 1 if !$self->{"_tempd"};
      if ( @_ == 0 ) {
          return $self->{_preserve} = 1;
      }
      else {
          return $self->{_preserve} = $_[0] ? 1 : 0;
      }
  }
  
  #--------------------------------------------------------------------------#
  # DESTROY()
  # Revert to original directory as object is destroyed and cleanup
  # if necessary
  #--------------------------------------------------------------------------#
  
  sub DESTROY {
      my ($self) = @_;
      my $orig = $self->{_original};
      chdir $orig if $orig; # should always be so, but just in case...
      if ( $self->{_tempd}
          && !$self->{_preserve} )
      {
          # don't destroy existing $@ if there is no error.
          my $err = do {
              local $@;
              eval { rmtree( $self->{_pushd} ) };
              $@;
          };
          carp $err if $err;
      }
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::pushd - change directory temporarily for a limited scope
  
  =head1 VERSION
  
  version 1.009
  
  =head1 SYNOPSIS
  
   use File::pushd;
  
   chdir $ENV{HOME};
  
   # change directory again for a limited scope
   {
       my $dir = pushd( '/tmp' );
       # working directory changed to /tmp
   }
   # working directory has reverted to $ENV{HOME}
  
   # tempd() is equivalent to pushd( File::Temp::tempdir )
   {
       my $dir = tempd();
   }
  
   # object stringifies naturally as an absolute path
   {
      my $dir = pushd( '/tmp' );
      my $filename = File::Spec->catfile( $dir, "somefile.txt" );
      # gives /tmp/somefile.txt
   }
  
  =head1 DESCRIPTION
  
  File::pushd does a temporary C<chdir> that is easily and automatically
  reverted, similar to C<pushd> in some Unix command shells.  It works by
  creating an object that caches the original working directory.  When the object
  is destroyed, the destructor calls C<chdir> to revert to the original working
  directory.  By storing the object in a lexical variable with a limited scope,
  this happens automatically at the end of the scope.
  
  This is very handy when working with temporary directories for tasks like
  testing; a function is provided to streamline getting a temporary
  directory from L<File::Temp>.
  
  For convenience, the object stringifies as the canonical form of the absolute
  pathname of the directory entered.
  
  B<Warning>: if you create multiple C<pushd> objects in the same lexical scope,
  their destruction order is not guaranteed and you might not wind up in the
  directory you expect.
  
  =head1 USAGE
  
   use File::pushd;
  
  Using File::pushd automatically imports the C<pushd> and C<tempd> functions.
  
  =head2 pushd
  
   {
       my $dir = pushd( $target_directory );
   }
  
  Caches the current working directory, calls C<chdir> to change to the target
  directory, and returns a File::pushd object.  When the object is
  destroyed, the working directory reverts to the original directory.
  
  The provided target directory can be a relative or absolute path. If
  called with no arguments, it uses the current directory as its target and
  returns to the current directory when the object is destroyed.
  
  If the target directory does not exist or if the directory change fails
  for some reason, C<pushd> will die with an error message.
  
  Can be given a hashref as an optional second argument.  The only supported
  option is C<untaint_pattern>, which is used to untaint file paths involved.
  It defaults to {qr{^(L<-+@\w./>+)$}}, which is reasonably restrictive (e.g.
  it does not even allow spaces in the path).  Change this to suit your
  circumstances and security needs if running under taint mode. *Note*: you
  must include the parentheses in the pattern to capture the untainted
  portion of the path.
  
  =head2 tempd
  
   {
       my $dir = tempd();
   }
  
  This function is like C<pushd> but automatically creates and calls C<chdir> to
  a temporary directory created by L<File::Temp>. Unlike normal L<File::Temp>
  cleanup which happens at the end of the program, this temporary directory is
  removed when the object is destroyed. (But also see C<preserve>.)  A warning
  will be issued if the directory cannot be removed.
  
  As with C<pushd>, C<tempd> will die if C<chdir> fails.
  
  It may be given a single options hash that will be passed internally
  to C<pushd>.
  
  =head2 preserve
  
   {
       my $dir = tempd();
       $dir->preserve;      # mark to preserve at end of scope
       $dir->preserve(0);   # mark to delete at end of scope
   }
  
  Controls whether a temporary directory will be cleaned up when the object is
  destroyed.  With no arguments, C<preserve> sets the directory to be preserved.
  With an argument, the directory will be preserved if the argument is true, or
  marked for cleanup if the argument is false.  Only C<tempd> objects may be
  marked for cleanup.  (Target directories to C<pushd> are always preserved.)
  C<preserve> returns true if the directory will be preserved, and false
  otherwise.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<File::chdir>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/File-pushd/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/File-pushd>
  
    git clone https://github.com/dagolden/File-pushd.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by David A Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
  
  __END__
  
  
  # vim: ts=4 sts=4 sw=4 et:
FILE_PUSHD

$fatpacked{"IO/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRING';
  package IO::String;
  
  # Copyright 1998-2005 Gisle Aas.
  #
  # This library is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  require 5.005_03;
  use strict;
  use vars qw($VERSION $DEBUG $IO_CONSTANTS);
  $VERSION = "1.08";  # $Date: 2005/12/05 12:00:47 $
  
  use Symbol ();
  
  sub new
  {
      my $class = shift;
      my $self = bless Symbol::gensym(), ref($class) || $class;
      tie *$self, $self;
      $self->open(@_);
      return $self;
  }
  
  sub open
  {
      my $self = shift;
      return $self->new(@_) unless ref($self);
  
      if (@_) {
  	my $bufref = ref($_[0]) ? $_[0] : \$_[0];
  	$$bufref = "" unless defined $$bufref;
  	*$self->{buf} = $bufref;
      }
      else {
  	my $buf = "";
  	*$self->{buf} = \$buf;
      }
      *$self->{pos} = 0;
      *$self->{lno} = 0;
      return $self;
  }
  
  sub pad
  {
      my $self = shift;
      my $old = *$self->{pad};
      *$self->{pad} = substr($_[0], 0, 1) if @_;
      return "\0" unless defined($old) && length($old);
      return $old;
  }
  
  sub dump
  {
      require Data::Dumper;
      my $self = shift;
      print Data::Dumper->Dump([$self], ['*self']);
      print Data::Dumper->Dump([*$self{HASH}], ['$self{HASH}']);
      return;
  }
  
  sub TIEHANDLE
  {
      print "TIEHANDLE @_\n" if $DEBUG;
      return $_[0] if ref($_[0]);
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->open(@_);
      return $self;
  }
  
  sub DESTROY
  {
      print "DESTROY @_\n" if $DEBUG;
  }
  
  sub close
  {
      my $self = shift;
      delete *$self->{buf};
      delete *$self->{pos};
      delete *$self->{lno};
      undef *$self if $] eq "5.008";  # workaround for some bug
      return 1;
  }
  
  sub opened
  {
      my $self = shift;
      return defined *$self->{buf};
  }
  
  sub binmode
  {
      my $self = shift;
      return 1 unless @_;
      # XXX don't know much about layers yet :-(
      return 0;
  }
  
  sub getc
  {
      my $self = shift;
      my $buf;
      return $buf if $self->read($buf, 1);
      return undef;
  }
  
  sub ungetc
  {
      my $self = shift;
      $self->setpos($self->getpos() - 1);
      return 1;
  }
  
  sub eof
  {
      my $self = shift;
      return length(${*$self->{buf}}) <= *$self->{pos};
  }
  
  sub print
  {
      my $self = shift;
      if (defined $\) {
  	if (defined $,) {
  	    $self->write(join($,, @_).$\);
  	}
  	else {
  	    $self->write(join("",@_).$\);
  	}
      }
      else {
  	if (defined $,) {
  	    $self->write(join($,, @_));
  	}
  	else {
  	    $self->write(join("",@_));
  	}
      }
      return 1;
  }
  *printflush = \*print;
  
  sub printf
  {
      my $self = shift;
      print "PRINTF(@_)\n" if $DEBUG;
      my $fmt = shift;
      $self->write(sprintf($fmt, @_));
      return 1;
  }
  
  
  my($SEEK_SET, $SEEK_CUR, $SEEK_END);
  
  sub _init_seek_constants
  {
      if ($IO_CONSTANTS) {
  	require IO::Handle;
  	$SEEK_SET = &IO::Handle::SEEK_SET;
  	$SEEK_CUR = &IO::Handle::SEEK_CUR;
  	$SEEK_END = &IO::Handle::SEEK_END;
      }
      else {
  	$SEEK_SET = 0;
  	$SEEK_CUR = 1;
  	$SEEK_END = 2;
      }
  }
  
  
  sub seek
  {
      my($self,$off,$whence) = @_;
      my $buf = *$self->{buf} || return 0;
      my $len = length($$buf);
      my $pos = *$self->{pos};
  
      _init_seek_constants() unless defined $SEEK_SET;
  
      if    ($whence == $SEEK_SET) { $pos = $off }
      elsif ($whence == $SEEK_CUR) { $pos += $off }
      elsif ($whence == $SEEK_END) { $pos = $len + $off }
      else                         { die "Bad whence ($whence)" }
      print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if $DEBUG;
  
      $pos = 0 if $pos < 0;
      $self->truncate($pos) if $pos > $len;  # extend file
      *$self->{pos} = $pos;
      return 1;
  }
  
  sub pos
  {
      my $self = shift;
      my $old = *$self->{pos};
      if (@_) {
  	my $pos = shift || 0;
  	my $buf = *$self->{buf};
  	my $len = $buf ? length($$buf) : 0;
  	$pos = $len if $pos > $len;
  	*$self->{pos} = $pos;
      }
      return $old;
  }
  
  sub getpos { shift->pos; }
  
  *sysseek = \&seek;
  *setpos  = \&pos;
  *tell    = \&getpos;
  
  
  
  sub getline
  {
      my $self = shift;
      my $buf  = *$self->{buf} || return;
      my $len  = length($$buf);
      my $pos  = *$self->{pos};
      return if $pos >= $len;
  
      unless (defined $/) {  # slurp
  	*$self->{pos} = $len;
  	return substr($$buf, $pos);
      }
  
      unless (length $/) {  # paragraph mode
  	# XXX slow&lazy implementation using getc()
  	my $para = "";
  	my $eol = 0;
  	my $c;
  	while (defined($c = $self->getc)) {
  	    if ($c eq "\n") {
  		$eol++;
  		next if $eol > 2;
  	    }
  	    elsif ($eol > 1) {
  		$self->ungetc($c);
  		last;
  	    }
  	    else {
  		$eol = 0;
  	    }
  	    $para .= $c;
  	}
  	return $para;   # XXX wantarray
      }
  
      my $idx = index($$buf,$/,$pos);
      if ($idx < 0) {
  	# return rest of it
  	*$self->{pos} = $len;
  	$. = ++ *$self->{lno};
  	return substr($$buf, $pos);
      }
      $len = $idx - $pos + length($/);
      *$self->{pos} += $len;
      $. = ++ *$self->{lno};
      return substr($$buf, $pos, $len);
  }
  
  sub getlines
  {
      die "getlines() called in scalar context\n" unless wantarray;
      my $self = shift;
      my($line, @lines);
      push(@lines, $line) while defined($line = $self->getline);
      return @lines;
  }
  
  sub READLINE
  {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub input_line_number
  {
      my $self = shift;
      my $old = *$self->{lno};
      *$self->{lno} = shift if @_;
      return $old;
  }
  
  sub truncate
  {
      my $self = shift;
      my $len = shift || 0;
      my $buf = *$self->{buf};
      if (length($$buf) >= $len) {
  	substr($$buf, $len) = '';
  	*$self->{pos} = $len if $len < *$self->{pos};
      }
      else {
  	$$buf .= ($self->pad x ($len - length($$buf)));
      }
      return 1;
  }
  
  sub read
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return undef unless $buf;
  
      my $pos = *$self->{pos};
      my $rem = length($$buf) - $pos;
      my $len = $_[1];
      $len = $rem if $len > $rem;
      return undef if $len < 0;
      if (@_ > 2) { # read offset
  	substr($_[0],$_[2]) = substr($$buf, $pos, $len);
      }
      else {
  	$_[0] = substr($$buf, $pos, $len);
      }
      *$self->{pos} += $len;
      return $len;
  }
  
  sub write
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return unless $buf;
  
      my $pos = *$self->{pos};
      my $slen = length($_[0]);
      my $len = $slen;
      my $off = 0;
      if (@_ > 1) {
  	$len = $_[1] if $_[1] < $len;
  	if (@_ > 2) {
  	    $off = $_[2] || 0;
  	    die "Offset outside string" if $off > $slen;
  	    if ($off < 0) {
  		$off += $slen;
  		die "Offset outside string" if $off < 0;
  	    }
  	    my $rem = $slen - $off;
  	    $len = $rem if $rem < $len;
  	}
      }
      substr($$buf, $pos, $len) = substr($_[0], $off, $len);
      *$self->{pos} += $len;
      return $len;
  }
  
  *sysread = \&read;
  *syswrite = \&write;
  
  sub stat
  {
      my $self = shift;
      return unless $self->opened;
      return 1 unless wantarray;
      my $len = length ${*$self->{buf}};
  
      return (
       undef, undef,  # dev, ino
       0666,          # filemode
       1,             # links
       $>,            # user id
       $),            # group id
       undef,         # device id
       $len,          # size
       undef,         # atime
       undef,         # mtime
       undef,         # ctime
       512,           # blksize
       int(($len+511)/512)  # blocks
      );
  }
  
  sub FILENO {
      return undef;   # XXX perlfunc says this means the file is closed
  }
  
  sub blocking {
      my $self = shift;
      my $old = *$self->{blocking} || 0;
      *$self->{blocking} = shift if @_;
      return $old;
  }
  
  my $notmuch = sub { return };
  
  *fileno    = $notmuch;
  *error     = $notmuch;
  *clearerr  = $notmuch; 
  *sync      = $notmuch;
  *flush     = $notmuch;
  *setbuf    = $notmuch;
  *setvbuf   = $notmuch;
  
  *untaint   = $notmuch;
  *autoflush = $notmuch;
  *fcntl     = $notmuch;
  *ioctl     = $notmuch;
  
  *GETC   = \&getc;
  *PRINT  = \&print;
  *PRINTF = \&printf;
  *READ   = \&read;
  *WRITE  = \&write;
  *SEEK   = \&seek;
  *TELL   = \&getpos;
  *EOF    = \&eof;
  *CLOSE  = \&close;
  *BINMODE = \&binmode;
  
  
  sub string_ref
  {
      my $self = shift;
      return *$self->{buf};
  }
  *sref = \&string_ref;
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::String - Emulate file interface for in-core strings
  
  =head1 SYNOPSIS
  
   use IO::String;
   $io = IO::String->new;
   $io = IO::String->new($var);
   tie *IO, 'IO::String';
  
   # read data
   <$io>;
   $io->getline;
   read($io, $buf, 100);
  
   # write data
   print $io "string\n";
   $io->print(@data);
   syswrite($io, $buf, 100);
  
   select $io;
   printf "Some text %s\n", $str;
  
   # seek
   $pos = $io->getpos;
   $io->setpos(0);        # rewind
   $io->seek(-30, -1);
   seek($io, 0, 0);
  
  =head1 DESCRIPTION
  
  The C<IO::String> module provides the C<IO::File> interface for in-core
  strings.  An C<IO::String> object can be attached to a string, and
  makes it possible to use the normal file operations for reading or
  writing data, as well as for seeking to various locations of the string.
  This is useful when you want to use a library module that only
  provides an interface to file handles on data that you have in a string
  variable.
  
  Note that perl-5.8 and better has built-in support for "in memory"
  files, which are set up by passing a reference instead of a filename
  to the open() call. The reason for using this module is that it
  makes the code backwards compatible with older versions of Perl.
  
  The C<IO::String> module provides an interface compatible with
  C<IO::File> as distributed with F<IO-1.20>, but the following methods
  are not available: new_from_fd, fdopen, format_write,
  format_page_number, format_lines_per_page, format_lines_left,
  format_name, format_top_name.
  
  The following methods are specific to the C<IO::String> class:
  
  =over 4
  
  =item $io = IO::String->new
  
  =item $io = IO::String->new( $string )
  
  The constructor returns a newly-created C<IO::String> object.  It
  takes an optional argument, which is the string to read from or write
  into.  If no $string argument is given, then an internal buffer
  (initially empty) is allocated.
  
  The C<IO::String> object returned is tied to itself.  This means
  that you can use most Perl I/O built-ins on it too: readline, <>, getc,
  print, printf, syswrite, sysread, close.
  
  =item $io->open
  
  =item $io->open( $string )
  
  Attaches an existing IO::String object to some other $string, or
  allocates a new internal buffer (if no argument is given).  The
  position is reset to 0.
  
  =item $io->string_ref
  
  Returns a reference to the string that is attached to
  the C<IO::String> object.  Most useful when you let the C<IO::String>
  create an internal buffer to write into.
  
  =item $io->pad
  
  =item $io->pad( $char )
  
  Specifies the padding to use if
  the string is extended by either the seek() or truncate() methods.  It
  is a single character and defaults to "\0".
  
  =item $io->pos
  
  =item $io->pos( $newpos )
  
  Yet another interface for reading and setting the current read/write
  position within the string (the normal getpos/setpos/tell/seek
  methods are also available).  The pos() method always returns the
  old position, and if you pass it an argument it sets the new
  position.
  
  There is (deliberately) a difference between the setpos() and seek()
  methods in that seek() extends the string (with the specified
  padding) if you go to a location past the end, whereas setpos()
  just snaps back to the end.  If truncate() is used to extend the string,
  then it works as seek().
  
  =back
  
  =head1 BUGS
  
  In Perl versions < 5.6, the TIEHANDLE interface was incomplete.
  If you use such a Perl, then seek(), tell(), eof(), fileno(), binmode() will
  not do anything on an C<IO::String> handle.  See L<perltie> for
  details.
  
  =head1 SEE ALSO
  
  L<IO::File>, L<IO::Stringy>, L<perlfunc/open>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
IO_STRING

$fatpacked{"IPC/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN';
  package IPC::Run;
  use bytes;
  
  =pod
  
  =head1 NAME
  
  IPC::Run - system() and background procs w/ piping, redirs, ptys (Unix, Win32)
  
  =head1 SYNOPSIS
  
     ## First,a command to run:
        my @cat = qw( cat );
  
     ## Using run() instead of system():
        use IPC::Run qw( run timeout );
  
        run \@cmd, \$in, \$out, \$err, timeout( 10 ) or die "cat: $?"
  
        # Can do I/O to sub refs and filenames, too:
        run \@cmd, '<', "in.txt", \&out, \&err or die "cat: $?"
        run \@cat, '<', "in.txt", '>>', "out.txt", '2>>', "err.txt";
  
  
        # Redirecting using psuedo-terminals instad of pipes.
        run \@cat, '<pty<', \$in,  '>pty>', \$out_and_err;
  
     ## Scripting subprocesses (like Expect):
  
        use IPC::Run qw( start pump finish timeout );
  
        # Incrementally read from / write to scalars. 
        # $in is drained as it is fed to cat's stdin,
        # $out accumulates cat's stdout
        # $err accumulates cat's stderr
        # $h is for "harness".
        my $h = start \@cat, \$in, \$out, \$err, timeout( 10 );
  
        $in .= "some input\n";
        pump $h until $out =~ /input\n/g;
  
        $in .= "some more input\n";
        pump $h until $out =~ /\G.*more input\n/;
  
        $in .= "some final input\n";
        finish $h or die "cat returned $?";
  
        warn $err if $err; 
        print $out;         ## All of cat's output
  
     # Piping between children
        run \@cat, '|', \@gzip;
  
     # Multiple children simultaneously (run() blocks until all
     # children exit, use start() for background execution):
        run \@foo1, '&', \@foo2;
  
     # Calling \&set_up_child in the child before it executes the
     # command (only works on systems with true fork() & exec())
     # exceptions thrown in set_up_child() will be propagated back
     # to the parent and thrown from run().
        run \@cat, \$in, \$out,
           init => \&set_up_child;
  
     # Read from / write to file handles you open and close
        open IN,  '<in.txt'  or die $!;
        open OUT, '>out.txt' or die $!;
        print OUT "preamble\n";
        run \@cat, \*IN, \*OUT or die "cat returned $?";
        print OUT "postamble\n";
        close IN;
        close OUT;
  
     # Create pipes for you to read / write (like IPC::Open2 & 3).
        $h = start
           \@cat,
              '<pipe', \*IN,
              '>pipe', \*OUT,
              '2>pipe', \*ERR 
           or die "cat returned $?";
        print IN "some input\n";
        close IN;
        print <OUT>, <ERR>;
        finish $h;
  
     # Mixing input and output modes
        run \@cat, 'in.txt', \&catch_some_out, \*ERR_LOG );
  
     # Other redirection constructs
        run \@cat, '>&', \$out_and_err;
        run \@cat, '2>&1';
        run \@cat, '0<&3';
        run \@cat, '<&-';
        run \@cat, '3<', \$in3;
        run \@cat, '4>', \$out4;
        # etc.
  
     # Passing options:
        run \@cat, 'in.txt', debug => 1;
  
     # Call this system's shell, returns TRUE on 0 exit code
     # THIS IS THE OPPOSITE SENSE OF system()'s RETURN VALUE
        run "cat a b c" or die "cat returned $?";
  
     # Launch a sub process directly, no shell.  Can't do redirection
     # with this form, it's here to behave like system() with an
     # inverted result.
        $r = run "cat a b c";
  
     # Read from a file in to a scalar
        run io( "filename", 'r', \$recv );
        run io( \*HANDLE,   'r', \$recv );
  
  =head1 DESCRIPTION
  
  IPC::Run allows you to run and interact with child processes using files, pipes,
  and pseudo-ttys.  Both system()-style and scripted usages are supported and
  may be mixed.  Likewise, functional and OO API styles are both supported and
  may be mixed.
  
  Various redirection operators reminiscent of those seen on common Unix and DOS
  command lines are provided.
  
  Before digging in to the details a few LIMITATIONS are important enough
  to be mentioned right up front:
  
  =over
  
  =item Win32 Support
  
  Win32 support is working but B<EXPERIMENTAL>, but does pass all relevant tests
  on NT 4.0.  See L</Win32 LIMITATIONS>.
  
  =item pty Support
  
  If you need pty support, IPC::Run should work well enough most of the
  time, but IO::Pty is being improved, and IPC::Run will be improved to
  use IO::Pty's new features when it is release.
  
  The basic problem is that the pty needs to initialize itself before the
  parent writes to the master pty, or the data written gets lost.  So
  IPC::Run does a sleep(1) in the parent after forking to (hopefully) give
  the child a chance to run.  This is a kludge that works well on non
  heavily loaded systems :(.
  
  ptys are not supported yet under Win32, but will be emulated...
  
  =item Debugging Tip
  
  You may use the environment variable C<IPCRUNDEBUG> to see what's going on
  under the hood:
  
     $ IPCRUNDEBUG=basic   myscript     # prints minimal debugging
     $ IPCRUNDEBUG=data    myscript     # prints all data reads/writes
     $ IPCRUNDEBUG=details myscript     # prints lots of low-level details
     $ IPCRUNDEBUG=gory    myscript     # (Win32 only) prints data moving through
                                        # the helper processes.
  
  =back
  
  We now return you to your regularly scheduled documentation.
  
  =head2 Harnesses
  
  Child processes and I/O handles are gathered in to a harness, then
  started and run until the processing is finished or aborted.
  
  =head2 run() vs. start(); pump(); finish();
  
  There are two modes you can run harnesses in: run() functions as an
  enhanced system(), and start()/pump()/finish() allow for background
  processes and scripted interactions with them.
  
  When using run(), all data to be sent to the harness is set up in
  advance (though one can feed subprocesses input from subroutine refs to
  get around this limitation). The harness is run and all output is
  collected from it, then any child processes are waited for:
  
     run \@cmd, \<<IN, \$out;
     blah
     IN
  
     ## To precompile harnesses and run them later:
     my $h = harness \@cmd, \<<IN, \$out;
     blah
     IN
  
     run $h;
  
  The background and scripting API is provided by start(), pump(), and
  finish(): start() creates a harness if need be (by calling harness())
  and launches any subprocesses, pump() allows you to poll them for
  activity, and finish() then monitors the harnessed activities until they
  complete.
  
     ## Build the harness, open all pipes, and launch the subprocesses
     my $h = start \@cat, \$in, \$out;
     $in = "first input\n";
  
     ## Now do I/O.  start() does no I/O.
     pump $h while length $in;  ## Wait for all input to go
  
     ## Now do some more I/O.
     $in = "second input\n";
     pump $h until $out =~ /second input/;
  
     ## Clean up
     finish $h or die "cat returned $?";
  
  You can optionally compile the harness with harness() prior to
  start()ing or run()ing, and you may omit start() between harness() and
  pump().  You might want to do these things if you compile your harnesses
  ahead of time.
  
  =head2 Using regexps to match output
  
  As shown in most of the scripting examples, the read-to-scalar facility
  for gathering subcommand's output is often used with regular expressions
  to detect stopping points.  This is because subcommand output often
  arrives in dribbles and drabs, often only a character or line at a time.
  This output is input for the main program and piles up in variables like
  the C<$out> and C<$err> in our examples.
  
  Regular expressions can be used to wait for appropriate output in
  several ways.  The C<cat> example in the previous section demonstrates
  how to pump() until some string appears in the output.  Here's an
  example that uses C<smb> to fetch files from a remote server:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /src:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
  Notice that we carefully clear $out after the first command/response
  cycle? That's because IPC::Run does not delete $out when we continue,
  and we don't want to trip over the old output in the second
  command/response cycle.
  
  Say you want to accumulate all the output in $out and analyze it
  afterwards.  Perl offers incremental regular expression matching using
  the C<m//gc> and pattern matching idiom and the C<\G> assertion.
  IPC::Run is careful not to disturb the current C<pos()> value for
  scalars it appends data to, so we could modify the above so as not to
  destroy $out by adding a couple of C</gc> modifiers.  The C</g> keeps us
  from tripping over the previous prompt and the C</c> keeps us from
  resetting the prior match position if the expected prompt doesn't
  materialize immediately:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error cding to /src:\n$out" if $out =~ "ERR";
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
     analyze( $out );
  
  When using this technique, you may want to preallocate $out to have
  plenty of memory or you may find that the act of growing $out each time
  new input arrives causes an C<O(length($out)^2)> slowdown as $out grows.
  Say we expect no more than 10,000 characters of input at the most.  To
  preallocate memory to $out, do something like:
  
     my $out = "x" x 10_000;
     $out = "";
  
  C<perl> will allocate at least 10,000 characters' worth of space, then
  mark the $out as having 0 length without freeing all that yummy RAM.
  
  =head2 Timeouts and Timers
  
  More than likely, you don't want your subprocesses to run forever, and
  sometimes it's nice to know that they're going a little slowly.
  Timeouts throw exceptions after a some time has elapsed, timers merely
  cause pump() to return after some time has elapsed.  Neither is
  reset/restarted automatically.
  
  Timeout objects are created by calling timeout( $interval ) and passing
  the result to run(), start() or harness().  The timeout period starts
  ticking just after all the child processes have been fork()ed or
  spawn()ed, and are polled for expiration in run(), pump() and finish().
  If/when they expire, an exception is thrown.  This is typically useful
  to keep a subprocess from taking too long.
  
  If a timeout occurs in run(), all child processes will be terminated and
  all file/pipe/ptty descriptors opened by run() will be closed.  File
  descriptors opened by the parent process and passed in to run() are not
  closed in this event.
  
  If a timeout occurs in pump(), pump_nb(), or finish(), it's up to you to
  decide whether to kill_kill() all the children or to implement some more
  graceful fallback.  No I/O will be closed in pump(), pump_nb() or
  finish() by such an exception (though I/O is often closed down in those
  routines during the natural course of events).
  
  Often an exception is too harsh.  timer( $interval ) creates timer
  objects that merely prevent pump() from blocking forever.  This can be
  useful for detecting stalled I/O or printing a soothing message or "."
  to pacify an anxious user.
  
  Timeouts and timers can both be restarted at any time using the timer's
  start() method (this is not the start() that launches subprocesses).  To
  restart a timer, you need to keep a reference to the timer:
  
     ## Start with a nice long timeout to let smbclient connect.  If
     ## pump or finish take too long, an exception will be thrown.
  
   my $h;
   eval {
     $h = harness \@smbclient, \$in, \$out, \$err, ( my $t = timeout 30 );
     sleep 11;  # No effect: timer not running yet
  
     start $h;
     $in = "cd /src\n";
     pump $h until ! length $in;
  
     $in = "ls\n";
     ## Now use a short timeout, since this should be faster
     $t->start( 5 );
     pump $h until ! length $in;
  
     $t->start( 10 );  ## Give smbclient a little while to shut down.
     $h->finish;
   };
   if ( $@ ) {
     my $x = $@;    ## Preserve $@ in case another exception occurs
     $h->kill_kill; ## kill it gently, then brutally if need be, or just
                     ## brutally on Win32.
     die $x;
   }
  
  Timeouts and timers are I<not> checked once the subprocesses are shut
  down; they will not expire in the interval between the last valid
  process and when IPC::Run scoops up the processes' result codes, for
  instance.
  
  =head2 Spawning synchronization, child exception propagation
  
  start() pauses the parent until the child executes the command or CODE
  reference and propagates any exceptions thrown (including exec()
  failure) back to the parent.  This has several pleasant effects: any
  exceptions thrown in the child, including exec() failure, come flying
  out of start() or run() as though they had occurred in the parent.
  
  This includes exceptions your code thrown from init subs.  In this
  example:
  
     eval {
        run \@cmd, init => sub { die "blast it! foiled again!" };
     };
     print $@;
  
  the exception "blast it! foiled again" will be thrown from the child
  process (preventing the exec()) and printed by the parent.
  
  In situations like
  
     run \@cmd1, "|", \@cmd2, "|", \@cmd3;
  
  @cmd1 will be initted and exec()ed before @cmd2, and @cmd2 before @cmd3.
  This can save time and prevent oddball errors emitted by later commands
  when earlier commands fail to execute.  Note that IPC::Run doesn't start
  any commands unless it can find the executables referenced by all
  commands.  These executables must pass both the C<-f> and C<-x> tests
  described in L<perlfunc>.
  
  Another nice effect is that init() subs can take their time doing things
  and there will be no problems caused by a parent continuing to execute
  before a child's init() routine is complete.  Say the init() routine
  needs to open a socket or a temp file that the parent wants to connect
  to; without this synchronization, the parent will need to implement a
  retry loop to wait for the child to run, since often, the parent gets a
  lot of things done before the child's first timeslice is allocated.
  
  This is also quite necessary for pseudo-tty initialization, which needs
  to take place before the parent writes to the child via pty.  Writes
  that occur before the pty is set up can get lost.
  
  A final, minor, nicety is that debugging output from the child will be
  emitted before the parent continues on, making for much clearer debugging
  output in complex situations.
  
  The only drawback I can conceive of is that the parent can't continue to
  operate while the child is being initted.  If this ever becomes a
  problem in the field, we can implement an option to avoid this behavior,
  but I don't expect it to.
  
  B<Win32>: executing CODE references isn't supported on Win32, see
  L</Win32 LIMITATIONS> for details.
  
  =head2 Syntax
  
  run(), start(), and harness() can all take a harness specification
  as input.  A harness specification is either a single string to be passed
  to the systems' shell:
  
     run "echo 'hi there'";
  
  or a list of commands, io operations, and/or timers/timeouts to execute.
  Consecutive commands must be separated by a pipe operator '|' or an '&'.
  External commands are passed in as array references, and, on systems
  supporting fork(), Perl code may be passed in as subs:
  
     run \@cmd;
     run \@cmd1, '|', \@cmd2;
     run \@cmd1, '&', \@cmd2;
     run \&sub1;
     run \&sub1, '|', \&sub2;
     run \&sub1, '&', \&sub2;
  
  '|' pipes the stdout of \@cmd1 the stdin of \@cmd2, just like a
  shell pipe.  '&' does not.  Child processes to the right of a '&'
  will have their stdin closed unless it's redirected-to.
  
  L<IPC::Run::IO> objects may be passed in as well, whether or not
  child processes are also specified:
  
     run io( "infile", ">", \$in ), io( "outfile", "<", \$in );
        
  as can L<IPC::Run::Timer> objects:
  
     run \@cmd, io( "outfile", "<", \$in ), timeout( 10 );
  
  Commands may be followed by scalar, sub, or i/o handle references for
  redirecting
  child process input & output:
  
     run \@cmd,  \undef,            \$out;
     run \@cmd,  \$in,              \$out;
     run \@cmd1, \&in, '|', \@cmd2, \*OUT;
     run \@cmd1, \*IN, '|', \@cmd2, \&out;
  
  This is known as succinct redirection syntax, since run(), start()
  and harness(), figure out which file descriptor to redirect and how.
  File descriptor 0 is presumed to be an input for
  the child process, all others are outputs.  The assumed file
  descriptor always starts at 0, unless the command is being piped to,
  in which case it starts at 1.
  
  To be explicit about your redirects, or if you need to do more complex
  things, there's also a redirection operator syntax:
  
     run \@cmd, '<', \undef, '>',  \$out;
     run \@cmd, '<', \undef, '>&', \$out_and_err;
     run(
        \@cmd1,
           '<', \$in,
        '|', \@cmd2,
           \$out
     );
  
  Operator syntax is required if you need to do something other than simple
  redirection to/from scalars or subs, like duping or closing file descriptors
  or redirecting to/from a named file.  The operators are covered in detail
  below.
  
  After each \@cmd (or \&foo), parsing begins in succinct mode and toggles to
  operator syntax mode when an operator (ie plain scalar, not a ref) is seen.
  Once in
  operator syntax mode, parsing only reverts to succinct mode when a '|' or
  '&' is seen.
  
  In succinct mode, each parameter after the \@cmd specifies what to
  do with the next highest file descriptor. These File descriptor start
  with 0 (stdin) unless stdin is being piped to (C<'|', \@cmd>), in which
  case they start with 1 (stdout).  Currently, being on the left of
  a pipe (C<\@cmd, \$out, \$err, '|'>) does I<not> cause stdout to be
  skipped, though this may change since it's not as DWIMerly as it
  could be.  Only stdin is assumed to be an
  input in succinct mode, all others are assumed to be outputs.
  
  If no piping or redirection is specified for a child, it will inherit
  the parent's open file handles as dictated by your system's
  close-on-exec behavior and the $^F flag, except that processes after a
  '&' will not inherit the parent's stdin. Also note that $^F does not
  affect file descriptors obtained via POSIX, since it only applies to
  full-fledged Perl file handles.  Such processes will have their stdin
  closed unless it has been redirected-to.
  
  If you want to close a child processes stdin, you may do any of:
  
     run \@cmd, \undef;
     run \@cmd, \"";
     run \@cmd, '<&-';
     run \@cmd, '0<&-';
  
  Redirection is done by placing redirection specifications immediately 
  after a command or child subroutine:
  
     run \@cmd1,      \$in, '|', \@cmd2,      \$out;
     run \@cmd1, '<', \$in, '|', \@cmd2, '>', \$out;
  
  If you omit the redirection operators, descriptors are counted
  starting at 0.  Descriptor 0 is assumed to be input, all others
  are outputs.  A leading '|' consumes descriptor 0, so this
  works as expected.
  
     run \@cmd1, \$in, '|', \@cmd2, \$out;
     
  The parameter following a redirection operator can be a scalar ref,
  a subroutine ref, a file name, an open filehandle, or a closed
  filehandle.
  
  If it's a scalar ref, the child reads input from or sends output to
  that variable:
  
     $in = "Hello World.\n";
     run \@cat, \$in, \$out;
     print $out;
  
  Scalars used in incremental (start()/pump()/finish()) applications are treated
  as queues: input is removed from input scalers, resulting in them dwindling
  to '', and output is appended to output scalars.  This is not true of 
  harnesses run() in batch mode.
  
  It's usually wise to append new input to be sent to the child to the input
  queue, and you'll often want to zap output queues to '' before pumping.
  
     $h = start \@cat, \$in;
     $in = "line 1\n";
     pump $h;
     $in .= "line 2\n";
     pump $h;
     $in .= "line 3\n";
     finish $h;
  
  The final call to finish() must be there: it allows the child process(es)
  to run to completion and waits for their exit values.
  
  =head1 OBSTINATE CHILDREN
  
  Interactive applications are usually optimized for human use.  This
  can help or hinder trying to interact with them through modules like
  IPC::Run.  Frequently, programs alter their behavior when they detect
  that stdin, stdout, or stderr are not connected to a tty, assuming that
  they are being run in batch mode.  Whether this helps or hurts depends
  on which optimizations change.  And there's often no way of telling
  what a program does in these areas other than trial and error and,
  occasionally, reading the source.  This includes different versions
  and implementations of the same program.
  
  All hope is not lost, however.  Most programs behave in reasonably
  tractable manners, once you figure out what it's trying to do.
  
  Here are some of the issues you might need to be aware of.
  
  =over
  
  =item *
  
  fflush()ing stdout and stderr
  
  This lets the user see stdout and stderr immediately.  Many programs
  undo this optimization if stdout is not a tty, making them harder to
  manage by things like IPC::Run.
  
  Many programs decline to fflush stdout or stderr if they do not
  detect a tty there.  Some ftp commands do this, for instance.
  
  If this happens to you, look for a way to force interactive behavior,
  like a command line switch or command.  If you can't, you will
  need to use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  false prompts
  
  Interactive programs generally do not guarantee that output from user
  commands won't contain a prompt string.  For example, your shell prompt
  might be a '$', and a file named '$' might be the only file in a directory
  listing.
  
  This can make it hard to guarantee that your output parser won't be fooled
  into early termination of results.
  
  To help work around this, you can see if the program can alter it's 
  prompt, and use something you feel is never going to occur in actual
  practice.
  
  You should also look for your prompt to be the only thing on a line:
  
     pump $h until $out =~ /^<SILLYPROMPT>\s?\z/m;
  
  (use C<(?!\n)\Z> in place of C<\z> on older perls).
  
  You can also take the approach that IPC::ChildSafe takes and emit a
  command with known output after each 'real' command you issue, then
  look for this known output.  See new_appender() and new_chunker() for
  filters that can help with this task.
  
  If it's not convenient or possibly to alter a prompt or use a known
  command/response pair, you might need to autodetect the prompt in case
  the local version of the child program is different then the one
  you tested with, or if the user has control over the look & feel of
  the prompt.
  
  =item *
  
  Refusing to accept input unless stdin is a tty.
  
  Some programs, for security reasons, will only accept certain types
  of input from a tty.  su, notable, will not prompt for a password unless
  it's connected to a tty.
  
  If this is your situation, use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  Not prompting unless connected to a tty.
  
  Some programs don't prompt unless stdin or stdout is a tty.  See if you can
  turn prompting back on.  If not, see if you can come up with a command that
  you can issue after every real command and look for it's output, as
  IPC::ChildSafe does.   There are two filters included with IPC::Run that
  can help with doing this: appender and chunker (see new_appender() and
  new_chunker()).
  
  =item *
  
  Different output format when not connected to a tty.
  
  Some commands alter their formats to ease machine parsability when they
  aren't connected to a pipe.  This is actually good, but can be surprising.
  
  =back
  
  =head1 PSEUDO TERMINALS
  
  On systems providing pseudo terminals under /dev, IPC::Run can use IO::Pty
  (available on CPAN) to provide a terminal environment to subprocesses.
  This is necessary when the subprocess really wants to think it's connected
  to a real terminal.
  
  =head2 CAVEATS
  
  Psuedo-terminals are not pipes, though they are similar.  Here are some
  differences to watch out for.
  
  =over
  
  =item Echoing
  
  Sending to stdin will cause an echo on stdout, which occurs before each
  line is passed to the child program.  There is currently no way to
  disable this, although the child process can and should disable it for
  things like passwords.
  
  =item Shutdown
  
  IPC::Run cannot close a pty until all output has been collected.  This
  means that it is not possible to send an EOF to stdin by half-closing
  the pty, as we can when using a pipe to stdin.
  
  This means that you need to send the child process an exit command or
  signal, or run() / finish() will time out.  Be careful not to expect a
  prompt after sending the exit command.
  
  =item Command line editing
  
  Some subprocesses, notable shells that depend on the user's prompt
  settings, will reissue the prompt plus the command line input so far
  once for each character.
  
  =item '>pty>' means '&>pty>', not '1>pty>'
  
  The pseudo terminal redirects both stdout and stderr unless you specify
  a file descriptor.  If you want to grab stderr separately, do this:
  
     start \@cmd, '<pty<', \$in, '>pty>', \$out, '2>', \$err;
  
  =item stdin, stdout, and stderr not inherited
  
  Child processes harnessed to a pseudo terminal have their stdin, stdout,
  and stderr completely closed before any redirection operators take
  effect.  This casts of the bonds of the controlling terminal.  This is
  not done when using pipes.
  
  Right now, this affects all children in a harness that has a pty in use,
  even if that pty would not affect a particular child.  That's a bug and
  will be fixed.  Until it is, it's best not to mix-and-match children.
  
  =back
  
  =head2 Redirection Operators
  
     Operator       SHNP   Description
     ========       ====   ===========
     <, N<          SHN    Redirects input to a child's fd N (0 assumed)
  
     >, N>          SHN    Redirects output from a child's fd N (1 assumed)
     >>, N>>        SHN    Like '>', but appends to scalars or named files
     >&, &>         SHN    Redirects stdout & stderr from a child process
  
     <pty, N<pty    S      Like '<', but uses a pseudo-tty instead of a pipe
     >pty, N>pty    S      Like '>', but uses a pseudo-tty instead of a pipe
  
     N<&M                  Dups input fd N to input fd M
     M>&N                  Dups output fd N to input fd M
     N<&-                  Closes fd N
  
     <pipe, N<pipe     P   Pipe opens H for caller to read, write, close.
     >pipe, N>pipe     P   Pipe opens H for caller to read, write, close.
                        
  'N' and 'M' are placeholders for integer file descriptor numbers.  The
  terms 'input' and 'output' are from the child process's perspective.
  
  The SHNP field indicates what parameters an operator can take:
  
     S: \$scalar or \&function references.  Filters may be used with
        these operators (and only these).
     H: \*HANDLE or IO::Handle for caller to open, and close
     N: "file name".
     P: \*HANDLE opened by IPC::Run as the parent end of a pipe, but read
        and written to and closed by the caller (like IPC::Open3).
  
  =over
  
  =item Redirecting input: [n]<, [n]<pipe
  
  You can input the child reads on file descriptor number n to come from a
  scalar variable, subroutine, file handle, or a named file.  If stdin
  is not redirected, the parent's stdin is inherited.
  
     run \@cat, \undef          ## Closes child's stdin immediately
        or die "cat returned $?"; 
  
     run \@cat, \$in;
  
     run \@cat, \<<TOHERE;
     blah
     TOHERE
  
     run \@cat, \&input;       ## Calls &input, feeding data returned
                                ## to child's.  Closes child's stdin
                                ## when undef is returned.
  
  Redirecting from named files requires you to use the input
  redirection operator:
  
     run \@cat, '<.profile';
     run \@cat, '<', '.profile';
  
     open IN, "<foo";
     run \@cat, \*IN;
     run \@cat, *IN{IO};
  
  The form used second example here is the safest,
  since filenames like "0" and "&more\n" won't confuse &run:
  
  You can't do either of
  
     run \@a, *IN;      ## INVALID
     run \@a, '<', *IN; ## BUGGY: Reads file named like "*main::A"
     
  because perl passes a scalar containing a string that
  looks like "*main::A" to &run, and &run can't tell the difference
  between that and a redirection operator or a file name.  &run guarantees
  that any scalar you pass after a redirection operator is a file name.
  
  If your child process will take input from file descriptors other
  than 0 (stdin), you can use a redirection operator with any of the
  valid input forms (scalar ref, sub ref, etc.):
  
     run \@cat, '3<', \$in3;
  
  When redirecting input from a scalar ref, the scalar ref is
  used as a queue.  This allows you to use &harness and pump() to
  feed incremental bits of input to a coprocess.  See L</Coprocesses>
  below for more information.
  
  The <pipe operator opens the write half of a pipe on the filehandle
  glob reference it takes as an argument:
  
     $h = start \@cat, '<pipe', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  Unlike the other '<' operators, IPC::Run does nothing further with
  it: you are responsible for it.  The previous example is functionally
  equivalent to:
  
     pipe( \*R, \*IN ) or die $!;
     $h = start \@cat, '<', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  This is like the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Redirecting output: [n]>, [n]>>, [n]>&[m], [n]>pipe
  
  You can redirect any output the child emits
  to a scalar variable, subroutine, file handle, or file name.  You
  can have &run truncate or append to named files or scalars.  If
  you are redirecting stdin as well, or if the command is on the
  receiving end of a pipeline ('|'), you can omit the redirection
  operator:
  
     @ls = ( 'ls' );
     run \@ls, \undef, \$out
        or die "ls returned $?"; 
  
     run \@ls, \undef, \&out;  ## Calls &out each time some output
                                ## is received from the child's 
                                ## when undef is returned.
  
     run \@ls, \undef, '2>ls.err';
     run \@ls, '2>', 'ls.err';
  
  The two parameter form guarantees that the filename
  will not be interpreted as a redirection operator:
  
     run \@ls, '>', "&more";
     run \@ls, '2>', ">foo\n";
  
  You can pass file handles you've opened for writing:
  
     open( *OUT, ">out.txt" );
     open( *ERR, ">err.txt" );
     run \@cat, \*OUT, \*ERR;
  
  Passing a scalar reference and a code reference requires a little
  more work, but allows you to capture all of the output in a scalar
  or each piece of output by a callback:
  
  These two do the same things:
  
     run( [ 'ls' ], '2>', sub { $err_out .= $_[0] } );
  
  does the same basic thing as:
  
     run( [ 'ls' ], '2>', \$err_out );
  
  The subroutine will be called each time some data is read from the child.
  
  The >pipe operator is different in concept than the other '>' operators,
  although it's syntax is similar:
  
     $h = start \@cat, $in, '>pipe', \*OUT, '2>pipe', \*ERR;
     $in = "hello world\n";
     finish $h;
     print <OUT>;
     print <ERR>;
     close OUT;
     close ERR;
  
  causes two pipe to be created, with one end attached to cat's stdout
  and stderr, respectively, and the other left open on OUT and ERR, so
  that the script can manually
  read(), select(), etc. on them.  This is like
  the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Duplicating output descriptors: >&m, n>&m
  
  This duplicates output descriptor number n (default is 1 if n is omitted)
  from descriptor number m.
  
  =item Duplicating input descriptors: <&m, n<&m
  
  This duplicates input descriptor number n (default is 0 if n is omitted)
  from descriptor number m
  
  =item Closing descriptors: <&-, 3<&-
  
  This closes descriptor number n (default is 0 if n is omitted).  The
  following commands are equivalent:
  
     run \@cmd, \undef;
     run \@cmd, '<&-';
     run \@cmd, '<in.txt', '<&-';
  
  Doing
  
     run \@cmd, \$in, '<&-';    ## SIGPIPE recipe.
  
  is dangerous: the parent will get a SIGPIPE if $in is not empty.
  
  =item Redirecting both stdout and stderr: &>, >&, &>pipe, >pipe&
  
  The following pairs of commands are equivalent:
  
     run \@cmd, '>&', \$out;       run \@cmd, '>', \$out,     '2>&1';
     run \@cmd, '>&', 'out.txt';   run \@cmd, '>', 'out.txt', '2>&1';
  
  etc.
  
  File descriptor numbers are not permitted to the left or the right of
  these operators, and the '&' may occur on either end of the operator.
  
  The '&>pipe' and '>pipe&' variants behave like the '>pipe' operator, except
  that both stdout and stderr write to the created pipe.
  
  =item Redirection Filters
  
  Both input redirections and output redirections that use scalars or
  subs as endpoints may have an arbitrary number of filter subs placed
  between them and the child process.  This is useful if you want to
  receive output in chunks, or if you want to massage each chunk of
  data sent to the child.  To use this feature, you must use operator
  syntax:
  
     run(
        \@cmd
           '<', \&in_filter_2, \&in_filter_1, $in,
           '>', \&out_filter_1, \&in_filter_2, $out,
     );
  
  This capability is not provided for IO handles or named files.
  
  Two filters are provided by IPC::Run: appender and chunker.  Because
  these may take an argument, you need to use the constructor functions
  new_appender() and new_chunker() rather than using \& syntax:
  
     run(
        \@cmd
           '<', new_appender( "\n" ), $in,
           '>', new_chunker, $out,
     );
  
  =back
  
  =head2 Just doing I/O
  
  If you just want to do I/O to a handle or file you open yourself, you
  may specify a filehandle or filename instead of a command in the harness
  specification:
  
     run io( "filename", '>', \$recv );
  
     $h = start io( $io, '>', \$recv );
  
     $h = harness \@cmd, '&', io( "file", '<', \$send );
  
  =head2 Options
  
  Options are passed in as name/value pairs:
  
     run \@cat, \$in, debug => 1;
  
  If you pass the debug option, you may want to pass it in first, so you
  can see what parsing is going on:
  
     run debug => 1, \@cat, \$in;
  
  =over
  
  =item debug
  
  Enables debugging output in parent and child.  Debugging info is emitted
  to the STDERR that was present when IPC::Run was first C<use()>ed (it's
  C<dup()>ed out of the way so that it can be redirected in children without
  having debugging output emitted on it).
  
  =back
  
  =head1 RETURN VALUES
  
  harness() and start() return a reference to an IPC::Run harness.  This is
  blessed in to the IPC::Run package, so you may make later calls to
  functions as members if you like:
  
     $h = harness( ... );
     $h->start;
     $h->pump;
     $h->finish;
  
     $h = start( .... );
     $h->pump;
     ...
  
  Of course, using method call syntax lets you deal with any IPC::Run
  subclasses that might crop up, but don't hold your breath waiting for
  any.
  
  run() and finish() return TRUE when all subcommands exit with a 0 result
  code.  B<This is the opposite of perl's system() command>.
  
  All routines raise exceptions (via die()) when error conditions are
  recognized.  A non-zero command result is not treated as an error
  condition, since some commands are tests whose results are reported 
  in their exit codes.
  
  =head1 ROUTINES
  
  =over
  
  =cut
  
  use strict;
  use Exporter ();
  use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
  BEGIN {
  	$VERSION = '0.94';
  	@ISA     = qw{ Exporter };
  
  	## We use @EXPORT for the end user's convenience: there's only one function
  	## exported, it's homonymous with the module, it's an unusual name, and
  	## it can be suppressed by "use IPC::Run ();".
  	@FILTER_IMP = qw( input_avail get_more_input );
  	@FILTERS    = qw(
  		new_appender
  		new_chunker
  		new_string_source
  		new_string_sink
  	);
  	@API        = qw(
  		run
  		harness start pump pumpable finish
  		signal kill_kill reap_nb
  		io timer timeout
  		close_terminal
  		binary
  	);
  	@EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
  	%EXPORT_TAGS = (
  		'filter_imp' => \@FILTER_IMP,
  		'all'        => \@EXPORT_OK,
  		'filters'    => \@FILTERS,
  		'api'        => \@API,
  	);
  
  }
  
  use strict;
  use IPC::Run::Debug;
  use Exporter;
  use Fcntl;
  use POSIX ();
  BEGIN { if ($] < 5.008) { require Symbol; } }
  use Carp;
  use File::Spec ();
  use IO::Handle;
  require IPC::Run::IO;
  require IPC::Run::Timer;
  use UNIVERSAL ();
  
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  BEGIN {
     if ( Win32_MODE ) {
        eval "use IPC::Run::Win32Helper; 1;"
           or ( $@ && die ) or die "$!";
     }
     else {
        eval "use File::Basename; 1;" or die $!;
     }
  }
  
  sub input_avail();
  sub get_more_input();
  
  ###############################################################################
  
  ##
  ## Error constants, not too locale-dependant
  use vars  qw( $_EIO $_EAGAIN );
  use Errno qw(   EIO   EAGAIN );
  BEGIN {
    local $!;
    $! = EIO;    $_EIO    = qr/^$!/;
    $! = EAGAIN; $_EAGAIN = qr/^$!/;
  }
  
  ##
  ## State machine states, set in $self->{STATE}
  ##
  ## These must be in ascending order numerically
  ##
  sub _newed()    {0}
  sub _harnessed(){1}
  sub _finished() {2}   ## _finished behave almost exactly like _harnessed
  sub _started()  {3}
  
  ##
  ## Which fds have been opened in the parent.  This may have extra fds, since
  ## we aren't all that rigorous about closing these off, but that's ok.  This
  ## is used on Unixish OSs to close all fds in the child that aren't needed
  ## by that particular child.
  my %fds;
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  
  use vars qw( $cur_self );
  
  sub _debug_fd {
     return fileno STDERR unless defined $cur_self;
  
     if ( _debugging && ! defined $cur_self->{DEBUG_FD} ) {
        my $fd = select STDERR; $| = 1; select $fd;
        $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
        _debug( "debugging fd is $cur_self->{DEBUG_FD}\n" )
           if _debugging_details;
     }
  
     return fileno STDERR unless defined $cur_self->{DEBUG_FD};
  
     return $cur_self->{DEBUG_FD}
  }
  
  sub DESTROY {
     ## We absolutely do not want to do anything else here.  We are likely
     ## to be in a child process and we don't want to do things like kill_kill
     ## ourself or cause other destruction.
     my IPC::Run $self = shift;
     POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
     $self->{DEBUG_FD} = undef;
  }
  
  ##
  ## Support routines (NOT METHODS)
  ##
  my %cmd_cache;
  
  sub _search_path {
     my ( $cmd_name ) = @_;
     if ( File::Spec->file_name_is_absolute( $cmd_name ) && -x $cmd_name) {
        _debug "'", $cmd_name, "' is absolute"
           if _debugging_details;
        return $cmd_name;
     }
  
     my $dirsep =
        ( Win32_MODE
           ? '[/\\\\]'
        : $^O =~ /MacOS/
           ? ':'
        : $^O =~ /VMS/
           ? '[\[\]]'
        : '/'
        );
  
     if ( Win32_MODE
        && ( $cmd_name =~ /$dirsep/ )
  #      && ( $cmd_name !~ /\..+$/ )  ## Only run if cmd_name has no extension?
        && ( $cmd_name !~ m!\.[^\\/\.]+$! )
      ) {
  
        _debug "no extension(.exe), checking ENV{PATHEXT}"  if _debugging;
        for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
           my $name = "$cmd_name$_";
           $cmd_name = $name, last if -f $name && -x _;
        }
        _debug "cmd_name is now '$cmd_name'"  if _debugging;
     }
  
     if ( $cmd_name =~ /($dirsep)/ ) {
        _debug "'$cmd_name' contains '$1'"  if _debugging;
        croak "file not found: $cmd_name"    unless -e $cmd_name;
        croak "not a file: $cmd_name"        unless -f $cmd_name;
        croak "permission denied: $cmd_name" unless -x $cmd_name;
        return $cmd_name;
     }
  
     if ( exists $cmd_cache{$cmd_name} ) {
        _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
           if _debugging;
        return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
        _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
           if _debugging;
        delete $cmd_cache{$cmd_name};
     }
  
     my @searched_in;
  
     ## This next bit is Unix/Win32 specific, unfortunately.
     ## There's been some conversation about extending File::Spec to provide
     ## a universal interface to PATH, but I haven't seen it yet.
        my $re = Win32_MODE ? qr/;/ : qr/:/;
  
  LOOP:
     for ( split( $re, $ENV{PATH} || '', -1 ) ) {
        $_ = "." unless length $_;
        push @searched_in, $_;
  
        my $prospect = File::Spec->catfile( $_, $cmd_name );
        my @prospects;
  
        @prospects =
           ( Win32_MODE && ! ( -f $prospect && -x _ ) )
              ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
              : ( $prospect );
  
        for my $found ( @prospects ) {
           if ( -f $found && -x _ ) {
              $cmd_cache{$cmd_name} = $found;
              last LOOP;
           }
        }
     }
  
     if ( exists $cmd_cache{$cmd_name} ) {
        _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
           if _debugging_details;
        return $cmd_cache{$cmd_name};
     }
  
     croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
  }
  
  
  sub _empty($) { ! ( defined $_[0] && length $_[0] ) }
  
  ## 'safe' versions of otherwise fun things to do. See also IPC::Run::Win32Helper.
  sub _close {
     confess 'undef' unless defined $_[0];
     my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
     my $r = POSIX::close $fd;
     $r = $r ? '' : " ERROR $!";
     delete $fds{$fd};
     _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
  }
  
  sub _dup {
     confess 'undef' unless defined $_[0];
     my $r = POSIX::dup( $_[0] );
     croak "$!: dup( $_[0] )" unless defined $r;
     $r = 0 if $r eq '0 but true';
     _debug "dup( $_[0] ) = $r" if _debugging_details;
     $fds{$r} = 1;
     return $r;
  }
  
  
  sub _dup2_rudely {
     confess 'undef' unless defined $_[0] && defined $_[1];
     my $r = POSIX::dup2( $_[0], $_[1] );
     croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
     $r = 0 if $r eq '0 but true';
     _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
     $fds{$r} = 1;
     return $r;
  }
  
  sub _exec {
     confess 'undef passed' if grep !defined, @_;
  #   exec @_ or croak "$!: exec( " . join( ', ', @_ ) . " )";
     _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
  
  #   {
  ## Commented out since we don't call this on Win32.
  #      # This works around the bug where 5.6.1 complains
  #      # "Can't exec ...: No error" after an exec on NT, where
  #      # exec() is simulated and actually returns in Perl's C
  #      # code, though Perl's &exec does not...
  #      no warnings "exec";
  #
  #      # Just in case the no warnings workaround
  #      # stops being a workaround, we don't want
  #      # old values of $! causing spurious strerr()
  #      # messages to appear in the "Can't exec" message
  #      undef $!;
        exec { $_[0] } @_;
  #   }
  #   croak "$!: exec( " . join( ', ', map "'$_'", @_ ) . " )";
      ## Fall through so $! can be reported to parent.
  }
  
  
  sub _sysopen {
     confess 'undef' unless defined $_[0] && defined $_[1];
  _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
  sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
  sprintf( "O_RDWR=0x%02x ", O_RDWR ),
  sprintf( "O_TRUNC=0x%02x ", O_TRUNC),
  sprintf( "O_CREAT=0x%02x ", O_CREAT),
  sprintf( "O_APPEND=0x%02x ", O_APPEND),
  if _debugging_details;
     my $r = POSIX::open( $_[0], $_[1], 0644 );
     croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
     _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
        if _debugging_data;
     $fds{$r} = 1;
     return $r;
  }
  
  sub _pipe {
     ## Normal, blocking write for pipes that we read and the child writes,
     ## since most children expect writes to stdout to block rather than
     ## do a partial write.
     my ( $r, $w ) = POSIX::pipe;
     croak "$!: pipe()" unless defined $r;
     _debug "pipe() = ( $r, $w ) " if _debugging_details;
     $fds{$r} = $fds{$w} = 1;
     return ( $r, $w );
  }
  
  sub _pipe_nb {
     ## For pipes that we write, unblock the write side, so we can fill a buffer
     ## and continue to select().
     ## Contributed by Borislav Deianov <borislav@ensim.com>, with minor
     ## bugfix on fcntl result by me.
     local ( *R, *W );
     my $f = pipe( R, W );
     croak "$!: pipe()" unless defined $f;
     my ( $r, $w ) = ( fileno R, fileno W );
     _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
     unless ( Win32_MODE ) {
        ## POSIX::fcntl doesn't take fd numbers, so gotta use Perl's and
        ## then _dup the originals (which get closed on leaving this block)
        my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
        croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
        _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
     }
     ( $r, $w ) = ( _dup( $r ), _dup( $w ) );
     _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
     return ( $r, $w );
  }
  
  sub _pty {
     require IO::Pty;
     my $pty = IO::Pty->new();
     croak "$!: pty ()" unless $pty;
     $pty->autoflush();
     $pty->blocking( 0 ) or croak "$!: pty->blocking ( 0 )";
     _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
        if _debugging_details;
     $fds{$pty->fileno} = $fds{$pty->slave->fileno} = 1;
     return $pty;
  }
  
  
  sub _read {
     confess 'undef' unless defined $_[0];
     my $s  = '';
     my $r = POSIX::read( $_[0], $s, 10_000 );
     croak "$!: read( $_[0] )" if not($r) and $! != POSIX::EINTR;
     $r ||= 0;
     _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
     return $s;
  }
  
  
  ## A METHOD, not a function.
  sub _spawn {
     my IPC::Run $self = shift;
     my ( $kid ) = @_;
  
     _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
     my $sync_reader_fd;
     ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
     $kid->{PID} = fork();
     croak "$! during fork" unless defined $kid->{PID};
  
     unless ( $kid->{PID} ) {
        ## _do_kid_and_exit closes sync_reader_fd since it closes all unwanted and
        ## unloved fds.
        $self->_do_kid_and_exit( $kid );
     }
     _debug "fork() = ", $kid->{PID} if _debugging_details;
  
     ## Wait for kid to get to it's exec() and see if it fails.
     _close $self->{SYNC_WRITER_FD};
     my $sync_pulse = _read $sync_reader_fd;
     _close $sync_reader_fd;
  
     if ( ! defined $sync_pulse || length $sync_pulse ) {
        if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
  	 $kid->{RESULT} = $?;
        }
        else {
  	 $kid->{RESULT} = -1;
        }
        $sync_pulse =
           "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
  	 unless length $sync_pulse;
        croak $sync_pulse;
     }
     return $kid->{PID};
  
  ## Wait for pty to get set up.  This is a hack until we get synchronous
  ## selects.
  if ( keys %{$self->{PTYS}} && $IO::Pty::VERSION < 0.9 ) {
  _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
  sleep 1;
  }
  }
  
  
  sub _write {
     confess 'undef' unless defined $_[0] && defined $_[1];
     my $r = POSIX::write( $_[0], $_[1], length $_[1] );
     croak "$!: write( $_[0], '$_[1]' )" unless $r;
     _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
     return $r;
  }
  
  =pod
  
  =over
  
  =item run
  
  Run takes a harness or harness specification and runs it, pumping
  all input to the child(ren), closing the input pipes when no more
  input is available, collecting all output that arrives, until the
  pipes delivering output are closed, then waiting for the children to
  exit and reaping their result codes.
  
  You may think of C<run( ... )> as being like 
  
     start( ... )->finish();
  
  , though there is one subtle difference: run() does not
  set \$input_scalars to '' like finish() does.  If an exception is thrown
  from run(), all children will be killed off "gently", and then "annihilated"
  if they do not go gently (in to that dark night. sorry).
  
  If any exceptions are thrown, this does a L</kill_kill> before propagating
  them.
  
  =cut
  
  use vars qw( $in_run );  ## No, not Enron;)
  
  sub run {
     local $in_run = 1;  ## Allow run()-only optimizations.
     my IPC::Run $self = start( @_ );
     my $r = eval {
        $self->{clear_ins} = 0;
        $self->finish;
     };
     if ( $@ ) {
        my $x = $@;
        $self->kill_kill;
        die $x;
     }
     return $r;
  }
  
  =pod
  
  =item signal
  
     ## To send it a specific signal by name ("USR1"):
     signal $h, "USR1";
     $h->signal ( "USR1" );
  
  If $signal is provided and defined, sends a signal to all child processes.  Try
  not to send numeric signals, use C<"KILL"> instead of C<9>, for instance.
  Numeric signals aren't portable.
  
  Throws an exception if $signal is undef.
  
  This will I<not> clean up the harness, C<finish> it if you kill it.
  
  Normally TERM kills a process gracefully (this is what the command line utility
  C<kill> does by default), INT is sent by one of the keys C<^C>, C<Backspace> or
  C<E<lt>DelE<gt>>, and C<QUIT> is used to kill a process and make it coredump.
  
  The C<HUP> signal is often used to get a process to "restart", rereading 
  config files, and C<USR1> and C<USR2> for really application-specific things.
  
  Often, running C<kill -l> (that's a lower case "L") on the command line will
  list the signals present on your operating system.
  
  B<WARNING>: The signal subsystem is not at all portable.  We *may* offer
  to simulate C<TERM> and C<KILL> on some operating systems, submit code
  to me if you want this.
  
  B<WARNING 2>: Up to and including perl v5.6.1, doing almost anything in a
  signal handler could be dangerous.  The most safe code avoids all
  mallocs and system calls, usually by preallocating a flag before
  entering the signal handler, altering the flag's value in the
  handler, and responding to the changed value in the main system:
  
     my $got_usr1 = 0;
     sub usr1_handler { ++$got_signal }
  
     $SIG{USR1} = \&usr1_handler;
     while () { sleep 1; print "GOT IT" while $got_usr1--; }
  
  Even this approach is perilous if ++ and -- aren't atomic on your system
  (I've never heard of this on any modern CPU large enough to run perl).
  
  =cut
  
  sub signal {
     my IPC::Run $self = shift;
  
     local $cur_self = $self;
  
     $self->_kill_kill_kill_pussycat_kill unless @_;
  
     Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
  
     my ( $signal ) = @_;
     croak "Undefined signal passed to signal" unless defined $signal;
     for ( grep $_->{PID} && ! defined $_->{RESULT}, @{$self->{KIDS}} ) {
        _debug "sending $signal to $_->{PID}"
           if _debugging;
        kill $signal, $_->{PID}
           or _debugging && _debug "$! sending $signal to $_->{PID}";
     }
     
     return;
  }
  
  =pod
  
  =item kill_kill
  
     ## To kill off a process:
     $h->kill_kill;
     kill_kill $h;
  
     ## To specify the grace period other than 30 seconds:
     kill_kill $h, grace => 5;
  
     ## To send QUIT instead of KILL if a process refuses to die:
     kill_kill $h, coup_d_grace => "QUIT";
  
  Sends a C<TERM>, waits for all children to exit for up to 30 seconds, then
  sends a C<KILL> to any that survived the C<TERM>.
  
  Will wait for up to 30 more seconds for the OS to successfully C<KILL> the
  processes.
  
  The 30 seconds may be overridden by setting the C<grace> option, this
  overrides both timers.
  
  The harness is then cleaned up.
  
  The doubled name indicates that this function may kill again and avoids
  colliding with the core Perl C<kill> function.
  
  Returns a 1 if the C<TERM> was sufficient, or a 0 if C<KILL> was 
  required.  Throws an exception if C<KILL> did not permit the children
  to be reaped.
  
  B<NOTE>: The grace period is actually up to 1 second longer than that
  given.  This is because the granularity of C<time> is 1 second.  Let me
  know if you need finer granularity, we can leverage Time::HiRes here.
  
  B<Win32>: Win32 does not know how to send real signals, so C<TERM> is
  a full-force kill on Win32.  Thus all talk of grace periods, etc. do
  not apply to Win32.
  
  =cut
  
  sub kill_kill {
     my IPC::Run $self = shift;
  
     my %options = @_;
     my $grace = $options{grace};
     $grace = 30 unless defined $grace;
     ++$grace; ## Make grace time a _minimum_
  
     my $coup_d_grace = $options{coup_d_grace};
     $coup_d_grace = "KILL" unless defined $coup_d_grace;
  
     delete $options{$_} for qw( grace coup_d_grace );
     Carp::cluck "Ignoring unknown options for kill_kill: ",
         join " ",keys %options
         if keys %options;
  
     $self->signal( "TERM" );
  
     my $quitting_time = time + $grace;
     my $delay = 0.01;
     my $accum_delay;
  
     my $have_killed_before;
  
     while () {
        ## delay first to yield to other processes
        select undef, undef, undef, $delay;
        $accum_delay += $delay;
  
        $self->reap_nb;
        last unless $self->_running_kids;
  
        if ( $accum_delay >= $grace*0.8 ) {
           ## No point in checking until delay has grown some.
           if ( time >= $quitting_time ) {
              if ( ! $have_killed_before ) {
                 $self->signal( $coup_d_grace );
                 $have_killed_before = 1;
                 $quitting_time += $grace;
                 $delay = 0.01;
                 $accum_delay = 0;
                 next;
              }
              croak "Unable to reap all children, even after KILLing them"
           }
        }
  
        $delay *= 2;
        $delay = 0.5 if $delay >= 0.5;
     }
  
     $self->_cleanup;
     return $have_killed_before;
  }
  
  =pod
  
  =item harness
  
  Takes a harness specification and returns a harness.  This harness is
  blessed in to IPC::Run, allowing you to use method call syntax for
  run(), start(), et al if you like.
  
  harness() is provided so that you can pre-build harnesses if you
  would like to, but it's not required..
  
  You may proceed to run(), start() or pump() after calling harness() (pump()
  calls start() if need be).  Alternatively, you may pass your
  harness specification to run() or start() and let them harness() for
  you.  You can't pass harness specifications to pump(), though.
  
  =cut
  
  ##
  ## Notes: I've avoided handling a scalar that doesn't look like an
  ## opcode as a here document or as a filename, though I could DWIM
  ## those.  I'm not sure that the advantages outweigh the danger when
  ## the DWIMer guesses wrong.
  ##
  ## TODO: allow user to spec default shell. Hmm, globally, in the
  ## lexical scope hash, or per instance?  'Course they can do that
  ## now by using a [...] to hold the command.
  ##
  my $harness_id = 0;
  sub harness {
     my $options;
     if ( @_ && ref $_[-1] eq 'HASH' ) {
        $options = pop;
        require Data::Dumper;
        carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper( $options );
     }
  
  #   local $IPC::Run::debug = $options->{debug}
  #      if $options && defined $options->{debug};
  
     my @args;
     if ( @_ == 1 && ! ref $_[0] ) {
        if ( Win32_MODE ) {
           my $command = $ENV{ComSpec} || 'cmd';
           @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
        }
        else {
           @args = ( [ qw( sh -c ), @_ ] );
        }
     }
     elsif ( @_ > 1 && ! grep ref $_, @_ ) {
        @args = ( [ @_ ] );
     }
     else {
        @args = @_;
     }
  
     my @errs;               # Accum errors, emit them when done.
  
     my $succinct;           # set if no redir ops are required yet.  Cleared
                              # if an op is seen.
  
     my $cur_kid;            # references kid or handle being parsed
  
     my $assumed_fd    = 0;  # fd to assume in succinct mode (no redir ops)
     my $handle_num    = 0;  # 1... is which handle we're parsing
  
     my IPC::Run $self = bless {}, __PACKAGE__;
  
     local $cur_self = $self;
  
     $self->{ID}    = ++$harness_id;
     $self->{IOS}   = [];
     $self->{KIDS}  = [];
     $self->{PIPES} = [];
     $self->{PTYS}  = {};
     $self->{STATE} = _newed;
  
     if ( $options ) {
        $self->{$_} = $options->{$_}
           for keys %$options;
     }
  
     _debug "****** harnessing *****" if _debugging;
  
     my $first_parse;
     local $_;
     my $arg_count = @args;
     while ( @args ) { for ( shift @args ) {
        eval {
           $first_parse = 1;
           _debug(
              "parsing ",
              defined $_
                 ? ref $_ eq 'ARRAY'
                    ? ( '[ ', join( ', ', map "'$_'", @$_ ), ' ]' )
                    : ( ref $_
                       || ( length $_ < 50
                             ? "'$_'"
                             : join( '', "'", substr( $_, 0, 10 ), "...'" )
                          )
                    )
                 : '<undef>'
           ) if _debugging;
  
        REPARSE:
           if ( ref eq 'ARRAY' || ( ! $cur_kid && ref eq 'CODE' ) ) {
              croak "Process control symbol ('|', '&') missing" if $cur_kid;
              croak "Can't spawn a subroutine on Win32"
  	       if Win32_MODE && ref eq "CODE";
              $cur_kid = {
                 TYPE   => 'cmd',
                 VAL    => $_,
                 NUM    => @{$self->{KIDS}} + 1,
                 OPS    => [],
                 PID    => '',
                 RESULT => undef,
              };
              push @{$self->{KIDS}}, $cur_kid;
              $succinct = 1;
           }
  
           elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
              push @{$self->{IOS}}, $_;
              $cur_kid = undef;
              $succinct = 1;
           }
           
           elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
              push @{$self->{TIMERS}}, $_;
              $cur_kid = undef;
              $succinct = 1;
           }
           
           elsif ( /^(\d*)>&(\d+)$/ ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'dup',
                 KFD1 => $2,
                 KFD2 => length $1 ? $1 : 1,
              };
              _debug "redirect operators now required" if _debugging_details;
              $succinct = ! $first_parse;
           }
  
           elsif ( /^(\d*)<&(\d+)$/ ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'dup',
                 KFD1 => $2,
                 KFD2 => length $1 ? $1 : 0,
              };
              $succinct = ! $first_parse;
           }
  
           elsif ( /^(\d*)<&-$/ ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'close',
                 KFD  => length $1 ? $1 : 0,
              };
              $succinct = ! $first_parse;
           }
  
           elsif (
                 /^(\d*) (<pipe)()            ()  ()  $/x
              || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
              || /^(\d*) (<)    ()            ()  (.*)$/x
           ) {
              croak "No command before '$_'" unless $cur_kid;
  
              $succinct = ! $first_parse;
  
              my $type = $2 . $4;
  
              my $kfd = length $1 ? $1 : 0;
  
              my $pty_id;
              if ( $type eq '<pty<' ) {
                 $pty_id = length $3 ? $3 : '0';
                 ## do the require here to cause early error reporting
                 require IO::Pty;
                 ## Just flag the pyt's existence for now.  It'll be
                 ## converted to a real IO::Pty by _open_pipes.
                 $self->{PTYS}->{$pty_id} = undef;
              }
  
              my $source = $5;
  
              my @filters;
              my $binmode;
  
              unless ( length $source ) {
                 if ( ! $succinct ) {
                    while ( @args > 1
                        && (
                           ( ref $args[1] && ! UNIVERSAL::isa $args[1], "IPC::Run::Timer" )
                           || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter"
                        )
                    ) {
                       if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                          $binmode = shift( @args )->();
                       }
                       else {
                          push @filters, shift @args
                       }
                    }
                 }
                 $source = shift @args;
                 croak "'$_' missing a source" if _empty $source;
  
                 _debug(
                    'Kid ', $cur_kid->{NUM}, "'s input fd ", $kfd,
                    ' has ', scalar( @filters ), ' filters.'
                 ) if _debugging_details && @filters;
              };
  
              my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal(
                 $type, $kfd, $pty_id, $source, $binmode, @filters
              );
  
              if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
                 && $type !~ /^<p(ty<|ipe)$/
              ) {
  	       _debug "setting DONT_CLOSE" if _debugging_details;
                 $pipe->{DONT_CLOSE} = 1; ## this FD is not closed by us.
  	       _dont_inherit( $source ) if Win32_MODE;
              }
  
              push @{$cur_kid->{OPS}}, $pipe;
        }
  
           elsif ( /^()   (>>?)  (&)     ()      (.*)$/x
              ||   /^()   (&)    (>pipe) ()      ()  $/x 
              ||   /^()   (>pipe)(&)     ()      ()  $/x 
              ||   /^(\d*)()     (>pipe) ()      ()  $/x
              ||   /^()   (&)    (>pty)  ( \w*)> ()  $/x 
  ## TODO:    ||   /^()   (>pty) (\d*)> (&) ()  $/x 
              ||   /^(\d*)()     (>pty)  ( \w*)> ()  $/x
              ||   /^()   (&)    (>>?)   ()      (.*)$/x 
              ||   /^(\d*)()     (>>?)   ()      (.*)$/x
           ) {
              croak "No command before '$_'" unless $cur_kid;
  
              $succinct = ! $first_parse;
  
              my $type = (
                 $2 eq '>pipe' || $3 eq '>pipe'
                    ? '>pipe'
                    : $2 eq '>pty' || $3 eq '>pty'
                       ? '>pty>'
                       : '>'
              );
              my $kfd = length $1 ? $1 : 1;
              my $trunc = ! ( $2 eq '>>' || $3 eq '>>' );
              my $pty_id = (
                 $2 eq '>pty' || $3 eq '>pty'
                    ? length $4 ? $4 : 0
                    : undef
              );
  
              my $stderr_too =
                    $2 eq '&'
                 || $3 eq '&'
                 || ( ! length $1 && substr( $type, 0, 4 ) eq '>pty' );
  
              my $dest = $5;
              my @filters;
              my $binmode = 0;
              unless ( length $dest ) {
                 if ( ! $succinct ) {
                    ## unshift...shift: '>' filters source...sink left...right
                    while ( @args > 1
                       && ( 
                          ( ref $args[1] && !  UNIVERSAL::isa $args[1], "IPC::Run::Timer" )
                          || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter"
                       )
                    ) {
                       if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                          $binmode = shift( @args )->();
                       }
                       else {
                          unshift @filters, shift @args;
                       }
                    }
                 }
  
                 $dest = shift @args;
  
                 _debug(
                    'Kid ', $cur_kid->{NUM}, "'s output fd ", $kfd,
                    ' has ', scalar( @filters ), ' filters.'
                 ) if _debugging_details && @filters;
  
                 if ( $type eq '>pty>' ) {
                    ## do the require here to cause early error reporting
                    require IO::Pty;
                    ## Just flag the pyt's existence for now.  _open_pipes()
                    ## will new an IO::Pty for each key.
                    $self->{PTYS}->{$pty_id} = undef;
                 }
              }
  
              croak "'$_' missing a destination" if _empty $dest;
              my $pipe = IPC::Run::IO->_new_internal(
                 $type, $kfd, $pty_id, $dest, $binmode, @filters
              );
              $pipe->{TRUNC} = $trunc;
  
              if (  ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
                 && $type !~ /^>(pty>|pipe)$/
              ) {
  	       _debug "setting DONT_CLOSE" if _debugging_details;
                 $pipe->{DONT_CLOSE} = 1; ## this FD is not closed by us.
              }
              push @{$cur_kid->{OPS}}, $pipe;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'dup',
                 KFD1 => 1,
                 KFD2 => 2,
              } if $stderr_too;
           }
  
           elsif ( $_ eq "|" ) {
              croak "No command before '$_'" unless $cur_kid;
              unshift @{$cur_kid->{OPS}}, {
                 TYPE => '|',
                 KFD  => 1,
              };
              $succinct   = 1;
              $assumed_fd = 1;
              $cur_kid    = undef;
           }
  
           elsif ( $_ eq "&" ) {
              croak "No command before '$_'" unless $cur_kid;
              unshift @{$cur_kid->{OPS}}, {
                 TYPE => 'close',
                 KFD  => 0,
              };
              $succinct   = 1;
              $assumed_fd = 0;
              $cur_kid    = undef;
           }
  
           elsif ( $_ eq 'init' ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'init',
                 SUB  => shift @args,
              };
           }
  
           elsif ( ! ref $_ ) {
              $self->{$_} = shift @args;
           }
  
           elsif ( $_ eq 'init' ) {
              croak "No command before '$_'" unless $cur_kid;
              push @{$cur_kid->{OPS}}, {
                 TYPE => 'init',
                 SUB  => shift @args,
              };
           }
  
           elsif ( $succinct && $first_parse ) {
              ## It's not an opcode, and no explicit opcodes have been
              ## seen yet, so assume it's a file name.
              unshift @args, $_;
              if ( ! $assumed_fd ) {
                 $_ = "$assumed_fd<",
              }
              else {
                 $_ = "$assumed_fd>",
              }
              _debug "assuming '", $_, "'" if _debugging_details;
              ++$assumed_fd;
              $first_parse = 0;
              goto REPARSE;
           }
  
           else {
              croak join( 
                 '',
                 'Unexpected ',
                 ( ref() ? $_ : 'scalar' ),
                 ' in harness() parameter ',
                 $arg_count - @args
              );
           }
        };
        if ( $@ ) {
           push @errs, $@;
           _debug 'caught ', $@ if _debugging;
        }
     } }
  
     die join( '', @errs ) if @errs;
  
  
     $self->{STATE} = _harnessed;
  #   $self->timeout( $options->{timeout} ) if exists $options->{timeout};
     return $self;
  }
  
  
  sub _open_pipes {
     my IPC::Run $self = shift;
  
     my @errs;
  
     my @close_on_fail;
  
     ## When a pipe character is seen, a pipe is created.  $pipe_read_fd holds
     ## the dangling read end of the pipe until we get to the next process.
     my $pipe_read_fd;
  
     ## Output descriptors for the last command are shared by all children.
     ## @output_fds_accum accumulates the current set of output fds.
     my @output_fds_accum;
  
     for ( sort keys %{$self->{PTYS}} ) {
        _debug "opening pty '", $_, "'" if _debugging_details;
        my $pty = _pty;
        $self->{PTYS}->{$_} = $pty;
     }
  
     for ( @{$self->{IOS}} ) {
        eval { $_->init; };
        if ( $@ ) {
           push @errs, $@;
           _debug 'caught ', $@ if _debugging;
        }
        else {
           push @close_on_fail, $_;
        }
     }
  
     ## Loop through the kids and their OPS, interpreting any that require
     ## parent-side actions.
     for my $kid ( @{$self->{KIDS}} ) {
        unless ( ref $kid->{VAL} eq 'CODE' ) {
           $kid->{PATH} = _search_path $kid->{VAL}->[0];
        }
        if ( defined $pipe_read_fd ) {
  	 _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
  	    if _debugging_details;
           unshift @{$kid->{OPS}}, {
              TYPE => 'PIPE',  ## Prevent next loop from triggering on this
              KFD  => 0,
              TFD  => $pipe_read_fd,
           };
           $pipe_read_fd = undef;
        }
        @output_fds_accum = ();
        for my $op ( @{$kid->{OPS}} ) {
  #         next if $op->{IS_DEBUG};
           my $ok = eval {
              if ( $op->{TYPE} eq '<' ) {
                 my $source = $op->{SOURCE};
  	       if ( ! ref $source ) {
  		  _debug(
  		     "kid ", $kid->{NUM}, " to read ", $op->{KFD},
  		     " from '" .  $source, "' (read only)"
  		  ) if _debugging_details;
  		  croak "simulated open failure"
  		     if $self->{_simulate_open_failure};
  		  $op->{TFD} = _sysopen( $source, O_RDONLY );
  		  push @close_on_fail, $op->{TFD};
  	       }
  	       elsif ( UNIVERSAL::isa( $source, 'GLOB' )
  		  ||   UNIVERSAL::isa( $source, 'IO::Handle' )
  	       ) {
  		  croak
  		     "Unopened filehandle in input redirect for $op->{KFD}"
  		     unless defined fileno $source;
  		  $op->{TFD} = fileno $source;
  		  _debug(
  		     "kid ", $kid->{NUM}, " to read ", $op->{KFD},
  		     " from fd ", $op->{TFD}
  		  ) if _debugging_details;
  	       }
  	       elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
  		  _debug(
  		     "kid ", $kid->{NUM}, " to read ", $op->{KFD},
  		     " from SCALAR"
  		  ) if _debugging_details;
  
  		  $op->open_pipe( $self->_debug_fd );
  		  push @close_on_fail, $op->{KFD}, $op->{FD};
  
  		  my $s = '';
  		  $op->{KIN_REF} = \$s;
  	       }
  	       elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
  		  _debug(
  		     'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE'
  		  ) if _debugging_details;
  		  
  		  $op->open_pipe( $self->_debug_fd );
  		  push @close_on_fail, $op->{KFD}, $op->{FD};
  		  
  		  my $s = '';
  		  $op->{KIN_REF} = \$s;
  	       }
  	       else {
  		  croak(
  		     "'"
  		     . ref( $source )
  		     . "' not allowed as a source for input redirection"
  		  );
  	       }
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '<pipe' ) {
                 _debug(
                    'kid to read ', $op->{KFD},
                    ' from a pipe IPC::Run opens and returns',
                 ) if _debugging_details;
  
                 my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
  	       _debug "caller will write to ", fileno $op->{SOURCE}
  	          if _debugging_details;
  
                 $op->{TFD}    = $r;
  	       $op->{FD}     = undef; # we don't manage this fd
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '<pty<' ) {
                 _debug(
                    'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
                 ) if _debugging_details;
                 
                 for my $source ( $op->{SOURCE} ) {
                    if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                       _debug(
                          "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                          " from SCALAR via pty '", $op->{PTY_ID}, "'"
                       ) if _debugging_details;
  
                       my $s = '';
                       $op->{KIN_REF} = \$s;
                    }
                    elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                       _debug(
                          "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                          " from CODE via pty '", $op->{PTY_ID}, "'"
                       ) if _debugging_details;
                       my $s = '';
                       $op->{KIN_REF} = \$s;
                    }
                    else {
                       croak(
                          "'"
                          . ref( $source )
                          . "' not allowed as a source for '<pty<' redirection"
                       );
                    }
                 }
                 $op->{FD} = $self->{PTYS}->{$op->{PTY_ID}}->fileno;
                 $op->{TFD} = undef; # The fd isn't known until after fork().
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '>' ) {
                 ## N> output redirection.
                 my $dest = $op->{DEST};
                 if ( ! ref $dest ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                       " to '", $dest, "' (write only, create, ",
                       ( $op->{TRUNC} ? 'truncate' : 'append' ),
                       ")"
                    ) if _debugging_details;
                    croak "simulated open failure"
                       if $self->{_simulate_open_failure};
                    $op->{TFD} = _sysopen(
                       $dest,
                       ( O_WRONLY
                       | O_CREAT 
                       | ( $op->{TRUNC} ? O_TRUNC : O_APPEND )
                       )
                    );
  		  if ( Win32_MODE ) {
  		     ## I have no idea why this is needed to make the current
  		     ## file position survive the gyrations TFD must go 
  		     ## through...
  		     POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
  		  }
                    push @close_on_fail, $op->{TFD};
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
                    croak(
                     "Unopened filehandle in output redirect, command $kid->{NUM}"
                    ) unless defined fileno $dest;
                    ## Turn on autoflush, mostly just to flush out
                    ## existing output.
                    my $old_fh = select( $dest ); $| = 1; select( $old_fh );
                    $op->{TFD} = fileno $dest;
                    _debug(
                       'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD}
                    ) if _debugging_details;
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR"
                    ) if _debugging_details;
  
  		  $op->open_pipe( $self->_debug_fd );
                    push @close_on_fail, $op->{FD}, $op->{TFD};
                    $$dest = '' if $op->{TRUNC};
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                    _debug(
                       "kid $kid->{NUM} to write $op->{KFD} to CODE"
                    ) if _debugging_details;
  
  		  $op->open_pipe( $self->_debug_fd );
                    push @close_on_fail, $op->{FD}, $op->{TFD};
                 }
                 else {
                    croak(
                       "'"
                       . ref( $dest )
                       . "' not allowed as a sink for output redirection"
                    );
                 }
                 $output_fds_accum[$op->{KFD}] = $op;
                 $op->_init_filters;
              }
  
              elsif ( $op->{TYPE} eq '>pipe' ) {
                 ## N> output redirection to a pipe we open, but don't select()
                 ## on.
                 _debug(
                    "kid ", $kid->{NUM}, " to write ", $op->{KFD},
  		  ' to a pipe IPC::Run opens and returns'
                 ) if _debugging_details;
  
                 my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
  	       _debug "caller will read from ", fileno $op->{DEST}
  	          if _debugging_details;
  
                 $op->{TFD} = $w;
  	       $op->{FD}  = undef; # we don't manage this fd
                 $op->_init_filters;
  
                 $output_fds_accum[$op->{KFD}] = $op;
              }
              elsif ( $op->{TYPE} eq '>pty>' ) {
                 my $dest = $op->{DEST};
                 if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                       " to SCALAR via pty '", $op->{PTY_ID}, "'"
                 ) if _debugging_details;
  
                    $$dest = '' if $op->{TRUNC};
                 }
                 elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                    _debug(
                       "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                       " to CODE via pty '", $op->{PTY_ID}, "'"
                    ) if _debugging_details;
                 }
                 else {
                    croak(
                       "'"
                       . ref( $dest )
                       . "' not allowed as a sink for output redirection"
                    );
                 }
  
                 $op->{FD} = $self->{PTYS}->{$op->{PTY_ID}}->fileno;
                 $op->{TFD} = undef; # The fd isn't known until after fork().
                 $output_fds_accum[$op->{KFD}] = $op;
                 $op->_init_filters;
              }
              elsif ( $op->{TYPE} eq '|' ) {
                 _debug(
                    "pipelining $kid->{NUM} and "
                    . ( $kid->{NUM} + 1 )
                 ) if _debugging_details;
                 ( $pipe_read_fd, $op->{TFD} ) = _pipe;
  	       if ( Win32_MODE ) {
  		  _dont_inherit( $pipe_read_fd );
  		  _dont_inherit( $op->{TFD} );
  	       }
                 @output_fds_accum = ();
              }
              elsif ( $op->{TYPE} eq '&' ) {
                 @output_fds_accum = ();
              } # end if $op->{TYPE} tree
  	    1;
  	 }; # end eval
  	 unless ( $ok ) {
  	    push @errs, $@;
  	    _debug 'caught ', $@ if _debugging;
  	 }
        } # end for ( OPS }
     }
  
     if ( @errs ) {
        for ( @close_on_fail ) {
           _close( $_ );
           $_ = undef;
        }
        for ( keys %{$self->{PTYS}} ) {
           next unless $self->{PTYS}->{$_};
           close $self->{PTYS}->{$_};
           $self->{PTYS}->{$_} = undef;
        }
        die join( '', @errs )
     }
  
     ## give all but the last child all of the output file descriptors
     ## These will be reopened (and thus rendered useless) if the child
     ## dup2s on to these descriptors, since we unshift these.  This way
     ## each process emits output to the same file descriptors that the
     ## last child will write to.  This is probably not quite correct,
     ## since each child should write to the file descriptors inherited
     ## from the parent.
     ## TODO: fix the inheritance of output file descriptors.
     ## NOTE: This sharing of OPS among kids means that we can't easily put
     ## a kid number in each OPS structure to ping the kid when all ops
     ## have closed (when $self->{PIPES} has emptied).  This means that we
     ## need to scan the KIDS whenever @{$self->{PIPES}} is empty to see
     ## if there any of them are still alive.
     for ( my $num = 0; $num < $#{$self->{KIDS}}; ++$num ) {
        for ( reverse @output_fds_accum ) {
           next unless defined $_;
           _debug(
              'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
              ' to ', ref $_->{DEST}
           ) if _debugging_details;
           unshift @{$self->{KIDS}->[$num]->{OPS}}, $_;
        }
     }
  
     ## Open the debug pipe if we need it
     ## Create the list of PIPES we need to scan and the bit vectors needed by
     ## select().  Do this first so that _cleanup can _clobber() them if an
     ## exception occurs.
     @{$self->{PIPES}} = ();
     $self->{RIN} = '';
     $self->{WIN} = '';
     $self->{EIN} = '';
     ## PIN is a vec()tor that indicates who's paused.
     $self->{PIN} = '';
     for my $kid ( @{$self->{KIDS}} ) {
        for ( @{$kid->{OPS}} ) {
           if ( defined $_->{FD} ) {
              _debug(
                 'kid ', $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
                 ' is my ', $_->{FD}
              ) if _debugging_details;
              vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
  #	    vec( $self->{EIN}, $_->{FD}, 1 ) = 1;
              push @{$self->{PIPES}}, $_;
           }
        }
     }
  
     for my $io ( @{$self->{IOS}} ) {
        my $fd = $io->fileno;
        vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
        vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
  #      vec( $self->{EIN}, $fd, 1 ) = 1;
        push @{$self->{PIPES}}, $io;
     }
  
     ## Put filters on the end of the filter chains to read & write the pipes.
     ## Clear pipe states
     for my $pipe ( @{$self->{PIPES}} ) {
        $pipe->{SOURCE_EMPTY} = 0;
        $pipe->{PAUSED} = 0;
        if ( $pipe->{TYPE} =~ /^>/ ) {
           my $pipe_reader = sub {
              my ( undef, $out_ref ) = @_;
  
              return undef unless defined $pipe->{FD};
              return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
  
              vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
  
              _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
              my $in = eval { _read( $pipe->{FD} ) };
              if ( $@ ) {
                 $in = '';
                 ## IO::Pty throws the Input/output error if the kid dies.
  	       ## read() throws the bad file descriptor message if the
  	       ## kid dies on Win32.
                 die $@ unless
  	          $@ =~ $_EIO ||
  		  ($@ =~ /input or output/ && $^O =~ /aix/) 
  		  || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
              }
  
              unless ( length $in ) {
                 $self->_clobber( $pipe );
                 return undef;
              }
  
              ## Protect the position so /.../g matches may be used.
              my $pos = pos $$out_ref;
              $$out_ref .= $in;
              pos( $$out_ref ) = $pos;
              return 1;
           };
           ## Input filters are the last filters
           push @{$pipe->{FILTERS}}, $pipe_reader;
           push @{$self->{TEMP_FILTERS}}, $pipe_reader;
        }
        else {
           my $pipe_writer = sub {
              my ( $in_ref, $out_ref ) = @_;
              return undef unless defined $pipe->{FD};
              return 0
                 unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
                    || $pipe->{PAUSED};
  
              vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
  
              if ( ! length $$in_ref ) {
                 if ( ! defined get_more_input ) {
                    $self->_clobber( $pipe );
                    return undef;
                 }
              }
  
              unless ( length $$in_ref ) {
                 unless ( $pipe->{PAUSED} ) {
                    _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
                    vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
  #		  vec( $self->{EIN}, $pipe->{FD}, 1 ) = 0;
                    vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
                    $pipe->{PAUSED} = 1;
                 }
                 return 0;
              }
              _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
  
              my $c = _write( $pipe->{FD}, $$in_ref );
              substr( $$in_ref, 0, $c, '' );
              return 1;
           };
           ## Output filters are the first filters
           unshift @{$pipe->{FILTERS}}, $pipe_writer;
           push    @{$self->{TEMP_FILTERS}}, $pipe_writer;
        }
     }
  }
  
  
  sub _dup2_gently {
     ## A METHOD, NOT A FUNCTION, NEEDS $self!
     my IPC::Run $self = shift;
     my ( $files, $fd1, $fd2 ) = @_;
     ## Moves TFDs that are using the destination fd out of the
     ## way before calling _dup2
     for ( @$files ) {
        next unless defined $_->{TFD};
        $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
     }
     $self->{DEBUG_FD} = _dup $self->{DEBUG_FD}
        if defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2;
  
     _dup2_rudely( $fd1, $fd2 );
  }
  
  =pod
  
  =item close_terminal
  
  This is used as (or in) an init sub to cast off the bonds of a controlling
  terminal.  It must precede all other redirection ops that affect
  STDIN, STDOUT, or STDERR to be guaranteed effective.
  
  =cut
  
  
  sub close_terminal {
     ## Cast of the bonds of a controlling terminal
  
     POSIX::setsid() || croak "POSIX::setsid() failed";
     _debug "closing stdin, out, err"
        if _debugging_details;
     close STDIN;
     close STDERR;
     close STDOUT;
  }
  
  
  sub _do_kid_and_exit {
     my IPC::Run $self = shift;
     my ( $kid ) = @_;
  
     my ( $s1, $s2 );
     if ($] < 5.008) {
       ## For unknown reasons, placing these two statements in the eval{}
       ## causes the eval {} to not catch errors after they are executed in
       ## perl 5.6.0, godforsaken version that it is...not sure about 5.6.1.
       ## Part of this could be that these symbols get destructed when
       ## exiting the eval, and that destruction might be what's (wrongly)
       ## confusing the eval{}, allowing the exception to probpogate.
       $s1 = Symbol::gensym();
       $s2 = Symbol::gensym();
     }
  
     eval {
        local $cur_self = $self;
  
        if ( _debugging ) {
           _set_child_debug_name( ref $kid->{VAL} eq "CODE"
           	 ? "CODE"
           	 : basename( $kid->{VAL}->[0] )
           );
        }
  
        ## close parent FD's first so they're out of the way.
        ## Don't close STDIN, STDOUT, STDERR: they should be inherited or
        ## overwritten below.
        my @needed = $self->{noinherit} ? () : ( 1, 1, 1 );
        $needed[ $self->{SYNC_WRITER_FD} ] = 1;
        $needed[ $self->{DEBUG_FD} ] = 1 if defined $self->{DEBUG_FD};
  
        for ( @{$kid->{OPS}} ) {
  	 $needed[ $_->{TFD} ] = 1 if defined $_->{TFD};
        }
  
        ## TODO: use the forthcoming IO::Pty to close the terminal and
        ## make the first pty for this child the controlling terminal.
        ## This will also make it so that pty-laden kids don't cause
        ## other kids to lose stdin/stdout/stderr.
        my @closed;
        if ( %{$self->{PTYS}} ) {
  	 ## Clean up the parent's fds.
  	 for ( keys %{$self->{PTYS}} ) {
  	    _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
  	    my $slave = $self->{PTYS}->{$_}->slave;
  	    $closed[ $self->{PTYS}->{$_}->fileno ] = 1;
  	    close $self->{PTYS}->{$_};
  	    $self->{PTYS}->{$_} = $slave;
  	 }
  
  	 close_terminal;
  	 $closed[ $_ ] = 1 for ( 0..2 );
        }
  
        for my $sibling ( @{$self->{KIDS}} ) {
  	 for ( @{$sibling->{OPS}} ) {
  	    if ( $_->{TYPE} =~ /^.pty.$/ ) {
  	       $_->{TFD} = $self->{PTYS}->{$_->{PTY_ID}}->fileno;
  	       $needed[$_->{TFD}] = 1;
  	    }
  
  #	    for ( $_->{FD}, ( $sibling != $kid ? $_->{TFD} : () ) ) {
  #	       if ( defined $_ && ! $closed[$_] && ! $needed[$_] ) {
  #		  _close( $_ );
  #		  $closed[$_] = 1;
  #		  $_ = undef;
  #	       }
  #	    }
  	 }
        }
  
        ## This is crude: we have no way of keeping track of browsing all open
        ## fds, so we scan to a fairly high fd.
        _debug "open fds: ", join " ", keys %fds if _debugging_details;
        for (keys %fds) {
           if ( ! $closed[$_] && ! $needed[$_] ) {
              _close( $_ );
              $closed[$_] = 1;
           }
        }
  
        ## Lazy closing is so the same fd (ie the same TFD value) can be dup2'ed on
        ## several times.
        my @lazy_close;
        for ( @{$kid->{OPS}} ) {
  	 if ( defined $_->{TFD} ) {
  	    unless ( $_->{TFD} == $_->{KFD} ) {
  	       $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
  	       push @lazy_close, $_->{TFD};
  	    }
  	 }
  	 elsif ( $_->{TYPE} eq 'dup' ) {
  	    $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
  	       unless $_->{KFD1} == $_->{KFD2};
  	 }
  	 elsif ( $_->{TYPE} eq 'close' ) {
  	    for ( $_->{KFD} ) {
  	       if ( ! $closed[$_] ) {
  		  _close( $_ );
  		  $closed[$_] = 1;
  		  $_ = undef;
  	       }
  	    }
  	 }
  	 elsif ( $_->{TYPE} eq 'init' ) {
  	    $_->{SUB}->();
  	 }
        }
  
        for ( @lazy_close ) {
  	 unless ( $closed[$_] ) {
  	    _close( $_ );
  	    $closed[$_] = 1;
  	 }
        }
  
        if ( ref $kid->{VAL} ne 'CODE' ) {
  	 open $s1, ">&=$self->{SYNC_WRITER_FD}"
  	    or croak "$! setting filehandle to fd SYNC_WRITER_FD";
  	 fcntl $s1, F_SETFD, 1;
  
  	 if ( defined $self->{DEBUG_FD} ) {
  	    open $s2, ">&=$self->{DEBUG_FD}"
  	       or croak "$! setting filehandle to fd DEBUG_FD";
  	    fcntl $s2, F_SETFD, 1;
  	 }
  
  	 if ( _debugging ) {
  	    my @cmd = ( $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}] );
  	    _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd;
  	 }
  
  	 die "exec failed: simulating exec() failure"
  	    if $self->{_simulate_exec_failure};
  
  	 _exec $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}];
  
  	 croak "exec failed: $!";
        }
     };
     if ( $@ ) {
        _write $self->{SYNC_WRITER_FD}, $@;
        ## Avoid DESTROY.
        POSIX::exit 1;
     }
  
     ## We must be executing code in the child, otherwise exec() would have
     ## prevented us from being here.
     _close $self->{SYNC_WRITER_FD};
     _debug 'calling fork()ed CODE ref' if _debugging;
     POSIX::close $self->{DEBUG_FD}      if defined $self->{DEBUG_FD};
     ## TODO: Overload CORE::GLOBAL::exit...
     $kid->{VAL}->();
  
     ## There are bugs in perl closures up to and including 5.6.1
     ## that may keep this next line from having any effect, and it
     ## won't have any effect if our caller has kept a copy of it, but
     ## this may cause the closure to be cleaned up.  Maybe.
     $kid->{VAL} = undef;
  
     ## Use POSIX::exit to avoid global destruction, since this might
     ## cause DESTROY() to be called on objects created in the parent
     ## and thus cause double cleanup.  For instance, if DESTROY() unlinks
     ## a file in the child, we don't want the parent to suddenly miss
     ## it.
     POSIX::exit 0;
  }
  
  =pod
  
  =item start
  
     $h = start(
        \@cmd, \$in, \$out, ...,
        timeout( 30, name => "process timeout" ),
        $stall_timeout = timeout( 10, name => "stall timeout"   ),
     );
  
     $h = start \@cmd, '<', \$in, '|', \@cmd2, ...;
  
  start() accepts a harness or harness specification and returns a harness
  after building all of the pipes and launching (via fork()/exec(), or, maybe
  someday, spawn()) all the child processes.  It does not send or receive any
  data on the pipes, see pump() and finish() for that.
  
  You may call harness() and then pass it's result to start() if you like,
  but you only need to if it helps you structure or tune your application.
  If you do call harness(), you may skip start() and proceed directly to
  pump.
  
  start() also starts all timers in the harness.  See L<IPC::Run::Timer>
  for more information.
  
  start() flushes STDOUT and STDERR to help you avoid duplicate output.
  It has no way of asking Perl to flush all your open filehandles, so
  you are going to need to flush any others you have open.  Sorry.
  
  Here's how if you don't want to alter the state of $| for your
  filehandle:
  
     $ofh = select HANDLE; $of = $|; $| = 1; $| = $of; select $ofh;
  
  If you don't mind leaving output unbuffered on HANDLE, you can do
  the slightly shorter
  
     $ofh = select HANDLE; $| = 1; select $ofh;
  
  Or, you can use IO::Handle's flush() method:
  
     use IO::Handle;
     flush HANDLE;
  
  Perl needs the equivalent of C's fflush( (FILE *)NULL ).
  
  =cut
  
  sub start {
  # $SIG{__DIE__} = sub { my $s = shift; Carp::cluck $s; die $s };
     my $options;
     if ( @_ && ref $_[-1] eq 'HASH' ) {
        $options = pop;
        require Data::Dumper;
        carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper( $options );
     }
  
     my IPC::Run $self;
     if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
        $self = shift;
        $self->{$_} = $options->{$_} for keys %$options;
     }
     else {
        $self = harness( @_, $options ? $options : () );
     }
  
     local $cur_self = $self;
  
     $self->kill_kill if $self->{STATE} == _started;
  
     _debug "** starting" if _debugging;
  
     $_->{RESULT} = undef for @{$self->{KIDS}};
  
     ## Assume we're not being called from &run.  It will correct our
     ## assumption if need be.  This affects whether &_select_loop clears
     ## input queues to '' when they're empty.
     $self->{clear_ins} = 1;
  
     IPC::Run::Win32Helper::optimize $self
         if Win32_MODE && $in_run;
  
     my @errs;
  
     for ( @{$self->{TIMERS}} ) {
        eval { $_->start };
        if ( $@ ) {
           push @errs, $@;
           _debug 'caught ', $@ if _debugging;
        }
     }
  
     eval { $self->_open_pipes };
     if ( $@ ) {
        push @errs, $@;
        _debug 'caught ', $@ if _debugging;
     }
  
     if ( ! @errs ) {
        ## This is a bit of a hack, we should do it for all open filehandles.
        ## Since there's no way I know of to enumerate open filehandles, we
        ## autoflush STDOUT and STDERR.  This is done so that the children don't
        ## inherit output buffers chock full o' redundant data.  It's really
        ## confusing to track that down.
        { my $ofh = select STDOUT; local $| = 1; select $ofh; }
        { my $ofh = select STDERR; local $| = 1; select $ofh; }
        for my $kid ( @{$self->{KIDS}} ) {
           $kid->{RESULT} = undef;
           _debug "child: ",
              ref( $kid->{VAL} ) eq "CODE"
              ? "CODE ref"
              : (
                 "`",
                 join( " ", map /[^\w.-]/ ? "'$_'" : $_, @{$kid->{VAL}} ),
                 "`"
              ) if _debugging_details;
           eval {
              croak "simulated failure of fork"
                 if $self->{_simulate_fork_failure};
              unless ( Win32_MODE ) {
  	       $self->_spawn( $kid );
              }
              else {
  ## TODO: Test and debug spawning code.  Someday.
                 _debug( 
                    'spawning ',
                    join(
                       ' ',
                       map(
                          "'$_'",
                          ( $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}] )
                       )
                    )
                 ) if _debugging;
  	       ## The external kid wouldn't know what to do with it anyway.
  	       ## This is only used by the "helper" pump processes on Win32.
  	       _dont_inherit( $self->{DEBUG_FD} );
                 ( $kid->{PID}, $kid->{PROCESS} ) =
  		  IPC::Run::Win32Helper::win32_spawn( 
  		     [ $kid->{PATH}, @{$kid->{VAL}}[1..$#{$kid->{VAL}}] ],
  		     $kid->{OPS},
  		  );
                 _debug "spawn() = ", $kid->{PID} if _debugging;
              }
           };
           if ( $@ ) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
           }
        }
     }
  
     ## Close all those temporary filehandles that the kids needed.
     for my $pty ( values %{$self->{PTYS}} ) {
        close $pty->slave;
     }
  
     my @closed;
     for my $kid ( @{$self->{KIDS}} ) {
        for ( @{$kid->{OPS}} ) {
           my $close_it = eval {
              defined $_->{TFD}
                 && ! $_->{DONT_CLOSE}
                 && ! $closed[$_->{TFD}]
                 && ( ! Win32_MODE || ! $_->{RECV_THROUGH_TEMP_FILE} ) ## Win32 hack
           };
           if ( $@ ) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
           }
           if ( $close_it || $@ ) {
              eval {
                 _close( $_->{TFD} );
                 $closed[$_->{TFD}] = 1;
                 $_->{TFD} = undef;
              };
              if ( $@ ) {
                 push @errs, $@;
                 _debug 'caught ', $@ if _debugging;
              }
           }
        }
     }
  confess "gak!" unless defined $self->{PIPES};
  
     if ( @errs ) {
        eval { $self->_cleanup };
        warn $@ if $@;
        die join( '', @errs );
     }
  
     $self->{STATE} = _started;
     return $self;
  }
  
  =item adopt
  
  Experimental feature. NOT FUNCTIONAL YET, NEED TO CLOSE FDS BETTER IN CHILDREN.  SEE t/adopt.t for a test suite.
  
  =cut
  
  sub adopt {
     my IPC::Run $self = shift;
  
     for my $adoptee ( @_ ) {
        push @{$self->{IOS}},    @{$adoptee->{IOS}};
        ## NEED TO RENUMBER THE KIDS!!
        push @{$self->{KIDS}},   @{$adoptee->{KIDS}};
        push @{$self->{PIPES}},  @{$adoptee->{PIPES}};
        $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_}
           for keys %{$adoptee->{PYTS}};
        push @{$self->{TIMERS}}, @{$adoptee->{TIMERS}};
        $adoptee->{STATE} = _finished;
     }
  }
  
  
  sub _clobber {
     my IPC::Run $self = shift;
     my ( $file ) = @_;
     _debug_desc_fd( "closing", $file ) if _debugging_details;
     my $doomed = $file->{FD};
     my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
     vec( $self->{$dir}, $doomed, 1 ) = 0;
  #   vec( $self->{EIN},  $doomed, 1 ) = 0;
     vec( $self->{PIN},  $doomed, 1 ) = 0;
     if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
        if ( $1 eq '>' ) {
           ## Only close output ptys.  This is so that ptys as inputs are
           ## never autoclosed, which would risk losing data that was
           ## in the slave->parent queue.
           _debug_desc_fd "closing pty", $file if _debugging_details;
           close $self->{PTYS}->{$file->{PTY_ID}}
              if defined $self->{PTYS}->{$file->{PTY_ID}};
           $self->{PTYS}->{$file->{PTY_ID}} = undef;
        }
     }
     elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
        $file->close unless $file->{DONT_CLOSE};
     }
     else {
        _close( $doomed );
     }
  
     @{$self->{PIPES}} = grep
        defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed),
        @{$self->{PIPES}};
  
     $file->{FD} = undef;
  }
  
  sub _select_loop {
     my IPC::Run $self = shift;
  
     my $io_occurred;
  
     my $not_forever = 0.01;
  
  SELECT:
     while ( $self->pumpable ) {
        if ( $io_occurred && $self->{break_on_io} ) {
           _debug "exiting _select(): io occured and break_on_io set"
  	    if _debugging_details;
           last;
        }
  
        my $timeout = $self->{non_blocking} ? 0 : undef;
  
        if ( @{$self->{TIMERS}} ) {
           my $now = time;
           my $time_left;
           for ( @{$self->{TIMERS}} ) {
              next unless $_->is_running;
              $time_left = $_->check( $now );
              ## Return when a timer expires
              return if defined $time_left && ! $time_left;
              $timeout = $time_left
                 if ! defined $timeout || $time_left < $timeout;
           }
        }
  
        ##
        ## See if we can unpause any input channels
        ##
        my $paused = 0;
  
        for my $file ( @{$self->{PIPES}} ) {
           next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
  
           _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
           my $did;
           1 while $did = $file->_do_filters( $self );
           if ( defined $file->{FD} && ! defined( $did ) || $did ) {
              _debug_desc_fd( "unpausing", $file ) if _debugging_details;
              $file->{PAUSED} = 0;
              vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
  #	    vec( $self->{EIN}, $file->{FD}, 1 ) = 1;
              vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
           }
           else {
              ## This gets incremented occasionally when the IO channel
              ## was actually closed.  That's a bug, but it seems mostly
              ## harmless: it causes us to exit if break_on_io, or to set
              ## the timeout to not be forever.  I need to fix it, though.
              ++$paused;
           }
        }
  
        if ( _debugging_details ) {
           my $map = join(
              '',
              map {
                 my $out;
                 $out = 'r'                     if vec( $self->{RIN}, $_, 1 );
                 $out = $out ? 'b' : 'w'        if vec( $self->{WIN}, $_, 1 );
                 $out = 'p'           if ! $out && vec( $self->{PIN}, $_, 1 );
                 $out = $out ? uc( $out ) : 'x' if vec( $self->{EIN}, $_, 1 );
                 $out = '-' unless $out;
                 $out;
              } (0..1024)
           );
           $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
           _debug 'fds for select: ', $map if _debugging_details;
        }
  
        ## _do_filters may have closed our last fd, and we need to see if
        ## we have I/O, or are just waiting for children to exit.
        my $p = $self->pumpable;
        last unless $p;
        if ( $p != 0  && ( ! defined $timeout || $timeout > 0.1 ) ) {
           ## No I/O will wake the select loop up, but we have children
           ## lingering, so we need to poll them with a short timeout.
  	 ## Otherwise, assume more input will be coming.
  	 $timeout = $not_forever;
           $not_forever *= 2;
           $not_forever = 0.5 if $not_forever >= 0.5;
        }
  
        ## Make sure we don't block forever in select() because inputs are
        ## paused.
        if ( ! defined $timeout && ! ( @{$self->{PIPES}} - $paused ) ) {
           ## Need to return if we're in pump and all input is paused, or
  	 ## we'll loop until all inputs are unpaused, which is darn near
  	 ## forever.  And a day.
           if ( $self->{break_on_io} ) {
  	    _debug "exiting _select(): no I/O to do and timeout=forever"
                 if _debugging;
  	    last;
  	 }
  
  	 ## Otherwise, assume more input will be coming.
  	 $timeout = $not_forever;
           $not_forever *= 2;
           $not_forever = 0.5 if $not_forever >= 0.5;
        }
  
        _debug 'timeout=', defined $timeout ? $timeout : 'forever'
           if _debugging_details;
  
        my $nfound;
        unless ( Win32_MODE ) {
           $nfound = select(
              $self->{ROUT} = $self->{RIN},
              $self->{WOUT} = $self->{WIN},
              $self->{EOUT} = $self->{EIN},
              $timeout 
  	 );
        }
        else {
  	 my @in = map $self->{$_}, qw( RIN WIN EIN );
  	 ## Win32's select() on Win32 seems to die if passed vectors of
  	 ## all 0's.  Need to report this when I get back online.
  	 for ( @in ) {
  	    $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
  	 }
  
  	 $nfound = select(
              $self->{ROUT} = $in[0],
              $self->{WOUT} = $in[1],
              $self->{EOUT} = $in[2],
              $timeout 
           );
  
  	 for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
  	    $_ = "" unless defined $_;
  	 }
        }
        last if ! $nfound && $self->{non_blocking};
  
        if ($nfound < 0) {
           if ($! == POSIX::EINTR) {
              # Caught a signal before any FD went ready.  Ensure that
              # the bit fields reflect "no FDs ready".
              $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
              $nfound = 0;
           }
           else {
              croak "$! in select";
           }
        }
            ## TODO: Analyze the EINTR failure mode and see if this patch
            ## is adequate and optimal.
            ## TODO: Add an EINTR test to the test suite.
  
        if ( _debugging_details ) {
           my $map = join(
              '',
              map {
                 my $out;
                 $out = 'r'                     if vec( $self->{ROUT}, $_, 1 );
                 $out = $out ? 'b' : 'w'        if vec( $self->{WOUT}, $_, 1 );
                 $out = $out ? uc( $out ) : 'x' if vec( $self->{EOUT}, $_, 1 );
                 $out = '-' unless $out;
                 $out;
              } (0..128)
           );
           $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
           _debug "selected  ", $map;
        }
  
        ## Need to copy since _clobber alters @{$self->{PIPES}}.
        ## TODO: Rethink _clobber().  Rethink $file->{PAUSED}, too.
        my @pipes = @{$self->{PIPES}};
        $io_occurred = $_->poll( $self ) ? 1 : $io_occurred for @pipes;
  #   FILE:
  #      for my $pipe ( @pipes ) {
  #         ## Pipes can be shared among kids.  If another kid closes the
  #         ## pipe, then it's {FD} will be undef.  Also, on Win32, pipes can
  #	 ## be optimized to be files, in which case the FD is left undef
  #	 ## so we don't try to select() on it.
  #         if ( $pipe->{TYPE} =~ /^>/
  #            && defined $pipe->{FD}
  #            && vec( $self->{ROUT}, $pipe->{FD}, 1 )
  #         ) {
  #            _debug_desc_fd( "filtering data from", $pipe ) if _debugging_details;
  #confess "phooey" unless UNIVERSAL::isa( $pipe, "IPC::Run::IO" );
  #            $io_occurred = 1 if $pipe->_do_filters( $self );
  #
  #            next FILE unless defined $pipe->{FD};
  #         }
  #
  #	 ## On Win32, pipes to the child can be optimized to be files
  #	 ## and FD left undefined so we won't select on it.
  #         if ( $pipe->{TYPE} =~ /^</
  #            && defined $pipe->{FD}
  #            && vec( $self->{WOUT}, $pipe->{FD}, 1 )
  #         ) {
  #            _debug_desc_fd( "filtering data to", $pipe ) if _debugging_details;
  #            $io_occurred = 1 if $pipe->_do_filters( $self );
  #
  #            next FILE unless defined $pipe->{FD};
  #         }
  #
  #         if ( defined $pipe->{FD} && vec( $self->{EOUT}, $pipe->{FD}, 1 ) ) {
  #            ## BSD seems to sometimes raise the exceptional condition flag
  #            ## when a pipe is closed before we read it's last data.  This
  #            ## causes spurious warnings and generally renders the exception
  #            ## mechanism useless for our purposes.  The exception
  #            ## flag semantics are too variable (they're device driver
  #            ## specific) for me to easily map to any automatic action like
  #            ## warning or croaking (try running v0.42 if you don't believe me
  #            ## :-).
  #            warn "Exception on descriptor $pipe->{FD}";
  #         }
  #      }
     }
  
     return;
  }
  
  
  sub _cleanup {
     my IPC::Run $self = shift;
     _debug "cleaning up" if _debugging_details;
  
     for ( values %{$self->{PTYS}} ) {
        next unless ref $_;
        eval {
           _debug "closing slave fd ", fileno $_->slave if _debugging_data;
           close $_->slave;
        };
        carp $@ . " while closing ptys" if $@;
        eval {
           _debug "closing master fd ", fileno $_ if _debugging_data;
           close $_;
        };
        carp $@ . " closing ptys" if $@;
     }
     
     _debug "cleaning up pipes" if _debugging_details;
     ## _clobber modifies PIPES
     $self->_clobber( $self->{PIPES}->[0] ) while @{$self->{PIPES}};
  
     for my $kid ( @{$self->{KIDS}} ) {
        _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
        if ( ! length $kid->{PID} ) {
           _debug 'never ran child ', $kid->{NUM}, ", can't reap"
              if _debugging;
           for my $op ( @{$kid->{OPS}} ) {
              _close( $op->{TFD} )
                 if defined $op->{TFD} && ! defined $op->{TEMP_FILE_HANDLE};
           }
        }
        elsif ( ! defined $kid->{RESULT} ) {
           _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
              if _debugging;
           my $pid = waitpid $kid->{PID}, 0;
           $kid->{RESULT} = $?;
           _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
              if _debugging;
        }
  
  #      if ( defined $kid->{DEBUG_FD} ) {
  #	 die;
  #         @{$kid->{OPS}} = grep
  #            ! defined $_->{KFD} || $_->{KFD} != $kid->{DEBUG_FD},
  #            @{$kid->{OPS}};
  #         $kid->{DEBUG_FD} = undef;
  #      }
  
        _debug "cleaning up filters" if _debugging_details;
        for my $op ( @{$kid->{OPS}} ) {
           @{$op->{FILTERS}} = grep {
              my $filter = $_;
              ! grep $filter == $_, @{$self->{TEMP_FILTERS}};
           } @{$op->{FILTERS}};
        }
  
        for my $op ( @{$kid->{OPS}} ) {
           $op->_cleanup( $self ) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
        }
     }
     $self->{STATE} = _finished;
     @{$self->{TEMP_FILTERS}} = ();
     _debug "done cleaning up" if _debugging_details;
  
     POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
     $self->{DEBUG_FD} = undef;
  }
  
  =pod
  
  =item pump
  
     pump $h;
     $h->pump;
  
  Pump accepts a single parameter harness.  It blocks until it delivers some
  input or receives some output.  It returns TRUE if there is still input or
  output to be done, FALSE otherwise.
  
  pump() will automatically call start() if need be, so you may call harness()
  then proceed to pump() if that helps you structure your application.
  
  If pump() is called after all harnessed activities have completed, a "process
  ended prematurely" exception to be thrown.  This allows for simple scripting
  of external applications without having to add lots of error handling code at
  each step of the script:
  
     $h = harness \@smbclient, \$in, \$out, $err;
  
     $in = "cd /foo\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /foo:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $h->finish;
  
     warn $err if $err;
  
  =cut
  
  sub pump {
     die "pump() takes only a a single harness as a parameter"
        unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
  
     my IPC::Run $self = shift;
  
     local $cur_self = $self;
  
     _debug "** pumping" 
        if _debugging;
  
  #   my $r = eval {
        $self->start if $self->{STATE} < _started;
        croak "process ended prematurely" unless $self->pumpable;
  
        $self->{auto_close_ins} = 0;
        $self->{break_on_io}    = 1;
        $self->_select_loop;
        return $self->pumpable;
  #   };
  #   if ( $@ ) {
  #      my $x = $@;
  #      _debug $x if _debugging && $x;
  #      eval { $self->_cleanup };
  #      warn $@ if $@;
  #      die $x;
  #   }
  #   return $r;
  }
  
  =pod
  
  =item pump_nb
  
     pump_nb $h;
     $h->pump_nb;
  
  "pump() non-blocking", pumps if anything's ready to be pumped, returns
  immediately otherwise.  This is useful if you're doing some long-running
  task in the foreground, but don't want to starve any child processes.
  
  =cut
  
  sub pump_nb {
     my IPC::Run $self = shift;
  
     $self->{non_blocking} = 1;
     my $r = eval { $self->pump };
     $self->{non_blocking} = 0;
     die $@ if $@;
     return $r;
  }
  
  =pod
  
  =item pumpable
  
  Returns TRUE if calling pump() won't throw an immediate "process ended
  prematurely" exception.  This means that there are open I/O channels or
  active processes. May yield the parent processes' time slice for 0.01
  second if all pipes are to the child and all are paused.  In this case
  we can't tell if the child is dead, so we yield the processor and
  then attempt to reap the child in a nonblocking way.
  
  =cut
  
  ## Undocumented feature (don't depend on it outside this module):
  ## returns -1 if we have I/O channels open, or >0 if no I/O channels
  ## open, but we have kids running.  This allows the select loop
  ## to poll for child exit.
  sub pumpable {
     my IPC::Run $self = shift;
  
     ## There's a catch-22 we can get in to if there is only one pipe left
     ## open to the child and it's paused (ie the SCALAR it's tied to
     ## is '').  It's paused, so we're not select()ing on it, so we don't
     ## check it to see if the child attached to it is alive and it stays
     ## in @{$self->{PIPES}} forever.  So, if all pipes are paused, see if
     ## we can reap the child.
     return -1 if grep !$_->{PAUSED}, @{$self->{PIPES}};
  
     ## See if the child is dead.
     $self->reap_nb;
     return 0 unless $self->_running_kids;
  
     ## If we reap_nb and it's not dead yet, yield to it to see if it
     ## exits.
     ##
     ## A better solution would be to unpause all the pipes, but I tried that
     ## and it never errored on linux.  Sigh.  
     select undef, undef, undef, 0.0001;
  
     ## try again
     $self->reap_nb;
     return 0 unless $self->_running_kids;
  
     return -1; ## There are pipes waiting
  }
  
  
  sub _running_kids {
     my IPC::Run $self = shift;
     return grep
        defined $_->{PID} && ! defined $_->{RESULT},
        @{$self->{KIDS}};
  }
  
  =pod
  
  =item reap_nb
  
  Attempts to reap child processes, but does not block.
  
  Does not currently take any parameters, one day it will allow specific
  children to be reaped.
  
  Only call this from a signal handler if your C<perl> is recent enough
  to have safe signal handling (5.6.1 did not, IIRC, but it was being discussed
  on perl5-porters).  Calling this (or doing any significant work) in a signal
  handler on older C<perl>s is asking for seg faults.
  
  =cut
  
  my $still_runnings;
  
  sub reap_nb {
     my IPC::Run $self = shift;
  
     local $cur_self = $self;
  
     ## No more pipes, look to see if all the kids yet live, reaping those
     ## that haven't.  I'd use $SIG{CHLD}/$SIG{CLD}, but that's broken
     ## on older (SYSV) platforms and perhaps less portable than waitpid().
     ## This could be slow with a lot of kids, but that's rare and, well,
     ## a lot of kids is slow in the first place.
     ## Oh, and this keeps us from reaping other children the process
     ## may have spawned.
     for my $kid ( @{$self->{KIDS}} ) {
        if ( Win32_MODE ) {
  	 next if ! defined $kid->{PROCESS} || defined $kid->{RESULT};
  	 unless ( $kid->{PROCESS}->Wait( 0 ) ) {
  	    _debug "kid $kid->{NUM} ($kid->{PID}) still running"
                 if _debugging_details;
  	    next;
  	 }
  
           _debug "kid $kid->{NUM} ($kid->{PID}) exited"
              if _debugging;
  
  	 $kid->{PROCESS}->GetExitCode( $kid->{RESULT} )
  	    or croak "$! while GetExitCode()ing for Win32 process";
  
  	 unless ( defined $kid->{RESULT} ) {
  	    $kid->{RESULT} = "0 but true";
  	    $? = $kid->{RESULT} = 0x0F;
  	 }
  	 else {
  	    $? = $kid->{RESULT} << 8;
  	 }
        }
        else {
  	 next if ! defined $kid->{PID} || defined $kid->{RESULT};
  	 my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
  	 unless ( $pid ) {
  	    _debug "$kid->{NUM} ($kid->{PID}) still running"
                 if _debugging_details;
  	    next;
  	 }
  
  	 if ( $pid < 0 ) {
  	    _debug "No such process: $kid->{PID}\n" if _debugging;
  	    $kid->{RESULT} = "unknown result, unknown PID";
  	 }
  	 else {
              _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                 if _debugging;
  
  	    confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
  	       unless $pid = $kid->{PID};
  	    _debug "$kid->{PID} returned $?\n" if _debugging;
  	    $kid->{RESULT} = $?;
  	 }
        }
     }
  }
  
  =pod
  
  =item finish
  
  This must be called after the last start() or pump() call for a harness,
  or your system will accumulate defunct processes and you may "leak"
  file descriptors.
  
  finish() returns TRUE if all children returned 0 (and were not signaled and did
  not coredump, ie ! $?), and FALSE otherwise (this is like run(), and the
  opposite of system()).
  
  Once a harness has been finished, it may be run() or start()ed again,
  including by pump()s auto-start.
  
  If this throws an exception rather than a normal exit, the harness may
  be left in an unstable state, it's best to kill the harness to get rid
  of all the child processes, etc.
  
  Specifically, if a timeout expires in finish(), finish() will not
  kill all the children.  Call C<<$h->kill_kill>> in this case if you care.
  This differs from the behavior of L</run>.
  
  =cut
  
  sub finish {
     my IPC::Run $self = shift;
     my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
  
     local $cur_self = $self;
  
     _debug "** finishing" if _debugging;
  
     $self->{non_blocking}   = 0;
     $self->{auto_close_ins} = 1;
     $self->{break_on_io}    = 0;
     # We don't alter $self->{clear_ins}, start() and run() control it.
  
     while ( $self->pumpable ) {
        $self->_select_loop( $options );
     }
     $self->_cleanup;
  
     return ! $self->full_result;
  }
  
  =pod
  
  =item result
  
     $h->result;
  
  Returns the first non-zero result code (ie $? >> 8).  See L</full_result> to 
  get the $? value for a child process.
  
  To get the result of a particular child, do:
  
     $h->result( 0 );  # first child's $? >> 8
     $h->result( 1 );  # second child
  
  or
  
     ($h->results)[0]
     ($h->results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub _assert_finished {
     my IPC::Run $self = $_[0];
  
     croak "Harness not run" unless $self->{STATE} >= _finished;
     croak "Harness not finished running" unless $self->{STATE} == _finished;
  }
  
  
  sub result {
     &_assert_finished;
     my IPC::Run $self = shift;
     
     if ( @_ ) {
        my ( $which ) = @_;
        croak(
           "Only ",
           scalar( @{$self->{KIDS}} ),
           " child processes, no process $which"
        )
           unless $which >= 0 && $which <= $#{$self->{KIDS}};
        return $self->{KIDS}->[$which]->{RESULT} >> 8;
     }
     else {
        return undef unless @{$self->{KIDS}};
        for ( @{$self->{KIDS}} ) {
           return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
        }
     }
  }
  
  =pod
  
  =item results
  
  Returns a list of child exit values.  See L</full_results> if you want to
  know if a signal killed the child.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub results {
     &_assert_finished;
     my IPC::Run $self = shift;
  
     # we add 0 here to stop warnings associated with "unknown result, unknown PID"
     return map { (0+$_->{RESULT}) >> 8 } @{$self->{KIDS}};
  }
  
  =pod
  
  =item full_result
  
     $h->full_result;
  
  Returns the first non-zero $?.  See L</result> to get the first $? >> 8 
  value for a child process.
  
  To get the result of a particular child, do:
  
     $h->full_result( 0 );  # first child's $? >> 8
     $h->full_result( 1 );  # second child
  
  or
  
     ($h->full_results)[0]
     ($h->full_results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub full_result {
     goto &result if @_ > 1;
     &_assert_finished;
  
     my IPC::Run $self = shift;
  
     return undef unless @{$self->{KIDS}};
     for ( @{$self->{KIDS}} ) {
        return $_->{RESULT} if $_->{RESULT};
     }
  }
  
  =pod
  
  =item full_results
  
  Returns a list of child exit values as returned by C<wait>.  See L</results>
  if you don't care about coredumps or signals.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub full_results {
     &_assert_finished;
     my IPC::Run $self = shift;
  
     croak "Harness not run" unless $self->{STATE} >= _finished;
     croak "Harness not finished running" unless $self->{STATE} == _finished;
  
     return map $_->{RESULT}, @{$self->{KIDS}};
  }
  
  
  ##
  ## Filter Scaffolding
  ##
  use vars (
     '$filter_op',        ## The op running a filter chain right now
     '$filter_num',       ## Which filter is being run right now.
  );
  
  ##
  ## A few filters and filter constructors
  ##
  
  =pod
  
  =back
  
  =back
  
  =head1 FILTERS
  
  These filters are used to modify input our output between a child
  process and a scalar or subroutine endpoint.
  
  =over
  
  =item binary
  
     run \@cmd, ">", binary, \$out;
     run \@cmd, ">", binary, \$out;  ## Any TRUE value to enable
     run \@cmd, ">", binary 0, \$out;  ## Any FALSE value to disable
  
  This is a constructor for a "binmode" "filter" that tells IPC::Run to keep
  the carriage returns that would ordinarily be edited out for you (binmode
  is usually off).  This is not a real filter, but an option masquerading as
  a filter.
  
  It's not named "binmode" because you're likely to want to call Perl's binmode
  in programs that are piping binary data around.
  
  =cut
  
  sub binary(;$) {
     my $enable = @_ ? shift : 1;
     return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
  }
  
  =pod
  
  =item new_chunker
  
  This breaks a stream of data in to chunks, based on an optional
  scalar or regular expression parameter.  The default is the Perl
  input record separator in $/, which is a newline be default.
  
     run \@cmd, '>', new_chunker, \&lines_handler;
     run \@cmd, '>', new_chunker( "\r\n" ), \&lines_handler;
  
  Because this uses $/ by default, you should always pass in a parameter
  if you are worried about other code (modules, etc) modifying $/.
  
  If this filter is last in a filter chain that dumps in to a scalar,
  the scalar must be set to '' before a new chunk will be written to it.
  
  As an example of how a filter like this can be written, here's a
  chunker that splits on newlines:
  
     sub line_splitter {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/\A(.*?\n)// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  
  =cut
  
  sub new_chunker(;$) {
     my ( $re ) = @_;
     $re = $/ if _empty $re;
     $re = quotemeta( $re ) unless ref $re eq 'Regexp';
     $re = qr/\A(.*?$re)/s;
  
     return sub {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/$re// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  }
  
  =pod
  
  =item new_appender
  
  This appends a fixed string to each chunk of data read from the source
  scalar or sub.  This might be useful if you're writing commands to a
  child process that always must end in a fixed string, like "\n":
  
     run( \@cmd,
        '<', new_appender( "\n" ), \&commands,
     );
  
  Here's a typical filter sub that might be created by new_appender():
  
     sub newline_appender {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, "\n" );
           $$in_ref = '';
           1;
        }
     };
  
  =cut
  
  sub new_appender($) {
     my ( $suffix ) = @_;
     croak "\$suffix undefined" unless defined $suffix;
  
     return sub {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
           $$in_ref = '';
           1;
        }
     };
  }
  
  =item new_string_source
  
  TODO: Needs confirmation. Was previously undocumented. in this module.
  
  This is a filter which is exportable. Returns a sub which appends the data passed in to the output buffer and returns 1 if data was appended. 0 if it was an empty string and undef if no data was passed. 
  
  NOTE: Any additional variables passed to new_string_source will be passed to the sub every time it's called and appended to the output. 
  
  =cut
  
  
  sub new_string_source {
     my $ref;
     if ( @_ > 1 ) {
        $ref = [ @_ ],
     }
     else {
        $ref = shift;
     }
  
     return ref $ref eq 'SCALAR'
        ? sub {
           my ( $in_ref, $out_ref ) = @_;
  
           return defined $$ref
              ? do {
                 $$out_ref .= $$ref;
                 my $r = length $$ref ? 1 : 0;
                 $$ref = undef;
                 $r;
              }
              : undef
        }
        : sub {
           my ( $in_ref, $out_ref ) = @_;
  
           return @$ref
              ? do {
                 my $s = shift @$ref;
                 $$out_ref .= $s;
                 length $s ? 1 : 0;
              }
              : undef;
        }
  }
  
  =item new_string_sink
  
  TODO: Needs confirmation. Was previously undocumented.
  
  This is a filter which is exportable. Returns a sub which pops the data out of the input stream and pushes it onto the string.
  
  =cut
  
  sub new_string_sink {
     my ( $string_ref ) = @_;
  
     return sub {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$string_ref .= $$in_ref;
           $$in_ref = '';
           1;
        }
     };
  }
  
  
  #=item timeout
  #
  #This function defines a time interval, starting from when start() is
  #called, or when timeout() is called.  If all processes have not finished
  #by the end of the timeout period, then a "process timed out" exception
  #is thrown.
  #
  #The time interval may be passed in seconds, or as an end time in
  #"HH:MM:SS" format (any non-digit other than '.' may be used as
  #spacing and punctuation).  This is probably best shown by example:
  #
  #   $h->timeout( $val );
  #
  #   $val                     Effect
  #   ======================== =====================================
  #   undef                    Timeout timer disabled
  #   ''                       Almost immediate timeout
  #   0                        Almost immediate timeout
  #   0.000001                 timeout > 0.0000001 seconds
  #   30                       timeout > 30 seconds
  #   30.0000001               timeout > 30 seconds
  #   10:30                    timeout > 10 minutes, 30 seconds
  #
  #Timeouts are currently evaluated with a 1 second resolution, though
  #this may change in the future.  This means that setting
  #timeout($h,1) will cause a pokey child to be aborted sometime after
  #one second has elapsed and typically before two seconds have elapsed.
  #
  #This sub does not check whether or not the timeout has expired already.
  #
  #Returns the number of seconds set as the timeout (this does not change
  #as time passes, unless you call timeout( val ) again).
  #
  #The timeout does not include the time needed to fork() or spawn()
  #the child processes, though some setup time for the child processes can
  #included.  It also does not include the length of time it takes for
  #the children to exit after they've closed all their pipes to the
  #parent process.
  #
  #=cut
  #
  #sub timeout {
  #   my IPC::Run $self = shift;
  #
  #   if ( @_ ) {
  #      ( $self->{TIMEOUT} ) = @_;
  #      $self->{TIMEOUT_END} = undef;
  #      if ( defined $self->{TIMEOUT} ) {
  #	 if ( $self->{TIMEOUT} =~ /[^\d.]/ ) {
  #	    my @f = split( /[^\d\.]+/i, $self->{TIMEOUT} );
  #	    unshift @f, 0 while @f < 3;
  #	    $self->{TIMEOUT} = (($f[0]*60)+$f[1])*60+$f[2];
  #	 }
  #	 elsif ( $self->{TIMEOUT} =~ /^(\d*)(?:\.(\d*))/ ) {
  #	    $self->{TIMEOUT} = $1 + 1;
  #	 }
  #	 $self->_calc_timeout_end if $self->{STATE} >= _started;
  #      }
  #   }
  #   return $self->{TIMEOUT};
  #}
  #
  #
  #sub _calc_timeout_end {
  #   my IPC::Run $self = shift;
  #
  #   $self->{TIMEOUT_END} = defined $self->{TIMEOUT} 
  #      ? time + $self->{TIMEOUT}
  #      : undef;
  #
  #   ## We add a second because we might be at the very end of the current
  #   ## second, and we want to guarantee that we don't have a timeout even
  #   ## one second less then the timeout period.
  #   ++$self->{TIMEOUT_END} if $self->{TIMEOUT};
  #}
  
  =pod
  
  =item io
  
  Takes a filename or filehandle, a redirection operator, optional filters,
  and a source or destination (depends on the redirection operator).  Returns
  an IPC::Run::IO object suitable for harness()ing (including via start()
  or run()).
  
  This is shorthand for 
  
  
     require IPC::Run::IO;
  
        ... IPC::Run::IO->new(...) ...
  
  =cut
  
  sub io {
     require IPC::Run::IO;
     IPC::Run::IO->new( @_ );
  }
  
  =pod
  
  =item timer
  
     $h = start( \@cmd, \$in, \$out, $t = timer( 5 ) );
  
     pump $h until $out =~ /expected stuff/ || $t->is_expired;
  
  Instantiates a non-fatal timer.  pump() returns once each time a timer
  expires.  Has no direct effect on run(), but you can pass a subroutine
  to fire when the timer expires. 
  
  See L</timeout> for building timers that throw exceptions on
  expiration.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timer;
  *timer = \&IPC::Run::Timer::timer;
  
  =pod
  
  =item timeout
  
     $h = start( \@cmd, \$in, \$out, $t = timeout( 5 ) );
  
     pump $h until $out =~ /expected stuff/;
  
  Instantiates a timer that throws an exception when it expires.
  If you don't provide an exception, a default exception that matches
  /^IPC::Run: .*timed out/ is thrown by default.  You can pass in your own
  exception scalar or reference:
  
     $h = start(
        \@cmd, \$in, \$out,
        $t = timeout( 5, exception => 'slowpoke' ),
     );
  
  or set the name used in debugging message and in the default exception
  string:
  
     $h = start(
        \@cmd, \$in, \$out,
        timeout( 50, name => 'process timer' ),
        $stall_timer = timeout( 5, name => 'stall timer' ),
     );
  
     pump $h until $out =~ /started/;
  
     $in = 'command 1';
     $stall_timer->start;
     pump $h until $out =~ /command 1 finished/;
  
     $in = 'command 2';
     $stall_timer->start;
     pump $h until $out =~ /command 2 finished/;
  
     $in = 'very slow command 3';
     $stall_timer->start( 10 );
     pump $h until $out =~ /command 3 finished/;
  
     $stall_timer->start( 5 );
     $in = 'command 4';
     pump $h until $out =~ /command 4 finished/;
  
     $stall_timer->reset; # Prevent restarting or expirng
     finish $h;
  
  See L</timer> for building non-fatal timers.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timeout;
  *timeout = \&IPC::Run::Timer::timeout;
  
  =pod
  
  =back
  
  =head1 FILTER IMPLEMENTATION FUNCTIONS
  
  These functions are for use from within filters.
  
  =over
  
  =item input_avail
  
  Returns TRUE if input is available.  If none is available, then 
  &get_more_input is called and its result is returned.
  
  This is usually used in preference to &get_more_input so that the
  calling filter removes all data from the $in_ref before more data
  gets read in to $in_ref.
  
  C<input_avail> is usually used as part of a return expression:
  
     return input_avail && do {
        ## process the input just gotten
        1;
     };
  
  This technique allows input_avail to return the undef or 0 that a
  filter normally returns when there's no input to process.  If a filter
  stores intermediate values, however, it will need to react to an
  undef:
  
     my $got = input_avail;
     if ( ! defined $got ) {
        ## No more input ever, flush internal buffers to $out_ref
     }
     return $got unless $got;
     ## Got some input, move as much as need be
     return 1 if $added_to_out_ref;
  
  =cut
  
  sub input_avail() {
     confess "Undefined FBUF ref for $filter_num+1"
        unless defined $filter_op->{FBUFS}->[$filter_num+1];
     length ${$filter_op->{FBUFS}->[$filter_num+1]} || get_more_input;
  }
  
  =pod
  
  =item get_more_input
  
  This is used to fetch more input in to the input variable.  It returns
  undef if there will never be any more input, 0 if there is none now,
  but there might be in the future, and TRUE if more input was gotten.
  
  C<get_more_input> is usually used as part of a return expression,
  see L</input_avail> for more information.
  
  =cut
  
  ##
  ## Filter implementation interface
  ##
  sub get_more_input() {
     ++$filter_num;
     my $r = eval {
        confess "get_more_input() called and no more filters in chain"
           unless defined $filter_op->{FILTERS}->[$filter_num];
        $filter_op->{FILTERS}->[$filter_num]->(
           $filter_op->{FBUFS}->[$filter_num+1],
           $filter_op->{FBUFS}->[$filter_num],
        ); # if defined ${$filter_op->{FBUFS}->[$filter_num+1]};
     };
     --$filter_num;
     die $@ if $@;
     return $r;
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 TODO
  
  These will be addressed as needed and as time allows.
  
  Stall timeout.
  
  Expose a list of child process objects.  When I do this,
  each child process is likely to be blessed into IPC::Run::Proc.
  
  $kid->abort(), $kid->kill(), $kid->signal( $num_or_name ).
  
  Write tests for /(full_)?results?/ subs.
  
  Currently, pump() and run() only work on systems where select() works on the
  filehandles returned by pipe().  This does *not* include ActiveState on Win32,
  although it does work on cygwin under Win32 (thought the tests whine a bit).
  I'd like to rectify that, suggestions and patches welcome.
  
  Likewise start() only fully works on fork()/exec() machines (well, just
  fork() if you only ever pass perl subs as subprocesses).  There's
  some scaffolding for calling Open3::spawn_with_handles(), but that's
  untested, and not that useful with limited select().
  
  Support for C<\@sub_cmd> as an argument to a command which
  gets replaced with /dev/fd or the name of a temporary file containing foo's
  output.  This is like <(sub_cmd ...) found in bash and csh (IIRC).
  
  Allow multiple harnesses to be combined as independent sets of processes
  in to one 'meta-harness'.
  
  Allow a harness to be passed in place of an \@cmd.  This would allow
  multiple harnesses to be aggregated.
  
  Ability to add external file descriptors w/ filter chains and endpoints.
  
  Ability to add timeouts and timing generators (i.e. repeating timeouts).
  
  High resolution timeouts.
  
  =head1 Win32 LIMITATIONS
  
  =over
  
  =item Fails on Win9X
  
  If you want Win9X support, you'll have to debug it or fund me because I
  don't use that system any more.  The Win32 subsysem has been extended to
  use temporary files in simple run() invocations and these may actually
  work on Win9X too, but I don't have time to work on it.
  
  =item May deadlock on Win2K (but not WinNT4 or WinXPPro)
  
  Spawning more than one subprocess on Win2K causes a deadlock I haven't
  figured out yet, but simple uses of run() often work.  Passes all tests
  on WinXPPro and WinNT.
  
  =item no support yet for <pty< and >pty>
  
  These are likely to be implemented as "<" and ">" with binmode on, not
  sure.
  
  =item no support for file descriptors higher than 2 (stderr)
  
  Win32 only allows passing explicit fds 0, 1, and 2.  If you really, really need to pass file handles, us Win32API:: GetOsFHandle() or ::FdGetOsFHandle() to
  get the integer handle and pass it to the child process using the command
  line, environment, stdin, intermediary file, or other IPC mechanism.  Then
  use that handle in the child (Win32API.pm provides ways to reconstitute
  Perl file handles from Win32 file handles).
  
  =item no support for subroutine subprocesses (CODE refs)
  
  Can't fork(), so the subroutines would have no context, and closures certainly
  have no meaning
  
  Perhaps with Win32 fork() emulation, this can be supported in a limited
  fashion, but there are other very serious problems with that: all parent
  fds get dup()ed in to the thread emulating the forked process, and that
  keeps the parent from being able to close all of the appropriate fds.
  
  =item no support for init => sub {} routines.
  
  Win32 processes are created from scratch, there is no way to do an init
  routine that will affect the running child.  Some limited support might
  be implemented one day, do chdir() and %ENV changes can be made.
  
  =item signals
  
  Win32 does not fully support signals.  signal() is likely to cause errors
  unless sending a signal that Perl emulates, and C<kill_kill()> is immediately
  fatal (there is no grace period).
  
  =item helper processes
  
  IPC::Run uses helper processes, one per redirected file, to adapt between the
  anonymous pipe connected to the child and the TCP socket connected to the
  parent.  This is a waste of resources and will change in the future to either
  use threads (instead of helper processes) or a WaitForMultipleObjects call
  (instead of select).  Please contact me if you can help with the
  WaitForMultipleObjects() approach; I haven't figured out how to get at it
  without C code.
  
  =item shutdown pause
  
  There seems to be a pause of up to 1 second between when a child program exits
  and the corresponding sockets indicate that they are closed in the parent.
  Not sure why.
  
  =item binmode
  
  binmode is not supported yet.  The underpinnings are implemented, just ask
  if you need it.
  
  =item IPC::Run::IO
  
  IPC::Run::IO objects can be used on Unix to read or write arbitrary files.  On
  Win32, they will need to use the same helper processes to adapt from
  non-select()able filehandles to select()able ones (or perhaps
  WaitForMultipleObjects() will work with them, not sure).
  
  =item startup race conditions
  
  There seems to be an occasional race condition between child process startup
  and pipe closings.  It seems like if the child is not fully created by the time
  CreateProcess returns and we close the TCP socket being handed to it, the
  parent socket can also get closed.  This is seen with the Win32 pumper
  applications, not the "real" child process being spawned.
  
  I assume this is because the kernel hasn't gotten around to incrementing the
  reference count on the child's end (since the child was slow in starting), so
  the parent's closing of the child end causes the socket to be closed, thus
  closing the parent socket.
  
  Being a race condition, it's hard to reproduce, but I encountered it while
  testing this code on a drive share to a samba box.  In this case, it takes
  t/run.t a long time to spawn it's chile processes (the parent hangs in the
  first select for several seconds until the child emits any debugging output).
  
  I have not seen it on local drives, and can't reproduce it at will,
  unfortunately.  The symptom is a "bad file descriptor in select()" error, and,
  by turning on debugging, it's possible to see that select() is being called on
  a no longer open file descriptor that was returned from the _socket() routine
  in Win32Helper.  There's a new confess() that checks for this ("PARENT_HANDLE
  no longer open"), but I haven't been able to reproduce it (typically).
  
  =back
  
  =head1 LIMITATIONS
  
  On Unix, requires a system that supports C<waitpid( $pid, WNOHANG )> so
  it can tell if a child process is still running.
  
  PTYs don't seem to be non-blocking on some versions of Solaris. Here's a
  test script contributed by Borislav Deianov <borislav@ensim.com> to see
  if you have the problem.  If it dies, you have the problem.
  
     #!/usr/bin/perl
  
     use IPC::Run qw(run);
     use Fcntl;
     use IO::Pty;
  
     sub makecmd {
         return ['perl', '-e', 
                 '<STDIN>, print "\n" x '.$_[0].'; while(<STDIN>){last if /end/}'];
     }
  
     #pipe R, W;
     #fcntl(W, F_SETFL, O_NONBLOCK);
     #while (syswrite(W, "\n", 1)) { $pipebuf++ };
     #print "pipe buffer size is $pipebuf\n";
     my $pipebuf=4096;
     my $in = "\n" x ($pipebuf * 2) . "end\n";
     my $out;
  
     $SIG{ALRM} = sub { die "Never completed!\n" };
  
     print "reading from scalar via pipe...";
     alarm( 2 );
     run(makecmd($pipebuf * 2), '<', \$in, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     print "reading from code via pipe... ";
     alarm( 2 );
     run(makecmd($pipebuf * 3), '<', sub { $t = $in; undef $in; $t}, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     $pty = IO::Pty->new();
     $pty->blocking(0);
     $slave = $pty->slave();
     while ($pty->syswrite("\n", 1)) { $ptybuf++ };
     print "pty buffer size is $ptybuf\n";
     $in = "\n" x ($ptybuf * 3) . "end\n";
  
     print "reading via pty... ";
     alarm( 2 );
     run(makecmd($ptybuf * 3), '<pty<', \$in, '>', \$out);
     alarm(0);
     print "done\n";
  
  No support for ';', '&&', '||', '{ ... }', etc: use perl's, since run()
  returns TRUE when the command exits with a 0 result code.
  
  Does not provide shell-like string interpolation.
  
  No support for C<cd>, C<setenv>, or C<export>: do these in an init() sub
  
     run(
        \cmd,
           ...
           init => sub {
              chdir $dir or die $!;
              $ENV{FOO}='BAR'
           }
     );
  
  Timeout calculation does not allow absolute times, or specification of
  days, months, etc.
  
  B<WARNING:> Function coprocesses (C<run \&foo, ...>) suffer from two
  limitations.  The first is that it is difficult to close all filehandles the
  child inherits from the parent, since there is no way to scan all open
  FILEHANDLEs in Perl and it both painful and a bit dangerous to close all open
  file descriptors with C<POSIX::close()>. Painful because we can't tell which
  fds are open at the POSIX level, either, so we'd have to scan all possible fds
  and close any that we don't want open (normally C<exec()> closes any
  non-inheritable but we don't C<exec()> for &sub processes.
  
  The second problem is that Perl's DESTROY subs and other on-exit cleanup gets
  run in the child process.  If objects are instantiated in the parent before the
  child is forked, the DESTROY will get run once in the parent and once in
  the child.  When coprocess subs exit, POSIX::exit is called to work around this,
  but it means that objects that are still referred to at that time are not
  cleaned up.  So setting package vars or closure vars to point to objects that
  rely on DESTROY to affect things outside the process (files, etc), will
  lead to bugs.
  
  I goofed on the syntax: "<pipe" vs. "<pty<" and ">filename" are both
  oddities.
  
  =head1 TODO
  
  =over
  
  =item Allow one harness to "adopt" another:
  
     $new_h = harness \@cmd2;
     $h->adopt( $new_h );
  
  =item Close all filehandles not explicitly marked to stay open.
  
  The problem with this one is that there's no good way to scan all open
  FILEHANDLEs in Perl, yet you don't want child processes inheriting handles
  willy-nilly.
  
  =back
  
  =head1 INSPIRATION
  
  Well, select() and waitpid() badly needed wrapping, and open3() isn't
  open-minded enough for me.
  
  The shell-like API inspired by a message Russ Allbery sent to perl5-porters,
  which included:
  
     I've thought for some time that it would be
     nice to have a module that could handle full Bourne shell pipe syntax
     internally, with fork and exec, without ever invoking a shell.  Something
     that you could give things like:
  
     pipeopen (PIPE, [ qw/cat file/ ], '|', [ 'analyze', @args ], '>&3');
  
  Message ylln51p2b6.fsf@windlord.stanford.edu, on 2000/02/04.
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=IPC-Run>
  
  For other issues, contact the maintainer (the first listed author)
  
  =head1 AUTHORS
  
  Adam Kennedy <adamk@cpan.org>
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2008 - 2009 Adam Kennedy.
  
  Copyright 1999 Barrie Slaymaker.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the README file.
  
  =cut
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Debug - debugging routines for IPC::Run
  
  =head1 SYNOPSIS
  
     ##
     ## Environment variable usage
     ##
     ## To force debugging off and shave a bit of CPU and memory
     ## by compile-time optimizing away all debugging code in IPC::Run
     ## (debug => ...) options to IPC::Run will be ignored.
     export IPCRUNDEBUG=none
  
     ## To force debugging on (levels are from 0..10)
     export IPCRUNDEBUG=basic
  
     ## Leave unset or set to "" to compile in debugging support and
     ## allow runtime control of it using the debug option.
  
  =head1 DESCRIPTION
  
  Controls IPC::Run debugging.  Debugging levels are now set by using words,
  but the numbers shown are still supported for backwards compatibility:
  
     0  none         disabled (special, see below)
     1  basic        what's running
     2  data         what's being sent/recieved
     3  details      what's going on in more detail
     4  gory         way too much detail for most uses
     10 all          use this when submitting bug reports
        noopts       optimizations forbidden due to inherited STDIN
  
  The C<none> level is special when the environment variable IPCRUNDEBUG
  is set to this the first time IPC::Run::Debug is loaded: it prevents
  the debugging code from being compiled in to the remaining IPC::Run modules,
  saving a bit of cpu.
  
  To do this in a script, here's a way that allows it to be overridden:
  
     BEGIN {
        unless ( defined $ENV{IPCRUNDEBUG} ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	    or die $@;
        }
     }
  
  This should force IPC::Run to not be debuggable unless somebody sets
  the IPCRUNDEBUG flag; modify this formula to grep @ARGV if need be:
  
     BEGIN {
        unless ( grep /^--debug/, @ARGV ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	 or die $@;
     }
  
  Both of those are untested.
  
  =cut
  
  ## We use @EXPORT for the end user's convenience: there's only one function
  ## exported, it's homonymous with the module, it's an unusual name, and
  ## it can be suppressed by "use IPC::Run ();".
  
  use strict;
  use Exporter;
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
  BEGIN {
  	$VERSION = '0.90';
  	@ISA     = qw( Exporter );
  	@EXPORT  = qw(
  		_debug
  		_debug_desc_fd
  		_debugging
  		_debugging_data
  		_debugging_details
  		_debugging_gory_details
  		_debugging_not_optimized
  		_set_child_debug_name
  	);
  	
  	@EXPORT_OK = qw(
  		_debug_init
  		_debugging_level
  		_map_fds
  	);
  	%EXPORT_TAGS = (
  		default => \@EXPORT,
  		all     => [ @EXPORT, @EXPORT_OK ],
  	);
  }
  
  my $disable_debugging =
     defined $ENV{IPCRUNDEBUG}
     && (
        ! $ENV{IPCRUNDEBUG}
        || lc $ENV{IPCRUNDEBUG} eq "none"
     );
  
  eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX;
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $in_use;
     my $dummy;
     for my $fd (0..63) {
        ## I'd like a quicker way (less user, cpu & expecially sys and kernal
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        ## but that segfaults on Win32
        my $test_fd = POSIX::dup( $fd );
        $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        $map .= $in_use ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to it's own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self ? "#$IPC::Run::cur_self->{ID}" : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
  
  =pod
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>, with numerous suggestions by p5p.
  
  =cut
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_IO';
  package IPC::Run::IO;
  
  =head1 NAME
  
  IPC::Run::IO -- I/O channels for IPC::Run.
  
  =head1 SYNOPSIS
  
  B<NOT IMPLEMENTED YET ON Win32! Win32 does not allow select() on
  normal file descriptors; IPC::RUN::IO needs to use IPC::Run::Win32Helper
  to do this.>
  
     use IPC::Run qw( io );
  
     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv );
     $io = io( "filename", 'r',  \$recv );
  
     ## Append to $recv:
     $io = io( "filename", '>>', \$recv );
     $io = io( "filename", 'ra', \$recv );
  
     $io = io( "filename", '<',  \$send );
     $io = io( "filename", 'w',  \$send );
  
     $io = io( "filename", '<<', \$send );
     $io = io( "filename", 'wa', \$send );
  
     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send );
  
     $f = IO::Handle->new( ... ); # Any subclass of IO::Handle
     $io = io( $f, '<', \$send );
  
     require IPC::Run::IO;
     $io = IPC::Run::IO->new( ... );
  
     ## Then run(), harness(), or start():
     run $io, ...;
  
     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... );
  
  =head1 DESCRIPTION
  
  This class and module allows filehandles and filenames to be harnessed for
  I/O when used IPC::Run, independent of anything else IPC::Run is doing
  (except that errors & exceptions can affect all things that IPC::Run is
  doing).
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: due to the awkwardness introduced in ripping pseudohashes
  out of Perl, this class I<no longer> uses the fields pragma.
  
  =cut
  
  ## This class is also used internally by IPC::Run in a very intimate way,
  ## since this is a partial factoring of code from IPC::Run plus some code
  ## needed to do standalone channels.  This factoring process will continue
  ## at some point.  Don't know how far how fast.
  
  use strict;
  use Carp;
  use Fcntl;
  use Symbol;
  
  use IPC::Run::Debug;
  use IPC::Run qw( Win32_MODE );
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '0.90';
  	if ( Win32_MODE ) {
  		eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
  		or ( $@ && die ) or die "$!";
  	}
  }
  
  sub _empty($);
  *_empty = \&IPC::Run::_empty;
  
  =head1 SUBROUTINES
  
  =over 4
  
  =item new
  
  I think it takes >> or << along with some other data.
  
  TODO: Needs more thorough documentation. Patches welcome.
  
  =cut
  
  sub new {
     my $class = shift;
     $class = ref $class || $class;
  
     my ( $external, $type, $internal ) = ( shift, shift, pop );
  
     croak "$class: '$_' is not a valid I/O operator"
        unless $type =~ /^(?:<<?|>>?)$/;
  
     my IPC::Run::IO $self = $class->_new_internal(
        $type, undef, undef, $internal, undef, @_
     );
  
     if ( ! ref $external ) {
        $self->{FILENAME} = $external;
     }
     elsif ( ref eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
        $self->{HANDLE} = $external;
        $self->{DONT_CLOSE} = 1;
     }
     else {
        croak "$class: cannot accept " . ref( $external ) . " to do I/O with";
     }
  
     return $self;
  }
  
  
  ## IPC::Run uses this ctor, since it preparses things and needs more
  ## smarts.
  sub _new_internal {
     my $class = shift;
     $class = ref $class || $class;
  
     $class = "IPC::Run::Win32IO"
        if Win32_MODE && $class eq "IPC::Run::IO";
  
     my IPC::Run::IO $self;
     $self = bless {}, $class;
  
     my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
  
     # Older perls (<=5.00503, at least) don't do list assign to
     # psuedo-hashes well.
     $self->{TYPE}    = $type;
     $self->{KFD}     = $kfd;
     $self->{PTY_ID}  = $pty_id;
     $self->binmode( $binmode );
     $self->{FILTERS} = [ @filters ];
  
     ## Add an adapter to the end of the filter chain (which is usually just the
     ## read/writer sub pushed by IPC::Run) to the DEST or SOURCE, if need be.
     if ( $self->op =~ />/ ) {
        croak "'$_' missing a destination" if _empty $internal;
        $self->{DEST} = $internal;
        if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
           ## Put a filter on the end of the filter chain to pass the
           ## output on to the CODE ref.  For SCALAR refs, the last
           ## filter in the chain writes directly to the scalar itself.  See
           ## _init_filters().  For CODE refs, however, we need to adapt from
           ## the SCALAR to calling the CODE.
           unshift( 
              @{$self->{FILTERS}},
              sub {
                 my ( $in_ref ) = @_;
  
                 return IPC::Run::input_avail() && do {
          	  $self->{DEST}->( $$in_ref );
          	  $$in_ref = '';
          	  1;
                 }
              }
           );
        }
     }
     else {
        croak "'$_' missing a source" if _empty $internal;
        $self->{SOURCE} = $internal;
        if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
           push(
              @{$self->{FILTERS}},
              sub {
                 my ( $in_ref, $out_ref ) = @_;
                 return 0 if length $$out_ref;
  
                 return undef
          	  if $self->{SOURCE_EMPTY};
  
                 my $in = $internal->();
                 unless ( defined $in ) {
          	  $self->{SOURCE_EMPTY} = 1;
          	  return undef 
                 }
                 return 0 unless length $in;
                 $$out_ref = $in;
  
                 return 1;
              }
           );
        }
        elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
           push(
              @{$self->{FILTERS}},
              sub {
                 my ( $in_ref, $out_ref ) = @_;
                 return 0 if length $$out_ref;
  
                 ## pump() clears auto_close_ins, finish() sets it.
                 return $self->{HARNESS}->{auto_close_ins} ? undef : 0
          	  if IPC::Run::_empty ${$self->{SOURCE}}
          	     || $self->{SOURCE_EMPTY};
  
                 $$out_ref = $$internal;
                 eval { $$internal = '' }
          	  if $self->{HARNESS}->{clear_ins};
  
                 $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
  
                 return 1;
              }
           );
        }
     }
  
     return $self;
  }
  
  =item filename
  
  Gets/sets the filename.  Returns the value after the name change, if
  any.
  
  =cut
  
  sub filename {
     my IPC::Run::IO $self = shift;
     $self->{FILENAME} = shift if @_;
     return $self->{FILENAME};
  }
  
  =item init
  
  Does initialization required before this can be run.  This includes open()ing
  the file, if necessary, and clearing the destination scalar if necessary.
  
  =cut
  
  sub init {
     my IPC::Run::IO $self = shift;
  
     $self->{SOURCE_EMPTY} = 0;
     ${$self->{DEST}} = ''
        if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
  
     $self->open if defined $self->filename;
     $self->{FD} = $self->fileno;
  
     if ( ! $self->{FILTERS} ) {
        $self->{FBUFS} = undef;
     }
     else {
        @{$self->{FBUFS}} = map {
           my $s = "";
           \$s;
        } ( @{$self->{FILTERS}}, '' );
  
        $self->{FBUFS}->[0] = $self->{DEST}
           if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
        push @{$self->{FBUFS}}, $self->{SOURCE};
     }
  
     return undef;
  }
  
  
  =item open
  
  If a filename was passed in, opens it.  Determines if the handle is open
  via fileno().  Throws an exception on error.
  
  =cut
  
  my %open_flags = (
     '>'  => O_RDONLY,
     '>>' => O_RDONLY,
     '<'  => O_WRONLY | O_CREAT | O_TRUNC,
     '<<' => O_WRONLY | O_CREAT | O_APPEND,
  );
  
  sub open {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: Can't open() a file with no name"
        unless defined $self->{FILENAME};
     $self->{HANDLE} = gensym unless $self->{HANDLE};
  
     _debug
        "opening '", $self->filename, "' mode '", $self->mode, "'"
     if _debugging_data;
     sysopen(
        $self->{HANDLE},
        $self->filename,
        $open_flags{$self->op},
     ) or croak
           "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
  
     return undef;
  }
  
  
  =item open_pipe
  
  If this is a redirection IO object, this opens the pipe in a platform
  independent manner.
  
  =cut
  
  sub _do_open {
     my $self = shift;
     my ( $child_debug_fd, $parent_handle ) = @_;
  
  
     if ( $self->dir eq "<" ) {
        ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
        if ( $parent_handle ) {
           CORE::open $parent_handle, ">&=$self->{FD}"
              or croak "$! duping write end of pipe for caller";
        }
     }
     else {
        ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
        if ( $parent_handle ) {
           CORE::open $parent_handle, "<&=$self->{FD}"
              or croak "$! duping read end of pipe for caller";
        }
     }
  }
  
  sub open_pipe {
     my IPC::Run::IO $self = shift;
  
     ## Hmmm, Maybe allow named pipes one day.  But until then...
     croak "IPC::Run::IO: Can't pipe() when a file name has been set"
        if defined $self->{FILENAME};
  
     $self->_do_open( @_ );
  
     ## return ( child_fd, parent_fd )
     return $self->dir eq "<"
        ? ( $self->{TFD}, $self->{FD} )
        : ( $self->{FD}, $self->{TFD} );
  }
  
  
  sub _cleanup { ## Called from Run.pm's _cleanup
     my $self = shift;
     undef $self->{FAKE_PIPE};
  }
  
  
  =item close
  
  Closes the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub close {
     my IPC::Run::IO $self = shift;
  
     if ( defined $self->{HANDLE} ) {
        close $self->{HANDLE}
           or croak(  "IPC::Run::IO: $! closing "
              . ( defined $self->{FILENAME}
                 ? "'$self->{FILENAME}'"
                 : "handle"
              )
           );
     }
     else {
        IPC::Run::_close( $self->{FD} );
     }
  
     $self->{FD} = undef;
  
     return undef;
  }
  
  =item fileno
  
  Returns the fileno of the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub fileno {
     my IPC::Run::IO $self = shift;
  
     my $fd = fileno $self->{HANDLE};
     croak(  "IPC::Run::IO: $! "
           . ( defined $self->{FILENAME}
              ? "'$self->{FILENAME}'"
              : "handle"
           )
        ) unless defined $fd;
  
     return $fd;
  }
  
  =item mode
  
  Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
  'ra', unlike Perl's open(), which indicates that data read from the
  handle or file will be appended to the output if the output is a scalar.
  This is only meaningful if the output is a scalar, it has no effect if
  the output is a subroutine.
  
  The redirection operators can be a little confusing, so here's a reference
  table:
  
     >      r      Read from handle in to process
     <      w      Write from process out to handle
     >>     ra     Read from handle in to process, appending it to existing
                   data if the destination is a scalar.
     <<     wa     Write from process out to handle, appending to existing
                   data if IPC::Run::IO opened a named file.
  
  =cut
  
  sub mode {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
  
     ## TODO: Optimize this
     return ( $self->{TYPE} =~ /</     ? 'w' : 'r' ) . 
            ( $self->{TYPE} =~ /<<|>>/ ? 'a' : ''  );
  }
  
  
  =item op
  
  Returns the operation: '<', '>', '<<', '>>'.  See L</mode> if you want
  to spell these 'r', 'w', etc.
  
  =cut
  
  sub op {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
  
     return $self->{TYPE};
  }
  
  =item binmode
  
  Sets/gets whether this pipe is in binmode or not.  No effect off of Win32
  OSs, of course, and on Win32, no effect after the harness is start()ed.
  
  =cut
  
  sub binmode {
     my IPC::Run::IO $self = shift;
  
     $self->{BINMODE} = shift if @_;
  
     return $self->{BINMODE};
  }
  
  
  =item dir
  
  Returns the first character of $self->op.  This is either "<" or ">".
  
  =cut
  
  sub dir {
     my IPC::Run::IO $self = shift;
  
     croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
  
     return substr $self->{TYPE}, 0, 1;
  }
  
  
  ##
  ## Filter Scaffolding
  ##
  #my $filter_op ;        ## The op running a filter chain right now
  #my $filter_num;        ## Which filter is being run right now.
  
  use vars (
  '$filter_op',        ## The op running a filter chain right now
  '$filter_num'        ## Which filter is being run right now.
  );
  
  sub _init_filters {
     my IPC::Run::IO $self = shift;
  
  confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
     $self->{FBUFS} = [];
  
     $self->{FBUFS}->[0] = $self->{DEST}
        if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
  
     return unless $self->{FILTERS} && @{$self->{FILTERS}};
  
     push @{$self->{FBUFS}}, map {
        my $s = "";
        \$s;
     } ( @{$self->{FILTERS}}, '' );
  
     push @{$self->{FBUFS}}, $self->{SOURCE};
  }
  
  =item poll
  
  TODO: Needs confirmation that this is correct. Was previously undocumented.
  
  I believe this is polling the IO for new input and then returns undef if there will never be any more input, 0 if there is none now, but there might be in the future, and TRUE if more input was gotten.
  
  =cut
  
  sub poll {
     my IPC::Run::IO $self = shift;
     my ( $harness ) = @_;
  
     if ( defined $self->{FD} ) {
        my $d = $self->dir;
        if ( $d eq "<" ) {
           if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
              _debug_desc_fd( "filtering data to", $self )
                 if _debugging_details;
              return $self->_do_filters( $harness );
           }
        }
        elsif ( $d eq ">" ) {
           if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
              _debug_desc_fd( "filtering data from", $self )
                 if _debugging_details;
              return $self->_do_filters( $harness );
           }
        }
     }
     return 0;
  }
  
  
  sub _do_filters {
     my IPC::Run::IO $self = shift;
  
     ( $self->{HARNESS} ) = @_;
  
     my ( $saved_op, $saved_num ) =($IPC::Run::filter_op,$IPC::Run::filter_num);
     $IPC::Run::filter_op = $self;
     $IPC::Run::filter_num = -1;
     my $redos = 0;
     my $r;
     {
  	   $@ = '';
  	   $r = eval { IPC::Run::get_more_input(); };
  
  	   # Detect Resource temporarily unavailable and re-try 200 times (2 seconds),  assuming select behaves (which it doesn't always? need ref)
  	   if(($@||'') =~ $IPC::Run::_EAGAIN && $redos++ < 200) {
  	       select(undef, undef, undef, 0.01);
  	       redo;
  	   }
     }
     ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
     $self->{HARNESS} = undef;
     die "ack ", $@ if $@;
     return $r;
  }
  
  =back
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 TODO
  
  Implement bidirectionality.
  
  =cut
  
  1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_TIMER';
  package IPC::Run::Timer;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Timer -- Timer channels for IPC::Run.
  
  =head1 SYNOPSIS
  
     use IPC::Run qw( run  timer timeout );
     ## or IPC::Run::Timer ( timer timeout );
     ## or IPC::Run::Timer ( :all );
  
     ## A non-fatal timer:
     $t = timer( 5 ); # or...
     $t = IO::Run::Timer->new( 5 );
     run $t, ...;
  
     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ); # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" );
  
  =head1 DESCRIPTION
  
  This class and module allows timers and timeouts to be created for use
  by IPC::Run.  A timer simply expires when it's time is up.  A timeout
  is a timer that throws an exception when it expires.
  
  Timeouts are usually a bit simpler to use  than timers: they throw an
  exception on expiration so you don't need to check them:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/;
  
  You do need to check timers:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $t->is_expired || $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired;
  
  Timers and timeouts that are reset get started by start() and
  pump().  Timers change state only in pump().  Since run() and
  finish() both call pump(), they act like pump() with respect to
  timers.
  
  Timers and timeouts have three states: reset, running, and expired.
  Setting the timeout value resets the timer, as does calling
  the reset() method.  The start() method starts (or restarts) a
  timer with the most recently set time value, no matter what state
  it's in.
  
  =head2 Time values
  
  All time values are in seconds.  Times may be specified as integer or
  floating point seconds, optionally preceded by puncuation-separated
  days, hours, and minutes.\
  
  Examples:
  
     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds
  
  Absolute date/time strings are *not* accepted: year, month and
  day-of-month parsing is not available (patches welcome :-).
  
  =head2 Interval fudging
  
  When calculating an end time from a start time and an interval, IPC::Run::Timer
  instances add a little fudge factor.  This is to ensure that no time will
  expire before the interval is up.
  
  First a little background.  Time is sampled in discrete increments.  We'll
  call the
  exact moment that the reported time increments from one interval to the
  next a tick, and the interval between ticks as the time period.  Here's
  a diagram of three ticks and the periods between them:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                   ^                   ^
      |<--- period 0 ---->|<--- period 1 ---->|
      |                   |                   |
    tick 0              tick 1              tick 2
  
  To see why the fudge factor is necessary, consider what would happen
  when a timer with an interval of 1 second is started right at the end of
  period 0:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^                   ^
      |                |  |                   |
      |                |  |                   |
    tick 0             |tick 1              tick 2
                       |
                   start $t
  
  Assuming that check() is called many times per period, then the timer
  is likely to expire just after tick 1, since the time reported will have
  lept from the value '0' to the value '1':
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^   ^               ^
      |                |  |   |               |
      |                |  |   |               |
    tick 0             |tick 1|             tick 2
                       |      |
                   start $t   |
  		            |
  			check $t
  
  Adding a fudge of '1' in this example means that the timer is guaranteed
  not to expire before tick 2.
  
  The fudge is not added to an interval of '0'.
  
  This means that intervals guarantee a minimum interval.  Given that
  the process running perl may be suspended for some period of time, or that
  it gets busy doing something time-consuming, there are no other guarantees on
  how long it will take a timer to expire.
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: Due to the awkwardness introduced by ripping
  pseudohashes out of Perl, this class I<no longer> uses the fields
  pragma.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use Carp;
  use Fcntl;
  use Symbol;
  use Exporter;
  use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
  BEGIN {
  	$VERSION   = '0.90';
  	@ISA       = qw( Exporter );
  	@EXPORT_OK = qw(
  		check
  		end_time
  		exception
  		expire
  		interval
  		is_expired
  		is_reset
  		is_running
  		name
  		reset
  		start
  		timeout
  		timer
  	);
  
  	%EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  }
  
  require IPC::Run;
  use IPC::Run::Debug;
  
  ##
  ## Some helpers
  ##
  my $resolution = 1;
  
  sub _parse_time {
     for ( $_[0] ) {
        return $_ unless defined $_;
        return $_ if /^\d*(?:\.\d*)?$/;
  
        my @f = reverse split( /[^\d\.]+/i );
        croak "IPC::Run: invalid time string '$_'" unless @f <= 4;
        my ( $s, $m, $h, $d ) = @f;
        return
        ( (
  	         ( $d || 0 )   * 24
  	       + ( $h || 0 ) ) * 60
  	       + ( $m || 0 ) ) * 60
                 + ( $s || 0 );
     }
  }
  
  sub _calc_end_time {
     my IPC::Run::Timer $self = shift;
     my $interval = $self->interval;
     $interval += $resolution if $interval;
     $self->end_time( $self->start_time + $interval );
  }
  
  
  =item timer
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timer( 5 );
     $t = timer( 5, name => 'stall timer', debug => 1 );
  
     $t = timer;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timer( 5 );
  
  This convenience function is a shortened spelling of
  
     IPC::Run::Timer->new( ... );
     
  .  It returns a timer in the reset state with a given interval.
  
  If an exception is provided, it will be thrown when the timer notices that
  it has expired (in check()).  The name is for debugging usage, if you plan on
  having multiple timers around.  If no name is provided, a name like "timer #1"
  will be provided.
  
  =cut
  
  sub timer {
     return IPC::Run::Timer->new( @_ );
  }
  
  
  =item timeout
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timeout( 5 );
     $t = timeout( 5, exception => "kablooey" );
     $t = timeout( 5, name => "stall", exception => "kablooey" );
  
     $t = timeout;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timeout( 5 );
  
  A This convenience function is a shortened spelling of 
  
     IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... );
     
  .  It returns a timer in the reset state that will throw an
  exception when it expires.
  
  Takes the same parameters as L</timer>, any exception passed in overrides
  the default exception.
  
  =cut
  
  sub timeout {
     my $t = IPC::Run::Timer->new( @_ );
     $t->exception( "IPC::Run: timeout on " . $t->name )
        unless defined $t->exception;
     return $t;
  }
  
  
  =item new
  
     IPC::Run::Timer->new()  ;
     IPC::Run::Timer->new( 5 )  ;
     IPC::Run::Timer->new( 5, exception => 'kablooey' )  ;
  
  Constructor.  See L</timer> for details.
  
  =cut
  
  my $timer_counter;
  
  
  sub new {
     my $class = shift;
     $class = ref $class || $class;
  
     my IPC::Run::Timer $self = bless {}, $class;
  
     $self->{STATE} = 0;
     $self->{DEBUG} = 0;
     $self->{NAME}  = "timer #" . ++$timer_counter;
  
     while ( @_ ) {
        my $arg = shift;
        if ( $arg =~ /^(?:\d+[^\a\d]){0,3}\d*(?:\.\d*)?$/ ) {
           $self->interval( $arg );
        }
        elsif ( $arg eq 'exception' ) {
           $self->exception( shift );
        }
        elsif ( $arg eq 'name' ) {
           $self->name( shift );
        }
        elsif ( $arg eq 'debug' ) {
           $self->debug( shift );
        }
        else {
           croak "IPC::Run: unexpected parameter '$arg'";
        }
     }
  
     _debug $self->name . ' constructed'
        if $self->{DEBUG} || _debugging_details;
  
     return $self;
  }
  
  =item check
  
     check $t;
     check $t, $now;
     $t->check;
  
  Checks to see if a timer has expired since the last check.  Has no effect
  on non-running timers.  This will throw an exception if one is defined.
  
  IPC::Run::pump() calls this routine for any timers in the harness.
  
  You may pass in a version of now, which is useful in case you have
  it lying around or you want to check several timers with a consistent
  concept of the current time.
  
  Returns the time left before end_time or 0 if end_time is no longer
  in the future or the timer is not running
  (unless, of course, check() expire()s the timer and this
  results in an exception being thrown).
  
  Returns undef if the timer is not running on entry, 0 if check() expires it,
  and the time left if it's left running.
  
  =cut
  
  sub check {
     my IPC::Run::Timer $self = shift;
     return undef if ! $self->is_running;
     return 0     if  $self->is_expired;
  
     my ( $now ) = @_;
     $now = _parse_time( $now );
     $now = time unless defined $now;
  
     _debug(
        "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now 
     ) if $self->{DEBUG} || _debugging_details;
  
     my $left = $self->end_time - $now;
     return $left if $left > 0;
  
     $self->expire;
     return 0;
  }
  
  
  =item debug
  
  Sets/gets the current setting of the debugging flag for this timer.  This
  has no effect if debugging is not enabled for the current harness.
  
  =cut
  
  
  sub debug {
     my IPC::Run::Timer $self = shift;
     $self->{DEBUG} = shift if @_;
     return $self->{DEBUG};
  }
  
  
  =item end_time
  
     $et = $t->end_time;
     $et = end_time $t;
  
     $t->end_time( time + 10 );
  
  Returns the time when this timer will or did expire.  Even if this time is
  in the past, the timer may not be expired, since check() may not have been
  called yet.
  
  Note that this end_time is not start_time($t) + interval($t), since some
  small extra amount of time is added to make sure that the timer does not
  expire before interval() elapses.  If this were not so, then 
  
  Changing end_time() while a timer is running will set the expiration time.
  Changing it while it is expired has no affect, since reset()ing a timer always
  clears the end_time().
  
  =cut
  
  
  sub end_time {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{END_TIME} = shift;
        _debug $self->name, ' end_time set to ', $self->{END_TIME}
  	 if $self->{DEBUG} > 2 || _debugging_details;
     }
     return $self->{END_TIME};
  }
  
  
  =item exception
  
     $x = $t->exception;
     $t->exception( $x );
     $t->exception( undef );
  
  Sets/gets the exception to throw, if any.  'undef' means that no
  exception will be thrown.  Exception does not need to be a scalar: you 
  may ask that references be thrown.
  
  =cut
  
  
  sub exception {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{EXCEPTION} = shift;
        _debug $self->name, ' exception set to ', $self->{EXCEPTION}
  	 if $self->{DEBUG} || _debugging_details;
     }
     return $self->{EXCEPTION};
  }
  
  
  =item interval
  
     $i = interval $t;
     $i = $t->interval;
     $t->interval( $i );
  
  Sets the interval.  Sets the end time based on the start_time() and the
  interval (and a little fudge) if the timer is running.
  
  =cut
  
  sub interval {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{INTERVAL} = _parse_time( shift );
        _debug $self->name, ' interval set to ', $self->{INTERVAL}
  	 if $self->{DEBUG} > 2 || _debugging_details;
  
        $self->_calc_end_time if $self->state;
     }
     return $self->{INTERVAL};
  }
  
  
  =item expire
  
     expire $t;
     $t->expire;
  
  Sets the state to expired (undef).
  Will throw an exception if one
  is defined and the timer was not already expired.  You can expire a
  reset timer without starting it.
  
  =cut
  
  
  sub expire {
     my IPC::Run::Timer $self = shift;
     if ( defined $self->state ) {
        _debug $self->name . ' expired'
  	 if $self->{DEBUG} || _debugging;
  
        $self->state( undef );
        croak $self->exception if $self->exception;
     }
     return undef;
  }
  
  
  =item is_running
  
  =cut
  
  
  sub is_running {
     my IPC::Run::Timer $self = shift;
     return $self->state ? 1 : 0;
  }
  
  
  =item is_reset
  
  =cut
     
  sub is_reset {
     my IPC::Run::Timer $self = shift;
     return defined $self->state && $self->state == 0;
  }
  
  
  =item is_expired
  
  =cut
  
  sub is_expired {
     my IPC::Run::Timer $self = shift;
     return ! defined $self->state;
  }
  
  =item name
  
  Sets/gets this timer's name.  The name is only used for debugging
  purposes so you can tell which freakin' timer is doing what.
  
  =cut
  
  sub name {
     my IPC::Run::Timer $self = shift;
   
     $self->{NAME} = shift if @_;
     return defined $self->{NAME}
        ? $self->{NAME}
        : defined $self->{EXCEPTION}
           ? 'timeout'
  	 : 'timer';
  }
  
  
  =item reset
  
     reset $t;
     $t->reset;
  
  Resets the timer to the non-running, non-expired state and clears
  the end_time().
  
  =cut
  
  sub reset {
     my IPC::Run::Timer $self = shift;
     $self->state( 0 );
     $self->end_time( undef );
     _debug $self->name . ' reset'
        if $self->{DEBUG} || _debugging;
  
     return undef;
  }
  
  
  =item start
  
     start $t;
     $t->start;
     start $t, $interval;
     start $t, $interval, $now;
  
  Starts or restarts a timer.  This always sets the start_time.  It sets the
  end_time based on the interval if the timer is running or if no end time
  has been set.
  
  You may pass an optional interval or current time value.
  
  Not passing a defined interval causes the previous interval setting to be
  re-used unless the timer is reset and an end_time has been set
  (an exception is thrown if no interval has been set).  
  
  Not passing a defined current time value causes the current time to be used.
  
  Passing a current time value is useful if you happen to have a time value
  lying around or if you want to make sure that several timers are started
  with the same concept of start time.  You might even need to lie to an
  IPC::Run::Timer, occasionally.
  
  =cut
  
  sub start {
     my IPC::Run::Timer $self = shift;
  
     my ( $interval, $now ) = map { _parse_time( $_ ) } @_;
     $now = _parse_time( $now );
     $now = time unless defined $now;
  
     $self->interval( $interval ) if defined $interval;
  
     ## start()ing a running or expired timer clears the end_time, so that the
     ## interval is used.  So does specifying an interval.
     $self->end_time( undef ) if ! $self->is_reset || $interval;
  
     croak "IPC::Run: no timer interval or end_time defined for " . $self->name
        unless defined $self->interval || defined $self->end_time;
  
     $self->state( 1 );
     $self->start_time( $now );
     ## The "+ 1" is in case the START_TIME was sampled at the end of a
     ## tick (which are one second long in this module).
     $self->_calc_end_time
        unless defined $self->end_time;
  
     _debug(
        $self->name, " started at ", $self->start_time,
        ", with interval ", $self->interval, ", end_time ", $self->end_time
     ) if $self->{DEBUG} || _debugging;
     return undef;
  }
  
  
  =item start_time
  
  Sets/gets the start time, in seconds since the epoch.  Setting this manually
  is a bad idea, it's better to call L</start>() at the correct time.
  
  =cut
  
  
  sub start_time {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{START_TIME} = _parse_time( shift );
        _debug $self->name, ' start_time set to ', $self->{START_TIME}
  	 if $self->{DEBUG} > 2 || _debugging;
     }
  
     return $self->{START_TIME};
  }
  
  
  =item state
  
     $s = state $t;
     $t->state( $s );
  
  Get/Set the current state.  Only use this if you really need to transfer the
  state to/from some variable.
  Use L</expire>, L</start>, L</reset>, L</is_expired>, L</is_running>,
  L</is_reset>.
  
  Note:  Setting the state to 'undef' to expire a timer will not throw an
  exception.
  
  =back
  
  =cut
  
  sub state {
     my IPC::Run::Timer $self = shift;
     if ( @_ ) {
        $self->{STATE} = shift;
        _debug $self->name, ' state set to ', $self->{STATE}
  	 if $self->{DEBUG} > 2 || _debugging;
     }
     return $self->{STATE};
  }
  
  
  1;
  
  =pod
  
  =head1 TODO
  
  use Time::HiRes; if it's present.
  
  Add detection and parsing of [[[HH:]MM:]SS formatted times and intervals.
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =cut
IPC_RUN_TIMER

$fatpacked{"IPC/Run/Win32Helper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32HELPER';
  package IPC::Run::Win32Helper;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Helper - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32Helper;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select() loop
  will work on Win32. This seems to only work on WinNT and Win2K at this time, not
  sure if it will ever work on Win95 or Win98. If you have experience in this area, please
  contact me at barries@slaysys.com, thanks!.
  
  =cut
  
  use strict;
  use Carp;
  use IO::Handle;
  use vars qw{ $VERSION @ISA @EXPORT };
  BEGIN {
  	$VERSION = '0.90';
  	@ISA = qw( Exporter );
  	@EXPORT = qw(
  		win32_spawn
  		win32_parse_cmd_line
  		_dont_inherit
  		_inherit
  	);
  }
  
  require POSIX;
  
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug;
  use Win32API::File qw(
     FdGetOsFHandle
     SetHandleInformation
     HANDLE_FLAG_INHERIT
     INVALID_HANDLE_VALUE
  );
  
  ## Takes an fd or a GLOB ref, never never never a Win32 handle.
  sub _dont_inherit {
     for ( @_ ) {
        next unless defined $_;
        my $fd = $_;
        $fd = fileno $fd if ref $fd;
        _debug "disabling inheritance of ", $fd if _debugging_details;
        my $osfh = FdGetOsFHandle $fd;
        croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  
        SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
     }
  }
  
  sub _inherit {       #### REMOVE
     for ( @_ ) {       #### REMOVE
        next unless defined $_;       #### REMOVE
        my $fd = $_;       #### REMOVE
        $fd = fileno $fd if ref $fd;       #### REMOVE
        _debug "enabling inheritance of ", $fd if _debugging_details;       #### REMOVE
        my $osfh = FdGetOsFHandle $fd;       #### REMOVE
        croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;       #### REMOVE
         #### REMOVE
        SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );       #### REMOVE
     }       #### REMOVE
  }       #### REMOVE
         #### REMOVE
  #sub _inherit {
  #   for ( @_ ) {
  #      next unless defined $_;
  #      my $osfh = GetOsFHandle $_;
  #      croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  #      SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT );
  #   }
  #}
  
  =pod
  
  =head1 FUNCTIONS
  
  =over
  
  =item optimize()
  
  Most common incantations of C<run()> (I<not> C<harness()>, C<start()>,
  or C<finish()>) now use temporary files to redirect input and output
  instead of pumper processes.
  
  Temporary files are used when sending to child processes if input is
  taken from a scalar with no filter subroutines.  This is the only time
  we can assume that the parent is not interacting with the child's
  redirected input as it runs.
  
  Temporary files are used when receiving from children when output is
  to a scalar or subroutine with or without filters, but only if
  the child in question closes its inputs or takes input from 
  unfiltered SCALARs or named files.  Normally, a child inherits its STDIN
  from its parent; to close it, use "0<&-" or the C<< noinherit => 1 >> option.
  If data is sent to the child from CODE refs, filehandles or from
  scalars through filters than the child's outputs will not be optimized
  because C<optimize()> assumes the parent is interacting with the child.
  It is ok if the output is filtered or handled by a subroutine, however.
  
  This assumes that all named files are real files (as opposed to named
  pipes) and won't change; and that a process is not communicating with
  the child indirectly (through means not visible to IPC::Run).
  These can be an invalid assumptions, but are the 99% case.
  Write me if you need an option to enable or disable optimizations; I
  suspect it will work like the C<binary()> modifier.
  
  To detect cases that you might want to optimize by closing inputs, try
  setting the C<IPCRUNDEBUG> environment variable to the special C<notopt>
  value:
  
     C:> set IPCRUNDEBUG=notopt
     C:> my_app_that_uses_IPC_Run.pl
  
  =item optimizer() rationalizations
  
  Only for that limited case can we be sure that it's ok to batch all the
  input in to a temporary file.  If STDIN is from a SCALAR or from a named
  file or filehandle (again, only in C<run()>), then outputs to CODE refs
  are also assumed to be safe enough to batch through a temp file,
  otherwise only outputs to SCALAR refs are batched.  This can cause a bit
  of grief if the parent process benefits from or relies on a bit of
  "early returns" coming in before the child program exits.  As long as
  the output is redirected to a SCALAR ref, this will not be visible.
  When output is redirected to a subroutine or (deprecated) filters, the
  subroutine will not get any data until after the child process exits,
  and it is likely to get bigger chunks of data at once.
  
  The reason for the optimization is that, without it, "pumper" processes
  are used to overcome the inconsistencies of the Win32 API.  We need to
  use anonymous pipes to connect to the child processes' stdin, stdout,
  and stderr, yet select() does not work on these.  select() only works on
  sockets on Win32.  So for each redirected child handle, there is
  normally a "pumper" process that connects to the parent using a
  socket--so the parent can select() on that fd--and to the child on an
  anonymous pipe--so the child can read/write a pipe.
  
  Using a socket to connect directly to the child (as at least one MSDN
  article suggests) seems to cause the trailing output from most children
  to be lost.  I think this is because child processes rarely close their
  stdout and stderr explicitly, and the winsock dll does not seem to flush
  output when a process that uses it exits without explicitly closing
  them.
  
  Because of these pumpers and the inherent slowness of Win32
  CreateProcess(), child processes with redirects are quite slow to
  launch; so this routine looks for the very common case of
  reading/writing to/from scalar references in a run() routine and
  converts such reads and writes in to temporary file reads and writes.
  
  Such files are marked as FILE_ATTRIBUTE_TEMPORARY to increase speed and
  as FILE_FLAG_DELETE_ON_CLOSE so it will be cleaned up when the child
  process exits (for input files).  The user's default permissions are
  used for both the temporary files and the directory that contains them,
  hope your Win32 permissions are secure enough for you.  Files are
  created with the Win32API::File defaults of
  FILE_SHARE_READ|FILE_SHARE_WRITE.
  
  Setting the debug level to "details" or "gory" will give detailed
  information about the optimization process; setting it to "basic" or
  higher will tell whether or not a given call is optimized.  Setting
  it to "notopt" will highlight those calls that aren't optimized.
  
  =cut
  
  sub optimize {
     my ( $h ) = @_;
  
     my @kids = @{$h->{KIDS}};
  
     my $saw_pipe;
  
     my ( $ok_to_optimize_outputs, $veto_output_optimization );
  
     for my $kid ( @kids ) {
        ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
           unless $saw_pipe;
  
        _debug
           "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
           if _debugging_details && $ok_to_optimize_outputs;
        _debug
           "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
           if _debugging_details && $veto_output_optimization;
  
        if ( $h->{noinherit} && ! $ok_to_optimize_outputs ) {
  	 _debug
  	    "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
  	    if _debugging_details && $ok_to_optimize_outputs;
  	 $ok_to_optimize_outputs = 1;
        }
  
        for ( @{$kid->{OPS}} ) {
           if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
              if ( $_->{TYPE} eq "<" ) {
  	       if ( @{$_->{FILTERS}} > 1 ) {
  		  ## Can't assume that the filters are idempotent.
  	       }
                 elsif ( ref $_->{SOURCE} eq "SCALAR"
  	          || ref $_->{SOURCE} eq "GLOB"
  		  || UNIVERSAL::isa( $_, "IO::Handle" )
  	       ) {
                    if ( $_->{KFD} == 0 ) {
                       _debug
                          "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
                          ref $_->{SOURCE},
                          ", ok to optimize outputs"
                          if _debugging_details;
                       $ok_to_optimize_outputs = 1;
                    }
                    $_->{SEND_THROUGH_TEMP_FILE} = 1;
                    next;
                 }
                 elsif ( ! ref $_->{SOURCE} && defined $_->{SOURCE} ) {
                    if ( $_->{KFD} == 0 ) {
                       _debug
                          "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
                          if _debugging_details;
                       $ok_to_optimize_outputs = 1;
                    }
                    next;
                 }
              }
              _debug
                 "Win32 optimizer: (kid $kid->{NUM}) ",
                 $_->{KFD},
                 $_->{TYPE},
                 defined $_->{SOURCE}
                    ? ref $_->{SOURCE}      ? ref $_->{SOURCE}
                                            : $_->{SOURCE}
                    : defined $_->{FILENAME}
                                            ? $_->{FILENAME}
                                            : "",
  	       @{$_->{FILTERS}} > 1 ? " with filters" : (),
                 ", VETOING output opt."
                 if _debugging_details || _debugging_not_optimized;
              $veto_output_optimization = 1;
           }
           elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
              $ok_to_optimize_outputs = 1;
              _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
                 if _debugging_details;
           }
           elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
              $veto_output_optimization = 1;
              _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
                 if _debugging_details || _debugging_not_optimized;
           }
           elsif ( $_->{TYPE} eq "|" ) {
              $saw_pipe = 1;
           }
        }
  
        if ( ! $ok_to_optimize_outputs && ! $veto_output_optimization ) {
           _debug
              "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
              if _debugging_details || _debugging_not_optimized;
           $veto_output_optimization = 1;
        }
  
        if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
           $ok_to_optimize_outputs = 0;
           _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
              if _debugging_details || _debugging_not_optimized;
        }
  
        ## SOURCE/DEST ARRAY means it's a filter.
        ## TODO: think about checking to see if the final input/output of
        ## a filter chain (an ARRAY SOURCE or DEST) is a scalar...but
        ## we may be deprecating filters.
  
        for ( @{$kid->{OPS}} ) {
           if ( $_->{TYPE} eq ">" ) {
              if ( ref $_->{DEST} eq "SCALAR"
                 || (
                    ( @{$_->{FILTERS}} > 1
  		     || ref $_->{DEST} eq "CODE"
  		     || ref $_->{DEST} eq "ARRAY"  ## Filters?
  	          )
                    && ( $ok_to_optimize_outputs && ! $veto_output_optimization ) 
                 )
              ) {
  	       $_->{RECV_THROUGH_TEMP_FILE} = 1;
  	       next;
              }
  	    _debug
  	       "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
  	       $_->{KFD},
  	       $_->{TYPE},
  	       defined $_->{DEST}
  		  ? ref $_->{DEST}      ? ref $_->{DEST}
  					  : $_->{SOURCE}
  		  : defined $_->{FILENAME}
  					  ? $_->{FILENAME}
  					  : "",
  		  @{$_->{FILTERS}} ? " with filters" : (),
  	       if _debugging_details;
           }
        }
     }
  
  }
  
  =pod
  
  =item win32_parse_cmd_line
  
     @words = win32_parse_cmd_line( q{foo bar 'baz baz' "bat bat"} );
  
  returns 4 words. This parses like the bourne shell (see
  the bit about shellwords() in L<Text::ParseWords>), assuming we're
  trying to be a little cross-platform here.  The only difference is
  that "\" is *not* treated as an escape except when it precedes 
  punctuation, since it's used all over the place in DOS path specs.
  
  TODO: globbing? probably not (it's unDOSish).
  
  TODO: shebang emulation? Probably, but perhaps that should be part
  of Run.pm so all spawned processes get the benefit.
  
  LIMITATIONS: shellwords dies silently on malformed input like 
  
     a\"
  
  =cut
  
  sub win32_parse_cmd_line {
     my $line = shift;
     $line =~ s{(\\[\w\s])}{\\$1}g;
     return shellwords $line;
  }
  
  =pod
  
  =item win32_spawn
  
  Spawns a child process, possibly with STDIN, STDOUT, and STDERR (file descriptors 0, 1, and 2, respectively) redirected.
  
  B<LIMITATIONS>.
  
  Cannot redirect higher file descriptors due to lack of support for this in the
  Win32 environment.
  
  This can be worked around by marking a handle as inheritable in the
  parent (or leaving it marked; this is the default in perl), obtaining it's
  Win32 handle with C<Win32API::GetOSFHandle(FH)> or
  C<Win32API::FdGetOsFHandle($fd)> and passing it to the child using the command
  line, the environment, or any other IPC mechanism (it's a plain old integer).
  The child can then use C<OsFHandleOpen()> or C<OsFHandleOpenFd()> and possibly
  C<<open FOO ">&BAR">> or C<<open FOO ">&$fd>> as need be.  Ach, the pain!
  
  Remember to check the Win32 handle against INVALID_HANDLE_VALUE.
  
  =cut
  
  sub _save {
     my ( $saved, $saved_as, $fd ) = @_;
  
     ## We can only save aside the original fds once.
     return if exists $saved->{$fd};
  
     my $saved_fd = IPC::Run::_dup( $fd );
     _dont_inherit $saved_fd;
  
     $saved->{$fd} = $saved_fd;
     $saved_as->{$saved_fd} = $fd;
  
     _dont_inherit $saved->{$fd};
  }
  
  sub _dup2_gently {
     my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
     _save $saved, $saved_as, $fd2;
  
     if ( exists $saved_as->{$fd2} ) {
        ## The target fd is colliding with a saved-as fd, gotta bump
        ## the saved-as fd to another fd.
        my $orig_fd = delete $saved_as->{$fd2};
        my $saved_fd = IPC::Run::_dup( $fd2 );
        _dont_inherit $saved_fd;
  
        $saved->{$orig_fd} = $saved_fd;
        $saved_as->{$saved_fd} = $orig_fd;
     }
     _debug "moving $fd1 to kid's $fd2" if _debugging_details;
     IPC::Run::_dup2_rudely( $fd1, $fd2 );
  }
  
  sub win32_spawn {
     my ( $cmd, $ops) = @_;
  
     ## NOTE: The debug pipe write handle is passed to pump processes as STDOUT.
     ## and is not to the "real" child process, since they would not know
     ## what to do with it...unlike Unix, we have no code executing in the
     ## child before the "real" child is exec()ed.
     
     my %saved;      ## Map of parent's orig fd -> saved fd
     my %saved_as;   ## Map of parent's saved fd -> orig fd, used to
                      ## detect collisions between a KFD and the fd a
  		    ## parent's fd happened to be saved to.
     
     for my $op ( @$ops ) {
        _dont_inherit $op->{FD}  if defined $op->{FD};
  
        if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
  	 ## TODO: Detect this in harness()
  	 ## TODO: enable temporary redirections if ever necessary, not
  	 ## sure why they would be...
  	 ## 4>&1 1>/dev/null 1>&4 4>&-
           croak "Can't redirect fd #", $op->{KFD}, " on Win32";
        }
  
        ## This is very similar logic to IPC::Run::_do_kid_and_exit().
        if ( defined $op->{TFD} ) {
  	 unless ( $op->{TFD} == $op->{KFD} ) {
  	    _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
  	    _dont_inherit $op->{TFD};
  	 }
        }
        elsif ( $op->{TYPE} eq "dup" ) {
           _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
              unless $op->{KFD1} == $op->{KFD2};
        }
        elsif ( $op->{TYPE} eq "close" ) {
  	 _save \%saved, \%saved_as, $op->{KFD};
  	 IPC::Run::_close( $op->{KFD} );
        }
        elsif ( $op->{TYPE} eq "init" ) {
  	 ## TODO: detect this in harness()
           croak "init subs not allowed on Win32";
        }
     }
  
     my $process;
     my $cmd_line = join " ", map {
        ( my $s = $_ ) =~ s/"/"""/g;
        $s = qq{"$s"} if /[\"\s]|^$/;
        $s;
     } @$cmd;
  
     _debug "cmd line: ", $cmd_line
        if _debugging;
  
     Win32::Process::Create( 
        $process,
        $cmd->[0],
        $cmd_line,
        1,  ## Inherit handles
        NORMAL_PRIORITY_CLASS,
        ".",
     ) or croak "$!: Win32::Process::Create()";
  
     for my $orig_fd ( keys %saved ) {
        IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
        IPC::Run::_close( $saved{$orig_fd} );
     }
  
     return ( $process->GetProcessID(), $process );
  }
  
  
  1;
  
  =pod
  
  =back
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32HELPER

$fatpacked{"IPC/Run/Win32IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32IO';
  package IPC::Run::Win32IO;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32IO - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32IO;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select()
  loop will work on Win32. This seems to only work on WinNT and Win2K at this
  time, not sure if it will ever work on Win95 or Win98. If you have experience
  in this area, please contact me at barries@slaysys.com, thanks!.
  
  =head1 DESCRIPTION
  
  A specialized IO class used on Win32.
  
  =cut
  
  use strict;
  use Carp;
  use IO::Handle;
  use Socket;
  require POSIX;
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '0.90';
  }
  
  use Socket qw( IPPROTO_TCP TCP_NODELAY );
  use Symbol;
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug qw( :default _debugging_level );
  use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
  use Fcntl qw( O_TEXT O_RDONLY );
  
  use base qw( IPC::Run::IO );
  my @cleanup_fields;
  BEGIN {
     ## These fields will be set to undef in _cleanup to close
     ## the handles.
     @cleanup_fields = (
        'SEND_THROUGH_TEMP_FILE', ## Set by WinHelper::optimize()
        'RECV_THROUGH_TEMP_FILE', ## Set by WinHelper::optimize()
        'TEMP_FILE_NAME',         ## The name of the temp file, needed for
                                  ## error reporting / debugging only.
  
        'PARENT_HANDLE',       ## The handle of the socket for the parent
        'PUMP_SOCKET_HANDLE',  ## The socket handle for the pump
        'PUMP_PIPE_HANDLE',    ## The anon pipe handle for the pump
        'CHILD_HANDLE',        ## The anon pipe handle for the child
  
        'TEMP_FILE_HANDLE',    ## The Win32 filehandle for the temp file
     );
  }
  
  ## REMOVE OSFHandleOpen
  use Win32API::File qw(
     GetOsFHandle
     OsFHandleOpenFd
     OsFHandleOpen
     FdGetOsFHandle
     SetHandleInformation
     SetFilePointer
     HANDLE_FLAG_INHERIT
     INVALID_HANDLE_VALUE
  
     createFile
     WriteFile
     ReadFile
     CloseHandle
  
     FILE_ATTRIBUTE_TEMPORARY
     FILE_FLAG_DELETE_ON_CLOSE
     FILE_FLAG_WRITE_THROUGH
  
     FILE_BEGIN
  );
  
  #   FILE_ATTRIBUTE_HIDDEN
  #   FILE_ATTRIBUTE_SYSTEM
  
  
  BEGIN {
     ## Force AUTOLOADED constants to be, well, constant by getting them
     ## to AUTOLOAD before compilation continues.  Sigh.
     () = (
        SOL_SOCKET,
        SO_REUSEADDR,
        IPPROTO_TCP,
        TCP_NODELAY,
        HANDLE_FLAG_INHERIT,
        INVALID_HANDLE_VALUE,
     );
  }
  
  use constant temp_file_flags => (
     FILE_ATTRIBUTE_TEMPORARY()   |
     FILE_FLAG_DELETE_ON_CLOSE()  |
     FILE_FLAG_WRITE_THROUGH()
  );
  
  #   FILE_ATTRIBUTE_HIDDEN()    |
  #   FILE_ATTRIBUTE_SYSTEM()    |
  my $tmp_file_counter;
  my $tmp_dir;
  
  sub _cleanup {
      my IPC::Run::Win32IO $self = shift;
      my ( $harness ) = @_;
  
      $self->_recv_through_temp_file( $harness )
         if $self->{RECV_THROUGH_TEMP_FILE};
  
      CloseHandle( $self->{TEMP_FILE_HANDLE} )
         if defined $self->{TEMP_FILE_HANDLE};
  
      $self->{$_} = undef for @cleanup_fields;
  }
  
  
  sub _create_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     ## Create a hidden temp file that Win32 will delete when we close
     ## it.
     unless ( defined $tmp_dir ) {
        $tmp_dir = File::Spec->catdir(
           File::Spec->tmpdir, "IPC-Run.tmp"
        );
  
        ## Trust in the user's umask.
        ## This could possibly be a security hole, perhaps
        ## we should offer an option.  Hmmmm, really, people coding
        ## security conscious apps should audit this code and
        ## tell me how to make it better.  Nice cop-out :).
        unless ( -d $tmp_dir ) {
           mkdir $tmp_dir or croak "$!: $tmp_dir";
        }
     }
  
     $self->{TEMP_FILE_NAME} = File::Spec->catfile(
        ## File name is designed for easy sorting and not conflicting
        ## with other processes.  This should allow us to use "t"runcate
        ## access in CreateFile in case something left some droppings
        ## around (which should never happen because we specify
        ## FLAG_DELETE_ON_CLOSE.
        ## heh, belt and suspenders are better than bug reports; God forbid
        ## that NT should ever crash before a temp file gets deleted!
        $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
     );
  
     $self->{TEMP_FILE_HANDLE} = createFile(
        $self->{TEMP_FILE_NAME},
        "trw",         ## new, truncate, read, write
        {
           Flags      => temp_file_flags,
        },
     ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
  
     $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
     $self->{FD} = undef;
  
     _debug
        "Win32 Optimizer: temp file (",
        $self->{KFD},
        $self->{TYPE},
        $self->{TFD},
        ", fh ",
        $self->{TEMP_FILE_HANDLE},
        "): ",
        $self->{TEMP_FILE_NAME}
        if _debugging_details;
  }
  
  
  sub _reset_temp_file_pointer {
     my $self = shift;
     SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
        or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
  }
  
  
  sub _send_through_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     _debug
        "Win32 optimizer: optimizing "
        . " $self->{KFD} $self->{TYPE} temp file instead of ",
           ref $self->{SOURCE} || $self->{SOURCE}
        if _debugging_details;
  
     $self->_create_temp_file;
  
     if ( defined ${$self->{SOURCE}} ) {
        my $bytes_written = 0;
        my $data_ref;
        if ( $self->binmode ) {
  	 $data_ref = $self->{SOURCE};
        }
        else {
           my $data = ${$self->{SOURCE}};  # Ugh, a copy.
  	 $data =~ s/(?<!\r)\n/\r\n/g;
  	 $data_ref = \$data;
        }
  
        WriteFile(
           $self->{TEMP_FILE_HANDLE},
           $$data_ref,
           0,              ## Write entire buffer
           $bytes_written,
           [],             ## Not overlapped.
        ) or croak
           "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
        _debug
           "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
           if _debugging_data;
  
        $self->_reset_temp_file_pointer;
  
     }
  
  
     _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
        if _debugging_details;
  }
  
  
  sub _init_recv_through_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     $self->_create_temp_file;
  }
  
  
  ## TODO: Use the Win32 API in the select loop to see if the file has grown
  ## and read it incrementally if it has.
  sub _recv_through_temp_file {
     my IPC::Run::Win32IO $self = shift;
  
     ## This next line kicks in if the run() never got to initting things
     ## and needs to clean up.
     return undef unless defined $self->{TEMP_FILE_HANDLE};
  
     push @{$self->{FILTERS}}, sub {
        my ( undef, $out_ref ) = @_;
  
        return undef unless defined $self->{TEMP_FILE_HANDLE};
  
        my $r;
        my $s;
        ReadFile(
  	 $self->{TEMP_FILE_HANDLE},
  	 $s,
  	 999_999,  ## Hmmm, should read the size.
  	 $r,
  	 []
        ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
  
        _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
  
        return undef unless $r;
  
        $s =~ s/\r\n/\n/g unless $self->binmode;
  
        my $pos = pos $$out_ref;
        $$out_ref .= $s;
        pos( $out_ref ) = $pos;
        return 1;
     };
  
     my ( $harness ) = @_;
  
     $self->_reset_temp_file_pointer;
  
     1 while $self->_do_filters( $harness );
  
     pop @{$self->{FILTERS}};
  
     IPC::Run::_close( $self->{TFD} );
  }
  
  =head1 SUBROUTINES
  
  =over
  
  =item poll
  
  Windows version of IPC::Run::IP::poll.
  
  =back
  
  =cut
  
  sub poll {
     my IPC::Run::Win32IO $self = shift;
  
     return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
  
     return $self->SUPER::poll( @_ );
  }
  
  
  ## When threaded Perls get good enough, we should use threads here.
  ## The problem with threaded perls is that they dup() all sorts of
  ## filehandles and fds and don't allow sufficient control over
  ## closing off the ones we don't want.
  
  sub _spawn_pumper {
     my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
     my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
  
     _debug "pumper stdin = ", $stdin_fd if _debugging_details;
     _debug "pumper stdout = ", $stdout_fd if _debugging_details;
     _inherit $stdin_fd, $stdout_fd, $debug_fd;
     my @I_options = map qq{"-I$_"}, @INC;
  
     my $cmd_line = join( " ",
        qq{"$^X"},
        @I_options,
        qw(-MIPC::Run::Win32Pump -e 1 ),
  ## I'm using this clunky way of passing filehandles to the child process
  ## in order to avoid some kind of premature closure of filehandles
  ## problem I was having with VCP's test suite when passing them
  ## via CreateProcess.  All of the ## REMOVE code is stuff I'd like
  ## to be rid of and the ## ADD code is what I'd like to use.
        FdGetOsFHandle( $stdin_fd ), ## REMOVE
        FdGetOsFHandle( $stdout_fd ), ## REMOVE
        FdGetOsFHandle( $debug_fd ), ## REMOVE
        $binmode ? 1 : 0,
        $$, $^T, _debugging_level, qq{"$child_label"},
        @opts
     );
  
  #   open SAVEIN,  "<&STDIN"  or croak "$! saving STDIN";       #### ADD
  #   open SAVEOUT, ">&STDOUT" or croak "$! saving STDOUT";       #### ADD
  #   open SAVEERR, ">&STDERR" or croak "$! saving STDERR";       #### ADD
  #   _dont_inherit \*SAVEIN;       #### ADD
  #   _dont_inherit \*SAVEOUT;       #### ADD
  #   _dont_inherit \*SAVEERR;       #### ADD
  #   open STDIN,  "<&$stdin_fd"  or croak "$! dup2()ing $stdin_fd (pumper's STDIN)";       #### ADD
  #   open STDOUT, ">&$stdout_fd" or croak "$! dup2()ing $stdout_fd (pumper's STDOUT)";       #### ADD
  #   open STDERR, ">&$debug_fd" or croak "$! dup2()ing $debug_fd (pumper's STDERR/debug_fd)";       #### ADD
  
     _debug "pump cmd line: ", $cmd_line if _debugging_details;
  
     my $process;
     Win32::Process::Create( 
        $process,
        $^X,
        $cmd_line,
        1,  ## Inherit handles
        NORMAL_PRIORITY_CLASS,
        ".",
     ) or croak "$!: Win32::Process::Create()";
  
  #   open STDIN,  "<&SAVEIN"  or croak "$! restoring STDIN";       #### ADD
  #   open STDOUT, ">&SAVEOUT" or croak "$! restoring STDOUT";       #### ADD
  #   open STDERR, ">&SAVEERR" or croak "$! restoring STDERR";       #### ADD
  #   close SAVEIN             or croak "$! closing SAVEIN";       #### ADD
  #   close SAVEOUT            or croak "$! closing SAVEOUT";       #### ADD
  #   close SAVEERR            or croak "$! closing SAVEERR";       #### ADD
  
     close $stdin  or croak "$! closing pumper's stdin in parent";
     close $stdout or croak "$! closing pumper's stdout in parent";
     # Don't close $debug_fd, we need it, as do other pumpers.
  
     # Pause a moment to allow the child to get up and running and emit
     # debug messages.  This does not always work.
     #   select undef, undef, undef, 1 if _debugging_details;
  
     _debug "_spawn_pumper pid = ", $process->GetProcessID 
        if _debugging_data;
  }
  
  
  my $next_port = 2048;
  my $loopback  = inet_aton "127.0.0.1";
  my $tcp_proto = getprotobyname('tcp');
  croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
  
  sub _socket {
     my ( $server ) = @_;
     $server ||= gensym;
     my $client = gensym;
  
     my $listener = gensym;
     socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
        or croak "$!: socket()";
     setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack("l", 0)
        or croak "$!: setsockopt()";
  
     my $port;
     my @errors;
  PORT_FINDER_LOOP:
     {
        $port = $next_port;
        $next_port = 2048 if ++$next_port > 65_535; 
        unless ( bind $listener, sockaddr_in( $port, $loopback ) ) {
  	 push @errors, "$! on port $port";
  	 croak join "\n", @errors if @errors > 10;
           goto PORT_FINDER_LOOP;
        }
     }
  
     _debug "win32 port = $port" if _debugging_details;
  
     listen $listener, my $queue_size = 1
        or croak "$!: listen()";
  
     {
        socket $client, PF_INET, SOCK_STREAM, $tcp_proto
           or croak "$!: socket()";
  
        my $paddr = sockaddr_in($port, $loopback );
  
        connect $client, $paddr
           or croak "$!: connect()";
      
        croak "$!: accept" unless defined $paddr;
  
        ## The windows "default" is SO_DONTLINGER, which should make
        ## sure all socket data goes through.  I have my doubts based
        ## on experimentation, but nothing prompts me to set SO_LINGER
        ## at this time...
        setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack("l", 0)
  	 or croak "$!: setsockopt()";
     }
  
     {
        _debug "accept()ing on port $port" if _debugging_details;
        my $paddr = accept( $server, $listener );
        croak "$!: accept()" unless defined $paddr;
     }
  
     _debug
        "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port" 
        if _debugging_details;
     return ( $server, $client );
  }
  
  
  sub _open_socket_pipe {
     my IPC::Run::Win32IO $self = shift;
     my ( $debug_fd, $parent_handle ) = @_;
  
     my $is_send_to_child = $self->dir eq "<";
  
     $self->{CHILD_HANDLE}     = gensym;
     $self->{PUMP_PIPE_HANDLE} = gensym;
  
     ( 
        $self->{PARENT_HANDLE},
        $self->{PUMP_SOCKET_HANDLE}
     ) = _socket $parent_handle;
  
     ## These binmodes seem to have no effect on Win2K, but just to be safe
     ## I do them.
     binmode $self->{PARENT_HANDLE}      or die $!;
     binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
  
  _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
     if _debugging_details;
  ##my $buf;
  ##$buf = "write on child end of " . fileno( $self->{WRITE_HANDLE} ) . "\n\n\n\n\n";
  ##POSIX::write(fileno $self->{WRITE_HANDLE}, $buf, length $buf) or warn "$! in syswrite";
  ##$buf = "write on parent end of " . fileno( $self->{CHILD_HANDLE} ) . "\r\n";
  ##POSIX::write(fileno $self->{CHILD_HANDLE},$buf, length $buf) or warn "$! in syswrite";
  ##   $self->{CHILD_HANDLE}->autoflush( 1 );
  ##   $self->{WRITE_HANDLE}->autoflush( 1 );
  
     ## Now fork off a data pump and arrange to return the correct fds.
     if ( $is_send_to_child ) {
        pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
           or croak "$! opening child pipe";
  _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
     if _debugging_details;
  _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
     if _debugging_details;
     }
     else {
        pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
           or croak "$! opening child pipe";
  _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
     if _debugging_details;
  _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
     if _debugging_details;
     }
  
     ## These binmodes seem to have no effect on Win2K, but just to be safe
     ## I do them.
     binmode $self->{CHILD_HANDLE};
     binmode $self->{PUMP_PIPE_HANDLE};
  
     ## No child should ever see this.
     _dont_inherit $self->{PARENT_HANDLE};
  
     ## We clear the inherit flag so these file descriptors are not inherited.
     ## It'll be dup()ed on to STDIN/STDOUT/STDERR before CreateProcess is
     ## called and *that* fd will be inheritable.
     _dont_inherit $self->{PUMP_SOCKET_HANDLE};
     _dont_inherit $self->{PUMP_PIPE_HANDLE};
     _dont_inherit $self->{CHILD_HANDLE};
  
     ## Need to return $self so the HANDLEs don't get freed.
     ## Return $self, $parent_fd, $child_fd
     my ( $parent_fd, $child_fd ) = (
        fileno $self->{PARENT_HANDLE},
        fileno $self->{CHILD_HANDLE}
     );
  
     ## Both PUMP_..._HANDLEs will be closed, no need to worry about
     ## inheritance.
     _debug "binmode on" if _debugging_data && $self->binmode;
     _spawn_pumper(
        $is_send_to_child
  	 ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
  	 : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
        $debug_fd,
        $self->binmode,
        $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
     );
  
  {
  my $foo;
  confess "PARENT_HANDLE no longer open"
     unless POSIX::read( $parent_fd, $foo, 0 );
  }
  
     _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
        if _debugging_details;
  
     $self->{FD}  = $parent_fd;
     $self->{TFD} = $child_fd;
  }
  
  sub _do_open {
     my IPC::Run::Win32IO $self = shift;
  
     if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
        return $self->_send_through_temp_file( @_ );
     }
     elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
        return $self->_init_recv_through_temp_file( @_ );
     }
     else {
        return $self->_open_socket_pipe( @_ );
     }
  }
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32IO

$fatpacked{"IPC/Run/Win32Pump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PUMP';
  package IPC::Run::Win32Pump;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Pump - helper processes to shovel data to/from parent, child
  
  =head1 SYNOPSIS
  
  Internal use only; see IPC::Run::Win32IO and best of luck to you.
  
  =head1 DESCRIPTION
  
  See L<IPC::Run::Win32Helper|IPC::Run::Win32Helper> for details.  This
  module is used in subprocesses that are spawned to shovel data to/from
  parent processes from/to their child processes.  Where possible, pumps
  are optimized away.
  
  NOTE: This is not a real module: it's a script in module form, designed
  to be run like
  
     $^X -MIPC::Run::Win32Pumper -e 1 ...
  
  It parses a bunch of command line parameters from IPC::Run::Win32IO.
  
  =cut
  
  use strict;
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '0.90';
  }
  
  use Win32API::File qw(
     OsFHandleOpen
  );
  
  
  my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
  BEGIN {
     ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
     ## Rather than letting IPC::Run::Debug export all-0 constants
     ## when not debugging, we do it manually in order to not even
     ## load IPC::Run::Debug.
     if ( $debug ) {
        eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
  	 or die $@;
     }
     else {
        eval <<STUBS_END or die $@;
  	 sub _debug {}
  	 sub _debug_init {}
  	 sub _debugging() { 0 }
  	 sub _debugging_data() { 0 }
  	 sub _debugging_details() { 0 }
  	 sub _debugging_gory_details() { 0 }
  	 1;
  STUBS_END
     }
  }
  
  ## For some reason these get created with binmode on.  AAargh, gotta       #### REMOVE
  ## do it by hand below.       #### REMOVE
  if ( $debug ) {       #### REMOVE
  close STDERR;       #### REMOVE
  OsFHandleOpen( \*STDERR, $debug_fh, "w" )       #### REMOVE
   or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";       #### REMOVE
  }       #### REMOVE
  close STDIN;       #### REMOVE
  OsFHandleOpen( \*STDIN, $stdin_fh, "r" )       #### REMOVE
  or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";       #### REMOVE
  close STDOUT;       #### REMOVE
  OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )       #### REMOVE
  or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";       #### REMOVE
  
  binmode STDIN;
  binmode STDOUT;
  $| = 1;
  select STDERR; $| = 1; select STDOUT;
  
  $child_label ||= "pump";
  _debug_init(
  $parent_pid,
  $parent_start_time,
  $debug,
  fileno STDERR,
  $child_label,
  );
  
  _debug "Entered" if _debugging_details;
  
  # No need to close all fds; win32 doesn't seem to pass any on to us.
  $| = 1;
  my $buf;
  my $total_count = 0;
  while (1) {
  my $count = sysread STDIN, $buf, 10_000;
  last unless $count;
  if ( _debugging_gory_details ) {
   my $msg = "'$buf'";
   substr( $msg, 100, -1 ) = '...' if length $msg > 100;
   $msg =~ s/\n/\\n/g;
   $msg =~ s/\r/\\r/g;
   $msg =~ s/\t/\\t/g;
   $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
   _debug sprintf( "%5d chars revc: ", $count ), $msg;
  }
  $total_count += $count;
  $buf =~ s/\r//g unless $binmode;
  if ( _debugging_gory_details ) {
   my $msg = "'$buf'";
   substr( $msg, 100, -1 ) = '...' if length $msg > 100;
   $msg =~ s/\n/\\n/g;
   $msg =~ s/\r/\\r/g;
   $msg =~ s/\t/\\t/g;
   $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
   _debug sprintf( "%5d chars sent: ", $count ), $msg;
  }
  print $buf;
  }
  
  _debug "Exiting, transferred $total_count chars" if _debugging_details;
  
  ## Perform a graceful socket shutdown.  Windows defaults to SO_DONTLINGER,
  ## which should cause a "graceful shutdown in the background" on sockets.
  ## but that's only true if the process closes the socket manually, it
  ## seems; if the process exits and lets the OS clean up, the OS is not
  ## so kind.  STDOUT is not always a socket, of course, but it won't hurt
  ## to close a pipe and may even help.  With a closed source OS, who
  ## can tell?
  ##
  ## In any case, this close() is one of the main reasons we have helper
  ## processes; if the OS closed socket fds gracefully when an app exits,
  ## we'd just redirect the client directly to what is now the pump end 
  ## of the socket.  As it is, however, we need to let the client play with
  ## pipes, which don't have the abort-on-app-exit behavior, and then
  ## adapt to the sockets in the helper processes to allow the parent to
  ## select.
  ##
  ## Possible alternatives / improvements:
  ## 
  ## 1) use helper threads instead of processes.  I don't trust perl's threads
  ## as of 5.005 or 5.6 enough (which may be myopic of me).
  ##
  ## 2) figure out if/how to get at WaitForMultipleObjects() with pipe
  ## handles.  May be able to take the Win32 handle and pass it to 
  ## Win32::Event::wait_any, dunno.
  ## 
  ## 3) Use Inline::C or a hand-tooled XS module to do helper threads.
  ## This would be faster than #1, but would require a ppm distro.
  ##
  close STDOUT;
  close STDERR;
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32PUMP

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use Moo::_strictures;
  use Moo::_Utils;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quoted_from_sub quotify);
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  
  my $module_name_only = qr/\A$Module::Runtime::module_name_rx\z/;
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with "
      . ( $type || 'an accessor' );
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ $module_name_only;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
    if (($spec->{coerce}||0) eq 1) {
      my $isa = $spec->{isa};
      if (blessed $isa and $isa->can('coercion')) {
        $spec->{coerce} = $isa->coercion;
      } elsif (blessed $isa and $isa->can('coerce')) {
        $spec->{coerce} = sub { $isa->coerce(@_) };
      } else {
        die "Invalid coercion for $into->$name - no appropriate type constraint";
      }
    }
  
    foreach my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name",
          'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      foreach my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $methods{$pred} =
          quote_sub "${into}::${pred}" =>
            '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
          ;
      }
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
      $methods{$cl} =
        quote_sub "${into}::${cl}" =>
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Moo::Role')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" =>
          $self->_generate_asserter($name, $spec),
          delete $self->{captures};
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_default {
    my ($self, $name, $spec) = @_;
    $spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\quotify $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\quotify $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa} ?
         "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
    );
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : quotify $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_simple_get(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .=
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return quotify($name) if !defined($init_arg) or $init_arg eq $name;
    return quotify($name).' (constructor argument: '.quotify($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce),
      1,
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _wrap_attr_exception {
    my ($self, $name, $step, $arg, $code, $want_return) = @_;
    my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
    .'    init_arg => '.quotify($arg).",\n"
    .'    name     => '.quotify($name).",\n"
    .'    step     => '.quotify($step).",\n"
    ."  };\n"
    .($want_return ? '  my $_return;'."\n" : '')
    .'  my $_error;'."\n"
    ."  {\n"
    .'    my $_old_error = $@;'."\n"
    ."    if (!eval {\n"
    .'      $@ = $_old_error;'."\n"
    .($want_return ? '      $_return ='."\n" : '')
    .'      '.$code.";\n"
    ."      1;\n"
    ."    }) {\n"
    .'      $_error = $@;'."\n"
    .'      if (!ref $_error) {'."\n"
    .'        $_error = '.$prefix.'.$_error;'."\n"
    ."      }\n"
    ."    }\n"
    .'    $@ = $_old_error;'."\n"
    ."  }\n"
    .'  die $_error if $_error;'."\n"
    .($want_return ? '  $_return;'."\n" : '')
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.$self->_sanitize_name($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify($code, $values,
          Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.$self->_sanitize_name($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name {
    my ($self, $name) = @_;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value =
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n"
              ."${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      # &Internals::SvREADONLY($foo, 0);
      # Scalar::Util::weaken($foo);
      # &Internals::SvREADONLY($foo, 1);
      #
      # but requires Internal functions and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using quotify
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{mro::get_linear_isa($into)};
    '    unless (('.$args.')[0]->{__no_BUILD__}) {'."\n"
    .join('', map qq{      ${me}->${_}(${args});\n}, @builds)
    ."   }\n";
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use Moo::_strictures;
  use Sub::Quote qw(quote_sub unquote_sub quotify);
  use Sub::Defer;
  use Moo::_Utils qw(_getstash _getglob);
  use Moo;
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    $self->assert_constructor;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      if ($new_spec->{required}
        && !(
          $self->accessor_generator->has_default($name, $new_spec)
          || !exists $new_spec->{init_arg}
          || defined $new_spec->{init_arg}
        )
      ) {
        die "You cannot have a required attribute (${name})"
          . " without a default, builder, or an init_arg";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    $self->assert_constructor;
    my $package = $self->{package};
    my (undef, @isa) = @{mro::get_linear_isa($package)};
    my $isa = join ',', @isa;
    $self->{deferred_constructor} = defer_sub "${package}::new" => sub {
      my (undef, @new_isa) = @{mro::get_linear_isa($package)};
      if (join(',', @new_isa) ne $isa) {
        my ($expected_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa;
        my ($found_new) = grep { *{_getglob($_.'::new')}{CODE} } @new_isa;
        if (($found_new||'') ne ($expected_new||'')) {
          $found_new ||= 'none';
          $expected_new ||= 'none';
          die "Expected parent constructor of $package expected to be"
          . " $expected_new, but found $found_new: changing the inheritance"
          . " chain (\@ISA) at runtime is unsupported";
        }
      }
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub current_constructor {
    my ($self, $package) = @_;
    return *{_getglob("${package}::new")}{CODE};
  }
  
  sub assert_constructor {
    my ($self) = @_;
    my $package = $self->{package} or return 1;
    my $current = $self->current_constructor($package)
      or return 1;
    my $deferred = $self->{deferred_constructor}
      or die "Unknown constructor for $package already exists";
    return 1
      if $deferred == $current;
    my $current_deferred = (Sub::Defer::defer_info($current)||[])->[3];
    if ($current_deferred && $current_deferred == $deferred) {
      die "Constructor for $package has been inlined and cannot be updated";
    }
    die "Constructor for $package has been replaced with an unknown sub";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      $body .= $self->buildall_generator->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.quotify($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = quotify($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or exists $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, '
      .join(', ', map quotify($_), @required_init).') {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  # bootstrap our own constructor
  sub new {
    my $class = shift;
    delete _getstash(__PACKAGE__)->{new};
    bless $class->BUILDARGS(@_), $class;
  }
  Moo->_constructor_maker_for(__PACKAGE__)
  ->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'bare' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'bare' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  our @ISA = qw(Moo::Object);
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{mro::get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use Moo::_strictures;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
          $fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Minilla.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA';
  package Minilla;
  use strict;
  use warnings;
  use 5.008005;
  use version; our $VERSION = version->declare("v3.0.1");
  
  our $DEBUG;
  our $AUTO_INSTALL;
  
  sub debug { $DEBUG }
  sub auto_install { $AUTO_INSTALL }
  
  1;
  __END__
  
  =for stopwords MINILLA .mailmap mimick XSUtil travis XSUtil.needs_compiler_cpp XSUtil.generate_xshelper_h XSUtil.cc_warnings DarkPAN
  
  =encoding utf8
  
  =head1 NAME
  
  Minilla - CPAN module authoring tool
  
  =head1 SYNOPSIS
  
      minil new     - Create a new dist
      minil test    - Run test cases
      minil dist    - Make your dist tarball
      minil install - Install your dist
      minil release - Release your dist to CPAN
      minil run     - Run arbitrary commands against build dir
  
  =head1 DESCRIPTION
  
  Minilla is a CPAN module authoring tool. Minilla provides L<minil> command for authorizing a CPAN distribution.
  
      (M::I - inc) + shipit + (dzil - plugins)
  
  =head1 CONVENTION
  
  As stated above, Minilla is opinionated. Minilla has a bold assumption and convention like the followings, which are almost compatible to the sister project L<Dist::Milla>.
  
  =over 4
  
  =item Your modules are written in Pure Perl and are located in I<lib/>.
  
  =item Your executable files are in I<script/> directory, if any
  
  =item Your module is maintained with B<Git> and C<git ls-files> matches with what you will release
  
  =item Your module has a static list of prerequisites that can be described in L<cpanfile>
  
  =item Your module has a Changes file
  
  =item Your module requires at least perl 5.6.
  
  =back
  
  =head1 GETTING STARTED
  
      # First time only
      % cpanm Minilla
      # Minilla has only a few deps. It should be very quick
  
      # Make a new distribution
      % minil new Dist-Name
      % cd Dist-Name/
  
      # Git commit
      % git commit -m "initial commit"
  
      # Hack your code!
      % $EDITOR lib/Dist/Name.pm t/dist-name.t cpanfile
  
      # Done? Test and release it!
      % minil release
  
  It's that easy.
  
  You already have distributions with L<Module::Install>, L<Module::Build>, L<Dist::Zilla> or L<ShipIt>? Migrating is also trivial. See "MIGRATING" in L<Minilla::Tutorial> for more details.
  
  =head1 WHY MINILLA?
  
  =head2 Repository managed by Minilla is git install ready.
  
  The repository created and managed by Minilla is git install ready.
  You can install the library by C<< cpanm git://... >>.
  
  Of course, you can install Minilla from C<< cpanm git://github.com/tokuhirom/Minilla.git >>.
  
  =head2 Minilla is built on small libraries.
  
  Minilla is built on only few small libraries. You can install Minilla without a huge list of dependencies to heavy modules.
  
  =head2 And, what is Minilla?
  
      Minilla is a Kaiju (Japanese giant monster) from the Godzilla series of films and is the first of several young Godzillas.
      https://en.wikipedia.org/wiki/Minilla
  
  =head1 CONFIGURATION
  
  Minilla uses B<Convention over Configuration>.
  
  But, you can write configurations to I<minil.toml> file in L<TOML|https://github.com/toml-lang/toml> format. Minilla reads the I<minil.toml> file in the root directory of your project.
  
  =over 4
  
  =item name
  
  You can write 'name' instead of automatically detecting project name out of the directory name.
  
  =item readme_from
  
      readme_from="lib/My/Foo.pod"
  
  You can specify the file to generate the README.md. This is a main module path by default.
  
  =item tag_format
  
      tag_format="perl/%v"
  
  format of the tag to apply. Defaults to %v. C<%v> will replace with the distribution version.
  
  =item abstract_from
  
      abstract_from="lib/My/Foo.pod"
  
  Grab abstract information from the file contains pod.
  
  =item authors_from
  
      authors_from="lib/My/Foo.pod"
  
  Grab authors information from the file contains pod.
  
  =item authority
  
      authority = "cpan:TOKUHIROM"
  
  Set x_authority attribute to META.
  See L<https://jawnsy.wordpress.com/2011/02/20/what-is-x_authority/> for more details.
  
  =item allow_pureperl
  
      allow_pureperl=1
  
  A boolean indicating the module is still functional without its XS parts.  When an XS module is build
  with C<--pureperl_only>, it will otherwise fail.
  
  It affects to L<Module::Build> 0.4005+ only.
  
  =item no_github_issues
  
      no_github_issues=true
  
  Minilla sets bugtracker as github issues by default. But if you want to use RT, you can set this variable.
  
  =item no_index
  
      [no_index]
      directory=['t', 'xt', 'tools']
  
  Minilla sets META.json's no_index as C<< directory => ['t', 'xt', 'inc', 'share', 'eg', 'examples', 'author', 'builder'] >>
  by default. But if you want to change them, you can set this section variable. If this section is set,
  specified variables are only used, in fact default settings are not merged.
  
  =item c_source
  
      c_source = ['src']
  
  A directory which contains C source files that the rest of the build may depend
  on.  Any ".c" files in the directory will be compiled to object files.
  The directory will be added to the search path during the compilation and
  linking phases of any C or XS files.
  
  =item script_files
  
      script_files = ['bin/foo', 'script/*']
  
  Minilla sets install script files as C<< ['script/*', 'bin/*'] >> by default.
  
  (Note. This option doesn't affect anything if you are using ModuleBuildTiny or ExtUtilsMakeMaker, for now. If you are using ModuleBuildTiny, you MUST put scripts in script/ directory.)
  
  =item tap_harness_args(EXPERIMENTAL)
  
      [tap_harness_args]
      jobs=19
  
  This parameters pass to TAP::Harness when running tests. See the L<TAP::Harness> documentation for details.
  
  =item license
  
      license="artistic_2"
  
  You can specify your favorite license on minil.toml. The license key is same as CPAN Meta spec 2.0.
  See L<CPAN::Meta::Spec>.
  
  =item badges
  
      badges = ['travis', 'appveyor', 'coveralls', 'codecov', 'gitter']
  
  Embed badges image (e.g. Travis-CI) to README.md. It ought to be array and each elements must be service name. Now, supported services are only 'travis', 'appveyor', 'coveralls', 'codecov' and 'gitter'.
  
  =item PL_files
  
  Specify the PL files.
  
      [PL_files]
      lib/Foo/Bar.pm.PL="lib/Foo/Bar.pm"
  
  This option is not supported by L<Minilla::ModuleMaker::ModuleBuildTiny>.
  
  Note. MBTiny executes *.PL files by default.
  
  =item build.build_class
  
  Specify a custom Module::Build subclass.
  
      [build]
      build_class = "builder::MyBuilder"
  
  =item XSUtil.needs_compiler_c99
  
      [XSUtil]
      needs_compiler_c99 = 1
  
  You can specify C<needs_compiler_c99> parameter of L<Module::Build::XSUtil>.
  
  =item XSUtil.needs_compiler_cpp
  
      [XSUtil]
      needs_compiler_cpp = 1
  
  You can specify C<needs_compiler_cpp> parameter of L<Module::Build::XSUtil>.
  
  =item XSUtil.generate_ppport_h
  
      [XSUtil]
      generate_ppport_h = 1
  
  You can specify C<generate_ppport_h> parameter of L<Module::Build::XSUtil>.
  
  =item XSUtil.generate_xshelper_h
  
      [XSUtil]
      generate_xshelper_h = 1
  
  You can specify C<generate_xshelper_h> parameter of L<Module::Build::XSUtil>.
  
  =item XSUtil.cc_warnings
  
      [XSUtil]
      cc_warnings = 1
  
  You can specify C<cc_warnings> parameter of L<Module::Build::XSUtil>.
  
  =item FileGatherer.exclude_match
  
      [FileGatherer]
      exclude_match = ['^author_tools/.*']
  
  Nothing by default. To exclude certain files from being gathered into dist, use the
  C<exclude_match> option. Files matching the patterns are not gathered.
  
  =item FileGatherer.include_dotfiles
  
      [FileGatherer]
      include_dotfiles = false
  
  By default, files will not be included in dist if they begin with a dot. This goes
  both for files and for directories.
  
  In almost all cases, the default value (false) is correct.
  
  =item release.pause_config
  
      [release]
      pause_config = "/path/to/some/.pause"
  
  By setting this value to another PAUSE configuration file (see
  L<cpan_upload/CONFIGURATION> for the details), it is possible to use another
  PAUSE server (or anything good enough to mimick its upload process) for the
  release step.
  
  To do so, simply add a C<upload_uri> entry in your file to the alternate PAUSE
  server, i.e :
  
      upload_uri http://127.0.0.1:5000/pause/authenquery
  
  If you instantly launch your origin upload server as DarkPAN, See L<OrePAN2::Server>.
  
  =item release.do_not_upload_to_cpan
  
      [release]
      do_not_upload_to_cpan=true
  
  This variable disables CPAN upload feature.
  
  =item release.hooks
  
      [release]
      hooks = [
          "COMMAND1",
          "COMMAND2"
      ]
  
  Commands that are specified by this option will be executed when releasing. If result of commands is not successful, it will abort.
  
  =item ReleaseTest.MinimumVersion
  
      [ReleaseTest]
      MinimumVersion = false
  
  If you set this key false, Minilla will not generate 'xt/minilla/minimum_version.t'.
  
  =item requires_external_bin
  
      requires_external_bin=['tar']
  
  The C<requires_external_bin> command takes the name of a system command
  or program. Build fail if the command does not exist.
  
  =item markdown_maker
  
      markdown_maker = "Pod::Markdown::Github"
  
  Use a different module to generate C<README.md> from your pod. This
  module must subclass L<Pod::Markdown>.
  
  =back
  
  =head1 FAQ
  
  =over 4
  
  =item How can I manage B<contributors> section?
  
  Minilla aggregates contributors list from C<< git log --format="%aN <%aE>" | sort | uniq >>.
  
  You can merge accounts by .mailmap file. See L<https://www.kernel.org/pub/software/scm/git/docs/git-shortlog.html>
  
  =item Why don't you provide plug-in support?
  
  If you want a pluggable tool, it already exists: It's called L<Dist::Zilla> :P
  If you like Minilla's behavior but you really want something pluggable, you can use L<Dist::Milla>, Minilla's sister project.
  L<Dist::Milla>'s behavior is almost identical to that of Minilla.
  
  =item Why does minil only support git?
  
  I think git is a best VC for CPAN modules, for now.
  
  If you want to use another version control system, you can probably use L<Dist::Milla>.
  
  =item And why...
  
  Yes. You can use L<Dist::Milla>.
  
  =item Should I add (META.json|Build.PL) to repository?
  
  Yes. You need to add it to make your git repo installable via cpanm.
  
  =item How do I manage ppport.h?
  
  Is there a reason to remove ppport.h from repo?
  
  =item How can I install script files?
  
  Your executables must be in F<script/> directory.
  
  =item How to switch from Module::Install/Module::Build/Dist::Zilla?
  
  You can use experimental `minil migrate` sub-command.
  See L<Minilla::CLI::Migrate> for more details.
  
  =item How should I manage the files you do not want to upload to CPAN?
  
  Please use FileGatherer.exclude_match for ignoring files to upload tar ball.
  
  You can use MANIFEST.SKIP file for ignoring files. ref. L<ExtUtils::Manifest>.
  
  =item How do I use Module::Build::Tiny with Minilla?
  
  Minilla supports Module::Build::Tiny and uses it as a default installer since v1.0.0.
  
  If you want to migrate an existing project created before Minilla v1.0, you need to rewrite C<minil.toml> file.
  You need to add the following line:
  
      module_maker="ModuleBuildTiny"
  
  =item How do I use Module::Build with Minilla?
  
  If you want to create new project with Module::Build, run the command as following.
  
      % minil new -p ModuleBuild My::Awesome::Module
  
  =item How do I use ExtUtils::MakeMaker with Minilla?
  
  Minilla v2.1.0+ supports EUMM(EXPERIMENTAL).
  
  You need to rewrite minil.toml file and add the following line:
  
      module_maker="ExtUtilsMakeMaker"
  
  (There is no profile, yet. Patches welcome.)
  
  I don't suggest to use this module... But you can use this option for maintaining
  primitive modules like Test::TCP.
  
  =item Ho do I support Perl 5.6?
  
  EUMM can run on Perl 5.6. Write following statement in your minil.toml file.
  
      module_maker="ExtUtilsMakeMaker"
  
  =back
  
  =head1 AUTHORS
  
  Tokuhiro Matsuno E<lt> tokuhirom@gmail.com E<gt>
  
  Tatsuhiko Miyagawa
  
  =head1 THANKS TO
  
  RJBS, the author of L<Dist::Zilla>. L<Dist::Zilla> points CPAN authorizing tool.
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  Copyright (C) Tokuhiro Matsuno
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
MINILLA

$fatpacked{"Minilla/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI';
  package Minilla::CLI;
  use strict;
  use warnings;
  use utf8;
  use Getopt::Long;
  use Try::Tiny;
  
  use Minilla;
  use Minilla::Errors;
  use Minilla::Project;
  use Minilla::Util qw(find_dir);
  use Minilla::Logger;
  
  use Minilla::CLI::New;
  use Minilla::CLI::Help;
  use Minilla::CLI::Dist;
  use Minilla::CLI::Test;
  use Minilla::CLI::Release;
  use Minilla::CLI::Install;
  
  use Moo;
  
  no Moo;
  
  sub run {
      my ($self, @args) = @_;
   
      local $Minilla::AUTO_INSTALL = 1;
      local $Minilla::Logger::COLOR = -t STDOUT ? 1 : 0;
      local @ARGV = @args;
      my @commands;
      my $version;
      my $p = Getopt::Long::Parser->new(
          config => [ "no_ignore_case", "pass_through" ],
      );
      $p->getoptions(
          "h|help"         => sub { unshift @commands, 'help' },
          "color!"         => \$Minilla::Logger::COLOR,
          "debug!"         => \$Minilla::DEBUG,
          "auto-install!"  => \$Minilla::AUTO_INSTALL,
          'version!'       => \$version,
      );
  
      if ($version) {
          print "Minilla: $Minilla::VERSION\n";
          exit 0;
      }
   
      push @commands, @ARGV;
   
      my $cmd = shift @commands || 'help';
      my $klass = sprintf("Minilla::CLI::%s", ucfirst($cmd));
   
      ## no critic
      if (eval sprintf("require %s; 1;", $klass)) {
          try {
              $klass->run(@commands);
          } catch {
              /Minilla::Error::CommandExit/ and return;
              errorf("%s\n", $_);
              exit 1;
          }
      } else {
          warnf("Could not find command '%s'\n", $cmd);
          if ($@ !~ /^Can't locate Minilla/) {
              errorf("$@\n");
          }
          exit 2;
      }
  }
  
  1;
  
MINILLA_CLI

$fatpacked{"Minilla/CLI/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_BUILD';
  package Minilla::CLI::Build;
  use strict;
  use warnings;
  use utf8;
  
  use File::Path qw(rmtree mkpath);
  use File::Spec;
  
  use Minilla::Project;
  use Minilla::WorkDir;
  use Minilla::Logger;
  use Minilla::Util qw(parse_options);
  
  sub run {
      my ($class, @args) = @_;
  
      my $test = 1;
      parse_options(
          \@args,
          'test!' => \$test,
      );
  
      my $project = Minilla::Project->new();
      $project->regenerate_files();
      unless ($project->validate()) {
          return;
      }
  
      my $dst = File::Spec->rel2abs(sprintf("%s-%s", $project->dist_name, $project->version));
  
      # generate project directory
      infof("Create %s\n", $dst);
      rmtree($dst);
      mkpath($dst);
      my $work_dir = Minilla::WorkDir->new(project => $project, dir => $dst, cleanup => 0);
      $work_dir->build();
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Build - Build dist directory
  
  =head1 SYNOPSIS
  
      % minil build
  
  =head1 DESCRIPTION
  
  TBD
MINILLA_CLI_BUILD

$fatpacked{"Minilla/CLI/Clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_CLEAN';
  package Minilla::CLI::Clean;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  use File::Path qw(rmtree);
  
  use Minilla::Project;
  use Minilla::Util qw(parse_options);
  
  sub run {
      my ($self, @args) = @_;
  
      my $yes_opt = 0;
      parse_options(
          \@args,
          'y!' => \$yes_opt,
      );
  
      my $project = Minilla::Project->new();
      my @targets = grep { -e $_ } (
          glob(sprintf("%s-*", $project->dist_name)),
          'blib',
          'Build',
          'MYMETA.json',
          'MYMETA.yml',
          '_build_params',
          '_build',       # M::B
          'Makefile',
          'pm_to_blib',
      );
      print("Would remove $_\n") for (@targets);
      if ($yes_opt || prompt('Remove it?', 'y') =~ /y/i) {
          rmtree($_) for @targets;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Clean - Clean up directory
  
  =head1 SYNOPSIS
  
      % minil clean
  
          -y    delete files without asking
  
  =head1 DESCRIPTION
  
  Remove some temporary files.
  
MINILLA_CLI_CLEAN

$fatpacked{"Minilla/CLI/Dist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_DIST';
  package Minilla::CLI::Dist;
  use strict;
  use warnings;
  use utf8;
  
  use File::Spec::Functions qw(catfile);
  use File::Basename qw(basename);
  use File::Copy qw(copy);
  
  use Minilla::Project;
  use Minilla::Util qw(check_git parse_options);
  
  sub run {
      my ($self, @args) = @_;
  
      my $test = 1;
  
      check_git;
  
      parse_options(
          \@args,
          'test!' => \$test,
      );
  
      my $project = Minilla::Project->new();
      unless ($project->validate()) {
          return;
      }
      my $work_dir = $project->work_dir;
      if ($test) {
          local $ENV{RELEASE_TESTING} = 1;
          $work_dir->dist_test();
      }
      my $tar = $work_dir->dist();
      my $dst = catfile($project->dir, basename($tar));
      copy($tar, $dst);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Dist - Make tar ball distribution
  
  =head1 SYNOPSIS
  
      % minil dist
  
  =head1 DESCRIPTION
  
  This sub-command makes distribution tar ball.
  
MINILLA_CLI_DIST

$fatpacked{"Minilla/CLI/Help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_HELP';
  package Minilla::CLI::Help;
  use strict;
  use warnings;
  use utf8;
  
  sub run {
      my ($self, @args) = @_;
  
      my $module = $args[0] ? ( "Minilla::CLI::" . ucfirst $args[0] ) : "Minilla";
      system "perldoc", $module;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Help - Help me!
  
  =head1 SYNOPSIS
  
      # show help for minil itself
      minil help
  
      # show help page for `install` sub-command
      minil help install
  
MINILLA_CLI_HELP

$fatpacked{"Minilla/CLI/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_INSTALL';
  package Minilla::CLI::Install;
  use strict;
  use warnings;
  use utf8;
  
  use Minilla::WorkDir;
  use Minilla::Util qw(cmd parse_options);
  
  sub run {
      my ($self, @args) = @_;
  
      my $test = 1;
      parse_options(
          \@args,
          'test!' => \$test,
      );
  
      my $project = Minilla::Project->new();
      my $work_dir = $project->work_dir();
  
      if ($test) {
          local $ENV{RELEASE_TESTING} = 1;
          $work_dir->dist_test();
      }
      my $tar = $work_dir->dist();
  
      cmd(
          'cpanm',
          '--notest',
          $tar
      );
      unlink($tar) unless Minilla->debug;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Install - Install the dist to system
  
  =head1 SYNOPSIS
  
      % minil install
  
          --no-test Do not run test
  
  =head1 DESCRIPTION
  
  This sub-command install the dist for your system.
  
MINILLA_CLI_INSTALL

$fatpacked{"Minilla/CLI/Migrate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_MIGRATE';
  package Minilla::CLI::Migrate;
  use strict;
  use warnings;
  use utf8;
  
  use Minilla::Util qw(check_git slurp spew);
  use Minilla::Migrate;
  
  sub run {
      my ($self, @args) = @_;
  
      check_git;
  
      Minilla::Migrate->new()->run;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Migrate - Migrate existed distribution repo
  
  =head1 SYNOPSIS
  
      % minil migrate
  
  =head1 DESCRIPTION
  
  This sub-command migrate existed distribution repository to minil ready repository.
  
  =head1 HOW IT WORKS
  
  This module runs script like following shell script.
  
      # Generate META.json from Module::Build or EU::MM
      perl Build.PL
  
      # Create cpanfile from META.json
      mymeta-cpanfile > cpanfile
  
      # MANIFEST, MANIFEST.SKIP is no longer needed.
      git rm MANIFEST MANIFEST.SKIP
  
      # generate META.json
      minil build
      git add -f META.json
  
      # remove META.json from ignored file list
      perl -i -pe 's!^META.json\n$!!' .gitignore
      echo '.build/' >> .gitignore
  
      # remove .shipit if it's exists.
      if [ -f '.shipit' ]; then git rm .shipit; fi
  
      # add things
      git add .
  
MINILLA_CLI_MIGRATE

$fatpacked{"Minilla/CLI/New.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_NEW';
  package Minilla::CLI::New;
  use strict;
  use warnings;
  use utf8;
  use File::pushd;
  use File::Path qw(mkpath);
  
  use Minilla::Util qw(check_git cmd parse_options);
  use Minilla::Logger;
  
  sub run {
      my ($self, @args) = @_;
  
      my $username;
      my $email;
      my $profile = 'Default';
      parse_options(
          \@args,
          'username=s' => \$username,
          'email=s'    => \$email,
          'p|profile=s' => \$profile,
      );
  
      my $module = shift @args or errorf("Missing module name\n");
         $module =~ s!-!::!g;
  
      check_git;
  
      $username ||= `git config user.name`;
      $username =~ s/\n$//;
  
      $email ||= `git config user.email`;
      $email =~ s/\n$//;
  
      my $version = '0.01';
  
      unless ($username) {
          errorf("Please set user.name in git, or use `--username` option.\n");
      }
  
      # $module = "Foo::Bar"
      # $suffix = "Bar"
      # $dist   = "Foo-Bar"
      # $path   = "Foo/Bar.pm"
      my @pkg    = split /::/, $module;
      my $suffix = $pkg[ @pkg - 1 ];
      my $dist   = join "-", @pkg;
      my $path   = join( "/", @pkg ) . ".pm";
      ( my $dir = $dist ) =~ s/^App-//;
  
      if (-d $dist) {
          errorf("There is %s/\n", $dist);
      }
  
      my $author = $username;
  
      my $profile_klass = "Minilla::Profile::${profile}";
      eval "require $profile_klass; 1;" or die $@;
      my $skelton = $profile_klass->new(
          dist    => $dist,
          path    => $path,
          author  => $username,
          suffix  => $suffix,
          module  => $module,
          version => $version,
          email   => $email,
      );
      {
          mkpath($dist);
          my $guard = pushd($dist);
          $skelton->generate();
  
          # init git repo
          infof("Initializing git $module\n");
          cmd('git', 'init');
  
          # generate project after initialize git repo
          my $project = Minilla::Project->new();
          $project->generate_minil_toml($profile);
          $project->regenerate_files();
  
          # and git add all things
          cmd('git', 'add', '.');
      }
  
      infof("Finished to create $module\n");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::New - Generate new module skeleton
  
  =head1 SYNOPSIS
  
      # Create new app using Module::Build::Tiny(default)
      % minil new MyApp
  
      # Create new app using XS
      % minil new -p XS MyApp
  
  =head1 DESCRIPTION
  
  This module creates module skeleton to current directory.
  
  =head1 OPTIONS
  
  =over 4
  
  =back
MINILLA_CLI_NEW

$fatpacked{"Minilla/CLI/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_RELEASE';
  package Minilla::CLI::Release;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use Minilla::Util qw(edit_file require_optional parse_options);
  use Minilla::WorkDir;
  use Minilla::Logger;
  use Minilla::Project;
  
  sub run {
      my ($self, @args) = @_;
  
      my $opts = {
          test => 1,
          trial => 0,
          dry_run => 0,
      };
      parse_options(
          \@args,
          'test!' => \$opts->{test},
          'trial!' => \$opts->{trial},
          'dry-run!' => \$opts->{dry_run},
          'pause-config=s' => \$opts->{pause_config},
      );
  
      my $project = Minilla::Project->new();
      unless ($project->validate()) {
          return;
      }
  
      my @steps = qw(
          CheckUntrackedFiles
          CheckOrigin
          BumpVersion
          CheckChanges
          RegenerateFiles
          RunHooks
          DistTest
          MakeDist
  
          UploadToCPAN
  
          RewriteChanges
          Commit
          Tag
      );
      my @klasses;
      # Load all step classes.
      for (@steps) {
          my $klass = "Minilla::Release::$_";
          if (eval "require ${klass}; 1") {
              push @klasses, $klass;
              $klass->init() if $klass->can('init');
          } else {
              errorf("Error while loading %s: %s\n", $_, $@);
          }
      }
      # And run all steps.
      for my $klass (@klasses) {
          $klass->run($project, $opts);
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Release - Release the module to CPAN!
  
  =head1 SYNOPSIS
  
      % minil release
  
          --no-test         Do not run test scripts
          --trial           Trial release
          --dry-run         Dry run mode
          --pause-config    Path to a CPAN::Uploader configuration file
  
  =head1 DESCRIPTION
  
  This sub-command release the module to CPAN.
  
  =head1 ENVIRONMENT VARIABLES
  
  =over 4
  
  =item FAKE_RELEASE
  
      > FAKE_RELEASE=1 minil release
  
  If this is your first conversion to Minilla and want to make sure you're not going to mess CPAN with a bad archive when something goes wrong, you can run the release command with FAKE_RELEASE environment variable. This will run all the other release process, except the UploadToCPAN step.
  
  Note, this runs C<< git tag >> and C<< git push >>.
  
  =back
MINILLA_CLI_RELEASE

$fatpacked{"Minilla/CLI/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_RUN';
  package Minilla::CLI::Run;
  use strict;
  use warnings;
  use utf8;
  
  use Minilla::WorkDir;
  use Minilla::Project;
  
  sub run {
      my ($self, @args) = @_;
  
      my $project = Minilla::Project->new();
      my $work_dir = $project->work_dir;
      my $code = $work_dir->run(@args);
      exit $code;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Run - Run Arbitrary Commands
  
  =head1 SYNOPSIS
  
      % minil run ...
  
  =head1 DESCRIPTION
  
  This sub-command allows you to run arbitrary commands on your build directory
  
  =cut
MINILLA_CLI_RUN

$fatpacked{"Minilla/CLI/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_CLI_TEST';
  package Minilla::CLI::Test;
  use strict;
  use warnings;
  use utf8;
  use File::pushd;
  
  use Minilla::WorkDir;
  use Minilla::Project;
  use Minilla::Util qw(check_git parse_options);
  
  sub run {
      my ($self, @args) = @_;
  
      my $release   = 0;
      my $author    = 1;
      my $automated = 0;
      my $all       = 0;
  
      check_git;
  
      parse_options(
          \@args,
          'release!'   => \$release,
          'author!'    => \$author,
          'automated!' => \$automated,
          'all!'       => \$all,
      );
  
      if ($all) {
          $release = $author = $automated = 1;
      }
  
      my $project = Minilla::Project->new();
      $project->verify_prereqs( );
  
      $ENV{RELEASE_TESTING}   =1 if $release;
      $ENV{AUTHOR_TESTING}    =1 if $author;
      $ENV{AUTOMATED_TESTING} =1 if $automated;
  
      my $work_dir = $project->work_dir;
      my $code = $work_dir->dist_test();
      exit $code;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Minilla::CLI::Test - Run test cases
  
  =head1 SYNOPSIS
  
      % minil test
  
          --release      enables the RELEASE_TESTING env variable
          --automated    enables the AUTOMATED_TESTING env variable
          --author       enables the AUTHOR_TESTING env variable (default
                         behavior)
          --all          enables the RELEASE_TESTING, AUTOMATED_TESTING and
                         AUTHOR_TESTING env variables
  
  =head1 DESCRIPTION
  
  This sub-command run test cases.
  
MINILLA_CLI_TEST

$fatpacked{"Minilla/Errors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_ERRORS';
  package Minilla::Errors;
  use strict;
  use warnings;
  use utf8;
  
  use Carp ();
  
  package Minilla::Error::CommandExit;
  
  use overload '""' => 'message', fallback => 1;
  
  sub throw {
      my ($class, $body) = @_;
      my $self = bless { body => $body, message => Carp::longmess($class) }, $class;
      die $self;
  }
  
  sub body { shift->{body} }
  
  sub message {
      my($self) = @_;
      return $self->{message};
  }
  
  1;
  
MINILLA_ERRORS

$fatpacked{"Minilla/FileGatherer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_FILEGATHERER';
  package Minilla::FileGatherer;
  use strict;
  use warnings;
  use utf8;
  use File::pushd;
  use File::Spec;
  use ExtUtils::Manifest 1.54 qw(maniskip);
  
  use Minilla::Git;
  
  use Moo;
  
  has exclude_match => (
      is => 'ro',
      default => sub { +[ ] },
  );
  
  has include_dotfiles => (
      is => 'ro',
      default => sub { undef },
  );
  
  no Moo;
  
  sub gather_files {
      my ($self, $root) = @_;
      my $guard = pushd($root);
      my @files = grep { _topdir($_) ne 'extlib' }
                  grep { not -l $_ }
                  map { File::Spec->abs2rel($_, $root) }
                  git_ls_files(), git_submodule_files();
      if ($self->exclude_match) {
          for my $pattern (@{$self->exclude_match || []}) {
              @files = grep { _normalize($_) !~ $pattern } @files;
          }
      }
  
      if (-f 'MANIFEST.SKIP') {
          my $skip = maniskip('MANIFEST.SKIP') ;
          @files = grep { !$skip->($_) } @files;
      }
      unless ($self->include_dotfiles) {
          @files = grep {
              !(grep { $_ =~ qr/^\./ } split m!/!, _normalize($_))
          } @files;
      }
      if ($^O eq 'MSWin32') {
          @files = map {
              my $x = $_;
              $x =~ s!\\!/!g;
              $x;
          } @files;
      }
  
      my @submodules = git_submodules;
      if (@submodules) {
          for my $filename (@submodules) {
              @files = grep { $_ ne $filename } @files;
          }
      }
  
      return @files;
  }
  
  sub _topdir {
      my ($path) = @_;
      [File::Spec->splitdir($path)]->[0] || '';
  }
  
  # for Windows
  sub _normalize {
      local $_ = shift;
      s!\\!/!g;
      $_;
  }
  
  1;
MINILLA_FILEGATHERER

$fatpacked{"Minilla/Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_GIT';
  package Minilla::Git;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Exporter);
  
  our @EXPORT = qw(git_ls_files git_init git_add git_rm git_commit git_config git_remote git_submodule_add git_submodules git_submodule_files);
  
  use Minilla::Util qw(cmd);
  
  sub git_init {
      cmd('git', 'init');
  }
  
  sub git_add {
      cmd('git', 'add', @_ ? @_ : '.');
  }
  
  sub git_config {
      cmd('git', 'config', @_ ? @_ : '.');
  }
  
  sub git_rm {
      cmd('git', 'rm', @_);
  }
  
  sub git_commit {
      cmd('git', 'commit', @_);
  }
  
  sub git_remote {
      cmd('git', 'remote', @_);
  }
  
  sub git_ls_files {
      my @files = split /\0/, `git ls-files -z`;
      return @files;
  }
  
  sub git_submodule_add {
      cmd('git', 'submodule', 'add', @_);
  }
  
  sub git_submodules {
      my @submodules = split /\n/, `git submodule status --recursive`;
      my @files;
      for (@submodules) {
          my ($path) = $_ =~ /^[+\-U\x20][0-9a-f]{40}\x20([^\x20]+).*$/;
          push @files, $path if $path;
      }
      return @files;
  }
  
  sub git_submodule_files {
      # XXX: `git ls-files -z` does *NOT* print new line in last.
      #      So it breaks format when multiple submodules contains and combined with `git submodule foreach`. (and failed to parse.)
      my @output = split /\n/, `git submodule foreach --recursive git ls-files -z`;
      for (my $i = 1; $i <= @output-2; $i += 2) {
          $output[$i] =~ s/\0([^\0]*)$//;
          splice @output, $i+1, 0, $1;
      }
  
      my @files;
      while (@output) {
          my $submodule_line = shift @output;
          my ($submodule_name) = $submodule_line =~ /'(.+)'/;
          push @files, map "$submodule_name/$_", split /\0/, shift @output;
      }
      return @files;
  }
  
  1;
  
MINILLA_GIT

$fatpacked{"Minilla/Gitignore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_GITIGNORE';
  package Minilla::Gitignore;
  use strict;
  use warnings;
  use utf8;
  
  use Moo;
  
  has lines => (
      is => 'rw',
      default => sub { +[ ] },
  );
  
  no Moo;
  
  sub load {
      my ($class, $filename) = @_;
  
      open my $fh, '<', $filename 
          or die "Cannot open $filename: $!";
      my @lines;
      while (defined($_ = <$fh>)) {
          chomp;
          push @lines, $_;
      }
  
      return $class->new(
          lines => [@lines],
      );
  }
  
  sub remove {
      my ($self, $pattern) = @_;
      if (ref $pattern) {
          $self->lines([grep { $_ !~ $pattern } @{$self->lines}]);
      } else {
          $self->lines([grep { $_ ne $pattern } @{$self->lines}]);
      }
  }
  
  sub add {
      my ($self, $pattern) = @_;
  
      unless (grep { $pattern eq $_ } @{$self->lines}) {
          push @{$self->lines}, $pattern;
      }
  }
  
  sub as_string {
      my $self = shift;
      return join('', map { "$_\n" } @{$self->lines});
  }
  
  sub save {
      my ($self, $filename) = @_;
      open my $fh, '>', $filename
          or die "Cannot open $filename: $!";
      for (@{$self->lines}) {
          print {$fh} $_, "\n";
      }
      close $fh;
  }
  
  1;
  
MINILLA_GITIGNORE

$fatpacked{"Minilla/License/Perl_5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_LICENSE_PERL_5';
  package Minilla::License::Perl_5;
  use strict;
  use warnings;
  use utf8;
  use Time::Piece;
  
  use Moo;
  
  has holder => (
      is => 'rw',
      required => 1,
  );
  
  no Moo;
  
  sub name { 'the same terms as the perl 5 programming language system itself' }
  sub url  { 'http://dev.perl.org/licenses/' }
  sub meta_name  { 'perl' }
  sub meta2_name { 'perl_5' }
  
  sub fulltext {
      my ($self) = @_;
  
      my $year = localtime->year;
      my $holder = $self->holder;
      <<"...";
  This software is copyright (c) $year by $holder.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  Terms of the Perl programming language system itself
  
  a) the GNU General Public License as published by the Free
     Software Foundation; either version 1, or (at your option) any
     later version, or
  b) the "Artistic License"
  
  --- The GNU General Public License, Version 1, February 1989 ---
  
  This software is Copyright (c) $year by $holder.
  
  This is free software, licensed under:
  
    The GNU General Public License, Version 1, February 1989
  
                      GNU GENERAL PUBLIC LICENSE
                       Version 1, February 1989
  
   Copyright (C) 1989 Free Software Foundation, Inc.
   51 Franklin St, Suite 500, Boston, MA  02110-1335  USA
  
   Everyone is permitted to copy and distribute verbatim copies
   of this license document, but changing it is not allowed.
  
                              Preamble
  
    The license agreements of most software companies try to keep users
  at the mercy of those companies.  By contrast, our General Public
  License is intended to guarantee your freedom to share and change free
  software--to make sure the software is free for all its users.  The
  General Public License applies to the Free Software Foundation's
  software and to any other program whose authors commit to using it.
  You can use it for your programs, too.
  
    When we speak of free software, we are referring to freedom, not
  price.  Specifically, the General Public License is designed to make
  sure that you have the freedom to give away or sell copies of free
  software, that you receive source code or can get it if you want it,
  that you can change the software or use pieces of it in new free
  programs; and that you know you can do these things.
  
    To protect your rights, we need to make restrictions that forbid
  anyone to deny you these rights or to ask you to surrender the rights.
  These restrictions translate to certain responsibilities for you if you
  distribute copies of the software, or if you modify it.
  
    For example, if you distribute copies of a such a program, whether
  gratis or for a fee, you must give the recipients all the rights that
  you have.  You must make sure that they, too, receive or can get the
  source code.  And you must tell them their rights.
  
    We protect your rights with two steps: (1) copyright the software, and
  (2) offer you this license which gives you legal permission to copy,
  distribute and/or modify the software.
  
    Also, for each author's protection and ours, we want to make certain
  that everyone understands that there is no warranty for this free
  software.  If the software is modified by someone else and passed on, we
  want its recipients to know that what they have is not the original, so
  that any problems introduced by others will not reflect on the original
  authors' reputations.
  
    The precise terms and conditions for copying, distribution and
  modification follow.
  
                      GNU GENERAL PUBLIC LICENSE
     TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  
    0. This License Agreement applies to any program or other work which
  contains a notice placed by the copyright holder saying it may be
  distributed under the terms of this General Public License.  The
  "Program", below, refers to any such program or work, and a "work based
  on the Program" means either the Program or any work containing the
  Program or a portion of it, either verbatim or with modifications.  Each
  licensee is addressed as "you".
  
    1. You may copy and distribute verbatim copies of the Program's source
  code as you receive it, in any medium, provided that you conspicuously and
  appropriately publish on each copy an appropriate copyright notice and
  disclaimer of warranty; keep intact all the notices that refer to this
  General Public License and to the absence of any warranty; and give any
  other recipients of the Program a copy of this General Public License
  along with the Program.  You may charge a fee for the physical act of
  transferring a copy.
  
    2. You may modify your copy or copies of the Program or any portion of
  it, and copy and distribute such modifications under the terms of Paragraph
  1 above, provided that you also do the following:
  
      a) cause the modified files to carry prominent notices stating that
      you changed the files and the date of any change; and
  
      b) cause the whole of any work that you distribute or publish, that
      in whole or in part contains the Program or any part thereof, either
      with or without modifications, to be licensed at no charge to all
      third parties under the terms of this General Public License (except
      that you may choose to grant warranty protection to some or all
      third parties, at your option).
  
      c) If the modified program normally reads commands interactively when
      run, you must cause it, when started running for such interactive use
      in the simplest and most usual way, to print or display an
      announcement including an appropriate copyright notice and a notice
      that there is no warranty (or else, saying that you provide a
      warranty) and that users may redistribute the program under these
      conditions, and telling the user how to view a copy of this General
      Public License.
  
      d) You may charge a fee for the physical act of transferring a
      copy, and you may at your option offer warranty protection in
      exchange for a fee.
  
  Mere aggregation of another independent work with the Program (or its
  derivative) on a volume of a storage or distribution medium does not bring
  the other work under the scope of these terms.
  
    3. You may copy and distribute the Program (or a portion or derivative of
  it, under Paragraph 2) in object code or executable form under the terms of
  Paragraphs 1 and 2 above provided that you also do one of the following:
  
      a) accompany it with the complete corresponding machine-readable
      source code, which must be distributed under the terms of
      Paragraphs 1 and 2 above; or,
  
      b) accompany it with a written offer, valid for at least three
      years, to give any third party free (except for a nominal charge
      for the cost of distribution) a complete machine-readable copy of the
      corresponding source code, to be distributed under the terms of
      Paragraphs 1 and 2 above; or,
  
      c) accompany it with the information you received as to where the
      corresponding source code may be obtained.  (This alternative is
      allowed only for noncommercial distribution and only if you
      received the program in object code or executable form alone.)
  
  Source code for a work means the preferred form of the work for making
  modifications to it.  For an executable file, complete source code means
  all the source code for all modules it contains; but, as a special
  exception, it need not include source code for modules which are standard
  libraries that accompany the operating system on which the executable
  file runs, or for standard header files or definitions files that
  accompany that operating system.
  
    4. You may not copy, modify, sublicense, distribute or transfer the
  Program except as expressly provided under this General Public License.
  Any attempt otherwise to copy, modify, sublicense, distribute or transfer
  the Program is void, and will automatically terminate your rights to use
  the Program under this License.  However, parties who have received
  copies, or rights to use copies, from you under this General Public
  License will not have their licenses terminated so long as such parties
  remain in full compliance.
  
    5. By copying, distributing or modifying the Program (or any work based
  on the Program) you indicate your acceptance of this license to do so,
  and all its terms and conditions.
  
    6. Each time you redistribute the Program (or any work based on the
  Program), the recipient automatically receives a license from the original
  licensor to copy, distribute or modify the Program subject to these
  terms and conditions.  You may not impose any further restrictions on the
  recipients' exercise of the rights granted herein.
  
    7. The Free Software Foundation may publish revised and/or new versions
  of the General Public License from time to time.  Such new versions will
  be similar in spirit to the present version, but may differ in detail to
  address new problems or concerns.
  
  Each version is given a distinguishing version number.  If the Program
  specifies a version number of the license which applies to it and "any
  later version", you have the option of following the terms and conditions
  either of that version or of any later version published by the Free
  Software Foundation.  If the Program does not specify a version number of
  the license, you may choose any version ever published by the Free Software
  Foundation.
  
    8. If you wish to incorporate parts of the Program into other free
  programs whose distribution conditions are different, write to the author
  to ask for permission.  For software which is copyrighted by the Free
  Software Foundation, write to the Free Software Foundation; we sometimes
  make exceptions for this.  Our decision will be guided by the two goals
  of preserving the free status of all derivatives of our free software and
  of promoting the sharing and reuse of software generally.
  
                              NO WARRANTY
  
    9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
  REPAIR OR CORRECTION.
  
    10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGES.
  
                       END OF TERMS AND CONDITIONS
  
          Appendix: How to Apply These Terms to Your New Programs
  
    If you develop a new program, and you want it to be of the greatest
  possible use to humanity, the best way to achieve this is to make it
  free software which everyone can redistribute and change under these
  terms.
  
    To do so, attach the following notices to the program.  It is safest to
  attach them to the start of each source file to most effectively convey
  the exclusion of warranty; and each file should have at least the
  "copyright" line and a pointer to where the full notice is found.
  
      <one line to give the program's name and a brief idea of what it does.>
      Copyright (C) 19yy  <name of author>
  
      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation; either version 1, or (at your option)
      any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
  
  
  Also add information on how to contact you by electronic and paper mail.
  
  If the program is interactive, make it output a short notice like this
  when it starts in an interactive mode:
  
      Gnomovision version 69, Copyright (C) 19xx name of author
      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
      This is free software, and you are welcome to redistribute it
      under certain conditions; type `show c' for details.
  
  The hypothetical commands `show w' and `show c' should show the
  appropriate parts of the General Public License.  Of course, the
  commands you use may be called something other than `show w' and `show
  c'; they could even be mouse-clicks or menu items--whatever suits your
  program.
  
  You should also get your employer (if you work as a programmer) or your
  school, if any, to sign a "copyright disclaimer" for the program, if
  necessary.  Here a sample; alter the names:
  
    Yoyodyne, Inc., hereby disclaims all copyright interest in the
    program `Gnomovision' (a program to direct compilers to make passes
    at assemblers) written by James Hacker.
  
    <signature of Ty Coon>, 1 April 1989
    Ty Coon, President of Vice
  
  That's all there is to it!
  
  
  --- The Artistic License 1.0 ---
  
  This software is Copyright (c) $year by $holder.
  
  This is free software, licensed under:
  
    The Artistic License 1.0
  
  The Artistic License
  
  Preamble
  
  The intent of this document is to state the conditions under which a Package
  may be copied, such that the Copyright Holder maintains some semblance of
  artistic control over the development of the package, while giving the users of
  the package the right to use and distribute the Package in a more-or-less
  customary fashion, plus the right to make reasonable modifications.
  
  Definitions:
  
    - "Package" refers to the collection of files distributed by the Copyright
      Holder, and derivatives of that collection of files created through
      textual modification. 
    - "Standard Version" refers to such a Package if it has not been modified,
      or has been modified in accordance with the wishes of the Copyright
      Holder. 
    - "Copyright Holder" is whoever is named in the copyright or copyrights for
      the package. 
    - "You" is you, if you're thinking about copying or distributing this Package.
    - "Reasonable copying fee" is whatever you can justify on the basis of media
      cost, duplication charges, time of people involved, and so on. (You will
      not be required to justify it to the Copyright Holder, but only to the
      computing community at large as a market that must bear the fee.) 
    - "Freely Available" means that no fee is charged for the item itself, though
      there may be fees involved in handling the item. It also means that
      recipients of the item may redistribute it under the same conditions they
      received it. 
  
  1. You may make and give away verbatim copies of the source form of the
  Standard Version of this Package without restriction, provided that you
  duplicate all of the original copyright notices and associated disclaimers.
  
  2. You may apply bug fixes, portability fixes and other modifications derived
  from the Public Domain or from the Copyright Holder. A Package modified in such
  a way shall still be considered the Standard Version.
  
  3. You may otherwise modify your copy of this Package in any way, provided that
  you insert a prominent notice in each changed file stating how and when you
  changed that file, and provided that you do at least ONE of the following:
  
    a) place your modifications in the Public Domain or otherwise make them
       Freely Available, such as by posting said modifications to Usenet or an
       equivalent medium, or placing the modifications on a major archive site
       such as ftp.uu.net, or by allowing the Copyright Holder to include your
       modifications in the Standard Version of the Package.
  
    b) use the modified Package only within your corporation or organization.
  
    c) rename any non-standard executables so the names do not conflict with
       standard executables, which must also be provided, and provide a separate
       manual page for each non-standard executable that clearly documents how it
       differs from the Standard Version.
  
    d) make other distribution arrangements with the Copyright Holder.
  
  4. You may distribute the programs of this Package in object code or executable
  form, provided that you do at least ONE of the following:
  
    a) distribute a Standard Version of the executables and library files,
       together with instructions (in the manual page or equivalent) on where to
       get the Standard Version.
  
    b) accompany the distribution with the machine-readable source of the Package
       with your modifications.
  
    c) accompany any non-standard executables with their corresponding Standard
       Version executables, giving the non-standard executables non-standard
       names, and clearly documenting the differences in manual pages (or
       equivalent), together with instructions on where to get the Standard
       Version.
  
    d) make other distribution arrangements with the Copyright Holder.
  
  5. You may charge a reasonable copying fee for any distribution of this
  Package.  You may charge any fee you choose for support of this Package. You
  may not charge a fee for this Package itself. However, you may distribute this
  Package in aggregate with other (possibly commercial) programs as part of a
  larger (possibly commercial) software distribution provided that you do not
  advertise this Package as a product of your own.
  
  6. The scripts and library files supplied as input to or produced as output
  from the programs of this Package do not automatically fall under the copyright
  of this Package, but belong to whomever generated them, and may be sold
  commercially, and may be aggregated with this Package.
  
  7. C or perl subroutines supplied by you and linked into this Package shall not
  be considered part of this Package.
  
  8. The name of the Copyright Holder may not be used to endorse or promote
  products derived from this software without specific prior written permission.
  
  9. THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  The End
  ...
  }
  
  1;
  
MINILLA_LICENSE_PERL_5

$fatpacked{"Minilla/License/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_LICENSE_UNKNOWN';
  package Minilla::License::Unknown;
  use strict;
  use warnings;
  use utf8;
  
  use Moo;
  
  has holder => (
      is => 'rw',
      required => 1,
  );
  
  no Moo;
  
  sub name { 'Unknown license' }
  sub url  { 'http://example.com' }
  sub meta_name  { 'unknown' }
  sub meta2_name { 'unknown' }
  
  sub fulltext {
      my ($self) = @_;
      return "Minilla cannot detect license terms.";
  }
  
  1;
  
MINILLA_LICENSE_UNKNOWN

$fatpacked{"Minilla/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_LOGGER';
  package Minilla::Logger;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use Term::ANSIColor qw(colored);
  require Win32::Console::ANSI if $^O eq 'MSWin32';
  
  use Minilla::Errors;
  
  our @EXPORT = qw(debugf infof warnf errorf);
  
  our $COLOR;
  
  use constant { DEBUG => 1, INFO => 2, WARN => 3, ERROR => 4 };
  
  our $Colors = {
      DEBUG,   => 'green',
      WARN,    => 'yellow',
      INFO,    => 'cyan',
      ERROR,   => 'red',
  };
  
  sub _printf {
      my $type = pop;
      my($temp, @args) = @_;
      _print(sprintf($temp, map { defined($_) ? $_ : '-' } @args), $type);
  }
  
  sub _print {
      my($msg, $type) = @_;
      return if $type == DEBUG && !Minilla->debug;
      $msg = colored $msg, $Colors->{$type} if defined $type && $COLOR;
      my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
      print {$fh} $msg;
  }
  
  sub infof {
      _printf(@_, INFO);
  }
  
  sub warnf {
      _printf(@_, WARN);
  }
  
  sub debugf {
      _printf(@_, DEBUG);
  }
  
  sub errorf {
      my(@msg) = @_;
      _printf(@msg, ERROR);
  
      my $fmt = shift @msg;
      Minilla::Error::CommandExit->throw(sprintf($fmt, @msg));
  }
  
  1;
  
MINILLA_LOGGER

$fatpacked{"Minilla/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_METADATA';
  package Minilla::Metadata;
  use strict;
  use warnings;
  use utf8;
  use Minilla::Util qw(slurp slurp_utf8 require_optional);
  use Carp;
  use Module::Metadata;
  use Minilla::License::Perl_5;
  use Pod::Escapes;
  
  use Moo;
  
  has [qw(abstract perl_version authors license)] => (
      is => 'lazy',
  );
  
  has '_license_name' => (
      is => 'ro',
  );
  
  has metadata => (
      is => 'lazy',
      handles => [qw(name version)],
  );
  
  has source => (
      is => 'rw',
      isa => sub {
          defined $_[0] or Carp::confess("source should not be undef");
          -f $_[0] or Carp::confess("source file not found: '$_[0]'");
      },
      required => 1,
  );
  
  no Moo;
  
  sub _build_metadata {
      my $self = shift;
      Module::Metadata->new_from_file($self->source, collect_pod => 1);
  }
  
  # Taken from Module::Install::Metadata
  sub _build_abstract {
      my ($self) = @_;
  
      # find by EU::MM
      {
          require ExtUtils::MM_Unix;
          my $abstract = bless( { DISTNAME => $self->name }, 'ExtUtils::MM_Unix' )->parse_abstract($self->source);
          return $abstract if $abstract;
      }
      # Parsing pod with Module::Metadata
      {
          my $name = $self->metadata->pod('NAME');
          if (defined $name) {
              $name =~ s/^\s+//gxsm;
              $name =~ s/\s+$//gxsm;
              my ($pkg, $abstract) = split /\s+-\s+/, $name, 2;
              return $abstract if $abstract;
          }
      }
      # find dzil style '# ABSTRACT: '
      {
          if (slurp($self->source) =~ /^\s*#+\s*ABSTRACT:\s*(.+)$/m) {
              return $1;
          }
      }
      return;
  }
  
  sub _extract_perl_version {
      if (
          $_[0] =~ m/
          ^\s*
          (?:use|require) \s*
          v?
          ([\d_\.]+)
          \s* ;
          /ixms
      ) {
          my $perl_version = $1;
          $perl_version =~ s{_}{}g;
          return $perl_version;
      } else {
          return;
      }
  }
   
  sub _build_perl_version {
      my ($self) = @_;
  
      my $perl_version = _extract_perl_version(slurp($self->source));
      if ($perl_version) {
          return $perl_version;
      } else {
          return;
      }
  }
  
  sub _build_authors {
      my ($self) = @_;
  
      my $content = slurp_utf8($self->source);
      if ($content =~ m/
          =head \d \s+ (?:authors?)\b \s*
          ([^\n]*)
          |
          =head \d \s+ (?:licen[cs]e|licensing|copyright|legal)\b \s*
          .*? copyright .*? \d\d\d[\d.]+ \s* (?:\bby\b)? \s*
          ([^\n]*)
      /ixms) {
          my $author = $1 || $2;
   
          $author =~ s{ E<( (\d+) | ([A-Za-z]+) )> }{
              defined $2
              ? chr($2)
              : defined $Pod::Escapes::Name2character_number{$1}
              ? chr($Pod::Escapes::Name2character_number{$1})
              : do {
                  warn "Unknown escape: E<$1>";
                  "E<$1>";
              };
          }gex;
  
          my @authors;
          for (split /\n/, $author) {
              chomp;
              next unless /\S/;
              push @authors, $_;
          }
          return \@authors;
      } else {
          warn "Cannot determine author info from @{[ $_[0]->source ]}\n";
          return undef;
      }
  }
  
  
  #Stolen from M::B
  sub _is_perl5_license {
      my $pod = shift;
      my $matched;
      return __extract_license(
          ($matched) = $pod =~ m/
              (=head \d \s+ L(?i:ICEN[CS]E|ICENSING)\b.*?)
              (=head \d.*|=cut.*|)\z
          /xms
      ) || __extract_license(
          ($matched) = $pod =~ m/
              (=head \d \s+ (?:C(?i:OPYRIGHTS?)|L(?i:EGAL))\b.*?)
              (=head \d.*|=cut.*|)\z
          /xms
      );
  }
   
  sub __extract_license {
      my $license_text = shift or return;
      my @phrases      = (
          '(?:under )?the same (?:terms|license) as (?:perl|the perl (?:\d )?programming language)',
          '(?:under )?the terms of (?:perl|the perl programming language) itself',
          'Artistic and GPL'
      );
      for my $pattern (@phrases) {
          $pattern =~ s#\s+#\\s+#gs;
          if ( $license_text =~ /\b$pattern\b/i ) {
              return 1;
          }
      }
      return 0;
  }
  
  sub _guess_license_class_by_name {
      my ($name) = @_;
  
      if ($name eq 'Perl_5') {
          return 'Minilla::License::Perl_5'
      } else {
          my %license_map = (
              'agpl_3'       => 'Software::License::AGPL_3',
              'apache_1_1'   => 'Software::License::Apache_1_1',
              'apache_2_0'   => 'Software::License::Apache_2_0',
              'artistic_1'   => 'Software::License::Artistic_1_0',
              'artistic_2'   => 'Software::License::Artistic_2_0',
              'bsd'          => 'Software::License::BSD',
              'unrestricted' => 'Software::License::CC0_1_0',
              'custom'       => 'Software::License::Custom',
              'freebsd'      => 'Software::License::FreeBSD',
              'gfdl_1_2'     => 'Software::License::GFDL_1_2',
              'gfdl_1_3'     => 'Software::License::GFDL_1_3',
              'gpl_1'        => 'Software::License::GPL_1',
              'gpl_2'        => 'Software::License::GPL_2',
              'gpl_3'        => 'Software::License::GPL_3',
              'lgpl_2_1'     => 'Software::License::LGPL_2_1',
              'lgpl_3_0'     => 'Software::License::LGPL_3_0',
              'mit'          => 'Software::License::MIT',
              'mozilla_1_0'  => 'Software::License::Mozilla_1_0',
              'mozilla_1_1'  => 'Software::License::Mozilla_1_1',
              'open_source'  => 'Software::License::Mozilla_2_0',
              'restricted'   => 'Software::License::None',
              'openssl'      => 'Software::License::OpenSSL',
              'perl_5'       => 'Software::License::Perl_5',
              'open_source'  => 'Software::License::PostgreSQL',
              'qpl_1_0'      => 'Software::License::QPL_1_0',
              'ssleay'       => 'Software::License::SSLeay',
              'sun'          => 'Software::License::Sun',
              'zlib'         => 'Software::License::Zlib',
          );
          if (my $klass = $license_map{$name}) {
              eval "require $klass; 1" or die "$klass is required for supporting $name license. But: $@"; ## no critic.
              return $klass;
          } else {
              die "'$name' is not supported yet. Supported licenses are: " . join(', ', keys %license_map);
          }
      }
  }
  
  sub _build_license {
      my ($self) = @_;
  
      my $pm_text = slurp($self->source);
      my $holder = $self->authors ? $self->authors->[0] : 'Unknown';
      if ($self->_license_name) {
          _guess_license_class_by_name($self->_license_name)->new({
              holder => $holder,
          });
      } elsif (_is_perl5_license($pm_text)) {
          require Minilla::License::Perl_5;
          return Minilla::License::Perl_5->new({
              holder => $holder,
          });
      } else {
          if (eval "require Software::LicenseUtils; 1") {
              my (@guesses) = Software::LicenseUtils->guess_license_from_pod($pm_text);
              if (@guesses) {
                  my $klass = $guesses[0];
                  eval "require $klass; 1" or die $@; ## no critic.
                  $klass->new({
                      holder => $holder,
                  });
              } else {
                  warn "Cannot determine license info from @{[ $_[0]->source ]}\n";
                  require Minilla::License::Unknown;
                  return Minilla::License::Unknown->new({
                      holder => $holder,
                  });
              }
          } else {
              warn "Software::License is needed when you want to use non Perl_5 license.\n";
              require Minilla::License::Unknown;
              return Minilla::License::Unknown->new({
                  holder => $holder,
              });
          }
      }
  }
  
  1;
  
MINILLA_METADATA

$fatpacked{"Minilla/Migrate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_MIGRATE';
  package Minilla::Migrate;
  use strict;
  use warnings;
  use utf8;
  
  use File::pushd;
  use CPAN::Meta;
  use File::Find ();
  use TOML 0.92 qw(to_toml);
  use Config;
  
  use Minilla::Gitignore;
  use Minilla::Util qw(
      slurp spew require_optional
      cmd cmd_perl slurp_utf8 spew_utf8
      slurp_raw spew_raw
  );
  use Minilla::Logger;
  use Minilla::Git;
  use Minilla::Project;
  
  use Moo;
  
  has project => (
      is => 'lazy',
  );
  
  no Moo;
  
  sub _build_project {
      my $self = shift;
      Minilla::Project->new();
  }
  
  sub run {
      my $self = shift;
  
      if (!-d '.git') {
          # init git repo
          infof("Initializing git\n");
          cmd('git', 'init');
      }
  
      my $guard = pushd($self->project->dir);
  
      # Generate cpanfile from Build.PL/Makefile.PL
      unless (-f 'cpanfile') {
          $self->migrate_cpanfile();
      }
  
      $self->generate_license();
  
      # TODO move top level *.pm to lib/?
  
      if (-f 'dist.ini') {
          $self->dist_ini2minil_toml();
      } elsif (!-f 'minil.toml') {
          $self->project->generate_minil_toml('Default');
      }
  
      $self->remove_unused_files();
      $self->migrate_gitignore();
      $self->project->regenerate_files();
      $self->migrate_changes();
  
      git_add('.');
  }
  
  sub migrate_changes {
      my $self = shift;
  
      if (-f 'Changes') {
          # Q. Why :raw?
          # A. It's for windows. See dzil.
          my $content = slurp_raw('Changes');
          unless ($content =~ qr!\{\{\$NEXT\}\}!) {
              $content =~ s!^(Revision history for Perl extension \S+\n\n)!$1\{\{\$NEXT\}\}\n\n!;
          }
          spew_raw('Changes', $content);
      } else {
          # Q. Why :raw?
          # A. It's for windows. See dzil.
          require Minilla::Profile::Default;
          Minilla::Profile::Default->new_from_project(
              $self->project
          )->render('Changes');
      }
  }
  
  sub rm {
      my ($self, $file) = @_;
  }
  
  sub dist_ini2minil_toml {
      my $self = shift;
  
      infof("Converting dist.ini to minil.toml\n");
  
      require_optional( 'Config/MVP/Reader/INI.pm', 'Migrate dzil repo' );
      require_optional( 'Dist/Zilla/MVP/Assembler.pm', 'Migrate dzil repo' );
      require_optional( 'Dist/Zilla/Chrome/Term.pm', 'Migrate dzil repo' );
      my $sequence = Config::MVP::Reader::INI->read_into_assembler(
          'dist.ini',
          Dist::Zilla::MVP::Assembler->new(
              chrome => Dist::Zilla::Chrome::Term->new(),
          )
      );
      my $conf = do {
          # Note. dist.ini using @Milla does not have '_' section.
          my $section = $sequence->section_named('_');
          $section ? $section->payload : +{};
      };
  
      my $dst = +{};
      for my $key (qw(name author version license)) {
          if ( defined(my $val = $conf->{$key}) ) {
              $dst->{$key} = $val;
          }
      }
      if (%$dst) {
          my $toml = to_toml($dst);
          spew( 'minil.toml' => $toml );
          git_add('minil.toml');
      }
      git_rm('--quiet', 'dist.ini');
  
      $self->project->clear_metadata();
  }
  
  sub generate_license {
      my ($self) = @_;
  
      unless (-f 'LICENSE') {
          spew_raw('LICENSE', $self->project->metadata->license->fulltext());
          git_add(qw(-f LICENSE));
      }
  }
  
  sub migrate_cpanfile {
      my ($self) = @_;
  
      my $metafile;
      if (-f 'Build.PL') {
          if (slurp('Build.PL') =~ /Module::Build::Tiny/) {
              infof("M::B::Tiny was detected. I hope META.json is already exists here\n");
              $metafile = 'META.json';
          } else {
              cmd_perl('Build.PL');
              $metafile = 'MYMETA.json';
          }
      } elsif (-f 'Makefile.PL') {
          # ExtUtils::MakeMaker or Module::Install's
          cmd_perl('Makefile.PL');
          cmd($Config{make}, 'metafile');
          $metafile = 'MYMETA.json';
      } elsif (-f 'dist.ini') {
          my %orig = map { $_ => 1 } glob('*/META.yml');
          cmd_perl('-S', 'dzil', 'build');
          ($metafile) = grep { !$orig{$_} } glob('*/META.yml');
      } else {
          errorf("There is no Build.PL/Makefile.PL/dist.ini: %s\n", Cwd::getcwd());
      }
  
      unless (defined($metafile) && -f $metafile) {
          errorf("Build.PL/Makefile.PL does not generates %s\n", $metafile);
      }
  
      my $meta = CPAN::Meta->load_file($metafile);
      my $prereqs = $meta->effective_prereqs->as_string_hash;
  
      infof("Using Module::Build (Because this distribution uses xs)\n");
      delete $prereqs->{configure}->{requires}->{'ExtUtils::MakeMaker'};
      delete $prereqs->{configure}->{requires}->{'Module::Build'};
      delete $prereqs->{configure}->{requires}->{'Module::Build::Tiny'};
  
      my $cpanfile = Module::CPANfile->from_prereqs($prereqs);
      spew('cpanfile', $cpanfile->to_string);
  
      git_add('cpanfile');
  }
  
  sub remove_unused_files {
      my $self = shift;
  
      # Some users put a README.pod symlink for main module.
      # But it's duplicated to README.md created by Minilla.
  
      # remove some unusable files
      for my $file (qw(
          Makefile.PL
          MANIFEST
          MANIFEST.SKIP
          .shipit
          xt/97_podspell.t
          xt/99_pod.t
          xt/01_podspell.t    xt/03_pod.t              xt/05_cpan_meta.t
          xt/04_minimum_version.t  xt/06_meta_author.t
          xt/podspell.t
          MANIFEST.SKIP.bak
          MANIFEST.bak
          README.pod
          META.yml
          README
          MYMETA.json
          MYMETA.yml
          inc/Module/Install.pm
      ), glob('inc/Module/Install/*.pm')) {
          if (-e $file) {
              if (grep { $_ eq $file } git_ls_files()) {
                  # committed file
                  git_rm('--quiet', $file);
              } else {
                  unlink $file;
              }
          }
      }
  }
  
  sub migrate_gitignore {
      my ($self) = @_;
  
      my @lines;
  
      my $gitignore = (
          -f '.gitignore'
          ? Minilla::Gitignore->load('.gitignore')
          : Minilla::Gitignore->new()
      );
      $gitignore->remove('META.json');
      $gitignore->remove('/META.json');
      $gitignore->remove('LICENSE');
  
      # Add some lines
      $gitignore->add(sprintf('/%s-*', $self->project->dist_name));
      for my $fname (qw(
          /.build
          /_build_params
          /Build
          /Build.bat
          !Build/
          !META.json
          !LICENSE
      )) {
          $gitignore->add($fname);
      }
  
      $gitignore->save('.gitignore');
  
      git_add(qw(.gitignore));
  }
  
  
  
  1;
  
MINILLA_MIGRATE

$fatpacked{"Minilla/ModuleMaker/ExtUtilsMakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_MODULEMAKER_EXTUTILSMAKEMAKER';
  package Minilla::ModuleMaker::ExtUtilsMakeMaker;
  use strict;
  use warnings;
  use utf8;
  use Data::Section::Simple qw(get_data_section);
  use Text::MicroTemplate qw(render_mt);
  use Data::Dumper;
  use File::Spec::Functions qw(catdir rel2abs);
  use File::Find ();
  use TAP::Harness::Env;
  
  # This module is EXPERIMENTAL.
  # You can use this. But I may change the behaviour...
  
  use Moo;
  
  no Moo;
  
  use Minilla::Util qw(spew_raw);
  
  sub generate {
      my ($self, $project) = @_;
  
      local $Data::Dumper::Terse = 1;
      local $Data::Dumper::Useqq = 1;
      local $Data::Dumper::Purity = 1;
      local $Data::Dumper::Indent = 1;
      local $Data::Dumper::Sortkeys = 1;
      my $content = get_data_section('Makefile.PL');
      my $mt = Text::MicroTemplate->new(template => $content, escape_func => sub { $_[0] });
      my $src = $mt->build->($project);
      spew_raw('Makefile.PL', $src);
  }
  
  sub prereqs {
      my ($self, $project) = @_;
  
      my %configure_requires = (
          'ExtUtils::MakeMaker' => '6.64', # TEST_REQUIRES (and MYMETA)
      );
  
      my $prereqs = +{
          configure => {
              requires => {
                  %configure_requires,
              }
          }
      };
  
      for my $key (qw(tap_harness_args use_xsutil c_source allow_pureperl requires_external_bin)) {
          if( $project->$key ){
              die "$key does not supported by " . __PACKAGE__;
          }
      }
      return $prereqs;
  }
  
  sub run_tests {
      my $harness = TAP::Harness::Env->create({
          verbosity => 0,
          lib       => [ map { rel2abs(catdir(qw/blib/, $_)) } qw/arch lib/ ],
          color     => -t STDOUT
      });
      my @tests = sort +_find(qr/\.t$/, 't');
      if ($ENV{RELEASE_TESTING}) {
          push @tests, sort +_find(qr/\.t$/, 'xt');
      }
      $harness->runtests(@tests)->has_errors and die;
  }
  
  sub _find {
      my ($pattern, $dir) = @_;
      my @ret;
      File::Find::find(sub { push @ret, $File::Find::name if /$pattern/ && -f }, $dir) if -d $dir;
      return @ret;
  }
  
  1;
  __DATA__
  
  @@ Makefile.PL
  ? my $project = shift;
  ? use Data::Dumper;
  # =========================================================================
  # THIS FILE IS AUTOMATICALLY GENERATED BY MINILLA.
  # DO NOT EDIT DIRECTLY.
  # =========================================================================
  
  use 5.006;
  use strict;
  
  use ExtUtils::MakeMaker 6.64;
  
  ? if ( @{ $project->requires_external_bin || [] } ) {
  use Devel::CheckBin;
  
  ?   for my $bin ( @{ $project->requires_external_bin } ) {
  check_bin('<?= $bin ?>');
  ?   }
  
  ? }
  
  ? my $prereqs = $project->cpan_meta->effective_prereqs;
  ? my $d = sub { Dumper($prereqs->merged_requirements([$_[0]], ['requires'])->as_string_hash) };
  my %WriteMakefileArgs = (
      NAME     => '<?= $project->name ?>',
      DISTNAME => '<?= $project->dist_name ?>',
      VERSION  => '<?= $project->version ?>',
      EXE_FILES => [<?= $project->script_files ?>],
      CONFIGURE_REQUIRES => <?= $d->('configure') ?>,
      BUILD_REQUIRES     => <?= $d->('build') ?>,
      TEST_REQUIRES      => <?= $d->('test') ?>,
      PREREQ_PM          => <?= $d->('runtime') ?>,
  );
  
  WriteMakefile(%WriteMakefileArgs);
MINILLA_MODULEMAKER_EXTUTILSMAKEMAKER

$fatpacked{"Minilla/ModuleMaker/ModuleBuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_MODULEMAKER_MODULEBUILD';
  package Minilla::ModuleMaker::ModuleBuild;
  use strict;
  use warnings;
  use utf8;
  use Data::Section::Simple qw(get_data_section);
  use Text::MicroTemplate qw(render_mt);
  use Data::Dumper;
  use Minilla::Util qw(cmd_perl);
  
  use Moo;
  
  no Moo;
  
  use Minilla::Util qw(spew_raw);
  
  sub generate {
      my ($self, $project) = @_;
  
      Carp::croak('Usage: $module_maker->generate($project)') unless defined $project;
  
      local $Data::Dumper::Terse = 1;
      local $Data::Dumper::Useqq = 1;
      local $Data::Dumper::Purity = 1;
      local $Data::Dumper::Indent = 0;
      my $content = get_data_section('Build.PL');
      my $mt = Text::MicroTemplate->new(template => $content, escape_func => sub { $_[0] });
      my $src = $mt->build->($project);
      spew_raw('Build.PL', $src);
  }
  
  sub prereqs {
      my ($self, $project) = @_;
  
      Carp::croak('Usage: $module_maker->prereqs($project)') unless defined $project;
  
      my %configure_requires = (
          'Module::Build'       => 0.4005, # test_requires, --pureperl
      );
      if ($project->requires_external_bin && @{$project->requires_external_bin}) {
          $configure_requires{'Devel::CheckBin'} = 0;
      }
  
      my $prereqs = +{
          configure => {
              requires => {
                  %configure_requires,
              }
          }
      };
  
      if( $project->use_xsutil ){
          $prereqs->{configure}{requires}{'Module::Build::XSUtil'} = '0.03';
      }
      return $prereqs;
  }
  
  sub run_tests {
      cmd_perl('Build', 'test');
  }
  
  1;
  __DATA__
  
  @@ Build.PL
  ? my $project = shift;
  ? use Data::Dumper;
  # =========================================================================
  # THIS FILE IS AUTOMATICALLY GENERATED BY MINILLA.
  # DO NOT EDIT DIRECTLY.
  # =========================================================================
  
  use 5.008_001;
  
  use strict;
  use warnings;
  use utf8;
  
  use <?= $project->build_class ?>;
  use File::Basename;
  use File::Spec;
  
  ? if ( @{ $project->requires_external_bin || [] } ) {
  use Devel::CheckBin;
  
  ?   for my $bin ( @{ $project->requires_external_bin } ) {
  check_bin('<?= $bin ?>');
  ?   }
  
  ? }
  my %args = (
      license              => '<?= $project->metadata->license->meta2_name ?>',
      dynamic_config       => 0,
  
      configure_requires => {
          'Module::Build' => '0.4005',
      },
  
      name            => '<?= $project->dist_name ?>',
      module_name     => '<?= $project->name ?>',
      allow_pureperl => <?= $project->allow_pureperl ?>,
  
      script_files => [<?= $project->script_files ?>],
      c_source     => [qw(<?= $project->c_source ?>)],
      PL_files => <?= Data::Dumper::Dumper($project->PL_files) ?>,
  
      test_files           => ((-d '.git' || $ENV{RELEASE_TESTING}) && -d 'xt') ? 't/ xt/' : 't/',
      recursive_test_files => 1,
  
  ? if( $project->tap_harness_args ){
      tap_harness_args => <?= Dumper($project->tap_harness_args) ?>,
  ? }
  
  ? if( $project->use_xsutil ){
      needs_compiler_c99 => <?= $project->needs_compiler_c99 ?>,
      needs_compiler_cpp => <?= $project->needs_compiler_cpp ?>,
      generate_ppport_h => '<?= $project->generate_ppport_h ?>',
      generate_xshelper_h => '<?= $project->generate_xshelper_h ?>',
      cc_warnings => <?= $project->cc_warnings ?>,
  ? }
  );
  if (-d 'share') {
      $args{share_dir} = 'share';
  }
  
  my $builder = <?= $project->build_class ?>->subclass(
      class => 'MyBuilder',
      code => q{
          sub ACTION_distmeta {
              die "Do not run distmeta. Install Minilla and `minil install` instead.\n";
          }
          sub ACTION_installdeps {
              die "Do not run installdeps. Run `cpanm --installdeps .` instead.\n";
          }
      }
  )->new(%args);
  $builder->create_build_script();
  
MINILLA_MODULEMAKER_MODULEBUILD

$fatpacked{"Minilla/ModuleMaker/ModuleBuildTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_MODULEMAKER_MODULEBUILDTINY';
  package Minilla::ModuleMaker::ModuleBuildTiny;
  use strict;
  use warnings;
  use utf8;
  use Data::Section::Simple qw(get_data_section);
  use Text::MicroTemplate qw(render_mt);
  use Data::Dumper;
  use File::Spec::Functions qw(catdir rel2abs);
  use File::Find ();
  use TAP::Harness::Env;
  
  use Moo;
  
  no Moo;
  
  use Minilla::Util qw(spew_raw);
  
  sub generate {
      my ($self, $project) = @_;
  
      local $Data::Dumper::Terse = 1;
      local $Data::Dumper::Useqq = 1;
      local $Data::Dumper::Purity = 1;
      local $Data::Dumper::Indent = 0;
      my $content = get_data_section('Build.PL');
      my $mt = Text::MicroTemplate->new(template => $content, escape_func => sub { $_[0] });
      my $src = $mt->build->($project);
      spew_raw('Build.PL', $src);
  }
  
  sub validate {
      my $self = shift;
  
      if (-d 'bin/') {
          warn "[ERROR] Module::Build::Tiny doesn't install bin/ directory. You should rename bin/ to script/\n";
          return 0;
      }
      return 1; # Yes. It's valid project.
  }
  
  sub prereqs {
      my ($self, $project) = @_;
  
      my %configure_requires = (
          'Module::Build::Tiny' => '0.035',
      );
      if ( @{$project->requires_external_bin || []} ) {
          $configure_requires{'Devel::CheckBin'} = 0;
      }
  
      my $prereqs = +{
          configure => {
              requires => {
                  %configure_requires,
              }
          }
      };
  
      for my $key (qw(tap_harness_args use_xsutil c_source allow_pureperl)) {
          if( $project->$key ){
              die "$key does not supported by " . __PACKAGE__;
          }
      }
      for my $key (qw(PL_files)) {
          if( $project->$key && ref($project->$key) eq 'HASH' && %{$project->$key} > 0 ){
              die "$key does not supported by " . __PACKAGE__;
          }
      }
      return $prereqs;
  }
  
  sub run_tests {
      my $harness = TAP::Harness::Env->create({
          verbosity => 0,
          lib       => [ map { rel2abs(catdir(qw/blib/, $_)) } qw/arch lib/ ],
          color     => -t STDOUT
      });
      my @tests = sort +_find(qr/\.t$/, 't');
      if ($ENV{RELEASE_TESTING}) {
          push @tests, sort +_find(qr/\.t$/, 'xt');
      }
      $harness->runtests(@tests)->has_errors and die;
  }
  
  sub _find {
      my ($pattern, $dir) = @_;
      my @ret;
      File::Find::find(sub { push @ret, $File::Find::name if /$pattern/ && -f }, $dir) if -d $dir;
      return @ret;
  }
  
  1;
  __DATA__
  
  @@ Build.PL
  ? my $project = shift;
  # =========================================================================
  # THIS FILE IS AUTOMATICALLY GENERATED BY MINILLA.
  # DO NOT EDIT DIRECTLY.
  # =========================================================================
  
  use 5.008_001;
  use strict;
  
  use Module::Build::Tiny 0.035;
  
  ? if ( @{ $project->requires_external_bin || [] } ) {
  use Devel::CheckBin;
  
  ?   for my $bin ( @{ $project->requires_external_bin } ) {
  check_bin('<?= $bin ?>');
  ?   }
  
  ? }
  Build_PL();
  
MINILLA_MODULEMAKER_MODULEBUILDTINY

$fatpacked{"Minilla/Profile/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROFILE_BASE';
  package Minilla::Profile::Base;
  use strict;
  use warnings;
  use utf8;
  use File::Spec::Functions qw(catfile);
  use File::Path qw(mkpath);
  use File::Basename qw(dirname);
  use Data::Section::Simple;
  use Time::Piece;
  
  use Minilla::Util qw(spew_raw);
  use Minilla::Logger;
  
  BEGIN { eval "use MRO::Compat;1" or die $@ if $] < 5.009_005 }
  
  use Moo;
  
  has [qw(dist path module)] => (
      is       => 'ro',
      required => 1,
  );
  
  has 'version' => (
      is       => 'ro',
      default  => sub { '0.01' },
  );
  
  has suffix => (
      is => 'lazy',
      required => 1,
  );
  
  has [qw(email author)] => (
      is => 'lazy',
      required => 1,
  );
  
  no Moo;
  
  sub _build_author {
      my $self = shift;
  
      my $name ||= `git config user.name`;
      $name =~ s/\n$//;
  
      unless ($name) {
          errorf("You need to set user.name in git config.\nRun: git config user.name 'Your name'\n");
      }
  
      $name;
  }
  
  sub _build_email {
      my $self = shift;
  
      my $email ||= `git config user.email`;
      $email =~ s/\n$//;
  
      unless ($email) {
          errorf("You need to set user.email in git config.\nRun: git config user.email 'name\@example.com'\n");
      }
  
      $email;
  }
  
  sub _build_suffix {
      my $self = shift;
      my $suffix = $self->path;
      $suffix =~ s!^.+/!!;
      $suffix =~ s!\.pm!!;
      $suffix;
  }
  
  sub new_from_project {
      my ($class, $project) = @_;
  
      my $path = $project->main_module_path;
      $path =~ s!^lib/!!;
      my $self = $class->new(
          dist    => $project->dist_name,
          author  => $project->authors ? $project->authors->[0] : 'Unknown Author',
          version => $project->version,
          path    => $path,
          module  => $project->name,
      );
      return $self;
  }
  
  sub date {
      gmtime->strftime('%Y-%m-%dT%H:%M:%SZ');
  }
  
  sub end { '__END__' }
  
  sub module_pm_src { '' }
  
  sub render {
      my ($self, $tmplname, $dst) = @_;
      my $path = $dst || $tmplname;
  
      infof("Writing %s\n", $path);
      mkpath(dirname($path));
  
      for my $pkg (@{mro::get_linear_isa(ref $self || $self)}) {
          my $content = Data::Section::Simple->new($pkg)->get_data_section($tmplname);
          next unless defined $content;
          $content =~ s!<%\s*\$([a-z_]+)\s*%>!
              $self->$1()
          !ge;
          spew_raw($path, $content);
          return;
      }
      errorf("Cannot find template for %s\n", $tmplname);
  }
  
  sub write_file {
      my ($self, $path, $content) = @_;
  
      infof("Writing %s\n", $path);
      mkpath(dirname($path));
      spew_raw($path, $content);
  }
  
  
  1;
  __DATA__
  
  @@ t/00_compile.t
  use strict;
  use Test::More 0.98;
  
  use_ok $_ for qw(
      <% $module %>
  );
  
  done_testing;
  
  @@ Module.pm
  package <% $module %>;
  use 5.008001;
  use strict;
  use warnings;
  
  our $VERSION = "<% $version %>";
  
  <% $module_pm_src %>
  
  1;
  <% $end %>
  
  =encoding utf-8
  
  =head1 NAME
  
  <% $module %> - It's new $module
  
  =head1 SYNOPSIS
  
      use <% $module %>;
  
  =head1 DESCRIPTION
  
  <% $module %> is ...
  
  =head1 LICENSE
  
  Copyright (C) <% $author %>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  <% $author %> E<lt><% $email %>E<gt>
  
  =cut
  
  @@ .travis.yml
  language: perl
  sudo: false
  perl:
    - "5.12"
    - "5.14"
    - "5.16"
    - "5.18"
    - "5.20"
  
  @@ Changes
  Revision history for Perl extension <% $dist %>
  
  {{$NEXT}}
  
      - original version
  
  @@ .gitignore
  /.build/
  /_build/
  /Build
  /Build.bat
  /blib
  /Makefile
  /pm_to_blib
  
  /carton.lock
  /.carton/
  /local/
  
  nytprof.out
  nytprof/
  
  cover_db/
  
  *.bak
  *.old
  *~
  *.swp
  *.o
  *.obj
  
  !LICENSE
  
  /_build_params
  
  MYMETA.*
  
  /<% $dist %>-*
MINILLA_PROFILE_BASE

$fatpacked{"Minilla/Profile/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROFILE_DEFAULT';
  package Minilla::Profile::Default;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Minilla::Profile::ModuleBuildTiny);
  
  # The default profile is Module::Build.
  
  1;
  __DATA__
MINILLA_PROFILE_DEFAULT

$fatpacked{"Minilla/Profile/ExtUtilsMakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROFILE_EXTUTILSMAKEMAKER';
  package Minilla::Profile::ExtUtilsMakeMaker;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Minilla::Profile::Base);
  
  use File::Spec::Functions qw(catfile);
  use File::Path qw(mkpath);
  use File::Basename qw(dirname);
  use CPAN::Meta;
  use Data::Section::Simple qw(get_data_section);
  use File::pushd;
  
  use Minilla::License::Perl_5;
  
  sub generate {
      my $self = shift;
  
      $self->render('Module.pm', catfile('lib', $self->path));
  
      $self->render('Changes');
      $self->render('t/00_compile.t');
      $self->render('.travis.yml');
  
      $self->render('.gitignore');
      $self->write_file('LICENSE', Minilla::License::Perl_5->new(
          holder => sprintf('%s <%s>', $self->author, $self->email)
      )->fulltext);
  
      $self->render('cpanfile');
  }
  
  1;
  __DATA__
  
  @@ cpanfile
  requires 'perl', '5.008001';
  
  on 'test' => sub {
      requires 'Test::More', '0.98';
  };
  
MINILLA_PROFILE_EXTUTILSMAKEMAKER

$fatpacked{"Minilla/Profile/ModuleBuild.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROFILE_MODULEBUILD';
  package Minilla::Profile::ModuleBuild;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Minilla::Profile::Base);
  
  use File::Spec::Functions qw(catfile);
  use File::Path qw(mkpath);
  use File::Basename qw(dirname);
  use CPAN::Meta;
  use Data::Section::Simple qw(get_data_section);
  use File::pushd;
  
  use Minilla::License::Perl_5;
  
  sub generate {
      my $self = shift;
  
      $self->render('Module.pm', catfile('lib', $self->path));
  
      $self->render('Changes');
      $self->render('t/00_compile.t');
      $self->render('.travis.yml');
  
      $self->render('.gitignore');
      $self->write_file('LICENSE', Minilla::License::Perl_5->new(
          holder => sprintf('%s <%s>', $self->author, $self->email)
      )->fulltext);
  
      $self->render('cpanfile');
  }
  
  1;
  __DATA__
  
  @@ cpanfile
  requires 'perl', '5.008001';
  
  on 'test' => sub {
      requires 'Test::More', '0.98';
  };
  
MINILLA_PROFILE_MODULEBUILD

$fatpacked{"Minilla/Profile/ModuleBuildTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROFILE_MODULEBUILDTINY';
  package Minilla::Profile::ModuleBuildTiny;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Minilla::Profile::Base);
  
  use File::Spec::Functions qw(catfile);
  use File::Path qw(mkpath);
  use File::Basename qw(dirname);
  use CPAN::Meta;
  use Data::Section::Simple qw(get_data_section);
  use File::pushd;
  
  use Minilla::License::Perl_5;
  
  sub generate {
      my $self = shift;
  
      $self->render('Module.pm', catfile('lib', $self->path));
  
      $self->render('Changes');
      $self->render('t/00_compile.t');
      $self->render('.travis.yml');
  
      $self->render('.gitignore');
      $self->write_file('LICENSE', Minilla::License::Perl_5->new(
          holder => sprintf('%s <%s>', $self->author, $self->email)
      )->fulltext);
  
      $self->render('cpanfile');
  }
  
  1;
  __DATA__
  
  @@ cpanfile
  requires 'perl', '5.008001';
  
  on 'test' => sub {
      requires 'Test::More', '0.98';
  };
  
MINILLA_PROFILE_MODULEBUILDTINY

$fatpacked{"Minilla/Profile/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROFILE_XS';
  package Minilla::Profile::XS;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Minilla::Profile::ModuleBuild);
  
  use File::Spec::Functions qw(catfile);
  use File::Basename qw(dirname);
  use Data::Section::Simple qw(get_data_section);
  
  use Minilla::Gitignore;
  use Minilla::Util qw(require_optional);
  use Minilla::Logger;
  
  sub module_pm_src {
      join("\n",
          'use XSLoader;',
          'XSLoader::load(__PACKAGE__, $VERSION);'
      );
  }
  
  sub generate {
      my $self = shift;
  
      require_optional( 'Devel/PPPort.pm', 'PPPort is required for XS support' );
  
      $self->render('Module.pm', catfile('lib', $self->path));
      $self->render('Module.xs', catfile('lib', dirname($self->path), $self->suffix . '.xs'));
  
      my $ppport = catfile(dirname(catfile('lib', $self->path)), 'ppport.h');
      infof("Writing ppport.h: %s\n", $ppport);
      Devel::PPPort::WriteFile($ppport);
  
      $self->render('Changes');
      $self->render('t/00_compile.t');
      $self->render('t/01_simple.t');
      $self->render('.travis.yml');
  
      $self->render('.gitignore');
      my $gi = Minilla::Gitignore->load('.gitignore');
      $gi->add(catfile('lib', dirname($self->path), $self->suffix . '.c'));
      $gi->add("!$ppport"); # Import ppport.h!
      $gi->save('.gitignore');
  
      $self->write_file('LICENSE', Minilla::License::Perl_5->new(
          holder => sprintf('%s <%s>', $self->author, $self->email)
      )->fulltext);
  
      $self->render('cpanfile');
  }
  
  1;
  __DATA__
  
  @@ t/01_simple.t
  use strict;
  use Test::More;
  
  use <% $module %>;
  
  is(<% $module %>::hello(), 'Hello, world!');
  
  done_testing;
  
  @@ Module.xs
  #ifdef __cplusplus
  extern "C" {
  #endif
  
  #define PERL_NO_GET_CONTEXT /* we want efficiency */
  #include <EXTERN.h>
  #include <perl.h>
  #include <XSUB.h>
  
  #ifdef __cplusplus
  } /* extern "C" */
  #endif
  
  #define NEED_newSVpvn_flags
  #include "ppport.h"
  
  MODULE = <% $module %>    PACKAGE = <% $module %>
  
  PROTOTYPES: DISABLE
  
  void
  hello()
  CODE:
  {
      ST(0) = newSVpvs_flags("Hello, world!", SVs_TEMP);
  }
MINILLA_PROFILE_XS

$fatpacked{"Minilla/Project.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_PROJECT';
  package Minilla::Project;
  use strict;
  use warnings;
  use utf8;
  
  use TOML 0.92 qw(from_toml);
  use File::Basename qw(basename dirname);
  use File::Spec::Functions qw(catdir catfile);
  use DirHandle;
  use File::pushd;
  use CPAN::Meta;
  use Module::CPANfile;
  use Config::Identity::PAUSE;
  use Module::Runtime qw(require_module);
  
  use Minilla;
  use Minilla::Logger;
  use Minilla::Metadata;
  use Minilla::WorkDir;
  use Minilla::ReleaseTest;
  use Minilla::ModuleMaker::ModuleBuild;
  use Minilla::ModuleMaker::ModuleBuildTiny;
  use Minilla::ModuleMaker::ExtUtilsMakeMaker;
  use Minilla::Util qw(slurp_utf8 find_dir cmd spew_raw slurp_raw);
  use Encode qw(decode_utf8);
  
  use Moo;
  
  has dir => (
      is => 'rw',
      builder => 1,
      trigger => 1,
      required => 1,
  );
  
  has module_maker => (
      is => 'ro',
      default => sub {
          my $self = shift;
          if ($self->config && defined($self->config->{module_maker})) {
              # Automatic require.
              my $klass = $self->config->{module_maker};
              $klass = $klass =~ s/^\+// ? $klass : "Minilla::ModuleMaker::$klass";
              return $klass->new();
          }
          Minilla::ModuleMaker::ModuleBuildTiny->new()
      },
      lazy => 1,
  );
  
  has dist_name => (
      is => 'lazy',
  );
  
  has build_class => (
      is => 'lazy',
  );
  
  has main_module_path => (
      is => 'lazy',
  );
  
  has metadata => (
      is => 'lazy',
      required => 1,
      handles => [qw(name perl_version license)],
      clearer => 1,
  );
  
  has contributors => (
      is => 'lazy',
  );
  
  has work_dir => (
      is => 'lazy',
  );
  
  has files => (
      is => 'lazy',
  );
  
  has no_index => (
      is => 'ro',
      default => sub {
          my $self = shift;
          exists $self->config->{no_index} ?
              $self->config->{no_index} :
              {
                  directory => [qw(
                      t xt inc share eg examples author builder
                  ) ]
              };
      },
  );
  
  has script_files => (
      is => 'ro',
      default => sub {
          my $self = shift;
          my $script_files = exists $self->config->{script_files} ?
              $self->config->{script_files} :
              ['script/*', 'bin/*'];
          join ', ', map { "glob('$_')" } @$script_files;
      },
  );
  
  no Moo;
  
  sub allow_pureperl {
      my $self = shift;
      $self->config->{allow_pureperl} ? 1 : 0;
  }
  
  sub version {
      my $self = shift;
      my $version = $self->config->{version} || $self->metadata->version;
      unless (defined $version) {
          errorf("Minilla can't aggregate version number from '" . $self->main_module_path . '"');
      }
      return $version;
  }
  
  sub authors {
      my $self = shift;
      if (my $authors_from = $self->config->{authors_from}) {
          my $meta = Minilla::Metadata->new(
              source => $authors_from
          );
          return $meta->authors;
      }
      $self->config->{authors} || $self->metadata->authors;
  }
  
  sub abstract {
      my $self = shift;
      if (my $abstract_from = $self->config->{abstract_from}) {
          my $meta = Minilla::Metadata->new(
              source => $abstract_from
          );
          return $meta->abstract;
      }
      $self->config->{abstract} || $self->metadata->abstract;
  }
  
  sub badges {
      my $self = shift;
      $self->config->{badges} || [];
  }
  
  sub tap_harness_args {
      my $self = shift;
      $self->config->{tap_harness_args};
  }
  
  sub use_xsutil {
      my $self = shift;
      return defined $self->config->{XSUtil} ? 1 : 0;
  }
  
  sub needs_compiler_c99 {
      my $self = shift;
      if( my $xsutil = $self->config->{XSUtil} ){
          return $xsutil->{needs_compiler_c99} ? 1 : 0;
      }
  }
  
  sub needs_compiler_cpp {
      my $self = shift;
      if( my $xsutil = $self->config->{XSUtil} ){
          return $xsutil->{needs_compiler_cpp} ? 1 : 0;
      }
  }
  
  sub generate_ppport_h {
      my $self = shift;
      if( my $xsutil = $self->config->{XSUtil} ){
          return $xsutil->{generate_ppport_h} || 0;
      }
  }
  
  sub generate_xshelper_h {
      my $self = shift;
      if( my $xsutil = $self->config->{XSUtil} ){
          return $xsutil->{generate_xshelper_h} || 0;
      }
  }
  
  sub cc_warnings{
      my $self = shift;
      if( my $xsutil = $self->config->{XSUtil} ){
          return $xsutil->{cc_warnings} ? 1 : 0;
      }
  }
  
  sub _build_dir {
      my $self = shift;
  
      my $gitdir = find_dir('.git')
          or errorf("Current directory is not in git(%s)\n", Cwd::getcwd());
      $gitdir = File::Spec->rel2abs($gitdir);
      my $base_dir = dirname($gitdir);
  
      return $base_dir;
  }
  
  sub _trigger_dir {
      my ($self, $dir) = @_;
      unless (File::Spec->file_name_is_absolute($dir)) {
          $self->dir(File::Spec->rel2abs($dir));
      }
  }
  
  sub config {
      my $self = shift;
  
      my $toml_path = File::Spec->catfile($self->dir, 'minil.toml');
      if (-f $toml_path) {
          my ($conf, $err) = from_toml(slurp_utf8($toml_path));
          if ($err) {
              errorf("TOML error in %s: %s\n", $toml_path, $err);
          }
          $self->_patch_config_for_mb($conf) unless $conf->{module_maker};
          $conf;
      } else {
          +{};
      }
  }
  
  sub _patch_config_for_mb {
      my($self, $conf) = @_;
  
      if (exists $conf->{build} or exists $conf->{XSUtil}) {
          warn <<WARN unless $self->{__already_warned}++;
  !
  ! WARNING:
  ! module_maker is not set in your Minilla config (minil.toml), but found [build] or [XSUtil] section in it.
  ! Defaulting to Module::Build, but you're suggested to add the following to your minil.toml:
  !
  !   module_maker="ModuleBuild"
  !
  ! This friendly warning will go away in the next major release, and Minilla will default to ModuleBuildTiny
  ! when module_maker is not explicitly set in minil.toml.
  !
  WARN
          $conf->{module_maker} = "ModuleBuild";
      }
  
      return;
  }
  
  sub c_source {
      my $self = shift;
      $self->config->{c_source} ? join(' ', @{$self->config->{c_source}}) : '';
  }
  
  sub _build_dist_name {
      my $self = shift;
  
      my $dist_name;
      if ($self->config && defined($self->config->{name})) {
          my $conf = $self->config;
          if ($conf->{name} =~ /::/) {
              (my $better_name = $conf->{name}) =~ s/::/-/g;
              Carp::croak(qq!You shouldn't set 'name="$conf->{name}"' in minil.toml. You need to set the value as 'name="$better_name"'.!);
          }
          $dist_name = $conf->{name};
      }
      unless (defined $dist_name) {
          infof("Detecting project name from directory name.\n");
          $dist_name = $self->_detect_project_name_from_dir;
      }
      if ($dist_name eq '.') { Carp::confess("Heh? " . $self->dir); }
  
      unless ($dist_name) {
          errorf("Cannot detect distribution name from minil.toml or directory name(cwd: %s, dir:%s)\n", Cwd::getcwd(), $self->dir);
      }
  
      return $dist_name;
  }
  
  sub _detect_project_name_from_dir {
      my $self = shift;
  
      local $_ = basename($self->dir);
      $_ =~ s!--!-!g;
      $_ =~ s!\Ap5-!!;
      return $_;
  }
  
  sub _build_build_class {
      my $self = shift;
  
      my $build_class;
      if (my $conf = $self->config) {
          $build_class = $conf->{build}{build_class};
      }
  
      return $build_class if $build_class;
  
      return $self->use_xsutil ? 'Module::Build::XSUtil' : 'Module::Build';
  }
  
  sub _build_main_module_path {
      my $self = shift;
  
      my $dist_name = $self->dist_name;
      my $source_path = $self->_detect_source_path($dist_name);
      unless (defined($source_path) && -e $source_path) {
          errorf("%s not found.\n", $source_path || "main module($dist_name)");
      }
  
      infof("Retrieving meta data from %s.\n", $source_path);
      return $source_path;
  }
  
  sub _build_metadata {
      my $self = shift;
  
      my $config = +{%{$self->config}};
      if (my $license = delete $config->{license}) {
          $config->{_license_name} = $license;
      }
  
      # fill from main_module
      my $metadata = Minilla::Metadata->new(
          source => $self->main_module_path,
          %$config,
      );
      infof("Name: %s\n", $metadata->name);
      infof("Abstract: %s\n", $metadata->abstract);
      infof("Version: %s\n", $metadata->version);
  
      return $metadata;
  }
  
  sub _case_insensitive_match {
      my $path = shift;
      my @path = File::Spec->splitdir($path);
      my $realpath = '.';
      LOOP: for my $part (@path) {
          my $d = DirHandle->new($realpath)
              or do {
              # warn "Cannot open dirhandle";
              return;
          };
          while (defined($_ = $d->read)) {
              if (uc($_) eq uc($part)) {
                  $realpath = catfile($realpath, $_);
                  next LOOP;
              }
          }
  
          # does not match
          # warn "Does not match: $part in $realpath";
          return undef;
      }
      return $realpath;
  }
  
  sub format_tag {
      my ($self, $version) = @_;
      if (defined(my $format = $self->config->{tag_format})) {
          (my $tag = $format) =~ s/%v/$version/;
          $tag;
      } else {
          $version;
      }
  }
  
  sub _detect_source_path {
      my ($self, $dir) = @_;
  
      # like cpan-outdated => lib/App/cpanminus.pm
      my $pat2 = "App-" . do {
          local $_ = $dir;
          s!-!!;
          $_;
      };
      for my $path ("App-$dir", $pat2, $dir) {
          $path =~ s!::!/!g;
          $path =~ s!-!/!g;
          $path = "lib/${path}.pm";
  
          return $path if -f $path;
  
          $path = _case_insensitive_match($path);
          return $path if defined($path);
      }
  
      return undef;
  }
  
  sub load_cpanfile {
      my $self = shift;
      Module::CPANfile->load(catfile($self->dir, 'cpanfile'));
  }
  
  sub cpan_meta {
      my ($self, $release_status) = @_;
      $release_status ||= ($self->version =~ /_/ ? 'unstable' : 'stable');
  
      my $cpanfile = $self->load_cpanfile;
      my $merged_prereqs = $cpanfile->prereqs->with_merged_prereqs(
          CPAN::Meta::Prereqs->new($self->module_maker->prereqs($self))
      );
      $merged_prereqs = $merged_prereqs->with_merged_prereqs(
          CPAN::Meta::Prereqs->new(Minilla::ReleaseTest->prereqs)
      );
      if ($self->metadata->perl_version) {
          $merged_prereqs = $merged_prereqs->with_merged_prereqs(
              CPAN::Meta::Prereqs->new(+{
                  runtime => {
                      requires => {
                          perl => $self->metadata->perl_version,
                      }
                  }
              })
          );
      }
      $merged_prereqs = $merged_prereqs->as_string_hash;
  
      my $dat = {
          "meta-spec" => {
              "version" => "2",
              "url"     => "http://search.cpan.org/perldoc?CPAN::Meta::Spec"
          },
          license        => [ $self->license->meta2_name ],
          abstract       => $self->abstract,
          dynamic_config => 0,
          version        => $self->version,
          name           => $self->dist_name,
          prereqs        => $merged_prereqs,
          generated_by   => "Minilla/$Minilla::VERSION",
          release_status => $release_status || 'stable',
          no_index       => $self->no_index,
      };
      unless ($dat->{abstract}) {
          errorf("Cannot retrieve 'abstract' from %s. You need to write POD in your main module.\n", $self->dir);
      }
      if ($self->authors) {
          $dat->{author} = $self->authors;
      } else {
          errorf("Cannot determine 'author' from %s\n", $self->dir);
      }
      if ($self->contributors && @{$self->contributors} > 0) {
          $dat->{x_contributors} = $self->contributors;
      }
      if (my $authority = $self->config->{authority}) {
          $dat->{x_authority} = $authority;
      }
  
      # fill 'provides' section
      if ($release_status ne 'unstable') {
          my $provides = Module::Metadata->provides(
              dir     => File::Spec->catdir($self->dir, 'lib'),
              version => 2
          );
          unless (%$provides) {
              errorf("%s does not provides any package. Abort.\n", $self->dir);
          }
          $dat->{provides} = $provides;
      }
  
      # fill repository information
      my $git_info = $self->extract_git_info;
      if ($git_info->{bugtracker}) {
          $dat->{resources}->{bugtracker} = $git_info->{bugtracker};
      }
      if ($git_info->{repository}) {
          $dat->{resources}->{repository} = $git_info->{repository};
      }
      if ($git_info->{homepage}) {
          $dat->{resources}->{homepage}   = $git_info->{homepage};
      }
  
      my $meta = CPAN::Meta->new($dat);
      return $meta;
  }
  
  sub extract_git_info {
      my $self = shift;
  
      my $guard = pushd($self->dir);
  
      my $bugtracker;
      my $repository;
      my $homepage;
      if ( my $registered_url = `git config --get remote.origin.url` ) {
          $registered_url =~ s/\n//g;
          # XXX Make it public clone URL, but this only works with github
          if ($registered_url =~ /github\.com/) {
              my ($user, $repo) = $registered_url =~ m{
                  github\.com
                  (?:(?::[0-9]+)?/|:)([^/]+)
                  /
                  ([^/]+?)(?:\.git)?
                  $
              }ix;
              my $git_url = "git://github.com/$user/$repo.git";
              my $http_url = "https://github.com/$user/$repo";
              unless ($self->config->{no_github_issues}) {
                  $bugtracker = +{
                      web => "$http_url/issues",
                  };
              }
              $repository = +{
                  url => $git_url,
                  web => $http_url,
              };
              $homepage = $self->config->{homepage} || $http_url;
          } else {
              if ($registered_url !~ m{^(?:https?|ssh|git)://}) {
                  # We can't do much more than this, but we need to fix
                  # user@host:path/to/repo.git to git://$host/path/to/repo.git in
                  # order to work with CPAN::Meta
                  $registered_url =~ s{
                      \A
                      [^@]+       # user name, which we toss away
                      @
                      ([^:]+)     # anything other than a ":"
                      :
                      (.+)        # anything, which is the repository
                      \Z
                  }{git://$1/$2}gx;
              }
  
              # normal repository
              if ($registered_url !~ m{^file://}) {
                  $repository = +{
                      url => $registered_url,
                  };
              }
          }
      }
  
      return +{
          bugtracker => $bugtracker,
          repository => $repository,
          homepage   => $homepage,
      }
  }
  
  sub readme_from {
      my $self = shift;
      $self->config->{readme_from} || $self->main_module_path;
  }
  
  sub regenerate_files {
      my $self = shift;
  
      $self->regenerate_meta_json();
      $self->regenerate_readme_md();
      $self->module_maker->generate($self);
      if (Cwd::getcwd() ne $self->dir) {
          my $guard = pushd($self->dir);
          $self->module_maker->generate($self);
      }
  }
  
  sub regenerate_meta_json {
      my $self = shift;
  
      my $meta = $self->cpan_meta('unstable');
      $meta->save(File::Spec->catfile($self->dir, 'META.json'), {
          version => '2.0'
      });
  }
  
  sub generate_minil_toml {
      my ($self, $profile) = @_;
  
      my $fname        = File::Spec->catfile($self->dir, 'minil.toml');
      my $project_name = $self->_detect_project_name_from_dir;
      my $content      = join("\n",
          qq{name = "$project_name"},
          qq{# badges = ["travis"]},
      );
  
      my %pause;
      if (eval { %pause = Config::Identity::PAUSE->load; 1; } && exists $pause{user}) {
          my $user = uc($pause{user});
          $content .= qq{\nauthority="cpan:${user}"\n},
      }
      warn $@ if $@;
  
      if ($profile eq 'ModuleBuild') {
          $content .= qq{\nmodule_maker="ModuleBuild"\n};
      } elsif ($profile eq 'ExtUtilsMakeMaker') {
          $content .= qq{\nmodule_maker="ExtUtilsMakeMaker"\n};
      } else {
          $content .= qq{\nmodule_maker="ModuleBuildTiny"\n};
      }
  
      spew_raw($fname, $content . "\n");
  }
  
  sub regenerate_readme_md {
      my $self = shift;
  
      my $markdown_maker = $self->config->{markdown_maker} || 'Pod::Markdown';
      require_module($markdown_maker);
      if ($markdown_maker eq 'Pod::Markdown') {
          $markdown_maker->VERSION('1.322');
      }
  
      my $parser = $markdown_maker->new;
      if (not $parser->isa('Pod::Markdown')) {
          errorf("'markdown_maker' config key must be a subclass of Pod::Markdown\n");
      }
      $parser->parse_from_file($self->readme_from);
  
      my $fname = File::Spec->catfile($self->dir, 'README.md');
      my $markdown = $parser->as_markdown;
  
      if (ref $self->badges eq 'ARRAY' && scalar @{$self->badges} > 0) {
          my $user_name;
          my $repository_name;
  
          my $git_info = $self->extract_git_info;
          if (my $web_url = $git_info->{repository}->{web}) {
              ($user_name, $repository_name) = $web_url =~ m!https://.+/(.+)/(.+)!;
          }
  
          my @badges;
          if ($user_name && $repository_name) {
              for my $badge (@{$self->badges}) {
                  if ($badge eq 'travis') {
                      push @badges, "[![Build Status](https://travis-ci.org/$user_name/$repository_name.svg?branch=master)](https://travis-ci.org/$user_name/$repository_name)";
                  }
                  if ($badge eq 'appveyor') {
                      push @badges, "[![Build Status](https://img.shields.io/appveyor/ci/$user_name/$repository_name/master.svg)](https://ci.appveyor.com/project/$user_name/$repository_name/branch/master)";
                  }
                  if ($badge eq 'coveralls') {
                      push @badges, "[![Coverage Status](https://img.shields.io/coveralls/$user_name/$repository_name/master.svg?style=flat)](https://coveralls.io/r/$user_name/$repository_name?branch=master)"
                  }
                  if ($badge eq 'codecov') {
                      push @badges, "[![Coverage Status](http://codecov.io/github/$user_name/$repository_name/coverage.svg?branch=master)](https://codecov.io/github/$user_name/$repository_name?branch=master)";
                  }
                  if ($badge eq 'gitter') {
                      push @badges, "[![Gitter chat](https://badges.gitter.im/$user_name/$repository_name.png)](https://gitter.im/$user_name/$repository_name)";
                  }
              }
          }
  
          $markdown = "\n" . $markdown;
          $markdown = join(' ', @badges) . $markdown
      }
  
      spew_raw($fname, $markdown);
  }
  
  sub verify_prereqs {
      my ($self) = @_;
  
      if ($Minilla::AUTO_INSTALL) {
          system('cpanm', '--quiet', '--installdeps', '--with-develop', '.');
      }
  }
  
  sub _build_contributors {
      my $self = shift;
  
      return [] unless (`git show-ref --head`);
  
      my $normalize = sub {
          local $_ = shift;
          if (/<([^>]+)>/) {
              $1;
          } else {
              $_;
          }
      };
      my @lines = do {
          my %uniq;
          reverse grep { !$uniq{$normalize->($_)}++ } split /\n/, `git log --format="%aN <%aE>"`
      };
      my %is_author = map { $normalize->($_) => 1 } @{$self->authors};
      @lines = map { decode_utf8($_) } @lines;
      @lines = grep { !$is_author{$normalize->($_)} } @lines;
      @lines = grep { $_ ne 'Your Name <you@example.com>' } @lines;
      @lines = grep { ! /^\(no author\) <\(no author\)\@[\d\w\-]+>$/ } @lines;
      \@lines;
  }
  
  sub _build_work_dir {
      my $self = shift;
      Minilla::WorkDir->new(
          project  => $self,
      );
  }
  
  sub _build_files {
      my $self = shift;
      my $conf = $self->config->{'FileGatherer'};
      my @files = Minilla::FileGatherer->new(
          exclude_match => $conf->{exclude_match},
          exists $conf->{include_dotfiles} ? (include_dotfiles => $conf->{include_dotfiles}) : (),
      )->gather_files(
          $self->dir
      );
      \@files;
  }
  
  sub perl_files {
      my $self = shift;
      my @files = @{$self->files};
      grep {
          $_ =~ /\.(?:pm|pl|t)$/i || slurp_raw($_) =~ m{ ^ \#\! .* perl }ix
      } @files;
  }
  
  sub PL_files { shift->config->{PL_files} || +{} }
  
  sub requires_external_bin {
      my $self = shift;
      return $self->config->{requires_external_bin};
  }
  
  # @return true if the project is valid, false otherwise.
  sub validate {
      my $self = shift;
      my $module_maker = $self->module_maker;
      if ($module_maker->can('validate')) {
          return $module_maker->validate();
      } else {
          return 1;
      }
  }
  
  1;
MINILLA_PROJECT

$fatpacked{"Minilla/Release/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_BUMPVERSION';
  package Minilla::Release::BumpVersion;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use Minilla::Util qw(find_file require_optional cmd);
  use Minilla::Logger;
  use Module::BumpVersion;
  use version ();
  
  sub init {
      require_optional(
          'Module/BumpVersion.pm', 'Release engineering'
      );
      require_optional(
          'Version/Next.pm', 'Release engineering'
      );
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      if (my $ver = prompt("Next Release?", $self->default_new_version($project))) {
          # Do not use is_strict. is_strict rejects '5.00_01' style.
          if (!version::is_lax($ver)) {
              errorf("Sorry, version '%s' is invalid.  Stopping.\n", $ver);
          }
  
          my @opts;
          push @opts, '-set', $ver;
          if ($opts->{dry_run}) {
              push @opts, '-dryrun';
          }
          unless ($opts->{dry_run}) {
              $self->bump_version($project, $ver);
  
              # clear old version information
              $project->clear_metadata();
              my $newver = $project->metadata->version;
              if (exists_tag($project->format_tag($newver))) {
                  errorf("Sorry, version '%s' is already tagged.  Stopping.\n", $newver);
              }
          }
      }
  }
  
  sub bump_version {
      my ($self, $project, $version) = @_;
  
      for my $file ($project->perl_files) {
          next if $file =~ /\.t$/;
          next if $file =~ m{\Ashare/};
  
          my $bump = Module::BumpVersion->load($file);
          $bump->set_version($version);
      }
  }
  
  sub default_new_version {
      my ($self, $project) = @_;
      @_==2 or die;
  
      my $curver = $project->metadata->version;
      if (not exists_tag($project->format_tag($curver))) {
          $curver;
      } else {
          # $project->metadata->version returns version.pm object.
          # But stringify was needed by Version::Next.
          return Version::Next::next_version("$curver");
      }
  }
  
  sub exists_tag {
      my ( $tag ) = @_;
  
      my $x       = `git tag -l $tag`;
      chomp $x;
      return !!$x;
  }
  
  1;
  
  
MINILLA_RELEASE_BUMPVERSION

$fatpacked{"Minilla/Release/CheckChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_CHECKCHANGES';
  package Minilla::Release::CheckChanges;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use Minilla::Util qw(edit_file slurp);
  use Minilla::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my $version = $project->version;
  
      if ($ENV{PERL_MINILLA_SKIP_CHECK_CHANGE_LOG}) {
          infof("Okay, you are debugging now.\n");
          return;
      }
  
      until (slurp('Changes') =~ /^\{\{\$NEXT\}\}\n+[ \t]+\S/m) {
          infof("No mention of {{\$NEXT}} in changelog file 'Changes'\n");
          if (prompt("Edit file?", 'y') =~ /y/i) {
              edit_file('Changes');
          } else {
              errorf("Giving up!\n");
          }
      }
  }
  
  1;
  
MINILLA_RELEASE_CHECKCHANGES

$fatpacked{"Minilla/Release/CheckOrigin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_CHECKORIGIN';
  package Minilla::Release::CheckOrigin;
  use strict;
  use warnings;
  use utf8;
  use Minilla::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      unless (`git remote`) {
          errorf("No git remote.\n");
      }
  }
  
  1;
  
MINILLA_RELEASE_CHECKORIGIN

$fatpacked{"Minilla/Release/CheckUntrackedFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_CHECKUNTRACKEDFILES';
  package Minilla::Release::CheckUntrackedFiles;
  use strict;
  use warnings;
  use utf8;
  
  use Minilla::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      if ( my $unk = `git ls-files -z --others --exclude-standard` ) {
          $unk =~ s/\0/\n/g;
          errorf("Unknown local files:\n$unk\n\nUpdate .gitignore, or git add them\n");
      }
  }
  
  1;
  
MINILLA_RELEASE_CHECKUNTRACKEDFILES

$fatpacked{"Minilla/Release/Commit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_COMMIT';
  package Minilla::Release::Commit;
  use strict;
  use warnings;
  use utf8;
  
  use Minilla::Util qw(find_file cmd);
  use Minilla::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my @modified_files = split /\0/, `git ls-files --deleted --modified -z`;
      return if @modified_files == 0;
  
      $project->clear_metadata();
      my $ver = $project->metadata->version;
  
      my $msg = "Checking in changes prior to tagging of version $ver.\n\nChangelog diff is:\n\n";
      $msg .= `git diff Changes`;
  
      if ($opts->{dry_run}) {
          infof("DRY-RUN.  Would have committed message of:\n----------------\n$msg\n-----------\n");
          return;
      }
  
      cmd('git', 'commit', '-a', '-m', $msg);
  
      $self->_push_to_origin();
  }
  
  sub _push_to_origin {
      my ($self) = @_;
  
      # git v1.7.10 is required?
      my $branch = _get_branch()
          or return;
      $branch =~ s/\n//g;
      infof("Pushing to origin\n");
      cmd('git', 'push', 'origin', $branch);
  }
  
  sub _get_branch {
      open my $fh, '<', '.git/HEAD';
      chomp( my $head = do { local $/; <$fh> });
      close $fh;
  
      my ($branch) = $head =~ m!ref: refs/heads/(\S+)!;
      return $branch;
  }
  
  1;
  
MINILLA_RELEASE_COMMIT

$fatpacked{"Minilla/Release/DistTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_DISTTEST';
  package Minilla::Release::DistTest;
  use strict;
  use warnings;
  use utf8;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      $opts->{test} or return;
  
      local $ENV{RELEASE_TESTING} = 1;
      my $work_dir = $project->work_dir();
      if ($work_dir->dist_test) {
          # Failed.
          exit 1;
      }
  }
  
  1;
  
MINILLA_RELEASE_DISTTEST

$fatpacked{"Minilla/Release/MakeDist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_MAKEDIST';
  package Minilla::Release::MakeDist;
  use strict;
  use warnings;
  use utf8;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my $work_dir = $project->work_dir();
      $work_dir->dist;
  }
  
  1;
  
  
  1;
  
MINILLA_RELEASE_MAKEDIST

$fatpacked{"Minilla/Release/RegenerateFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_REGENERATEFILES';
  package Minilla::Release::RegenerateFiles;
  use strict;
  use warnings;
  use utf8;
  use Minilla::Project;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      $project->regenerate_files();
  }
  
  1;
  
MINILLA_RELEASE_REGENERATEFILES

$fatpacked{"Minilla/Release/RewriteChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_REWRITECHANGES';
  package Minilla::Release::RewriteChanges;
  use strict;
  use warnings;
  use utf8;
  use Minilla::Util qw(slurp_raw spew_raw);
  
  sub run {
      my ($self, $project, $opts) = @_;
      return if $opts->{dry_run};
  
      my $content = slurp_raw('Changes');
      $content =~ s!\{\{\$NEXT\}\}!
          "{{\$NEXT}}\n\n" . $project->version . " " . $project->work_dir->changes_time->strftime('%Y-%m-%dT%H:%M:%SZ')
      !e;
      spew_raw('Changes' => $content);
  }
  
  
  1;
  
MINILLA_RELEASE_REWRITECHANGES

$fatpacked{"Minilla/Release/RunHooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_RUNHOOKS';
  package Minilla::Release::RunHooks;
  use strict;
  use warnings;
  use utf8;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my $return_value = 0;
      my $commands     = $project->config->{release}->{hooks};
  
      if ($commands) {
          if (ref $commands ne 'ARRAY') {
              warn "Release hooks must be array";
              exit 1;
          }
          $return_value = system(join ' && ', @$commands);
      }
  
      if ($return_value != 0) {
          # Failure executing command of hooks
          exit 1;
      }
  }
  
  1;
  
MINILLA_RELEASE_RUNHOOKS

$fatpacked{"Minilla/Release/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_TAG';
  package Minilla::Release::Tag;
  use strict;
  use warnings;
  use utf8;
  
  use Minilla::Util qw(cmd);
  use Minilla::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my $ver = $project->version;
      if ( $opts->{dry_run} ) {
          infof("DRY-RUN.  Would have tagged version $ver.\n");
          return;
      }
  
      my $tag = $project->format_tag($ver);
      cmd('git', 'tag', $tag);
      cmd('git', "push", 'origin', tag => $tag);
  }
  
  1;
  
MINILLA_RELEASE_TAG

$fatpacked{"Minilla/Release/UploadToCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASE_UPLOADTOCPAN';
  package Minilla::Release::UploadToCPAN;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use Minilla::Util qw(require_optional);
  use Minilla::Logger;
  
  sub init {
      require_optional('CPAN/Uploader.pm',
          'Release engineering');
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my $work_dir = $project->work_dir();
      my $tar = $work_dir->dist;
  
      if ($opts->{dry_run} || $ENV{FAKE_RELEASE}) {
          infof("Dry run. You don't need the module upload to CPAN\n");
      } elsif ($project->config->{release}->{do_not_upload_to_cpan}) {
          infof("You disabled CPAN uploading feature in minil.toml.\n");
      } else {
          infof("Upload to CPAN\n");
  
          my $pause_config = ($opts->{pause_config})          ? $opts->{pause_config}
              : ($project->config->{release}->{pause_config}) ? $project->config->{release}->{pause_config}
              :                                                 undef;
          my $config = CPAN::Uploader->read_config_file($pause_config);
  
          PROMPT: while (1) {
              my $answer = prompt("Release to " . ($config->{upload_uri} || 'CPAN') . ' ? [y/n] ');
              if ($answer =~ /y/i) {
                  last PROMPT;
              } elsif ($answer =~ /n/i) {
                  errorf("Giving up!\n");
              } else {
                  redo PROMPT;
              }
          }
  
          if ($opts->{trial}) {
              my $orig_file = $tar;
              $tar =~ s/\.(tar\.gz|tgz|tar.bz2|tbz|zip)$/-TRIAL.$1/
              or die "Distfile doesn't match supported archive format: $orig_file";
              infof("renaming $orig_file -> $tar for TRIAL release\n");
              rename $orig_file, $tar or errorf("Renaming $orig_file -> $tar failed: $!\n");
          }
  
          my $uploader = CPAN::Uploader->new(+{
              tar => $tar,
              %$config
          });
          $uploader->upload_file($tar);
      }
  
      unlink($tar) unless Minilla->debug;
  }
  
  1;
  
MINILLA_RELEASE_UPLOADTOCPAN

$fatpacked{"Minilla/ReleaseTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_RELEASETEST';
  package Minilla::ReleaseTest;
  use strict;
  use warnings;
  use utf8;
  use Data::Section::Simple qw(get_data_section);
  use File::pushd;
  use File::Spec::Functions qw(catfile);
  use File::Path qw(mkpath);
  
  use Minilla::Logger;
  use Minilla::Util qw(spew);
  
  sub write_release_tests {
      my ($class, $project, $dir) = @_;
  
      mkpath(catfile($dir, 'xt', 'minilla'));
  
      my $stopwords = do {
          my $append_people_into_stopwords = sub {
              my $people = shift;
              my @stopwords;
              for (@{$people || +[]}) {
                  s!<.*!!; # trim e-mail address
                  push @stopwords, split(/\s+/, $_);
              }
              return @stopwords;
          };
  
          my @stopwords;
          push @stopwords, $append_people_into_stopwords->($project->contributors);
          push @stopwords, $append_people_into_stopwords->($project->authors);
          local $Data::Dumper::Terse = 1;
          local $Data::Dumper::Useqq = 1;
          local $Data::Dumper::Purity = 1;
          local $Data::Dumper::Indent = 0;
          Data::Dumper::Dumper([map { split /\s+/, $_ } @stopwords]);
      };
  
      my $config = $project->config->{ReleaseTest};
      my $name = $project->dist_name;
      for my $file (qw(
          xt/minilla/minimum_version.t
          xt/minilla/cpan_meta.t
          xt/minilla/pod.t
          xt/minilla/spelling.t
          xt/minilla/permissions.t
      )) {
          infof("Writing release tests: %s\n", $file);
  
          if ($file eq 'xt/minilla/minimum_version.t' && ($config->{MinimumVersion}||'') eq 'false') {
              infof("Skipping MinimumVersion");
              next;
          }
  
          my $content = get_data_section($file);
          $content =~s!<<DIST>>!$name!g;
          $content =~s!<<STOPWORDS>>!$stopwords!g;
          spew(catfile($dir, $file), $content);
      }
  }
  
  sub prereqs {
      +{
          develop => {
              requires => {
                  'Test::MinimumVersion::Fast' => 0.04,
                  'Test::CPAN::Meta' => 0,
                  'Test::Pod' => 1.41,
                  'Test::Spellunker' => 'v0.2.7',
                  'Test::PAUSE::Permissions' => 0.04,
              },
          },
      };
  }
  
  1;
  __DATA__
  
  @@ xt/minilla/minimum_version.t
  use Test::More;
  eval "use Test::MinimumVersion::Fast 0.04";
  if ($@) {
      plan skip_all => "Test::MinimumVersion::Fast required for testing perl minimum version";
  }
  all_minimum_version_from_metayml_ok();
  
  @@ xt/minilla/cpan_meta.t
  use Test::More;
  eval "use Test::CPAN::Meta";
  plan skip_all => "Test::CPAN::Meta required for testing META.yml" if $@;
  plan skip_all => "There is no META.yml" unless -f "META.yml";
  meta_yaml_ok();
  
  @@ xt/minilla/pod.t
  use strict;
  use Test::More;
  eval "use Test::Pod 1.41";
  plan skip_all => "Test::Pod 1.41 required for testing POD" if $@;
  all_pod_files_ok();
  
  @@ xt/minilla/spelling.t
  use strict;
  use Test::More;
  use File::Spec;
  eval q{ use Test::Spellunker v0.2.2 };
  plan skip_all => "Test::Spellunker is not installed." if $@;
  
  plan skip_all => "no ENV[HOME]" unless $ENV{HOME};
  my $spelltest_switchfile = ".spellunker.en";
  plan skip_all => "no ~/$spelltest_switchfile" unless -e File::Spec->catfile($ENV{HOME}, $spelltest_switchfile);
  
  add_stopwords('<<DIST>>');
  add_stopwords(@{<<STOPWORDS>>});
  
  all_pod_files_spelling_ok('lib');
  
  @@ xt/minilla/permissions.t
  use strict;
  use Test::More;
  
  eval q{ use Test::PAUSE::Permissions 0.04 };
  plan skip_all => "Test::PAUSE::Permissions is not installed." if $@;
  
  all_permissions_ok();
MINILLA_RELEASETEST

$fatpacked{"Minilla/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_UTIL';
  package Minilla::Util;
  use strict;
  use warnings;
  use utf8;
  use Carp ();
  use File::Basename ();
  use File::Spec ();
  use File::Which 'which';
  use Minilla::Logger ();
  use Getopt::Long ();
  use Cwd();
  
  use parent qw(Exporter);
  
  our @EXPORT_OK = qw(
      find_dir find_file
      randstr
      slurp slurp_utf8 slurp_raw
      spew  spew_utf8  spew_raw
      edit_file require_optional
      cmd cmd_perl
      pod_escape
      parse_options
      check_git
  );
  
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK
  );
  
  sub randstr {
      my $len = shift;
      my @chars = ("a".."z","A".."Z",0..9);
      my $ret = '';
      join('', map { $chars[int(rand(scalar(@chars)))] } 1..$len);
  }
  
  sub slurp {
      my $fname = shift;
      open my $fh, '<', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub slurp_utf8 {
      my $fname = shift;
      open my $fh, '<:encoding(UTF-8)', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub slurp_raw {
      my $fname = shift;
      open my $fh, '<:raw', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub spew($$) {
      my $fname = shift;
      open my $fh, '>', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  sub spew_raw {
      my $fname = shift;
      open my $fh, '>:raw', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  sub spew_utf8 {
      my $fname = shift;
      open my $fh, '>:encoding(UTF8)', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  sub edit_file {
      my ($file) = @_;
      my $editor = $ENV{"EDITOR"} || "vi";
      system( $editor, $file );
  }
  
  sub find_file {
      my ($file) = @_;
  
      my $dir = Cwd::getcwd();
      my %seen;
      while ( -d $dir ) {
          return undef if $seen{$dir}++;    # guard from deep recursion
          if ( -f "$dir/$file" ) {
              return "$dir/$file";
          }
          $dir = File::Basename::dirname($dir);
      }
  
      return undef;
  }
  
  sub find_dir {
      my ($file) = @_;
  
      my $dir = Cwd::getcwd();
      my %seen;
      while ( -d $dir ) {
          return undef if $seen{$dir}++;    # guard from deep recursion
          if ( -d "$dir/$file" ) {
              return "$dir/$file";
          }
          $dir = File::Basename::dirname($dir);
      }
  
      return undef;
  }
  
  sub require_optional {
      my ( $file, $feature, $library ) = @_;
  
      return if exists $INC{$file};
      unless ( eval { require $file } ) {
          if ( $@ =~ /^Can't locate/ ) {
              $library ||= do {
                  local $_ = $file;
                  s/ \.pm \z//xms;
                  s{/}{::}g;
                  $_;
              };
              Carp::croak( "$feature requires $library, but it is not available."
                    . " Please install $library using your preferred CPAN client" );
          }
          else {
              die $@;
          }
      }
  }
  
  sub cmd_perl {
      my(@args) = @_;
  
      require Config;
  
      my %std_inc = map { $_ => 1 } @Config::Config{qw(
          sitelibexp sitearchexp
          privlibexp archlibexp
      )};
      if ($Config::Config{usevendorprefix}) {
          @std_inc{'vendorarchexp', 'vendorlibexp'} = (1, 1);
      }
      my @non_std_inc = map { $_ eq '.' ? $_ : File::Spec->rel2abs($_) }
                        grep { not $std_inc{$_} } @INC;
  
      cmd($^X, (map { "-I$_" } @non_std_inc), @args);
  }
  
  sub cmd {
      Minilla::Logger::infof("[%s] \$ %s\n", File::Basename::basename(Cwd::getcwd()), "@_");
      system(@_) == 0
          or Minilla::Logger::errorf("Giving up.\n");
  }
  
  sub parse_options {
      my ( $args, @spec ) = @_;
      Getopt::Long::GetOptionsFromArray( $args, @spec );
  }
  
  sub pod_escape {
      local $_ = shift;
      my %POD_ESCAPE = ( '<' => 'E<lt>', '>' => 'E<gt>' );
      s!([<>])!$POD_ESCAPE{$1}!ge;
      $_;
  }
  
  sub check_git {
      unless (which 'git') {
          Minilla::Logger::errorf("The \"git\" executable has not been found.\n");
      }
  }
  
  1;
  
MINILLA_UTIL

$fatpacked{"Minilla/WorkDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MINILLA_WORKDIR';
  package Minilla::WorkDir;
  use strict;
  use warnings;
  use utf8;
  use Archive::Tar;
  use File::pushd;
  use Data::Dumper; # serializer
  use File::Spec::Functions qw(splitdir);
  use File::Spec;
  use Time::Piece qw(gmtime);
  use File::Basename qw(dirname);
  use File::Path qw(mkpath);
  use File::Copy qw(copy);
  use Config;
  
  use Minilla::Logger;
  use Minilla::Util qw(randstr cmd cmd_perl slurp slurp_raw spew spew_raw pod_escape);
  use Minilla::FileGatherer;
  use Minilla::ReleaseTest;
  
  use Moo;
  
  has project => (
      is => 'ro',
      required => 1,
      handles => [qw(files)],
  );
  
  has dir => (
      is => 'lazy',
      isa => sub {
          Carp::confess("'dir' must not be undef") unless defined $_[0];
      },
  );
  
  has manifest_files => (
      is => 'lazy',
  );
  
  has [qw(prereq_specs)] => (
      is => 'lazy',
  );
  
  has 'cleanup' => (
      is => 'ro',
      default => sub { $Minilla::DEBUG ? 0 : 1 },
  );
  
  has changes_time => (
      is => 'lazy',
  );
  
  no Moo;
  
  sub _build_changes_time { scalar(gmtime()) }
  
  sub DEMOLISH {
      my $self = shift;
      if ($self->cleanup) {
          infof("Removing %s\n", $self->dir);
          File::Path::rmtree($self->dir)
      }
  }
  
  sub _build_dir {
      my $self = shift;
      my $dirname = $^O eq 'MSWin32' ? '_build' : '.build';
      File::Spec->catfile($self->project->dir, $dirname, randstr(8));
  }
  
  sub _build_prereq_specs {
      my $self = shift;
  
      my $cpanfile = Module::CPANfile->load(File::Spec->catfile($self->project->dir, 'cpanfile'));
      return $cpanfile->prereq_specs;
  }
  
  sub _build_manifest_files {
      my $self = shift;
      my @files = (@{$self->files}, qw(LICENSE META.json META.yml MANIFEST));
      if (-f File::Spec->catfile($self->dir, 'Makefile.PL')) {
          push @files, 'Makefile.PL';
      } else {
          push @files, 'Build.PL';
      }
  
      [do {
          my %h;
          grep {!$h{$_}++} @files;
      }];
  }
  
  sub as_string {
      my $self = shift;
      $self->dir;
  }
  
  sub BUILD {
      my ($self) = @_;
  
      infof("Creating working directory: %s\n", $self->dir);
  
      # copying
      mkpath($self->dir);
      for my $src (@{$self->files}) {
          next if -d $src;
          debugf("Copying %s\n", $src);
  
          if (not -e $src) {
              warnf("Trying to copy non-existing file '$src', ignored\n");
              next;
          }
          my $dst = File::Spec->catfile($self->dir, File::Spec->abs2rel($src, $self->project->dir));
          mkpath(dirname($dst));
          infof("cp %s %s\n", $src, $dst);
          copy($src => $dst) or die "Copying failed: $src $dst, $!\n";
          chmod((stat($src))[2], $dst) or die "Cannot change mode: $dst, $!\n";
      }
  }
  
  sub build {
      my ($self) = @_;
  
      return if $self->{build}++;
  
      my $guard = pushd($self->dir);
  
      infof("Building %s\n", $self->dir);
  
      # Generate meta file
      {
          my $meta = $self->project->cpan_meta();
          $meta->save('META.yml', {
              version => 1.4,
          });
          $meta->save('META.json', {
              version => 2.0,
          });
      }
  
      {
          infof("Writing MANIFEST file\n");
          spew('MANIFEST', join("\n", @{$self->manifest_files}));
      }
  
      $self->project->regenerate_files();
      $self->_rewrite_changes();
      $self->_rewrite_pod();
  
      unless ($ENV{MINILLA_DISABLE_WRITE_RELEASE_TEST}) { # DO NOT USE THIS ENVIRONMENT VARIABLE.
          Minilla::ReleaseTest->write_release_tests($self->project, $self->dir);
      }
  
      if (-f 'Build.PL') {
          cmd_perl('Build.PL');
          cmd_perl('Build', 'build');
      } elsif (-f 'Makefile.PL') {
          cmd_perl('Makefile.PL');
          cmd($Config{make});
      } else {
         die "There is no Makefile.PL/Build.PL";
      }
  }
  
  sub _rewrite_changes {
      my $self = shift;
  
      my $orig = slurp_raw('Changes');
      $orig =~ s!\{\{\$NEXT\}\}!
          $self->project->version . ' ' . $self->changes_time->strftime('%Y-%m-%dT%H:%M:%SZ')
      !e;
      spew_raw('Changes', $orig);
  }
  
  sub _rewrite_pod {
      my $self = shift;
  
      # Disabled this feature.
  #   my $orig =slurp_raw($self->project->main_module_path);
  #   if (@{$self->project->contributors}) {
  #       $orig =~ s!
  #           (^=head \d \s+ (?:authors?)\b \s*)
  #           (.*?)
  #           (^=head \d \s+ | \z)
  #       !
  #           (       $1
  #               . $2
  #               . "=head1 CONTRIBUTORS\n\n=over 4\n\n"
  #               . join( '', map { "=item $_\n\n" } map { pod_escape($_) } @{ $self->project->contributors } )
  #               . "=back\n\n"
  #               . $3 )
  #       !ixmse;
  #       spew_raw($self->project->main_module_path => $orig);
  #   }
  }
  
  # Return non-zero if fail
  sub dist_test {
      my ($self, @targets) = @_;
  
      $self->build();
  
      $self->project->verify_prereqs();
  
      eval {
          my $guard = pushd($self->dir);
          $self->project->module_maker->run_tests();
      };
      return $@ ? 1 : 0;
  }
  
  sub dist {
      my ($self) = @_;
  
      $self->{tarball} ||= do {
          $self->build();
  
          my $guard = pushd($self->dir);
  
          # Create tar ball
          my $tarball = sprintf('%s-%s.tar.gz', $self->project->dist_name, $self->project->version);
  
          my $force_mode = 0;
  
          my $tar = Archive::Tar->new;
          for my $file (@{$self->manifest_files}) {
              my $filename = File::Spec->catfile($self->project->dist_name . '-' . $self->project->version, $file);
              my $data = slurp($file);
  
              my $mode = (stat($file))[2];
  
              # On Windows, (stat($file))[2] * ALWAYS * results in octal 0100666 (which means it is
              # world writeable). World writeable files are always rejected by PAUSE. The solution is to
              # change a file mode octal 0100666 to octal 000664, such that it is * NOT * world
              # writeable. This works on Windows, as well as on other systems (Linux, Mac, etc...), because
              # the filemode 0100666 only occurs on Windows. (If it occurred on Linux, it would be wrong anyway)
  
              if ($mode == 0100666) {
                  $mode = 0644;
                  $force_mode++;
              }
  
              $tar->add_data($filename, $data, { mode => $mode });
          }
          $tar->write($tarball, COMPRESS_GZIP);
          infof("Wrote %s\n", $tarball.($force_mode == 0 ? '' : ' --> forced to mode 000664'));
  
          File::Spec->rel2abs($tarball);
      };
  }
  
  sub run {
      my ($self, @cmd) = @_;
      $self->build();
  
      eval {
          my $guard = pushd($self->dir);
          cmd(@cmd);
      };
      return $@ ? 1 : 0;
  }
  
  1;
MINILLA_WORKDIR

$fatpacked{"Module/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUMPVERSION';
  package Module::BumpVersion;
  use strict;
  use warnings;
  use utf8;
  
  sub load {
      my ($class, $name) = @_;
  
      my $lines;
      my $is_perl = sub {
          return 1 if $name =~ m{ [.] (?i: pl | pm | t ) $ }x;
          $lines = $class->read_file($name);
          return 1 if @$lines && $lines->[0] =~ m{ ^ \#\! .* perl }ix;
          return;
      }->();
      $lines ||= $class->read_file($name);
      return unless $is_perl;
      return unless $lines;
  
      bless {lines => $lines, name => $name}, $class;
  }
  
  sub read_file {
      my ($class, $name) = @_;
      open my $fh, '<:raw', $name
          or die "Cannot open '$name' for readding: $!";
      my @ret = <$fh>;
      close $fh;
      return \@ret;
  }
  
  sub set_version {
      my ($self, $new_version) = @_;
  
      my $versions = $self->versions;
      my @lines = @{$self->{lines}};
      my $dirty;
      for my $edits ( values %$versions ) {
          for my $edit (@$edits) {
              $lines[ $edit->{line} ] =
                $edit->{pre} . $new_version . $edit->{post} . "\n";
              $dirty++;
          }
      }
      return unless $dirty;
  
      open my $fh, '>:raw', $self->{name}
          or die "Cannot open '$self->{name}' for writing: $!";
      print {$fh} $_ for @lines;
      close $fh;
  }
  
  sub find_version {
      my $self = shift;
      my ($version) = keys %{$self->versions};
      return $version;
  }
  
  sub versions {
      my $self = shift;
      $self->{versions} ||= $self->_find_version_for_doc();
  }
  
  sub _find_version_for_doc {
      my ( $self ) = @_;
  
      my $name = $self->{name};
  
      my $machine = $self->scanner();
      my $state = $machine->{init};
      my $lines = $self->{lines};
      my $ver_found = {};
  
    LINE:
      for my $ln ( 0 .. @$lines - 1 ) {
          my $line = $lines->[$ln];
  
          next LINE if $line =~ /# No BumpVersion/;
  
          # Bail out when we're in a state with no possible actions.
          last LINE unless @$state;
  
        STATE: {
              for my $trans (@$state) {
                  if ( my @match = $line =~ $trans->{re} ) {
                      if ( $trans->{mark} ) {
                          my $ver = $2 . $3 . $4;
                          push @{ $ver_found->{ $ver } },
                            {
                              file => $name,
                              info => $self,
                              line => $ln,
                              pre  => $1,
                              ver  => $ver,
                              post => $5
                            };
                      }
  
                      if ( my $code = $trans->{exec} ) {
                          $code->( $machine, \@match, $line );
                      }
  
                      if ( my $goto = $trans->{goto} ) {
                          $state = $machine->{$goto};
                          redo STATE;
                      }
                  }
              }
          }
      }
      return $ver_found;
  }
  
  sub version_re_perl {
      my $ver_re = shift;
  
      return qr{ ^ ( .*?  [\$\*] (?: \w+ (?: :: | ' ) )* VERSION \s* =
                      \D*? ) 
                   $ver_re 
                   ( .* ) $ }x;
  }
  
  sub version_re_pod {
      my $ver_re = shift;
      return qr{ ^ ( .*? (?i: version ) .*? ) $ver_re ( .* ) $ }x;
  }
  
  
  # State machine for Perl source
  sub scanner{
      # Perl::Version::REGEX
      my $ver_re = qr/ ( (?i: Revision: \s+ ) | v | )
                       ( \d+ (?: [.] \d+)* )
                       ( (?: _ \d+ )? ) /x;
  
      {
          init => [
              {
                  re   => qr{ ^ = (?! cut ) }x,
                  goto => 'pod',
              },
              {
                  re   => version_re_perl($ver_re),
                  mark => 1,
              },
          ],
  
          # pod within perl
          pod => [
              {
                  re   => qr{ ^ =head\d\s+VERSION\b }x,
                  goto => 'version',
              },
              {
                  re   => qr{ ^ =cut }x,
                  goto => 'init',
              },
          ],
  
          # version section within pod
          version => [
              {
                  re   => qr{ ^ = (?! head\d\s+VERSION\b ) }x,
                  goto => 'pod',
              },
              {
                  re   => version_re_pod($ver_re),
                  mark => 1,
              },
  
          ],
      };
  }
  
  
  1;
  
MODULE_BUMPVERSION

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;
  use strict;
  use warnings;
  use Cwd;
  use Carp ();
  use Module::CPANfile::Environment;
  use Module::CPANfile::Requirement;
  
  our $VERSION = '1.1001';
  
  sub new {
      my($class, $file) = @_;
      bless {}, $class;
  }
  
  sub load {
      my($proto, $file) = @_;
  
      my $self = ref $proto ? $proto : $proto->new;
      $self->parse($file || Cwd::abs_path('cpanfile'));
      $self;
  }
  
  sub save {
      my($self, $path) = @_;
  
      open my $out, ">", $path or die "$path: $!";
      print {$out} $self->to_string;
  }
  
  sub parse {
      my($self, $file) = @_;
  
      my $code = do {
          open my $fh, "<", $file or die "$file: $!";
          join '', <$fh>;
      };
  
      my $env = Module::CPANfile::Environment->new($file);
      $env->parse($code) or die $@;
  
      $self->{_mirrors} = $env->mirrors;
      $self->{_prereqs} = $env->prereqs;
  }
  
  sub from_prereqs {
      my($proto, $prereqs) = @_;
  
      my $self = $proto->new;
      $self->{_prereqs} = Module::CPANfile::Prereqs->from_cpan_meta($prereqs);
  
      $self;
  }
  
  sub mirrors {
      my $self = shift;
      $self->{_mirrors} || [];
  }
  
  sub features {
      my $self = shift;
      map $self->feature($_), $self->{_prereqs}->identifiers;
  }
  
  sub feature {
      my($self, $identifier) = @_;
      $self->{_prereqs}->feature($identifier);
  }
  
  sub prereq { shift->prereqs }
  
  sub prereqs {
      my $self = shift;
      $self->{_prereqs}->as_cpan_meta;
  }
  
  sub merged_requirements {
      my $self = shift;
      $self->{_prereqs}->merged_requirements;
  }
  
  sub effective_prereqs {
      my($self, $features) = @_;
      $self->prereqs_with(@{$features || []});
  }
  
  sub prereqs_with {
      my($self, @feature_identifiers) = @_;
  
      my $prereqs = $self->prereqs;
      my @others = map { $self->feature($_)->prereqs } @feature_identifiers;
  
      $prereqs->with_merged_prereqs(\@others);
  }
  
  sub prereq_specs {
      my $self = shift;
      $self->prereqs->as_string_hash;
  }
  
  sub prereq_for_module {
      my($self, $module) = @_;
      $self->{_prereqs}->find($module);
  }
  
  sub options_for_module {
      my($self, $module) = @_;
      my $prereq = $self->prereq_for_module($module) or return;
      $prereq->requirement->options;
  }
  
  sub merge_meta {
      my($self, $file, $version) = @_;
  
      require CPAN::Meta;
  
      $version ||= $file =~ /\.yml$/ ? '1.4' : '2';
  
      my $prereq = $self->prereqs;
  
      my $meta = CPAN::Meta->load_file($file);
      my $prereqs_hash = $prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;
      my $struct = { %{$meta->as_struct}, prereqs => $prereqs_hash };
  
      CPAN::Meta->new($struct)->save($file, { version => $version });
  }
  
  sub _dump {
      my $str = shift;
      require Data::Dumper;
      chomp(my $value = Data::Dumper->new([$str])->Terse(1)->Dump);
      $value;
  }
  
  sub to_string {
      my($self, $include_empty) = @_;
  
      my $mirrors = $self->mirrors;
      my $prereqs = $self->prereq_specs;
  
      my $code = '';
      $code .= $self->_dump_mirrors($mirrors);
      $code .= $self->_dump_prereqs($prereqs, $include_empty);
  
      for my $feature ($self->features) {
          $code .= sprintf "feature %s, %s => sub {\n", _dump($feature->{identifier}), _dump($feature->{description});
          $code .= $self->_dump_prereqs($feature->{spec}, $include_empty, 4);
          $code .= "}\n\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_mirrors {
      my($self, $mirrors) = @_;
  
      my $code = "";
  
      for my $url (@$mirrors) {
          $code .= "mirror '$url';\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_prereqs {
      my($self, $prereqs, $include_empty, $base_indent) = @_;
  
      my $code = '';
      for my $phase (qw(runtime configure build test develop)) {
          my $indent = $phase eq 'runtime' ? '' : '    ';
          $indent = (' ' x ($base_indent || 0)) . $indent;
  
          my($phase_code, $requirements);
          $phase_code .= "on $phase => sub {\n" unless $phase eq 'runtime';
  
          for my $type (qw(requires recommends suggests conflicts)) {
              for my $mod (sort keys %{$prereqs->{$phase}{$type}}) {
                  my $ver = $prereqs->{$phase}{$type}{$mod};
                  $phase_code .= $ver eq '0'
                               ? "${indent}$type '$mod';\n"
                               : "${indent}$type '$mod', '$ver';\n";
                  $requirements++;
              }
          }
  
          $phase_code .= "\n" unless $requirements;
          $phase_code .= "};\n" unless $phase eq 'runtime';
  
          $code .= $phase_code . "\n" if $requirements or $include_empty;
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::CPANfile - Parse cpanfile
  
  =head1 SYNOPSIS
  
    use Module::CPANfile;
  
    my $file = Module::CPANfile->load("cpanfile");
    my $prereqs = $file->prereqs; # CPAN::Meta::Prereqs object
  
    my @features = $file->features; # CPAN::Meta::Feature objects
    my $merged_prereqs = $file->prereqs_with(@identifiers); # CPAN::Meta::Prereqs
  
    $file->merge_meta('MYMETA.json');
  
  =head1 DESCRIPTION
  
  Module::CPANfile is a tool to handle L<cpanfile> format to load application
  specific dependencies, not just for CPAN distributions.
  
  =head1 METHODS
  
  =over 4
  
  =item load
  
    $file = Module::CPANfile->load;
    $file = Module::CPANfile->load('cpanfile');
  
  Load and parse a cpanfile. By default it tries to load C<cpanfile> in
  the current directory, unless you pass the path to its argument.
  
  =item from_prereqs
  
    $file = Module::CPANfile->from_prereqs({
      runtime => { requires => { DBI => '1.000' } },
    });
  
  Creates a new Module::CPANfile object from prereqs hash you can get
  via L<CPAN::Meta>'s C<prereqs>, or L<CPAN::Meta::Prereqs>'
  C<as_string_hash>.
  
    # read MYMETA, then feed the prereqs to create Module::CPANfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
  
    # load cpanfile, then recreate it with round-trip
    my $file = Module::CPANfile->load('cpanfile');
    $file = Module::CPANfile->from_prereqs($file->prereq_specs);
                                      # or $file->prereqs->as_string_hash
  
  =item prereqs
  
  Returns L<CPAN::Meta::Prereqs> object out of the parsed cpanfile.
  
  =item prereq_specs
  
  Returns a hash reference that should be passed to C<< CPAN::Meta::Prereqs->new >>.
  
  =item features
  
  Returns a list of features available in the cpanfile as L<CPAN::Meta::Feature>.
  
  =item prereqs_with(@identifiers), effective_prereqs(\@identifiers)
  
  Returns L<CPAN::Meta::Prereqs> object, with merged prereqs for
  features identified with the C<@identifiers>.
  
  =item to_string($include_empty)
  
    $file->to_string;
    $file->to_string(1);
  
  Returns a canonical string (code) representation for cpanfile. Useful
  if you want to convert L<CPAN::Meta::Prereqs> to a new cpanfile.
  
    # read MYMETA's prereqs and print cpanfile representation of it
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    print $file->to_string;
  
  By default, it omits the phase where there're no modules
  registered. If you pass the argument of a true value, it will print
  them as well.
  
  =item save
  
    $file->save('cpanfile');
  
  Saves the currently loaded prereqs as a new C<cpanfile> by calling
  C<to_string>. Beware B<this method will overwrite the existing
  cpanfile without any warning or backup>. Taking a backup or giving
  warnings to users is a caller's responsibility.
  
    # Read MYMETA.json and creates a new cpanfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    $file->save('cpanfile');
  
  =item merge_meta
  
    $file->merge_meta('META.yml');
    $file->merge_meta('MYMETA.json', '2.0');
  
  Merge the effective prereqs with Meta specification loaded from the
  given META file, using CPAN::Meta. You can specify the META spec
  version in the second argument, which defaults to 1.4 in case the
  given file is YAML, and 2 if it is JSON.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<cpanfile>, L<CPAN::Meta>, L<CPAN::Meta::Spec>
  
  =cut
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;
  use strict;
  use warnings;
  use Module::CPANfile::Prereqs;
  use Carp ();
  
  my @bindings = qw(
      on requires recommends suggests conflicts
      feature
      osname
      mirror
      configure_requires build_requires test_requires author_requires
  );
  
  my $file_id = 1;
  
  sub new {
      my($class, $file) = @_;
      bless {
          file     => $file,
          phase    => 'runtime', # default phase
          feature  => undef,
          features => {},
          prereqs  => Module::CPANfile::Prereqs->new,
          mirrors  => [],
      }, $class;
  }
  
  sub bind {
      my $self = shift;
      my $pkg = caller;
  
      for my $binding (@bindings) {
          no strict 'refs';
          *{"$pkg\::$binding"} = sub { $self->$binding(@_) };
      }
  }
  
  sub parse {
      my($self, $code) = @_;
  
      my $err;
      {
          local $@;
          $file_id++;
          $self->_evaluate(<<EVAL);
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
          $err = $@;
      }
  
      if ($err) { die "Parsing $self->{file} failed: $err" };
  
      return 1;
  }
  
  sub _evaluate {
      my $_environment = $_[0];
      eval $_[1];
  }
  
  sub prereqs { $_[0]->{prereqs} }
  
  sub mirrors { $_[0]->{mirrors} }
  
  # DSL goes from here
  
  sub on {
      my($self, $phase, $code) = @_;
      local $self->{phase} = $phase;
      $code->();
  }
  
  sub feature {
      my($self, $identifier, $description, $code) = @_;
  
      # shortcut: feature identifier => sub { ... }
      if (@_ == 3 && ref($description) eq 'CODE') {
          $code = $description;
          $description = $identifier;
      }
  
      unless (ref $description eq '' && ref $code eq 'CODE') {
          Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }");
      }
  
      local $self->{feature} = $identifier;
      $self->prereqs->add_feature($identifier, $description);
  
      $code->();
  }
  
  sub osname { die "TODO" }
  
  sub mirror {
      my($self, $url) = @_;
      push @{$self->{mirrors}}, $url;
  }
  
  sub requirement_for {
      my($self, $module, @args) = @_;
  
      my $requirement = 0;
      $requirement = shift @args if @args % 2;
  
      return Module::CPANfile::Requirement->new(
          name    => $module,
          version => $requirement,
          @args,
      );
  }
  
  sub requires {
      my $self = shift;
      $self->add_prereq(requires => @_);
  }
  
  sub recommends {
      my $self = shift;
      $self->add_prereq(recommends => @_);
  }
  
  sub suggests {
      my $self = shift;
      $self->add_prereq(suggests => @_);
  }
  
  sub conflicts {
      my $self = shift;
      $self->add_prereq(conflicts => @_);
  }
  
  sub add_prereq {
      my($self, $type, $module, @args) = @_;
  
      $self->prereqs->add_prereq(
          feature => $self->{feature},
          phase   => $self->{phase},
          type    => $type,
          module  => $module,
          requirement => $self->requirement_for($module, @args),
      );
  }
  
  # Module::Install compatible shortcuts
  
  sub configure_requires {
      my($self, @args) = @_;
      $self->on(configure => sub { $self->requires(@args) });
  }
  
  sub build_requires {
      my($self, @args) = @_;
      $self->on(build => sub { $self->requires(@args) });
  }
  
  sub test_requires {
      my($self, @args) = @_;
      $self->on(test => sub { $self->requires(@args) });
  }
  
  sub author_requires {
      my($self, @args) = @_;
      $self->on(develop => sub { $self->requires(@args) });
  }
  
  1;
  
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;
  use strict;
  
  sub new {
      my($class, %options) = @_;
      bless \%options, $class;
  }
  
  sub feature { $_[0]->{feature} }
  sub phase   { $_[0]->{phase} }
  sub type    { $_[0]->{type} }
  sub module  { $_[0]->{module} }
  sub requirement { $_[0]->{requirement} }
  
  sub match_feature {
      my($self, $identifier) = @_;
      no warnings 'uninitialized';
      $self->feature eq $identifier;
  }
  
  1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;
  use strict;
  use Carp ();
  use CPAN::Meta::Feature;
  use Module::CPANfile::Prereq;
  
  sub from_cpan_meta {
      my($class, $prereqs) = @_;
  
      my $self = $class->new;
  
      for my $phase (keys %$prereqs) {
          for my $type (keys %{ $prereqs->{$phase} }) {
              while (my($module, $requirement) = each %{ $prereqs->{$phase}{$type} }) {
                  $self->add_prereq(
                      phase => $phase,
                      type  => $type,
                      module => $module,
                      requirement => Module::CPANfile::Requirement->new(name => $module, version => $requirement),
                  );
              }
          }
      }
  
      $self;
  }
  
  sub new {
      my $class = shift;
      bless {
          prereqs => [],
          features => {},
      }, $class;
  }
  
  sub add_feature {
      my($self, $identifier, $description) = @_;
      $self->{features}{$identifier} = { description => $description };
  }
  
  sub add_prereq {
      my($self, %args) = @_;
      $self->add( Module::CPANfile::Prereq->new(%args) );
  }
  
  sub add {
      my($self, $prereq) = @_;
      push @{$self->{prereqs}}, $prereq;
  }
  
  sub as_cpan_meta {
      my $self = shift;
      $self->{cpanmeta} ||= $self->build_cpan_meta;
  }
  
  sub build_cpan_meta {
      my($self, $identifier) = @_;
  
      my $prereq_spec = {};
      $self->prereq_each($identifier, sub {
          my $prereq = shift;
          $prereq_spec->{$prereq->phase}{$prereq->type}{$prereq->module} = $prereq->requirement->version;
      });
  
      CPAN::Meta::Prereqs->new($prereq_spec);
  }
  
  sub prereq_each {
      my($self, $identifier, $code) = @_;
  
      for my $prereq (@{$self->{prereqs}}) {
          next unless $prereq->match_feature($identifier);
          $code->($prereq);
      }
  }
  
  sub merged_requirements {
      my $self = shift;
  
      my $reqs = CPAN::Meta::Requirements->new;
      for my $prereq (@{$self->{prereqs}}) {
          $reqs->add_string_requirement($prereq->module, $prereq->requirement->version);
      }
  
      $reqs;
  }
  
  sub find {
      my($self, $module) = @_;
  
      for my $prereq (@{$self->{prereqs}}) {
          return $prereq if $prereq->module eq $module;
      }
  
      return;
  }
  
  sub identifiers {
      my $self = shift;
      keys %{$self->{features}};
  }
  
  sub feature {
      my($self, $identifier) = @_;
  
      my $data = $self->{features}{$identifier}
        or Carp::croak("Unknown feature '$identifier'");
  
      my $prereqs = $self->build_cpan_meta($identifier);
  
      CPAN::Meta::Feature->new($identifier, {
          description => $data->{description},
          prereqs => $prereqs->as_string_hash,
      });
  }
  
  1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;
  use strict;
  
  sub new {
      my ($class, %args) = @_;
  
      $args{version} ||= 0;
  
      bless +{
          name    => delete $args{name},
          version => delete $args{version},
          options => \%args,
      }, $class;
  }
  
  sub name    { $_[0]->{name} }
  sub version { $_[0]->{version} }
  
  sub options { $_[0]->{options} }
  
  sub has_options {
      keys %{$_[0]->{options}} > 0;
  }
  
  1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2
  package Module::Metadata; # git description: v1.000026-12-g9b12bf1
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  sub __clean_eval { eval $_[0] }
  use strict;
  use warnings;
  
  our $VERSION = '1.000027';
  
  use Carp qw/croak/;
  use File::Spec;
  BEGIN {
         # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
         eval {
                 require Fcntl; Fcntl->import('SEEK_SET'); 1;
         } or *SEEK_SET = sub { 0 }
  }
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
      Log::Contextual->import('log_info',
        '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
      );
    } else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
            if ( defined( $version ) ) {
              if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                $err .= "  $p->{file} ($p->{version})\n";
              } else {
                # same version declared multiple times, ignore
              }
            } else {
              $file    = $p->{file};
              $version = $p->{version};
            }
          }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep { $args{version} eq $_ } qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      } else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
        my @path = split( /\//, $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            } else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          } else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              $result->{err}
            };
  
          } elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
          if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              };
            }
  
          } else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
          } else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
          }
  
        } else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
              $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( not $handle ) {
      my $filename = $self->{filename};
      open $handle, '<', $filename
        or croak( "Can't open '$filename': $!" );
  
      $self->_handle_bom($handle, $filename);
    }
    $self->_parse_fh($handle);
  
    unless($self->{module} and length($self->{module})) {
      my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
      if($f =~ /\.pm$/) {
        $f =~ s/\..+$//;
        my @candidates = grep /$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # punt
      }
      else {
        if(grep /main/, @{$self->{packages}}) {
          $self->{module} = 'main';
        }
        else {
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
        if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      $testfile .= '.pm';
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile;
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sigil, $variable_name, $package);
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $package ) {
        $package = ($package eq '::') ? 'main' : $package;
        $package =~ s/::$//;
      }
    }
  
    return ( $sigil, $variable_name, $package );
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = tell $fh;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = read $fh, $buf, length $buf;
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    } elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    } elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = read $fh, $buf, length $buf;
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        binmode( $fh, ":encoding($encoding)" );
      }
    } else {
      seek $fh, $pos, SEEK_SET
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @packages, %vers, %pod, @pod );
    my $package = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
          push( @pod, $1 );
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = $1;
  
        } elsif ( $self->{collect_pod} ) {
          $pod_data .= "$line\n";
  
        }
  
      } elsif ( $is_cut ) {
  
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
  
      } else {
  
        # Skip after __END__
        next if $in_end;
  
        # Skip comments in code
        next if $line =~ /^\s*#/;
  
        # Would be nice if we could also check $in_string or something too
        if ($line eq '__END__') {
          $in_end++;
          next;
        }
        last if $line eq '__DATA__';
  
        # parse $line to see if it's a $VERSION declaration
        my( $version_sigil, $version_fullname, $version_package ) =
            index($line, 'VERSION') >= 1
                ? $self->_parse_version_expression( $line )
                : ();
  
        if ( $line =~ /$PKG_REGEXP/o ) {
          $package = $1;
          my $version = $2;
          push( @packages, $package ) unless grep( $package eq $_, @packages );
          $need_vers = defined $version ? 0 : 1;
  
          if ( not exists $vers{$package} and defined $version ){
            # Upgrade to a version object.
            my $dwim_version = eval { _dwim_version($version) };
            croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
                unless defined $dwim_version;  # "0" is OK!
            $vers{$package} = $dwim_version;
          }
  
        # VERSION defined with full package spec, i.e. $Module::VERSION
        } elsif ( $version_fullname && $version_package ) {
          push( @packages, $version_package ) unless grep( $version_package eq $_, @packages );
          $need_vers = 0 if $version_package eq $package;
  
          unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
          $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        }
  
        # first non-comment line in undeclared package main is VERSION
        } elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
          $need_vers = 0;
          my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
          $vers{$package} = $v;
          push( @packages, 'main' );
  
        # first non-comment line in undeclared package defines package main
        } elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
          $need_vers = 1;
          $vers{main} = '';
          push( @packages, 'main' );
  
        # only keep if this is the first $VERSION seen
        } elsif ( $version_fullname && $need_vers ) {
          $need_vers = 0;
          my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
  
          unless ( defined $vers{$package} && length $vers{$package} ) {
            $vers{$package} = $v;
          }
        }
      }
    }
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@packages;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $variable_name, $line ) = @_;
  
    # We compile into a local sub because 'use version' would cause
    # compiletime/runtime issues with local()
    $pn++; # everybody gets their own package
    my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        \$$variable_name
      };
    };
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    my $vsub = __clean_eval($eval);
    # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      $vsub = __clean_eval($eval);
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
  
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
  
    my $result = eval { $vsub->() };
    # FIXME: $eval is not the right thing to print here
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    # FIXME: $eval is not the right thing to print here
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
           exists( $self->{versions}{$mod} ) ) {
          return $self->{versions}{$mod};
      } else {
          return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
           exists( $self->{pod}{$sect} ) ) {
          return $self->{pod}{$sect};
      } else {
          return undef;
      }
  }
  
  sub is_indexable {
    my ($self, $package) = @_;
  
    my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;
  
    # check for specific package, if provided
    return !! grep { $_ eq $package } @indexable_packages if $package;
  
    # otherwise, check for any indexable packages at all
    return !! @indexable_packages;
  }
  
  1;
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 CLASS METHODS
  
  =head2 C<< new_from_file($filename, collect_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  =head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> argument as described above,
  this method accepts a C<inc> argument which is a reference to an array of
  directories to search for the module.  If none are given, the default is
  @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =head2 C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =head2 C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =head2 C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =head1 OBJECT METHODS
  
  =head2 C<< name() >>
  
  Returns the name of the package represented by this module. If there
  is more than one package, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =head2 C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =head2 C<< filename() >>
  
  Returns the absolute path to the file.
  Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
  
  =head2 C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =head2 C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =head2 C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =head2 C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
  
  Returns a boolean indicating whether the package (if provided) or any package
  (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
  Note This only checks for valid C<package> declarations, and does not take any
  ownership information into account.
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
MODULE_METADATA

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use Moo::_strictures;
  use Moo::_Utils;
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
  
    strict->import;
    warnings->import;
  
    if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      $old->assert_constructor;
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              require Sub::Defer;
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
  
      my %construct_opts = (
        package => $target,
        accessor_generator => $class->_accessor_maker_for($target),
        subconstructor_handler => (
          '      if ($Moo::MAKERS{$class}) {'."\n"
          .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
          .'          return $class->'.$target.'::SUPER::new(@_);'."\n"
          .'        }'."\n"
          .'        '.$class.'->_constructor_maker_for($class);'."\n"
          .'        return $class->new(@_)'.";\n"
          .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
          .'        return $meta->new_object('."\n"
          .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
          .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
          .'        );'."\n"
          .'      }'."\n"
        ),
      );
  
      my $con;
      my @isa = @{mro::get_linear_isa($target)};
      shift @isa;
      if (my ($parent_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa) {
        if ($parent_new eq 'Moo::Object') {
          # no special constructor needed
        }
        elsif (my $makers = $MAKERS{$parent_new}) {
          $con = $makers->{constructor};
          $construct_opts{construction_string} = $con->construction_string
            if $con;
        }
        elsif ($parent_new->can('BUILDALL')) {
          $construct_opts{construction_builder} = sub {
            my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
            'do {'
            .'  my $args = $class->'.$inv.'BUILDARGS(@_);'
            .'  $args->{__no_BUILD__} = 1;'
            .'  $class->'.$target.'::SUPER::new($args);'
            .'}'
          };
        }
        else {
          $construct_opts{construction_builder} = sub {
            '$class->'.$target.'::SUPER::new('
              .($target->can('FOREIGNBUILDARGS') ?
                '$class->FOREIGNBUILDARGS(@_)' : '@_')
              .')'
          };
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(%construct_opts)
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use strictures 2;
   use namespace::clean;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  C<Moo> is an extremely light-weight Object Orientation system. It allows one to
  concisely define objects and roles with a convenient syntax that avoids the
  details of Perl's object system.  C<Moo> contains a subset of L<Moose> and is
  optimised for rapid startup.
  
  C<Moo> avoids depending on any XS modules to allow for simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite --
  two thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead to provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  But if you don't want to use L<Moose>, you may not want "less metaprotocol"
  like L<Mouse> offers, but you probalby want "no metaprotocol", which is what
  Moo provides. C<Moo> is ideal for some situations where deployment or startup
  time precludes using L<Moose> and L<Mouse>:
  
  =over 2
  
  =item a command line or CGI script where fast startup is essential
  
  =item code designed to be deployed as a single file via L<App::FatPacker>
  
  =item a CPAN module that may be used by others in the above situations
  
  =back
  
  C<Moo> maintains transparent compatibility with L<Moose> so if you install and
  load L<Moose> you can use Moo clases and roles in L<Moose> code without
  modification.
  
  Moo -- Minimal Object Orientation -- aims to make it smooth to upgrade to
  L<Moose> when you need more than the minimal features offered by Moo.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without modification.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  L<Moo> classes and roles, so that in Moose classes C<< isa => 'MyMooClass' >>
  and C<< isa => 'MyMooRole' >> work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  Extending a L<Mouse> class or consuming a L<Mouse::Role> will also work. But
  note that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  global and turns the mechanism off entirely so don't put this in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  better performance.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   }
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares a base class. Multiple superclasses can be passed for multiple
  inheritance but please consider using L<roles|Moo::Role> instead.  The class
  will be loaded but no errors will be triggered if the class can't be found and
  there are already subs in the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles cannot be composed because they
  have conflicting method definitions.  The roles will be loaded using the same
  mechansim as C<extends> uses.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * C<is>
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> stands for "read-only" and generates an accessor that dies if you attempt
  to write to it - i.e.  a getter only - by defaulting C<reader> to the name of
  the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> stands for "read-write protected" and generates a reader like C<ro>, but
  also sets C<writer> to C<_set_${attribute_name}> for attributes that are
  designed to be written from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> stands for "read-write" and generates a normal getter/setter by
  defaulting the C<accessor> to the name of the attribute specified.
  
  =item * C<isa>
  
  Takes a coderef which is used to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   use Scalar::Util qw(looks_like_number);
   ...
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value for C<isa> is discarded. Only if the sub dies does
  type validation fail.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<Moose> compatible or L<MooseX::Types> style named types, look at
  L<Type::Tiny>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * C<coerce>
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always execute your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  If the C<isa> option is a blessed object providing a C<coerce> or
  C<coercion> method, then the C<coerce> option may be set to just C<1>.
  
  =item * C<handles>
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a L<role|Moo::Role> that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. The coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument to
  populate an attribute if no value for that attribute was supplied to the
  constructor. Alternatively, if the attribute is lazy, C<default> executes when
  the attribute is first retrieved if no value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  B<NOTE:> If the attribute is C<lazy>, it will be regenerated from C<default> or
  C<builder> the next time it is accessed. If it is not lazy, it will be C<undef>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on object instantiation.
  
  =item * C<reader>
  
  The name of the method that returns the value of the attribute.  If you like
  Java style methods, you might set this to C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened. Use this when circular references, which cause memory leaks, are
  possible.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... }; >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
   package Record;
  
   use Digest::MD5 qw(md5_hex);
  
   use Moo;
   use namespace::clean;
  
   has name => (is => 'ro', required => 1);
   has id => (is => 'lazy');
   sub _build_id {
     my ($self) = @_;
     return md5_hex($self->name);
   }
  
   1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> Older versions of L<namespace::autoclean> would
  inflate Moo classes to full L<Moose> classes, losing the benefits of Moo.  If
  you want to use L<namespace::autoclean> with a Moo class, make sure you are
  using version 0.16 or newer.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, L<Type::Tiny> can provide types, type libraries, and
  will work seamlessly with both L<Moo> and L<Moose>.  L<Type::Tiny> can be
  considered the successor to L<MooseX::Types> and provides a similar API, so
  that you can write
  
    use Types::Standard;
    has days_to_live => (is => 'ro', isa => Int);
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you need
  L<Moose> - Moo is small because it explicitly does not provide a metaprotocol.
  However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and
  L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  C<BUILDARGS> is not triggered if your class does not have any attributes.
  Without attributes, C<BUILDARGS> return value would be ignored, so we just
  skip calling the method instead.
  
  Handling of warnings: when you C<use Moo> we enable strict and warnings, in a
  similar way to Moose. The authors recommend the use of C<strictures>, which
  enables FATAL warnings, and several extra pragmas when used in development:
  L<indirect>, L<multidimensional>, and L<bareword::filehandles>.
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
      use strictures 2;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  bubaflub - Bob Kuo (cpan:BUBAFLUB) <bubaflub@cpan.org>
  
  ether = Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2015 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  use Moo::_strictures;
  no warnings 'once';
  use Moo::_Utils;
  use Sub::Quote qw(quotify);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    die "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
    @Moo::HandleMoose::FakeMeta::ISA = 'Moose::Meta::Method::Meta';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $am_class, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, 0, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, 1, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, 0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    foreach my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods
      = %{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Moo::Role cache is cleared so we don't confuse Moo itself.
    if (my $info = $Moo::Role::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              unless ( Scalar::Util::blessed($type)
                  && $type->isa("Moose::Meta::TypeConstraint") ) {
                die "error inflating attribute '$name' for package '$_[0]': "
                  ."\$TYPE_MAP{$isa} did not return a valid type constraint'";
              }
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = quotify($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    foreach my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    }
    elsif ($am_class) {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      my $meta_meth;
      if (
        $meta_meth = $meta->find_method_by_name('meta')
        and $meta_meth->body == \&Moo::Object::meta
      ) {
        bless($meta_meth, 'Moo::HandleMoose::FakeMeta');
      }
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Moo::Role::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  use Moo::_strictures;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    my $self = shift;
    die "Can't call $meth without object instance"
      if !ref $self;
    die "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)
  }
  sub can {
    my $self = shift;
    return $self->SUPER::can(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)
  }
  sub isa {
    my $self = shift;
    return $self->SUPER::isa(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use Moo::_strictures;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  use Config;
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/) {
      my $id = do { no warnings 'portable'; hex "$1" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  if ($Config{useithreads}) {
    my @types = %TYPE_MAP;
    tie %TYPE_MAP, __PACKAGE__;
    %TYPE_MAP = @types;
  }
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use Moo::_strictures;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    my $proto = $class->BUILDARGS(@_);
    $NO_BUILD{$class} and
      return bless({}, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({}, $class)
      : bless({}, $class)->BUILDALL($proto);
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    return !!0
      unless ($INC{'Moose/Role.pm'} || $INC{'Role/Tiny.pm'});
    require Moo::Role;
    my $does = Moo::Role->can("does_role");
    { no warnings 'redefine'; *does = $does }
    goto &$does;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use Moo::_strictures;
  use Moo::_Utils;
  use Role::Tiny ();
  our @ISA = qw(Role::Tiny);
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  BEGIN {
      *INFO = \%Role::Tiny::INFO;
      *APPLIED_TO = \%Role::Tiny::APPLIED_TO;
      *ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
  }
  
  our %INFO;
  our %APPLIED_TO;
  our %APPLY_DEFAULTS;
  our @ON_ROLE_CREATE;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
  
    _set_loaded(caller);
    strict->import;
    warnings->import;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
  
    $_->($target)
      for @ON_ROLE_CREATE;
  }
  
  push @ON_ROLE_CREATE, sub {
    my $target = shift;
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  };
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    _load_module($role);
    $self->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $self->is_role($role);
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub is_role {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    $self->SUPER::is_role($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    my $meta;
    if (!$self->SUPER::is_role($role)
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $me->is_role($role);
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    _load_module($role);
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $me->is_role($role);
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        _load_module($role);
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->apply_roles_to_package($new_name, @roles);
      _set_loaded($new_name, (caller)[1]);
      return $new_name;
    }
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Moo::Role" unless $me->is_role($role);
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    _set_loaded(ref $new, (caller)[1]);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = "{no warnings 'void';\n";
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code . ";\n";
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        $assign .= "}";
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _install_does {
      my ($me, $to) = @_;
  
      # If Role::Tiny actually installed the DOES, give it a name
      my $new = $me->SUPER::_install_does($to) or return;
      return _name_coderef("${to}::DOES", $new);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return 1
      if Role::Tiny::does_role($proto, $role);
    my $meta;
    if ($INC{'Moose.pm'}
        and $meta = Class::MOP::class_of($proto)
        and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
        and $meta->can('does_role')
    ) {
      return $meta->does_role($role);
    }
    return 0;
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    my $info = $INFO{$to};
    my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
    my %existing
      = $info ? @{$info->{attributes} || []}
      : $con  ? %{$con->all_attribute_specs || {}}
      : ();
  
    my @attr_info =
      map { @{$attr_info}[$_, $_+1] }
      grep { ! $existing{$attr_info->[$_]} }
      map { 2 * $_ } 0..@$attr_info/2-1;
  
    if ($info) {
      push @{$info->{attributes}||=[]}, @attr_info;
    }
    elsif ($con) {
      # shallow copy of the specs since the constructor will assign an index
      $con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
   use strictures 2;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
   use strictures 2;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
   package My::Role::ID;
  
   use Digest::MD5 qw(md5_hex);
   use Moo::Role;
   use Digest::SHA qw(sha1_hex);
  
   requires 'name';
  
   sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
   sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
   1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subutil => (
      $INC{"Sub/Util.pm"}
      || ( !$INC{"Sub/Name.pm"} && eval { require Sub::Util } )
    ) && defined &Sub::Util::set_subname;
  use constant can_haz_subname => (
      $INC{"Sub/Name.pm"}
      || ( !$INC{"Sub/Util.pm"} && eval { require Sub::Name } )
    ) && defined &Sub::Name::subname;
  
  use Moo::_strictures;
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use Exporter qw(import);
  use Moo::_mro;
  use Config;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction _set_loaded
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    my $module = $_[0];
    my $file = module_notional_filename($module);
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    die $error;
  }
  
  sub _maybe_load_module {
    my $module = $_[0];
    return $MAYBE_LOADED{$module}
      if exists $MAYBE_LOADED{$module};
    if(! eval { use_package_optimistically($module) }) {
      warn "$module exists but failed to load with error: $@";
    }
    elsif ( $INC{module_notional_filename($module)} ) {
      return $MAYBE_LOADED{$module} = 1;
    }
    return $MAYBE_LOADED{$module} = 0;
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subutil ? Sub::Util::set_subname(@_) :
      can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  use Moo::_strictures;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;
  use strict;
  use warnings;
  
  sub import {
    if ($ENV{MOO_FATAL_WARNINGS}) {
      require strictures;
      strictures->VERSION(2);
      @_ = ('strictures');
      goto &strictures::import;
    }
    else {
      strict->import;
      warnings->import;
    }
  }
  
  1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use Moo::_strictures;
  no warnings 'once';
  use Devel::GlobalDestruction qw(in_global_destruction);
  
  sub unimport {
    die "Can't disable Moo::sification after inflation has been done"
      if $Moo::HandleMoose::SETUP_DONE;
    our $disabled = 1;
  }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disabled or in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  sub import {
    return
      if our $setup_done;
    if ($INC{"Moose.pm"}) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    } else {
      $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
    }
    $setup_done = 1;
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use Moo::_strictures;
  use Exporter qw(import);
  use Moo::_Utils qw(_getglob _install_coderef);
  use Scalar::Util qw(weaken);
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  our @EXPORT_OK = qw(undefer_package);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    $DEFERRED{$made} = $DEFERRED{$deferred};
    weaken $DEFERRED{$made}
      unless $target;
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub undefer_package {
    my $package = shift;
    my @subs = grep { $DEFERRED{$_}[0] =~ /^${package}::[^:]+$/ } keys %DEFERRED;
    undefer_sub($_) for @subs;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred||''} or return undef;
    [ @$info ];
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($deferred_info->[3]);
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ && $_->[3] ? ($_->[3] => $_) : () } values %DEFERRED;
    foreach my $info (values %DEFERRED) {
      weaken($info)
        unless $info->[0] && ${$info->[2]};
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  Exported by default.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  Exported by default.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all defered subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.  Note this may bake the behavior of some subs that were intended to
  calculate their behavior later, so it shouldn't be used midway through a
  module load or class definition.
  
  Exported by default.
  
  =head2 undefer_package
  
    undefer_package($package);
  
  This undefers all defered subs in a package.
  
  Not exported by default.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001011';
  
  use Carp ();
  use List::Util ();
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (List::Util::first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = List::Util::first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              Carp::croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              Carp::croak $too_complicated if List::Util::first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 Carp::croak $too_complicated if List::Util::first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              Carp::croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        Carp::croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  sub _clean_eval { eval $_[0] }
  
  use Moo::_strictures;
  
  use Sub::Defer qw(defer_sub);
  use Scalar::Util qw(weaken);
  use Exporter qw(import);
  use B ();
  BEGIN {
    *_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.000002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
  our @EXPORT_OK = qw(quotify capture_unroll inlinify);
  
  our %QUOTED;
  
  sub quotify {
    ! defined $_[0]     ? 'undef()'
    : _HAVE_PERLSTRING  ? B::perlstring($_[0])
    : qq["\Q$_[0]\E"];
  }
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms) {
      my ($pre, $indent, $code_args) = ($1, $2, $3);
      $do .= $pre;
      if ($code_args ne $args) {
        $do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my ($package, $hints, $bitmask, $hintshash) = (caller(0))[0,8,9,10];
    my $context
      ="# BEGIN quote_sub PRELUDE\n"
      ."package $package;\n"
      ."BEGIN {\n"
      ."  \$^H = ".quotify($hints).";\n"
      ."  \${^WARNING_BITS} = ".quotify($bitmask).";\n"
      ."  \%^H = (\n"
      . join('', map
       "    ".quotify($_)." => ".quotify($hintshash->{$_}).",",
        keys %$hintshash)
      ."  );\n"
      ."}\n"
      ."# END quote_sub PRELUDE\n";
    $code = "$context$code";
    my $quoted_info;
    my $unquoted;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      $unquoted if 0;
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, \$unquoted, $deferred ];
    weaken($quoted_info->[3]);
    weaken($quoted_info->[4]);
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub||''} or return undef;
    my ($name, $code, $captured, $unquoted, $deferred) = @{$quoted_info};
    $unquoted &&= $$unquoted;
    if (($deferred && $deferred eq $sub)
        || ($unquoted && $unquoted eq $sub)) {
      return [ $name, $code, $captured, $unquoted, $deferred ];
    }
    return undef;
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    my $quoted = $QUOTED{$sub} or return undef;
    my $unquoted = $quoted->[3];
    unless ($unquoted && $$unquoted) {
      my ($name, $code, $captures) = @$quoted;
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_UNQUOTED'} = \$unquoted;
      $captures{'$_QUOTED'} = \$quoted;
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$\$_UNQUOTED = sub {\n"
      );
      $make_sub .= "  \$_QUOTED if 0;\n";
      $make_sub .= "  \$_UNQUOTED if 0;\n";
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$\$_UNQUOTED = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{$name} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
        weaken($QUOTED{$$unquoted} = $quoted);
      }
    }
    $$unquoted;
  }
  
  sub qsub ($) {
    goto &quote_sub;
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? (
      $_->[3] && ${$_->[3]} ? (${ $_->[3] } => $_) : (),
      $_->[4] ? ($_->[4] => $_) : (),
    ) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 quotify
  
   my $quoted_value = quotify $value;
  
  Quotes a single (non-reference) scalar value for use in a code string.  Numbers
  aren't treated specially and will be quoted as strings, but undef will quoted as
  C<undef()>.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head2 qsub
  
   my $hash = {
    coderef => qsub q{ print "hello"; },
    other   => 5,
   };
  
  Arguments: $code
  
  Works exactly like L</quote_sub>, but includes a prototype to only accept a
  single parameter.  This makes it easier to include in hash structures or lists.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few
  caveats apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_QUOTE

$fatpacked{"TOML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML';
  package TOML;
  
  # -------------------------------------------------------------------
  # TOML - Parser for Tom's Obvious, Minimal Language.
  #
  # Copyright (C) 2013 Darren Chamberlain <darren@cpan.org>
  # -------------------------------------------------------------------
  
  use 5.008005;
  use strict;
  use warnings;
  use Exporter 'import';
  
  our ($VERSION, @EXPORT, @_NAMESPACE, $PARSER);
  
  use B;
  use Carp qw(croak);
  use TOML::Parser 0.03;
  
  $VERSION = "0.96";
  @EXPORT = qw(from_toml to_toml);
  $PARSER = TOML::Parser->new(inflate_boolean  => sub { $_[0] });
  
  sub to_toml {
      my $stuff = shift;
      local @_NAMESPACE = ();
      _to_toml($stuff);
  }
  
  sub _to_toml {
      my ($stuff) = @_;
  
      if (ref $stuff eq 'HASH') {
          my $res = '';
          my @keys = sort keys %$stuff;
          for my $key (grep { ref $stuff->{$_} ne 'HASH' } @keys) {
              my $val = $stuff->{$key};
              $res .= "$key = " . _serialize($val) . "\n";
          }
          for my $key (grep { ref $stuff->{$_} eq 'HASH' } @keys) {
              my $val = $stuff->{$key};
              local @_NAMESPACE = (@_NAMESPACE, $key);
              $res .= sprintf("[%s]\n", join(".", @_NAMESPACE));
              $res .= _to_toml($val);
          }
          return $res;
      } else {
          croak("You cannot convert non-HashRef values to TOML");
      }
  }
  
  sub _serialize {
      my $value = shift;
      my $b_obj = B::svref_2object(\$value);
      my $flags = $b_obj->FLAGS;
  
      return $value
          if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
      my $type = ref($value);
      if (!$type) {
          return string_to_json($value);
      } elsif ($type eq 'ARRAY') {
          return sprintf('[%s]', join(", ", map { _serialize($_) } @$value));
      } elsif ($type eq 'SCALAR') {
          if (defined $$value) {
              if ($$value eq '0') {
                  return 'false';
              } elsif ($$value eq '1') {
                  return 'true';
              } else {
                  croak("cannot encode reference to scalar");
              }
          }
          croak("cannot encode reference to scalar");
      }
      croak("Bad type in to_toml: $type");
  }
  
  my %esc = (
      "\n" => '\n',
      "\r" => '\r',
      "\t" => '\t',
      "\f" => '\f',
      "\b" => '\b',
      "\"" => '\"',
      "\\" => '\\\\',
      "\'" => '\\\'',
  );
  sub string_to_json {
      my ($arg) = @_;
  
      $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
      $arg =~ s/\//\\\//g if 1;
      $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
      return '"' . $arg . '"';
  }
  
  sub from_toml {
      my $string = shift;
      local $@;
      my $toml = eval { $PARSER->parse($string) };
      return wantarray ? ($toml, $@) : $toml;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  TOML - Parser for Tom's Obvious, Minimal Language.
  
  =head1 SYNOPSIS
  
      use TOML qw(from_toml to_toml);
  
      # Parsing toml
      my $toml = slurp("~/.foo.toml");
      my $data = from_toml($toml);
  
      # With error checking
      my ($data, $err) = from_toml($toml);
      unless ($data) {
          die "Error parsing toml: $err";
      }
  
      # Creating toml
      my $toml = to_toml($data); 
  
  =head1 DESCRIPTION
  
  C<TOML> implements a parser for Tom's Obvious, Minimal Language, as
  defined at L<https://github.com/mojombo/toml>. C<TOML> exports two
  subroutines, C<from_toml> and C<to_toml>,
  
  =head1 FAQ
  
  =over 4
  
  =item How change how to de-serialize?
  
  You can change C<$TOML::PARSER> for change how to de-serialize.
  
  example:
  
      use TOML;
      use TOML::Parser;
  
      local $TOML::PARSER = TOML::Parser->new(
          inflate_boolean => sub { $_[0] eq 'true' ? \1 : \0 },
      );
  
      my $data = TOML::from_toml('foo = true');
  
  =back
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item from_toml
  
  C<from_toml> transforms a string containing toml to a perl data
  structure or vice versa. This data structure complies with the tests
  provided at L<https://github.com/mojombo/toml/tree/master/tests>.
  
  If called in list context, C<from_toml> produces a (C<hash>,
  C<error_string>) tuple, where C<error_string> is C<undef> on
  non-errors. If there is an error, then C<hash> will be undefined and
  C<error_string> will contains (scant) details about said error.
  
  =item to_toml
  
  C<to_toml> transforms a perl data structure into toml-formatted
  string.
  
  =back
  
  =head1 SEE ALSO
  
  L<TOML::Parser>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; version 2.
  
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  02111-1301 USA
  
  =head1 AUTHOR
  
  Darren Chamberlain <darren@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item Tokuhiro Matsuno <tokuhirom@cpan.org>
  
  =item Matthias Bethke <matthias@towiski.de>
  
  =item Sergey Romanov <complefor@rambler.ru>
  
  =item karupanerura <karupa@cpan.org>
  
  =back
TOML

$fatpacked{"TOML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER';
  package TOML::Parser;
  use 5.008005;
  use strict;
  use warnings;
  use Encode;
  
  our $VERSION = "0.06";
  
  use TOML::Parser::Tokenizer qw/:constant/;
  use TOML::Parser::Tokenizer::Strict;
  use TOML::Parser::Util qw/unescape_str/;
  use Types::Serialiser;
  
  sub new {
      my $class = shift;
      my $args  = (@_ == 1 and ref $_[0] eq 'HASH') ? +shift : +{ @_ };
      return bless +{
          inflate_datetime => sub { $_[0] },
          inflate_boolean  => sub { $_[0] eq 'true' ? Types::Serialiser::true : Types::Serialiser::false },
          strict_mode      => 0,
          %$args,
      } => $class;
  }
  
  sub parse_file {
      my ($self, $file) = @_;
      open my $fh, '<:encoding(utf-8)', $file or die $!;
      return $self->parse_fh($fh);
  }
  
  sub parse_fh {
      my ($self, $fh) = @_;
      my $src = do { local $/; <$fh> };
      return $self->parse($src);
  }
  
  sub _tokenizer_class {
      my $self = shift;
      return $self->{strict_mode} ? 'TOML::Parser::Tokenizer::Strict' : 'TOML::Parser::Tokenizer';
  }
  
  our @TOKENS;
  our $ROOT;
  our $CONTEXT;
  sub parse {
      my ($self, $src) = @_;
  
      local $ROOT    = {};
      local $CONTEXT = $ROOT;
      local @TOKENS  = $self->_tokenizer_class->tokenize($src);
      return $self->_parse_tokens();
  }
  
  sub _parse_tokens {
      my $self = shift;
  
      while (my $token = shift @TOKENS) {
          $self->_parse_token($token);
      }
  
      return $CONTEXT;
  }
  
  sub _parse_token {
      my ($self, $token) = @_;
  
      my ($type, $val) = @$token;
      if ($type eq TOKEN_TABLE) {
          $self->_parse_table($val);
      }
      elsif ($type eq TOKEN_ARRAY_OF_TABLE) {
          $self->_parse_array_of_table($val);
      }
      elsif (my ($key, $value) = $self->_parse_key_and_value($token)) {
          die "Duplicate key. key:$key" if exists $CONTEXT->{$key};
          $CONTEXT->{$key} = $value;
      }
      elsif ($type eq TOKEN_COMMENT) {
          # pass through
      }
      else {
          die "Unknown case. type:$type";
      }
  }
  
  sub _parse_key_and_value {
      my ($self, $token) = @_;
  
      my ($type, $val) = @$token;
      if ($type eq TOKEN_KEY) {
          my $token = shift @TOKENS;
  
          my $key = $val;
          my $value = $self->_parse_value_token($token);
          return ($key, $value);
      }
  
      return;
  }
  
  sub _parse_table {
      my ($self, $keys) = @_;
      my @keys = @$keys;
  
      local $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. @{[ join '.', @keys ]} cannot be `Table`";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  
      $self->_parse_tokens();
  }
  
  sub _parse_array_of_table {
      my ($self, $keys) = @_;
      my @keys     = @$keys;
      my $last_key = pop @keys;
  
      local $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. @{[ join '.', @keys ]} cannot be `Array of table`.";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  
      $CONTEXT->{$last_key} = [] unless exists $CONTEXT->{$last_key};
      die "invalid structure. @{[ join '.', @keys ]} cannot be `Array of table`" unless ref $CONTEXT->{$last_key} eq 'ARRAY';
      push @{ $CONTEXT->{$last_key} } => $CONTEXT = {};
  
      $self->_parse_tokens();
  }
  
  sub _parse_value_token {
      my $self  = shift;
      my $token = shift;
  
      my ($type, $val) = @$token;
      if ($type eq TOKEN_COMMENT) {
          return; # pass through
      }
      elsif ($type eq TOKEN_INTEGER || $type eq TOKEN_FLOAT) {
          $val =~ tr/_//d;
          return 0+$val;
      }
      elsif ($type eq TOKEN_BOOLEAN) {
          return $self->inflate_boolean($val);
      }
      elsif ($type eq TOKEN_DATETIME) {
          return $self->inflate_datetime($val);
      }
      elsif ($type eq TOKEN_STRING) {
          return unescape_str($val);
      }
      elsif ($type eq TOKEN_MULTI_LINE_STRING_BEGIN) {
          my $value = $self->_parse_value_token(shift @TOKENS);
          $value =~ s/\A\s+//msg;
          $value =~ s/\\\s+//msg;
          if (my $token = shift @TOKENS) {
              my ($type) = @$token;
              return $value if $type eq TOKEN_MULTI_LINE_STRING_END;
              die "Unexpected token: $type";
          }
      }
      elsif ($type eq TOKEN_INLINE_TABLE_BEGIN) {
          my %data;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_INLINE_TABLE_END;
              my ($key, $value) = $self->_parse_key_and_value($token);
              die "Duplicate key. key:$key" if exists $data{$key};
              $data{$key} = $value;
          }
          return \%data;
      }
      elsif ($type eq TOKEN_ARRAY_BEGIN) {
          my @data;
  
          my $last_token;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_ARRAY_END;
              if ($self->{strict_mode} && $token->[0] ne TOKEN_COMMENT) {
                  die "Unexpected token: $token->[0]" if defined $last_token && $token->[0] ne $last_token->[0];
              }
              push @data => $self->_parse_value_token($token);
              $last_token = $token;
          }
          return \@data;
      }
  
      die "Unexpected token: $type";
  }
  
  sub inflate_datetime {
      my $self = shift;
      return $self->{inflate_datetime}->(@_);
  }
  
  sub inflate_boolean {
      my $self = shift;
      return $self->{inflate_boolean}->(@_);
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords versa
  
  =head1 NAME
  
  TOML::Parser - simple toml parser
  
  =head1 SYNOPSIS
  
      use TOML::Parser;
  
      my $parser = TOML::Parser->new;
      my $data   = $parser->parse($toml);
  
  =head1 DESCRIPTION
  
  TOML::Parser is a simple toml parser.
  
  This data structure complies with the tests
  provided at L<https://github.com/toml-lang/toml/tree/v0.4.0/tests>.
  
  The v0.4.0 specification is supported.
  
  =head1 METHODS
  
  =over
  
  =item my $parser = TOML::Parser->new(\%args)
  
  Creates a new TOML::Parser instance.
  
      use TOML::Parser;
  
      # create new parser
      my $parser = TOML::Parser->new();
  
  Arguments can be:
  
  =over
  
  =item * C<inflate_datetime>
  
  If use it, You can replace inflate C<datetime> process.
  The subroutine of default is C<identity>. C<e.g.) sub { $_[0] }>
  
      use TOML::Parser;
      use DateTime;
      use DateTime::Format::ISO8601;
  
      # create new parser
      my $parser = TOML::Parser->new(
          inflate_datetime => sub {
              my $dt = shift;
              return DateTime::Format::ISO8601->parse_datetime($dt);
          },
      );
  
  =item * C<inflate_boolean>
  
  If use it, You can replace inflate boolean process.
  The return value of default subroutine is C<Types::Serialiser::true> or C<Types::Serialiser::false>.
  
      use TOML::Parser;
  
      # create new parser
      my $parser = TOML::Parser->new(
          inflate_boolean => sub {
              my $boolean = shift;
              return $boolean eq 'true' ? 1 : 0;
          },
      );
  
  =item * C<strict_mode>
  
  TOML::Parser is using a more flexible rule for compatibility with old TOML of default.
  If make this option true value, You can parse a toml with strict rule.
  
      use TOML::Parser;
  
      # create new parser
      my $parser = TOML::Parser->new(
          strict_mode => 1
      );
  
  =back
  
  =item my $data = $parser->parse_file($path)
  
  =item my $data = $parser->parse_fh($fh)
  
  =item my $data = $parser->parse($src)
  
  Transforms a string containing toml to a perl data structure or vice versa.
  
  =back
  
  =head1 SEE ALSO
  
  L<TOML>
  
  =head1 LICENSE
  
  Copyright (C) karupanerura.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  karupanerura E<lt>karupa@cpan.orgE<gt>
  
  =head1 CONTRIBUTOR
  
  Olivier Mengué E<lt>dolmen@cpan.orgE<gt>
  
  =cut
TOML_PARSER

$fatpacked{"TOML/Parser/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER';
  package TOML::Parser::Tokenizer;
  use 5.008005;
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  
  use constant DEBUG => $ENV{TOML_PARSER_TOKENIZER_DEBUG} ? 1 : 0;
  
  BEGIN {
      my @TOKENS = map uc, qw/
          comment
          table
          array_of_table
          key
          integer
          float
          boolean
          datetime
          string
          multi_line_string_begin
          multi_line_string_end
          inline_table_begin
          inline_table_end
          array_begin
          array_end
      /;
      my %CONSTANTS = map {
          ("TOKEN_$_" => $_)
      } @TOKENS;
  
      require constant;
      constant->import(\%CONSTANTS);
  
      # Exporter
      our @EXPORT_OK   = keys %CONSTANTS;
      our %EXPORT_TAGS = (
          constant => [keys %CONSTANTS],
      );
  };
  
  sub grammar_regexp {
      return +{
          comment        => qr{#(.*)},
          table          => {
              start => qr{\[},
              key   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^.\s\\\]]+))},
              sep   => qr{\.},
              end   => qr{\]},
          },
          array_of_table => {
              start => qr{\[\[},
              key   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^.\s\\\]]+))},
              sep   => qr{\.},
              end   => qr{\]\]},
          },
          key            => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^\s]+))\s*=},
          value          => {
              datetime => qr{([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.[0-9]+)?(?:Z|[-+][0-9]{2}:[0-9]{2}))},
              float    => qr{([-+]?(?:[0-9_]+(?:\.[0-9_]+)?[eE][-+]?[0-9_]+|[0-9_]*\.[0-9_]+))},
              integer  => qr{([-+]?[0-9_]+)},
              boolean  => qr{(true|false)},
              string   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\')},
              mlstring => qr{("""|''')},
              inline   => {
                  start => qr{\{},
                  sep   => qr{\s*,\s*},
                  end   => qr{\}},
              },
              array    => {
                  start => qr{\[},
                  sep   => qr{\s*,\s*},
                  end   => qr{\]},
              },
          },
      };
  }
  
  sub tokenize {
      my ($class, $src) = @_;
  
      local $_ = $src;
      return $class->_tokenize();
  }
  
  sub _tokenize {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
  
      my @tokens;
      until (/\G\z/mgco) {
          if (/\G$grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              $class->_skip_whitespace();
              push @tokens => [TOKEN_COMMENT, $1 || ''];
          }
          elsif (/\G$grammar_regexp->{array_of_table}->{start}/mgc) {
              push @tokens => $class->_tokenize_array_of_table();
          }
          elsif (/\G$grammar_regexp->{table}->{start}/mgc) {
              push @tokens => $class->_tokenize_table();
          }
          elsif (my @t = $class->_tokenize_key_and_value()) {
              push @tokens => @t;
          }
          elsif (/\G\s+/mgco) {
              # pass through
              $class->_skip_whitespace();
          }
          else {
              $class->_syntax_error();
          }
      }
      return @tokens;
  }
  
  sub _tokenize_key_and_value {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
  
      my @tokens;
      if (/\G$grammar_regexp->{key}/mgc) {
          my $key = $1 || $2 || $3;
          warn "[TOKEN] KEY: $key" if DEBUG;
          $class->_skip_whitespace();
          push @tokens => [TOKEN_KEY, $key];
          push @tokens => $class->_tokenize_value();
          return @tokens;
      }
  
      return;
  }
  
  sub _tokenize_value {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
      warn "[CALL] _tokenize_value" if DEBUG;
  
      if (/\G$grammar_regexp->{comment}/mgc) {
          warn "[TOKEN] COMMENT: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_COMMENT, $1 || ''];
      }
      elsif (/\G$grammar_regexp->{value}->{datetime}/mgc) {
          warn "[TOKEN] DATETIME: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_DATETIME, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{float}/mgc) {
          warn "[TOKEN] FLOAT: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_FLOAT, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{integer}/mgc) {
          warn "[TOKEN] INTEGER: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_INTEGER, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{boolean}/mgc) {
          warn "[TOKEN] BOOLEAN: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_BOOLEAN, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{mlstring}/mgc) {
          warn "[TOKEN] BOOLEAN: $1" if DEBUG;
          return (
              [TOKEN_MULTI_LINE_STRING_BEGIN],
              $class->_extract_multi_line_string($1),
              [TOKEN_MULTI_LINE_STRING_END],
          );
      }
      elsif (/\G$grammar_regexp->{value}->{string}/mgc) {
          warn "[TOKEN] STRING: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_STRING, $1 || $2 || ''];
      }
      elsif (/\G$grammar_regexp->{value}->{inline}->{start}/mgc) {
          warn "[TOKEN] INLINE TABLE" if DEBUG;
          $class->_skip_whitespace();
          return (
              [TOKEN_INLINE_TABLE_BEGIN],
              $class->_tokenize_inline_table(),
              [TOKEN_INLINE_TABLE_END],
          );
      }
      elsif (/\G$grammar_regexp->{value}->{array}->{start}/mgc) {
          warn "[TOKEN] ARRAY" if DEBUG;
          $class->_skip_whitespace();
          return (
              [TOKEN_ARRAY_BEGIN],
              $class->_tokenize_array(),
              [TOKEN_ARRAY_END],
          );
      }
  
      $class->_syntax_error();
  }
  
  sub _tokenize_table {
      my $class = shift;
  
      my $grammar_regexp = $class->grammar_regexp()->{table};
      warn "[CALL] _tokenize_table" if DEBUG;
  
      $class->_skip_whitespace();
  
      my @expected = ($grammar_regexp->{key});
  
      my @keys;
   LOOP:
      while (1) {
          for my $rx (@expected) {
              if (/\G$rx/smgc) {
                  if ($rx eq $grammar_regexp->{key}) {
                      my $key = $1 || $2 || $3;
                      warn "[TOKEN] table key: $key" if DEBUG;
                      push @keys => $key;
                      @expected = ($grammar_regexp->{sep}, $grammar_regexp->{end});
                  }
                  elsif ($rx eq $grammar_regexp->{sep}) {
                      warn "[TOKEN] table key separator" if DEBUG;
                      @expected = ($grammar_regexp->{key});
                  }
                  elsif ($rx eq $grammar_regexp->{end}) {
                      warn "[TOKEN] table key end" if DEBUG;
                      @expected = ();
                      last LOOP;
                  }
                  $class->_skip_whitespace();
                  next LOOP;
              }
          }
  
          $class->_syntax_error();
      }
  
      warn "[TOKEN] TABLE: @{[ join '.', @keys ]}" if DEBUG;
      return [TOKEN_TABLE, \@keys];
  }
  
  sub _tokenize_array_of_table {
      my $class = shift;
  
      my $grammar_regexp = $class->grammar_regexp()->{array_of_table};
      warn "[CALL] _tokenize_array_of_table" if DEBUG;
  
      $class->_skip_whitespace();
  
      my @expected = ($grammar_regexp->{key});
  
      my @keys;
   LOOP:
      while (1) {
          for my $rx (@expected) {
              if (/\G$rx/smgc) {
                  if ($rx eq $grammar_regexp->{key}) {
                      my $key = $1 || $2 || $3;
                      warn "[TOKEN] table key: $key" if DEBUG;
                      push @keys => $key;
                      @expected = ($grammar_regexp->{sep}, $grammar_regexp->{end});
                  }
                  elsif ($rx eq $grammar_regexp->{sep}) {
                      warn "[TOKEN] table key separator" if DEBUG;
                      @expected = ($grammar_regexp->{key});
                  }
                  elsif ($rx eq $grammar_regexp->{end}) {
                      warn "[TOKEN] table key end" if DEBUG;
                      @expected = ();
                      last LOOP;
                  }
                  $class->_skip_whitespace();
                  next LOOP;
              }
          }
  
          $class->_syntax_error();
      }
  
      warn "[TOKEN] ARRAY_OF_TABLE: @{[ join '.', @keys ]}" if DEBUG;
      return [TOKEN_ARRAY_OF_TABLE, \@keys];
  }
  
  sub _extract_multi_line_string {
      my ($class, $delimiter) = @_;
      if (/\G(.+?)\Q$delimiter/smgc) {
          warn "[TOKEN] MULTI LINE STRING: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_STRING, $1];
      }
      $class->_syntax_error();
  }
  
  sub _tokenize_inline_table {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp()->{value}->{inline};
      warn "[CALL] _tokenize_inline_table" if DEBUG;
      return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;
  
      my @tokens = $class->_tokenize_key_and_value();
      while (/\G$grammar_regexp->{sep}/smgc || !/\G$grammar_regexp->{end}/mgc) {
          last if /\G$grammar_regexp->{end}/mgc;
          warn "[CONTEXT] _tokenize_inline_table [loop]" if DEBUG;
          $class->_skip_whitespace();
          push @tokens => $class->_tokenize_key_and_value();
          $class->_skip_whitespace();
      }
  
      return @tokens;
  }
  
  sub _tokenize_array {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp()->{value}->{array};
      warn "[CALL] _tokenize_array" if DEBUG;
      return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;
  
      my @tokens = $class->_tokenize_value();
      while (/\G$grammar_regexp->{sep}/smgc || !/\G$grammar_regexp->{end}/mgc) {
          last if /\G$grammar_regexp->{end}/mgc;
          warn "[CONTEXT] _tokenize_array [loop]" if DEBUG;
          $class->_skip_whitespace();
          push @tokens => $class->_tokenize_value();
          $class->_skip_whitespace();
      }
  
      return @tokens;
  }
  
  sub _skip_whitespace {
      my $class = shift;
      if (/\G\s+/smgco) {
          # pass through
          warn "[PASS] WHITESPACE" if DEBUG;
      }
  }
  
  sub _syntax_error { shift->_error('Syntax Error') }
  
  sub _error {
      my ($class, $msg) = @_;
  
      my $src   = $_;
      my $line  = 1;
      my $start = pos $src || 0;
      while ($src =~ /$/smgco and pos $src <= pos) {
          $start = pos $src;
          $line++;
      }
      my $end = pos $src;
      my $len = pos() - $start;
      $len-- if $len > 0;
  
      my $trace = join "\n",
          "${msg}: line:$line",
          substr($src, $start || 0, $end - $start),
          (' ' x $len) . '^';
      die $trace, "\n";
  }
  
  1;
  __END__
TOML_PARSER_TOKENIZER

$fatpacked{"TOML/Parser/Tokenizer/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER_STRICT';
  package TOML::Parser::Tokenizer::Strict;
  use 5.008005;
  use strict;
  use warnings;
  
  use parent qw/TOML::Parser::Tokenizer/;
  BEGIN { import TOML::Parser::Tokenizer qw/:constant/ }
  
  sub grammar_regexp {
      my $grammar_regexp = {%{ shift->SUPER::grammar_regexp() }};
      $grammar_regexp->{table}                 = {%{ $grammar_regexp->{table} }};
      $grammar_regexp->{array_of_table}        = {%{ $grammar_regexp->{array_of_table} }};
      $grammar_regexp->{table}->{key}          = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))};
      $grammar_regexp->{array_of_table}->{key} = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))};
      $grammar_regexp->{key}                   = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))\s*=};
      return $grammar_regexp;
  }
  
  1;
  __END__
TOML_PARSER_TOKENIZER_STRICT

$fatpacked{"TOML/Parser/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_UTIL';
  package TOML::Parser::Util;
  use 5.008005;
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw/unescape_str/;
  
  sub unescape_str {
      my $str = shift;
  
      $str =~ s!\\b !\x08!xmgo;      # backspace       (U+0008)
      $str =~ s!\\t !\x09!xmgo;      # tab             (U+0009)
      $str =~ s!\\n !\x0A!xmgo;      # linefeed        (U+000A)
      $str =~ s!\\f !\x0C!xmgo;      # form feed       (U+000C)
      $str =~ s!\\r !\x0D!xmgo;      # carriage return (U+000D)
      $str =~ s!\\" !\x22!xmgo;      # quote           (U+0022)
      $str =~ s!\\/ !\x2F!xmgo;      # slash           (U+002F)
      $str =~ s!\\\\!\x5C!xmgo;      # backslash       (U+005C)
      $str =~ s{\\u([0-9A-Fa-f]{4})}{# unicode         (U+XXXX)
          chr hex $1
      }xmgeo;
      $str =~ s{\\U([0-9A-Fa-f]{8})}{# unicode         (U+XXXXXXXX)
          chr hex $1
      }xmgeo;
  
      return $str;
  }
  
  1;
  __END__
TOML_PARSER_UTIL

$fatpacked{"Text/MicroTemplate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_MICROTEMPLATE';
  # modified for NanoA by kazuho, some modified by tokuhirom
  # based on Mojo::Template. Copyright (C) 2008, Sebastian Riedel.
  
  package Text::MicroTemplate;
  
  require Exporter;
  
  use strict;
  use warnings;
  use constant DEBUG => $ENV{MICRO_TEMPLATE_DEBUG} || 0;
  use 5.00800;
  
  use Scalar::Util;
  
  our $VERSION = '0.24';
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(encoded_string build_mt render_mt);
  our %EXPORT_TAGS = (
      all => [ @EXPORT_OK ],
  );
  our $_mt_setter = '';
  
  sub new {
      my $class = shift;
      my $self = bless {
          code                => undef,
          comment_mark        => '#',
          expression_mark     => '=',
          line_start          => '?',
          template            => undef,
          tree                => [],
          tag_start           => '<?',
          tag_end             => '?>',
          escape_func         => \&_inline_escape_html,
          prepend             => '',
          package_name        => undef, # defaults to caller
          @_ == 1 ? ref($_[0]) ? %{$_[0]} : (template => $_[0]) : @_,
      }, $class;
      if (defined $self->{template}) {
          $self->parse($self->{template});
      }
      unless (defined $self->{package_name}) {
          $self->{package_name} = 'main';
          my $i = 0;
          while (my $c = caller(++$i)) {
              if ($c !~ /^Text::MicroTemplate\b/) {
                  $self->{package_name} = $c;
                  last;
              }
          }
      }
      $self;
  }
  
  sub escape_func {
      my $self = shift;
      if (@_) {
          $self->{escape_func} = shift;
      }
      $self->{escape_func};
  }
  
  sub package_name {
      my $self = shift;
      if (@_) {
          $self->{package_name} = shift;
      }
      $self->{package_name};
  }
  
  sub template { shift->{template} }
  
  sub code {
      my $self = shift;
      unless (defined $self->{code}) {
          $self->_build();
      }
      $self->{code};
  }
  
  sub _build {
      my $self = shift;
      
      my $escape_func = $self->{escape_func} || '';
  
      my $embed_escape_func = ref($escape_func) eq 'CODE'
          ? $escape_func
          : sub{ $escape_func . "(@_)" };
  
      # Compile
      my @lines;
      my $last_was_code;
      my $last_text;
      for my $line (@{$self->{tree}}) {
  
          # New line
          push @lines, '';
          for (my $j = 0; $j < @{$line}; $j += 2) {
              my $type  = $line->[$j];
              my $value = $line->[$j + 1];
  
              if ($type ne 'text' && defined $last_text) {
                  # do not mess the start of current line, since it might be
                  # the start of "=pod", etc.
                  $lines[
                      $j == 0 && @lines >= 2 ? -2 : -1
                  ] .= "\$_MT .=\"$last_text\";";
                  undef $last_text;
              }
              
              # Need to fix line ending?
              my $newline = chomp $value;
  
              # add semicolon to last line of code
              if ($last_was_code && $type ne 'code') {
                  $lines[-1] .= ';';
                  undef $last_was_code;
              }
  
              # Text
              if ($type eq 'text') {
  
                  # Quote and fix line ending
                  $value = quotemeta($value);
                  $value .= '\n' if $newline;
  
                  $last_text = defined $last_text ? "$last_text$value" : $value;
              }
  
              # Code
              if ($type eq 'code') {
                  $lines[-1] .= $value;
                  $last_was_code = 1;
              }
  
              # Expression
              if ($type eq 'expr') {
                  my $escaped = $embed_escape_func->('$_MT_T');
                  if ($newline && $value =~ /\n/) {
                      $value .= "\n"; # temporary workaround for t/13-heredoc.t
                  }
                  $lines[-1] .= "\$_MT_T = $value;\$_MT .= ref \$_MT_T eq 'Text::MicroTemplate::EncodedString' ? \$\$_MT_T : $escaped; \$_MT_T = '';";
              }
          }
      }
  
      # add semicolon to last line of code
      if ($last_was_code) {
          $lines[-1] .= "\n;";
      }
      # add last text line(s)
      if (defined $last_text) {
          $lines[-1] .= "\$_MT .=\"$last_text\";";
      }
      
      # Wrap
      $lines[0]   = q/sub { my $_MT = ''; local $/ . $self->{package_name} . q/::_MTREF = \$_MT; my $_MT_T = '';/ . (@lines ? $lines[0] : '');
      $lines[-1] .= q/return $_MT; }/;
  
      $self->{code} = join "\n", @lines;
      return $self;
  }
  
  # I am so smart! I am so smart! S-M-R-T! I mean S-M-A-R-T...
  sub parse {
      my ($self, $tmpl) = @_;
      $self->{template} = $tmpl;
  
      # Clean start
      delete $self->{tree};
      delete $self->{code};
  
      # Tags
      my $line_start    = quotemeta $self->{line_start};
      my $tag_start     = quotemeta $self->{tag_start};
      my $tag_end       = quotemeta $self->{tag_end};
      my $cmnt_mark     = quotemeta $self->{comment_mark};
      my $expr_mark     = quotemeta $self->{expression_mark};
  
      # Tokenize
      my $state = 'text';
      my @lines = split /(\n)/, $tmpl;
      my $tokens = [];
      while (@lines) {
          my $line = shift @lines;
          my $newline = undef;
          if (@lines) {
              shift @lines;
              $newline = 1;
          }
          
          if ($state eq 'text') {
              # Perl line without return value
              if ($line =~ /^$line_start\s+(.*)$/) {
                  push @{$self->{tree}}, ['code', $1];
                  next;
              }
              # Perl line with return value
              if ($line =~ /^$line_start$expr_mark\s+(.+)$/) {
                  push @{$self->{tree}}, [
                      'expr', $1,
                      $newline ? ('text', "\n") : (),
                  ];
                  next;
              }
              # Comment line, dummy token needed for line count
              if ($line =~ /^$line_start$cmnt_mark/) {
                  push @{$self->{tree}}, [];
                  next;
              }
          }
  
          # Escaped line ending?
          if ($line =~ /(\\+)$/) {
              my $length = length $1;
              # Newline escaped
              if ($length == 1) {
                  $line =~ s/\\$//;
              }
              # Backslash escaped
              if ($length >= 2) {
                  $line =~ s/\\\\$/\\/;
                  $line .= "\n";
              }
          } else {
              $line .= "\n" if $newline;
          }
  
          # Mixed line
          for my $token (split /
              (
                  $tag_start$expr_mark     # Expression
              |
                  $tag_start$cmnt_mark     # Comment
              |
                  $tag_start               # Code
              |
                  $tag_end                 # End
              )
          /x, $line) {
  
              # handle tags and bail out
              if ($token eq '') {
                  next;
              } elsif ($token =~ /^$tag_end$/) {
                  $state = 'text';
                  next;
              } elsif ($token =~ /^$tag_start$/) {
                  $state = 'code';
                  next;
              } elsif ($token =~ /^$tag_start$cmnt_mark$/) {
                  $state = 'cmnt';
                  next;
              } elsif ($token =~ /^$tag_start$expr_mark$/) {
                  $state = 'expr';
                  next;
              }
  
              # value
              if ($state eq 'text') {
                  push @$tokens, $state, $token;
              } elsif ($state eq 'cmnt') {
                  next; # ignore comments
              } elsif ($state eq 'cont') {
                  $tokens->[-1] .= $token;
              } else {
                  # state is code or expr
                  push @$tokens, $state, $token;
                  $state = 'cont';
              }
          }
          if ($state eq 'text') {
              push @{$self->{tree}}, $tokens;
              $tokens = [];
          }
      }
      push @{$self->{tree}}, $tokens
          if @$tokens;
      
      return $self;
  }
  
  sub _context {
      my ($self, $text, $line) = @_;
      my @lines  = split /\n/, $text;
      
      join '', map {
          0 < $_ && $_ <= @lines ? sprintf("%4d: %s\n", $_, $lines[$_ - 1]) : ''
      } ($line - 2) .. ($line + 2);
  }
  
  # Debug goodness
  sub _error {
      my ($self, $error, $line_offset, $from) = @_;
      
      # Line
      if ($error =~ /^(.*)\s+at\s+\(eval\s+\d+\)\s+line\s+(\d+)/) {
          my $reason = $1;
          my $line   = $2 - $line_offset;
          my $delim  = '-' x 76;
          
          my $report = "$reason at line $line in template passed from $from.\n";
          my $template = $self->_context($self->{template}, $line);
          $report .= "$delim\n$template$delim\n";
  
          # Advanced debugging
          if (DEBUG) {
              my $code = $self->_context($self->code, $line);
              $report .= "$code$delim\n";
              $report .= $error;
          }
  
          return $report;
      }
  
      # No line found
      return "Template error: $error";
  }
  
  # create raw string (that does not need to be escaped)
  sub encoded_string {
      Text::MicroTemplate::EncodedString->new($_[0]);
  }
  
  
  sub _inline_escape_html{
      my($variable) = @_;
  
      my $source = qq{
          do{
              $variable =~ s/([&><"'])/\$Text::MicroTemplate::_escape_table{\$1}/ge;
              $variable;
          }
      }; #" for poor editors
      $source =~ s/\n//g; # to keep line numbers
      return $source;
  }
  
  our %_escape_table = ( '&' => '&amp;', '>' => '&gt;', '<' => '&lt;', q{"} => '&quot;', q{'} => '&#39;' );
  sub escape_html {
      my $str = shift;
      return ''
          unless defined $str;
      return $str->as_string
          if ref $str eq 'Text::MicroTemplate::EncodedString';
      $str =~ s/([&><"'])/$_escape_table{$1}/ge; #' for poor editors
      return $str;
  }
  
  sub build_mt {
      my $mt = Text::MicroTemplate->new(@_);
      $mt->build();
  }
  
  sub build {
      my $_mt = shift;
      Scalar::Util::weaken($_mt) if $_mt_setter;
      my $_code = $_mt->code;
      my $_from = sub {
          my $i = 0;
          while (my @c = caller(++$i)) {
              return "$c[1] at line $c[2]"
                  if $c[0] ne __PACKAGE__;
          }
          '';
      }->();
      my $line_offset = (() = ($_mt->{prepend} =~ /\n/sg)) + 5;
      my $expr = << "...";
  package $_mt->{package_name};
  sub {
      ${_mt_setter}local \$SIG{__WARN__} = sub { print STDERR \$_mt->_error(shift, $line_offset, \$_from) };
      $_mt->{prepend}
      Text::MicroTemplate::encoded_string((
          $_code
      )->(\@_));
  }
  ...
  
      if(DEBUG >= 2){
          DEBUG >= 3 ? die $expr : warn $expr;
      }
  
      my $die_msg;
      {
          local $@;
          if (my $_builder = eval($expr)) {
              return $_builder;
          }
          $die_msg = $_mt->_error($@, $line_offset, $_from);
      }
      die $die_msg;
  }
  
  sub render_mt {
      my $builder = build_mt(shift);
      $builder->(@_);
  }
  
  # ? $_mt->filter(sub { s/\s+//smg; s/[\r\n]//g; })->(sub { ... ? });
  sub filter {
      my ($self, $callback) = @_;
      my $mtref = do {
          no strict 'refs';
          ${"$self->{package_name}::_MTREF"};
      };
      my $before = $$mtref;
      $$mtref = '';
      return sub {
          my $inner_func = shift;
          $inner_func->(@_);
  
          ## sub { s/foo/bar/g } is a valid filter
          ## sub { DateTime::Format::Foo->parse_string(shift) } is valid too
          local $_ = $$mtref;
          my $retval = $callback->($$mtref);
          no warnings 'uninitialized';
          if (($retval =~ /^\d+$/ and $_ ne $$mtref) or (defined $retval and !$retval)) {
              $$mtref = $before . $_;
          } else {
              $$mtref = $before . $retval;
          }
      }
  }
  
  package Text::MicroTemplate::EncodedString;
  
  use strict;
  use warnings;
  
  use overload q{""} => sub { shift->as_string }, fallback => 1;
  
  sub new {
      my ($klass, $str) = @_;
      bless \$str, $klass;
  }
  
  sub as_string {
      my $self = shift;
      $$self;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::MicroTemplate - Micro template engine with Perl5 language
  
  =head1 SYNOPSIS
  
      use Text::MicroTemplate qw(:all);
  
      # compile template, and render
      $renderer = build_mt('hello, <?= $_[0] ?>');
      $html = $renderer->('John')->as_string;
  
      # or in one line
      $html = render_mt('hello, <?= $_[0] ?>', 'John')->as_string;
  
      # complex form
      $mt = Text::MicroTemplate->new(
          template => 'hello, <?= $query->param('user') ?>',
      );
      $code = $mt->code;
      $renderer = eval << "..." or die $@;
      sub {
          my \$query = shift;
          $code->();
      }
      ...
      $html = $renderer->(CGI->new)->as_string;
  
  =head1 DESCRIPTION
  
  Text::MicroTemplate is a standalone, fast, intelligent, extensible template engine with following features.
  
  =head2 standalone
  
  Text::MicroTemplate does not rely on other CPAN modules.
  
  =head2 fast
  
  Based on L<Mojo::Template>, expressions in the template is perl code.
  
  =head2 intelligent
  
  Text::MicroTemplate automatically escapes variables when and only when necessary.
  
  =head2 extensible
  
  Text::MicroTemplate does not provide features like template cache or including other files by itself.  However, it is easy to add you own (that suites the most to your application), by wrapping the result of the module (which is a perl expression).
  
  The module only provides basic building blocks for a template engine.  Refer to L<Text::MicroTemplate::File> for higher-level interface.
  
  =head1 TEMPLATE SYNTAX
  
  The template language is Perl5 itself!
  
      # output the result of expression with automatic escape
      <?= $expr ?>             (tag style)
      ?= $expr                 (per-line)
  
      # execute perl code (tag style)
      <? foo() ?>
      ? foo()
  
      # comment (tag style)
      <?# comment ?>
      ?# comment
  
      # loops
      <ul>
      ? for my $item (@list) {
      <li><?= $item ?></li>
      ? }
      </ul>
  
  =head1 EXPORTABLE FUNCTIONS
  
  =head2 build_mt($template)
  
  Returns a subref that renders given template.  Parameters are equivalent to Text::MicroTemplate->new.
  
      # build template renderer at startup time and use it multiple times
      my $renderer = build_mt('hello, <?= $_[0] ?>!');
  
      sub run {
          ...
          my $hello = $renderer->($query->param('user'));
          ...
      }
  
  =head2 render_mt($template, @args)
  
  Utility function that combines build_mt and call to the generated template builder.
  
      # render
      $hello = render_mt('hello, <?= $_[0] ?>!', 'John');
  
      # print as HTML
      print $hello->as_string;
  
      # use the result in another template (no double-escapes)
      $enc = render_mt('<h1><?= $_[0] ?></h1>', $hello);
  
  Internally, the function is equivalent to:
  
      build_mt($template)->(@_);
  
  =head2 encoded_string($str)
  
  wraps given string to an object that will not be escaped by the template engine
  
  =head1 OO-STYLE INTERFACE
  
  Text::MicroTemplate provides OO-style interface to handle more complex cases.
  
  =head2 new($template)
  
  =head2 new(%args)
  
  =head2 new(\%args)
  
  Constructs template renderer.  In the second or third form, parameters below are recognized.
  
  =head3 template
  
  template string (mandatory)
  
  =head3 escape_func
  
  escape function (defaults to L<Text::MicroTemplate::escape_html>), no escape when set to undef
  
  =head3 package_name
  
  package under where the renderer is compiled (defaults to caller package)
  
  =head3 prepend
  
  Prepends Perl code to the template.
  
  =head2 code()
  
  returns perl code that renders the template when evaluated
  
  =head2 filter(sub filter_func { ... })->(sub { template lines })
  
  filters given template lines
  
      ? $_mt->filter(sub { s/Hello/Good bye/g })->(sub {
      Hello, John!
      ? })
  
  =head1 DEBUG
  
  The C<MICRO_TEMPLATE_DEBUG> environment variable helps debugging.
  The value C<1> extends debugging messages, C<2> reports compiled
  Perl code with C<warn()>, C<3> is like C<2> but uses C<die()>.
  
  =head1 SEE ALSO
  
  L<Text::MicroTemplate::File>
  
  L<Text::MicroTemplate::Extended>
  
  =head1 AUTHOR
  
  Kazuho Oku E<lt>kazuhooku gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom AAJKLFJEF GMAIL COME<gt>
  
  The module is based on L<Mojo::Template> by Sebastian Riedel.
  
  =head1 LICENSE
  
  This program is free software, you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
TEXT_MICROTEMPLATE

$fatpacked{"Text/MicroTemplate/EncodedString.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_MICROTEMPLATE_ENCODEDSTRING';
  # the package in implemented intentionally in Text::MicroTemplate
  use Text::MicroTemplate;
  1;
TEXT_MICROTEMPLATE_ENCODEDSTRING

$fatpacked{"Text/MicroTemplate/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_MICROTEMPLATE_FILE';
  package Text::MicroTemplate::File;
  
  use strict;
  use warnings;
  use File::Spec;
  use Text::MicroTemplate;
  
  sub croak {require Carp; goto &Carp::croak}
  
  our @ISA = qw(Text::MicroTemplate);
  
  sub new {
      my $klass = shift;
      my $self = $klass->SUPER::new(@_);
      $self->{include_path} ||= [ '.' ];
      unless (defined $self->{open_layer}) {
          $self->{open_layer} = ':utf8';
      }
      unless (ref $self->{include_path}) {
          $self->{include_path} = [ $self->{include_path} ];
      }
      $self->{use_cache} ||= 0;
      $self->{cache} = {};  # file => { mtime, sub }
      $self;
  }
  
  sub include_path {
      my $self = shift;
      croak("This is readonly accessor") if @_;
      $self->{include_path};
  }
  
  sub open_layer {
      my $self = shift;
      $self->{open_layer} = $_[0]
          if @_;
      $self->{open_layer};
  }
  
  sub use_cache {
      my $self = shift;
      $self->{use_cache} = $_[0]
          if @_;
      $self->{use_cache};
  }
  
  sub build_file {
      my ($self, $file) = @_;
      # return cached entry
      if ($self->{use_cache} == 2) {
          if (my $e = $self->{cache}->{$file}) {
              return $e->[1];
          }
      }
      # setup ($filepath, @st)
      my ($filepath, @st);
      if (File::Spec->file_name_is_absolute($file)) {
          # absolute path
          $filepath = $file;
          @st = stat $filepath;
      } else {
          # relative path, search "include_path"s
          foreach my $path (@{$self->{include_path}}) {
              $filepath = $path . '/' . $file;
              @st = stat $filepath
                  and last;
          }
      }
      croak("could not find template file: $file (include_path: @{$self->{include_path}})")
          unless @st;
  
      # return cached entry after comparing mtime
      if (my $e = $self->{cache}->{$file}) {
          return $e->[1]
              if $st[9] == $e->[0]; # compare mtime
      }
  
      # read the file, parse, build, cache the entry if necessary, and return
      open my $fh, "<$self->{open_layer}", $filepath
          or croak("failed to open:$filepath:$!");
      my $src = do { local $/; <$fh> };
      close $fh;
      $self->parse($src);
      local $Text::MicroTemplate::_mt_setter = 'my $_mt = shift;';
      my $f = $self->build();
      $self->{cache}->{$file} = [
          $st[9], # mtime
          $f,
      ] if $self->{use_cache};
      return $f;
  }
  
  sub render_file {
      my $self = shift;
      my $file = shift;
      $self->build_file($file)->($self, @_);
  }
  
  sub wrapper_file {
      my $self = shift;
      my $file = shift;
      my @args = @_;
      my $mtref = do {
          no strict 'refs';
          ${"$self->{package_name}::_MTREF"};
      };
      my $before = $$mtref;
      $$mtref = '';
      return sub {
          my $inner_func = shift;
          $inner_func->(@_);
          $$mtref =
              $before . $self->render_file($file, Text::MicroTemplate::encoded_string($$mtref), @args)->as_string;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::MicroTemplate::File - a file-based template manager
  
  =head1 SYNOPSIS
  
      use Text::MicroTemplate::File;
  
      our $mtf = Text::MicroTemplate::File->new(
          include_path => [ $path1, $path2, ... ],
          use_cache    => 1,
      );
  
      # render
      $mtf->render_file('template.file', $arg1, $arg2, ...);
  
  =head1 DESCRIPTION
  
  Text::MicroTemplate::File is a file-based template manager for L<Text::MicroTemplate>.
  
  =head1 PROPERTIES
  
  Text::MicroTemplate provides OO-style interface with following properties.
  
  =head2 include_path
  
  include path (default: ['.'])
  
  This accessor is readonly.
  
  =head2 use_cache
  
  cache mode (0: no cache (default), 1: cache with update check, 2: cache but do not check updates)
  
  =head2 open_layer
  
  layer passed to L<open> (default: ":utf8")
  
  =head2 package_name
  
  package under where template files are compiled (default: "main")
  
  =head1 METHODS
  
  =head2 build_file($file)
  
  Returns a subref that renders given template file.
  
  =head2 render_file($file, @args)
  
  Renders the template file with given arguments.
  
  =head2 wrapper_file($file, @args)->(sub { template lines })
  
  Wraps given template with wrapper file.  Internally the processed template is passed as $_[0] to the wrapper template.
  
  =head1 SEE ALSO
  
  L<Text::MicroTemplate>
  
  =head1 AUTHOR
  
  Kazuho Oku E<lt>kazuhooku gmail.comE<gt>
  
  =head1 LICENSE
  
  This program is free software, you can redistribute it and/or modify it under the same terms as Perl 5.10.
  
  =cut
TEXT_MICROTEMPLATE_FILE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.23-3-g5ee27f1
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.24';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    _subname("${caller}::try {...} " => $try)
      if _HAS_SUBNAME;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::catch {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::finally {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.24
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jonathan Yu Marc Mims Stosberg
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"Types/Serialiser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER';
  =head1 NAME
  
  Types::Serialiser - simple data types for common serialisation formats
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  This module provides some extra datatypes that are used by common
  serialisation formats such as JSON or CBOR. The idea is to have a
  repository of simple/small constants and containers that can be shared by
  different implementations so they become interoperable between each other.
  
  =cut
  
  package Types::Serialiser;
  
  use common::sense; # required to suppress annoying warnings
  
  our $VERSION = '1.0';
  
  =head1 SIMPLE SCALAR CONSTANTS
  
  Simple scalar constants are values that are overloaded to act like simple
  Perl values, but have (class) type to differentiate them from normal Perl
  scalars. This is necessary because these have different representations in
  the serialisation formats.
  
  =head2 BOOLEANS (Types::Serialiser::Boolean class)
  
  This type has only two instances, true and false. A natural representation
  for these in Perl is C<1> and C<0>, but serialisation formats need to be
  able to differentiate between them and mere numbers.
  
  =over 4
  
  =item $Types::Serialiser::true, Types::Serialiser::true
  
  This value represents the "true" value. In most contexts is acts like
  the number C<1>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::true>) or the constant form (C<Types::Serialiser::true>).
  
  The constant is represented as a reference to a scalar containing C<1> -
  implementations are allowed to directly test for this.
  
  =item $Types::Serialiser::false, Types::Serialiser::false
  
  This value represents the "false" value. In most contexts is acts like
  the number C<0>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::false>) or the constant form (C<Types::Serialiser::false>).
  
  The constant is represented as a reference to a scalar containing C<0> -
  implementations are allowed to directly test for this.
  
  =item $is_bool = Types::Serialiser::is_bool $value
  
  Returns true iff the C<$value> is either C<$Types::Serialiser::true> or
  C<$Types::Serialiser::false>.
  
  For example, you could differentiate between a perl true value and a
  C<Types::Serialiser::true> by using this:
  
     $value && Types::Serialiser::is_bool $value
  
  =item $is_true = Types::Serialiser::is_true $value
  
  Returns true iff C<$value> is C<$Types::Serialiser::true>.
  
  =item $is_false = Types::Serialiser::is_false $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::false>.
  
  =back
  
  =head2 ERROR (Types::Serialiser::Error class)
  
  This class has only a single instance, C<error>. It is used to signal
  an encoding or decoding error. In CBOR for example, and object that
  couldn't be encoded will be represented by a CBOR undefined value, which
  is represented by the error value in Perl.
  
  =over 4
  
  =item $Types::Serialiser::error, Types::Serialiser::error
  
  This value represents the "error" value. Accessing values of this type
  will throw an exception.
  
  The constant is represented as a reference to a scalar containing C<undef>
  - implementations are allowed to directly test for this.
  
  =item $is_error = Types::Serialiser::is_error $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::error>.
  
  =back
  
  =cut
  
  BEGIN {
     # for historical reasons, and to avoid extra dependencies in JSON::PP,
     # we alias *Types::Serialiser::Boolean with JSON::PP::Boolean.
     package JSON::PP::Boolean;
  
     *Types::Serialiser::Boolean:: = *JSON::PP::Boolean::;
  }
  
  {
     # this must done before blessing to work around bugs
     # in perl < 5.18 (it seems to be fixed in 5.18).
     package Types::Serialiser::BooleanBase;
  
     use overload
        "0+"     => sub { ${$_[0]} },
        "++"     => sub { $_[0] = ${$_[0]} + 1 },
        "--"     => sub { $_[0] = ${$_[0]} - 1 },
        fallback => 1;
  
     @Types::Serialiser::Boolean::ISA = Types::Serialiser::BooleanBase::;
  }
  
  our $true  = do { bless \(my $dummy = 1), Types::Serialiser::Boolean:: };
  our $false = do { bless \(my $dummy = 0), Types::Serialiser::Boolean:: };
  our $error = do { bless \(my $dummy    ), Types::Serialiser::Error::   };
  
  sub true  () { $true  }
  sub false () { $false }
  sub error () { $error }
  
  sub is_bool  ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_true  ($) {  $_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_false ($) { !$_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_error ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Error::   }
  
  package Types::Serialiser::Error;
  
  sub error {
     require Carp;
     Carp::croak ("caught attempt to use the Types::Serialiser::error value");
  };
  
  use overload
     "0+"     => \&error,
     "++"     => \&error,
     "--"     => \&error,
     fallback => 1;
  
  =head1 NOTES FOR XS USERS
  
  The recommended way to detect whether a scalar is one of these objects
  is to check whether the stash is the C<Types::Serialiser::Boolean> or
  C<Types::Serialiser::Error> stash, and then follow the scalar reference to
  see if it's C<1> (true), C<0> (false) or C<undef> (error).
  
  While it is possible to use an isa test, directly comparing stash pointers
  is faster and guaranteed to work.
  
  For historical reasons, the C<Types::Serialiser::Boolean> stash is
  just an alias for C<JSON::PP::Boolean>. When printed, the classname
  with usually be C<JSON::PP::Boolean>, but isa tests and stash pointer
  comparison will normally work correctly (i.e. Types::Serialiser::true ISA
  JSON::PP::Boolean, but also ISA Types::Serialiser::Boolean).
  
  =head1 A GENERIC OBJECT SERIALIATION PROTOCOL
  
  This section explains the object serialisation protocol used by
  L<CBOR::XS>. It is meant to be generic enough to support any kind of
  generic object serialiser.
  
  This protocol is called "the Types::Serialiser object serialisation
  protocol".
  
  =head2 ENCODING
  
  When the encoder encounters an object that it cannot otherwise encode (for
  example, L<CBOR::XS> can encode a few special types itself, and will first
  attempt to use the special C<TO_CBOR> serialisation protocol), it will
  look up the C<FREEZE> method on the object.
  
  Note that the C<FREEZE> method will normally be called I<during> encoding,
  and I<MUST NOT> change the data structure that is being encoded in any
  way, or it might cause memory corruption or worse.
  
  If it exists, it will call it with two arguments: the object to serialise,
  and a constant string that indicates the name of the data model. For
  example L<CBOR::XS> uses C<CBOR>, and the L<JSON> and L<JSON::XS> modules
  (or any other JSON serialiser), would use C<JSON> as second argument.
  
  The C<FREEZE> method can then return zero or more values to identify the
  object instance. The serialiser is then supposed to encode the class name
  and all of these return values (which must be encodable in the format)
  using the relevant form for Perl objects. In CBOR for example, there is a
  registered tag number for encoded perl objects.
  
  The values that C<FREEZE> returns must be serialisable with the serialiser
  that calls it. Therefore, it is recommended to use simple types such as
  strings and numbers, and maybe array references and hashes (basically, the
  JSON data model). You can always use a more complex format for a specific
  data model by checking the second argument, the data model.
  
  The "data model" is not the same as the "data format" - the data model
  indicates what types and kinds of return values can be returned from
  C<FREEZE>. For example, in C<CBOR> it is permissible to return tagged CBOR
  values, while JSON does not support these at all, so C<JSON> would be a
  valid (but too limited) data model name for C<CBOR::XS>. similarly, a
  serialising format that supports more or less the same data model as JSON
  could use C<JSON> as data model without losing anything.
  
  =head2 DECODING
  
  When the decoder then encounters such an encoded perl object, it should
  look up the C<THAW> method on the stored classname, and invoke it with the
  classname, the constant string to identify the data model/data format, and
  all the return values returned by C<FREEZE>.
  
  =head2 EXAMPLES
  
  See the C<OBJECT SERIALISATION> section in the L<CBOR::XS> manpage for
  more details, an example implementation, and code examples.
  
  Here is an example C<FREEZE>/C<THAW> method pair:
  
     sub My::Object::FREEZE {
        my ($self, $model) = @_;
  
        ($self->{type}, $self->{id}, $self->{variant})
     }
  
     sub My::Object::THAW {
        my ($class, $model, $type, $id, $variant) = @_;
  
        $class->new (type => $type, id => $id, variant => $variant)
     }
  
  =head1 BUGS
  
  The use of L<overload> makes this module much heavier than it should be
  (on my system, this module: 4kB RSS, overload: 260kB RSS).
  
  =head1 SEE ALSO
  
  Currently, L<JSON::XS> and L<CBOR::XS> use these types.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER

$fatpacked{"Types/Serialiser/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER_ERROR';
  =head1 NAME
  
  Types::Serialiser::Error - dummy module for Types::Serialiser
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules that assume that class name equals module name. See
  L<Types::Serialiser> for more info about this class.
  
  =cut
  
  use Types::Serialiser ();
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER_ERROR

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use Moo::_strictures;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  oo - syntactic sugar for Moo oneliners
  
  =head1 SYNOPSIS
  
    perl -Moo=Foo -e 'has bar => ( is => q[ro], default => q[baz] ); print Foo->new->bar'
  
    # loads an existing class and re-"opens" the package definition
    perl -Moo=+My::Class -e 'print __PACKAGE__->new->bar'
  
  =head1 DESCRIPTION
  
  oo.pm is a simple source filter that adds C<package $name; use Moo;> to the
  beginning of your script, intended for use on the command line via the -M
  option.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
OO

$fatpacked{"x86_64-linux/common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.74;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\xc0\x00\x00";
     # use strict, use utf8; use feature;
     $^H |= 0x1c820fc0;
     @^H{qw(feature___SUB__ feature_fc feature_unicode feature_say feature_switch feature_evalbytes feature_state)} = (1) x 7;
  }
  
  1
X86_64-LINUX_COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use Minilla::CLI;

Minilla::CLI->new()->run(@ARGV);

